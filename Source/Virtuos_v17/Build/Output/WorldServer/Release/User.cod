; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.6030 

	TITLE	.\User.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0BC@MOGJFHKK@tr1?3?3bad_weak_ptr?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BL@MCMODJOL@SMMODE?5OVERFLOW?5nType?5?3?5?$CFd?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02DPKJAMEF@?$CFd?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05DNIIFBMG@?$CFs?5?$CFs?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04OEDFLLKD@?$CC?$CFs?$CC?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04EDDHFNCG@PACK?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01DDCIFGEA@E?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07EEDNNGKF@GIFTBOX?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@LOCHAH@GIFTBOX?1?10?1?1?$CFs?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@JEJCJGDO@ITEMCONTAINER?1?11?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01PAPGNFGE@c?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@EMDEHLJF@CreateItem?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@LFPBHGMF@StartCollecting?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@GOPANMLP@StopCollecting?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01KGKMHCOC@e?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@CLPMAOJC@DoUseItemTicket?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01HNPIGOCE@?$CG?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09GKNMOCMA@ANGEL_DIE?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BI@IDEPNPML@p?$CD?5?3?5?$CFd?0?5b?5?3?5?$CFd?0?5t?5?3?5?$CFd?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CC@KGHJJCFM@nItem?5?3?5?$CFd?0?5szName?3?5?$CFs?0?5nNum?5?3?5?$CF@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@JFOKAJOJ@ITEMPROP?1?10?1?1?$CFs?1?1?$CFd?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@CHKPHCIE@ITEMNUM?1?10?1?1?$CFs?1?1?$CFd?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06NDLDHKAP@flaris?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01DCLJPIOD@?$CB?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@LCNGLDCF@?$LD?$KK?$LP?$MA?$LI?i?5?$LO?H?$LF?J?4?4?5?$LN?C?$MA?$PM?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09NNGGDJBM@Not?5Guild?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DJ@NAGLBLJJ@AddNewChatting?5?3?5MAX_ChattingMem@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06EDLOMNPN@?$CFd?7?$CFd?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@MLCPHCKD@U?$DN?$CFd?0?5A?$DN?$CFd?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BO@DPEJLCAF@?4?4?1statistics?$CFY?$CFm?$CFd?$CFH?$CFM?$CFS?4txt?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08DLFHAEOO@NotGuild?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01HIHLOKLC@1?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01FDFGLJHB@2?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EB@EMOECFFH@pItem?5is?5NULL?5in?5SelectAwakening@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DN@GIFNBFBB@Item?5SerialNumber?5is?5different?4?5@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CG@DCOGLGC@This?5item?5have?5not?5new?5random?5op@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BI@JPOENJFP@SELECT?5_AWAKE_OLD_VALUE?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BI@COLBDCPC@SELECT?5_AWAKE_NEW_VALUE?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@DOANKLPK@SELECT?5ERROR?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01GLPGHMHM@z?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@GELFDHNG@CONTAINER?1?10?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
text$yc	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yc	ENDS
CRT$XCA	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCA	ENDS
CRT$XCU	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCU	ENDS
CRT$XCL	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCL	ENDS
CRT$XCC	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCC	ENDS
CRT$XCZ	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCZ	ENDS
text$yd	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yd	ENDS
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
text$AFX_COL1	SEGMENT PARA USE32 PUBLIC ''
text$AFX_COL1	ENDS
;	COMDAT ?GetSizeofMember@CParty@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsMaster@CGuild@@QAEHK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Serialize@CGuildRank@@QAEXAAVCAr@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SelectMemberClear@__GuildCombatMember@CGuildCombat@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetChattingMember@CChatting@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0__MINIGAME_PACKET@@QAE@GHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Serialize@__MINIGAME_PACKET@@UAEXAAVCAr@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Serialize@__MINIGAME_EXT_PACKET@@UAEXAAVCAr@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetApplicantNum@CRainbowRaceMng@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0MINIGMAME_PRIZE_LIST@CRainbowRaceMng@@QAE@KHK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Serialize@HOUSINGINFO@@QAEXAAVCAr@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsMaster@CCampus@@QAEHK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemovePlayerId2CampusId@CCampusMng@@QAEXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetCampus@CCampusHelper@@QAEPAVCCampus@@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetValid@CUser@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetInput@CUser@@QAEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetIncRestPoint@CUser@@QAEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetDecRestPoint@CUser@@QAEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetRestPointTick@CUser@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPacketSize@CBuffer2@@UAEKPAE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetHeader@CBuffer2@@UAEXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCBuffer2@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CBuffer2@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsEmpty@CBufferQueue@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CMapChild@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCMapChild@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$map@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CMapChildE@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCMapChildE@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$map@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetRecvHandle@CDPSock@@QAEPAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Send@CDPMng@@QAEHPAXKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsInstanceDungeon@CInstanceDungeonHelper@@QAEHK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPetItemId@CAIPet@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetExpanedLayer@CTicketProperty@@QAEHK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetMaxBattery@CCollectingProperty@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0__TAXDETAIL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$map@EPAU__TAXDETAIL@@U?$less@E@std@@V?$allocator@U?$pair@$$CBEPAU__TAXDETAIL@@@std@@@3@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?what@bad_weak_ptr@boost@@UBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1sp_counted_base@detail@boost@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@sp_counted_base@detail@boost@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?add_ref_copy@sp_counted_base@detail@boost@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?add_ref_lock@sp_counted_base@detail@boost@@QAE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?release@sp_counted_base@detail@boost@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?weak_add_ref@sp_counted_base@detail@boost@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?weak_release@sp_counted_base@detail@boost@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?use_count@sp_counted_base@detail@boost@@QBEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Gsp_counted_base@detail@boost@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?use_count@shared_count@detail@boost@@QBEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0bad_weak_ptr@boost@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1bad_weak_ptr@boost@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Gbad_weak_ptr@boost@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetCooltime@CLordSkillComponent@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetTick@CLordSkillComponent@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CLordSkillComponentExecutable@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CLordSkillComponentExecutable@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Use@CLordSkillComponentExecutable@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Execute@CLordSkillComponentExecutable@@UAEXKKPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCLordSkillComponentExecutable@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetDeposit@CCandidate@@QBE_JXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetVote@CCandidate@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetCreate@CCandidate@@QAEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CLordSkillComponentItemBuf@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCLordSkillComponentItemBuf@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CLordSkillComponentSummon@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCLordSkillComponentSummon@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CLordSkillComponentTeleport@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCLordSkillComponentTeleport@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetEnvironmentEffect@CEnvironment@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1ITestCase@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GITestCase@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCTestCaseMgr@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CCoupleTestCase@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCCoupleTestCase@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CCouple@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCCouple@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetCouple@CCoupleHelper@@QAEPAVCCouple@@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E1
text$yc	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yc	ENDS
;	COMDAT _$E2
text$yd	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yd	ENDS
;	COMDAT ??0CUser@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCUser@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$map@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CUser@@QAE@KK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CUser@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsValid@CUser@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Init@CUser@@AAEXKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LevelUpSetting@CUser@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ExpUpSetting@CUser@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveItFromView2@CUser@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Open@CUser@@QAEXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Process@CUser@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Notify@CUser@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetAllAction@CUser@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddBlock@CUser@@QAEXPAEK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddHdr@CUser@@QAEXKG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddAddObj@CUser@@QAEXPAVCCtrl@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddText@CUser@@QAEXPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddDiagText@CUser@@QAEXPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddAllAction@CUser@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddReplace@CUser@@QAEXKAAUD3DXVECTOR3@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddCreateItem@CUser@@QAEXPAVCItemBase@@PAEPAFE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddMoveItem@CUser@@QAEXEEE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddTrade@CUser@@QAEXPAV1@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddComfirmTrade@CUser@@QAEXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddComfirmTradeCancel@CUser@@QAEXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddExpBoxCoolTime@CUser@@QAEXKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddCommonSkill@CUser@@QAEXKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddTradePut@CUser@@QAEXKEEEF@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddTradePutError@CUser@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddTradePull@CUser@@QAEXKE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddTradePutGold@CUser@@QAEXKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddTradeCancel@CUser@@QAEXKKH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddOpenShopWnd@CUser@@QAEXPAVCMover@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddUnregisterPVendorItem@CUser@@QAEXE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddRegisterPVendorItem@CUser@@QAEXEEEFH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddPVendorClose@CUser@@QAEXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddPVendorItem@CUser@@QAEXPAV1@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddPutItemGuildBank@CUser@@QAEXPAVCItemElem@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddGetItemGuildBank@CUser@@QAEXPAVCItemElem@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddGetGoldGuildBank@CUser@@QAEXKEKE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddPutItemBank@CUser@@QAEXEPAVCItemElem@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddGetItemBank@CUser@@QAEXPAVCItemElem@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddPutGoldBank@CUser@@QAEXEKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddMoveBankItem@CUser@@QAEXEE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddBankIsFull@CUser@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddRemoveSkillInfluence@CUser@@QAEXGG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddBankWindow@CUser@@QAEXHKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddGuildBankWindow@CUser@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddChangeBankPass@CUser@@QAEXHKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddconfirmBankPass@CUser@@QAEXHKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddUpdateItemEx@CUser@@QAEXED_J@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddUpdateItem@CUser@@QAEXDEDKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddUpdateBankItem@CUser@@QAEXEEDK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddSetExperience@CUser@@QAEX_JGHH0G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddSetFxp@CUser@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddSetGrowthLearningPoint@CUser@@QAEXJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddSetStatLevel@CUser@@QAEXDJJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddSetChangeJob@CUser@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddReturnSay@CUser@@QAEXHPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddGameTimer@CUser@@QAEXN@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddDoEquip@CUser@@QAEXEKE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddTaskBar@CUser@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddSendErrorParty@CUser@@QAEXKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddSetPartyMemberParam@CUser@@QAEXKEH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddPartyMember@CUser@@QAEXPAVCParty@@KPBD1@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddPartyExpLevel@CUser@@QAEXHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddSetPartyMode@CUser@@QAEXHHJK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddPartyChangeItemMode@CUser@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddPartyChangeExpMode@CUser@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddPartyChangeName@CUser@@QAEXPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddPartyChangeTroup@CUser@@QAEXPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddPartyRequest@CUser@@QAEXPAV1@0H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddPartyRequestCancel@CUser@@QAEXKKH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddPartyName@CUser@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddPartySkillCall@CUser@@QAEXABUD3DXVECTOR3@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddPartySkillBlitz@CUser@@QAEXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddFriendGameJoin@CUser@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddPartyChangeLeader@CUser@@QAEXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddCancelQuest@CUser@@QAEXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddRemoveQuest@CUser@@QAEXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddRemoveAllQuest@CUser@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddRemoveCompleteQuest@CUser@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ADDGameJoin@CUser@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddFriendReqest@CUser@@QAEXKJEPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddFriendCancel@CUser@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddFriendError@CUser@@QAEXEPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddEnvironmentSetting@CUser@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddEnvironment@CUser@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddPartyChat@CUser@@QAEXPBD0K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddAddFriend@CUser@@QAEXKPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddRemoveFriend@CUser@@QAEXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddDuelRequest@CUser@@QAEXKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddDuelStart@CUser@@QAEXKH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddDuelCount@CUser@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddDuelNo@CUser@@QAEXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddDuelCancel@CUser@@QAEXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddDuelPartyRequest@CUser@@QAEXKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddDuelPartyStart@CUser@@QAEXPBDHPAKKH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddDuelPartyNo@CUser@@QAEXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddDuelPartyCancel@CUser@@QAEXPAVCParty@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddDuelPartyResult@CUser@@QAEXPAVCParty@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddQueryPlayerData@CUser@@QAEXKPAU_PlayerData@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddPlayerData@CUser@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddGuildInvite@CUser@@QAEXKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddAllGuilds@CUser@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddMyGuild@CUser@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddMyGuildWar@CUser@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddContribution@CUser@@QAEXAAUCONTRIBUTION_CHANGED_INFO@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddInsertedVote@CUser@@QAEXAAUVOTE_INSERTED_INFO@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddModifyVote@CUser@@QAEXKEE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddSetNotice@CUser@@QAEXKPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddSetGuildAuthority@CUser@@QAEXQAK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddSetGuildPenya@CUser@@QAEXKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddGuildRealPenya@CUser@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SendGuildRank@CUser@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SendPartyList@CUser@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddSMMode@CUser@@QAEXHK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddSMModeAll@CUser@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddResistSMMode@CUser@@QAEXEEE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddCommercialElem@CUser@@QAEXKH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddFlyffEvent@CUser@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddEventLuaDesc@CUser@@QAEXHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddGoldText@CUser@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddRemoveGuildBankItem@CUser@@QAEXKKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddDefinedText@CUser@@QAAXHPBDZZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddChatText@CUser@@QAAXHPBDZZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddDefinedText@CUser@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddExpBoxInfo@CUser@@QAEXKKKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddDefinedCaption@CUser@@QAAXHHPBDZZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddSetGuildQuest@CUser@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddRemoveGuildQuest@CUser@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddSetQuest@CUser@@QAEXPAUtagQuest@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddQueryGetDestObj@CUser@@QAEXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddGetDestObj@CUser@@QAEXKKM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddQueryGetPos@CUser@@QAEXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddGetPos@CUser@@QAEXKABUD3DXVECTOR3@@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddResurrectionMessage@CUser@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddCorrReq@CUser@@QAEXPAVCMover@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddSetFuel@CUser@@QAEXHK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddSetState@CUser@@QAEXJJJJJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddSetSkill@CUser@@QAEXKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddMotionError@CUser@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddTag@CUser@@QAEXFPBUTAG_ENTRY@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddSetSkillState@CUser@@QAEXPAVCMover@@KKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddPlayMusic@CUser@@QAEXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddPlaySound@CUser@@QAEXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddPlaySound2@CUser@@QAEXPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddMoverFocus@CUser@@QAEXPAVCMover@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddPartyMapInfo@CUser@@QAEXHUD3DXVECTOR3@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddSetNaviPoint@CUser@@QAEXABUNaviPoint@@KPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddSetDuel@CUser@@QAEXPAVCMover@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddPKValue@CUser@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ScheduleDestory@CUser@@QAEXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddSnoop@CUser@@QAEXPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddSetCheerParam@CUser@@QAEXHKH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddQueryEquip@CUser@@QAEXPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddSummonFriendUse@CUser@@QAEXPAVCItemElem@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddSummonFriendConfirm@CUser@@QAEXKKPBD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddSummonPartyConfirm@CUser@@QAEXKKPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetReturnPos@CUser@@QAEXABUD3DXVECTOR3@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetReturnPos@CUser@@QAEAAUD3DXVECTOR3@@PAK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DoUsePackItem@CUser@@QAEXPAVCItemElem@@PAU_PACKITEMELEM@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DoUseGiftbox@CUser@@QAEHPAVCItemElem@@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DoUseEveFBOX@CUser@@QAEXPAVCItemElem@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsUsableState@CUser@@QAEHK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnDoUseItem@CUser@@QAEXKKH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddPetState@CUser@@QAEXKGGK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddPetSetExp@CUser@@QAEXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddPet@CUser@@QAEXPAVCPet@@E@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddPetFoodMill@CUser@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ProcessCollecting@CUser@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddRestartCollecting@CUser@@QAEXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StartCollecting@CUser@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StopCollecting@CUser@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DoUseItemBattery@CUser@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FindActiveTicket@CUser@@AAEPAVCItemElem@@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DoUseItemTicket@CUser@@QAEXPAVCItemElem@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddGC1to1TenderOpenWnd@CUser@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddGC1to1TenderGuildView@CUser@@QAEXHHJAAV?$vector@U__GC1TO1TENDER@CGuildCombat1to1Mng@@V?$allocator@U__GC1TO1TENDER@CGuildCombat1to1Mng@@@std@@@std@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddGC1to1NowState@CUser@@QAEXHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddGC1to1MemberLineUpOpenWnd@CUser@@QAEXAAV?$vector@KV?$allocator@K@std@@@std@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddGC1to1WarResult@CUser@@QAEXHKHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveAngel@CUser@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddPocketAttribute@CUser@@QAEXHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddPocketView@CUser@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddPocketAddItem@CUser@@QAEXHPAVCItemElem@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddPocketRemoveItem@CUser@@QAEXHHF@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddQuePetResurrectionResult@CUser@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ValidateItem@CUser@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AdjustGuildQuest@CUser@@QAEXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AdjustMailboxState@CUser@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddEventLuaDesc@CUser@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AdjustPartyQuest@CUser@@QAEXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddCouple@CUser@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddProposeResult@CUser@@QAEXKPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddCoupleResult@CUser@@QAEXKPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddDecoupleResult@CUser@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ProcessCouple@CUser@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ActiveCoupleBuff@CUser@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddAddCoupleExperience@CUser@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CUserMng@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCUserMng@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$map@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CUserMng@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveAllUsers@CUserMng@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddUser@CUserMng@@QAEPAVCUser@@KKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveUser@CUserMng@@QAEXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveUserFromCacheMsg@CUserMng@@AAEXPAVCUser@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetUser@CUserMng@@QAEPAVCUser@@KK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetUserByPlayerID@CUserMng@@QAEPAVCUser@@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddPlayer@CUserMng@@QAEHPAVCUser@@KH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DestroyPlayer@CUserMng@@QAEXPAVCUser@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ModifyMode@CUserMng@@QAEXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddEventMessage@CUserMng@@QAEXPAVCCtrl@@PBDHK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddDlgEmoticon@CUserMng@@QAEXPAVCCtrl@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddStartCollecting@CUserMng@@QAEXPAVCUser@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddStopCollecting@CUserMng@@QAEXPAVCUser@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddChat@CUserMng@@QAEXPAVCCtrl@@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddDefinedText@CUserMng@@QAAXPAVCMover@@HPBDZZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddShipActMsg@CUserMng@@QAEXPAVCMover@@PAVCShip@@KHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddMotion@CUserMng@@QAEXPAVCMover@@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddRemoveAllSkillInfluence@CUserMng@@QAEXPAVCMover@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddWorldShout@CUserMng@@QAEXPBD0UD3DXVECTOR3@@PAVCWorld@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddDamage@CUserMng@@QAEXPAVCMover@@KKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddDisguise@CUserMng@@QAEXPAVCMover@@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddNoDisguise@CUserMng@@QAEXPAVCMover@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddSetStateLevel@CUserMng@@QAEXPAVCMover@@DJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddMoverDeath@CUserMng@@QAEXPAVCMover@@0K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddUseSkill@CUserMng@@QAEXPAVCMover@@KKKHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddDoEquip@CUserMng@@QAEXPAVCMover@@HEABU_EQUIP_INFO@@E@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddDoEquip@CUserMng@@QAEXPAVCMover@@HPAVCItemElem@@E@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddVendor@CUserMng@@QAEXPAVCMover@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddUpdateVendor@CUserMng@@QAEXPAVCMover@@DEF@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddSetDestParam@CUserMng@@QAEXPAVCMover@@HHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddResetDestParam@CUserMng@@QAEXPAVCMover@@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddResetDestParamSync@CUserMng@@QAEXPAVCMover@@HHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddSetPointParam@CUserMng@@QAEXPAVCMover@@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddSetPos@CUserMng@@QAEXPAVCCtrl@@AAUD3DXVECTOR3@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddSetLevel@CUserMng@@QAEXPAVCMover@@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddSetFlightLevel@CUserMng@@QAEXPAVCMover@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddSetSkillLevel@CUserMng@@QAEXPAVCMover@@KK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddSetDestPos@CUserMng@@QAEXPAVCMover@@ABUD3DXVECTOR3@@E@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddSetMovePattern@CUserMng@@QAEXPAVCMover@@HABUD3DXVECTOR3@@MM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddSetDestAngle@CUserMng@@QAEXPAVCMover@@ME@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddMoverSetDestObj@CUserMng@@QAEXPAVCMover@@KMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddMeleeAttack@CUserMng@@QAEXPAVCMover@@KKHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddMeleeAttack2@CUserMng@@QAEXPAVCMover@@KKHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddMagicAttack@CUserMng@@QAEXPAVCMover@@KKHHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddRangeAttack@CUserMng@@QAEXPAVCMover@@KKHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddAttackSP@CUserMng@@QAEXPAVCMover@@KKHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddMoverMoved@CUserMng@@QAEXPAVCMover@@AAUD3DXVECTOR3@@1MKKKHHK_J@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddMoverBehavior@CUserMng@@QAEXPAVCMover@@AAUD3DXVECTOR3@@1MKKKHHK_JH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddMoverMoved2@CUserMng@@QAEXPAVCMover@@AAUD3DXVECTOR3@@1MMMMKKKHHK_JE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddMoverBehavior2@CUserMng@@QAEXPAVCMover@@AAUD3DXVECTOR3@@1MMMMKKKHHK_JH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddMoverAngle@CUserMng@@QAEXPAVCMover@@AAUD3DXVECTOR3@@1MMMM_J@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddMoverCorr@CUserMng@@QAEXPAVCMover@@AAUD3DXVECTOR3@@1MKKKHHK_J@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddMoverCorr2@CUserMng@@QAEXPAVCMover@@AAUD3DXVECTOR3@@1MMMMKKKHHK_J@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddCreateSfxObj@CUserMng@@QAEXPAVCCtrl@@KMMMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddRemoveSfxObj@CUserMng@@QAEXPAVCCtrl@@KMMMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddMotionArrive@CUserMng@@QAEXPAVCMover@@W4OBJMSG@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddPKPink@CUserMng@@QAEXPAVCMover@@E@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddPKPropensity@CUserMng@@QAEXPAVCMover@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddWorldCreateSfxObj@CUserMng@@QAEXKMMMHK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddCreateSfxAllow@CUserMng@@QAEXPAVCMover@@KKUD3DXVECTOR3@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddNearSetChangeJob@CUserMng@@QAEXPAVCMover@@HPAUtagSkill@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddModifyMode@CUserMng@@QAEXPAVCUser@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddStateMode@CUserMng@@QAEXPAVCUser@@E@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddSetFame@CUserMng@@QAEXPAVCMover@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddSetLocalEvent@CUserMng@@QAEXFE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddGameRate@CUserMng@@QAEXME@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddChangeFace@CUserMng@@QAEXKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddSchoolReport@CUserMng@@QAEXPAU_SCHOOL_ENTRY@@F@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddSexChange@CUserMng@@QAEXPAVCMover@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddCreateGuild@CUserMng@@QAEXKPBDK0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddDestroyGuild@CUserMng@@QAEXPBDK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddSetGuild@CUserMng@@QAEXPAVCUser@@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddSetWar@CUserMng@@QAEXPAVCUser@@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddSetLogo@CUserMng@@QAEXKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddGetItemElem@CUserMng@@QAEXPAVCUser@@PAVCItemElem@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddPutItemElem@CUserMng@@QAEXPAVCUser@@PAVCItemElem@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddPutItemElem@CUserMng@@QAEXKPAVCItemElem@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddPVendorOpen@CUserMng@@QAEXPAVCUser@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddPVendorClose@CUserMng@@QAEXPAVCUser@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddPVendorItemNum@CUserMng@@QAEXPAVCUser@@EFPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddSetHair@CUserMng@@QAEXPAVCUser@@EEEE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddHdr@CUserMng@@QAEXPAVCCtrl@@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddBlock@CUserMng@@QAEXPAEK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddBlock@CUserMng@@QAEXPAEKPAVCWorld@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddBlockNoLock@CUserMng@@QAEXPAEK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddBlockNoLock@CUserMng@@QAEXPAEKPAVCWorld@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddBlock@CUserMng@@QAEXPAVCWorld@@ABUD3DXVECTOR3@@HPAEK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddGameSetting@CUserMng@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddShout@CUserMng@@QAEXPAVCUser@@HPAEK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddWorldMsg@CUserMng@@QAEXPBVCRect@@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddSetScale@CUserMng@@QAEXPAVCMover@@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddSetSkillState@CUserMng@@QAEXPAVCMover@@0GGKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddMonsterProp@CUserMng@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddGMChat@CUserMng@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddGuildCombatUserState@CUserMng@@QAEXPAVCMover@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddGCWinGuild@CUserMng@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddGCBestPlayer@CUserMng@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddGuildCombatState@CUserMng@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddGuildCombatNextTimeWorld@CUserMng@@QAEXKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddGuildCombatEnterTime@CUserMng@@QAEXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddGCWarPlayerlist@CUserMng@@QAEXKPAVCUser@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddGCLogWorld@CUserMng@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddGCLogRealTimeWorld@CUserMng@@QAEXU__GCGETPOINT@CGuildCombat@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ReplaceWorld@CUserMng@@QAEXKKMMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ReplaceWorldArea@CUserMng@@QAEXKKKMMMHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddWorldMsg@CUserMng@@QAEXKPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddGuildMsg@CUserMng@@QAEXKPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddGuildMsg@CUserMng@@QAEXPAVCGuild@@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddGCIsRequest@CUserMng@@QAEXKH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddGCGuildStatus@CUserMng@@QAEXKPAVCUser@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddGCGuildPrecedence@CUserMng@@QAEXPAVCUser@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddGCPlayerPrecedence@CUserMng@@QAEXPAVCUser@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddRunScriptFunc@CUser@@QAEXABU_runscriptfunc@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddEnterChatting@CUser@@QAEXPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddNewChatting@CUser@@QAEXPAVCChatting@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddAngelInfo@CUser@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddRemoveChatting@CUser@@QAEXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddDeleteChatting@CUser@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddChatting@CUser@@QAEXKPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddChttingRoomState@CUser@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddGameRate@CUser@@QAEXME@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddGameSetting@CUser@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddMonsterProp@CUser@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddInitSkill@CUser@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddDoUseSkillPoint@CUser@@QAEXQAUtagSkill@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddWantedInfo@CUser@@QAEXABUD3DXVECTOR3@@EKPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddCommonPlace@CUserMng@@QAEXPAVCCtrl@@E@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddReturnScroll@CUser@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OutputStatistics@CUserMng@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddPostMail@CUser@@QAEXPAVCMail@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddRemoveMail@CUser@@QAEXKH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddMailBox@CUser@@QAEXPAVCMailBox@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SendCheckMailBoxReq@CUser@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CheckTransMailBox@CUser@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetCheckTransMailBox@CUser@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CheckClientReq@CUser@@QAE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ResetCheckClientReq@CUser@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetCountClientReq@CUser@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddGCWindow@CUser@@QAEX_JKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddGCRequestStatus@CUser@@QAEX_JV?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddGCSelectPlayerWindow@CUser@@QAEXAAV?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@KHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddGCJoinWarWindow@CUser@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddGCWinGuild@CUser@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddGCBestPlayer@CUser@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddGCIsRequest@CUser@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddGCGetPenyaGuild@CUser@@QAEXH_J@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddGCGetPenyaPlayer@CUser@@QAEXH_J@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddGCDiagMessage@CUser@@QAEXPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddGCTele@CUser@@QAEXPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddGuildCombatNextTime@CUser@@QAEXKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddGuildCombatEnterTime@CUser@@QAEXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddGCWarPlayerlist@CUser@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddCtrlCoolTimeCancel@CUser@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddGuildCombatState@CUser@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddGCLog@CUser@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddGCPlayerPoint@CUser@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddQuestTextTime@CUser@@QAEXHHK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddFocusObj@CUser@@QAEXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnMsgArrival@CUser@@QAEXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CheckFiniteItem@CUser@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DoSMItemEquip@CUser@@QAEXPAVCItemElem@@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DoSMItemUnEquip@CUser@@QAEXPAVCItemElem@@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddAddRegion@CUserMng@@QAEXKAAUREGIONELEM@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetEventFlagBit@CUser@@QAE_JH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetEventFlagBit@CUser@@QAEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddCallTheRoll@CUser@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0__ITEMINFO@@QAE@KHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CallTheRoll@CUserMng@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddKawibawiboResult@CUser@@QAEXHHKHKH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddReassembleOpenWnd@CUser@@QAEXV?$vector@KV?$allocator@K@std@@@std@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddReassembleResult@CUser@@QAEXKH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddAlphabetOpenWnd@CUser@@QAEXHHDV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddAlphabetResult@CUser@@QAEXHKH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddFiveSystemOpenWnd@CUser@@QAEXHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddFiveSystemResult@CUser@@QAEXHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddUltimateMakeItem@CUser@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddUltimateMakeGem@CUser@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddUltimateWeapon@CUser@@QAEXEH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddExchangeResult@CUser@@QAEXEH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddRemoveAttribute@CUser@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddSetPetName@CUserMng@@QAEXPAVCUser@@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddPetCall@CUserMng@@QAEXPAVCMover@@KKEPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddPetRelease@CUserMng@@QAEXPAVCMover@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddPetLevelup@CUserMng@@QAEXPAVCMover@@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddPetFeed@CUserMng@@QAEXPAVCMover@@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddHonorTitleChange@CUserMng@@QAEXPAVCMover@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddSetSpeedFactor@CUserMng@@QAEXPAVCMover@@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddLegendSkillResult@CUser@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddEventLua@CUserMng@@QAEXEH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddGuildBankLogView@CUser@@QAEXEFPBU__GUILDBANKLOG_ENTRY@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddHonorListAck@CUser@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddSealChar@CUser@@QAEXFPBU__SEALCHAR_ENTRY@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddSealCharSet@CUser@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddCoupon@CUser@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddSecretRoomMngState@CUser@@QAEXHK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddSecretRoomContInfo@CUser@@QAEXEEAAV?$vector@U__SECRETROOM_TENDER@@V?$allocator@U__SECRETROOM_TENDER@@@std@@@std@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddSecretRoomTenderOpenWnd@CUser@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddSecretRoomLineUpOpenWnd@CUser@@QAEXAAV?$vector@KV?$allocator@K@std@@@std@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddSecretRoomTenderView@CUser@@QAEXHHJAAV?$vector@U__SECRETROOM_TENDER@@V?$allocator@U__SECRETROOM_TENDER@@@std@@@std@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddLord@CUser@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetMuteText@CUser@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddLordSkillTick@CUser@@QAEXPAVCLordSkill@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsTeleportable@CUser@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddSetTutorialState@CUser@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddElectionBeginCandidacy@CUserMng@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddElectionBeginVote@CUserMng@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddElectionEndVote@CUserMng@@QAEXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddElectionAddDeposit@CUserMng@@QAEXK_JJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddElectionSetPledge@CUserMng@@QAEXKPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddElectionIncVote@CUserMng@@QAEXKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddLEventCreate@CUserMng@@QAEXPAVCLEComponent@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddLEventInitialize@CUserMng@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddLEventTick@CUserMng@@QAEXPAVILordEvent@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddLordSkillUse@CUserMng@@QAEXPAVCUser@@KH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddQueryPlayerData@CUserMng@@QAEXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddTaxInfo@CUser@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddTaxSetTaxRateOpenWnd@CUser@@QAEXE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddTaxInfo@CUserMng@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddRainbowRacePrevRankingOpenWnd@CUser@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddRainbowRaceApplicationOpenWnd@CUser@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddRainbowRaceState@CUser@@QAEXPAVCRainbowRace@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddMiniGameState@CUser@@QAEXU__MINIGAME_PACKET@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddMiniGameExtState@CUser@@QAEXU__MINIGAME_EXT_PACKET@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1__MINIGAME_EXT_PACKET@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddHousingAllInfo@CUser@@QAEXPAVCHousing@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddHousingSetFurnitureList@CUser@@QAEXAAUHOUSINGINFO@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddHousingSetupFurniture@CUser@@QAEXPAUHOUSINGINFO@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddHousingPaperingInfo@CUser@@QAEXKH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddHousingPaperingInfo@CUserMng@@QAEXKHK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddHousingSetVisitAllow@CUser@@QAEXKH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddHousingVisitableList@CUser@@QAEXAAV?$vector@KV?$allocator@K@std@@@std@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddNPCPos@CUser@@QAEXABUD3DXVECTOR3@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddClearTarget@CUser@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsGuildMaster@CUser@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DoUseItemInput@CUser@@QAEHPAUItemProp@@PAVCItemElem@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DoUseItemPetNaming@CUser@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddPCBangInfo@CUser@@QAEXPAVCPCBangInfo@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddSmeltSafety@CUser@@QAEXE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddWorldReadInfo@CUser@@QAEXKUD3DXVECTOR3@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddQuizEventState@CUser@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddQuizEventMessage@CUser@@QAEXPBDH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddQuizQuestion@CUser@@QAEXHPBDH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddActivateVisPet@CUser@@QAEXKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddChangeMoverSfxId@CUserMng@@QAEXPAVCMover@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddGuildHousePakcet@CUser@@QAEXHAAUGuildHouse_Furniture_Info@CGuildHouseBase@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddGuildHouseAllInfo@CUser@@QAEXPAVCGuildHouseBase@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddGuildHouseRemvoe@CUser@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAddExpAfterApplyRestPoint@CUser@@QAE_J_J@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetAddRestPoint@CUser@@AAEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddRestPoint@CUser@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?HasUserSameWorldnLayer@CUserMng@@QAEHPAVCUser@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddCheckedQuest@CUser@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddInviteCampusMember@CUser@@QAEXPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddUpdateCampus@CUser@@QAEXPAVCCampus@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddRemoveCampus@CUser@@QAEXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddUpdateCampusPoint@CUser@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ProcessCampus@CUser@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ActiveCampusBuff@CUser@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPointByType@CUser@@QAEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SelectAwakeningValue@CUser@@QAEXKKE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SendNewRandomOption@CUser@@QAEXEK_J@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SendColosseumEnter@CUser@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SendColosseumStart@CUser@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SendColosseumReady1@CUser@@QAEXHE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SendColosseumReady2@CUser@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SendColosseumEndMatch@CUser@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddActivateBarunaPet@CUser@@QAEXKKH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SendTreasure@CUser@@QAEXQAUTreasureItem@@QAH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$CSimpleStringT@D$0A@@ATL@@QBEDH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHABV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$map@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?find@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Citerator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QBEPAU?$pair@$$CBKPAVCUser@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsFull@?$CStack@K@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$map@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$map@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@@std@@QAEAAPAVCCtrl@@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$pair@KPAVCCtrl@@@std@@QAE@ABKABQAVCCtrl@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$vector@KV?$allocator@K@std@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$vector@KV?$allocator@K@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$vector@KV?$allocator@K@std@@@std@@QAEAAKI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?push_back@?$vector@KV?$allocator@K@std@@@std@@QAEXABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$vector@EV?$allocator@E@std@@@std@@QAEAAEI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetSize@?$CItemContainer@VCItemElem@@@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetMax@?$CItemContainer@VCItemElem@@@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetEmptyCount@?$CItemContainer@VCItemElem@@@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$deque@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$deque@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$deque@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$deque@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?empty@?$deque@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?clear@?$deque@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$deque@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$deque@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$deque@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$deque@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?empty@?$deque@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?clear@?$deque@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$vector@VCGuildCombat1to1@@V?$allocator@VCGuildCombat1to1@@@std@@@std@@QAEAAVCGuildCombat1to1@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$vector@U__GC1TO1TENDER@CGuildCombat1to1Mng@@V?$allocator@U__GC1TO1TENDER@CGuildCombat1to1Mng@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$vector@U__GC1TO1TENDER@CGuildCombat1to1Mng@@V?$allocator@U__GC1TO1TENDER@CGuildCombat1to1Mng@@@std@@@std@@QAEAAU__GC1TO1TENDER@CGuildCombat1to1Mng@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Citerator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBEPAU?$pair@$$CBHH@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$deque@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@QBEAAPAUtagACTMSG@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$deque@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$deque@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$deque@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@QBEAAPAUtagMAGICATKMSG@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$deque@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$deque@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QAEIABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Citerator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QBEPAU?$pair@$$CBKU_Friend@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$_Tree@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAEAAPAU__JOINPLAYER@CGuildCombat@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?clear@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?push_front@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAEXABQAU__JOINPLAYER@CGuildCombat@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?push_back@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAEXABQAU__JOINPLAYER@CGuildCombat@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?clear@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@QAEAAU__GCGETPOINT@CGuildCombat@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@QAEAAU__GCPLAYERPOINT@CGuildCombat@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QAEAAPAU__GuildCombatMember@CGuildCombat@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QAEAAU__REQUESTGUILD@CGuildCombat@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$_Tree@V?$_Tmap_traits@KPAU_PlayerData@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAU_PlayerData@@@std@@@3@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$vector@U__SECRETROOM_MONSTER@@V?$allocator@U__SECRETROOM_MONSTER@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$vector@U__SECRETROOM_MONSTER@@V?$allocator@U__SECRETROOM_MONSTER@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$vector@U__SECRETROOM_TENDER@@V?$allocator@U__SECRETROOM_TENDER@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$vector@U__SECRETROOM_TENDER@@V?$allocator@U__SECRETROOM_TENDER@@@std@@@std@@QAEAAU__SECRETROOM_TENDER@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?clear@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?push_back@?$vector@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@V?$allocator@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@std@@@std@@QAEXABUMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$_Tree@V?$_Tmap_traits@KPAVCRainbowRace@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCRainbowRace@@@std@@@3@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$vector@PAVCMiniGameBase@@V?$allocator@PAVCMiniGameBase@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$vector@PAVCMiniGameBase@@V?$allocator@PAVCMiniGameBase@@@std@@@std@@QAEAAPAVCMiniGameBase@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$vector@MV?$allocator@M@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$vector@MV?$allocator@M@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$vector@UGuildHouse_Furniture_Info@CGuildHouseBase@@V?$allocator@UGuildHouse_Furniture_Info@CGuildHouseBase@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$vector@UGuildHouse_Furniture_Info@CGuildHouseBase@@V?$allocator@UGuildHouse_Furniture_Info@CGuildHouseBase@@@std@@@std@@QAEAAUGuildHouse_Furniture_Info@CGuildHouseBase@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?empty@?$_Tree@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?insert@?$_Tree@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBKPAVCGuildHouseBase@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$_Tree@V?$_Tmap_traits@KPAVCCampusMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCampusMember@@@std@@@3@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?empty@?$_Tree@V?$_Tmap_traits@KPAVCCampus@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCampus@@@std@@@3@$0A@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@QAEIABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$map@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?find@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Citerator@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@QBEPAU?$pair@$$CBKPAVCClientSock@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$map@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?find@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Citerator@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@QBEPAU?$pair@$$CBKPAVCClientSockE@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@KP8CDPDatabaseClient@@AEXAAVCAr@@KK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?find@?$_Tree@V?$_Tmap_traits@KP8CDPDatabaseClient@@AEXAAVCAr@@KK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Citerator@?$_Tree@V?$_Tmap_traits@KP8CDPDatabaseClient@@AEXAAVCAr@@KK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@std@@@4@$0A@@std@@@std@@QBEPAU?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@KP8CDPDatabaseClient@@AEXAAVCAr@@KK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@std@@@4@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@KP8CDPCoreClient@@AEXAAVCAr@@KKK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?find@?$_Tree@V?$_Tmap_traits@KP8CDPCoreClient@@AEXAAVCAr@@KKK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Citerator@?$_Tree@V?$_Tmap_traits@KP8CDPCoreClient@@AEXAAVCAr@@KKK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@std@@@4@$0A@@std@@@std@@QBEPAU?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@KP8CDPCoreClient@@AEXAAVCAr@@KKK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@std@@@4@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@KP8CDPSrvr@@AEXAAVCAr@@KKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?find@?$_Tree@V?$_Tmap_traits@KP8CDPSrvr@@AEXAAVCAr@@KKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Citerator@?$_Tree@V?$_Tmap_traits@KP8CDPSrvr@@AEXAAVCAr@@KKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@std@@@4@$0A@@std@@@std@@QBEPAU?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@KP8CDPSrvr@@AEXAAVCAr@@KKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@std@@@4@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$map@EPAU__TAXDETAIL@@U?$less@E@std@@V?$allocator@U?$pair@$$CBEPAU__TAXDETAIL@@@std@@@3@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$_Tree@V?$_Tmap_traits@EPAU__TAXDETAIL@@U?$less@E@std@@V?$allocator@U?$pair@$$CBEPAU__TAXDETAIL@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?insert@?$_Tree@V?$_Tmap_traits@EPAU__TAXDETAIL@@U?$less@E@std@@V?$allocator@U?$pair@$$CBEPAU__TAXDETAIL@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@EPAU__TAXDETAIL@@U?$less@E@std@@V?$allocator@U?$pair@$$CBEPAU__TAXDETAIL@@@std@@@3@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBEPAU__TAXDETAIL@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??R?$less@PAVsp_counted_base@detail@boost@@@std@@QBE_NABQAVsp_counted_base@detail@boost@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$vector@PAVCLordSkillComponentExecutable@@V?$allocator@PAVCLordSkillComponentExecutable@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$vector@V?$shared_ptr@VCCandidate@@@boost@@V?$allocator@V?$shared_ptr@VCCandidate@@@boost@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??C?$shared_ptr@VCCandidate@@@boost@@QBEPAVCCandidate@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$vector@PAVCLEComponent@@V?$allocator@PAVCLEComponent@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$vector@U?$pair@M_J@std@@V?$allocator@U?$pair@M_J@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$_Tree@V?$_Tmap_traits@HU__ATTRIBUTE_ENCHANT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU__ATTRIBUTE_ENCHANT@@@std@@@3@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$_Tree@V?$_Tmap_traits@KPAVCGuildWar@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildWar@@@std@@@3@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$vector@PAVITestCase@@V?$allocator@PAVITestCase@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$vector@PAVITestCase@@V?$allocator@PAVITestCase@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$vector@PAVCCouple@@V?$allocator@PAVCCouple@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Citerator@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@QBEPAU?$pair@$$CBKPAVCGuildMember@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Citerator@?$_Tree@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@std@@QBEPAU?$pair@$$CBKPAVCParty@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEAAPAU__JOINPLAYER@CGuildCombat@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@QAEAAU__JOINPLAYER@CGuildCombat@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?push_back@?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@QAEXABQAVCUser@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?clear@?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@QBEAAPAVCUser@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@QAEAAU__ITEMINFO@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?push_back@?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@QAEXABU__ITEMINFO@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHIIPBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@K@1@ABV?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@K@1@ABV?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?insert@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@ABU?$pair@$$CBKPAVCCtrl@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$pair@$$CBKPAVCCtrl@@@std@@QAE@ABKABQAVCCtrl@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@KV?$allocator@K@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$vector@KV?$allocator@K@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$vector@KV?$allocator@K@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?insert@?$vector@KV?$allocator@K@std@@@std@@QAE?AViterator@12@V312@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?clear@?$vector@KV?$allocator@K@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ufill@?$vector@KV?$allocator@K@std@@@std@@IAEPAKPAKIABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?get_allocator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBE?AV?$allocator@U?$pair@$$CBHH@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?key_comp@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBE?AU?$less@H@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXABV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Init@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$vector@EV?$allocator@E@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??R?$less@E@std@@QBE_NABE0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$deque@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Deque_val@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@IAE@V?$allocator@PAUtagACTMSG@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@PAUtagACTMSG@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$deque@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Deque_val@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@IAE@V?$allocator@PAUtagMAGICATKMSG@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@PAUtagMAGICATKMSG@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$vector@VCGuildCombat1to1@@V?$allocator@VCGuildCombat1to1@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$vector@U__GC1TO1TENDER@CGuildCombat1to1Mng@@V?$allocator@U__GC1TO1TENDER@CGuildCombat1to1Mng@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBEAAU?$pair@$$CBHH@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$deque@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@QAE@IPBV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$deque@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@QBEABQAUtagACTMSG@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$deque@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$deque@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@QAE@IPBV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$deque@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@QBEABQAUtagMAGICATKMSG@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$deque@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lmost@?$_Tree@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?equal_range@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@V123@@2@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lmost@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QBEAAU?$pair@$$CBKU_Friend@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lmost@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Nextnode@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Prevnode@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Insert@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAEXViterator@12@ABQAU__JOINPLAYER@CGuildCombat@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Buynode@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAEPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_List_val@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAE@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@U_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@U_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Buy@?$vector@U__SECRETROOM_MONSTER@@V?$allocator@U__SECRETROOM_MONSTER@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@U__SECRETROOM_MONSTER@@V?$allocator@U__SECRETROOM_MONSTER@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Vector_val@U__SECRETROOM_MONSTER@@V?$allocator@U__SECRETROOM_MONSTER@@@std@@@std@@IAE@V?$allocator@U__SECRETROOM_MONSTER@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@U__SECRETROOM_MONSTER@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$vector@U__SECRETROOM_TENDER@@V?$allocator@U__SECRETROOM_TENDER@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?insert@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AViterator@12@V312@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Buy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAE_NI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ufill@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@PAV32@IABV32@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Vector_val@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAE@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@V?$allocator@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$vector@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@V?$allocator@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$vector@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@V?$allocator@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?insert@?$vector@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@V?$allocator@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@std@@@std@@QAE?AViterator@12@V312@ABUMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ufill@?$vector@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@V?$allocator@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@std@@@std@@IAEPAUMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@PAU34@IABU34@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$vector@PAVCMiniGameBase@@V?$allocator@PAVCMiniGameBase@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Buy@?$vector@MV?$allocator@M@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@MV?$allocator@M@std@@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Vector_val@MV?$allocator@M@std@@@std@@IAE@V?$allocator@M@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@M@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$vector@UGuildHouse_Furniture_Info@CGuildHouseBase@@V?$allocator@UGuildHouse_Furniture_Info@CGuildHouseBase@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Key@?$_Tree@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@std@@KAABKPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$_Tree@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Insert@?$_Tree@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBKPAVCGuildHouseBase@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Kfn@?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@SAABKABU?$pair@$$CBKPAVCGuildHouseBase@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@1@AB_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Fiterator@?$_Tree@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@3@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$_Tree@V?$_Tmap_traits@KPAVCCampus@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCampus@@@std@@@3@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@V312@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?equal_range@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@V123@@2@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Key@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@KAABKPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@K@1@ABV?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@QBEAAU?$pair@$$CBKPAVCClientSock@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@3@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Key@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@KAABKPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@K@1@ABV?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@QBEAAU?$pair@$$CBKPAVCClientSockE@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@3@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Key@?$_Tree@V?$_Tmap_traits@KP8CDPDatabaseClient@@AEXAAVCAr@@KK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@std@@@4@$0A@@std@@@std@@KAABKPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPDatabaseClient@@AEXAAVCAr@@KK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@KP8CDPDatabaseClient@@AEXAAVCAr@@KK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@KP8CDPDatabaseClient@@AEXAAVCAr@@KK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@std@@@4@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPDatabaseClient@@AEXAAVCAr@@KK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$_Tree@V?$_Tmap_traits@KP8CDPDatabaseClient@@AEXAAVCAr@@KK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@std@@@4@$0A@@std@@@std@@QBEAAU?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@KP8CDPDatabaseClient@@AEXAAVCAr@@KK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@std@@@4@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@KP8CDPDatabaseClient@@AEXAAVCAr@@KK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@std@@@4@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPDatabaseClient@@AEXAAVCAr@@KK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@std@@@4@$0A@@std@@@3@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Key@?$_Tree@V?$_Tmap_traits@KP8CDPCoreClient@@AEXAAVCAr@@KKK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@std@@@4@$0A@@std@@@std@@KAABKPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPCoreClient@@AEXAAVCAr@@KKK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@KP8CDPCoreClient@@AEXAAVCAr@@KKK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@KP8CDPCoreClient@@AEXAAVCAr@@KKK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@std@@@4@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPCoreClient@@AEXAAVCAr@@KKK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$_Tree@V?$_Tmap_traits@KP8CDPCoreClient@@AEXAAVCAr@@KKK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@std@@@4@$0A@@std@@@std@@QBEAAU?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@KP8CDPCoreClient@@AEXAAVCAr@@KKK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@std@@@4@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@KP8CDPCoreClient@@AEXAAVCAr@@KKK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@std@@@4@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPCoreClient@@AEXAAVCAr@@KKK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@std@@@4@$0A@@std@@@3@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Key@?$_Tree@V?$_Tmap_traits@KP8CDPSrvr@@AEXAAVCAr@@KKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@std@@@4@$0A@@std@@@std@@KAABKPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPSrvr@@AEXAAVCAr@@KKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@KP8CDPSrvr@@AEXAAVCAr@@KKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@KP8CDPSrvr@@AEXAAVCAr@@KKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@std@@@4@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPSrvr@@AEXAAVCAr@@KKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$_Tree@V?$_Tmap_traits@KP8CDPSrvr@@AEXAAVCAr@@KKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@std@@@4@$0A@@std@@@std@@QBEAAU?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@KP8CDPSrvr@@AEXAAVCAr@@KKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@std@@@4@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@KP8CDPSrvr@@AEXAAVCAr@@KKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@std@@@4@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPSrvr@@AEXAAVCAr@@KKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@std@@@4@$0A@@std@@@3@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@EPAU__TAXDETAIL@@U?$less@E@std@@V?$allocator@U?$pair@$$CBEPAU__TAXDETAIL@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@EPAU__TAXDETAIL@@U?$less@E@std@@V?$allocator@U?$pair@$$CBEPAU__TAXDETAIL@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Key@?$_Tree@V?$_Tmap_traits@EPAU__TAXDETAIL@@U?$less@E@std@@V?$allocator@U?$pair@$$CBEPAU__TAXDETAIL@@@std@@@3@$0A@@std@@@std@@KAABEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@EPAU__TAXDETAIL@@U?$less@E@std@@V?$allocator@U?$pair@$$CBEPAU__TAXDETAIL@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@EPAU__TAXDETAIL@@U?$less@E@std@@V?$allocator@U?$pair@$$CBEPAU__TAXDETAIL@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@EPAU__TAXDETAIL@@U?$less@E@std@@V?$allocator@U?$pair@$$CBEPAU__TAXDETAIL@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@EPAU__TAXDETAIL@@U?$less@E@std@@V?$allocator@U?$pair@$$CBEPAU__TAXDETAIL@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@EPAU__TAXDETAIL@@U?$less@E@std@@V?$allocator@U?$pair@$$CBEPAU__TAXDETAIL@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@EPAU__TAXDETAIL@@U?$less@E@std@@V?$allocator@U?$pair@$$CBEPAU__TAXDETAIL@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@E@1@ABV?$allocator@U?$pair@$$CBEPAU__TAXDETAIL@@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@EPAU__TAXDETAIL@@U?$less@E@std@@V?$allocator@U?$pair@$$CBEPAU__TAXDETAIL@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Insert@?$_Tree@V?$_Tmap_traits@EPAU__TAXDETAIL@@U?$less@E@std@@V?$allocator@U?$pair@$$CBEPAU__TAXDETAIL@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@EPAU__TAXDETAIL@@U?$less@E@std@@V?$allocator@U?$pair@$$CBEPAU__TAXDETAIL@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBEPAU__TAXDETAIL@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@EPAU__TAXDETAIL@@U?$less@E@std@@V?$allocator@U?$pair@$$CBEPAU__TAXDETAIL@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@EPAU__TAXDETAIL@@U?$less@E@std@@V?$allocator@U?$pair@$$CBEPAU__TAXDETAIL@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$_Tree@V?$_Tmap_traits@EPAU__TAXDETAIL@@U?$less@E@std@@V?$allocator@U?$pair@$$CBEPAU__TAXDETAIL@@@std@@@3@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Kfn@?$_Tmap_traits@EPAU__TAXDETAIL@@U?$less@E@std@@V?$allocator@U?$pair@$$CBEPAU__TAXDETAIL@@@std@@@3@$0A@@std@@SAABEABU?$pair@$$CBEPAU__TAXDETAIL@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@U?$pair@$$CBEPAU__TAXDETAIL@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@EPAU__TAXDETAIL@@U?$less@E@std@@V?$allocator@U?$pair@$$CBEPAU__TAXDETAIL@@@std@@@3@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@EPAU__TAXDETAIL@@U?$less@E@std@@V?$allocator@U?$pair@$$CBEPAU__TAXDETAIL@@@std@@@3@$0A@@std@@@1@AB_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@EPAU__TAXDETAIL@@U?$less@E@std@@V?$allocator@U?$pair@$$CBEPAU__TAXDETAIL@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@EPAU__TAXDETAIL@@U?$less@E@std@@V?$allocator@U?$pair@$$CBEPAU__TAXDETAIL@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Fiterator@?$_Tree@V?$_Tmap_traits@EPAU__TAXDETAIL@@U?$less@E@std@@V?$allocator@U?$pair@$$CBEPAU__TAXDETAIL@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@EPAU__TAXDETAIL@@U?$less@E@std@@V?$allocator@U?$pair@$$CBEPAU__TAXDETAIL@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@EPAU__TAXDETAIL@@U?$less@E@std@@V?$allocator@U?$pair@$$CBEPAU__TAXDETAIL@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@EPAU__TAXDETAIL@@U?$less@E@std@@V?$allocator@U?$pair@$$CBEPAU__TAXDETAIL@@@std@@@3@$0A@@std@@@3@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Buy@?$vector@PAVITestCase@@V?$allocator@PAVITestCase@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@PAVITestCase@@V?$allocator@PAVITestCase@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Vector_val@PAVITestCase@@V?$allocator@PAVITestCase@@@std@@@std@@IAE@V?$allocator@PAVITestCase@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@PAVITestCase@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@QBEAAU?$pair@$$CBKPAVCGuildMember@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$_Tree@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@std@@QBEAAU?$pair@$$CBKPAVCParty@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE@PAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEABQAU__JOINPLAYER@CGuildCombat@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Econst_iterator@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Nextnode@?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Prevnode@?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Insert@?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@QAEXViterator@12@ABQAVCUser@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Buynode@?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@IAEPAU_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_List_val@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@IAE@V?$allocator@PAVCUser@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@PAVCUser@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@U_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@2@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@U_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@QAE@PAU_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@QBEABQAVCUser@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Econst_iterator@?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?insert@?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@QAE?AViterator@12@V312@ABU__ITEMINFO@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Buy@?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ufill@?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@IAEPAU__ITEMINFO@@PAU3@IABU3@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Vector_val@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@IAE@V?$allocator@U__ITEMINFO@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@U__ITEMINFO@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$vector@KV?$allocator@K@std@@@std@@QBEAAKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Hiterator@?$vector@KV?$allocator@K@std@@@std@@QBE?AV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$vector@HV?$allocator@H@std@@@std@@QBEAAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Hiterator@?$vector@HV?$allocator@H@std@@@std@@QBE?AV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$vector@EV?$allocator@E@std@@@std@@QBEAAEXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Hiterator@?$vector@EV?$allocator@E@std@@@std@@QBE?AV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$vector@VCGuildCombat1to1@@V?$allocator@VCGuildCombat1to1@@@std@@@std@@QBEAAVCGuildCombat1to1@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Hiterator@?$vector@VCGuildCombat1to1@@V?$allocator@VCGuildCombat1to1@@@std@@@std@@QBE?AV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$vector@U__GC1TO1TENDER@CGuildCombat1to1Mng@@V?$allocator@U__GC1TO1TENDER@CGuildCombat1to1Mng@@@std@@@std@@QBEAAU__GC1TO1TENDER@CGuildCombat1to1Mng@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Hiterator@?$vector@U__GC1TO1TENDER@CGuildCombat1to1Mng@@V?$allocator@U__GC1TO1TENDER@CGuildCombat1to1Mng@@@std@@@std@@QBE?AV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEAAPAU__JOINPLAYER@CGuildCombat@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Hiterator@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBE?AV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@QBEAAU__GCGETPOINT@CGuildCombat@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Hiterator@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@QBE?AV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@QBEAAU__GCPLAYERPOINT@CGuildCombat@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Hiterator@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@QBE?AV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QBEAAPAU__GuildCombatMember@CGuildCombat@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Hiterator@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QBE?AV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QBEAAU__REQUESTGUILD@CGuildCombat@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Hiterator@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QBE?AV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$vector@U__SECRETROOM_TENDER@@V?$allocator@U__SECRETROOM_TENDER@@@std@@@std@@QBEAAU__SECRETROOM_TENDER@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Hiterator@?$vector@U__SECRETROOM_TENDER@@V?$allocator@U__SECRETROOM_TENDER@@@std@@@std@@QBE?AV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Hiterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBE?AV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$vector@PAVCMiniGameBase@@V?$allocator@PAVCMiniGameBase@@@std@@@std@@QBEAAPAVCMiniGameBase@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Hiterator@?$vector@PAVCMiniGameBase@@V?$allocator@PAVCMiniGameBase@@@std@@@std@@QBE?AV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$vector@UGuildHouse_Furniture_Info@CGuildHouseBase@@V?$allocator@UGuildHouse_Furniture_Info@CGuildHouseBase@@@std@@@std@@QBEAAUGuildHouse_Furniture_Info@CGuildHouseBase@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Hiterator@?$vector@UGuildHouse_Furniture_Info@CGuildHouseBase@@V?$allocator@UGuildHouse_Furniture_Info@CGuildHouseBase@@@std@@@std@@QBE?AV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEAAU__JOINPLAYER@CGuildCombat@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Hiterator@?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@QBE?AV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@QBEAAU__ITEMINFO@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Hiterator@?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@QBE?AV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Init@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Tree_val@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@K@1@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Init@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Tree_val@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@K@1@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Insert_n@?$vector@KV?$allocator@K@std@@@std@@IAEXViterator@12@IABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Tree_ptr@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@U?$pair@$$CBHH@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$vector@EV?$allocator@E@std@@@std@@QBEABEXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?pop_back@?$deque@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Deque_map@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@IAE@V?$allocator@PAUtagACTMSG@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@PAUtagACTMSG@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@PAUtagACTMSG@@@std@@QAEXPAPAUtagACTMSG@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@PAPAUtagACTMSG@@@std@@QAEXPAPAPAUtagACTMSG@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@PAPAUtagACTMSG@@@std@@QAEXPAPAPAUtagACTMSG@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?pop_back@?$deque@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Deque_map@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@IAE@V?$allocator@PAUtagMAGICATKMSG@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@PAUtagMAGICATKMSG@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@PAUtagMAGICATKMSG@@@std@@QAEXPAPAUtagMAGICATKMSG@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@PAPAUtagMAGICATKMSG@@@std@@QAEXPAPAPAUtagMAGICATKMSG@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@PAPAUtagMAGICATKMSG@@@std@@QAEXPAPAPAUtagMAGICATKMSG@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBEABU?$pair@$$CBHH@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$deque@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@QAE@IPBV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$deque@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@QAE@IPBV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?clear@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?upper_bound@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QAE?AV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QBEABU?$pair@$$CBKU_Friend@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Destroy@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAEXPAPAU__JOINPLAYER@CGuildCombat@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@QAEXPAPAU__JOINPLAYER@CGuildCombat@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myval@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@KAAAPAU__JOINPLAYER@CGuildCombat@@PAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Buynode@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAEPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@PAU342@0ABQAU__JOINPLAYER@CGuildCombat@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Incsize@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_List_ptr@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAE@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@U_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@@std@@QAEPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?construct@?$allocator@PAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@ABQAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@PAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Destroy@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@IAEXPAU__REQUESTGUILD@CGuildCombat@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@QAEXPAU__REQUESTGUILD@CGuildCombat@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$vector@U__SECRETROOM_MONSTER@@V?$allocator@U__SECRETROOM_MONSTER@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Destroy@?$vector@U__SECRETROOM_MONSTER@@V?$allocator@U__SECRETROOM_MONSTER@@@std@@@std@@IAEXPAU__SECRETROOM_MONSTER@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Xlen@?$vector@U__SECRETROOM_MONSTER@@V?$allocator@U__SECRETROOM_MONSTER@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@U__SECRETROOM_MONSTER@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@U__SECRETROOM_MONSTER@@@std@@QAEXPAU__SECRETROOM_MONSTER@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@U__SECRETROOM_MONSTER@@@std@@QAEPAU__SECRETROOM_MONSTER@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Destroy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Insert_n@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXViterator@12@IABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Xlen@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$vector@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@V?$allocator@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Insert_n@?$vector@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@V?$allocator@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@std@@@std@@IAEXViterator@12@IABUMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$vector@MV?$allocator@M@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Destroy@?$vector@MV?$allocator@M@std@@@std@@IAEXPAM0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Xlen@?$vector@MV?$allocator@M@std@@@std@@IBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@M@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@M@std@@QAEXPAMI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@M@std@@QAEPAMI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Color@?$_Tree@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myval@?$_Tree@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBKPAVCGuildHouseBase@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$_Tree@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lmost@?$_Tree@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Rmost@?$_Tree@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBKPAVCGuildHouseBase@@@2@D@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Fconst_iterator@?$_Tree@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?clear@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?upper_bound@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@QAE?AV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myval@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBKPAVCClientSock@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Init@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lbound@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@2@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Tree_val@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@K@1@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Kfn@?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@SAABKABU?$pair@$$CBKPAVCClientSock@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@2@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@QBEABU?$pair@$$CBKPAVCClientSock@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myval@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBKPAVCClientSockE@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Init@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lbound@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@2@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Tree_val@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@K@1@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Kfn@?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@SAABKABU?$pair@$$CBKPAVCClientSockE@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@2@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@QBEABU?$pair@$$CBKPAVCClientSockE@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myval@?$_Tree@V?$_Tmap_traits@KP8CDPDatabaseClient@@AEXAAVCAr@@KK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@std@@@4@$0A@@std@@@std@@KAAAU?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPDatabaseClient@@AEXAAVCAr@@KK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lbound@?$_Tree@V?$_Tmap_traits@KP8CDPDatabaseClient@@AEXAAVCAr@@KK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@std@@@4@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPDatabaseClient@@AEXAAVCAr@@KK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@std@@@4@$0A@@std@@@2@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Kfn@?$_Tmap_traits@KP8CDPDatabaseClient@@AEXAAVCAr@@KK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@std@@@4@$0A@@std@@SAABKABU?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@KP8CDPDatabaseClient@@AEXAAVCAr@@KK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@std@@@4@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPDatabaseClient@@AEXAAVCAr@@KK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$_Tree@V?$_Tmap_traits@KP8CDPDatabaseClient@@AEXAAVCAr@@KK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@std@@@4@$0A@@std@@@std@@QBEABU?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myval@?$_Tree@V?$_Tmap_traits@KP8CDPCoreClient@@AEXAAVCAr@@KKK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@std@@@4@$0A@@std@@@std@@KAAAU?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPCoreClient@@AEXAAVCAr@@KKK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lbound@?$_Tree@V?$_Tmap_traits@KP8CDPCoreClient@@AEXAAVCAr@@KKK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@std@@@4@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPCoreClient@@AEXAAVCAr@@KKK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@std@@@4@$0A@@std@@@2@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Kfn@?$_Tmap_traits@KP8CDPCoreClient@@AEXAAVCAr@@KKK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@std@@@4@$0A@@std@@SAABKABU?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@KP8CDPCoreClient@@AEXAAVCAr@@KKK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@std@@@4@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPCoreClient@@AEXAAVCAr@@KKK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$_Tree@V?$_Tmap_traits@KP8CDPCoreClient@@AEXAAVCAr@@KKK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@std@@@4@$0A@@std@@@std@@QBEABU?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myval@?$_Tree@V?$_Tmap_traits@KP8CDPSrvr@@AEXAAVCAr@@KKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@std@@@4@$0A@@std@@@std@@KAAAU?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPSrvr@@AEXAAVCAr@@KKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lbound@?$_Tree@V?$_Tmap_traits@KP8CDPSrvr@@AEXAAVCAr@@KKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@std@@@4@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPSrvr@@AEXAAVCAr@@KKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@std@@@4@$0A@@std@@@2@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Kfn@?$_Tmap_traits@KP8CDPSrvr@@AEXAAVCAr@@KKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@std@@@4@$0A@@std@@SAABKABU?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@KP8CDPSrvr@@AEXAAVCAr@@KKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@std@@@4@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPSrvr@@AEXAAVCAr@@KKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$_Tree@V?$_Tmap_traits@KP8CDPSrvr@@AEXAAVCAr@@KKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@std@@@4@$0A@@std@@@std@@QBEABU?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Color@?$_Tree@V?$_Tmap_traits@EPAU__TAXDETAIL@@U?$less@E@std@@V?$allocator@U?$pair@$$CBEPAU__TAXDETAIL@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@EPAU__TAXDETAIL@@U?$less@E@std@@V?$allocator@U?$pair@$$CBEPAU__TAXDETAIL@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@EPAU__TAXDETAIL@@U?$less@E@std@@V?$allocator@U?$pair@$$CBEPAU__TAXDETAIL@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@EPAU__TAXDETAIL@@U?$less@E@std@@V?$allocator@U?$pair@$$CBEPAU__TAXDETAIL@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myval@?$_Tree@V?$_Tmap_traits@EPAU__TAXDETAIL@@U?$less@E@std@@V?$allocator@U?$pair@$$CBEPAU__TAXDETAIL@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBEPAU__TAXDETAIL@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@EPAU__TAXDETAIL@@U?$less@E@std@@V?$allocator@U?$pair@$$CBEPAU__TAXDETAIL@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@EPAU__TAXDETAIL@@U?$less@E@std@@V?$allocator@U?$pair@$$CBEPAU__TAXDETAIL@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$_Tree@V?$_Tmap_traits@EPAU__TAXDETAIL@@U?$less@E@std@@V?$allocator@U?$pair@$$CBEPAU__TAXDETAIL@@@std@@@3@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@EPAU__TAXDETAIL@@U?$less@E@std@@V?$allocator@U?$pair@$$CBEPAU__TAXDETAIL@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Init@?$_Tree@V?$_Tmap_traits@EPAU__TAXDETAIL@@U?$less@E@std@@V?$allocator@U?$pair@$$CBEPAU__TAXDETAIL@@@std@@@3@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lmost@?$_Tree@V?$_Tmap_traits@EPAU__TAXDETAIL@@U?$less@E@std@@V?$allocator@U?$pair@$$CBEPAU__TAXDETAIL@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@EPAU__TAXDETAIL@@U?$less@E@std@@V?$allocator@U?$pair@$$CBEPAU__TAXDETAIL@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tmap_traits@EPAU__TAXDETAIL@@U?$less@E@std@@V?$allocator@U?$pair@$$CBEPAU__TAXDETAIL@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@EPAU__TAXDETAIL@@U?$less@E@std@@V?$allocator@U?$pair@$$CBEPAU__TAXDETAIL@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Rmost@?$_Tree@V?$_Tmap_traits@EPAU__TAXDETAIL@@U?$less@E@std@@V?$allocator@U?$pair@$$CBEPAU__TAXDETAIL@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@EPAU__TAXDETAIL@@U?$less@E@std@@V?$allocator@U?$pair@$$CBEPAU__TAXDETAIL@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tmap_traits@EPAU__TAXDETAIL@@U?$less@E@std@@V?$allocator@U?$pair@$$CBEPAU__TAXDETAIL@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@EPAU__TAXDETAIL@@U?$less@E@std@@V?$allocator@U?$pair@$$CBEPAU__TAXDETAIL@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@EPAU__TAXDETAIL@@U?$less@E@std@@V?$allocator@U?$pair@$$CBEPAU__TAXDETAIL@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@EPAU__TAXDETAIL@@U?$less@E@std@@V?$allocator@U?$pair@$$CBEPAU__TAXDETAIL@@@std@@@3@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBEPAU__TAXDETAIL@@@2@D@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Tree_val@V?$_Tmap_traits@EPAU__TAXDETAIL@@U?$less@E@std@@V?$allocator@U?$pair@$$CBEPAU__TAXDETAIL@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@E@1@V?$allocator@U?$pair@$$CBEPAU__TAXDETAIL@@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@U?$pair@$$CBEPAU__TAXDETAIL@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@EPAU__TAXDETAIL@@U?$less@E@std@@V?$allocator@U?$pair@$$CBEPAU__TAXDETAIL@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@EPAU__TAXDETAIL@@U?$less@E@std@@V?$allocator@U?$pair@$$CBEPAU__TAXDETAIL@@@std@@@3@$0A@@std@@@2@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@EPAU__TAXDETAIL@@U?$less@E@std@@V?$allocator@U?$pair@$$CBEPAU__TAXDETAIL@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@EPAU__TAXDETAIL@@U?$less@E@std@@V?$allocator@U?$pair@$$CBEPAU__TAXDETAIL@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@EPAU__TAXDETAIL@@U?$less@E@std@@V?$allocator@U?$pair@$$CBEPAU__TAXDETAIL@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@EPAU__TAXDETAIL@@U?$less@E@std@@V?$allocator@U?$pair@$$CBEPAU__TAXDETAIL@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Fconst_iterator@?$_Tree@V?$_Tmap_traits@EPAU__TAXDETAIL@@U?$less@E@std@@V?$allocator@U?$pair@$$CBEPAU__TAXDETAIL@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$vector@PAVITestCase@@V?$allocator@PAVITestCase@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Destroy@?$vector@PAVITestCase@@V?$allocator@PAVITestCase@@@std@@@std@@IAEXPAPAVITestCase@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Xlen@?$vector@PAVITestCase@@V?$allocator@PAVITestCase@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@PAVITestCase@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@PAVITestCase@@@std@@QAEXPAPAVITestCase@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@PAVITestCase@@@std@@QAEPAPAVITestCase@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@QBEABU?$pair@$$CBKPAVCGuildMember@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$_Tree@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@std@@QBEABU?$pair@$$CBKPAVCParty@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE@PAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Mynode@const_iterator@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@3@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myval@?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@KAAAPAVCUser@@PAU_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Buynode@?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@IAEPAU_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@2@PAU342@0ABQAVCUser@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Incsize@?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_List_ptr@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@IAE@V?$allocator@PAVCUser@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@PAVCUser@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@U_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@@std@@QAEPAU_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@2@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?construct@?$allocator@PAU_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@2@ABQAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@PAU_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@QAE@PAU_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Mynode@const_iterator@?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@QBEPAU_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@3@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Destroy@?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@IAEXPAU__ITEMINFO@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Insert_n@?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@IAEXViterator@12@IABU__ITEMINFO@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Xlen@?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@U__ITEMINFO@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@U__ITEMINFO@@@std@@QAEXPAU__ITEMINFO@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@U__ITEMINFO@@@std@@QAEPAU__ITEMINFO@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$vector@KV?$allocator@K@std@@@std@@QAE@PAK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Yiterator@?$vector@KV?$allocator@K@std@@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Giterator@?$vector@KV?$allocator@K@std@@@std@@QBEHABVconst_iterator@12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$vector@KV?$allocator@K@std@@@std@@QBEABKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$vector@HV?$allocator@H@std@@@std@@QAE@PAH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Yiterator@?$vector@HV?$allocator@H@std@@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$vector@HV?$allocator@H@std@@@std@@QBEABHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$vector@EV?$allocator@E@std@@@std@@QAE@PAE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Yiterator@?$vector@EV?$allocator@E@std@@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$vector@VCGuildCombat1to1@@V?$allocator@VCGuildCombat1to1@@@std@@@std@@QAE@PAVCGuildCombat1to1@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Yiterator@?$vector@VCGuildCombat1to1@@V?$allocator@VCGuildCombat1to1@@@std@@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$vector@VCGuildCombat1to1@@V?$allocator@VCGuildCombat1to1@@@std@@@std@@QBEABVCGuildCombat1to1@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$vector@U__GC1TO1TENDER@CGuildCombat1to1Mng@@V?$allocator@U__GC1TO1TENDER@CGuildCombat1to1Mng@@@std@@@std@@QAE@PAU__GC1TO1TENDER@CGuildCombat1to1Mng@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Yiterator@?$vector@U__GC1TO1TENDER@CGuildCombat1to1Mng@@V?$allocator@U__GC1TO1TENDER@CGuildCombat1to1Mng@@@std@@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$vector@U__GC1TO1TENDER@CGuildCombat1to1Mng@@V?$allocator@U__GC1TO1TENDER@CGuildCombat1to1Mng@@@std@@@std@@QBEABU__GC1TO1TENDER@CGuildCombat1to1Mng@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@V123@@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@1@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE@PAPAU__JOINPLAYER@CGuildCombat@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Yiterator@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEABQAU__JOINPLAYER@CGuildCombat@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@QAE@PAU__GCGETPOINT@CGuildCombat@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Yiterator@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@QBEABU__GCGETPOINT@CGuildCombat@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@QAE@PAU__GCPLAYERPOINT@CGuildCombat@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Yiterator@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@QBEABU__GCPLAYERPOINT@CGuildCombat@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QAE@PAPAU__GuildCombatMember@CGuildCombat@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Yiterator@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QBEABQAU__GuildCombatMember@CGuildCombat@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QAE@PAU__REQUESTGUILD@CGuildCombat@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Yiterator@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QBEABU__REQUESTGUILD@CGuildCombat@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$vector@U__SECRETROOM_TENDER@@V?$allocator@U__SECRETROOM_TENDER@@@std@@@std@@QAE@PAU__SECRETROOM_TENDER@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Yiterator@?$vector@U__SECRETROOM_TENDER@@V?$allocator@U__SECRETROOM_TENDER@@@std@@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$vector@U__SECRETROOM_TENDER@@V?$allocator@U__SECRETROOM_TENDER@@@std@@@std@@QBEABU__SECRETROOM_TENDER@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Yiterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Giterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEHABVconst_iterator@12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$vector@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@V?$allocator@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@std@@@std@@QAE@PAUMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Hiterator@?$vector@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@V?$allocator@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@std@@@std@@QBE?AV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Giterator@?$vector@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@V?$allocator@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@std@@@std@@QBEHABVconst_iterator@12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$vector@PAVCMiniGameBase@@V?$allocator@PAVCMiniGameBase@@@std@@@std@@QAE@PAPAVCMiniGameBase@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Yiterator@?$vector@PAVCMiniGameBase@@V?$allocator@PAVCMiniGameBase@@@std@@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$vector@PAVCMiniGameBase@@V?$allocator@PAVCMiniGameBase@@@std@@@std@@QBEABQAVCMiniGameBase@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$vector@UGuildHouse_Furniture_Info@CGuildHouseBase@@V?$allocator@UGuildHouse_Furniture_Info@CGuildHouseBase@@@std@@@std@@QAE@PAUGuildHouse_Furniture_Info@CGuildHouseBase@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Yiterator@?$vector@UGuildHouse_Furniture_Info@CGuildHouseBase@@V?$allocator@UGuildHouse_Furniture_Info@CGuildHouseBase@@@std@@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$vector@UGuildHouse_Furniture_Info@CGuildHouseBase@@V?$allocator@UGuildHouse_Furniture_Info@CGuildHouseBase@@@std@@@std@@QBEABUGuildHouse_Furniture_Info@CGuildHouseBase@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@V123@@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@1@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE@PAU__JOINPLAYER@CGuildCombat@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Yiterator@?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEABU__JOINPLAYER@CGuildCombat@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@QAE@PAU__ITEMINFO@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Yiterator@?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Giterator@?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@QBEHABVconst_iterator@12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@QBEABU__ITEMINFO@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Tree_ptr@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@K@1@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Tree_ptr@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@K@1@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myval@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@KAAAU?$pair@$$CBHH@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHH@2@D@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@ABQAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@PAUtagACTMSG@@@std@@QAEXPAPAUtagACTMSG@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@PAUtagMAGICATKMSG@@@std@@QAEXPAPAUtagMAGICATKMSG@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myval@?$_Tree@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBKPAVCParty@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Min@?$_Tree@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Color@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myval@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBKU_Friend@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Erase@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lbound@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Max@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Min@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Rmost@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ubound@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@3@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myval@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBKPAVCGuildMember@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Min@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAE@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@U__SECRETROOM_MONSTER@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$vector@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@V?$allocator@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Destroy@?$vector@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@V?$allocator@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@std@@@std@@IAEXPAUMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Xlen@?$vector@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@V?$allocator@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@std@@QAEXPAUMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@std@@QAEPAUMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@M@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@2@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@2@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Color@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Erase@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lbound@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@2@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lmost@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Max@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Min@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Rmost@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ubound@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@2@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@2@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@3@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?clear@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lmost@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Rmost@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Tree_ptr@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@K@1@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@QAE?AV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?clear@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lmost@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Rmost@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Tree_ptr@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@K@1@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@QAE?AV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@KP8CDPDatabaseClient@@AEXAAVCAr@@KK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPDatabaseClient@@AEXAAVCAr@@KK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@KP8CDPDatabaseClient@@AEXAAVCAr@@KK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPDatabaseClient@@AEXAAVCAr@@KK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@std@@@4@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@KP8CDPDatabaseClient@@AEXAAVCAr@@KK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPDatabaseClient@@AEXAAVCAr@@KK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@std@@@4@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@KP8CDPDatabaseClient@@AEXAAVCAr@@KK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPDatabaseClient@@AEXAAVCAr@@KK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@std@@@4@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@KP8CDPCoreClient@@AEXAAVCAr@@KKK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPCoreClient@@AEXAAVCAr@@KKK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@KP8CDPCoreClient@@AEXAAVCAr@@KKK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPCoreClient@@AEXAAVCAr@@KKK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@std@@@4@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@KP8CDPCoreClient@@AEXAAVCAr@@KKK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPCoreClient@@AEXAAVCAr@@KKK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@std@@@4@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@KP8CDPCoreClient@@AEXAAVCAr@@KKK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPCoreClient@@AEXAAVCAr@@KKK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@std@@@4@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@KP8CDPSrvr@@AEXAAVCAr@@KKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPSrvr@@AEXAAVCAr@@KKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@KP8CDPSrvr@@AEXAAVCAr@@KKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPSrvr@@AEXAAVCAr@@KKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@std@@@4@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@KP8CDPSrvr@@AEXAAVCAr@@KKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPSrvr@@AEXAAVCAr@@KKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@std@@@4@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@KP8CDPSrvr@@AEXAAVCAr@@KKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPSrvr@@AEXAAVCAr@@KKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@std@@@4@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@EPAU__TAXDETAIL@@U?$less@E@std@@V?$allocator@U?$pair@$$CBEPAU__TAXDETAIL@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?clear@?$_Tree@V?$_Tmap_traits@EPAU__TAXDETAIL@@U?$less@E@std@@V?$allocator@U?$pair@$$CBEPAU__TAXDETAIL@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@EPAU__TAXDETAIL@@U?$less@E@std@@V?$allocator@U?$pair@$$CBEPAU__TAXDETAIL@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@EPAU__TAXDETAIL@@U?$less@E@std@@V?$allocator@U?$pair@$$CBEPAU__TAXDETAIL@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Tree_ptr@V?$_Tmap_traits@EPAU__TAXDETAIL@@U?$less@E@std@@V?$allocator@U?$pair@$$CBEPAU__TAXDETAIL@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@E@1@V?$allocator@U?$pair@$$CBEPAU__TAXDETAIL@@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@U?$pair@$$CBEPAU__TAXDETAIL@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@EPAU__TAXDETAIL@@U?$less@E@std@@V?$allocator@U?$pair@$$CBEPAU__TAXDETAIL@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@EPAU__TAXDETAIL@@U?$less@E@std@@V?$allocator@U?$pair@$$CBEPAU__TAXDETAIL@@@std@@@3@$0A@@std@@@2@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@EPAU__TAXDETAIL@@U?$less@E@std@@V?$allocator@U?$pair@$$CBEPAU__TAXDETAIL@@@std@@@3@$0A@@std@@@std@@QAE?AV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@EPAU__TAXDETAIL@@U?$less@E@std@@V?$allocator@U?$pair@$$CBEPAU__TAXDETAIL@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@EPAU__TAXDETAIL@@U?$less@E@std@@V?$allocator@U?$pair@$$CBEPAU__TAXDETAIL@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@PAVITestCase@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@IAE@V?$allocator@PAVCUser@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@U__ITEMINFO@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$vector@KV?$allocator@K@std@@@std@@QAE@PAK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Gconst_iterator@?$vector@KV?$allocator@K@std@@@std@@QBEHABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$vector@HV?$allocator@H@std@@@std@@QAE@PAH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$vector@VCGuildCombat1to1@@V?$allocator@VCGuildCombat1to1@@@std@@@std@@QAE@PAVCGuildCombat1to1@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$vector@U__GC1TO1TENDER@CGuildCombat1to1Mng@@V?$allocator@U__GC1TO1TENDER@CGuildCombat1to1Mng@@@std@@@std@@QAE@PAU__GC1TO1TENDER@CGuildCombat1to1Mng@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE@PAPAU__JOINPLAYER@CGuildCombat@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@QAE@PAU__GCGETPOINT@CGuildCombat@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@QAE@PAU__GCPLAYERPOINT@CGuildCombat@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QAE@PAPAU__GuildCombatMember@CGuildCombat@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QAE@PAU__REQUESTGUILD@CGuildCombat@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$vector@U__SECRETROOM_TENDER@@V?$allocator@U__SECRETROOM_TENDER@@@std@@@std@@QAE@PAU__SECRETROOM_TENDER@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Gconst_iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEHABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Yiterator@?$vector@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@V?$allocator@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@std@@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$vector@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@V?$allocator@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@std@@@std@@QAE@PAUMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Gconst_iterator@?$vector@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@V?$allocator@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@std@@@std@@QBEHABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$vector@PAVCMiniGameBase@@V?$allocator@PAVCMiniGameBase@@@std@@@std@@QAE@PAPAVCMiniGameBase@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$vector@UGuildHouse_Furniture_Info@CGuildHouseBase@@V?$allocator@UGuildHouse_Furniture_Info@CGuildHouseBase@@@std@@@std@@QAE@PAUGuildHouse_Furniture_Info@CGuildHouseBase@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE@PAU__JOINPLAYER@CGuildCombat@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@QAE@PAU__ITEMINFO@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Gconst_iterator@?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@QBEHABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE@PAU012@0ABQAU__JOINPLAYER@CGuildCombat@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBKPAVCGuildHouseBase@@@2@D@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_Node@?$_Tree_nod@V?$_Tmap_traits@EPAU__TAXDETAIL@@U?$less@E@std@@V?$allocator@U?$pair@$$CBEPAU__TAXDETAIL@@@std@@@3@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBEPAU__TAXDETAIL@@@2@D@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@QAE@PAU012@0ABQAVCUser@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@K@1@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@ABQAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@K@1@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@ABQAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@QAE@U?$less@H@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBHH@2@D@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Key@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@KAABKPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Max@?$_Tree@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Key@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@KAABKPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Color@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Erase@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Max@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Min@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@K@1@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@2@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@2@ABQAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Color@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Erase@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Max@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Min@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@K@1@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@2@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@2@ABQAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@KP8CDPDatabaseClient@@AEXAAVCAr@@KK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPDatabaseClient@@AEXAAVCAr@@KK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@std@@@4@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@KP8CDPCoreClient@@AEXAAVCAr@@KKK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPCoreClient@@AEXAAVCAr@@KKK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@std@@@4@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@KP8CDPSrvr@@AEXAAVCAr@@KKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPSrvr@@AEXAAVCAr@@KKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@std@@@4@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Erase@?$_Tree@V?$_Tmap_traits@EPAU__TAXDETAIL@@U?$less@E@std@@V?$allocator@U?$pair@$$CBEPAU__TAXDETAIL@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@EPAU__TAXDETAIL@@U?$less@E@std@@V?$allocator@U?$pair@$$CBEPAU__TAXDETAIL@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Max@?$_Tree@V?$_Tmap_traits@EPAU__TAXDETAIL@@U?$less@E@std@@V?$allocator@U?$pair@$$CBEPAU__TAXDETAIL@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@EPAU__TAXDETAIL@@U?$less@E@std@@V?$allocator@U?$pair@$$CBEPAU__TAXDETAIL@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Min@?$_Tree@V?$_Tmap_traits@EPAU__TAXDETAIL@@U?$less@E@std@@V?$allocator@U?$pair@$$CBEPAU__TAXDETAIL@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@EPAU__TAXDETAIL@@U?$less@E@std@@V?$allocator@U?$pair@$$CBEPAU__TAXDETAIL@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Tree_nod@V?$_Tmap_traits@EPAU__TAXDETAIL@@U?$less@E@std@@V?$allocator@U?$pair@$$CBEPAU__TAXDETAIL@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@E@1@V?$allocator@U?$pair@$$CBEPAU__TAXDETAIL@@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@EPAU__TAXDETAIL@@U?$less@E@std@@V?$allocator@U?$pair@$$CBEPAU__TAXDETAIL@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@EPAU__TAXDETAIL@@U?$less@E@std@@V?$allocator@U?$pair@$$CBEPAU__TAXDETAIL@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@EPAU__TAXDETAIL@@U?$less@E@std@@V?$allocator@U?$pair@$$CBEPAU__TAXDETAIL@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@EPAU__TAXDETAIL@@U?$less@E@std@@V?$allocator@U?$pair@$$CBEPAU__TAXDETAIL@@@std@@@3@$0A@@std@@@2@ABQAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@EPAU__TAXDETAIL@@U?$less@E@std@@V?$allocator@U?$pair@$$CBEPAU__TAXDETAIL@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@PAVCUser@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@QAE@U?$less@K@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@QAE@U?$less@K@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Kfn@?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@SAABKABU?$pair@$$CBKU_Friend@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myval@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@KAAAU?$pair@$$CBKK@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Kfn@?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@SAABKABU?$pair@$$CBKK@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@QAE@U?$less@K@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@QAE@U?$less@K@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Tmap_traits@EPAU__TAXDETAIL@@U?$less@E@std@@V?$allocator@U?$pair@$$CBEPAU__TAXDETAIL@@@std@@@3@$0A@@std@@QAE@U?$less@E@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@EPAU__TAXDETAIL@@U?$less@E@std@@V?$allocator@U?$pair@$$CBEPAU__TAXDETAIL@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@EPAU__TAXDETAIL@@U?$less@E@std@@V?$allocator@U?$pair@$$CBEPAU__TAXDETAIL@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Iter_cat@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABVconst_iterator@?$vector@EV?$allocator@E@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Assign@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@QAEXVconst_iterator@01@0Uinput_iterator_tag@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsEquip@?$CItemContainer@VCItemElem@@@@QAEHK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAtItemId@?$CItemContainer@VCItemElem@@@@QAEPAVCItemElem@@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAtItemNum@?$CItemContainer@VCItemElem@@@@QAEHK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveAtId@?$CItemContainer@VCItemElem@@@@QAEXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Serialize@?$CItemContainer@VCItemElem@@@@QAEXAAVCAr@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Iter_cat@Viterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@@std@@YA?AUbidirectional_iterator_tag@0@ABViterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Distance2@Viterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@I@std@@YAXViterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@0@0AAIUbidirectional_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Iter_cat@Viterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@@std@@YA?AUbidirectional_iterator_tag@0@ABViterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Distance2@Viterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@I@std@@YAXViterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@0@0AAIUbidirectional_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_copy@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@PAEV?$allocator@E@3@@std@@YAPAEVconst_iterator@?$vector@EV?$allocator@E@std@@@0@0PAEAAV?$allocator@E@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Iter_cat@Viterator@?$_Tree@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@std@@@std@@YA?AUbidirectional_iterator_tag@0@ABViterator@?$_Tree@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Distance2@Viterator@?$_Tree@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@std@@I@std@@YAXViterator@?$_Tree@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@0@0AAIUbidirectional_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAU__SPAWNREGION@CEventLua@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU__SPAWNREGION@CEventLua@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_fill_n@PAU__SPAWNREGION@CEventLua@@IU12@V?$allocator@U__SPAWNREGION@CEventLua@@@std@@@std@@YAXPAU__SPAWNREGION@CEventLua@@IABU12@AAV?$allocator@U__SPAWNREGION@CEventLua@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Copy_opt@PAJPAJ@std@@YAPAJPAJ00U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_copy@PAJPAJV?$allocator@J@std@@@std@@YAPAJPAJ00AAV?$allocator@J@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAJPAJ@std@@YAPAJPAJ00U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAUtagDROPITEM@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUtagDROPITEM@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@UtagDROPITEM@@V?$allocator@UtagDROPITEM@@@std@@@std@@YAXPAUtagDROPITEM@@0AAV?$allocator@UtagDROPITEM@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAUWORMON@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUWORMON@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@UWORMON@@V?$allocator@UWORMON@@@std@@@std@@YAXPAUWORMON@@0AAV?$allocator@UWORMON@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAU__ITEMGAME@CMiniGame@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU__ITEMGAME@CMiniGame@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@U__ITEMGAME@CMiniGame@@V?$allocator@U__ITEMGAME@CMiniGame@@@std@@@std@@YAXPAU__ITEMGAME@CMiniGame@@0AAV?$allocator@U__ITEMGAME@CMiniGame@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@KV?$allocator@K@std@@@std@@YAXPAK0AAV?$allocator@K@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@HV?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAU__ITEM@CExchange@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU__ITEM@CExchange@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@U__ITEM@CExchange@@V?$allocator@U__ITEM@CExchange@@@std@@@std@@YAXPAU__ITEM@CExchange@@0AAV?$allocator@U__ITEM@CExchange@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAU__POINT@CExchange@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU__POINT@CExchange@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@U__POINT@CExchange@@V?$allocator@U__POINT@CExchange@@@std@@@std@@YAXPAU__POINT@CExchange@@0AAV?$allocator@U__POINT@CExchange@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@EV?$allocator@E@std@@@std@@YAXPAE0AAV?$allocator@E@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_copy@PAU__SPAWNREGION@CEventLua@@PAU12@V?$allocator@U__SPAWNREGION@CEventLua@@@std@@@std@@YAPAU__SPAWNREGION@CEventLua@@PAU12@00AAV?$allocator@U__SPAWNREGION@CEventLua@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAU__SPAWNREGION@CEventLua@@PAU12@@std@@YAPAU__SPAWNREGION@CEventLua@@PAU12@00U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAUD3DXVECTOR3@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUD3DXVECTOR3@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@YAXPAUD3DXVECTOR3@@0AAV?$allocator@UD3DXVECTOR3@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAU_GIFTBOX@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU_GIFTBOX@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@U_GIFTBOX@@V?$allocator@U_GIFTBOX@@@std@@@std@@YAXPAU_GIFTBOX@@0AAV?$allocator@U_GIFTBOX@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@JV?$allocator@J@std@@@std@@YAXPAJ0AAV?$allocator@J@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_fill_n@JIJ@std@@YAXPAJIABJAAV?$allocator@J@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@U__SPAWNREGION@CEventLua@@V?$allocator@U__SPAWNREGION@CEventLua@@@std@@@std@@YAXPAU__SPAWNREGION@CEventLua@@0AAV?$allocator@U__SPAWNREGION@CEventLua@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$make_pair@KPAVCGuildHouseBase@@@std@@YA?AU?$pair@KPAVCGuildHouseBase@@@0@KPAVCGuildHouseBase@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?0KPAVCGuildHouseBase@@@?$pair@$$CBKPAVCGuildHouseBase@@@std@@QAE@ABU?$pair@KPAVCGuildHouseBase@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CFixedArray@UtagWORLD@@@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAt@?$CFixedArray@UtagWORLD@@@@QAEPAUtagWORLD@@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$make_pair@EPAU__TAXDETAIL@@@std@@YA?AU?$pair@EPAU__TAXDETAIL@@@0@EPAU__TAXDETAIL@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?0EPAU__TAXDETAIL@@@?$pair@$$CBEPAU__TAXDETAIL@@@std@@QAE@ABU?$pair@EPAU__TAXDETAIL@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$throw_exception@Vbad_weak_ptr@boost@@@boost@@YAXABVbad_weak_ptr@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$make_pair@KPAVCUser@@@std@@YA?AU?$pair@KPAVCUser@@@0@KPAVCUser@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?0KPAVCUser@@@?$pair@$$CBKPAVCUser@@@std@@QAE@ABU?$pair@KPAVCUser@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$copy@PAKPAK@std@@YAPAKPAK00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ucopy@PAK@?$vector@KV?$allocator@K@std@@@std@@IAEPAKPAK00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Distance@Viterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@I@std@@YAXViterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@0@0AAI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Distance@Viterator@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@I@std@@YAXViterator@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@0@0AAI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_fill_n@PAKIKV?$allocator@K@std@@@std@@YAXPAKIABKAAV?$allocator@K@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@U_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@@std@@YAXPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_fill_n@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IABV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_fill_n@PAUMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@IU12@V?$allocator@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@std@@@std@@YAXPAUMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@IABU12@AAV?$allocator@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@U_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@@std@@YAXPAU_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_fill_n@PAU__ITEMINFO@@IU1@V?$allocator@U__ITEMINFO@@@std@@@std@@YAXPAU__ITEMINFO@@IABU1@AAV?$allocator@U__ITEMINFO@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IPAV10@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$fill@PAKK@std@@YAXPAK0ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$copy_backward@PAKPAK@std@@YAPAKPAK00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@$$CBHH@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHH@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?0PAUtagACTMSG@@@?$allocator@PAPAUtagACTMSG@@@std@@QAE@ABV?$allocator@PAUtagACTMSG@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@PAPAUtagACTMSG@@@std@@YAXPAPAPAUtagACTMSG@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?0PAUtagMAGICATKMSG@@@?$allocator@PAPAUtagMAGICATKMSG@@@std@@QAE@ABV?$allocator@PAUtagMAGICATKMSG@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@PAPAUtagMAGICATKMSG@@@std@@YAXPAPAPAUtagMAGICATKMSG@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@YAXPAPAU__JOINPLAYER@CGuildCombat@@0AAV?$allocator@PAU__JOINPLAYER@CGuildCombat@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?0PAU__JOINPLAYER@CGuildCombat@@@?$allocator@PAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@@std@@QAE@ABV?$allocator@PAU__JOINPLAYER@CGuildCombat@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@U_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@@std@@YAPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@0@IPAU120@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Construct@PAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@0@ABQAU120@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@PAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@@std@@YAXPAPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@YAXPAU__REQUESTGUILD@CGuildCombat@@0AAV?$allocator@U__REQUESTGUILD@CGuildCombat@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@U__SECRETROOM_MONSTER@@V?$allocator@U__SECRETROOM_MONSTER@@@std@@@std@@YAXPAU__SECRETROOM_MONSTER@@0AAV?$allocator@U__SECRETROOM_MONSTER@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@U__SECRETROOM_MONSTER@@@std@@YAPAU__SECRETROOM_MONSTER@@IPAU1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ucopy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PAV21@00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$fill@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0ABV10@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$copy_backward@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ucopy@PAUMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@?$vector@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@V?$allocator@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@std@@@std@@IAEPAUMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@PAU23@00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$fill@PAUMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@U12@@std@@YAXPAUMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@0ABU12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$copy_backward@PAUMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@PAU12@@std@@YAPAUMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@PAU12@00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@MV?$allocator@M@std@@@std@@YAXPAM0AAV?$allocator@M@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@M@std@@YAPAMIPAM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@EPAU__TAXDETAIL@@U?$less@E@std@@V?$allocator@U?$pair@$$CBEPAU__TAXDETAIL@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@EPAU__TAXDETAIL@@U?$less@E@std@@V?$allocator@U?$pair@$$CBEPAU__TAXDETAIL@@@std@@@3@$0A@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@PAVITestCase@@V?$allocator@PAVITestCase@@@std@@@std@@YAXPAPAVITestCase@@0AAV?$allocator@PAVITestCase@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@PAVITestCase@@@std@@YAPAPAVITestCase@@IPAPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?0PAVCUser@@@?$allocator@PAU_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCUser@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@U_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@@std@@YAPAU_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@0@IPAU120@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Construct@PAU_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@0@ABQAU120@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@PAU_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@@std@@YAXPAPAU_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@YAXPAU__ITEMINFO@@0AAV?$allocator@U__ITEMINFO@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ucopy@PAU__ITEMINFO@@@?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@IAEPAU__ITEMINFO@@PAU2@00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$fill@PAU__ITEMINFO@@U1@@std@@YAXPAU__ITEMINFO@@0ABU1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$copy_backward@PAU__ITEMINFO@@PAU1@@std@@YAPAU__ITEMINFO@@PAU1@00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@U__ITEMINFO@@@std@@YAPAU__ITEMINFO@@IPAU1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@$$CBKPAVCUser@@@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@$$CBKPAVCCtrl@@@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@$$CBHH@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHH@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@0@IPAU120@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@0@ABQAU120@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@PAUtagACTMSG@@@std@@YAXPAPAUtagACTMSG@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@PAUtagMAGICATKMSG@@@std@@YAXPAPAUtagMAGICATKMSG@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?0PAU__JOINPLAYER@CGuildCombat@@@?$allocator@U_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@@std@@QAE@ABV?$allocator@PAU__JOINPLAYER@CGuildCombat@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@V?$allocator@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@std@@@std@@YAXPAUMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@0AAV?$allocator@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@std@@YAPAUMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@IPAU12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@0@IPAU120@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@$$CBKPAVCClientSock@@@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@$$CBKPAVCClientSockE@@@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@$$CBEPAU__TAXDETAIL@@@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@EPAU__TAXDETAIL@@U?$less@E@std@@V?$allocator@U?$pair@$$CBEPAU__TAXDETAIL@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBEPAU__TAXDETAIL@@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@EPAU__TAXDETAIL@@U?$less@E@std@@V?$allocator@U?$pair@$$CBEPAU__TAXDETAIL@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@EPAU__TAXDETAIL@@U?$less@E@std@@V?$allocator@U?$pair@$$CBEPAU__TAXDETAIL@@@std@@@3@$0A@@std@@@0@IPAU120@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?0PAVCUser@@@?$allocator@U_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCUser@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@$$CBKPAVCUser@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@0@ABQAU120@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@$$CBKPAVCCtrl@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@0@ABQAU120@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@$$CBKPAVCClientSock@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@0@IPAU120@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@0@ABQAU120@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@$$CBKPAVCClientSockE@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@0@IPAU120@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@0@ABQAU120@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@$$CBEPAU__TAXDETAIL@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@EPAU__TAXDETAIL@@U?$less@E@std@@V?$allocator@U?$pair@$$CBEPAU__TAXDETAIL@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBEPAU__TAXDETAIL@@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@EPAU__TAXDETAIL@@U?$less@E@std@@V?$allocator@U?$pair@$$CBEPAU__TAXDETAIL@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@EPAU__TAXDETAIL@@U?$less@E@std@@V?$allocator@U?$pair@$$CBEPAU__TAXDETAIL@@@std@@@3@$0A@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@EPAU__TAXDETAIL@@U?$less@E@std@@V?$allocator@U?$pair@$$CBEPAU__TAXDETAIL@@@std@@@3@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@EPAU__TAXDETAIL@@U?$less@E@std@@V?$allocator@U?$pair@$$CBEPAU__TAXDETAIL@@@std@@@3@$0A@@std@@@0@ABQAU120@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$CFixedArray@UtagWORLD@@@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0bad_weak_ptr@boost@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@UtagDROPITEM@@@std@@QAEXPAUtagDROPITEM@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@UWORMON@@@std@@QAEXPAUWORMON@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@U__ITEMGAME@CMiniGame@@@std@@QAEXPAU__ITEMGAME@CMiniGame@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@U__ITEM@CExchange@@@std@@QAEXPAU__ITEM@CExchange@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@U__POINT@CExchange@@@std@@QAEXPAU__POINT@CExchange@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$vector@EV?$allocator@E@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$vector@EV?$allocator@E@std@@@std@@QAE?AViterator@12@V312@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?construct@?$allocator@U__SPAWNREGION@CEventLua@@@std@@QAEXPAU__SPAWNREGION@CEventLua@@ABU34@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@U__SPAWNREGION@CEventLua@@@std@@QAEXPAU__SPAWNREGION@CEventLua@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@UD3DXVECTOR3@@@std@@QAEXPAUD3DXVECTOR3@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@U_GIFTBOX@@@std@@QAEXPAU_GIFTBOX@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$pair@KPAVCGuildHouseBase@@@std@@QAE@ABKABQAVCGuildHouseBase@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$pair@EPAU__TAXDETAIL@@@std@@QAE@ABEABQAU__TAXDETAIL@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$pair@KPAVCUser@@@std@@QAE@ABKABQAVCUser@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$vector@EV?$allocator@E@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$vector@EV?$allocator@E@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$insert@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@QAEXViterator@01@Vconst_iterator@01@1@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@PAE@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAVconst_iterator@?$vector@EV?$allocator@E@std@@@0@AAPAE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@PAEV?$allocator@E@3@@std@@YAPAEVconst_iterator@?$vector@EV?$allocator@E@std@@@0@0PAEAAV?$allocator@E@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@JJ@std@@YAPAJPAJ00AAV?$allocator@J@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PAU__SPAWNREGION@CEventLua@@PAU12@V?$allocator@U__SPAWNREGION@CEventLua@@@std@@@std@@YAPAU__SPAWNREGION@CEventLua@@PAU12@00AAV?$allocator@U__SPAWNREGION@CEventLua@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$fill_n@PAJIJ@std@@YAXPAJIABJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Copy_opt@PAKPAK@std@@YAPAKPAK00U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_copy@PAKPAKV?$allocator@K@std@@@std@@YAPAKPAK00AAV?$allocator@K@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Iter_cat@Viterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@@std@@YA?AUbidirectional_iterator_tag@0@ABViterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Distance2@Viterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@I@std@@YAXViterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@0@0AAIUbidirectional_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Iter_cat@Viterator@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@@std@@YA?AUbidirectional_iterator_tag@0@ABViterator@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Distance2@Viterator@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@I@std@@YAXViterator@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@0@0AAIUbidirectional_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_fill_n@KIK@std@@YAXPAKIABKAAV?$allocator@K@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_fill_n@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IABV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAUMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_fill_n@PAUMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@IU12@V?$allocator@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@std@@@std@@YAXPAUMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@IABU12@AAV?$allocator@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAU__ITEMINFO@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU__ITEMINFO@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_fill_n@PAU__ITEMINFO@@IU1@V?$allocator@U__ITEMINFO@@@std@@@std@@YAXPAU__ITEMINFO@@IABU1@AAV?$allocator@U__ITEMINFO@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAKPAK@std@@YAPAKPAK00U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@U__JOINPLAYER@CGuildCombat@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAU__JOINPLAYER@CGuildCombat@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@YAXPAPAU__JOINPLAYER@CGuildCombat@@0AAV?$allocator@PAU__JOINPLAYER@CGuildCombat@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAU__REQUESTGUILD@CGuildCombat@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU__REQUESTGUILD@CGuildCombat@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@YAXPAU__REQUESTGUILD@CGuildCombat@@0AAV?$allocator@U__REQUESTGUILD@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAU__SECRETROOM_MONSTER@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU__SECRETROOM_MONSTER@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@U__SECRETROOM_MONSTER@@V?$allocator@U__SECRETROOM_MONSTER@@@std@@@std@@YAXPAU__SECRETROOM_MONSTER@@0AAV?$allocator@U__SECRETROOM_MONSTER@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_copy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_copy@PAUMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@PAU12@V?$allocator@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@std@@@std@@YAPAUMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@PAU12@00AAV?$allocator@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAUMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@PAU12@@std@@YAPAUMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@PAU12@00U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@MV?$allocator@M@std@@@std@@YAXPAM0AAV?$allocator@M@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@VITestCase@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVITestCase@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@PAVITestCase@@V?$allocator@PAVITestCase@@@std@@@std@@YAXPAPAVITestCase@@0AAV?$allocator@PAVITestCase@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@YAXPAU__ITEMINFO@@0AAV?$allocator@U__ITEMINFO@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_copy@PAU__ITEMINFO@@PAU1@V?$allocator@U__ITEMINFO@@@std@@@std@@YAPAU__ITEMINFO@@PAU1@00AAV?$allocator@U__ITEMINFO@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAU__ITEMINFO@@PAU1@@std@@YAPAU__ITEMINFO@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@V?$allocator@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@std@@@std@@YAXPAUMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@0AAV?$allocator@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@UtagDROPITEM@@@std@@YAXPAUtagDROPITEM@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@UWORMON@@@std@@YAXPAUWORMON@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@U__ITEMGAME@CMiniGame@@@std@@YAXPAU__ITEMGAME@CMiniGame@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@U__ITEM@CExchange@@@std@@YAXPAU__ITEM@CExchange@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@U__POINT@CExchange@@@std@@YAXPAU__POINT@CExchange@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$copy@PAEPAE@std@@YAPAEPAE00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Construct@U__SPAWNREGION@CEventLua@@U12@@std@@YAXPAU__SPAWNREGION@CEventLua@@ABU12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@U__SPAWNREGION@CEventLua@@@std@@YAXPAU__SPAWNREGION@CEventLua@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@UD3DXVECTOR3@@@std@@YAXPAUD3DXVECTOR3@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@U_GIFTBOX@@@std@@YAXPAU_GIFTBOX@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?construct@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@ABV32@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?construct@?$allocator@E@std@@QAEXPAEABE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@E@std@@QAEXPAE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Econst_iterator@?$vector@EV?$allocator@E@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@QAEXPAU__REQUESTGUILD@CGuildCombat@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@U__SECRETROOM_MONSTER@@@std@@QAEXPAU__SECRETROOM_MONSTER@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?construct@?$allocator@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@std@@QAEXPAUMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@ABU34@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@std@@QAEXPAUMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?construct@?$allocator@U__ITEMINFO@@@std@@QAEXPAU__ITEMINFO@@ABU3@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@U__ITEMINFO@@@std@@QAEXPAU__ITEMINFO@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Insert@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@QAEXViterator@01@Vconst_iterator@01@1Uforward_iterator_tag@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@KK@std@@YAPAKPAK00AAV?$allocator@K@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$fill_n@PAKIK@std@@YAXPAKIABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PAUMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@PAU12@V?$allocator@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@std@@@std@@YAPAUMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@PAU12@00AAV?$allocator@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PAU__ITEMINFO@@PAU1@V?$allocator@U__ITEMINFO@@@std@@@std@@YAPAU__ITEMINFO@@PAU1@00AAV?$allocator@U__ITEMINFO@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Copy_opt@PAEPAE@std@@YAPAEPAE00U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Construct@EE@std@@YAXPAEABE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@E@std@@YAXPAE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@U__REQUESTGUILD@CGuildCombat@@@std@@YAXPAU__REQUESTGUILD@CGuildCombat@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@U__SECRETROOM_MONSTER@@@std@@YAXPAU__SECRETROOM_MONSTER@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Construct@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@U12@@std@@YAXPAUMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@ABU12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@std@@YAXPAUMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Construct@U__ITEMINFO@@U1@@std@@YAXPAU__ITEMINFO@@ABU1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@U__ITEMINFO@@@std@@YAXPAU__ITEMINFO@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Giterator@?$vector@EV?$allocator@E@std@@@std@@QBEHABVconst_iterator@12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Gconst_iterator@?$vector@EV?$allocator@E@std@@@std@@QBEHABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Distance@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@I@std@@YAXVconst_iterator@?$vector@EV?$allocator@E@std@@@0@0AAI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ucopy@PAE@?$vector@EV?$allocator@E@std@@@std@@IAEPAEPAE00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$advance@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@H@std@@YAXAAVconst_iterator@?$vector@EV?$allocator@E@std@@@0@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$copy@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@PAE@std@@YAPAEVconst_iterator@?$vector@EV?$allocator@E@std@@@0@0PAE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$copy_backward@PAEPAE@std@@YAPAEPAE00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Distance2@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@I@std@@YAXVconst_iterator@?$vector@EV?$allocator@E@std@@@0@0AAIUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_copy@PAEPAEV?$allocator@E@std@@@std@@YAPAEPAE00AAV?$allocator@E@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Advance@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@H@std@@YAXAAVconst_iterator@?$vector@EV?$allocator@E@std@@@0@HUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Copy_opt@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@PAE@std@@YAPAEVconst_iterator@?$vector@EV?$allocator@E@std@@@0@0PAEU_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAEPAE@std@@YAPAEPAE00U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Yconst_iterator@?$vector@EV?$allocator@E@std@@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@EE@std@@YAPAEPAE00AAV?$allocator@E@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SendDamageForce@CMover@@UAEHKKHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SendDamage@CMover@@UAEHKKHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SendDamage@CActionMover@@QAEHKKHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetIndex@CObj@@UAEHPAUIDirect3DDevice9@@KH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetName@CObj@@UAEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_05CJBACGMB@hello?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?deallocate@?$allocator@E@std@@QAEXPAEI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ucopy@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@IAEPAEVconst_iterator@01@0PAE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@E@std@@QAEPAEI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@E@std@@YAPAEIPAE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Xlen@?$vector@EV?$allocator@E@std@@@std@@IBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@E@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ptr_cat@std@@YA?AU_Scalar_ptr_iterator_tag@1@PAE0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Destroy@?$vector@EV?$allocator@E@std@@@std@@IAEXPAE0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@EV?$allocator@E@std@@@std@@YAXPAE0AAV?$allocator@E@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ptr_cat@std@@YA?AU_Scalar_ptr_iterator_tag@1@PAM0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@D@std@@YAPADIPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_Ptr_cat@std@@YA?AU_Scalar_ptr_iterator_tag@1@PAK0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __CTA2?AVbad_weak_ptr@boost@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT __CT??_R0?AVbad_weak_ptr@boost@@@8??0bad_weak_ptr@boost@@QAE@ABV01@@Z12
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_weak_ptr@boost@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT __TI2?AVbad_weak_ptr@boost@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_7?$CFixedArray@UtagWORLD@@@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_Ptr_cat@std@@YA?AU_Scalar_ptr_iterator_tag@1@PAJ0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Min@?$_Tree@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??5CAr@@QAEAAV0@AAE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@G@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?_Color@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@0@IPAU120@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Color@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@0@IPAU120@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$vector@EV?$allocator@E@std@@@std@@QAE@PAE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$swap@D@std@@YAXAAD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __TI3?AVout_of_range@std@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??1out_of_range@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7out_of_range@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_Gout_of_range@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1logic_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __CTA3?AVout_of_range@std@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R0?AVout_of_range@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??0out_of_range@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Color@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@K@std@@QAEPAKI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@K@std@@YAPAKIPAK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Xlen@?$vector@KV?$allocator@K@std@@@std@@IBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$vector@KV?$allocator@K@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@K@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lmost@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Rmost@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lmost@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Max@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Rmost@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Min@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lmost@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@KV?$allocator@K@std@@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Min@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Max@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAE?AV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?insert@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBKPAVCCtrl@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@1@AB_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Fiterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Fconst_iterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Rmost@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Kfn@?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@SAABKABU?$pair@$$CBKPAVCCtrl@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Insert@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBKPAVCCtrl@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBKPAVCCtrl@@@2@D@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBKPAVCCtrl@@@2@D@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?compare@?$char_traits@D@std@@SAHPBD0I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsEmpty@CItemBase@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@V312@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?clear@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@3@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Buy@?$vector@KV?$allocator@K@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@K@std@@QAEXPAKI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Destroy@?$vector@KV?$allocator@K@std@@@std@@IAEXPAK0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@KV?$allocator@K@std@@@std@@YAXPAK0AAV?$allocator@K@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QBEAAU?$pair@$$CBKPAVCCtrl@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QBEABU?$pair@$$CBKPAVCCtrl@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myval@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBKPAVCCtrl@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@3@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Key@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@KAABKPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lbound@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QBEAAU?$pair@$$CBKPAVCUser@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QBEABU?$pair@$$CBKPAVCUser@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myval@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBKPAVCUser@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@3@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Key@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@KAABKPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Kfn@?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@SAABKABU?$pair@$$CBKPAVCUser@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??R?$less@K@std@@QBE_NABK0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lbound@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AtlThrow@ATL@@YGXJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetLength@?$CSimpleStringT@D$0A@@ATL@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetData@?$CSimpleStringT@D$0A@@ATL@@ABEPAUCStringData@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetCampusPoint@CMover@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetCampusId@CMover@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAE?AV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetName@CPet@@QAEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetTutorialState@CMover@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_String_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetText@CProject@@QAEPBDK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LOG_RANGE@@YAXPBDHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0BM@HMFGHCP@?$CFs?5min?3?$CFd?0?5max?3?$CFd?0?5index?3?$CFd?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?GetSize@?$CFixedArray@UtagColorText@@@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0BE@OHDBLHOM@GetText?5range_error?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05KKCIMGE@error?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?GetAt@?$CFixedArray@UtagColorText@@@@QAEPAUtagColorText@@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetPosChanged@CObj@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetFlag@CObj@@AAEXHK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsEatPet@CItemElem@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsExpiring@CItemElem@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAt@?$CFixedArray@UQuestProp@@@@QAEPAUQuestProp@@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPropA@CItem@@QAEPAUItemProp@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Format@CTime@ATL@@QBE?AV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@2@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?lpOutputString@?8??OutputStatistics@CUserMng@@QAEXXZ@4PADA
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
;	COMDAT ??0CPoint@@QAE@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PtInRect@CRect@@QBEHUtagPOINT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPKPropensity@CMover@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetState@CAction@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAttrOption@CItemElem@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAngle@CObj@@QAEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?D3DXVec3LengthSq@@YAMPBUD3DXVECTOR3@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??GD3DXVECTOR3@@QBE?AU0@ABU0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsPlayer@CMover@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsFly@CMover@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsDie@CMover@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsDie@CAction@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsCollecting@CMover@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsAuthHigher@CMover@@QAEKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Min@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Max@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?insert@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBKPAVCUser@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Fiterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Fconst_iterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Insert@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBKPAVCUser@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBKPAVCUser@@@2@D@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBKPAVCUser@@@2@D@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@1@AB_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?clear@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Erase@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CUserMng@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?GetUserByID@CProject@@QAEPAVCMover@@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?find@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lbound@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Key@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@KAABKPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Kfn@?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@SAABKABU?$pair@$$CBKPAVCMover@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myval@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBKPAVCMover@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@3@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Citerator@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QBEPAU?$pair@$$CBKPAVCMover@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QBEAAU?$pair@$$CBKPAVCMover@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QBEABU?$pair@$$CBKPAVCMover@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@EV?$allocator@E@std@@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetMode@CMover@@QAEXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsChaotic@CMover@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetSerialNumber@CItemBase@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetExtra@CItemBase@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsAvailable@CPocketController@@QAEHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsExpired@CPocket@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsRegionAttr@CMover@@QAEHK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAbilityOption@CItemElem@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetActionState@CAction@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsFlag@CItemElem@@QAEHE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetOtherID@CVTInfo@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_LogItemInfo@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_GIFTBOXRESULT@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetFlag@CItemElem@@QAEXE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPropA@CItemElem@@QAEPAUItemProp@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetAbilityOption@CItemElem@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetTime@CTime@ATL@@QBE_JXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SerializePiercing@CItemElem@@QAEXAAVCAr@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetRandomOptItemId@CItemElem@@QAE_JXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPKValue@CMover@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetGold@CMover@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetTotalSeconds@CTimeSpan@ATL@@QBE_JXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??GCTime@ATL@@QBE?AVCTimeSpan@1@V01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CTimeSpan@ATL@@QAE@_J@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CTime@ATL@@QAE@_J@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetSex@CMover@@QAEEXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6CAr@@QAEAAV0@N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6CAr@@QAEAAV0@D@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6@YAAAVCAr@@AAV0@_J@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetExtra@CItemBase@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetOffset@CAr@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6CAr@@QAEAAV0@F@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetMethod@CObj@@SAXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetIndex@CObj@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@CObj@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6CAr@@QAEAAV0@E@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??B?$CSimpleStringT@D$0A@@ATL@@QBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CSimpleStringT@D$0A@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Release@CStringData@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CSimpleStringT@D$0A@@ATL@@QAE@PAUIAtlStringMgr@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Attach@?$CSimpleStringT@D$0A@@ATL@@AAEXPAUCStringData@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?data@CStringData@ATL@@QAEPAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetDefaultManager@?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@SAPAUIAtlStringMgr@ATL@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CheckImplicitLoad@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@AAE_NPBX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LoadStringA@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEHI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FindStringResourceInstance@?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@SAPAUHINSTANCE__@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LoadStringA@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEHPAUHINSTANCE__@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AtlGetStringResourceImage@ATL@@YAPBUATLSTRINGRESOURCEIMAGE@1@PAUHINSTANCE__@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_AtlGetStringResourceImage@ATL@@YAPBUATLSTRINGRESOURCEIMAGE@1@PAUHINSTANCE__@@PAUHRSRC__@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetBaseTypeLength@?$ChTraitsCRT@D@ATL@@SAHPBGH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_AtlGetConversionACP@ATL@@YGIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?g_pfnGetThreadACP@ATL@@3P6GIXZA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?_AtlGetThreadACPThunk@ATL@@YGIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_AtlGetThreadACPReal@ATL@@YGIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_AtlGetThreadACPFake@ATL@@YGIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InterlockedExchangePointer@@YGPAXPAPAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetBuffer@?$CSimpleStringT@D$0A@@ATL@@QAEPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PrepareWrite@?$CSimpleStringT@D$0A@@ATL@@AAEPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PrepareWrite2@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsShared@CStringData@ATL@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Fork@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ThrowMemoryException@?$CSimpleStringT@D$0A@@ATL@@KAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CopyChars@?$CSimpleStringT@D$0A@@ATL@@SAXPADPBDH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Reallocate@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ConvertToBaseType@?$ChTraitsCRT@D@ATL@@SAXPADHPBGH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ReleaseBufferSetLength@?$CSimpleStringT@D$0A@@ATL@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetLength@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$CSimpleStringT@D$0A@@ATL@@QAEAAV01@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetString@?$CSimpleStringT@D$0A@@ATL@@QAEXPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetString@?$CSimpleStringT@D$0A@@ATL@@QAEXPBDH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Empty@?$CSimpleStringT@D$0A@@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsLocked@CStringData@ATL@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetString@?$CSimpleStringT@D$0A@@ATL@@QBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CopyCharsOverlapped@?$CSimpleStringT@D$0A@@ATL@@SAXPADPBDH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StringLength@?$CSimpleStringT@D$0A@@ATL@@SAHPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?uOffset@?5??Notify@CUser@@QAEHXZ@4IA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?IsValidObj@@YAHPAVCObj@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetEatPetId@CMover@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?HasActivatedEatPet@CMover@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetPKPink@CMover@@QAEXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPKPink@CMover@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsPKPink@CMover@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetLayer@CObj@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsFly@CAction@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ClearDestAngle@CMover@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ClearDest@CMover@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ClearDestObj@CMover@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ClearDestPos@CMover@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SendActMsg@CMover@@QAEHW4OBJMSG@@HHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsStateFlag@CAction@@QAEHK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsLive@CMover@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetID@CWorld@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetWorld@CObj@@QAEPAVCWorld@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetItemProp@CProject@@QAEPAUItemProp@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetSize@?$CFixedArray@UItemProp@@@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0BI@BEIFNGEL@GetItemProp?5range_error?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?LOG_CALLSTACK@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAt@?$CFixedArray@UItemProp@@@@QAEPAUItemProp@@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?GetAtId@?$CItemContainer@VCItemElem@@@@QAEPAVCItemElem@@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsStateMode@CMover@@QAEHK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetNotMode@CMover@@QAEXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsMode@CMover@@QAEHK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPos@CObj@@QAE?AUD3DXVECTOR3@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PCSetAt@CCtrl@@QAEXKPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$map@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@@std@@QAEAAPAVCUser@@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?insert@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@ABU?$pair@$$CBKPAVCUser@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$pair@$$CBKPAVCUser@@@std@@QAE@ABKABQAVCUser@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?clear@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Erase@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetId@CCtrl@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PCRemoveKey@CCtrl@@QAEHK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAEIABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?equal_range@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@V123@@2@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@V123@@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@1@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?upper_bound@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ubound@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Distance@Viterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@I@std@@YAXViterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@0@0AAI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Citerator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QBEPAU?$pair@$$CBKPAVCCtrl@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetMaxExp1@CMover@@QAE_JXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetExp1@CMover@@QAE_JXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetLevel@CMover@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsDelete@CObj@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CUser@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CCouple@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CCoupleTestCase@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CTestCaseMgr@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ITestCase@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??0CTimeSpan@ATL@@QAE@JHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??HCTime@ATL@@QBE?AV01@VCTimeSpan@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetTimeSpan@CTimeSpan@ATL@@QBE_JXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CLordSkillComponentTeleport@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CLordSkillComponentSummon@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CLordSkillComponentItemBuf@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Vector_val@HV?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@H@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@H@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@H@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Xlen@?$vector@HV?$allocator@H@std@@@std@@IBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@H@std@@QAEPAHI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@H@std@@YAPAHIPAH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@HV?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ptr_cat@std@@YA?AU_Scalar_ptr_iterator_tag@1@PAH0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@H@std@@QAEXPAHI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CLordSkillComponentExecutable@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7bad_weak_ptr@boost@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7sp_counted_base@detail@boost@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CMapChildE@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?Leave@CMclCritSec@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Enter@CMclCritSec@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CMclCritSec@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CMclCritSec@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_GCMclCritSec@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CMclCritSec@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CMapChild@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??1CMclAutoLock@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CMclAutoLock@@QAE@AAVCMclCritSec@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CBuffer2@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAEIABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?equal_range@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@V123@@2@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@V123@@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@1@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?upper_bound@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ubound@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Distance@Viterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@I@std@@YAXViterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@0@0AAI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??5@YAAAVCAr@@AAV0@AAUD3DXVECTOR3@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??5CAr@@QAEAAV0@AAM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??5CAr@@QAEAAV0@AAJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?time_null@@YAJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6CAr@@QAEAAV0@J@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6@YAAAVCAr@@AAV0@UD3DXVECTOR3@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6CAr@@QAEAAV0@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?length@?$char_traits@D@std@@SAIPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6CAr@@QAEAAV0@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7__MINIGAME_EXT_PACKET@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??5CAr@@QAEAAV0@AAG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??5CAr@@QAEAAV0@AAH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6CAr@@QAEAAV0@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6CAr@@QAEAAV0@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7__MINIGAME_PACKET@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??1?$vector@KV?$allocator@K@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$vector@KV?$allocator@K@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Vector_val@KV?$allocator@K@std@@@std@@IAE@V?$allocator@K@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@K@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@K@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??5CAr@@QAEAAV0@AAK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6CAr@@QAEAAV0@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsStoring@CAr@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0D3DXVECTOR3@@QAE@MMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetTickCount@CTime@ATL@@SG?AV12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0D3DXVECTOR3@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CTime@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
sxdata	SEGMENT DWORD USE32 'SXDATA'
sxdata	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?g_pfnGetThreadACP@ATL@@3P6GIXZA		; ATL::g_pfnGetThreadACP
PUBLIC	?_AtlGetThreadACPThunk@ATL@@YGIXZ		; ATL::_AtlGetThreadACPThunk
;	COMDAT ?g_pfnGetThreadACP@ATL@@3P6GIXZA
_DATA	SEGMENT
?g_pfnGetThreadACP@ATL@@3P6GIXZA DD FLAT:?_AtlGetThreadACPThunk@ATL@@YGIXZ ; ATL::g_pfnGetThreadACP
_DATA	ENDS
PUBLIC	?GetSizeofMember@CParty@@QAEHXZ			; CParty::GetSizeofMember
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\party.h
;	COMDAT ?GetSizeofMember@CParty@@QAEHXZ
_TEXT	SEGMENT
?GetSizeofMember@CParty@@QAEHXZ PROC NEAR		; CParty::GetSizeofMember, COMDAT
; _this$ = ecx

; 121  : 	int		GetSizeofMember()					{	return m_nSizeofMember;		}

  00000	8b 81 cc 01 00
	00		 mov	 eax, DWORD PTR [ecx+460]
  00006	c3		 ret	 0
?GetSizeofMember@CParty@@QAEHXZ ENDP			; CParty::GetSizeofMember
_TEXT	ENDS
PUBLIC	??2@YAPAXIPAX@Z					; operator new
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\new.h
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__P$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC NEAR				; operator new, COMDAT

; 109  :         {return (_P); }

  00000	8b 44 24 08	 mov	 eax, DWORD PTR __P$[esp-4]
  00004	c3		 ret	 0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
PUBLIC	??3@YAXPAX0@Z					; operator delete
; Function compile flags: /Ogty
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC NEAR					; operator delete, COMDAT

; 112  :         {return; }

  00000	c3		 ret	 0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
PUBLIC	?IsMaster@CGuild@@QAEHK@Z			; CGuild::IsMaster
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\guild.h
;	COMDAT ?IsMaster@CGuild@@QAEHK@Z
_TEXT	SEGMENT
_idPlayer$ = 8						; size = 4
?IsMaster@CGuild@@QAEHK@Z PROC NEAR			; CGuild::IsMaster, COMDAT
; _this$ = ecx

; 309  : 	BOOL	IsMaster( u_long idPlayer )	{	return( m_idMaster == idPlayer );	}

  00000	8b 49 44	 mov	 ecx, DWORD PTR [ecx+68]
  00003	8b 54 24 04	 mov	 edx, DWORD PTR _idPlayer$[esp-4]
  00007	33 c0		 xor	 eax, eax
  00009	3b ca		 cmp	 ecx, edx
  0000b	0f 94 c0	 sete	 al
  0000e	c2 04 00	 ret	 4
?IsMaster@CGuild@@QAEHK@Z ENDP				; CGuild::IsMaster
_TEXT	ENDS
PUBLIC	?GetChattingMember@CChatting@@QAEHXZ		; CChatting::GetChattingMember
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\chatting.h
;	COMDAT ?GetChattingMember@CChatting@@QAEHXZ
_TEXT	SEGMENT
?GetChattingMember@CChatting@@QAEHXZ PROC NEAR		; CChatting::GetChattingMember, COMDAT
; _this$ = ecx

; 37   : 	int		GetChattingMember() { return m_nSizeofMember; }

  00000	8b 41 28	 mov	 eax, DWORD PTR [ecx+40]
  00003	c3		 ret	 0
?GetChattingMember@CChatting@@QAEHXZ ENDP		; CChatting::GetChattingMember
_TEXT	ENDS
PUBLIC	?InterlockedExchangePointer@@YGPAXPAPAXPAX@Z	; InterlockedExchangePointer
EXTRN	__imp__InterlockedExchange@8:NEAR
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlconv.h
;	COMDAT ?InterlockedExchangePointer@@YGPAXPAPAXPAX@Z
_TEXT	SEGMENT
_pp$ = 8						; size = 4
_pNew$ = 12						; size = 4
?InterlockedExchangePointer@@YGPAXPAPAXPAX@Z PROC NEAR	; InterlockedExchangePointer, COMDAT

; 92   : 	return( reinterpret_cast<void*>(static_cast<LONG_PTR>(::InterlockedExchange(reinterpret_cast<LONG*>(pp), static_cast<LONG>(reinterpret_cast<LONG_PTR>(pNew))))) );

  00000	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp__InterlockedExchange@8
?InterlockedExchangePointer@@YGPAXPAPAXPAX@Z ENDP	; InterlockedExchangePointer
_TEXT	ENDS
PUBLIC	?_AtlGetThreadACPFake@ATL@@YGIXZ		; ATL::_AtlGetThreadACPFake
EXTRN	__imp__GetThreadLocale@0:NEAR
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:NEAR
EXTRN	__imp__GetACP@0:NEAR
EXTRN	__imp__GetLocaleInfoA@16:NEAR
; Function compile flags: /Ogty
;	COMDAT ?_AtlGetThreadACPFake@ATL@@YGIXZ
_TEXT	SEGMENT
_szACP$ = -12						; size = 7
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
?_AtlGetThreadACPFake@ATL@@YGIXZ PROC NEAR		; ATL::_AtlGetThreadACPFake, COMDAT

; 101  : {

  00000	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00008	33 c4		 xor	 eax, esp
  0000a	56		 push	 esi
  0000b	89 44 24 0c	 mov	 DWORD PTR __$ArrayPad$[esp+16], eax

; 102  : 	UINT nACP = 0;

  0000f	33 f6		 xor	 esi, esi

; 103  : 
; 104  : 	LCID lcidThread = ::GetThreadLocale();

  00011	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetThreadLocale@0

; 105  : 
; 106  : 	char szACP[7];
; 107  : 	// GetLocaleInfoA will fail for a Unicode-only LCID, but those are only supported on 
; 108  : 	// Windows 2000.  Since Windows 2000 supports CP_THREAD_ACP, this code path is never
; 109  : 	// executed on Windows 2000.
; 110  : 	if (::GetLocaleInfoA(lcidThread, LOCALE_IDEFAULTANSICODEPAGE, szACP, 7) != 0)

  00017	6a 07		 push	 7
  00019	8d 4c 24 08	 lea	 ecx, DWORD PTR _szACP$[esp+20]
  0001d	51		 push	 ecx
  0001e	68 04 10 00 00	 push	 4100			; 00001004H
  00023	50		 push	 eax
  00024	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLocaleInfoA@16
  0002a	85 c0		 test	 eax, eax
  0002c	74 27		 je	 SHORT $L296144

; 111  : 	{
; 112  : 		char* pch = szACP;
; 113  : 		while (*pch != '\0')

  0002e	8a 44 24 04	 mov	 al, BYTE PTR _szACP$[esp+16]
  00032	84 c0		 test	 al, al
  00034	8d 4c 24 04	 lea	 ecx, DWORD PTR _szACP$[esp+16]
  00038	74 1b		 je	 SHORT $L296144
  0003a	8d 9b 00 00 00
	00		 npad	 6
$L38556:

; 114  : 		{
; 115  : 			nACP *= 10;
; 116  : 			nACP += *pch++ - '0';

  00040	0f be c0	 movsx	 eax, al
  00043	8d 14 b6	 lea	 edx, DWORD PTR [esi+esi*4]
  00046	41		 inc	 ecx
  00047	8d 74 50 d0	 lea	 esi, DWORD PTR [eax+edx*2-48]
  0004b	8a 01		 mov	 al, BYTE PTR [ecx]
  0004d	84 c0		 test	 al, al
  0004f	75 ef		 jne	 SHORT $L38556

; 117  : 		}
; 118  : 	}
; 119  : 	// Use the Default ANSI Code Page if we were unable to get the thread ACP or if one does not exist.
; 120  : 	if (nACP == 0)

  00051	85 f6		 test	 esi, esi
  00053	75 16		 jne	 SHORT $L296145
$L296144:

; 121  : 		nACP = ::GetACP();

  00055	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetACP@0
  0005b	5e		 pop	 esi

; 122  : 
; 123  : 	return nACP;
; 124  : }

  0005c	8b 4c 24 08	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+12]
  00060	33 cc		 xor	 ecx, esp
  00062	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00067	83 c4 0c	 add	 esp, 12			; 0000000cH
  0006a	c3		 ret	 0
$L296145:
  0006b	8b 4c 24 0c	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+16]
  0006f	8b c6		 mov	 eax, esi
  00071	5e		 pop	 esi
  00072	33 cc		 xor	 ecx, esp
  00074	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00079	83 c4 0c	 add	 esp, 12			; 0000000cH
  0007c	c3		 ret	 0
?_AtlGetThreadACPFake@ATL@@YGIXZ ENDP			; ATL::_AtlGetThreadACPFake
_TEXT	ENDS
PUBLIC	?_AtlGetThreadACPReal@ATL@@YGIXZ		; ATL::_AtlGetThreadACPReal
; Function compile flags: /Ogty
;	COMDAT ?_AtlGetThreadACPReal@ATL@@YGIXZ
_TEXT	SEGMENT
?_AtlGetThreadACPReal@ATL@@YGIXZ PROC NEAR		; ATL::_AtlGetThreadACPReal, COMDAT

; 128  : 	return( CP_THREAD_ACP );

  00000	b8 03 00 00 00	 mov	 eax, 3

; 129  : }

  00005	c3		 ret	 0
?_AtlGetThreadACPReal@ATL@@YGIXZ ENDP			; ATL::_AtlGetThreadACPReal
_TEXT	ENDS
EXTRN	__imp__GetVersionExA@4:NEAR
; Function compile flags: /Ogty
;	COMDAT ?_AtlGetThreadACPThunk@ATL@@YGIXZ
_TEXT	SEGMENT
_ver$ = -152						; size = 148
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
?_AtlGetThreadACPThunk@ATL@@YGIXZ PROC NEAR		; ATL::_AtlGetThreadACPThunk, COMDAT

; 134  : {

  00000	81 ec 98 00 00
	00		 sub	 esp, 152		; 00000098H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c4		 xor	 eax, esp
  0000d	89 84 24 94 00
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+152], eax

; 135  : 	OSVERSIONINFO ver;
; 136  : 	ATLGETTHREADACP pfnGetThreadACP;
; 137  : 
; 138  : 	ver.dwOSVersionInfoSize = sizeof( ver );
; 139  : 	::GetVersionEx( &ver );

  00014	8d 04 24	 lea	 eax, DWORD PTR _ver$[esp+152]
  00017	50		 push	 eax
  00018	c7 44 24 04 94
	00 00 00	 mov	 DWORD PTR _ver$[esp+156], 148 ; 00000094H
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetVersionExA@4

; 140  : 	if( (ver.dwPlatformId == VER_PLATFORM_WIN32_NT) && (ver.dwMajorVersion >= 5) )

  00026	83 7c 24 10 02	 cmp	 DWORD PTR _ver$[esp+168], 2
  0002b	75 0c		 jne	 SHORT $L38566
  0002d	83 7c 24 04 05	 cmp	 DWORD PTR _ver$[esp+156], 5

; 141  : 	{
; 142  : 		// On Win2K, CP_THREAD_ACP is supported
; 143  : 		pfnGetThreadACP = _AtlGetThreadACPReal;

  00032	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?_AtlGetThreadACPReal@ATL@@YGIXZ ; ATL::_AtlGetThreadACPReal
  00037	73 05		 jae	 SHORT $L38567
$L38566:

; 144  : 	}
; 145  : 	else
; 146  : 	{
; 147  : 		pfnGetThreadACP = _AtlGetThreadACPFake;

  00039	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?_AtlGetThreadACPFake@ATL@@YGIXZ ; ATL::_AtlGetThreadACPFake
$L38567:

; 148  : 	}
; 149  : 	InterlockedExchangePointer( reinterpret_cast< void** >(&g_pfnGetThreadACP), pfnGetThreadACP );

  0003e	50		 push	 eax
  0003f	68 00 00 00 00	 push	 OFFSET FLAT:?g_pfnGetThreadACP@ATL@@3P6GIXZA ; ATL::g_pfnGetThreadACP
  00044	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InterlockedExchange@8

; 150  : 
; 151  : 	return( g_pfnGetThreadACP() );

  0004a	ff 15 00 00 00
	00		 call	 DWORD PTR ?g_pfnGetThreadACP@ATL@@3P6GIXZA ; ATL::g_pfnGetThreadACP

; 152  : }

  00050	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+152]
  00057	33 cc		 xor	 ecx, esp
  00059	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0005e	81 c4 98 00 00
	00		 add	 esp, 152		; 00000098H
  00064	c3		 ret	 0
?_AtlGetThreadACPThunk@ATL@@YGIXZ ENDP			; ATL::_AtlGetThreadACPThunk
_TEXT	ENDS
PUBLIC	?_AtlGetConversionACP@ATL@@YGIXZ		; ATL::_AtlGetConversionACP
; Function compile flags: /Ogty
;	COMDAT ?_AtlGetConversionACP@ATL@@YGIXZ
_TEXT	SEGMENT
?_AtlGetConversionACP@ATL@@YGIXZ PROC NEAR		; ATL::_AtlGetConversionACP, COMDAT

; 158  : 	return( g_pfnGetThreadACP() );

  00000	ff 25 00 00 00
	00		 jmp	 DWORD PTR ?g_pfnGetThreadACP@ATL@@3P6GIXZA ; ATL::g_pfnGetThreadACP
?_AtlGetConversionACP@ATL@@YGIXZ ENDP			; ATL::_AtlGetConversionACP
_TEXT	ENDS
PUBLIC	?IsMaster@CCampus@@QAEHK@Z			; CCampus::IsMaster
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\campus.h
;	COMDAT ?IsMaster@CCampus@@QAEHK@Z
_TEXT	SEGMENT
_idPlayer$ = 8						; size = 4
?IsMaster@CCampus@@QAEHK@Z PROC NEAR			; CCampus::IsMaster, COMDAT
; _this$ = ecx

; 54   : 	BOOL	IsMaster( u_long idPlayer )		{	return ( idPlayer == m_idMaster );	}

  00000	8b 54 24 04	 mov	 edx, DWORD PTR _idPlayer$[esp-4]
  00004	56		 push	 esi
  00005	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  00008	33 c0		 xor	 eax, eax
  0000a	3b d6		 cmp	 edx, esi
  0000c	0f 94 c0	 sete	 al
  0000f	5e		 pop	 esi
  00010	c2 04 00	 ret	 4
?IsMaster@CCampus@@QAEHK@Z ENDP				; CCampus::IsMaster
_TEXT	ENDS
PUBLIC	?GetCampus@CCampusHelper@@QAEPAVCCampus@@K@Z	; CCampusHelper::GetCampus
EXTRN	?GetCampus@CCampusMng@@QAEPAVCCampus@@K@Z:NEAR	; CCampusMng::GetCampus
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\campushelper.h
;	COMDAT ?GetCampus@CCampusHelper@@QAEPAVCCampus@@K@Z
_TEXT	SEGMENT
_idCampus$ = 8						; size = 4
?GetCampus@CCampusHelper@@QAEPAVCCampus@@K@Z PROC NEAR	; CCampusHelper::GetCampus, COMDAT
; _this$ = ecx

; 41   : 	CCampus*	GetCampus( u_long idCampus )	{	return m_pCampusMng->GetCampus( idCampus );	}

  00000	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00002	e9 00 00 00 00	 jmp	 ?GetCampus@CCampusMng@@QAEPAVCCampus@@K@Z ; CCampusMng::GetCampus
?GetCampus@CCampusHelper@@QAEPAVCCampus@@K@Z ENDP	; CCampusHelper::GetCampus
_TEXT	ENDS
PUBLIC	?SetValid@CUser@@QAEXH@Z			; CUser::SetValid
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.h
;	COMDAT ?SetValid@CUser@@QAEXH@Z
_TEXT	SEGMENT
_bValid$ = 8						; size = 4
?SetValid@CUser@@QAEXH@Z PROC NEAR			; CUser::SetValid, COMDAT
; _this$ = ecx

; 198  : 	void			SetValid( BOOL bValid ) { m_bValid = bValid; }

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _bValid$[esp-4]
  00004	89 81 e8 16 00
	00		 mov	 DWORD PTR [ecx+5864], eax
  0000a	c2 04 00	 ret	 4
?SetValid@CUser@@QAEXH@Z ENDP				; CUser::SetValid
_TEXT	ENDS
PUBLIC	?GetInput@CUser@@QAEPADXZ			; CUser::GetInput
; Function compile flags: /Ogty
;	COMDAT ?GetInput@CUser@@QAEPADXZ
_TEXT	SEGMENT
?GetInput@CUser@@QAEPADXZ PROC NEAR			; CUser::GetInput, COMDAT
; _this$ = ecx

; 563  : 	char*	GetInput()	{	return m_szInput;	}

  00000	8d 81 44 96 00
	00		 lea	 eax, DWORD PTR [ecx+38468]
  00006	c3		 ret	 0
?GetInput@CUser@@QAEPADXZ ENDP				; CUser::GetInput
_TEXT	ENDS
PUBLIC	?AtlThrow@ATL@@YGXJ@Z				; ATL::AtlThrow
EXTRN	?AfxThrowMemoryException@@YGXXZ:NEAR		; AfxThrowMemoryException
EXTRN	?AfxThrowOleException@@YGXJ@Z:NEAR		; AfxThrowOleException
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlexcept.h
;	COMDAT ?AtlThrow@ATL@@YGXJ@Z
_TEXT	SEGMENT
_hr$ = 8						; size = 4
?AtlThrow@ATL@@YGXJ@Z PROC NEAR				; ATL::AtlThrow, COMDAT

; 62   : 	ATLTRACE(atlTraceException, 0, _T("AtlThrow: hr = 0x%x\n"), hr );
; 63   : #ifdef _AFX
; 64   : 	if( hr == E_OUTOFMEMORY )

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _hr$[esp-4]
  00004	3d 0e 00 07 80	 cmp	 eax, -2147024882	; 8007000eH
  00009	75 05		 jne	 SHORT $L39168

; 65   : 	{
; 66   : 		AfxThrowMemoryException();

  0000b	e8 00 00 00 00	 call	 ?AfxThrowMemoryException@@YGXXZ ; AfxThrowMemoryException
$L296181:
$L39168:

; 67   : 	}
; 68   : 	else
; 69   : 	{
; 70   : 		AfxThrowOleException( hr );

  00010	50		 push	 eax
  00011	e8 00 00 00 00	 call	 ?AfxThrowOleException@@YGXJ@Z ; AfxThrowOleException
$L296182:
$L296180:
  00016	cc		 int	 3
?AtlThrow@ATL@@YGXJ@Z ENDP				; ATL::AtlThrow
_TEXT	ENDS
PUBLIC	?_AtlGetStringResourceImage@ATL@@YAPBUATLSTRINGRESOURCEIMAGE@1@PAUHINSTANCE__@@PAUHRSRC__@@I@Z ; ATL::_AtlGetStringResourceImage
EXTRN	__imp__LoadResource@8:NEAR
EXTRN	__imp__SizeofResource@8:NEAR
EXTRN	__imp__LockResource@4:NEAR
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlcore.h
;	COMDAT ?_AtlGetStringResourceImage@ATL@@YAPBUATLSTRINGRESOURCEIMAGE@1@PAUHINSTANCE__@@PAUHRSRC__@@I@Z
_TEXT	SEGMENT
_hInstance$ = 8						; size = 4
_hResource$ = 12					; size = 4
_id$ = 16						; size = 4
?_AtlGetStringResourceImage@ATL@@YAPBUATLSTRINGRESOURCEIMAGE@1@PAUHINSTANCE__@@PAUHRSRC__@@I@Z PROC NEAR ; ATL::_AtlGetStringResourceImage, COMDAT

; 239  : {

  00000	53		 push	 ebx

; 240  : 	const ATLSTRINGRESOURCEIMAGE* pImage;
; 241  : 	const ATLSTRINGRESOURCEIMAGE* pImageEnd;
; 242  : 	ULONG nResourceSize;
; 243  : 	HGLOBAL hGlobal;
; 244  : 	UINT iIndex;
; 245  : 
; 246  : 	hGlobal = ::LoadResource( hInstance, hResource );

  00001	8b 5c 24 08	 mov	 ebx, DWORD PTR _hInstance$[esp]
  00005	57		 push	 edi
  00006	8b 7c 24 10	 mov	 edi, DWORD PTR _hResource$[esp+4]
  0000a	57		 push	 edi
  0000b	53		 push	 ebx
  0000c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LoadResource@8

; 247  : 	if( hGlobal == NULL )

  00012	85 c0		 test	 eax, eax
  00014	75 03		 jne	 SHORT $L39522
  00016	5f		 pop	 edi
  00017	5b		 pop	 ebx

; 272  : 	{
; 273  : 		return( NULL );
; 274  : 	}
; 275  : 
; 276  : 	return( pImage );
; 277  : }

  00018	c3		 ret	 0
$L39522:
  00019	56		 push	 esi

; 248  : 	{
; 249  : 		return( NULL );
; 250  : 	}
; 251  : 
; 252  : 	pImage = (const ATLSTRINGRESOURCEIMAGE*)::LockResource( hGlobal );

  0001a	50		 push	 eax
  0001b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LockResource@4
  00021	8b f0		 mov	 esi, eax

; 253  : 	if( pImage == NULL )

  00023	85 f6		 test	 esi, esi
  00025	75 06		 jne	 SHORT $L39524
$L296188:
  00027	5e		 pop	 esi
  00028	5f		 pop	 edi

; 254  : 	{
; 255  : 		return( NULL );

  00029	33 c0		 xor	 eax, eax
  0002b	5b		 pop	 ebx

; 272  : 	{
; 273  : 		return( NULL );
; 274  : 	}
; 275  : 
; 276  : 	return( pImage );
; 277  : }

  0002c	c3		 ret	 0
$L39524:

; 256  : 	}
; 257  : 
; 258  : 	nResourceSize = ::SizeofResource( hInstance, hResource );

  0002d	57		 push	 edi
  0002e	53		 push	 ebx
  0002f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SizeofResource@8

; 259  : 	pImageEnd = (const ATLSTRINGRESOURCEIMAGE*)(LPBYTE( pImage )+nResourceSize);
; 260  : 	iIndex = id&0x000f;

  00035	8b 4c 24 18	 mov	 ecx, DWORD PTR _id$[esp+8]
  00039	03 c6		 add	 eax, esi
  0003b	83 e1 0f	 and	 ecx, 15			; 0000000fH

; 261  : 
; 262  : 	while( (iIndex > 0) && (pImage < pImageEnd) )

  0003e	76 0e		 jbe	 SHORT $L39528
$L39527:
  00040	3b f0		 cmp	 esi, eax
  00042	73 e3		 jae	 SHORT $L296188

; 263  : 	{
; 264  : 		pImage = (const ATLSTRINGRESOURCEIMAGE*)(LPBYTE( pImage )+(sizeof( ATLSTRINGRESOURCEIMAGE )+(pImage->nLength*sizeof( WCHAR ))));
; 265  : 		iIndex--;

  00044	49		 dec	 ecx
  00045	0f b7 16	 movzx	 edx, WORD PTR [esi]
  00048	8d 74 56 02	 lea	 esi, DWORD PTR [esi+edx*2+2]
  0004c	75 f2		 jne	 SHORT $L39527
$L39528:

; 266  : 	}
; 267  : 	if( pImage >= pImageEnd )

  0004e	3b f0		 cmp	 esi, eax

; 268  : 	{
; 269  : 		return( NULL );

  00050	73 d5		 jae	 SHORT $L296188

; 270  : 	}
; 271  : 	if( pImage->nLength == 0 )

  00052	66 8b 06	 mov	 ax, WORD PTR [esi]
  00055	66 f7 d8	 neg	 ax
  00058	1b c0		 sbb	 eax, eax
  0005a	23 c6		 and	 eax, esi
  0005c	5e		 pop	 esi
  0005d	5f		 pop	 edi
  0005e	5b		 pop	 ebx

; 272  : 	{
; 273  : 		return( NULL );
; 274  : 	}
; 275  : 
; 276  : 	return( pImage );
; 277  : }

  0005f	c3		 ret	 0
?_AtlGetStringResourceImage@ATL@@YAPBUATLSTRINGRESOURCEIMAGE@1@PAUHINSTANCE__@@PAUHRSRC__@@I@Z ENDP ; ATL::_AtlGetStringResourceImage
_TEXT	ENDS
PUBLIC	?AtlGetStringResourceImage@ATL@@YAPBUATLSTRINGRESOURCEIMAGE@1@PAUHINSTANCE__@@I@Z ; ATL::AtlGetStringResourceImage
EXTRN	__imp__FindResourceA@12:NEAR
; Function compile flags: /Ogty
;	COMDAT ?AtlGetStringResourceImage@ATL@@YAPBUATLSTRINGRESOURCEIMAGE@1@PAUHINSTANCE__@@I@Z
_TEXT	SEGMENT
_hInstance$ = 8						; size = 4
_id$ = 12						; size = 4
?AtlGetStringResourceImage@ATL@@YAPBUATLSTRINGRESOURCEIMAGE@1@PAUHINSTANCE__@@I@Z PROC NEAR ; ATL::AtlGetStringResourceImage, COMDAT

; 280  : {

  00000	56		 push	 esi

; 281  : 	HRSRC hResource;
; 282  : 
; 283  : 	hResource = ::FindResource( hInstance, MAKEINTRESOURCE( ((id>>4)+1) ), RT_STRING );

  00001	8b 74 24 0c	 mov	 esi, DWORD PTR _id$[esp]
  00005	8b c6		 mov	 eax, esi
  00007	c1 e8 04	 shr	 eax, 4
  0000a	57		 push	 edi
  0000b	8b 7c 24 0c	 mov	 edi, DWORD PTR _hInstance$[esp+4]
  0000f	40		 inc	 eax
  00010	0f b7 c8	 movzx	 ecx, ax
  00013	6a 06		 push	 6
  00015	51		 push	 ecx
  00016	57		 push	 edi
  00017	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FindResourceA@12

; 284  : 	if( hResource == NULL )

  0001d	85 c0		 test	 eax, eax
  0001f	75 03		 jne	 SHORT $L39545
  00021	5f		 pop	 edi
  00022	5e		 pop	 esi

; 290  : }

  00023	c3		 ret	 0
$L39545:

; 285  : 	{
; 286  : 		return( NULL );
; 287  : 	}
; 288  : 
; 289  : 	return _AtlGetStringResourceImage( hInstance, hResource, id );

  00024	56		 push	 esi
  00025	50		 push	 eax
  00026	57		 push	 edi
  00027	e8 00 00 00 00	 call	 ?_AtlGetStringResourceImage@ATL@@YAPBUATLSTRINGRESOURCEIMAGE@1@PAUHINSTANCE__@@PAUHRSRC__@@I@Z ; ATL::_AtlGetStringResourceImage
  0002c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0002f	5f		 pop	 edi
  00030	5e		 pop	 esi

; 290  : }

  00031	c3		 ret	 0
?AtlGetStringResourceImage@ATL@@YAPBUATLSTRINGRESOURCEIMAGE@1@PAUHINSTANCE__@@I@Z ENDP ; ATL::AtlGetStringResourceImage
_TEXT	ENDS
PUBLIC	?data@CStringData@ATL@@QAEPAXXZ			; ATL::CStringData::data
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlsimpstr.h
;	COMDAT ?data@CStringData@ATL@@QAEPAXXZ
_TEXT	SEGMENT
?data@CStringData@ATL@@QAEPAXXZ PROC NEAR		; ATL::CStringData::data, COMDAT
; _this$ = ecx

; 66   : 		return (this+1);

  00000	8d 41 10	 lea	 eax, DWORD PTR [ecx+16]

; 67   : 	}

  00003	c3		 ret	 0
?data@CStringData@ATL@@QAEPAXXZ ENDP			; ATL::CStringData::data
_TEXT	ENDS
PUBLIC	?IsLocked@CStringData@ATL@@QBE_NXZ		; ATL::CStringData::IsLocked
; Function compile flags: /Ogty
;	COMDAT ?IsLocked@CStringData@ATL@@QBE_NXZ
_TEXT	SEGMENT
?IsLocked@CStringData@ATL@@QBE_NXZ PROC NEAR		; ATL::CStringData::IsLocked, COMDAT
; _this$ = ecx

; 76   : 		return nRefs < 0;

  00000	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00003	33 c0		 xor	 eax, eax
  00005	85 d2		 test	 edx, edx
  00007	0f 9c c0	 setl	 al

; 77   : 	}

  0000a	c3		 ret	 0
?IsLocked@CStringData@ATL@@QBE_NXZ ENDP			; ATL::CStringData::IsLocked
_TEXT	ENDS
PUBLIC	?IsShared@CStringData@ATL@@QBE_NXZ		; ATL::CStringData::IsShared
; Function compile flags: /Ogty
;	COMDAT ?IsShared@CStringData@ATL@@QBE_NXZ
_TEXT	SEGMENT
?IsShared@CStringData@ATL@@QBE_NXZ PROC NEAR		; ATL::CStringData::IsShared, COMDAT
; _this$ = ecx

; 80   : 		return( nRefs > 1 ); 

  00000	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00003	33 c0		 xor	 eax, eax
  00005	83 fa 01	 cmp	 edx, 1
  00008	0f 9f c0	 setg	 al

; 81   : 	}

  0000b	c3		 ret	 0
?IsShared@CStringData@ATL@@QBE_NXZ ENDP			; ATL::CStringData::IsShared
_TEXT	ENDS
PUBLIC	?Release@CStringData@ATL@@QAEXXZ		; ATL::CStringData::Release
; Function compile flags: /Ogty
;	COMDAT ?Release@CStringData@ATL@@QAEXXZ
_TEXT	SEGMENT
?Release@CStringData@ATL@@QAEXXZ PROC NEAR		; ATL::CStringData::Release, COMDAT
; _this$ = ecx

; 93   : 		ATLASSERT( nRefs != 0 );
; 94   : 
; 95   : 		if( _InterlockedDecrement( &nRefs ) <= 0 )

  00000	8d 41 0c	 lea	 eax, DWORD PTR [ecx+12]
  00003	83 ca ff	 or	 edx, -1
  00006	f0 0f c1 10	 lock	  xadd	 DWORD PTR [eax], edx
  0000a	4a		 dec	 edx
  0000b	85 d2		 test	 edx, edx
  0000d	7f 0a		 jg	 SHORT $L39885

; 96   : 		{
; 97   : 			pStringMgr->Free( this );

  0000f	8b 01		 mov	 eax, DWORD PTR [ecx]
  00011	8b 10		 mov	 edx, DWORD PTR [eax]
  00013	51		 push	 ecx
  00014	8b c8		 mov	 ecx, eax
  00016	ff 52 04	 call	 DWORD PTR [edx+4]
$L39885:

; 98   : 		}
; 99   : 	}

  00019	c3		 ret	 0
?Release@CStringData@ATL@@QAEXXZ ENDP			; ATL::CStringData::Release
_TEXT	ENDS
PUBLIC	?Send@CDPMng@@QAEHPAXKK@Z			; CDPMng::Send
EXTRN	?Send@CDPSock@@QAEHPADKK@Z:NEAR			; CDPSock::Send
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_network\net\include\dpmng.h
;	COMDAT ?Send@CDPMng@@QAEHPAXKK@Z
_TEXT	SEGMENT
_lpData$ = 8						; size = 4
_dwDataSize$ = 12					; size = 4
_dpidTo$ = 16						; size = 4
?Send@CDPMng@@QAEHPAXKK@Z PROC NEAR			; CDPMng::Send, COMDAT
; _this$ = ecx

; 171  : 	if( !m_pDPSock )

  00000	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00003	85 c9		 test	 ecx, ecx
  00005	75 05		 jne	 SHORT $L255078

; 172  : 		return FALSE;

  00007	33 c0		 xor	 eax, eax

; 174  : }

  00009	c2 0c 00	 ret	 12			; 0000000cH
$L255078:

; 173  : 	return m_pDPSock->Send( (char*)lpData, dwDataSize, dpidTo );

  0000c	e9 00 00 00 00	 jmp	 ?Send@CDPSock@@QAEHPADKK@Z ; CDPSock::Send
?Send@CDPMng@@QAEHPAXKK@Z ENDP				; CDPMng::Send
_TEXT	ENDS
PUBLIC	?IsInstanceDungeon@CInstanceDungeonHelper@@QAEHK@Z ; CInstanceDungeonHelper::IsInstanceDungeon
EXTRN	?GetType@CInstanceDungeonHelper@@AAEHK@Z:NEAR	; CInstanceDungeonHelper::GetType
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\instancedungeonbase.h
;	COMDAT ?IsInstanceDungeon@CInstanceDungeonHelper@@QAEHK@Z
_TEXT	SEGMENT
_dwWorldId$ = 8						; size = 4
?IsInstanceDungeon@CInstanceDungeonHelper@@QAEHK@Z PROC NEAR ; CInstanceDungeonHelper::IsInstanceDungeon, COMDAT
; _this$ = ecx

; 205  : 	BOOL	IsInstanceDungeon( DWORD dwWorldId )	{ return GetType( dwWorldId ) != NULL_ID; }

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _dwWorldId$[esp-4]
  00004	50		 push	 eax
  00005	e8 00 00 00 00	 call	 ?GetType@CInstanceDungeonHelper@@AAEHK@Z ; CInstanceDungeonHelper::GetType
  0000a	33 c9		 xor	 ecx, ecx
  0000c	83 f8 ff	 cmp	 eax, -1
  0000f	0f 95 c1	 setne	 cl
  00012	8b c1		 mov	 eax, ecx
  00014	c2 04 00	 ret	 4
?IsInstanceDungeon@CInstanceDungeonHelper@@QAEHK@Z ENDP	; CInstanceDungeonHelper::IsInstanceDungeon
_TEXT	ENDS
PUBLIC	?GetPetItemId@CAIPet@@QAEKXZ			; CAIPet::GetPetItemId
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_aiinterface\aipet.h
;	COMDAT ?GetPetItemId@CAIPet@@QAEKXZ
_TEXT	SEGMENT
?GetPetItemId@CAIPet@@QAEKXZ PROC NEAR			; CAIPet::GetPetItemId, COMDAT
; _this$ = ecx

; 48   : 	OBJID	GetPetItemId( void )	{	return m_idPetItem;		}

  00000	8b 41 4c	 mov	 eax, DWORD PTR [ecx+76]
  00003	c3		 ret	 0
?GetPetItemId@CAIPet@@QAEKXZ ENDP			; CAIPet::GetPetItemId
_TEXT	ENDS
PUBLIC	?GetExpanedLayer@CTicketProperty@@QAEHK@Z	; CTicketProperty::GetExpanedLayer
EXTRN	?GetExpanedLayer@CLayerProperty@@QAEHK@Z:NEAR	; CLayerProperty::GetExpanedLayer
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\ticket.h
;	COMDAT ?GetExpanedLayer@CTicketProperty@@QAEHK@Z
_TEXT	SEGMENT
_dwWorldId$ = 8						; size = 4
?GetExpanedLayer@CTicketProperty@@QAEHK@Z PROC NEAR	; CTicketProperty::GetExpanedLayer, COMDAT
; _this$ = ecx

; 42   : 	int		GetExpanedLayer( DWORD dwWorldId )	{	return m_lp.GetExpanedLayer( dwWorldId );	}

  00000	83 c1 1c	 add	 ecx, 28			; 0000001cH
  00003	e9 00 00 00 00	 jmp	 ?GetExpanedLayer@CLayerProperty@@QAEHK@Z ; CLayerProperty::GetExpanedLayer
?GetExpanedLayer@CTicketProperty@@QAEHK@Z ENDP		; CTicketProperty::GetExpanedLayer
_TEXT	ENDS
PUBLIC	?GetMaxBattery@CCollectingProperty@@QAEHXZ	; CCollectingProperty::GetMaxBattery
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\collecting.h
;	COMDAT ?GetMaxBattery@CCollectingProperty@@QAEHXZ
_TEXT	SEGMENT
?GetMaxBattery@CCollectingProperty@@QAEHXZ PROC NEAR	; CCollectingProperty::GetMaxBattery, COMDAT
; _this$ = ecx

; 24   : 	int		GetMaxBattery( void )	{	return m_nMaxBattery;	}

  00000	8b 41 34	 mov	 eax, DWORD PTR [ecx+52]
  00003	c3		 ret	 0
?GetMaxBattery@CCollectingProperty@@QAEHXZ ENDP		; CCollectingProperty::GetMaxBattery
_TEXT	ENDS
PUBLIC	??0CTimeSpan@ATL@@QAE@_J@Z			; ATL::CTimeSpan::CTimeSpan
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atltime.inl
;	COMDAT ??0CTimeSpan@ATL@@QAE@_J@Z
_TEXT	SEGMENT
_time$ = 8						; size = 8
??0CTimeSpan@ATL@@QAE@_J@Z PROC NEAR			; ATL::CTimeSpan::CTimeSpan, COMDAT
; _this$ = ecx

; 33   : {

  00000	8b 54 24 08	 mov	 edx, DWORD PTR _time$[esp]
  00004	8b c1		 mov	 eax, ecx
  00006	8b 4c 24 04	 mov	 ecx, DWORD PTR _time$[esp-4]
  0000a	89 08		 mov	 DWORD PTR [eax], ecx
  0000c	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 34   : }

  0000f	c2 08 00	 ret	 8
??0CTimeSpan@ATL@@QAE@_J@Z ENDP				; ATL::CTimeSpan::CTimeSpan
_TEXT	ENDS
PUBLIC	??0CTimeSpan@ATL@@QAE@JHHH@Z			; ATL::CTimeSpan::CTimeSpan
EXTRN	__allmul:NEAR
; Function compile flags: /Ogty
;	COMDAT ??0CTimeSpan@ATL@@QAE@JHHH@Z
_TEXT	SEGMENT
_lDays$ = 8						; size = 4
_nHours$ = 12						; size = 4
_nMins$ = 16						; size = 4
_nSecs$ = 20						; size = 4
??0CTimeSpan@ATL@@QAE@JHHH@Z PROC NEAR			; ATL::CTimeSpan::CTimeSpan, COMDAT
; _this$ = ecx

; 38   :  	m_timeSpan = nSecs + 60* (nMins + 60* (nHours + __int64(24) * lDays));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _lDays$[esp-4]
  00004	56		 push	 esi
  00005	57		 push	 edi
  00006	6a 00		 push	 0
  00008	99		 cdq
  00009	6a 18		 push	 24			; 00000018H
  0000b	52		 push	 edx
  0000c	50		 push	 eax
  0000d	8b f1		 mov	 esi, ecx
  0000f	e8 00 00 00 00	 call	 __allmul
  00014	8b c8		 mov	 ecx, eax
  00016	8b 44 24 10	 mov	 eax, DWORD PTR _nHours$[esp+4]
  0001a	8b fa		 mov	 edi, edx
  0001c	99		 cdq
  0001d	6a 00		 push	 0
  0001f	03 c8		 add	 ecx, eax
  00021	6a 3c		 push	 60			; 0000003cH
  00023	13 fa		 adc	 edi, edx
  00025	57		 push	 edi
  00026	51		 push	 ecx
  00027	e8 00 00 00 00	 call	 __allmul
  0002c	8b c8		 mov	 ecx, eax
  0002e	8b 44 24 14	 mov	 eax, DWORD PTR _nMins$[esp+4]
  00032	8b fa		 mov	 edi, edx
  00034	99		 cdq
  00035	6a 00		 push	 0
  00037	03 c8		 add	 ecx, eax
  00039	6a 3c		 push	 60			; 0000003cH
  0003b	13 fa		 adc	 edi, edx
  0003d	57		 push	 edi
  0003e	51		 push	 ecx
  0003f	e8 00 00 00 00	 call	 __allmul
  00044	8b c8		 mov	 ecx, eax
  00046	8b 44 24 18	 mov	 eax, DWORD PTR _nSecs$[esp+4]
  0004a	8b fa		 mov	 edi, edx
  0004c	99		 cdq
  0004d	03 c8		 add	 ecx, eax
  0004f	13 fa		 adc	 edi, edx
  00051	89 7e 04	 mov	 DWORD PTR [esi+4], edi
  00054	5f		 pop	 edi
  00055	89 0e		 mov	 DWORD PTR [esi], ecx

; 39   : }

  00057	8b c6		 mov	 eax, esi
  00059	5e		 pop	 esi
  0005a	c2 10 00	 ret	 16			; 00000010H
??0CTimeSpan@ATL@@QAE@JHHH@Z ENDP			; ATL::CTimeSpan::CTimeSpan
_TEXT	ENDS
PUBLIC	?GetTotalSeconds@CTimeSpan@ATL@@QBE_JXZ		; ATL::CTimeSpan::GetTotalSeconds
; Function compile flags: /Ogty
;	COMDAT ?GetTotalSeconds@CTimeSpan@ATL@@QBE_JXZ
_TEXT	SEGMENT
?GetTotalSeconds@CTimeSpan@ATL@@QBE_JXZ PROC NEAR	; ATL::CTimeSpan::GetTotalSeconds, COMDAT
; _this$ = ecx

; 68   : 	return( m_timeSpan );

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]

; 69   : }

  00005	c3		 ret	 0
?GetTotalSeconds@CTimeSpan@ATL@@QBE_JXZ ENDP		; ATL::CTimeSpan::GetTotalSeconds
_TEXT	ENDS
PUBLIC	?GetTimeSpan@CTimeSpan@ATL@@QBE_JXZ		; ATL::CTimeSpan::GetTimeSpan
; Function compile flags: /Ogty
;	COMDAT ?GetTimeSpan@CTimeSpan@ATL@@QBE_JXZ
_TEXT	SEGMENT
?GetTimeSpan@CTimeSpan@ATL@@QBE_JXZ PROC NEAR		; ATL::CTimeSpan::GetTimeSpan, COMDAT
; _this$ = ecx

; 78   : 	return( m_timeSpan );

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]

; 79   : }

  00005	c3		 ret	 0
?GetTimeSpan@CTimeSpan@ATL@@QBE_JXZ ENDP		; ATL::CTimeSpan::GetTimeSpan
_TEXT	ENDS
PUBLIC	??0CTime@ATL@@QAE@_J@Z				; ATL::CTime::CTime
; Function compile flags: /Ogty
;	COMDAT ??0CTime@ATL@@QAE@_J@Z
_TEXT	SEGMENT
_time$ = 8						; size = 8
??0CTime@ATL@@QAE@_J@Z PROC NEAR			; ATL::CTime::CTime, COMDAT
; _this$ = ecx

; 167  : {

  00000	8b 54 24 08	 mov	 edx, DWORD PTR _time$[esp]
  00004	8b c1		 mov	 eax, ecx
  00006	8b 4c 24 04	 mov	 ecx, DWORD PTR _time$[esp-4]
  0000a	89 08		 mov	 DWORD PTR [eax], ecx
  0000c	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 168  : }

  0000f	c2 08 00	 ret	 8
??0CTime@ATL@@QAE@_J@Z ENDP				; ATL::CTime::CTime
_TEXT	ENDS
PUBLIC	??GCTime@ATL@@QBE?AVCTimeSpan@1@V01@@Z		; ATL::CTime::operator-
; Function compile flags: /Ogty
;	COMDAT ??GCTime@ATL@@QBE?AVCTimeSpan@1@V01@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_time$ = 12						; size = 8
??GCTime@ATL@@QBE?AVCTimeSpan@1@V01@@Z PROC NEAR	; ATL::CTime::operator-, COMDAT
; _this$ = ecx

; 276  : 	return( CTimeSpan( m_time-time.m_time ) );

  00000	8b 11		 mov	 edx, DWORD PTR [ecx]
  00002	8b 44 24 08	 mov	 eax, DWORD PTR _time$[esp-4]
  00006	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00009	2b d0		 sub	 edx, eax
  0000b	1b 4c 24 0c	 sbb	 ecx, DWORD PTR _time$[esp]
  0000f	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  00013	89 10		 mov	 DWORD PTR [eax], edx
  00015	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 277  : }

  00018	c2 0c 00	 ret	 12			; 0000000cH
??GCTime@ATL@@QBE?AVCTimeSpan@1@V01@@Z ENDP		; ATL::CTime::operator-
_TEXT	ENDS
PUBLIC	??HCTime@ATL@@QBE?AV01@VCTimeSpan@1@@Z		; ATL::CTime::operator+
; Function compile flags: /Ogty
;	COMDAT ??HCTime@ATL@@QBE?AV01@VCTimeSpan@1@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_span$ = 12						; size = 8
??HCTime@ATL@@QBE?AV01@VCTimeSpan@1@@Z PROC NEAR	; ATL::CTime::operator+, COMDAT
; _this$ = ecx

; 286  : 	return( CTime( m_time+span.GetTimeSpan() ) );

  00000	8b 11		 mov	 edx, DWORD PTR [ecx]
  00002	8b 44 24 08	 mov	 eax, DWORD PTR _span$[esp-4]
  00006	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00009	03 d0		 add	 edx, eax
  0000b	13 4c 24 0c	 adc	 ecx, DWORD PTR _span$[esp]
  0000f	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  00013	89 10		 mov	 DWORD PTR [eax], edx
  00015	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 287  : }

  00018	c2 0c 00	 ret	 12			; 0000000cH
??HCTime@ATL@@QBE?AV01@VCTimeSpan@1@@Z ENDP		; ATL::CTime::operator+
_TEXT	ENDS
PUBLIC	?GetTime@CTime@ATL@@QBE_JXZ			; ATL::CTime::GetTime
; Function compile flags: /Ogty
;	COMDAT ?GetTime@CTime@ATL@@QBE_JXZ
_TEXT	SEGMENT
?GetTime@CTime@ATL@@QBE_JXZ PROC NEAR			; ATL::CTime::GetTime, COMDAT
; _this$ = ecx

; 372  : 	return( m_time );

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]

; 373  : }

  00005	c3		 ret	 0
?GetTime@CTime@ATL@@QBE_JXZ ENDP			; ATL::CTime::GetTime
_TEXT	ENDS
PUBLIC	?GetEnvironmentEffect@CEnvironment@@QAEHXZ	; CEnvironment::GetEnvironmentEffect
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\environment.h
;	COMDAT ?GetEnvironmentEffect@CEnvironment@@QAEHXZ
_TEXT	SEGMENT
?GetEnvironmentEffect@CEnvironment@@QAEHXZ PROC NEAR	; CEnvironment::GetEnvironmentEffect, COMDAT
; _this$ = ecx

; 14   : 	BOOL	GetEnvironmentEffect()	{	return m_bEffect;	}

  00000	8b 81 d0 02 00
	00		 mov	 eax, DWORD PTR [ecx+720]
  00006	c3		 ret	 0
?GetEnvironmentEffect@CEnvironment@@QAEHXZ ENDP		; CEnvironment::GetEnvironmentEffect
_TEXT	ENDS
PUBLIC	?GetCouple@CCoupleHelper@@QAEPAVCCouple@@K@Z	; CCoupleHelper::GetCouple
EXTRN	?GetCouple@CCoupleMgr@@QAEPAVCCouple@@K@Z:NEAR	; CCoupleMgr::GetCouple
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\couplehelper.h
;	COMDAT ?GetCouple@CCoupleHelper@@QAEPAVCCouple@@K@Z
_TEXT	SEGMENT
_idPlayer$ = 8						; size = 4
?GetCouple@CCoupleHelper@@QAEPAVCCouple@@K@Z PROC NEAR	; CCoupleHelper::GetCouple, COMDAT
; _this$ = ecx

; 28   : 	CCouple* GetCouple( u_long idPlayer )	{	ASSERT( m_pMgr );	return m_pMgr->GetCouple( idPlayer );	}

  00000	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00003	e9 00 00 00 00	 jmp	 ?GetCouple@CCoupleMgr@@QAEPAVCCouple@@K@Z ; CCoupleMgr::GetCouple
?GetCouple@CCoupleHelper@@QAEPAVCCouple@@K@Z ENDP	; CCoupleHelper::GetCouple
_TEXT	ENDS
PUBLIC	??0CPoint@@QAE@HH@Z				; CPoint::CPoint
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atltypes.inl
;	COMDAT ??0CPoint@@QAE@HH@Z
_TEXT	SEGMENT
_initX$ = 8						; size = 4
_initY$ = 12						; size = 4
??0CPoint@@QAE@HH@Z PROC NEAR				; CPoint::CPoint, COMDAT
; _this$ = ecx

; 63   : 	{ x = initX; y = initY; }

  00000	8b 54 24 08	 mov	 edx, DWORD PTR _initY$[esp-4]
  00004	8b c1		 mov	 eax, ecx
  00006	8b 4c 24 04	 mov	 ecx, DWORD PTR _initX$[esp-4]
  0000a	89 08		 mov	 DWORD PTR [eax], ecx
  0000c	89 50 04	 mov	 DWORD PTR [eax+4], edx
  0000f	c2 08 00	 ret	 8
??0CPoint@@QAE@HH@Z ENDP				; CPoint::CPoint
_TEXT	ENDS
PUBLIC	?PtInRect@CRect@@QBEHUtagPOINT@@@Z		; CRect::PtInRect
EXTRN	__imp__PtInRect@12:NEAR
; Function compile flags: /Ogty
;	COMDAT ?PtInRect@CRect@@QBEHUtagPOINT@@@Z
_TEXT	SEGMENT
_point$ = 8						; size = 8
?PtInRect@CRect@@QBEHUtagPOINT@@@Z PROC NEAR		; CRect::PtInRect, COMDAT
; _this$ = ecx

; 151  : 	{ return ::PtInRect(this, point); }

  00000	8b 44 24 08	 mov	 eax, DWORD PTR _point$[esp]
  00004	8b 54 24 04	 mov	 edx, DWORD PTR _point$[esp-4]
  00008	50		 push	 eax
  00009	52		 push	 edx
  0000a	51		 push	 ecx
  0000b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PtInRect@12
  00011	c2 08 00	 ret	 8
?PtInRect@CRect@@QBEHUtagPOINT@@@Z ENDP			; CRect::PtInRect
_TEXT	ENDS
PUBLIC	?ScheduleDestory@CUser@@QAEXK@Z			; CUser::ScheduleDestory
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
;	COMDAT ?ScheduleDestory@CUser@@QAEXK@Z
_TEXT	SEGMENT
_dwDestoryTime$ = 8					; size = 4
?ScheduleDestory@CUser@@QAEXK@Z PROC NEAR		; CUser::ScheduleDestory, COMDAT
; _this$ = ecx

; 2647 : 	m_dwDestroyTime = dwDestoryTime;

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _dwDestoryTime$[esp-4]
  00004	89 81 2c 57 00
	00		 mov	 DWORD PTR [ecx+22316], eax

; 2648 : }

  0000a	c2 04 00	 ret	 4
?ScheduleDestory@CUser@@QAEXK@Z ENDP			; CUser::ScheduleDestory
_TEXT	ENDS
PUBLIC	?GetReturnPos@CUser@@QAEAAUD3DXVECTOR3@@PAK@Z	; CUser::GetReturnPos
; Function compile flags: /Ogty
;	COMDAT ?GetReturnPos@CUser@@QAEAAUD3DXVECTOR3@@PAK@Z
_TEXT	SEGMENT
_pdwWorldID$ = 8					; size = 4
?GetReturnPos@CUser@@QAEAAUD3DXVECTOR3@@PAK@Z PROC NEAR	; CUser::GetReturnPos, COMDAT
; _this$ = ecx

; 2756 : 	*pdwWorldID = m_dwReturnWorldID;

  00000	8b 81 d0 95 00
	00		 mov	 eax, DWORD PTR [ecx+38352]
  00006	8b 54 24 04	 mov	 edx, DWORD PTR _pdwWorldID$[esp-4]
  0000a	89 02		 mov	 DWORD PTR [edx], eax

; 2757 : 	return m_vReturnPos;

  0000c	8d 81 c4 95 00
	00		 lea	 eax, DWORD PTR [ecx+38340]

; 2758 : }

  00012	c2 04 00	 ret	 4
?GetReturnPos@CUser@@QAEAAUD3DXVECTOR3@@PAK@Z ENDP	; CUser::GetReturnPos
_TEXT	ENDS
PUBLIC	?assign@?$char_traits@D@std@@SAXAADABD@Z	; std::char_traits<char>::assign
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\iosfwd
;	COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$char_traits@D@std@@SAXAADABD@Z PROC NEAR	; std::char_traits<char>::assign, COMDAT

; 331  : 		_Left = _Right;

  00000	8b 44 24 08	 mov	 eax, DWORD PTR __Right$[esp-4]
  00004	8a 08		 mov	 cl, BYTE PTR [eax]
  00006	8b 54 24 04	 mov	 edx, DWORD PTR __Left$[esp-4]
  0000a	88 0a		 mov	 BYTE PTR [edx], cl

; 332  : 		}

  0000c	c3		 ret	 0
?assign@?$char_traits@D@std@@SAXAADABD@Z ENDP		; std::char_traits<char>::assign
_TEXT	ENDS
PUBLIC	?length@?$char_traits@D@std@@SAIPBD@Z		; std::char_traits<char>::length
; Function compile flags: /Ogty
;	COMDAT ?length@?$char_traits@D@std@@SAIPBD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
?length@?$char_traits@D@std@@SAIPBD@Z PROC NEAR		; std::char_traits<char>::length, COMDAT

; 352  : 		return (::strlen(_First));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __First$[esp-4]
  00004	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
$L296282:
  00007	8a 08		 mov	 cl, BYTE PTR [eax]
  00009	40		 inc	 eax
  0000a	84 c9		 test	 cl, cl
  0000c	75 f9		 jne	 SHORT $L296282
  0000e	2b c2		 sub	 eax, edx

; 353  : 		}

  00010	c3		 ret	 0
?length@?$char_traits@D@std@@SAIPBD@Z ENDP		; std::char_traits<char>::length
_TEXT	ENDS
PUBLIC	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::copy
; Function compile flags: /Ogty
;	COMDAT ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z PROC NEAR	; std::char_traits<char>::copy, COMDAT

; 358  : 		return ((_Elem *)::memcpy(_First1, _First2, _Count));

  00000	8b 4c 24 0c	 mov	 ecx, DWORD PTR __Count$[esp-4]
  00004	56		 push	 esi
  00005	8b 74 24 0c	 mov	 esi, DWORD PTR __First2$[esp]
  00009	57		 push	 edi
  0000a	8b 7c 24 0c	 mov	 edi, DWORD PTR __First1$[esp+4]
  0000e	8b c1		 mov	 eax, ecx
  00010	8b d7		 mov	 edx, edi
  00012	c1 e9 02	 shr	 ecx, 2
  00015	f3 a5		 rep movsd
  00017	8b c8		 mov	 ecx, eax
  00019	83 e1 03	 and	 ecx, 3
  0001c	f3 a4		 rep movsb
  0001e	5f		 pop	 edi
  0001f	8b c2		 mov	 eax, edx
  00021	5e		 pop	 esi

; 359  : 		}

  00022	c3		 ret	 0
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::copy
_TEXT	ENDS
PUBLIC	?move@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::move
EXTRN	_memmove:NEAR
; Function compile flags: /Ogty
;	COMDAT ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?move@?$char_traits@D@std@@SAPADPADPBDI@Z PROC NEAR	; std::char_traits<char>::move, COMDAT

; 370  : 		return ((_Elem *)::memmove(_First1, _First2, _Count));

  00000	e9 00 00 00 00	 jmp	 _memmove
?move@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::move
_TEXT	ENDS
PUBLIC	?_Ptr_cat@std@@YA?AU_Scalar_ptr_iterator_tag@1@PAE0@Z ; std::_Ptr_cat
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xutility
;	COMDAT ?_Ptr_cat@std@@YA?AU_Scalar_ptr_iterator_tag@1@PAE0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?_Ptr_cat@std@@YA?AU_Scalar_ptr_iterator_tag@1@PAE0@Z PROC NEAR ; std::_Ptr_cat, COMDAT

; 282  : 	{	// return pointer category from pointer to unsigned char arguments

  00000	51		 push	 ecx

; 283  : 	_Scalar_ptr_iterator_tag _Cat;
; 284  : 	return (_Cat);

  00001	8a 44 24 03	 mov	 al, BYTE PTR __Cat$[esp+4]

; 285  : 	}

  00005	59		 pop	 ecx
  00006	c3		 ret	 0
?_Ptr_cat@std@@YA?AU_Scalar_ptr_iterator_tag@1@PAE0@Z ENDP ; std::_Ptr_cat
_TEXT	ENDS
PUBLIC	?_Ptr_cat@std@@YA?AU_Scalar_ptr_iterator_tag@1@PAK0@Z ; std::_Ptr_cat
; Function compile flags: /Ogty
;	COMDAT ?_Ptr_cat@std@@YA?AU_Scalar_ptr_iterator_tag@1@PAK0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?_Ptr_cat@std@@YA?AU_Scalar_ptr_iterator_tag@1@PAK0@Z PROC NEAR ; std::_Ptr_cat, COMDAT

; 371  : 	{	// return pointer category from pointer to unsigned long arguments

  00000	51		 push	 ecx

; 372  : 	_Scalar_ptr_iterator_tag _Cat;
; 373  : 	return (_Cat);

  00001	8a 44 24 03	 mov	 al, BYTE PTR __Cat$[esp+4]

; 374  : 	}

  00005	59		 pop	 ecx
  00006	c3		 ret	 0
?_Ptr_cat@std@@YA?AU_Scalar_ptr_iterator_tag@1@PAK0@Z ENDP ; std::_Ptr_cat
_TEXT	ENDS
PUBLIC	?CheckTransMailBox@CUser@@QAEXH@Z		; CUser::CheckTransMailBox
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
;	COMDAT ?CheckTransMailBox@CUser@@QAEXH@Z
_TEXT	SEGMENT
_bCheckTransMailBox$ = 8				; size = 4
?CheckTransMailBox@CUser@@QAEXH@Z PROC NEAR		; CUser::CheckTransMailBox, COMDAT
; _this$ = ecx

; 6765 : 	m_bCheckTransMailBox = bCheckTransMailBox;

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _bCheckTransMailBox$[esp-4]
  00004	89 81 d8 16 00
	00		 mov	 DWORD PTR [ecx+5848], eax

; 6766 : }

  0000a	c2 04 00	 ret	 4
?CheckTransMailBox@CUser@@QAEXH@Z ENDP			; CUser::CheckTransMailBox
_TEXT	ENDS
PUBLIC	?GetCheckTransMailBox@CUser@@QAEHXZ		; CUser::GetCheckTransMailBox
; Function compile flags: /Ogty
;	COMDAT ?GetCheckTransMailBox@CUser@@QAEHXZ
_TEXT	SEGMENT
?GetCheckTransMailBox@CUser@@QAEHXZ PROC NEAR		; CUser::GetCheckTransMailBox, COMDAT
; _this$ = ecx

; 6770 : 	return m_bCheckTransMailBox;

  00000	8b 81 d8 16 00
	00		 mov	 eax, DWORD PTR [ecx+5848]

; 6771 : }

  00006	c3		 ret	 0
?GetCheckTransMailBox@CUser@@QAEHXZ ENDP		; CUser::GetCheckTransMailBox
_TEXT	ENDS
PUBLIC	?CheckClientReq@CUser@@QAE_NXZ			; CUser::CheckClientReq
EXTRN	__imp__GetTickCount@0:NEAR
; Function compile flags: /Ogty
;	COMDAT ?CheckClientReq@CUser@@QAE_NXZ
_TEXT	SEGMENT
?CheckClientReq@CUser@@QAE_NXZ PROC NEAR		; CUser::CheckClientReq, COMDAT
; _this$ = ecx

; 6774 : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 6775 : 	DWORD dwTick = GetTickCount();

  00003	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0

; 6776 : 	if( dwTick >= m_dwTickFromClient + CHECK_TICK_FROM_CLIENT )

  00009	8b 8e e0 16 00
	00		 mov	 ecx, DWORD PTR [esi+5856]
  0000f	81 c1 b8 0b 00
	00		 add	 ecx, 3000		; 00000bb8H
  00015	3b c1		 cmp	 eax, ecx
  00017	72 10		 jb	 SHORT $L283248

; 6777 : 	{
; 6778 : 		m_dwTickFromClient = dwTick;

  00019	89 86 e0 16 00
	00		 mov	 DWORD PTR [esi+5856], eax

; 6779 : 		++m_nCountFromClient;

  0001f	ff 86 dc 16 00
	00		 inc	 DWORD PTR [esi+5852]

; 6780 : 		return true;

  00025	b0 01		 mov	 al, 1
  00027	5e		 pop	 esi

; 6783 : }

  00028	c3		 ret	 0
$L283248:

; 6781 : 	}
; 6782 : 	return false;

  00029	32 c0		 xor	 al, al
  0002b	5e		 pop	 esi

; 6783 : }

  0002c	c3		 ret	 0
?CheckClientReq@CUser@@QAE_NXZ ENDP			; CUser::CheckClientReq
_TEXT	ENDS
PUBLIC	?ResetCheckClientReq@CUser@@QAEXXZ		; CUser::ResetCheckClientReq
; Function compile flags: /Ogty
;	COMDAT ?ResetCheckClientReq@CUser@@QAEXXZ
_TEXT	SEGMENT
?ResetCheckClientReq@CUser@@QAEXXZ PROC NEAR		; CUser::ResetCheckClientReq, COMDAT
; _this$ = ecx

; 6787 : 	m_dwTickFromClient = 0;

  00000	33 c0		 xor	 eax, eax
  00002	89 81 e0 16 00
	00		 mov	 DWORD PTR [ecx+5856], eax

; 6788 : 	m_nCountFromClient = 0;

  00008	89 81 dc 16 00
	00		 mov	 DWORD PTR [ecx+5852], eax

; 6789 : }

  0000e	c3		 ret	 0
?ResetCheckClientReq@CUser@@QAEXXZ ENDP			; CUser::ResetCheckClientReq
_TEXT	ENDS
PUBLIC	?GetCountClientReq@CUser@@QAEHXZ		; CUser::GetCountClientReq
; Function compile flags: /Ogty
;	COMDAT ?GetCountClientReq@CUser@@QAEHXZ
_TEXT	SEGMENT
?GetCountClientReq@CUser@@QAEHXZ PROC NEAR		; CUser::GetCountClientReq, COMDAT
; _this$ = ecx

; 6793 : 	return m_nCountFromClient;

  00000	8b 81 dc 16 00
	00		 mov	 eax, DWORD PTR [ecx+5852]

; 6794 : }

  00006	c3		 ret	 0
?GetCountClientReq@CUser@@QAEHXZ ENDP			; CUser::GetCountClientReq
_TEXT	ENDS
PUBLIC	?GetEventFlagBit@CUser@@QAE_JH@Z		; CUser::GetEventFlagBit
EXTRN	__allshl:NEAR
; Function compile flags: /Ogty
;	COMDAT ?GetEventFlagBit@CUser@@QAE_JH@Z
_TEXT	SEGMENT
_nBit$ = 8						; size = 4
?GetEventFlagBit@CUser@@QAE_JH@Z PROC NEAR		; CUser::GetEventFlagBit, COMDAT
; _this$ = ecx

; 7506 : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 7507 : #ifdef __EVENT_1101_2
; 7508 : 	return m_nEventFlag & ( (__int64)0x0000000000000001 << nBit );

  00003	8b 4c 24 08	 mov	 ecx, DWORD PTR _nBit$[esp]
  00007	b8 01 00 00 00	 mov	 eax, 1
  0000c	33 d2		 xor	 edx, edx
  0000e	e8 00 00 00 00	 call	 __allshl
  00013	23 86 e0 95 00
	00		 and	 eax, DWORD PTR [esi+38368]
  00019	23 96 e4 95 00
	00		 and	 edx, DWORD PTR [esi+38372]
  0001f	5e		 pop	 esi

; 7509 : #else // __EVENT_1101_2
; 7510 : 	return m_dwEventFlag & ( 0x00000001 << nBit );
; 7511 : #endif // __EVENT_1101_2
; 7512 : }

  00020	c2 04 00	 ret	 4
?GetEventFlagBit@CUser@@QAE_JH@Z ENDP			; CUser::GetEventFlagBit
_TEXT	ENDS
PUBLIC	?SetEventFlagBit@CUser@@QAEHH@Z			; CUser::SetEventFlagBit
; Function compile flags: /Ogty
;	COMDAT ?SetEventFlagBit@CUser@@QAEHH@Z
_TEXT	SEGMENT
_nCount$ = -4						; size = 4
_nBit$ = 8						; size = 4
?SetEventFlagBit@CUser@@QAEHH@Z PROC NEAR		; CUser::SetEventFlagBit, COMDAT
; _this$ = ecx

; 7515 : {

  00000	51		 push	 ecx
  00001	53		 push	 ebx
  00002	55		 push	 ebp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 7516 : 	int nCount	= 0;
; 7517 : #ifdef __EVENT_1101_2
; 7518 : 	m_nEventFlag	|= ( (__int64)0x0000000000000001 << nBit );

  00006	8b 4c 24 14	 mov	 ecx, DWORD PTR _nBit$[esp+12]
  0000a	33 ed		 xor	 ebp, ebp
  0000c	57		 push	 edi
  0000d	b8 01 00 00 00	 mov	 eax, 1
  00012	33 d2		 xor	 edx, edx
  00014	89 6c 24 10	 mov	 DWORD PTR _nCount$[esp+20], ebp
  00018	e8 00 00 00 00	 call	 __allshl
  0001d	8b 8e e0 95 00
	00		 mov	 ecx, DWORD PTR [esi+38368]
  00023	0b c8		 or	 ecx, eax
  00025	8b 86 e4 95 00
	00		 mov	 eax, DWORD PTR [esi+38372]
  0002b	0b c2		 or	 eax, edx
  0002d	89 8e e0 95 00
	00		 mov	 DWORD PTR [esi+38368], ecx
  00033	89 86 e4 95 00
	00		 mov	 DWORD PTR [esi+38372], eax

; 7519 : 	for( int i = 0; i < 63; i++ )

  00039	8b d9		 mov	 ebx, ecx
  0003b	8b f0		 mov	 esi, eax
  0003d	8d 49 00	 npad	 3
$L296325:

; 7520 : #else // __EVENT_1101_2
; 7521 : 	m_dwEventFlag	|= 0x00000001 << nBit;
; 7522 : 	for( int i = 0; i < 32; i++ )
; 7523 : #endif // __EVENT_1101_2
; 7524 : 
; 7525 : 	{
; 7526 : 		if( GetEventFlagBit( i ) )

  00040	b8 01 00 00 00	 mov	 eax, 1
  00045	33 d2		 xor	 edx, edx
  00047	8b cd		 mov	 ecx, ebp
  00049	e8 00 00 00 00	 call	 __allshl
  0004e	23 c3		 and	 eax, ebx
  00050	23 d6		 and	 edx, esi
  00052	0b c2		 or	 eax, edx
  00054	74 04		 je	 SHORT $L284433

; 7527 : 			nCount++;

  00056	ff 44 24 10	 inc	 DWORD PTR _nCount$[esp+20]
$L284433:
  0005a	8d 7d 02	 lea	 edi, DWORD PTR [ebp+2]
  0005d	8d 4f ff	 lea	 ecx, DWORD PTR [edi-1]
  00060	b8 01 00 00 00	 mov	 eax, 1
  00065	33 d2		 xor	 edx, edx
  00067	e8 00 00 00 00	 call	 __allshl
  0006c	23 c3		 and	 eax, ebx
  0006e	23 d6		 and	 edx, esi
  00070	0b c2		 or	 eax, edx
  00072	74 04		 je	 SHORT $L296323
  00074	ff 44 24 10	 inc	 DWORD PTR _nCount$[esp+20]
$L296323:
  00078	b8 01 00 00 00	 mov	 eax, 1
  0007d	33 d2		 xor	 edx, edx
  0007f	8b cf		 mov	 ecx, edi
  00081	e8 00 00 00 00	 call	 __allshl
  00086	23 c3		 and	 eax, ebx
  00088	23 d6		 and	 edx, esi
  0008a	0b c2		 or	 eax, edx
  0008c	74 04		 je	 SHORT $L296324
  0008e	ff 44 24 10	 inc	 DWORD PTR _nCount$[esp+20]
$L296324:
  00092	83 c5 03	 add	 ebp, 3
  00095	83 fd 3f	 cmp	 ebp, 63			; 0000003fH
  00098	7c a6		 jl	 SHORT $L296325

; 7528 : 	}
; 7529 : 	return nCount;

  0009a	8b 44 24 10	 mov	 eax, DWORD PTR _nCount$[esp+20]
  0009e	5f		 pop	 edi
  0009f	5e		 pop	 esi
  000a0	5d		 pop	 ebp
  000a1	5b		 pop	 ebx

; 7530 : }

  000a2	59		 pop	 ecx
  000a3	c2 04 00	 ret	 4
?SetEventFlagBit@CUser@@QAEHH@Z ENDP			; CUser::SetEventFlagBit
_TEXT	ENDS
PUBLIC	??0__ITEMINFO@@QAE@KHH@Z			; __ITEMINFO::__ITEMINFO
; Function compile flags: /Ogty
;	COMDAT ??0__ITEMINFO@@QAE@KHH@Z
_TEXT	SEGMENT
_dwII$ = 8						; size = 4
_nIN$ = 12						; size = 4
_nB$ = 16						; size = 4
??0__ITEMINFO@@QAE@KHH@Z PROC NEAR			; __ITEMINFO::__ITEMINFO, COMDAT
; _this$ = ecx

; 7550 : 	__ITEMINFO( DWORD dwII, int nIN, int nB )

  00000	8b 54 24 08	 mov	 edx, DWORD PTR _nIN$[esp-4]
  00004	8b c1		 mov	 eax, ecx
  00006	8b 4c 24 04	 mov	 ecx, DWORD PTR _dwII$[esp-4]
  0000a	89 08		 mov	 DWORD PTR [eax], ecx
  0000c	8b 4c 24 0c	 mov	 ecx, DWORD PTR _nB$[esp-4]
  00010	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00013	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  00016	c2 0c 00	 ret	 12			; 0000000cH
??0__ITEMINFO@@QAE@KHH@Z ENDP				; __ITEMINFO::__ITEMINFO
_TEXT	ENDS
PUBLIC	?GetMuteText@CUser@@QAEHXZ			; CUser::GetMuteText
EXTRN	?HasBuff@CMover@@QAEHGG@Z:NEAR			; CMover::HasBuff
; Function compile flags: /Ogty
;	COMDAT ?GetMuteText@CUser@@QAEHXZ
_TEXT	SEGMENT
?GetMuteText@CUser@@QAEHXZ PROC NEAR			; CUser::GetMuteText, COMDAT
; _this$ = ecx

; 8190 : 	if( m_dwMute > 0 )

  00000	8b 81 68 0b 00
	00		 mov	 eax, DWORD PTR [ecx+2920]
  00006	85 c0		 test	 eax, eax
  00008	76 06		 jbe	 SHORT $L285239

; 8191 : 		return TID_GAME_STATE_MUTE;

  0000a	b8 d2 0e 00 00	 mov	 eax, 3794		; 00000ed2H

; 8193 : 		return TID_GAME_LORD_SKILL_RAGE_E001;
; 8194 : 	return 0;
; 8195 : }

  0000f	c3		 ret	 0
$L285239:

; 8192 : 	if( HasBuff( BUFF_ITEM, II_SYS_SYS_LS_RAGE ) )

  00010	68 37 4e 00 00	 push	 20023			; 00004e37H
  00015	6a 00		 push	 0
  00017	e8 00 00 00 00	 call	 ?HasBuff@CMover@@QAEHGG@Z ; CMover::HasBuff
  0001c	f7 d8		 neg	 eax
  0001e	1b c0		 sbb	 eax, eax
  00020	25 cf 0e 00 00	 and	 eax, 3791		; 00000ecfH

; 8193 : 		return TID_GAME_LORD_SKILL_RAGE_E001;
; 8194 : 	return 0;
; 8195 : }

  00025	c3		 ret	 0
?GetMuteText@CUser@@QAEHXZ ENDP				; CUser::GetMuteText
_TEXT	ENDS
PUBLIC	?IsGuildMaster@CUser@@QAEHXZ			; CUser::IsGuildMaster
EXTRN	?GetGuild@CMover@@QAEPAVCGuild@@XZ:NEAR		; CMover::GetGuild
; Function compile flags: /Ogty
;	COMDAT ?IsGuildMaster@CUser@@QAEHXZ
_TEXT	SEGMENT
?IsGuildMaster@CUser@@QAEHXZ PROC NEAR			; CUser::IsGuildMaster, COMDAT
; _this$ = ecx

; 8532 : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 8533 : 	if( GetGuild() && GetGuild()->IsMaster( m_idPlayer ) )

  00003	e8 00 00 00 00	 call	 ?GetGuild@CMover@@QAEPAVCGuild@@XZ ; CMover::GetGuild
  00008	85 c0		 test	 eax, eax
  0000a	74 1b		 je	 SHORT $L285526
  0000c	57		 push	 edi
  0000d	8b be 38 02 00
	00		 mov	 edi, DWORD PTR [esi+568]
  00013	8b ce		 mov	 ecx, esi
  00015	e8 00 00 00 00	 call	 ?GetGuild@CMover@@QAEPAVCGuild@@XZ ; CMover::GetGuild
  0001a	39 78 44	 cmp	 DWORD PTR [eax+68], edi
  0001d	5f		 pop	 edi
  0001e	75 07		 jne	 SHORT $L285526

; 8534 : 		return TRUE;

  00020	b8 01 00 00 00	 mov	 eax, 1
  00025	5e		 pop	 esi

; 8537 : }

  00026	c3		 ret	 0
$L285526:

; 8535 : 
; 8536 : 	return FALSE;

  00027	33 c0		 xor	 eax, eax
  00029	5e		 pop	 esi

; 8537 : }

  0002a	c3		 ret	 0
?IsGuildMaster@CUser@@QAEHXZ ENDP			; CUser::IsGuildMaster
_TEXT	ENDS
PUBLIC	?SetAddRestPoint@CUser@@AAEHH@Z			; CUser::SetAddRestPoint
EXTRN	?GetRestPointFactor@CGuildHouseMng@@QAEMPAVCUser@@@Z:NEAR ; CGuildHouseMng::GetRestPointFactor
EXTRN	__ftol2:NEAR
EXTRN	__fltused:NEAR
EXTRN	?GetInstance@CGuildHouseMng@@SAPAV1@XZ:NEAR	; CGuildHouseMng::GetInstance
; Function compile flags: /Ogty
;	COMDAT ?SetAddRestPoint@CUser@@AAEHH@Z
_TEXT	SEGMENT
_nRestPoint$ = 8					; size = 4
?SetAddRestPoint@CUser@@AAEHH@Z PROC NEAR		; CUser::SetAddRestPoint, COMDAT
; _this$ = ecx

; 8763 : 	if( nRestPoint == 0 ) return m_nRestPoint;

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _nRestPoint$[esp-4]
  00004	85 c0		 test	 eax, eax
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	75 0a		 jne	 SHORT $L285669
  0000b	8b 86 a8 96 00
	00		 mov	 eax, DWORD PTR [esi+38568]
  00011	5e		 pop	 esi

; 8769 : 
; 8770 : 	return nRemainPoint;
; 8771 : }

  00012	c2 04 00	 ret	 4
$L285669:

; 8764 : 	
; 8765 : 	m_nRestPoint	= (int)( m_nRestPoint + ( nRestPoint * GuildHouseMng->GetRestPointFactor( this ) ) );

  00015	56		 push	 esi
  00016	e8 00 00 00 00	 call	 ?GetInstance@CGuildHouseMng@@SAPAV1@XZ ; CGuildHouseMng::GetInstance
  0001b	8b c8		 mov	 ecx, eax
  0001d	e8 00 00 00 00	 call	 ?GetRestPointFactor@CGuildHouseMng@@QAEMPAVCUser@@@Z ; CGuildHouseMng::GetRestPointFactor
  00022	da 4c 24 08	 fimul	 DWORD PTR _nRestPoint$[esp]
  00026	da 86 a8 96 00
	00		 fiadd	 DWORD PTR [esi+38568]
  0002c	e8 00 00 00 00	 call	 __ftol2

; 8766 : 	int nRemainPoint = m_nRestPoint;
; 8767 : 	if( m_nRestPoint < 0 )	m_nRestPoint = 0;

  00031	85 c0		 test	 eax, eax
  00033	89 86 a8 96 00
	00		 mov	 DWORD PTR [esi+38568], eax
  00039	7d 0a		 jge	 SHORT $L285672
  0003b	c7 86 a8 96 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+38568], 0
$L285672:

; 8768 : 	if( m_nRestPoint > MAX_REST_POINT ) m_nRestPoint = MAX_REST_POINT;

  00045	8b 96 a8 96 00
	00		 mov	 edx, DWORD PTR [esi+38568]
  0004b	b9 40 42 0f 00	 mov	 ecx, 1000000		; 000f4240H
  00050	3b d1		 cmp	 edx, ecx
  00052	7e 06		 jle	 SHORT $L285668
  00054	89 8e a8 96 00
	00		 mov	 DWORD PTR [esi+38568], ecx
$L285668:
  0005a	5e		 pop	 esi

; 8769 : 
; 8770 : 	return nRemainPoint;
; 8771 : }

  0005b	c2 04 00	 ret	 4
?SetAddRestPoint@CUser@@AAEHH@Z ENDP			; CUser::SetAddRestPoint
_TEXT	ENDS
PUBLIC	?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::length
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::length, COMDAT
; _this$ = ecx

; 1104 : 		return (_Mysize);

  00000	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]

; 1105 : 		}

  00003	c3		 ret	 0
?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::length
_TEXT	ENDS
PUBLIC	?size@?$vector@KV?$allocator@K@std@@@std@@QBEIXZ ; std::vector<unsigned long,std::allocator<unsigned long> >::size
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ?size@?$vector@KV?$allocator@K@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@KV?$allocator@K@std@@@std@@QBEIXZ PROC NEAR ; std::vector<unsigned long,std::allocator<unsigned long> >::size, COMDAT
; _this$ = ecx

; 516  : 		return (_Myfirst == 0 ? 0 : _Mylast - _Myfirst);

  00000	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00003	85 d2		 test	 edx, edx
  00005	75 03		 jne	 SHORT $L296351
  00007	33 c0		 xor	 eax, eax

; 517  : 		}

  00009	c3		 ret	 0
$L296351:

; 516  : 		return (_Myfirst == 0 ? 0 : _Mylast - _Myfirst);

  0000a	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  0000d	2b c2		 sub	 eax, edx
  0000f	c1 f8 02	 sar	 eax, 2

; 517  : 		}

  00012	c3		 ret	 0
?size@?$vector@KV?$allocator@K@std@@@std@@QBEIXZ ENDP	; std::vector<unsigned long,std::allocator<unsigned long> >::size
_TEXT	ENDS
PUBLIC	?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::size
; Function compile flags: /Ogty
;	COMDAT ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ PROC NEAR ; std::vector<int,std::allocator<int> >::size, COMDAT
; _this$ = ecx

; 516  : 		return (_Myfirst == 0 ? 0 : _Mylast - _Myfirst);

  00000	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00003	85 d2		 test	 edx, edx
  00005	75 03		 jne	 SHORT $L296356
  00007	33 c0		 xor	 eax, eax

; 517  : 		}

  00009	c3		 ret	 0
$L296356:

; 516  : 		return (_Myfirst == 0 ? 0 : _Mylast - _Myfirst);

  0000a	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  0000d	2b c2		 sub	 eax, edx
  0000f	c1 f8 02	 sar	 eax, 2

; 517  : 		}

  00012	c3		 ret	 0
?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ENDP	; std::vector<int,std::allocator<int> >::size
_TEXT	ENDS
PUBLIC	?size@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::size
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ?size@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBEIXZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::size, COMDAT
; _this$ = ecx

; 448  : 		return (_Mysize);

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]

; 449  : 		}

  00003	c3		 ret	 0
?size@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::size
_TEXT	ENDS
PUBLIC	?GetSize@?$CItemContainer@VCItemElem@@@@QAEHXZ	; CItemContainer<CItemElem>::GetSize
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\item.h
;	COMDAT ?GetSize@?$CItemContainer@VCItemElem@@@@QAEHXZ
_TEXT	SEGMENT
?GetSize@?$CItemContainer@VCItemElem@@@@QAEHXZ PROC NEAR ; CItemContainer<CItemElem>::GetSize, COMDAT
; _this$ = ecx

; 411  : 	int		GetSize() { return int( m_dwIndexNum ); }

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00003	c3		 ret	 0
?GetSize@?$CItemContainer@VCItemElem@@@@QAEHXZ ENDP	; CItemContainer<CItemElem>::GetSize
_TEXT	ENDS
PUBLIC	?GetMax@?$CItemContainer@VCItemElem@@@@QAEHXZ	; CItemContainer<CItemElem>::GetMax
; Function compile flags: /Ogty
;	COMDAT ?GetMax@?$CItemContainer@VCItemElem@@@@QAEHXZ
_TEXT	SEGMENT
?GetMax@?$CItemContainer@VCItemElem@@@@QAEHXZ PROC NEAR	; CItemContainer<CItemElem>::GetMax, COMDAT
; _this$ = ecx

; 412  : 	int		GetMax() { return int( m_dwItemMax ); }

  00000	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  00003	c3		 ret	 0
?GetMax@?$CItemContainer@VCItemElem@@@@QAEHXZ ENDP	; CItemContainer<CItemElem>::GetMax
_TEXT	ENDS
PUBLIC	?size@?$vector@U__GC1TO1TENDER@CGuildCombat1to1Mng@@V?$allocator@U__GC1TO1TENDER@CGuildCombat1to1Mng@@@std@@@std@@QBEIXZ ; std::vector<CGuildCombat1to1Mng::__GC1TO1TENDER,std::allocator<CGuildCombat1to1Mng::__GC1TO1TENDER> >::size
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ?size@?$vector@U__GC1TO1TENDER@CGuildCombat1to1Mng@@V?$allocator@U__GC1TO1TENDER@CGuildCombat1to1Mng@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@U__GC1TO1TENDER@CGuildCombat1to1Mng@@V?$allocator@U__GC1TO1TENDER@CGuildCombat1to1Mng@@@std@@@std@@QBEIXZ PROC NEAR ; std::vector<CGuildCombat1to1Mng::__GC1TO1TENDER,std::allocator<CGuildCombat1to1Mng::__GC1TO1TENDER> >::size, COMDAT
; _this$ = ecx

; 516  : 		return (_Myfirst == 0 ? 0 : _Mylast - _Myfirst);

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	85 c0		 test	 eax, eax
  00005	75 01		 jne	 SHORT $L296370

; 517  : 		}

  00007	c3		 ret	 0
$L296370:

; 516  : 		return (_Myfirst == 0 ? 0 : _Mylast - _Myfirst);

  00008	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  0000b	2b c8		 sub	 ecx, eax
  0000d	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00012	f7 e9		 imul	 ecx
  00014	c1 fa 03	 sar	 edx, 3
  00017	8b c2		 mov	 eax, edx
  00019	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0001c	03 c2		 add	 eax, edx

; 517  : 		}

  0001e	c3		 ret	 0
?size@?$vector@U__GC1TO1TENDER@CGuildCombat1to1Mng@@V?$allocator@U__GC1TO1TENDER@CGuildCombat1to1Mng@@@std@@@std@@QBEIXZ ENDP ; std::vector<CGuildCombat1to1Mng::__GC1TO1TENDER,std::allocator<CGuildCombat1to1Mng::__GC1TO1TENDER> >::size
_TEXT	ENDS
PUBLIC	?size@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEIXZ ; std::vector<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::size
; Function compile flags: /Ogty
;	COMDAT ?size@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEIXZ PROC NEAR ; std::vector<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::size, COMDAT
; _this$ = ecx

; 516  : 		return (_Myfirst == 0 ? 0 : _Mylast - _Myfirst);

  00000	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00003	85 d2		 test	 edx, edx
  00005	75 03		 jne	 SHORT $L296375
  00007	33 c0		 xor	 eax, eax

; 517  : 		}

  00009	c3		 ret	 0
$L296375:

; 516  : 		return (_Myfirst == 0 ? 0 : _Mylast - _Myfirst);

  0000a	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  0000d	2b c2		 sub	 eax, edx
  0000f	c1 f8 02	 sar	 eax, 2

; 517  : 		}

  00012	c3		 ret	 0
?size@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEIXZ ENDP ; std::vector<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::size
_TEXT	ENDS
PUBLIC	?size@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEIXZ ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::size
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\list
;	COMDAT ?size@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEIXZ PROC NEAR ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::size, COMDAT
; _this$ = ecx

; 431  : 		return (_Mysize);

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]

; 432  : 		}

  00003	c3		 ret	 0
?size@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEIXZ ENDP ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::size
_TEXT	ENDS
PUBLIC	?size@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@QBEIXZ ; std::vector<CGuildCombat::__GCGETPOINT,std::allocator<CGuildCombat::__GCGETPOINT> >::size
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ?size@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@QBEIXZ PROC NEAR ; std::vector<CGuildCombat::__GCGETPOINT,std::allocator<CGuildCombat::__GCGETPOINT> >::size, COMDAT
; _this$ = ecx

; 516  : 		return (_Myfirst == 0 ? 0 : _Mylast - _Myfirst);

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	85 c0		 test	 eax, eax
  00005	75 01		 jne	 SHORT $L296383

; 517  : 		}

  00007	c3		 ret	 0
$L296383:

; 516  : 		return (_Myfirst == 0 ? 0 : _Mylast - _Myfirst);

  00008	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  0000b	2b c8		 sub	 ecx, eax
  0000d	b8 39 8e e3 38	 mov	 eax, 954437177		; 38e38e39H
  00012	f7 e9		 imul	 ecx
  00014	c1 fa 03	 sar	 edx, 3
  00017	8b c2		 mov	 eax, edx
  00019	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0001c	03 c2		 add	 eax, edx

; 517  : 		}

  0001e	c3		 ret	 0
?size@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@QBEIXZ ENDP ; std::vector<CGuildCombat::__GCGETPOINT,std::allocator<CGuildCombat::__GCGETPOINT> >::size
_TEXT	ENDS
PUBLIC	?size@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@QBEIXZ ; std::vector<CGuildCombat::__GCPLAYERPOINT,std::allocator<CGuildCombat::__GCPLAYERPOINT> >::size
; Function compile flags: /Ogty
;	COMDAT ?size@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@QBEIXZ PROC NEAR ; std::vector<CGuildCombat::__GCPLAYERPOINT,std::allocator<CGuildCombat::__GCPLAYERPOINT> >::size, COMDAT
; _this$ = ecx

; 516  : 		return (_Myfirst == 0 ? 0 : _Mylast - _Myfirst);

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	85 c0		 test	 eax, eax
  00005	75 01		 jne	 SHORT $L296388

; 517  : 		}

  00007	c3		 ret	 0
$L296388:

; 516  : 		return (_Myfirst == 0 ? 0 : _Mylast - _Myfirst);

  00008	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  0000b	2b c8		 sub	 ecx, eax
  0000d	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00012	f7 e9		 imul	 ecx
  00014	d1 fa		 sar	 edx, 1
  00016	8b c2		 mov	 eax, edx
  00018	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0001b	03 c2		 add	 eax, edx

; 517  : 		}

  0001d	c3		 ret	 0
?size@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@QBEIXZ ENDP ; std::vector<CGuildCombat::__GCPLAYERPOINT,std::allocator<CGuildCombat::__GCPLAYERPOINT> >::size
_TEXT	ENDS
PUBLIC	?size@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QBEIXZ ; std::vector<CGuildCombat::__GuildCombatMember *,std::allocator<CGuildCombat::__GuildCombatMember *> >::size
; Function compile flags: /Ogty
;	COMDAT ?size@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QBEIXZ PROC NEAR ; std::vector<CGuildCombat::__GuildCombatMember *,std::allocator<CGuildCombat::__GuildCombatMember *> >::size, COMDAT
; _this$ = ecx

; 516  : 		return (_Myfirst == 0 ? 0 : _Mylast - _Myfirst);

  00000	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00003	85 d2		 test	 edx, edx
  00005	75 03		 jne	 SHORT $L296393
  00007	33 c0		 xor	 eax, eax

; 517  : 		}

  00009	c3		 ret	 0
$L296393:

; 516  : 		return (_Myfirst == 0 ? 0 : _Mylast - _Myfirst);

  0000a	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  0000d	2b c2		 sub	 eax, edx
  0000f	c1 f8 02	 sar	 eax, 2

; 517  : 		}

  00012	c3		 ret	 0
?size@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QBEIXZ ENDP ; std::vector<CGuildCombat::__GuildCombatMember *,std::allocator<CGuildCombat::__GuildCombatMember *> >::size
_TEXT	ENDS
PUBLIC	?size@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QBEIXZ ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::size
; Function compile flags: /Ogty
;	COMDAT ?size@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QBEIXZ PROC NEAR ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::size, COMDAT
; _this$ = ecx

; 516  : 		return (_Myfirst == 0 ? 0 : _Mylast - _Myfirst);

  00000	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00003	85 d2		 test	 edx, edx
  00005	75 03		 jne	 SHORT $L296398
  00007	33 c0		 xor	 eax, eax

; 517  : 		}

  00009	c3		 ret	 0
$L296398:

; 516  : 		return (_Myfirst == 0 ? 0 : _Mylast - _Myfirst);

  0000a	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  0000d	2b c2		 sub	 eax, edx
  0000f	c1 f8 03	 sar	 eax, 3

; 517  : 		}

  00012	c3		 ret	 0
?size@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QBEIXZ ENDP ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::size
_TEXT	ENDS
PUBLIC	?size@?$vector@U__SECRETROOM_TENDER@@V?$allocator@U__SECRETROOM_TENDER@@@std@@@std@@QBEIXZ ; std::vector<__SECRETROOM_TENDER,std::allocator<__SECRETROOM_TENDER> >::size
; Function compile flags: /Ogty
;	COMDAT ?size@?$vector@U__SECRETROOM_TENDER@@V?$allocator@U__SECRETROOM_TENDER@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@U__SECRETROOM_TENDER@@V?$allocator@U__SECRETROOM_TENDER@@@std@@@std@@QBEIXZ PROC NEAR ; std::vector<__SECRETROOM_TENDER,std::allocator<__SECRETROOM_TENDER> >::size, COMDAT
; _this$ = ecx

; 516  : 		return (_Myfirst == 0 ? 0 : _Mylast - _Myfirst);

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	85 c0		 test	 eax, eax
  00005	75 01		 jne	 SHORT $L296403

; 517  : 		}

  00007	c3		 ret	 0
$L296403:

; 516  : 		return (_Myfirst == 0 ? 0 : _Mylast - _Myfirst);

  00008	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  0000b	2b c8		 sub	 ecx, eax
  0000d	b8 4f ec c4 4e	 mov	 eax, 1321528399		; 4ec4ec4fH
  00012	f7 e9		 imul	 ecx
  00014	c1 fa 04	 sar	 edx, 4
  00017	8b c2		 mov	 eax, edx
  00019	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0001c	03 c2		 add	 eax, edx

; 517  : 		}

  0001e	c3		 ret	 0
?size@?$vector@U__SECRETROOM_TENDER@@V?$allocator@U__SECRETROOM_TENDER@@@std@@@std@@QBEIXZ ENDP ; std::vector<__SECRETROOM_TENDER,std::allocator<__SECRETROOM_TENDER> >::size
_TEXT	ENDS
PUBLIC	?size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::size
; Function compile flags: /Ogty
;	COMDAT ?size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ PROC NEAR ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::size, COMDAT
; _this$ = ecx

; 516  : 		return (_Myfirst == 0 ? 0 : _Mylast - _Myfirst);

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	85 c0		 test	 eax, eax
  00005	75 01		 jne	 SHORT $L296408

; 517  : 		}

  00007	c3		 ret	 0
$L296408:

; 516  : 		return (_Myfirst == 0 ? 0 : _Mylast - _Myfirst);

  00008	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  0000b	2b c8		 sub	 ecx, eax
  0000d	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  00012	f7 e9		 imul	 ecx
  00014	03 d1		 add	 edx, ecx
  00016	c1 fa 04	 sar	 edx, 4
  00019	8b c2		 mov	 eax, edx
  0001b	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0001e	03 c2		 add	 eax, edx

; 517  : 		}

  00020	c3		 ret	 0
?size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::size
_TEXT	ENDS
PUBLIC	?size@?$_Tree@V?$_Tmap_traits@KPAVCRainbowRace@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCRainbowRace@@@std@@@3@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<unsigned long,CRainbowRace *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CRainbowRace *> >,0> >::size
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ?size@?$_Tree@V?$_Tmap_traits@KPAVCRainbowRace@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCRainbowRace@@@std@@@3@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$_Tree@V?$_Tmap_traits@KPAVCRainbowRace@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCRainbowRace@@@std@@@3@$0A@@std@@@std@@QBEIXZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CRainbowRace *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CRainbowRace *> >,0> >::size, COMDAT
; _this$ = ecx

; 448  : 		return (_Mysize);

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]

; 449  : 		}

  00003	c3		 ret	 0
?size@?$_Tree@V?$_Tmap_traits@KPAVCRainbowRace@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCRainbowRace@@@std@@@3@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CRainbowRace *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CRainbowRace *> >,0> >::size
_TEXT	ENDS
PUBLIC	?size@?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEIXZ ; std::vector<CGuildCombat::__JOINPLAYER,std::allocator<CGuildCombat::__JOINPLAYER> >::size
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ?size@?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEIXZ PROC NEAR ; std::vector<CGuildCombat::__JOINPLAYER,std::allocator<CGuildCombat::__JOINPLAYER> >::size, COMDAT
; _this$ = ecx

; 516  : 		return (_Myfirst == 0 ? 0 : _Mylast - _Myfirst);

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	85 c0		 test	 eax, eax
  00005	75 01		 jne	 SHORT $L296416

; 517  : 		}

  00007	c3		 ret	 0
$L296416:

; 516  : 		return (_Myfirst == 0 ? 0 : _Mylast - _Myfirst);

  00008	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  0000b	2b c8		 sub	 ecx, eax
  0000d	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00012	f7 e9		 imul	 ecx
  00014	c1 fa 02	 sar	 edx, 2
  00017	8b c2		 mov	 eax, edx
  00019	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0001c	03 c2		 add	 eax, edx

; 517  : 		}

  0001e	c3		 ret	 0
?size@?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEIXZ ENDP ; std::vector<CGuildCombat::__JOINPLAYER,std::allocator<CGuildCombat::__JOINPLAYER> >::size
_TEXT	ENDS
PUBLIC	?size@?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@QBEIXZ ; std::list<CUser *,std::allocator<CUser *> >::size
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\list
;	COMDAT ?size@?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@QBEIXZ PROC NEAR ; std::list<CUser *,std::allocator<CUser *> >::size, COMDAT
; _this$ = ecx

; 431  : 		return (_Mysize);

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]

; 432  : 		}

  00003	c3		 ret	 0
?size@?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@QBEIXZ ENDP ; std::list<CUser *,std::allocator<CUser *> >::size
_TEXT	ENDS
PUBLIC	?size@?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@QBEIXZ ; std::vector<__ITEMINFO,std::allocator<__ITEMINFO> >::size
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ?size@?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@QBEIXZ PROC NEAR ; std::vector<__ITEMINFO,std::allocator<__ITEMINFO> >::size, COMDAT
; _this$ = ecx

; 516  : 		return (_Myfirst == 0 ? 0 : _Mylast - _Myfirst);

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	85 c0		 test	 eax, eax
  00005	75 01		 jne	 SHORT $L296424

; 517  : 		}

  00007	c3		 ret	 0
$L296424:

; 516  : 		return (_Myfirst == 0 ? 0 : _Mylast - _Myfirst);

  00008	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  0000b	2b c8		 sub	 ecx, eax
  0000d	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00012	f7 e9		 imul	 ecx
  00014	d1 fa		 sar	 edx, 1
  00016	8b c2		 mov	 eax, edx
  00018	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0001b	03 c2		 add	 eax, edx

; 517  : 		}

  0001d	c3		 ret	 0
?size@?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@QBEIXZ ENDP ; std::vector<__ITEMINFO,std::allocator<__ITEMINFO> >::size
_TEXT	ENDS
PUBLIC	??0?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@std@@QAE@XZ ; std::allocator<std::pair<unsigned long const ,CUser *> >::allocator<std::pair<unsigned long const ,CUser *> >
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??0?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@std@@QAE@XZ PROC NEAR ; std::allocator<std::pair<unsigned long const ,CUser *> >::allocator<std::pair<unsigned long const ,CUser *> >, COMDAT
; _this$ = ecx

; 111  : 	allocator()

  00000	8b c1		 mov	 eax, ecx

; 112  : 		{	// construct default allocator (do nothing)
; 113  : 		}

  00002	c3		 ret	 0
??0?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@std@@QAE@XZ ENDP ; std::allocator<std::pair<unsigned long const ,CUser *> >::allocator<std::pair<unsigned long const ,CUser *> >
_TEXT	ENDS
PUBLIC	??0?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@std@@QAE@XZ ; std::allocator<std::pair<unsigned long const ,CCtrl *> >::allocator<std::pair<unsigned long const ,CCtrl *> >
; Function compile flags: /Ogty
;	COMDAT ??0?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@std@@QAE@XZ PROC NEAR ; std::allocator<std::pair<unsigned long const ,CCtrl *> >::allocator<std::pair<unsigned long const ,CCtrl *> >, COMDAT
; _this$ = ecx

; 111  : 	allocator()

  00000	8b c1		 mov	 eax, ecx

; 112  : 		{	// construct default allocator (do nothing)
; 113  : 		}

  00002	c3		 ret	 0
??0?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@std@@QAE@XZ ENDP ; std::allocator<std::pair<unsigned long const ,CCtrl *> >::allocator<std::pair<unsigned long const ,CCtrl *> >
_TEXT	ENDS
PUBLIC	?capacity@?$vector@KV?$allocator@K@std@@@std@@QBEIXZ ; std::vector<unsigned long,std::allocator<unsigned long> >::capacity
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ?capacity@?$vector@KV?$allocator@K@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@KV?$allocator@K@std@@@std@@QBEIXZ PROC NEAR ; std::vector<unsigned long,std::allocator<unsigned long> >::capacity, COMDAT
; _this$ = ecx

; 458  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

  00000	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00003	85 d2		 test	 edx, edx
  00005	75 03		 jne	 SHORT $L296435
  00007	33 c0		 xor	 eax, eax

; 459  : 		}

  00009	c3		 ret	 0
$L296435:

; 458  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

  0000a	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  0000d	2b c2		 sub	 eax, edx
  0000f	c1 f8 02	 sar	 eax, 2

; 459  : 		}

  00012	c3		 ret	 0
?capacity@?$vector@KV?$allocator@K@std@@@std@@QBEIXZ ENDP ; std::vector<unsigned long,std::allocator<unsigned long> >::capacity
_TEXT	ENDS
PUBLIC	?key_comp@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBE?AU?$less@H@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::key_comp
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ?key_comp@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBE?AU?$less@H@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?key_comp@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBE?AU?$less@H@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::key_comp, COMDAT
; _this$ = ecx

; 468  : 		return (this->comp);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 469  : 		}

  00004	c2 04 00	 ret	 4
?key_comp@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBE?AU?$less@H@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::key_comp
_TEXT	ENDS
PUBLIC	??8const_iterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,_Friend,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,_Friend> >,0> >::const_iterator::operator==
; Function compile flags: /Ogty
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8const_iterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,_Friend,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,_Friend> >,0> >::const_iterator::operator==, COMDAT
; _this$ = ecx

; 241  : 			return (_Ptr == _Right._Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Right$[esp-4]
  00006	2b 01		 sub	 eax, DWORD PTR [ecx]
  00008	f7 d8		 neg	 eax
  0000a	1b c0		 sbb	 eax, eax
  0000c	40		 inc	 eax

; 242  : 			}

  0000d	c2 04 00	 ret	 4
??8const_iterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,_Friend,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,_Friend> >,0> >::const_iterator::operator==
_TEXT	ENDS
PUBLIC	??0?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@QAE@XZ ; std::allocator<CGuildCombat::__JOINPLAYER *>::allocator<CGuildCombat::__JOINPLAYER *>
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??0?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@QAE@XZ PROC NEAR ; std::allocator<CGuildCombat::__JOINPLAYER *>::allocator<CGuildCombat::__JOINPLAYER *>, COMDAT
; _this$ = ecx

; 111  : 	allocator()

  00000	8b c1		 mov	 eax, ecx

; 112  : 		{	// construct default allocator (do nothing)
; 113  : 		}

  00002	c3		 ret	 0
??0?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@QAE@XZ ENDP ; std::allocator<CGuildCombat::__JOINPLAYER *>::allocator<CGuildCombat::__JOINPLAYER *>
_TEXT	ENDS
PUBLIC	?_Nextnode@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@PAU342@@Z ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Nextnode
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\list
;	COMDAT ?_Nextnode@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Nextnode@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@PAU342@@Z PROC NEAR ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Nextnode, COMDAT

; 108  : 		return ((_Nodepref)(*_Pnode)._Next);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]

; 109  : 		}

  00004	c3		 ret	 0
?_Nextnode@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@PAU342@@Z ENDP ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Nextnode
_TEXT	ENDS
PUBLIC	?_Prevnode@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@PAU342@@Z ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Prevnode
; Function compile flags: /Ogty
;	COMDAT ?_Prevnode@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Prevnode@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@PAU342@@Z PROC NEAR ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Prevnode, COMDAT

; 113  : 		return ((_Nodepref)(*_Pnode)._Prev);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]
  00004	83 c0 04	 add	 eax, 4

; 114  : 		}

  00007	c3		 ret	 0
?_Prevnode@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@PAU342@@Z ENDP ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Prevnode
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@U_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@I@Z ; std::allocator<std::_List_nod<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Node>::deallocate
EXTRN	??3@YAXPAX@Z:NEAR				; operator delete
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ?deallocate@?$allocator@U_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@U_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@I@Z PROC NEAR ; std::allocator<std::_List_nod<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Node>::deallocate, COMDAT
; _this$ = ecx

; 132  : 		operator delete(_Ptr);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Ptr$[esp-4]
  00004	50		 push	 eax
  00005	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000a	59		 pop	 ecx

; 133  : 		}

  0000b	c2 08 00	 ret	 8
?deallocate@?$allocator@U_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@I@Z ENDP ; std::allocator<std::_List_nod<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Node>::deallocate
_TEXT	ENDS
PUBLIC	?capacity@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::capacity
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ?capacity@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ PROC NEAR ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::capacity, COMDAT
; _this$ = ecx

; 458  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	85 c0		 test	 eax, eax
  00005	75 01		 jne	 SHORT $L296458

; 459  : 		}

  00007	c3		 ret	 0
$L296458:

; 458  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

  00008	8b 49 0c	 mov	 ecx, DWORD PTR [ecx+12]
  0000b	2b c8		 sub	 ecx, eax
  0000d	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  00012	f7 e9		 imul	 ecx
  00014	03 d1		 add	 edx, ecx
  00016	c1 fa 04	 sar	 edx, 4
  00019	8b c2		 mov	 eax, edx
  0001b	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0001e	03 c2		 add	 eax, edx

; 459  : 		}

  00020	c3		 ret	 0
?capacity@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::capacity
_TEXT	ENDS
PUBLIC	??0D3DXVECTOR3@@QAE@XZ				; D3DXVECTOR3::D3DXVECTOR3
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\dx_sdk\d3dx9math.h
;	COMDAT ??0D3DXVECTOR3@@QAE@XZ
_TEXT	SEGMENT
??0D3DXVECTOR3@@QAE@XZ PROC NEAR			; D3DXVECTOR3::D3DXVECTOR3, COMDAT
; _this$ = ecx

; 165  :     D3DXVECTOR3() {};

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0D3DXVECTOR3@@QAE@XZ ENDP				; D3DXVECTOR3::D3DXVECTOR3
_TEXT	ENDS
PUBLIC	??0D3DXVECTOR3@@QAE@MMM@Z			; D3DXVECTOR3::D3DXVECTOR3
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\dx_sdk\d3dx9math.inl
;	COMDAT ??0D3DXVECTOR3@@QAE@MMM@Z
_TEXT	SEGMENT
_fx$ = 8						; size = 4
_fy$ = 12						; size = 4
_fz$ = 16						; size = 4
??0D3DXVECTOR3@@QAE@MMM@Z PROC NEAR			; D3DXVECTOR3::D3DXVECTOR3, COMDAT
; _this$ = ecx

; 300  :     x = fx;
; 301  :     y = fy;

  00000	8b 54 24 08	 mov	 edx, DWORD PTR _fy$[esp-4]
  00004	8b c1		 mov	 eax, ecx
  00006	8b 4c 24 04	 mov	 ecx, DWORD PTR _fx$[esp-4]
  0000a	89 08		 mov	 DWORD PTR [eax], ecx

; 302  :     z = fz;

  0000c	8b 4c 24 0c	 mov	 ecx, DWORD PTR _fz$[esp-4]
  00010	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00013	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 303  : }

  00016	c2 0c 00	 ret	 12			; 0000000cH
??0D3DXVECTOR3@@QAE@MMM@Z ENDP				; D3DXVECTOR3::D3DXVECTOR3
_TEXT	ENDS
PUBLIC	??GD3DXVECTOR3@@QBE?AU0@ABU0@@Z			; D3DXVECTOR3::operator-
; Function compile flags: /Ogty
;	COMDAT ??GD3DXVECTOR3@@QBE?AU0@ABU0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_v$ = 12						; size = 4
??GD3DXVECTOR3@@QBE?AU0@ABU0@@Z PROC NEAR		; D3DXVECTOR3::operator-, COMDAT
; _this$ = ecx

; 383  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00000	d9 41 08	 fld	 DWORD PTR [ecx+8]
  00003	8b 44 24 08	 mov	 eax, DWORD PTR _v$[esp-4]
  00007	d8 60 08	 fsub	 DWORD PTR [eax+8]
  0000a	d9 41 04	 fld	 DWORD PTR [ecx+4]
  0000d	d8 60 04	 fsub	 DWORD PTR [eax+4]
  00010	d9 01		 fld	 DWORD PTR [ecx]
  00012	d8 20		 fsub	 DWORD PTR [eax]
  00014	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  00018	d9 18		 fstp	 DWORD PTR [eax]
  0001a	d9 58 04	 fstp	 DWORD PTR [eax+4]
  0001d	d9 58 08	 fstp	 DWORD PTR [eax+8]

; 384  : }

  00020	c2 08 00	 ret	 8
??GD3DXVECTOR3@@QBE?AU0@ABU0@@Z ENDP			; D3DXVECTOR3::operator-
_TEXT	ENDS
PUBLIC	??8const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CGuildMember *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuildMember *> >,0> >::const_iterator::operator==
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CGuildMember *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuildMember *> >,0> >::const_iterator::operator==, COMDAT
; _this$ = ecx

; 241  : 			return (_Ptr == _Right._Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Right$[esp-4]
  00006	2b 01		 sub	 eax, DWORD PTR [ecx]
  00008	f7 d8		 neg	 eax
  0000a	1b c0		 sbb	 eax, eax
  0000c	40		 inc	 eax

; 242  : 			}

  0000d	c2 04 00	 ret	 4
??8const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CGuildMember *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuildMember *> >,0> >::const_iterator::operator==
_TEXT	ENDS
PUBLIC	??0const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,CParty *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CParty *> >,0> >::const_iterator::const_iterator
; Function compile flags: /Ogty
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@std@@QAE@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CParty *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CParty *> >,0> >::const_iterator::const_iterator, COMDAT
; _this$ = ecx

; 193  : 			{	// construct with null node pointer

  00000	8b c1		 mov	 eax, ecx
  00002	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 194  : 			}

  00008	c3		 ret	 0
??0const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CParty *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CParty *> >,0> >::const_iterator::const_iterator
_TEXT	ENDS
PUBLIC	??8const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CParty *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CParty *> >,0> >::const_iterator::operator==
; Function compile flags: /Ogty
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CParty *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CParty *> >,0> >::const_iterator::operator==, COMDAT
; _this$ = ecx

; 241  : 			return (_Ptr == _Right._Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Right$[esp-4]
  00006	2b 01		 sub	 eax, DWORD PTR [ecx]
  00008	f7 d8		 neg	 eax
  0000a	1b c0		 sbb	 eax, eax
  0000c	40		 inc	 eax

; 242  : 			}

  0000d	c2 04 00	 ret	 4
??8const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CParty *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CParty *> >,0> >::const_iterator::operator==
_TEXT	ENDS
PUBLIC	??Econst_iterator@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAEAAV012@XZ ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::const_iterator::operator++
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\list
;	COMDAT ??Econst_iterator@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??Econst_iterator@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAEAAV012@XZ PROC NEAR ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::const_iterator::operator++, COMDAT
; _this$ = ecx

; 170  : 			{	// preincrement

  00000	8b c1		 mov	 eax, ecx

; 171  : 			_Ptr = _Nextnode(_Ptr);

  00002	8b 08		 mov	 ecx, DWORD PTR [eax]
  00004	8b 11		 mov	 edx, DWORD PTR [ecx]
  00006	89 10		 mov	 DWORD PTR [eax], edx

; 172  : 			return (*this);
; 173  : 			}

  00008	c3		 ret	 0
??Econst_iterator@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAEAAV012@XZ ENDP ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::const_iterator::operator++
_TEXT	ENDS
PUBLIC	??8const_iterator@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBE_NABV012@@Z ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::const_iterator::operator==
; Function compile flags: /Ogty
;	COMDAT ??8const_iterator@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8const_iterator@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBE_NABV012@@Z PROC NEAR ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::const_iterator::operator==, COMDAT
; _this$ = ecx

; 197  : 			return (_Ptr == _Right._Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Right$[esp-4]
  00006	2b 01		 sub	 eax, DWORD PTR [ecx]
  00008	f7 d8		 neg	 eax
  0000a	1b c0		 sbb	 eax, eax
  0000c	40		 inc	 eax

; 198  : 			}

  0000d	c2 04 00	 ret	 4
??8const_iterator@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBE_NABV012@@Z ENDP ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::const_iterator::operator==
_TEXT	ENDS
PUBLIC	?_Nextnode@?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@2@PAU342@@Z ; std::list<CUser *,std::allocator<CUser *> >::_Nextnode
; Function compile flags: /Ogty
;	COMDAT ?_Nextnode@?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Nextnode@?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@2@PAU342@@Z PROC NEAR ; std::list<CUser *,std::allocator<CUser *> >::_Nextnode, COMDAT

; 108  : 		return ((_Nodepref)(*_Pnode)._Next);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]

; 109  : 		}

  00004	c3		 ret	 0
?_Nextnode@?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@2@PAU342@@Z ENDP ; std::list<CUser *,std::allocator<CUser *> >::_Nextnode
_TEXT	ENDS
PUBLIC	?_Prevnode@?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@2@PAU342@@Z ; std::list<CUser *,std::allocator<CUser *> >::_Prevnode
; Function compile flags: /Ogty
;	COMDAT ?_Prevnode@?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Prevnode@?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@2@PAU342@@Z PROC NEAR ; std::list<CUser *,std::allocator<CUser *> >::_Prevnode, COMDAT

; 113  : 		return ((_Nodepref)(*_Pnode)._Prev);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]
  00004	83 c0 04	 add	 eax, 4

; 114  : 		}

  00007	c3		 ret	 0
?_Prevnode@?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@2@PAU342@@Z ENDP ; std::list<CUser *,std::allocator<CUser *> >::_Prevnode
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVCUser@@@std@@QAE@XZ		; std::allocator<CUser *>::allocator<CUser *>
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??0?$allocator@PAVCUser@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@PAVCUser@@@std@@QAE@XZ PROC NEAR		; std::allocator<CUser *>::allocator<CUser *>, COMDAT
; _this$ = ecx

; 111  : 	allocator()

  00000	8b c1		 mov	 eax, ecx

; 112  : 		{	// construct default allocator (do nothing)
; 113  : 		}

  00002	c3		 ret	 0
??0?$allocator@PAVCUser@@@std@@QAE@XZ ENDP		; std::allocator<CUser *>::allocator<CUser *>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@U_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@2@I@Z ; std::allocator<std::_List_nod<CUser *,std::allocator<CUser *> >::_Node>::deallocate
; Function compile flags: /Ogty
;	COMDAT ?deallocate@?$allocator@U_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@U_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@2@I@Z PROC NEAR ; std::allocator<std::_List_nod<CUser *,std::allocator<CUser *> >::_Node>::deallocate, COMDAT
; _this$ = ecx

; 132  : 		operator delete(_Ptr);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Ptr$[esp-4]
  00004	50		 push	 eax
  00005	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000a	59		 pop	 ecx

; 133  : 		}

  0000b	c2 08 00	 ret	 8
?deallocate@?$allocator@U_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@2@I@Z ENDP ; std::allocator<std::_List_nod<CUser *,std::allocator<CUser *> >::_Node>::deallocate
_TEXT	ENDS
PUBLIC	??0const_iterator@?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@QAE@XZ ; std::list<CUser *,std::allocator<CUser *> >::const_iterator::const_iterator
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\list
;	COMDAT ??0const_iterator@?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0const_iterator@?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@QAE@XZ PROC NEAR ; std::list<CUser *,std::allocator<CUser *> >::const_iterator::const_iterator, COMDAT
; _this$ = ecx

; 151  : 			{	// construct with null node pointer

  00000	8b c1		 mov	 eax, ecx
  00002	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 152  : 			}

  00008	c3		 ret	 0
??0const_iterator@?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@QAE@XZ ENDP ; std::list<CUser *,std::allocator<CUser *> >::const_iterator::const_iterator
_TEXT	ENDS
PUBLIC	??Econst_iterator@?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@QAEAAV012@XZ ; std::list<CUser *,std::allocator<CUser *> >::const_iterator::operator++
; Function compile flags: /Ogty
;	COMDAT ??Econst_iterator@?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??Econst_iterator@?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@QAEAAV012@XZ PROC NEAR ; std::list<CUser *,std::allocator<CUser *> >::const_iterator::operator++, COMDAT
; _this$ = ecx

; 170  : 			{	// preincrement

  00000	8b c1		 mov	 eax, ecx

; 171  : 			_Ptr = _Nextnode(_Ptr);

  00002	8b 08		 mov	 ecx, DWORD PTR [eax]
  00004	8b 11		 mov	 edx, DWORD PTR [ecx]
  00006	89 10		 mov	 DWORD PTR [eax], edx

; 172  : 			return (*this);
; 173  : 			}

  00008	c3		 ret	 0
??Econst_iterator@?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@QAEAAV012@XZ ENDP ; std::list<CUser *,std::allocator<CUser *> >::const_iterator::operator++
_TEXT	ENDS
PUBLIC	??8const_iterator@?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@QBE_NABV012@@Z ; std::list<CUser *,std::allocator<CUser *> >::const_iterator::operator==
; Function compile flags: /Ogty
;	COMDAT ??8const_iterator@?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8const_iterator@?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@QBE_NABV012@@Z PROC NEAR ; std::list<CUser *,std::allocator<CUser *> >::const_iterator::operator==, COMDAT
; _this$ = ecx

; 197  : 			return (_Ptr == _Right._Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Right$[esp-4]
  00006	2b 01		 sub	 eax, DWORD PTR [ecx]
  00008	f7 d8		 neg	 eax
  0000a	1b c0		 sbb	 eax, eax
  0000c	40		 inc	 eax

; 198  : 			}

  0000d	c2 04 00	 ret	 4
??8const_iterator@?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@QBE_NABV012@@Z ENDP ; std::list<CUser *,std::allocator<CUser *> >::const_iterator::operator==
_TEXT	ENDS
PUBLIC	?capacity@?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@QBEIXZ ; std::vector<__ITEMINFO,std::allocator<__ITEMINFO> >::capacity
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ?capacity@?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@QBEIXZ PROC NEAR ; std::vector<__ITEMINFO,std::allocator<__ITEMINFO> >::capacity, COMDAT
; _this$ = ecx

; 458  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	85 c0		 test	 eax, eax
  00005	75 01		 jne	 SHORT $L296522

; 459  : 		}

  00007	c3		 ret	 0
$L296522:

; 458  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

  00008	8b 49 0c	 mov	 ecx, DWORD PTR [ecx+12]
  0000b	2b c8		 sub	 ecx, eax
  0000d	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00012	f7 e9		 imul	 ecx
  00014	d1 fa		 sar	 edx, 1
  00016	8b c2		 mov	 eax, edx
  00018	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0001b	03 c2		 add	 eax, edx

; 459  : 		}

  0001d	c3		 ret	 0
?capacity@?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@QBEIXZ ENDP ; std::vector<__ITEMINFO,std::allocator<__ITEMINFO> >::capacity
_TEXT	ENDS
PUBLIC	??0?$allocator@U__ITEMINFO@@@std@@QAE@XZ	; std::allocator<__ITEMINFO>::allocator<__ITEMINFO>
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??0?$allocator@U__ITEMINFO@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@U__ITEMINFO@@@std@@QAE@XZ PROC NEAR	; std::allocator<__ITEMINFO>::allocator<__ITEMINFO>, COMDAT
; _this$ = ecx

; 111  : 	allocator()

  00000	8b c1		 mov	 eax, ecx

; 112  : 		{	// construct default allocator (do nothing)
; 113  : 		}

  00002	c3		 ret	 0
??0?$allocator@U__ITEMINFO@@@std@@QAE@XZ ENDP		; std::allocator<__ITEMINFO>::allocator<__ITEMINFO>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::deallocate
; Function compile flags: /Ogty
;	COMDAT ?deallocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z PROC NEAR ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::deallocate, COMDAT
; _this$ = ecx

; 132  : 		operator delete(_Ptr);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Ptr$[esp-4]
  00004	50		 push	 eax
  00005	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000a	59		 pop	 ecx

; 133  : 		}

  0000b	c2 08 00	 ret	 8
?deallocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ENDP ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::deallocate
_TEXT	ENDS
PUBLIC	??0?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<unsigned long const ,CUser *> >::allocator<std::pair<unsigned long const ,CUser *> >
; Function compile flags: /Ogty
;	COMDAT ??0?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@std@@QAE@ABV01@@Z PROC NEAR ; std::allocator<std::pair<unsigned long const ,CUser *> >::allocator<std::pair<unsigned long const ,CUser *> >, COMDAT
; _this$ = ecx

; 115  : 	allocator(const allocator<_Ty>&)

  00000	8b c1		 mov	 eax, ecx

; 116  : 		{	// construct by copying (do nothing)
; 117  : 		}

  00002	c2 04 00	 ret	 4
??0?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<std::pair<unsigned long const ,CUser *> >::allocator<std::pair<unsigned long const ,CUser *> >
_TEXT	ENDS
PUBLIC	??0?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<unsigned long const ,CCtrl *> >::allocator<std::pair<unsigned long const ,CCtrl *> >
; Function compile flags: /Ogty
;	COMDAT ??0?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@std@@QAE@ABV01@@Z PROC NEAR ; std::allocator<std::pair<unsigned long const ,CCtrl *> >::allocator<std::pair<unsigned long const ,CCtrl *> >, COMDAT
; _this$ = ecx

; 115  : 	allocator(const allocator<_Ty>&)

  00000	8b c1		 mov	 eax, ecx

; 116  : 		{	// construct by copying (do nothing)
; 117  : 		}

  00002	c2 04 00	 ret	 4
??0?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<std::pair<unsigned long const ,CCtrl *> >::allocator<std::pair<unsigned long const ,CCtrl *> >
_TEXT	ENDS
PUBLIC	??0?$allocator@U?$pair@$$CBHH@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<int const ,int> >::allocator<std::pair<int const ,int> >
; Function compile flags: /Ogty
;	COMDAT ??0?$allocator@U?$pair@$$CBHH@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@U?$pair@$$CBHH@std@@@std@@QAE@ABV01@@Z PROC NEAR ; std::allocator<std::pair<int const ,int> >::allocator<std::pair<int const ,int> >, COMDAT
; _this$ = ecx

; 115  : 	allocator(const allocator<_Ty>&)

  00000	8b c1		 mov	 eax, ecx

; 116  : 		{	// construct by copying (do nothing)
; 117  : 		}

  00002	c2 04 00	 ret	 4
??0?$allocator@U?$pair@$$CBHH@std@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<std::pair<int const ,int> >::allocator<std::pair<int const ,int> >
_TEXT	ENDS
PUBLIC	??Dconst_iterator@?$vector@EV?$allocator@E@std@@@std@@QBEABEXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::const_iterator::operator*
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ??Dconst_iterator@?$vector@EV?$allocator@E@std@@@std@@QBEABEXZ
_TEXT	SEGMENT
??Dconst_iterator@?$vector@EV?$allocator@E@std@@@std@@QBEABEXZ PROC NEAR ; std::vector<unsigned char,std::allocator<unsigned char> >::const_iterator::operator*, COMDAT
; _this$ = ecx

; 80   : 
; 81   : 
; 82   : 			return (*_Myptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 83   : 			}

  00002	c3		 ret	 0
??Dconst_iterator@?$vector@EV?$allocator@E@std@@@std@@QBEABEXZ ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::const_iterator::operator*
_TEXT	ENDS
PUBLIC	?_Left@?$_Tree@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CParty *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CParty *> >,0> >::_Left
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Left@?$_Tree@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CParty *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CParty *> >,0> >::_Left, COMDAT

; 147  : 		return ((_Nodepref)(*_Pnode)._Left);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]

; 148  : 		}

  00004	c3		 ret	 0
?_Left@?$_Tree@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CParty *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CParty *> >,0> >::_Left
_TEXT	ENDS
PUBLIC	?_Left@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,_Friend,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,_Friend> >,0> >::_Left
; Function compile flags: /Ogty
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Left@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,_Friend,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,_Friend> >,0> >::_Left, COMDAT

; 147  : 		return ((_Nodepref)(*_Pnode)._Left);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]

; 148  : 		}

  00004	c3		 ret	 0
?_Left@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,_Friend,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,_Friend> >,0> >::_Left
_TEXT	ENDS
PUBLIC	?D3DXVec3LengthSq@@YAMPBUD3DXVECTOR3@@@Z	; D3DXVec3LengthSq
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\dx_sdk\d3dx9math.inl
;	COMDAT ?D3DXVec3LengthSq@@YAMPBUD3DXVECTOR3@@@Z
_TEXT	SEGMENT
_pV$ = 8						; size = 4
?D3DXVec3LengthSq@@YAMPBUD3DXVECTOR3@@@Z PROC NEAR	; D3DXVec3LengthSq, COMDAT

; 1693 : #ifdef D3DX_DEBUG
; 1694 :     if(!pV)
; 1695 :         return 0.0f;
; 1696 : #endif
; 1697 : 
; 1698 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _pV$[esp-4]
  00004	d9 40 08	 fld	 DWORD PTR [eax+8]
  00007	d9 40 04	 fld	 DWORD PTR [eax+4]
  0000a	d9 00		 fld	 DWORD PTR [eax]
  0000c	d9 c0		 fld	 ST(0)
  0000e	d8 c9		 fmul	 ST(0), ST(1)
  00010	d9 c2		 fld	 ST(2)
  00012	d8 cb		 fmul	 ST(0), ST(3)
  00014	de c1		 faddp	 ST(1), ST(0)
  00016	d9 c3		 fld	 ST(3)
  00018	d8 cc		 fmul	 ST(0), ST(4)
  0001a	de c1		 faddp	 ST(1), ST(0)
  0001c	dd db		 fstp	 ST(3)
  0001e	dd d8		 fstp	 ST(0)
  00020	dd d8		 fstp	 ST(0)

; 1699 : }

  00022	c3		 ret	 0
?D3DXVec3LengthSq@@YAMPBUD3DXVECTOR3@@@Z ENDP		; D3DXVec3LengthSq
_TEXT	ENDS
PUBLIC	??0const_iterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,_Friend,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,_Friend> >,0> >::const_iterator::const_iterator
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
??0const_iterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,_Friend,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,_Friend> >,0> >::const_iterator::const_iterator, COMDAT
; _this$ = ecx

; 200  : 			{	// construct with node pointer _Pnode

  00000	8b c1		 mov	 eax, ecx
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Pnode$[esp-4]
  00006	89 08		 mov	 DWORD PTR [eax], ecx

; 201  : 			}

  00008	c2 04 00	 ret	 4
??0const_iterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,_Friend,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,_Friend> >,0> >::const_iterator::const_iterator
_TEXT	ENDS
PUBLIC	?_Left@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CGuildMember *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuildMember *> >,0> >::_Left
; Function compile flags: /Ogty
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Left@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CGuildMember *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuildMember *> >,0> >::_Left, COMDAT

; 147  : 		return ((_Nodepref)(*_Pnode)._Left);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]

; 148  : 		}

  00004	c3		 ret	 0
?_Left@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CGuildMember *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuildMember *> >,0> >::_Left
_TEXT	ENDS
PUBLIC	??0?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@QAE@ABV01@@Z ; std::allocator<CGuildCombat::__JOINPLAYER *>::allocator<CGuildCombat::__JOINPLAYER *>
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??0?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@QAE@ABV01@@Z PROC NEAR ; std::allocator<CGuildCombat::__JOINPLAYER *>::allocator<CGuildCombat::__JOINPLAYER *>, COMDAT
; _this$ = ecx

; 115  : 	allocator(const allocator<_Ty>&)

  00000	8b c1		 mov	 eax, ecx

; 116  : 		{	// construct by copying (do nothing)
; 117  : 		}

  00002	c2 04 00	 ret	 4
??0?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<CGuildCombat::__JOINPLAYER *>::allocator<CGuildCombat::__JOINPLAYER *>
_TEXT	ENDS
PUBLIC	?_Myval@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@KAAAPAU__JOINPLAYER@CGuildCombat@@PAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@@Z ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Myval
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\list
;	COMDAT ?_Myval@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@KAAAPAU__JOINPLAYER@CGuildCombat@@PAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Myval@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@KAAAPAU__JOINPLAYER@CGuildCombat@@PAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@@Z PROC NEAR ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Myval, COMDAT

; 118  : 		return ((_Vref)(*_Pnode)._Myval);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]
  00004	83 c0 08	 add	 eax, 8

; 119  : 		}

  00007	c3		 ret	 0
?_Myval@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@KAAAPAU__JOINPLAYER@CGuildCombat@@PAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@@Z ENDP ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Myval
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@QAEXPAU__REQUESTGUILD@CGuildCombat@@I@Z ; std::allocator<CGuildCombat::__REQUESTGUILD>::deallocate
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ?deallocate@?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@QAEXPAU__REQUESTGUILD@CGuildCombat@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@QAEXPAU__REQUESTGUILD@CGuildCombat@@I@Z PROC NEAR ; std::allocator<CGuildCombat::__REQUESTGUILD>::deallocate, COMDAT
; _this$ = ecx

; 132  : 		operator delete(_Ptr);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Ptr$[esp-4]
  00004	50		 push	 eax
  00005	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000a	59		 pop	 ecx

; 133  : 		}

  0000b	c2 08 00	 ret	 8
?deallocate@?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@QAEXPAU__REQUESTGUILD@CGuildCombat@@I@Z ENDP ; std::allocator<CGuildCombat::__REQUESTGUILD>::deallocate
_TEXT	ENDS
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??0_LogItemInfo@@QAE@XZ				; _LogItemInfo::_LogItemInfo
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_network\cmnhdr.h
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ??0_LogItemInfo@@QAE@XZ
_TEXT	SEGMENT
??0_LogItemInfo@@QAE@XZ PROC NEAR			; _LogItemInfo::_LogItemInfo, COMDAT
; _this$ = ecx

; 641  : 	_LogItemInfo()

  00000	8b c1		 mov	 eax, ecx
  00002	56		 push	 esi

; 642  : 	{
; 643  : 		Action = _T("");
; 644  : 		SendName = _T("");
; 645  : 		RecvName = _T("");
; 646  : 		WorldId = Gold = Gold2 = 0;
; 647  : 		Negudo = 0;
; 648  : 		MaxNegudo = 0;
; 649  : 		ItemNo = 0;
; 650  : 		//ItemName = _T("");
; 651  : 		::memset( szItemName, 0, sizeof(szItemName) );

  00003	33 d2		 xor	 edx, edx
  00005	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  0000a	89 08		 mov	 DWORD PTR [eax], ecx
  0000c	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  0000f	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  00012	33 c9		 xor	 ecx, ecx
  00014	89 48 14	 mov	 DWORD PTR [eax+20], ecx
  00017	89 48 10	 mov	 DWORD PTR [eax+16], ecx
  0001a	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  0001d	89 48 1c	 mov	 DWORD PTR [eax+28], ecx
  00020	89 48 20	 mov	 DWORD PTR [eax+32], ecx
  00023	89 48 18	 mov	 DWORD PTR [eax+24], ecx
  00026	8d 70 24	 lea	 esi, DWORD PTR [eax+36]
  00029	89 16		 mov	 DWORD PTR [esi], edx
  0002b	89 56 04	 mov	 DWORD PTR [esi+4], edx
  0002e	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00031	89 56 0c	 mov	 DWORD PTR [esi+12], edx
  00034	89 56 10	 mov	 DWORD PTR [esi+16], edx
  00037	89 56 14	 mov	 DWORD PTR [esi+20], edx
  0003a	89 56 18	 mov	 DWORD PTR [esi+24], edx
  0003d	89 56 1c	 mov	 DWORD PTR [esi+28], edx

; 652  : 		itemNumber = 0;

  00040	89 48 44	 mov	 DWORD PTR [eax+68], ecx

; 653  : 		nAbilityOption = 0;

  00043	89 48 48	 mov	 DWORD PTR [eax+72], ecx

; 654  : 		Gold_1 = 0;

  00046	89 48 4c	 mov	 DWORD PTR [eax+76], ecx

; 655  : 		nSlot = 100;
; 656  : 		nSlot1 = 100;
; 657  : 		nItemResist = 0;

  00049	89 48 58	 mov	 DWORD PTR [eax+88], ecx

; 658  : 		nResistAbilityOption = 0;

  0004c	89 48 5c	 mov	 DWORD PTR [eax+92], ecx

; 659  : 		m_bCharged = FALSE;

  0004f	89 48 60	 mov	 DWORD PTR [eax+96], ecx

; 660  : 		m_dwKeepTime = 0;

  00052	89 48 64	 mov	 DWORD PTR [eax+100], ecx

; 661  : #if __VER >= 11 // __SYS_IDENTIFY
; 662  : 		m_iRandomOptItemId = 0;

  00055	89 48 68	 mov	 DWORD PTR [eax+104], ecx
  00058	89 48 6c	 mov	 DWORD PTR [eax+108], ecx

; 663  : #else	//__SYS_IDENTIFY
; 664  : 		m_nRandomOptItemId = 0;
; 665  : #endif	// __SYS_IDENTIFY
; 666  : #if __VER >= 12 // __EXT_PIERCING
; 667  : 		nPiercedSize = 0;

  0005b	89 48 70	 mov	 DWORD PTR [eax+112], ecx
  0005e	ba 64 00 00 00	 mov	 edx, 100		; 00000064H
  00063	89 50 50	 mov	 DWORD PTR [eax+80], edx
  00066	89 50 54	 mov	 DWORD PTR [eax+84], edx

; 668  : //		for( int i=0; i<MAX_PIERCING_WEAPON; i++ )
; 669  : //			adwItemId[i] = 0;
; 670  : 		memset( adwItemId, 0, sizeof(adwItemId) );

  00069	33 d2		 xor	 edx, edx
  0006b	8d 70 74	 lea	 esi, DWORD PTR [eax+116]
  0006e	89 16		 mov	 DWORD PTR [esi], edx
  00070	89 56 04	 mov	 DWORD PTR [esi+4], edx
  00073	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00076	89 56 0c	 mov	 DWORD PTR [esi+12], edx
  00079	89 56 10	 mov	 DWORD PTR [esi+16], edx
  0007c	89 56 14	 mov	 DWORD PTR [esi+20], edx
  0007f	89 56 18	 mov	 DWORD PTR [esi+24], edx
  00082	89 56 1c	 mov	 DWORD PTR [esi+28], edx
  00085	89 56 20	 mov	 DWORD PTR [esi+32], edx
  00088	89 56 24	 mov	 DWORD PTR [esi+36], edx

; 671  : 		nUMPiercedSize = 0;

  0008b	89 88 9c 00 00
	00		 mov	 DWORD PTR [eax+156], ecx

; 672  : //		for( i=0; i<MAX_PIERCING_ULTIMATE; i++ )
; 673  : //	adwUMItemId[i] = 0;
; 674  : 		memset( adwUMItemId, 0, sizeof(adwUMItemId) );

  00091	8d b0 a0 00 00
	00		 lea	 esi, DWORD PTR [eax+160]
  00097	89 16		 mov	 DWORD PTR [esi], edx
  00099	89 56 04	 mov	 DWORD PTR [esi+4], edx
  0009c	89 56 08	 mov	 DWORD PTR [esi+8], edx
  0009f	89 56 0c	 mov	 DWORD PTR [esi+12], edx
  000a2	89 56 10	 mov	 DWORD PTR [esi+16], edx

; 675  : #else // __EXT_PIERCING
; 676  : 		nPiercedSize = 0;
; 677  : 		adwItemId0 = 0;
; 678  : 		adwItemId1 = 0;
; 679  : 		adwItemId2 = 0;
; 680  : 		adwItemId3 = 0;
; 681  : #if __VER >= 9 // __ULTIMATE
; 682  : 		adwItemId4 = 0;
; 683  : #endif // __ULTIMATE
; 684  : #endif // __EXT_PIERCING
; 685  : #if __VER >= 9 // __PET_0410
; 686  : 		nPetKind = 0;

  000a5	88 88 b4 00 00
	00		 mov	 BYTE PTR [eax+180], cl

; 687  : 		nPetLevel = 0;

  000ab	88 88 b5 00 00
	00		 mov	 BYTE PTR [eax+181], cl

; 688  : 		dwPetExp = 0;

  000b1	89 88 b8 00 00
	00		 mov	 DWORD PTR [eax+184], ecx

; 689  : 		wPetEnergy = 0;

  000b7	66 89 88 bc 00
	00 00		 mov	 WORD PTR [eax+188], cx

; 690  : 		wPetLife = 0;

  000be	66 89 88 be 00
	00 00		 mov	 WORD PTR [eax+190], cx

; 691  : 		nPetAL_D = 0;

  000c5	88 88 c0 00 00
	00		 mov	 BYTE PTR [eax+192], cl

; 692  : 		nPetAL_C = 0;

  000cb	88 88 c1 00 00
	00		 mov	 BYTE PTR [eax+193], cl

; 693  : 		nPetAL_B = 0;

  000d1	88 88 c2 00 00
	00		 mov	 BYTE PTR [eax+194], cl

; 694  : 		nPetAL_A = 0;

  000d7	88 88 c3 00 00
	00		 mov	 BYTE PTR [eax+195], cl

; 695  : 		nPetAL_S = 0;

  000dd	88 88 c4 00 00
	00		 mov	 BYTE PTR [eax+196], cl
  000e3	5e		 pop	 esi

; 696  : #endif // __PET_0410
; 697  : 	}

  000e4	c3		 ret	 0
??0_LogItemInfo@@QAE@XZ ENDP				; _LogItemInfo::_LogItemInfo
_TEXT	ENDS
PUBLIC	?time_null@@YAJXZ				; time_null
EXTRN	?g_tCurrent@@3JA:DWORD				; g_tCurrent
; Function compile flags: /Ogty
;	COMDAT ?time_null@@YAJXZ
_TEXT	SEGMENT
?time_null@@YAJXZ PROC NEAR				; time_null, COMDAT

; 702  : #if defined(__WORLDSERVER) || defined(__CLIENT)
; 703  : 	return	g_tCurrent;

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_tCurrent@@3JA ; g_tCurrent

; 704  : #else	//
; 705  : 	return time( NULL );
; 706  : #endif	//
; 707  : }

  00005	c3		 ret	 0
?time_null@@YAJXZ ENDP					; time_null
_TEXT	ENDS
PUBLIC	??0const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CGuildMember *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuildMember *> >,0> >::const_iterator::const_iterator
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
??0const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CGuildMember *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuildMember *> >,0> >::const_iterator::const_iterator, COMDAT
; _this$ = ecx

; 200  : 			{	// construct with node pointer _Pnode

  00000	8b c1		 mov	 eax, ecx
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Pnode$[esp-4]
  00006	89 08		 mov	 DWORD PTR [eax], ecx

; 201  : 			}

  00008	c2 04 00	 ret	 4
??0const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CGuildMember *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuildMember *> >,0> >::const_iterator::const_iterator
_TEXT	ENDS
PUBLIC	??0const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CParty *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CParty *> >,0> >::const_iterator::const_iterator
; Function compile flags: /Ogty
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
??0const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CParty *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CParty *> >,0> >::const_iterator::const_iterator, COMDAT
; _this$ = ecx

; 200  : 			{	// construct with node pointer _Pnode

  00000	8b c1		 mov	 eax, ecx
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Pnode$[esp-4]
  00006	89 08		 mov	 DWORD PTR [eax], ecx

; 201  : 			}

  00008	c2 04 00	 ret	 4
??0const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CParty *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CParty *> >,0> >::const_iterator::const_iterator
_TEXT	ENDS
PUBLIC	??0const_iterator@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE@PAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@@Z ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::const_iterator::const_iterator
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\list
;	COMDAT ??0const_iterator@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE@PAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
??0const_iterator@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE@PAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@@Z PROC NEAR ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::const_iterator::const_iterator, COMDAT
; _this$ = ecx

; 156  : 			{	// construct with node pointer _Pnode

  00000	8b c1		 mov	 eax, ecx
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Pnode$[esp-4]
  00006	89 08		 mov	 DWORD PTR [eax], ecx

; 157  : 			}

  00008	c2 04 00	 ret	 4
??0const_iterator@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE@PAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@@Z ENDP ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::const_iterator::const_iterator
_TEXT	ENDS
PUBLIC	?_Mynode@const_iterator@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@3@XZ ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::const_iterator::_Mynode
; Function compile flags: /Ogty
;	COMDAT ?_Mynode@const_iterator@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@3@XZ
_TEXT	SEGMENT
?_Mynode@const_iterator@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@3@XZ PROC NEAR ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::const_iterator::_Mynode, COMDAT
; _this$ = ecx

; 207  : 			return (_Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 208  : 			}

  00002	c3		 ret	 0
?_Mynode@const_iterator@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@3@XZ ENDP ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::const_iterator::_Mynode
_TEXT	ENDS
PUBLIC	?_Myval@?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@KAAAPAVCUser@@PAU_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@2@@Z ; std::list<CUser *,std::allocator<CUser *> >::_Myval
; Function compile flags: /Ogty
;	COMDAT ?_Myval@?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@KAAAPAVCUser@@PAU_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Myval@?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@KAAAPAVCUser@@PAU_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@2@@Z PROC NEAR ; std::list<CUser *,std::allocator<CUser *> >::_Myval, COMDAT

; 118  : 		return ((_Vref)(*_Pnode)._Myval);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]
  00004	83 c0 08	 add	 eax, 8

; 119  : 		}

  00007	c3		 ret	 0
?_Myval@?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@KAAAPAVCUser@@PAU_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@2@@Z ENDP ; std::list<CUser *,std::allocator<CUser *> >::_Myval
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVCUser@@@std@@QAE@ABV01@@Z	; std::allocator<CUser *>::allocator<CUser *>
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??0?$allocator@PAVCUser@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@PAVCUser@@@std@@QAE@ABV01@@Z PROC NEAR	; std::allocator<CUser *>::allocator<CUser *>, COMDAT
; _this$ = ecx

; 115  : 	allocator(const allocator<_Ty>&)

  00000	8b c1		 mov	 eax, ecx

; 116  : 		{	// construct by copying (do nothing)
; 117  : 		}

  00002	c2 04 00	 ret	 4
??0?$allocator@PAVCUser@@@std@@QAE@ABV01@@Z ENDP	; std::allocator<CUser *>::allocator<CUser *>
_TEXT	ENDS
PUBLIC	??0const_iterator@?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@QAE@PAU_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@2@@Z ; std::list<CUser *,std::allocator<CUser *> >::const_iterator::const_iterator
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\list
;	COMDAT ??0const_iterator@?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@QAE@PAU_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
??0const_iterator@?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@QAE@PAU_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@2@@Z PROC NEAR ; std::list<CUser *,std::allocator<CUser *> >::const_iterator::const_iterator, COMDAT
; _this$ = ecx

; 156  : 			{	// construct with node pointer _Pnode

  00000	8b c1		 mov	 eax, ecx
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Pnode$[esp-4]
  00006	89 08		 mov	 DWORD PTR [eax], ecx

; 157  : 			}

  00008	c2 04 00	 ret	 4
??0const_iterator@?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@QAE@PAU_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@2@@Z ENDP ; std::list<CUser *,std::allocator<CUser *> >::const_iterator::const_iterator
_TEXT	ENDS
PUBLIC	?_Mynode@const_iterator@?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@QBEPAU_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@3@XZ ; std::list<CUser *,std::allocator<CUser *> >::const_iterator::_Mynode
; Function compile flags: /Ogty
;	COMDAT ?_Mynode@const_iterator@?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@QBEPAU_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@3@XZ
_TEXT	SEGMENT
?_Mynode@const_iterator@?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@QBEPAU_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@3@XZ PROC NEAR ; std::list<CUser *,std::allocator<CUser *> >::const_iterator::_Mynode, COMDAT
; _this$ = ecx

; 207  : 			return (_Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 208  : 			}

  00002	c3		 ret	 0
?_Mynode@const_iterator@?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@QBEPAU_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@3@XZ ENDP ; std::list<CUser *,std::allocator<CUser *> >::const_iterator::_Mynode
_TEXT	ENDS
PUBLIC	??0?$allocator@U__ITEMINFO@@@std@@QAE@ABV01@@Z	; std::allocator<__ITEMINFO>::allocator<__ITEMINFO>
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??0?$allocator@U__ITEMINFO@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@U__ITEMINFO@@@std@@QAE@ABV01@@Z PROC NEAR ; std::allocator<__ITEMINFO>::allocator<__ITEMINFO>, COMDAT
; _this$ = ecx

; 115  : 	allocator(const allocator<_Ty>&)

  00000	8b c1		 mov	 eax, ecx

; 116  : 		{	// construct by copying (do nothing)
; 117  : 		}

  00002	c2 04 00	 ret	 4
??0?$allocator@U__ITEMINFO@@@std@@QAE@ABV01@@Z ENDP	; std::allocator<__ITEMINFO>::allocator<__ITEMINFO>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@U__ITEMINFO@@@std@@QAEXPAU__ITEMINFO@@I@Z ; std::allocator<__ITEMINFO>::deallocate
; Function compile flags: /Ogty
;	COMDAT ?deallocate@?$allocator@U__ITEMINFO@@@std@@QAEXPAU__ITEMINFO@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@U__ITEMINFO@@@std@@QAEXPAU__ITEMINFO@@I@Z PROC NEAR ; std::allocator<__ITEMINFO>::deallocate, COMDAT
; _this$ = ecx

; 132  : 		operator delete(_Ptr);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Ptr$[esp-4]
  00004	50		 push	 eax
  00005	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000a	59		 pop	 ecx

; 133  : 		}

  0000b	c2 08 00	 ret	 8
?deallocate@?$allocator@U__ITEMINFO@@@std@@QAEXPAU__ITEMINFO@@I@Z ENDP ; std::allocator<__ITEMINFO>::deallocate
_TEXT	ENDS
PUBLIC	??Yiterator@?$vector@KV?$allocator@K@std@@@std@@QAEAAV012@H@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::iterator::operator+=
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ??Yiterator@?$vector@KV?$allocator@K@std@@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Yiterator@?$vector@KV?$allocator@K@std@@@std@@QAEAAV012@H@Z PROC NEAR ; std::vector<unsigned long,std::allocator<unsigned long> >::iterator::operator+=, COMDAT
; _this$ = ecx

; 255  : 			{	// increment by integer

  00000	8b c1		 mov	 eax, ecx

; 256  : 			this->_Myptr += _Off;

  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Off$[esp-4]
  00006	8d 14 8d 00 00
	00 00		 lea	 edx, DWORD PTR [ecx*4]
  0000d	01 10		 add	 DWORD PTR [eax], edx

; 257  : 			return (*this);
; 258  : 			}

  0000f	c2 04 00	 ret	 4
??Yiterator@?$vector@KV?$allocator@K@std@@@std@@QAEAAV012@H@Z ENDP ; std::vector<unsigned long,std::allocator<unsigned long> >::iterator::operator+=
_TEXT	ENDS
PUBLIC	??Dconst_iterator@?$vector@KV?$allocator@K@std@@@std@@QBEABKXZ ; std::vector<unsigned long,std::allocator<unsigned long> >::const_iterator::operator*
; Function compile flags: /Ogty
;	COMDAT ??Dconst_iterator@?$vector@KV?$allocator@K@std@@@std@@QBEABKXZ
_TEXT	SEGMENT
??Dconst_iterator@?$vector@KV?$allocator@K@std@@@std@@QBEABKXZ PROC NEAR ; std::vector<unsigned long,std::allocator<unsigned long> >::const_iterator::operator*, COMDAT
; _this$ = ecx

; 80   : 
; 81   : 
; 82   : 			return (*_Myptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 83   : 			}

  00002	c3		 ret	 0
??Dconst_iterator@?$vector@KV?$allocator@K@std@@@std@@QBEABKXZ ENDP ; std::vector<unsigned long,std::allocator<unsigned long> >::const_iterator::operator*
_TEXT	ENDS
PUBLIC	??Yiterator@?$vector@HV?$allocator@H@std@@@std@@QAEAAV012@H@Z ; std::vector<int,std::allocator<int> >::iterator::operator+=
; Function compile flags: /Ogty
;	COMDAT ??Yiterator@?$vector@HV?$allocator@H@std@@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Yiterator@?$vector@HV?$allocator@H@std@@@std@@QAEAAV012@H@Z PROC NEAR ; std::vector<int,std::allocator<int> >::iterator::operator+=, COMDAT
; _this$ = ecx

; 255  : 			{	// increment by integer

  00000	8b c1		 mov	 eax, ecx

; 256  : 			this->_Myptr += _Off;

  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Off$[esp-4]
  00006	8d 14 8d 00 00
	00 00		 lea	 edx, DWORD PTR [ecx*4]
  0000d	01 10		 add	 DWORD PTR [eax], edx

; 257  : 			return (*this);
; 258  : 			}

  0000f	c2 04 00	 ret	 4
??Yiterator@?$vector@HV?$allocator@H@std@@@std@@QAEAAV012@H@Z ENDP ; std::vector<int,std::allocator<int> >::iterator::operator+=
_TEXT	ENDS
PUBLIC	??Dconst_iterator@?$vector@HV?$allocator@H@std@@@std@@QBEABHXZ ; std::vector<int,std::allocator<int> >::const_iterator::operator*
; Function compile flags: /Ogty
;	COMDAT ??Dconst_iterator@?$vector@HV?$allocator@H@std@@@std@@QBEABHXZ
_TEXT	SEGMENT
??Dconst_iterator@?$vector@HV?$allocator@H@std@@@std@@QBEABHXZ PROC NEAR ; std::vector<int,std::allocator<int> >::const_iterator::operator*, COMDAT
; _this$ = ecx

; 80   : 
; 81   : 
; 82   : 			return (*_Myptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 83   : 			}

  00002	c3		 ret	 0
??Dconst_iterator@?$vector@HV?$allocator@H@std@@@std@@QBEABHXZ ENDP ; std::vector<int,std::allocator<int> >::const_iterator::operator*
_TEXT	ENDS
PUBLIC	??Yiterator@?$vector@EV?$allocator@E@std@@@std@@QAEAAV012@H@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::iterator::operator+=
; Function compile flags: /Ogty
;	COMDAT ??Yiterator@?$vector@EV?$allocator@E@std@@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Yiterator@?$vector@EV?$allocator@E@std@@@std@@QAEAAV012@H@Z PROC NEAR ; std::vector<unsigned char,std::allocator<unsigned char> >::iterator::operator+=, COMDAT
; _this$ = ecx

; 255  : 			{	// increment by integer

  00000	8b c1		 mov	 eax, ecx

; 256  : 			this->_Myptr += _Off;

  00002	8b 10		 mov	 edx, DWORD PTR [eax]
  00004	8b 4c 24 04	 mov	 ecx, DWORD PTR __Off$[esp-4]
  00008	03 d1		 add	 edx, ecx
  0000a	89 10		 mov	 DWORD PTR [eax], edx

; 257  : 			return (*this);
; 258  : 			}

  0000c	c2 04 00	 ret	 4
??Yiterator@?$vector@EV?$allocator@E@std@@@std@@QAEAAV012@H@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::iterator::operator+=
_TEXT	ENDS
PUBLIC	??Yiterator@?$vector@VCGuildCombat1to1@@V?$allocator@VCGuildCombat1to1@@@std@@@std@@QAEAAV012@H@Z ; std::vector<CGuildCombat1to1,std::allocator<CGuildCombat1to1> >::iterator::operator+=
; Function compile flags: /Ogty
;	COMDAT ??Yiterator@?$vector@VCGuildCombat1to1@@V?$allocator@VCGuildCombat1to1@@@std@@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Yiterator@?$vector@VCGuildCombat1to1@@V?$allocator@VCGuildCombat1to1@@@std@@@std@@QAEAAV012@H@Z PROC NEAR ; std::vector<CGuildCombat1to1,std::allocator<CGuildCombat1to1> >::iterator::operator+=, COMDAT
; _this$ = ecx

; 255  : 			{	// increment by integer

  00000	8b c1		 mov	 eax, ecx

; 256  : 			this->_Myptr += _Off;

  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Off$[esp-4]
  00006	8b 10		 mov	 edx, DWORD PTR [eax]
  00008	8d 0c 49	 lea	 ecx, DWORD PTR [ecx+ecx*2]
  0000b	c1 e1 04	 shl	 ecx, 4
  0000e	03 d1		 add	 edx, ecx
  00010	89 10		 mov	 DWORD PTR [eax], edx

; 257  : 			return (*this);
; 258  : 			}

  00012	c2 04 00	 ret	 4
??Yiterator@?$vector@VCGuildCombat1to1@@V?$allocator@VCGuildCombat1to1@@@std@@@std@@QAEAAV012@H@Z ENDP ; std::vector<CGuildCombat1to1,std::allocator<CGuildCombat1to1> >::iterator::operator+=
_TEXT	ENDS
PUBLIC	??Dconst_iterator@?$vector@VCGuildCombat1to1@@V?$allocator@VCGuildCombat1to1@@@std@@@std@@QBEABVCGuildCombat1to1@@XZ ; std::vector<CGuildCombat1to1,std::allocator<CGuildCombat1to1> >::const_iterator::operator*
; Function compile flags: /Ogty
;	COMDAT ??Dconst_iterator@?$vector@VCGuildCombat1to1@@V?$allocator@VCGuildCombat1to1@@@std@@@std@@QBEABVCGuildCombat1to1@@XZ
_TEXT	SEGMENT
??Dconst_iterator@?$vector@VCGuildCombat1to1@@V?$allocator@VCGuildCombat1to1@@@std@@@std@@QBEABVCGuildCombat1to1@@XZ PROC NEAR ; std::vector<CGuildCombat1to1,std::allocator<CGuildCombat1to1> >::const_iterator::operator*, COMDAT
; _this$ = ecx

; 80   : 
; 81   : 
; 82   : 			return (*_Myptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 83   : 			}

  00002	c3		 ret	 0
??Dconst_iterator@?$vector@VCGuildCombat1to1@@V?$allocator@VCGuildCombat1to1@@@std@@@std@@QBEABVCGuildCombat1to1@@XZ ENDP ; std::vector<CGuildCombat1to1,std::allocator<CGuildCombat1to1> >::const_iterator::operator*
_TEXT	ENDS
PUBLIC	??Yiterator@?$vector@U__GC1TO1TENDER@CGuildCombat1to1Mng@@V?$allocator@U__GC1TO1TENDER@CGuildCombat1to1Mng@@@std@@@std@@QAEAAV012@H@Z ; std::vector<CGuildCombat1to1Mng::__GC1TO1TENDER,std::allocator<CGuildCombat1to1Mng::__GC1TO1TENDER> >::iterator::operator+=
; Function compile flags: /Ogty
;	COMDAT ??Yiterator@?$vector@U__GC1TO1TENDER@CGuildCombat1to1Mng@@V?$allocator@U__GC1TO1TENDER@CGuildCombat1to1Mng@@@std@@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Yiterator@?$vector@U__GC1TO1TENDER@CGuildCombat1to1Mng@@V?$allocator@U__GC1TO1TENDER@CGuildCombat1to1Mng@@@std@@@std@@QAEAAV012@H@Z PROC NEAR ; std::vector<CGuildCombat1to1Mng::__GC1TO1TENDER,std::allocator<CGuildCombat1to1Mng::__GC1TO1TENDER> >::iterator::operator+=, COMDAT
; _this$ = ecx

; 255  : 			{	// increment by integer

  00000	8b c1		 mov	 eax, ecx

; 256  : 			this->_Myptr += _Off;

  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Off$[esp-4]
  00006	8b 10		 mov	 edx, DWORD PTR [eax]
  00008	8d 0c 49	 lea	 ecx, DWORD PTR [ecx+ecx*2]
  0000b	c1 e1 04	 shl	 ecx, 4
  0000e	03 d1		 add	 edx, ecx
  00010	89 10		 mov	 DWORD PTR [eax], edx

; 257  : 			return (*this);
; 258  : 			}

  00012	c2 04 00	 ret	 4
??Yiterator@?$vector@U__GC1TO1TENDER@CGuildCombat1to1Mng@@V?$allocator@U__GC1TO1TENDER@CGuildCombat1to1Mng@@@std@@@std@@QAEAAV012@H@Z ENDP ; std::vector<CGuildCombat1to1Mng::__GC1TO1TENDER,std::allocator<CGuildCombat1to1Mng::__GC1TO1TENDER> >::iterator::operator+=
_TEXT	ENDS
PUBLIC	??Dconst_iterator@?$vector@U__GC1TO1TENDER@CGuildCombat1to1Mng@@V?$allocator@U__GC1TO1TENDER@CGuildCombat1to1Mng@@@std@@@std@@QBEABU__GC1TO1TENDER@CGuildCombat1to1Mng@@XZ ; std::vector<CGuildCombat1to1Mng::__GC1TO1TENDER,std::allocator<CGuildCombat1to1Mng::__GC1TO1TENDER> >::const_iterator::operator*
; Function compile flags: /Ogty
;	COMDAT ??Dconst_iterator@?$vector@U__GC1TO1TENDER@CGuildCombat1to1Mng@@V?$allocator@U__GC1TO1TENDER@CGuildCombat1to1Mng@@@std@@@std@@QBEABU__GC1TO1TENDER@CGuildCombat1to1Mng@@XZ
_TEXT	SEGMENT
??Dconst_iterator@?$vector@U__GC1TO1TENDER@CGuildCombat1to1Mng@@V?$allocator@U__GC1TO1TENDER@CGuildCombat1to1Mng@@@std@@@std@@QBEABU__GC1TO1TENDER@CGuildCombat1to1Mng@@XZ PROC NEAR ; std::vector<CGuildCombat1to1Mng::__GC1TO1TENDER,std::allocator<CGuildCombat1to1Mng::__GC1TO1TENDER> >::const_iterator::operator*, COMDAT
; _this$ = ecx

; 80   : 
; 81   : 
; 82   : 			return (*_Myptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 83   : 			}

  00002	c3		 ret	 0
??Dconst_iterator@?$vector@U__GC1TO1TENDER@CGuildCombat1to1Mng@@V?$allocator@U__GC1TO1TENDER@CGuildCombat1to1Mng@@@std@@@std@@QBEABU__GC1TO1TENDER@CGuildCombat1to1Mng@@XZ ENDP ; std::vector<CGuildCombat1to1Mng::__GC1TO1TENDER,std::allocator<CGuildCombat1to1Mng::__GC1TO1TENDER> >::const_iterator::operator*
_TEXT	ENDS
PUBLIC	??Yiterator@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAEAAV012@H@Z ; std::vector<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::iterator::operator+=
; Function compile flags: /Ogty
;	COMDAT ??Yiterator@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Yiterator@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAEAAV012@H@Z PROC NEAR ; std::vector<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::iterator::operator+=, COMDAT
; _this$ = ecx

; 255  : 			{	// increment by integer

  00000	8b c1		 mov	 eax, ecx

; 256  : 			this->_Myptr += _Off;

  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Off$[esp-4]
  00006	8d 14 8d 00 00
	00 00		 lea	 edx, DWORD PTR [ecx*4]
  0000d	01 10		 add	 DWORD PTR [eax], edx

; 257  : 			return (*this);
; 258  : 			}

  0000f	c2 04 00	 ret	 4
??Yiterator@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAEAAV012@H@Z ENDP ; std::vector<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::iterator::operator+=
_TEXT	ENDS
PUBLIC	??Dconst_iterator@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEABQAU__JOINPLAYER@CGuildCombat@@XZ ; std::vector<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::const_iterator::operator*
; Function compile flags: /Ogty
;	COMDAT ??Dconst_iterator@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEABQAU__JOINPLAYER@CGuildCombat@@XZ
_TEXT	SEGMENT
??Dconst_iterator@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEABQAU__JOINPLAYER@CGuildCombat@@XZ PROC NEAR ; std::vector<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::const_iterator::operator*, COMDAT
; _this$ = ecx

; 80   : 
; 81   : 
; 82   : 			return (*_Myptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 83   : 			}

  00002	c3		 ret	 0
??Dconst_iterator@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEABQAU__JOINPLAYER@CGuildCombat@@XZ ENDP ; std::vector<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::const_iterator::operator*
_TEXT	ENDS
PUBLIC	??Yiterator@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@QAEAAV012@H@Z ; std::vector<CGuildCombat::__GCGETPOINT,std::allocator<CGuildCombat::__GCGETPOINT> >::iterator::operator+=
; Function compile flags: /Ogty
;	COMDAT ??Yiterator@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Yiterator@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@QAEAAV012@H@Z PROC NEAR ; std::vector<CGuildCombat::__GCGETPOINT,std::allocator<CGuildCombat::__GCGETPOINT> >::iterator::operator+=, COMDAT
; _this$ = ecx

; 255  : 			{	// increment by integer

  00000	8b c1		 mov	 eax, ecx

; 256  : 			this->_Myptr += _Off;

  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Off$[esp-4]
  00006	8b 10		 mov	 edx, DWORD PTR [eax]
  00008	8d 0c c9	 lea	 ecx, DWORD PTR [ecx+ecx*8]
  0000b	c1 e1 02	 shl	 ecx, 2
  0000e	03 d1		 add	 edx, ecx
  00010	89 10		 mov	 DWORD PTR [eax], edx

; 257  : 			return (*this);
; 258  : 			}

  00012	c2 04 00	 ret	 4
??Yiterator@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@QAEAAV012@H@Z ENDP ; std::vector<CGuildCombat::__GCGETPOINT,std::allocator<CGuildCombat::__GCGETPOINT> >::iterator::operator+=
_TEXT	ENDS
PUBLIC	??Dconst_iterator@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@QBEABU__GCGETPOINT@CGuildCombat@@XZ ; std::vector<CGuildCombat::__GCGETPOINT,std::allocator<CGuildCombat::__GCGETPOINT> >::const_iterator::operator*
; Function compile flags: /Ogty
;	COMDAT ??Dconst_iterator@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@QBEABU__GCGETPOINT@CGuildCombat@@XZ
_TEXT	SEGMENT
??Dconst_iterator@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@QBEABU__GCGETPOINT@CGuildCombat@@XZ PROC NEAR ; std::vector<CGuildCombat::__GCGETPOINT,std::allocator<CGuildCombat::__GCGETPOINT> >::const_iterator::operator*, COMDAT
; _this$ = ecx

; 80   : 
; 81   : 
; 82   : 			return (*_Myptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 83   : 			}

  00002	c3		 ret	 0
??Dconst_iterator@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@QBEABU__GCGETPOINT@CGuildCombat@@XZ ENDP ; std::vector<CGuildCombat::__GCGETPOINT,std::allocator<CGuildCombat::__GCGETPOINT> >::const_iterator::operator*
_TEXT	ENDS
PUBLIC	??Yiterator@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@QAEAAV012@H@Z ; std::vector<CGuildCombat::__GCPLAYERPOINT,std::allocator<CGuildCombat::__GCPLAYERPOINT> >::iterator::operator+=
; Function compile flags: /Ogty
;	COMDAT ??Yiterator@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Yiterator@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@QAEAAV012@H@Z PROC NEAR ; std::vector<CGuildCombat::__GCPLAYERPOINT,std::allocator<CGuildCombat::__GCPLAYERPOINT> >::iterator::operator+=, COMDAT
; _this$ = ecx

; 255  : 			{	// increment by integer

  00000	8b c1		 mov	 eax, ecx

; 256  : 			this->_Myptr += _Off;

  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Off$[esp-4]
  00006	8b 10		 mov	 edx, DWORD PTR [eax]
  00008	8d 0c 49	 lea	 ecx, DWORD PTR [ecx+ecx*2]
  0000b	c1 e1 02	 shl	 ecx, 2
  0000e	03 d1		 add	 edx, ecx
  00010	89 10		 mov	 DWORD PTR [eax], edx

; 257  : 			return (*this);
; 258  : 			}

  00012	c2 04 00	 ret	 4
??Yiterator@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@QAEAAV012@H@Z ENDP ; std::vector<CGuildCombat::__GCPLAYERPOINT,std::allocator<CGuildCombat::__GCPLAYERPOINT> >::iterator::operator+=
_TEXT	ENDS
PUBLIC	??Dconst_iterator@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@QBEABU__GCPLAYERPOINT@CGuildCombat@@XZ ; std::vector<CGuildCombat::__GCPLAYERPOINT,std::allocator<CGuildCombat::__GCPLAYERPOINT> >::const_iterator::operator*
; Function compile flags: /Ogty
;	COMDAT ??Dconst_iterator@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@QBEABU__GCPLAYERPOINT@CGuildCombat@@XZ
_TEXT	SEGMENT
??Dconst_iterator@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@QBEABU__GCPLAYERPOINT@CGuildCombat@@XZ PROC NEAR ; std::vector<CGuildCombat::__GCPLAYERPOINT,std::allocator<CGuildCombat::__GCPLAYERPOINT> >::const_iterator::operator*, COMDAT
; _this$ = ecx

; 80   : 
; 81   : 
; 82   : 			return (*_Myptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 83   : 			}

  00002	c3		 ret	 0
??Dconst_iterator@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@QBEABU__GCPLAYERPOINT@CGuildCombat@@XZ ENDP ; std::vector<CGuildCombat::__GCPLAYERPOINT,std::allocator<CGuildCombat::__GCPLAYERPOINT> >::const_iterator::operator*
_TEXT	ENDS
PUBLIC	??Yiterator@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QAEAAV012@H@Z ; std::vector<CGuildCombat::__GuildCombatMember *,std::allocator<CGuildCombat::__GuildCombatMember *> >::iterator::operator+=
; Function compile flags: /Ogty
;	COMDAT ??Yiterator@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Yiterator@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QAEAAV012@H@Z PROC NEAR ; std::vector<CGuildCombat::__GuildCombatMember *,std::allocator<CGuildCombat::__GuildCombatMember *> >::iterator::operator+=, COMDAT
; _this$ = ecx

; 255  : 			{	// increment by integer

  00000	8b c1		 mov	 eax, ecx

; 256  : 			this->_Myptr += _Off;

  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Off$[esp-4]
  00006	8d 14 8d 00 00
	00 00		 lea	 edx, DWORD PTR [ecx*4]
  0000d	01 10		 add	 DWORD PTR [eax], edx

; 257  : 			return (*this);
; 258  : 			}

  0000f	c2 04 00	 ret	 4
??Yiterator@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QAEAAV012@H@Z ENDP ; std::vector<CGuildCombat::__GuildCombatMember *,std::allocator<CGuildCombat::__GuildCombatMember *> >::iterator::operator+=
_TEXT	ENDS
PUBLIC	??Dconst_iterator@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QBEABQAU__GuildCombatMember@CGuildCombat@@XZ ; std::vector<CGuildCombat::__GuildCombatMember *,std::allocator<CGuildCombat::__GuildCombatMember *> >::const_iterator::operator*
; Function compile flags: /Ogty
;	COMDAT ??Dconst_iterator@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QBEABQAU__GuildCombatMember@CGuildCombat@@XZ
_TEXT	SEGMENT
??Dconst_iterator@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QBEABQAU__GuildCombatMember@CGuildCombat@@XZ PROC NEAR ; std::vector<CGuildCombat::__GuildCombatMember *,std::allocator<CGuildCombat::__GuildCombatMember *> >::const_iterator::operator*, COMDAT
; _this$ = ecx

; 80   : 
; 81   : 
; 82   : 			return (*_Myptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 83   : 			}

  00002	c3		 ret	 0
??Dconst_iterator@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QBEABQAU__GuildCombatMember@CGuildCombat@@XZ ENDP ; std::vector<CGuildCombat::__GuildCombatMember *,std::allocator<CGuildCombat::__GuildCombatMember *> >::const_iterator::operator*
_TEXT	ENDS
PUBLIC	??Yiterator@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QAEAAV012@H@Z ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::iterator::operator+=
; Function compile flags: /Ogty
;	COMDAT ??Yiterator@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Yiterator@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QAEAAV012@H@Z PROC NEAR ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::iterator::operator+=, COMDAT
; _this$ = ecx

; 255  : 			{	// increment by integer

  00000	8b c1		 mov	 eax, ecx

; 256  : 			this->_Myptr += _Off;

  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Off$[esp-4]
  00006	8d 14 cd 00 00
	00 00		 lea	 edx, DWORD PTR [ecx*8]
  0000d	01 10		 add	 DWORD PTR [eax], edx

; 257  : 			return (*this);
; 258  : 			}

  0000f	c2 04 00	 ret	 4
??Yiterator@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QAEAAV012@H@Z ENDP ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::iterator::operator+=
_TEXT	ENDS
PUBLIC	??Dconst_iterator@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QBEABU__REQUESTGUILD@CGuildCombat@@XZ ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::const_iterator::operator*
; Function compile flags: /Ogty
;	COMDAT ??Dconst_iterator@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QBEABU__REQUESTGUILD@CGuildCombat@@XZ
_TEXT	SEGMENT
??Dconst_iterator@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QBEABU__REQUESTGUILD@CGuildCombat@@XZ PROC NEAR ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::const_iterator::operator*, COMDAT
; _this$ = ecx

; 80   : 
; 81   : 
; 82   : 			return (*_Myptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 83   : 			}

  00002	c3		 ret	 0
??Dconst_iterator@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QBEABU__REQUESTGUILD@CGuildCombat@@XZ ENDP ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::const_iterator::operator*
_TEXT	ENDS
PUBLIC	??Yiterator@?$vector@U__SECRETROOM_TENDER@@V?$allocator@U__SECRETROOM_TENDER@@@std@@@std@@QAEAAV012@H@Z ; std::vector<__SECRETROOM_TENDER,std::allocator<__SECRETROOM_TENDER> >::iterator::operator+=
; Function compile flags: /Ogty
;	COMDAT ??Yiterator@?$vector@U__SECRETROOM_TENDER@@V?$allocator@U__SECRETROOM_TENDER@@@std@@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Yiterator@?$vector@U__SECRETROOM_TENDER@@V?$allocator@U__SECRETROOM_TENDER@@@std@@@std@@QAEAAV012@H@Z PROC NEAR ; std::vector<__SECRETROOM_TENDER,std::allocator<__SECRETROOM_TENDER> >::iterator::operator+=, COMDAT
; _this$ = ecx

; 255  : 			{	// increment by integer

  00000	8b c1		 mov	 eax, ecx

; 256  : 			this->_Myptr += _Off;

  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Off$[esp-4]
  00006	8b 10		 mov	 edx, DWORD PTR [eax]
  00008	6b c9 34	 imul	 ecx, 52			; 00000034H
  0000b	03 d1		 add	 edx, ecx
  0000d	89 10		 mov	 DWORD PTR [eax], edx

; 257  : 			return (*this);
; 258  : 			}

  0000f	c2 04 00	 ret	 4
??Yiterator@?$vector@U__SECRETROOM_TENDER@@V?$allocator@U__SECRETROOM_TENDER@@@std@@@std@@QAEAAV012@H@Z ENDP ; std::vector<__SECRETROOM_TENDER,std::allocator<__SECRETROOM_TENDER> >::iterator::operator+=
_TEXT	ENDS
PUBLIC	??Dconst_iterator@?$vector@U__SECRETROOM_TENDER@@V?$allocator@U__SECRETROOM_TENDER@@@std@@@std@@QBEABU__SECRETROOM_TENDER@@XZ ; std::vector<__SECRETROOM_TENDER,std::allocator<__SECRETROOM_TENDER> >::const_iterator::operator*
; Function compile flags: /Ogty
;	COMDAT ??Dconst_iterator@?$vector@U__SECRETROOM_TENDER@@V?$allocator@U__SECRETROOM_TENDER@@@std@@@std@@QBEABU__SECRETROOM_TENDER@@XZ
_TEXT	SEGMENT
??Dconst_iterator@?$vector@U__SECRETROOM_TENDER@@V?$allocator@U__SECRETROOM_TENDER@@@std@@@std@@QBEABU__SECRETROOM_TENDER@@XZ PROC NEAR ; std::vector<__SECRETROOM_TENDER,std::allocator<__SECRETROOM_TENDER> >::const_iterator::operator*, COMDAT
; _this$ = ecx

; 80   : 
; 81   : 
; 82   : 			return (*_Myptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 83   : 			}

  00002	c3		 ret	 0
??Dconst_iterator@?$vector@U__SECRETROOM_TENDER@@V?$allocator@U__SECRETROOM_TENDER@@@std@@@std@@QBEABU__SECRETROOM_TENDER@@XZ ENDP ; std::vector<__SECRETROOM_TENDER,std::allocator<__SECRETROOM_TENDER> >::const_iterator::operator*
_TEXT	ENDS
PUBLIC	??Yiterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV012@H@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::iterator::operator+=
; Function compile flags: /Ogty
;	COMDAT ??Yiterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Yiterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV012@H@Z PROC NEAR ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::iterator::operator+=, COMDAT
; _this$ = ecx

; 255  : 			{	// increment by integer

  00000	8b c1		 mov	 eax, ecx

; 256  : 			this->_Myptr += _Off;

  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Off$[esp-4]
  00006	8b 10		 mov	 edx, DWORD PTR [eax]
  00008	6b c9 1c	 imul	 ecx, 28			; 0000001cH
  0000b	03 d1		 add	 edx, ecx
  0000d	89 10		 mov	 DWORD PTR [eax], edx

; 257  : 			return (*this);
; 258  : 			}

  0000f	c2 04 00	 ret	 4
??Yiterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV012@H@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::iterator::operator+=
_TEXT	ENDS
PUBLIC	??Dconst_iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::const_iterator::operator*
; Function compile flags: /Ogty
;	COMDAT ??Dconst_iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
??Dconst_iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC NEAR ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::const_iterator::operator*, COMDAT
; _this$ = ecx

; 80   : 
; 81   : 
; 82   : 			return (*_Myptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 83   : 			}

  00002	c3		 ret	 0
??Dconst_iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::const_iterator::operator*
_TEXT	ENDS
PUBLIC	?SetMethod@CObj@@SAXH@Z				; CObj::SetMethod
EXTRN	?m_nMethod@CObj@@2HA:DWORD			; CObj::m_nMethod
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\obj.h
;	COMDAT ?SetMethod@CObj@@SAXH@Z
_TEXT	SEGMENT
_nMethod$ = 8						; size = 4
?SetMethod@CObj@@SAXH@Z PROC NEAR			; CObj::SetMethod, COMDAT

; 160  : 	static void		SetMethod( int nMethod )		{ m_nMethod	= nMethod;	}

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _nMethod$[esp-4]
  00004	a3 00 00 00 00	 mov	 DWORD PTR ?m_nMethod@CObj@@2HA, eax ; CObj::m_nMethod
  00009	c3		 ret	 0
?SetMethod@CObj@@SAXH@Z ENDP				; CObj::SetMethod
_TEXT	ENDS
PUBLIC	??Yiterator@?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@QAEAAV012@H@Z ; std::vector<CGuildCombat::__JOINPLAYER,std::allocator<CGuildCombat::__JOINPLAYER> >::iterator::operator+=
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ??Yiterator@?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Yiterator@?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@QAEAAV012@H@Z PROC NEAR ; std::vector<CGuildCombat::__JOINPLAYER,std::allocator<CGuildCombat::__JOINPLAYER> >::iterator::operator+=, COMDAT
; _this$ = ecx

; 255  : 			{	// increment by integer

  00000	8b c1		 mov	 eax, ecx

; 256  : 			this->_Myptr += _Off;

  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Off$[esp-4]
  00006	8b 10		 mov	 edx, DWORD PTR [eax]
  00008	8d 0c 49	 lea	 ecx, DWORD PTR [ecx+ecx*2]
  0000b	c1 e1 03	 shl	 ecx, 3
  0000e	03 d1		 add	 edx, ecx
  00010	89 10		 mov	 DWORD PTR [eax], edx

; 257  : 			return (*this);
; 258  : 			}

  00012	c2 04 00	 ret	 4
??Yiterator@?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@QAEAAV012@H@Z ENDP ; std::vector<CGuildCombat::__JOINPLAYER,std::allocator<CGuildCombat::__JOINPLAYER> >::iterator::operator+=
_TEXT	ENDS
PUBLIC	?IsDelete@CObj@@QAEHXZ				; CObj::IsDelete
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\obj.h
;	COMDAT ?IsDelete@CObj@@QAEHXZ
_TEXT	SEGMENT
?IsDelete@CObj@@QAEHXZ PROC NEAR			; CObj::IsDelete, COMDAT
; _this$ = ecx

; 180  : 	BOOL			IsDelete()	{ return (m_dwFlags & OBJ_FLAG_DELETE);  }

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	83 e0 01	 and	 eax, 1
  00006	c3		 ret	 0
?IsDelete@CObj@@QAEHXZ ENDP				; CObj::IsDelete
_TEXT	ENDS
PUBLIC	??Dconst_iterator@?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEABU__JOINPLAYER@CGuildCombat@@XZ ; std::vector<CGuildCombat::__JOINPLAYER,std::allocator<CGuildCombat::__JOINPLAYER> >::const_iterator::operator*
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ??Dconst_iterator@?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEABU__JOINPLAYER@CGuildCombat@@XZ
_TEXT	SEGMENT
??Dconst_iterator@?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEABU__JOINPLAYER@CGuildCombat@@XZ PROC NEAR ; std::vector<CGuildCombat::__JOINPLAYER,std::allocator<CGuildCombat::__JOINPLAYER> >::const_iterator::operator*, COMDAT
; _this$ = ecx

; 80   : 
; 81   : 
; 82   : 			return (*_Myptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 83   : 			}

  00002	c3		 ret	 0
??Dconst_iterator@?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEABU__JOINPLAYER@CGuildCombat@@XZ ENDP ; std::vector<CGuildCombat::__JOINPLAYER,std::allocator<CGuildCombat::__JOINPLAYER> >::const_iterator::operator*
_TEXT	ENDS
PUBLIC	??Yiterator@?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@QAEAAV012@H@Z ; std::vector<__ITEMINFO,std::allocator<__ITEMINFO> >::iterator::operator+=
; Function compile flags: /Ogty
;	COMDAT ??Yiterator@?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Yiterator@?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@QAEAAV012@H@Z PROC NEAR ; std::vector<__ITEMINFO,std::allocator<__ITEMINFO> >::iterator::operator+=, COMDAT
; _this$ = ecx

; 255  : 			{	// increment by integer

  00000	8b c1		 mov	 eax, ecx

; 256  : 			this->_Myptr += _Off;

  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Off$[esp-4]
  00006	8b 10		 mov	 edx, DWORD PTR [eax]
  00008	8d 0c 49	 lea	 ecx, DWORD PTR [ecx+ecx*2]
  0000b	c1 e1 02	 shl	 ecx, 2
  0000e	03 d1		 add	 edx, ecx
  00010	89 10		 mov	 DWORD PTR [eax], edx

; 257  : 			return (*this);
; 258  : 			}

  00012	c2 04 00	 ret	 4
??Yiterator@?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@QAEAAV012@H@Z ENDP ; std::vector<__ITEMINFO,std::allocator<__ITEMINFO> >::iterator::operator+=
_TEXT	ENDS
PUBLIC	??Dconst_iterator@?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@QBEABU__ITEMINFO@@XZ ; std::vector<__ITEMINFO,std::allocator<__ITEMINFO> >::const_iterator::operator*
; Function compile flags: /Ogty
;	COMDAT ??Dconst_iterator@?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@QBEABU__ITEMINFO@@XZ
_TEXT	SEGMENT
??Dconst_iterator@?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@QBEABU__ITEMINFO@@XZ PROC NEAR ; std::vector<__ITEMINFO,std::allocator<__ITEMINFO> >::const_iterator::operator*, COMDAT
; _this$ = ecx

; 80   : 
; 81   : 
; 82   : 			return (*_Myptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 83   : 			}

  00002	c3		 ret	 0
??Dconst_iterator@?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@QBEABU__ITEMINFO@@XZ ENDP ; std::vector<__ITEMINFO,std::allocator<__ITEMINFO> >::const_iterator::operator*
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QBEIXZ ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::max_size
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ?max_size@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QBEIXZ PROC NEAR ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::max_size, COMDAT
; _this$ = ecx

; 157  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 158  : 		return (0 < _Count ? _Count : 1);

  00000	b8 49 92 24 09	 mov	 eax, 153391689		; 09249249H

; 159  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QBEIXZ ENDP ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::max_size
_TEXT	ENDS
PUBLIC	?GetType@CObj@@QAEKXZ				; CObj::GetType
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\obj.h
;	COMDAT ?GetType@CObj@@QAEKXZ
_TEXT	SEGMENT
?GetType@CObj@@QAEKXZ PROC NEAR				; CObj::GetType, COMDAT
; _this$ = ecx

; 206  : 	DWORD			GetType() { return m_dwType; }

  00000	8b 81 70 01 00
	00		 mov	 eax, DWORD PTR [ecx+368]
  00006	c3		 ret	 0
?GetType@CObj@@QAEKXZ ENDP				; CObj::GetType
_TEXT	ENDS
PUBLIC	?GetIndex@CObj@@QAEKXZ				; CObj::GetIndex
; Function compile flags: /Ogty
;	COMDAT ?GetIndex@CObj@@QAEKXZ
_TEXT	SEGMENT
?GetIndex@CObj@@QAEKXZ PROC NEAR			; CObj::GetIndex, COMDAT
; _this$ = ecx

; 207  : 	DWORD			GetIndex() { return m_dwIndex; }

  00000	8b 81 74 01 00
	00		 mov	 eax, DWORD PTR [ecx+372]
  00006	c3		 ret	 0
?GetIndex@CObj@@QAEKXZ ENDP				; CObj::GetIndex
_TEXT	ENDS
PUBLIC	?GetPos@CObj@@QAE?AUD3DXVECTOR3@@XZ		; CObj::GetPos
; Function compile flags: /Ogty
;	COMDAT ?GetPos@CObj@@QAE?AUD3DXVECTOR3@@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?GetPos@CObj@@QAE?AUD3DXVECTOR3@@XZ PROC NEAR		; CObj::GetPos, COMDAT
; _this$ = ecx

; 215  : 	D3DXVECTOR3		GetPos()	{ return m_vPos; }

  00000	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  00004	81 c1 60 01 00
	00		 add	 ecx, 352		; 00000160H
  0000a	56		 push	 esi
  0000b	8b 31		 mov	 esi, DWORD PTR [ecx]
  0000d	8b d0		 mov	 edx, eax
  0000f	89 32		 mov	 DWORD PTR [edx], esi
  00011	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  00014	89 72 04	 mov	 DWORD PTR [edx+4], esi
  00017	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  0001a	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  0001d	5e		 pop	 esi
  0001e	c2 04 00	 ret	 4
?GetPos@CObj@@QAE?AUD3DXVECTOR3@@XZ ENDP		; CObj::GetPos
_TEXT	ENDS
PUBLIC	?GetAngle@CObj@@QAEMXZ				; CObj::GetAngle
; Function compile flags: /Ogty
;	COMDAT ?GetAngle@CObj@@QAEMXZ
_TEXT	SEGMENT
?GetAngle@CObj@@QAEMXZ PROC NEAR			; CObj::GetAngle, COMDAT
; _this$ = ecx

; 217  : 	FLOAT			GetAngle()	{ return m_fAngle; }

  00000	d9 41 18	 fld	 DWORD PTR [ecx+24]
  00003	c3		 ret	 0
?GetAngle@CObj@@QAEMXZ ENDP				; CObj::GetAngle
_TEXT	ENDS
PUBLIC	?GetWorld@CObj@@QAEPAVCWorld@@XZ		; CObj::GetWorld
; Function compile flags: /Ogty
;	COMDAT ?GetWorld@CObj@@QAEPAVCWorld@@XZ
_TEXT	SEGMENT
?GetWorld@CObj@@QAEPAVCWorld@@XZ PROC NEAR		; CObj::GetWorld, COMDAT
; _this$ = ecx

; 221  : 	CWorld*			GetWorld()	{ return m_pWorld; }

  00000	8b 81 6c 01 00
	00		 mov	 eax, DWORD PTR [ecx+364]
  00006	c3		 ret	 0
?GetWorld@CObj@@QAEPAVCWorld@@XZ ENDP			; CObj::GetWorld
_TEXT	ENDS
PUBLIC	?_Myval@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@KAAAU?$pair@$$CBHH@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Myval
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ?_Myval@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@KAAAU?$pair@$$CBHH@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Myval@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@KAAAU?$pair@$$CBHH@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Myval, COMDAT

; 162  : 		return ((_Vref)(*_Pnode)._Myval);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]
  00004	83 c0 0c	 add	 eax, 12			; 0000000cH

; 163  : 		}

  00007	c3		 ret	 0
?_Myval@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@KAAAU?$pair@$$CBHH@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Myval
_TEXT	ENDS
PUBLIC	?GetLayer@CObj@@QAEHXZ				; CObj::GetLayer
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\obj.h
;	COMDAT ?GetLayer@CObj@@QAEHXZ
_TEXT	SEGMENT
?GetLayer@CObj@@QAEHXZ PROC NEAR			; CObj::GetLayer, COMDAT
; _this$ = ecx

; 247  : 	int		GetLayer()	{	return m_nLayer;	}

  00000	8b 81 b8 01 00
	00		 mov	 eax, DWORD PTR [ecx+440]
  00006	c3		 ret	 0
?GetLayer@CObj@@QAEHXZ ENDP				; CObj::GetLayer
_TEXT	ENDS
PUBLIC	?SetFlag@CObj@@AAEXHK@Z				; CObj::SetFlag
; Function compile flags: /Ogty
;	COMDAT ?SetFlag@CObj@@AAEXHK@Z
_TEXT	SEGMENT
_bUpdate$ = 8						; size = 4
_dwValue$ = 12						; size = 4
?SetFlag@CObj@@AAEXHK@Z PROC NEAR			; CObj::SetFlag, COMDAT
; _this$ = ecx

; 272  : 	if( bUpdate )

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _bUpdate$[esp-4]
  00004	85 c0		 test	 eax, eax
  00006	74 0f		 je	 SHORT $L176539

; 273  : 		m_dwFlags |= dwValue;

  00008	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0000b	8b 44 24 08	 mov	 eax, DWORD PTR _dwValue$[esp-4]
  0000f	0b d0		 or	 edx, eax
  00011	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 276  : }

  00014	c2 08 00	 ret	 8
$L176539:

; 274  : 	else
; 275  : 		m_dwFlags &= (~dwValue);

  00017	8b 54 24 08	 mov	 edx, DWORD PTR _dwValue$[esp-4]
  0001b	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0001e	f7 d2		 not	 edx
  00020	23 c2		 and	 eax, edx
  00022	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 276  : }

  00025	c2 08 00	 ret	 8
?SetFlag@CObj@@AAEXHK@Z ENDP				; CObj::SetFlag
_TEXT	ENDS
PUBLIC	?_Isnil@?$_Tree@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CParty *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CParty *> >,0> >::_Isnil
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Isnil@?$_Tree@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CParty *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CParty *> >,0> >::_Isnil, COMDAT

; 137  : 		return ((_Charref)(*_Pnode)._Isnil);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]
  00004	83 c0 15	 add	 eax, 21			; 00000015H

; 138  : 		}

  00007	c3		 ret	 0
?_Isnil@?$_Tree@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CParty *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CParty *> >,0> >::_Isnil
_TEXT	ENDS
PUBLIC	?_Parent@?$_Tree@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CParty *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CParty *> >,0> >::_Parent
; Function compile flags: /Ogty
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Parent@?$_Tree@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CParty *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CParty *> >,0> >::_Parent, COMDAT

; 152  : 		return ((_Nodepref)(*_Pnode)._Parent);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]
  00004	83 c0 04	 add	 eax, 4

; 153  : 		}

  00007	c3		 ret	 0
?_Parent@?$_Tree@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CParty *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CParty *> >,0> >::_Parent
_TEXT	ENDS
PUBLIC	?_Right@?$_Tree@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CParty *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CParty *> >,0> >::_Right
; Function compile flags: /Ogty
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Right@?$_Tree@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CParty *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CParty *> >,0> >::_Right, COMDAT

; 157  : 		return ((_Nodepref)(*_Pnode)._Right);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]
  00004	83 c0 08	 add	 eax, 8

; 158  : 		}

  00007	c3		 ret	 0
?_Right@?$_Tree@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CParty *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CParty *> >,0> >::_Right
_TEXT	ENDS
PUBLIC	?_Myval@?$_Tree@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBKPAVCParty@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CParty *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CParty *> >,0> >::_Myval
; Function compile flags: /Ogty
;	COMDAT ?_Myval@?$_Tree@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBKPAVCParty@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Myval@?$_Tree@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBKPAVCParty@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CParty *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CParty *> >,0> >::_Myval, COMDAT

; 162  : 		return ((_Vref)(*_Pnode)._Myval);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]
  00004	83 c0 0c	 add	 eax, 12			; 0000000cH

; 163  : 		}

  00007	c3		 ret	 0
?_Myval@?$_Tree@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBKPAVCParty@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CParty *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CParty *> >,0> >::_Myval
_TEXT	ENDS
PUBLIC	?_Min@?$_Tree@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CParty *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CParty *> >,0> >::_Min
; Function compile flags: /Ogty
;	COMDAT ?_Min@?$_Tree@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Min@?$_Tree@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CParty *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CParty *> >,0> >::_Min, COMDAT

; 1042 : 		while (!_Isnil(_Left(_Pnode)))

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]
  00004	8b 08		 mov	 ecx, DWORD PTR [eax]
  00006	8a 51 15	 mov	 dl, BYTE PTR [ecx+21]
  00009	84 d2		 test	 dl, dl
  0000b	75 0e		 jne	 SHORT $L290786
  0000d	8d 49 00	 npad	 3
$L290785:

; 1043 : 			_Pnode = _Left(_Pnode);

  00010	8b c1		 mov	 eax, ecx
  00012	8b 08		 mov	 ecx, DWORD PTR [eax]
  00014	8a 51 15	 mov	 dl, BYTE PTR [ecx+21]
  00017	84 d2		 test	 dl, dl
  00019	74 f5		 je	 SHORT $L290785
$L290786:

; 1044 : 		return (_Pnode);
; 1045 : 		}

  0001b	c3		 ret	 0
?_Min@?$_Tree@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CParty *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CParty *> >,0> >::_Min
_TEXT	ENDS
PUBLIC	?IsValidObj@@YAHPAVCObj@@@Z			; IsValidObj
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\obj.h
;	COMDAT ?IsValidObj@@YAHPAVCObj@@@Z
_TEXT	SEGMENT
_pObj$ = 8						; size = 4
?IsValidObj@@YAHPAVCObj@@@Z PROC NEAR			; IsValidObj, COMDAT

; 327  : 	return pObj && ( pObj->IsDelete() == FALSE ); 

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _pObj$[esp-4]
  00004	85 c0		 test	 eax, eax
  00006	74 0c		 je	 SHORT $L296748
  00008	f6 40 04 01	 test	 BYTE PTR [eax+4], 1
  0000c	75 06		 jne	 SHORT $L296748
  0000e	b8 01 00 00 00	 mov	 eax, 1

; 328  : }

  00013	c3		 ret	 0
$L296748:

; 327  : 	return pObj && ( pObj->IsDelete() == FALSE ); 

  00014	33 c0		 xor	 eax, eax

; 328  : }

  00016	c3		 ret	 0
?IsValidObj@@YAHPAVCObj@@@Z ENDP			; IsValidObj
_TEXT	ENDS
PUBLIC	?_Isnil@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,_Friend,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,_Friend> >,0> >::_Isnil
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Isnil@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,_Friend,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,_Friend> >,0> >::_Isnil, COMDAT

; 137  : 		return ((_Charref)(*_Pnode)._Isnil);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]
  00004	83 c0 19	 add	 eax, 25			; 00000019H

; 138  : 		}

  00007	c3		 ret	 0
?_Isnil@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,_Friend,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,_Friend> >,0> >::_Isnil
_TEXT	ENDS
PUBLIC	?_Parent@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,_Friend,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,_Friend> >,0> >::_Parent
; Function compile flags: /Ogty
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Parent@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,_Friend,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,_Friend> >,0> >::_Parent, COMDAT

; 152  : 		return ((_Nodepref)(*_Pnode)._Parent);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]
  00004	83 c0 04	 add	 eax, 4

; 153  : 		}

  00007	c3		 ret	 0
?_Parent@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,_Friend,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,_Friend> >,0> >::_Parent
_TEXT	ENDS
PUBLIC	?_Right@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,_Friend,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,_Friend> >,0> >::_Right
; Function compile flags: /Ogty
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Right@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,_Friend,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,_Friend> >,0> >::_Right, COMDAT

; 157  : 		return ((_Nodepref)(*_Pnode)._Right);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]
  00004	83 c0 08	 add	 eax, 8

; 158  : 		}

  00007	c3		 ret	 0
?_Right@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,_Friend,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,_Friend> >,0> >::_Right
_TEXT	ENDS
PUBLIC	?_Myval@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBKU_Friend@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,_Friend,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,_Friend> >,0> >::_Myval
; Function compile flags: /Ogty
;	COMDAT ?_Myval@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBKU_Friend@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Myval@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBKU_Friend@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,_Friend,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,_Friend> >,0> >::_Myval, COMDAT

; 162  : 		return ((_Vref)(*_Pnode)._Myval);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]
  00004	83 c0 0c	 add	 eax, 12			; 0000000cH

; 163  : 		}

  00007	c3		 ret	 0
?_Myval@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBKU_Friend@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,_Friend,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,_Friend> >,0> >::_Myval
_TEXT	ENDS
PUBLIC	?_Min@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,_Friend,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,_Friend> >,0> >::_Min
; Function compile flags: /Ogty
;	COMDAT ?_Min@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Min@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,_Friend,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,_Friend> >,0> >::_Min, COMDAT

; 1042 : 		while (!_Isnil(_Left(_Pnode)))

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]
  00004	8b 08		 mov	 ecx, DWORD PTR [eax]
  00006	8a 51 19	 mov	 dl, BYTE PTR [ecx+25]
  00009	84 d2		 test	 dl, dl
  0000b	75 0e		 jne	 SHORT $L290827
  0000d	8d 49 00	 npad	 3
$L290826:

; 1043 : 			_Pnode = _Left(_Pnode);

  00010	8b c1		 mov	 eax, ecx
  00012	8b 08		 mov	 ecx, DWORD PTR [eax]
  00014	8a 51 19	 mov	 dl, BYTE PTR [ecx+25]
  00017	84 d2		 test	 dl, dl
  00019	74 f5		 je	 SHORT $L290826
$L290827:

; 1044 : 		return (_Pnode);
; 1045 : 		}

  0001b	c3		 ret	 0
?_Min@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,_Friend,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,_Friend> >,0> >::_Min
_TEXT	ENDS
PUBLIC	?_Isnil@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CGuildMember *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuildMember *> >,0> >::_Isnil
; Function compile flags: /Ogty
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Isnil@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CGuildMember *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuildMember *> >,0> >::_Isnil, COMDAT

; 137  : 		return ((_Charref)(*_Pnode)._Isnil);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]
  00004	83 c0 15	 add	 eax, 21			; 00000015H

; 138  : 		}

  00007	c3		 ret	 0
?_Isnil@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CGuildMember *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuildMember *> >,0> >::_Isnil
_TEXT	ENDS
PUBLIC	?_Parent@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CGuildMember *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuildMember *> >,0> >::_Parent
; Function compile flags: /Ogty
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Parent@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CGuildMember *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuildMember *> >,0> >::_Parent, COMDAT

; 152  : 		return ((_Nodepref)(*_Pnode)._Parent);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]
  00004	83 c0 04	 add	 eax, 4

; 153  : 		}

  00007	c3		 ret	 0
?_Parent@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CGuildMember *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuildMember *> >,0> >::_Parent
_TEXT	ENDS
PUBLIC	?_Right@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CGuildMember *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuildMember *> >,0> >::_Right
; Function compile flags: /Ogty
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Right@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CGuildMember *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuildMember *> >,0> >::_Right, COMDAT

; 157  : 		return ((_Nodepref)(*_Pnode)._Right);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]
  00004	83 c0 08	 add	 eax, 8

; 158  : 		}

  00007	c3		 ret	 0
?_Right@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CGuildMember *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuildMember *> >,0> >::_Right
_TEXT	ENDS
PUBLIC	?_Myval@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBKPAVCGuildMember@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CGuildMember *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuildMember *> >,0> >::_Myval
; Function compile flags: /Ogty
;	COMDAT ?_Myval@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBKPAVCGuildMember@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Myval@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBKPAVCGuildMember@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CGuildMember *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuildMember *> >,0> >::_Myval, COMDAT

; 162  : 		return ((_Vref)(*_Pnode)._Myval);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]
  00004	83 c0 0c	 add	 eax, 12			; 0000000cH

; 163  : 		}

  00007	c3		 ret	 0
?_Myval@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBKPAVCGuildMember@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CGuildMember *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuildMember *> >,0> >::_Myval
_TEXT	ENDS
PUBLIC	?_Min@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CGuildMember *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuildMember *> >,0> >::_Min
; Function compile flags: /Ogty
;	COMDAT ?_Min@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Min@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CGuildMember *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuildMember *> >,0> >::_Min, COMDAT

; 1042 : 		while (!_Isnil(_Left(_Pnode)))

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]
  00004	8b 08		 mov	 ecx, DWORD PTR [eax]
  00006	8a 51 15	 mov	 dl, BYTE PTR [ecx+21]
  00009	84 d2		 test	 dl, dl
  0000b	75 0e		 jne	 SHORT $L290870
  0000d	8d 49 00	 npad	 3
$L290869:

; 1043 : 			_Pnode = _Left(_Pnode);

  00010	8b c1		 mov	 eax, ecx
  00012	8b 08		 mov	 ecx, DWORD PTR [eax]
  00014	8a 51 15	 mov	 dl, BYTE PTR [ecx+21]
  00017	84 d2		 test	 dl, dl
  00019	74 f5		 je	 SHORT $L290869
$L290870:

; 1044 : 		return (_Pnode);
; 1045 : 		}

  0001b	c3		 ret	 0
?_Min@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CGuildMember *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuildMember *> >,0> >::_Min
_TEXT	ENDS
PUBLIC	?GetId@CCtrl@@QAEKXZ				; CCtrl::GetId
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\ctrl.h
;	COMDAT ?GetId@CCtrl@@QAEKXZ
_TEXT	SEGMENT
?GetId@CCtrl@@QAEKXZ PROC NEAR				; CCtrl::GetId, COMDAT
; _this$ = ecx

; 58   : 	OBJID			GetId()					{ return m_objid;   }

  00000	8b 81 bc 01 00
	00		 mov	 eax, DWORD PTR [ecx+444]
  00006	c3		 ret	 0
?GetId@CCtrl@@QAEKXZ ENDP				; CCtrl::GetId
_TEXT	ENDS
PUBLIC	?LOG_RANGE@@YAXPBDHHH@Z				; LOG_RANGE
PUBLIC	??_C@_0BM@HMFGHCP@?$CFs?5min?3?$CFd?0?5max?3?$CFd?0?5index?3?$CFd?$AA@ ; `string'
EXTRN	?Error@@YAPBDPBDZZ:NEAR				; Error
;	COMDAT ??_C@_0BM@HMFGHCP@?$CFs?5min?3?$CFd?0?5max?3?$CFd?0?5index?3?$CFd?$AA@
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\project.h
CONST	SEGMENT
??_C@_0BM@HMFGHCP@?$CFs?5min?3?$CFd?0?5max?3?$CFd?0?5index?3?$CFd?$AA@ DB '%'
	DB	's min:%d, max:%d, index:%d', 00H		; `string'
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ?LOG_RANGE@@YAXPBDHHH@Z
_TEXT	SEGMENT
_szMsg$ = 8						; size = 4
_nMin$ = 12						; size = 4
_nMax$ = 16						; size = 4
_nIndex$ = 20						; size = 4
?LOG_RANGE@@YAXPBDHHH@Z PROC NEAR			; LOG_RANGE, COMDAT

; 559  : 	LPCTSTR szErr = Error( _T( "%s min:%d, max:%d, index:%d" ), szMsg, nMin, nMax, nIndex ); 

  00000	8b 44 24 10	 mov	 eax, DWORD PTR _nIndex$[esp-4]
  00004	8b 4c 24 0c	 mov	 ecx, DWORD PTR _nMax$[esp-4]
  00008	8b 54 24 08	 mov	 edx, DWORD PTR _nMin$[esp-4]
  0000c	50		 push	 eax
  0000d	8b 44 24 08	 mov	 eax, DWORD PTR _szMsg$[esp]
  00011	51		 push	 ecx
  00012	52		 push	 edx
  00013	50		 push	 eax
  00014	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@HMFGHCP@?$CFs?5min?3?$CFd?0?5max?3?$CFd?0?5index?3?$CFd?$AA@
  00019	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  0001e	83 c4 14	 add	 esp, 20			; 00000014H

; 560  : 	ADDERRORMSG( szErr ); 
; 561  : }

  00021	c3		 ret	 0
?LOG_RANGE@@YAXPBDHHH@Z ENDP				; LOG_RANGE
_TEXT	ENDS
PUBLIC	?LOG_CALLSTACK@@YAXXZ				; LOG_CALLSTACK
; Function compile flags: /Ogty
;	COMDAT ?LOG_CALLSTACK@@YAXXZ
_TEXT	SEGMENT
?LOG_CALLSTACK@@YAXXZ PROC NEAR				; LOG_CALLSTACK, COMDAT

; 565  : #ifdef _DEBUG
; 566  : 	__asm int 3
; 567  : #endif
; 568  : 
; 569  : #if defined(__INTERNALSERVER)
; 570  : 	int *p = NULL;		//    
; 571  : 	*p = 1;
; 572  : #endif
; 573  : }

  00000	c3		 ret	 0
?LOG_CALLSTACK@@YAXXZ ENDP				; LOG_CALLSTACK
_TEXT	ENDS
PUBLIC	??0_GIFTBOXRESULT@@QAE@XZ			; _GIFTBOXRESULT::_GIFTBOXRESULT
; Function compile flags: /Ogty
;	COMDAT ??0_GIFTBOXRESULT@@QAE@XZ
_TEXT	SEGMENT
??0_GIFTBOXRESULT@@QAE@XZ PROC NEAR			; _GIFTBOXRESULT::_GIFTBOXRESULT, COMDAT
; _this$ = ecx

; 665  : 	_GIFTBOXRESULT()

  00000	8b c1		 mov	 eax, ecx

; 666  : 		{
; 667  : 			dwItem	= 0;

  00002	33 c9		 xor	 ecx, ecx
  00004	89 08		 mov	 DWORD PTR [eax], ecx

; 668  : 			nNum	= 0;

  00006	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 669  : 			nFlag	= 0;

  00009	88 48 08	 mov	 BYTE PTR [eax+8], cl

; 670  : 			nSpan	= 0;

  0000c	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 671  : 			nAbilityOption	= 0;

  0000f	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 672  : 		}

  00012	c3		 ret	 0
??0_GIFTBOXRESULT@@QAE@XZ ENDP				; _GIFTBOXRESULT::_GIFTBOXRESULT
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@U__ITEMINFO@@@std@@QBEIXZ	; std::allocator<__ITEMINFO>::max_size
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ?max_size@?$allocator@U__ITEMINFO@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@U__ITEMINFO@@@std@@QBEIXZ PROC NEAR ; std::allocator<__ITEMINFO>::max_size, COMDAT
; _this$ = ecx

; 157  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 158  : 		return (0 < _Count ? _Count : 1);

  00000	b8 55 55 55 15	 mov	 eax, 357913941		; 15555555H

; 159  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@U__ITEMINFO@@@std@@QBEIXZ ENDP	; std::allocator<__ITEMINFO>::max_size
_TEXT	ENDS
PUBLIC	??0const_iterator@?$vector@KV?$allocator@K@std@@@std@@QAE@PAK@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::const_iterator::const_iterator
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ??0const_iterator@?$vector@KV?$allocator@K@std@@@std@@QAE@PAK@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0const_iterator@?$vector@KV?$allocator@K@std@@@std@@QAE@PAK@Z PROC NEAR ; std::vector<unsigned long,std::allocator<unsigned long> >::const_iterator::const_iterator, COMDAT
; _this$ = ecx

; 73   : 		const_iterator(_Tptr _Ptr)

  00000	8b c1		 mov	 eax, ecx

; 74   : 			{	// construct with pointer _Ptr
; 75   : 			_Myptr = _Ptr;

  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Ptr$[esp-4]
  00006	89 08		 mov	 DWORD PTR [eax], ecx

; 76   : 			}

  00008	c2 04 00	 ret	 4
??0const_iterator@?$vector@KV?$allocator@K@std@@@std@@QAE@PAK@Z ENDP ; std::vector<unsigned long,std::allocator<unsigned long> >::const_iterator::const_iterator
_TEXT	ENDS
PUBLIC	??Gconst_iterator@?$vector@KV?$allocator@K@std@@@std@@QBEHABV012@@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::const_iterator::operator-
; Function compile flags: /Ogty
;	COMDAT ??Gconst_iterator@?$vector@KV?$allocator@K@std@@@std@@QBEHABV012@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??Gconst_iterator@?$vector@KV?$allocator@K@std@@@std@@QBEHABV012@@Z PROC NEAR ; std::vector<unsigned long,std::allocator<unsigned long> >::const_iterator::operator-, COMDAT
; _this$ = ecx

; 141  : 
; 142  : 
; 143  : 			return (_Myptr - _Right._Myptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Right$[esp-4]
  00006	2b 01		 sub	 eax, DWORD PTR [ecx]
  00008	c1 f8 02	 sar	 eax, 2

; 144  : 			}

  0000b	c2 04 00	 ret	 4
??Gconst_iterator@?$vector@KV?$allocator@K@std@@@std@@QBEHABV012@@Z ENDP ; std::vector<unsigned long,std::allocator<unsigned long> >::const_iterator::operator-
_TEXT	ENDS
PUBLIC	??0const_iterator@?$vector@HV?$allocator@H@std@@@std@@QAE@PAH@Z ; std::vector<int,std::allocator<int> >::const_iterator::const_iterator
; Function compile flags: /Ogty
;	COMDAT ??0const_iterator@?$vector@HV?$allocator@H@std@@@std@@QAE@PAH@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0const_iterator@?$vector@HV?$allocator@H@std@@@std@@QAE@PAH@Z PROC NEAR ; std::vector<int,std::allocator<int> >::const_iterator::const_iterator, COMDAT
; _this$ = ecx

; 73   : 		const_iterator(_Tptr _Ptr)

  00000	8b c1		 mov	 eax, ecx

; 74   : 			{	// construct with pointer _Ptr
; 75   : 			_Myptr = _Ptr;

  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Ptr$[esp-4]
  00006	89 08		 mov	 DWORD PTR [eax], ecx

; 76   : 			}

  00008	c2 04 00	 ret	 4
??0const_iterator@?$vector@HV?$allocator@H@std@@@std@@QAE@PAH@Z ENDP ; std::vector<int,std::allocator<int> >::const_iterator::const_iterator
_TEXT	ENDS
PUBLIC	??0const_iterator@?$vector@VCGuildCombat1to1@@V?$allocator@VCGuildCombat1to1@@@std@@@std@@QAE@PAVCGuildCombat1to1@@@Z ; std::vector<CGuildCombat1to1,std::allocator<CGuildCombat1to1> >::const_iterator::const_iterator
; Function compile flags: /Ogty
;	COMDAT ??0const_iterator@?$vector@VCGuildCombat1to1@@V?$allocator@VCGuildCombat1to1@@@std@@@std@@QAE@PAVCGuildCombat1to1@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0const_iterator@?$vector@VCGuildCombat1to1@@V?$allocator@VCGuildCombat1to1@@@std@@@std@@QAE@PAVCGuildCombat1to1@@@Z PROC NEAR ; std::vector<CGuildCombat1to1,std::allocator<CGuildCombat1to1> >::const_iterator::const_iterator, COMDAT
; _this$ = ecx

; 73   : 		const_iterator(_Tptr _Ptr)

  00000	8b c1		 mov	 eax, ecx

; 74   : 			{	// construct with pointer _Ptr
; 75   : 			_Myptr = _Ptr;

  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Ptr$[esp-4]
  00006	89 08		 mov	 DWORD PTR [eax], ecx

; 76   : 			}

  00008	c2 04 00	 ret	 4
??0const_iterator@?$vector@VCGuildCombat1to1@@V?$allocator@VCGuildCombat1to1@@@std@@@std@@QAE@PAVCGuildCombat1to1@@@Z ENDP ; std::vector<CGuildCombat1to1,std::allocator<CGuildCombat1to1> >::const_iterator::const_iterator
_TEXT	ENDS
PUBLIC	??0const_iterator@?$vector@U__GC1TO1TENDER@CGuildCombat1to1Mng@@V?$allocator@U__GC1TO1TENDER@CGuildCombat1to1Mng@@@std@@@std@@QAE@PAU__GC1TO1TENDER@CGuildCombat1to1Mng@@@Z ; std::vector<CGuildCombat1to1Mng::__GC1TO1TENDER,std::allocator<CGuildCombat1to1Mng::__GC1TO1TENDER> >::const_iterator::const_iterator
; Function compile flags: /Ogty
;	COMDAT ??0const_iterator@?$vector@U__GC1TO1TENDER@CGuildCombat1to1Mng@@V?$allocator@U__GC1TO1TENDER@CGuildCombat1to1Mng@@@std@@@std@@QAE@PAU__GC1TO1TENDER@CGuildCombat1to1Mng@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0const_iterator@?$vector@U__GC1TO1TENDER@CGuildCombat1to1Mng@@V?$allocator@U__GC1TO1TENDER@CGuildCombat1to1Mng@@@std@@@std@@QAE@PAU__GC1TO1TENDER@CGuildCombat1to1Mng@@@Z PROC NEAR ; std::vector<CGuildCombat1to1Mng::__GC1TO1TENDER,std::allocator<CGuildCombat1to1Mng::__GC1TO1TENDER> >::const_iterator::const_iterator, COMDAT
; _this$ = ecx

; 73   : 		const_iterator(_Tptr _Ptr)

  00000	8b c1		 mov	 eax, ecx

; 74   : 			{	// construct with pointer _Ptr
; 75   : 			_Myptr = _Ptr;

  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Ptr$[esp-4]
  00006	89 08		 mov	 DWORD PTR [eax], ecx

; 76   : 			}

  00008	c2 04 00	 ret	 4
??0const_iterator@?$vector@U__GC1TO1TENDER@CGuildCombat1to1Mng@@V?$allocator@U__GC1TO1TENDER@CGuildCombat1to1Mng@@@std@@@std@@QAE@PAU__GC1TO1TENDER@CGuildCombat1to1Mng@@@Z ENDP ; std::vector<CGuildCombat1to1Mng::__GC1TO1TENDER,std::allocator<CGuildCombat1to1Mng::__GC1TO1TENDER> >::const_iterator::const_iterator
_TEXT	ENDS
PUBLIC	??0const_iterator@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE@PAPAU__JOINPLAYER@CGuildCombat@@@Z ; std::vector<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::const_iterator::const_iterator
; Function compile flags: /Ogty
;	COMDAT ??0const_iterator@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE@PAPAU__JOINPLAYER@CGuildCombat@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0const_iterator@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE@PAPAU__JOINPLAYER@CGuildCombat@@@Z PROC NEAR ; std::vector<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::const_iterator::const_iterator, COMDAT
; _this$ = ecx

; 73   : 		const_iterator(_Tptr _Ptr)

  00000	8b c1		 mov	 eax, ecx

; 74   : 			{	// construct with pointer _Ptr
; 75   : 			_Myptr = _Ptr;

  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Ptr$[esp-4]
  00006	89 08		 mov	 DWORD PTR [eax], ecx

; 76   : 			}

  00008	c2 04 00	 ret	 4
??0const_iterator@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE@PAPAU__JOINPLAYER@CGuildCombat@@@Z ENDP ; std::vector<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::const_iterator::const_iterator
_TEXT	ENDS
PUBLIC	??0const_iterator@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@QAE@PAU__GCGETPOINT@CGuildCombat@@@Z ; std::vector<CGuildCombat::__GCGETPOINT,std::allocator<CGuildCombat::__GCGETPOINT> >::const_iterator::const_iterator
; Function compile flags: /Ogty
;	COMDAT ??0const_iterator@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@QAE@PAU__GCGETPOINT@CGuildCombat@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0const_iterator@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@QAE@PAU__GCGETPOINT@CGuildCombat@@@Z PROC NEAR ; std::vector<CGuildCombat::__GCGETPOINT,std::allocator<CGuildCombat::__GCGETPOINT> >::const_iterator::const_iterator, COMDAT
; _this$ = ecx

; 73   : 		const_iterator(_Tptr _Ptr)

  00000	8b c1		 mov	 eax, ecx

; 74   : 			{	// construct with pointer _Ptr
; 75   : 			_Myptr = _Ptr;

  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Ptr$[esp-4]
  00006	89 08		 mov	 DWORD PTR [eax], ecx

; 76   : 			}

  00008	c2 04 00	 ret	 4
??0const_iterator@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@QAE@PAU__GCGETPOINT@CGuildCombat@@@Z ENDP ; std::vector<CGuildCombat::__GCGETPOINT,std::allocator<CGuildCombat::__GCGETPOINT> >::const_iterator::const_iterator
_TEXT	ENDS
PUBLIC	??0const_iterator@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@QAE@PAU__GCPLAYERPOINT@CGuildCombat@@@Z ; std::vector<CGuildCombat::__GCPLAYERPOINT,std::allocator<CGuildCombat::__GCPLAYERPOINT> >::const_iterator::const_iterator
; Function compile flags: /Ogty
;	COMDAT ??0const_iterator@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@QAE@PAU__GCPLAYERPOINT@CGuildCombat@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0const_iterator@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@QAE@PAU__GCPLAYERPOINT@CGuildCombat@@@Z PROC NEAR ; std::vector<CGuildCombat::__GCPLAYERPOINT,std::allocator<CGuildCombat::__GCPLAYERPOINT> >::const_iterator::const_iterator, COMDAT
; _this$ = ecx

; 73   : 		const_iterator(_Tptr _Ptr)

  00000	8b c1		 mov	 eax, ecx

; 74   : 			{	// construct with pointer _Ptr
; 75   : 			_Myptr = _Ptr;

  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Ptr$[esp-4]
  00006	89 08		 mov	 DWORD PTR [eax], ecx

; 76   : 			}

  00008	c2 04 00	 ret	 4
??0const_iterator@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@QAE@PAU__GCPLAYERPOINT@CGuildCombat@@@Z ENDP ; std::vector<CGuildCombat::__GCPLAYERPOINT,std::allocator<CGuildCombat::__GCPLAYERPOINT> >::const_iterator::const_iterator
_TEXT	ENDS
PUBLIC	??0const_iterator@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QAE@PAPAU__GuildCombatMember@CGuildCombat@@@Z ; std::vector<CGuildCombat::__GuildCombatMember *,std::allocator<CGuildCombat::__GuildCombatMember *> >::const_iterator::const_iterator
; Function compile flags: /Ogty
;	COMDAT ??0const_iterator@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QAE@PAPAU__GuildCombatMember@CGuildCombat@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0const_iterator@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QAE@PAPAU__GuildCombatMember@CGuildCombat@@@Z PROC NEAR ; std::vector<CGuildCombat::__GuildCombatMember *,std::allocator<CGuildCombat::__GuildCombatMember *> >::const_iterator::const_iterator, COMDAT
; _this$ = ecx

; 73   : 		const_iterator(_Tptr _Ptr)

  00000	8b c1		 mov	 eax, ecx

; 74   : 			{	// construct with pointer _Ptr
; 75   : 			_Myptr = _Ptr;

  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Ptr$[esp-4]
  00006	89 08		 mov	 DWORD PTR [eax], ecx

; 76   : 			}

  00008	c2 04 00	 ret	 4
??0const_iterator@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QAE@PAPAU__GuildCombatMember@CGuildCombat@@@Z ENDP ; std::vector<CGuildCombat::__GuildCombatMember *,std::allocator<CGuildCombat::__GuildCombatMember *> >::const_iterator::const_iterator
_TEXT	ENDS
PUBLIC	??0const_iterator@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QAE@PAU__REQUESTGUILD@CGuildCombat@@@Z ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::const_iterator::const_iterator
; Function compile flags: /Ogty
;	COMDAT ??0const_iterator@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QAE@PAU__REQUESTGUILD@CGuildCombat@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0const_iterator@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QAE@PAU__REQUESTGUILD@CGuildCombat@@@Z PROC NEAR ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::const_iterator::const_iterator, COMDAT
; _this$ = ecx

; 73   : 		const_iterator(_Tptr _Ptr)

  00000	8b c1		 mov	 eax, ecx

; 74   : 			{	// construct with pointer _Ptr
; 75   : 			_Myptr = _Ptr;

  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Ptr$[esp-4]
  00006	89 08		 mov	 DWORD PTR [eax], ecx

; 76   : 			}

  00008	c2 04 00	 ret	 4
??0const_iterator@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QAE@PAU__REQUESTGUILD@CGuildCombat@@@Z ENDP ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::const_iterator::const_iterator
_TEXT	ENDS
PUBLIC	??0const_iterator@?$vector@U__SECRETROOM_TENDER@@V?$allocator@U__SECRETROOM_TENDER@@@std@@@std@@QAE@PAU__SECRETROOM_TENDER@@@Z ; std::vector<__SECRETROOM_TENDER,std::allocator<__SECRETROOM_TENDER> >::const_iterator::const_iterator
; Function compile flags: /Ogty
;	COMDAT ??0const_iterator@?$vector@U__SECRETROOM_TENDER@@V?$allocator@U__SECRETROOM_TENDER@@@std@@@std@@QAE@PAU__SECRETROOM_TENDER@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0const_iterator@?$vector@U__SECRETROOM_TENDER@@V?$allocator@U__SECRETROOM_TENDER@@@std@@@std@@QAE@PAU__SECRETROOM_TENDER@@@Z PROC NEAR ; std::vector<__SECRETROOM_TENDER,std::allocator<__SECRETROOM_TENDER> >::const_iterator::const_iterator, COMDAT
; _this$ = ecx

; 73   : 		const_iterator(_Tptr _Ptr)

  00000	8b c1		 mov	 eax, ecx

; 74   : 			{	// construct with pointer _Ptr
; 75   : 			_Myptr = _Ptr;

  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Ptr$[esp-4]
  00006	89 08		 mov	 DWORD PTR [eax], ecx

; 76   : 			}

  00008	c2 04 00	 ret	 4
??0const_iterator@?$vector@U__SECRETROOM_TENDER@@V?$allocator@U__SECRETROOM_TENDER@@@std@@@std@@QAE@PAU__SECRETROOM_TENDER@@@Z ENDP ; std::vector<__SECRETROOM_TENDER,std::allocator<__SECRETROOM_TENDER> >::const_iterator::const_iterator
_TEXT	ENDS
PUBLIC	??0const_iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::const_iterator::const_iterator
; Function compile flags: /Ogty
;	COMDAT ??0const_iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0const_iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z PROC NEAR ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::const_iterator::const_iterator, COMDAT
; _this$ = ecx

; 73   : 		const_iterator(_Tptr _Ptr)

  00000	8b c1		 mov	 eax, ecx

; 74   : 			{	// construct with pointer _Ptr
; 75   : 			_Myptr = _Ptr;

  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Ptr$[esp-4]
  00006	89 08		 mov	 DWORD PTR [eax], ecx

; 76   : 			}

  00008	c2 04 00	 ret	 4
??0const_iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::const_iterator::const_iterator
_TEXT	ENDS
PUBLIC	??Gconst_iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEHABV012@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::const_iterator::operator-
; Function compile flags: /Ogty
;	COMDAT ??Gconst_iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEHABV012@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??Gconst_iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEHABV012@@Z PROC NEAR ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::const_iterator::operator-, COMDAT
; _this$ = ecx

; 141  : 
; 142  : 
; 143  : 			return (_Myptr - _Right._Myptr);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Right$[esp-4]
  00004	8b 10		 mov	 edx, DWORD PTR [eax]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	2b ca		 sub	 ecx, edx
  0000a	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  0000f	f7 e9		 imul	 ecx
  00011	03 d1		 add	 edx, ecx
  00013	c1 fa 04	 sar	 edx, 4
  00016	8b c2		 mov	 eax, edx
  00018	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0001b	03 c2		 add	 eax, edx

; 144  : 			}

  0001d	c2 04 00	 ret	 4
??Gconst_iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEHABV012@@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::const_iterator::operator-
_TEXT	ENDS
PUBLIC	??0const_iterator@?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE@PAU__JOINPLAYER@CGuildCombat@@@Z ; std::vector<CGuildCombat::__JOINPLAYER,std::allocator<CGuildCombat::__JOINPLAYER> >::const_iterator::const_iterator
; Function compile flags: /Ogty
;	COMDAT ??0const_iterator@?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE@PAU__JOINPLAYER@CGuildCombat@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0const_iterator@?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE@PAU__JOINPLAYER@CGuildCombat@@@Z PROC NEAR ; std::vector<CGuildCombat::__JOINPLAYER,std::allocator<CGuildCombat::__JOINPLAYER> >::const_iterator::const_iterator, COMDAT
; _this$ = ecx

; 73   : 		const_iterator(_Tptr _Ptr)

  00000	8b c1		 mov	 eax, ecx

; 74   : 			{	// construct with pointer _Ptr
; 75   : 			_Myptr = _Ptr;

  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Ptr$[esp-4]
  00006	89 08		 mov	 DWORD PTR [eax], ecx

; 76   : 			}

  00008	c2 04 00	 ret	 4
??0const_iterator@?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE@PAU__JOINPLAYER@CGuildCombat@@@Z ENDP ; std::vector<CGuildCombat::__JOINPLAYER,std::allocator<CGuildCombat::__JOINPLAYER> >::const_iterator::const_iterator
_TEXT	ENDS
PUBLIC	??0const_iterator@?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@QAE@PAU__ITEMINFO@@@Z ; std::vector<__ITEMINFO,std::allocator<__ITEMINFO> >::const_iterator::const_iterator
; Function compile flags: /Ogty
;	COMDAT ??0const_iterator@?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@QAE@PAU__ITEMINFO@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0const_iterator@?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@QAE@PAU__ITEMINFO@@@Z PROC NEAR ; std::vector<__ITEMINFO,std::allocator<__ITEMINFO> >::const_iterator::const_iterator, COMDAT
; _this$ = ecx

; 73   : 		const_iterator(_Tptr _Ptr)

  00000	8b c1		 mov	 eax, ecx

; 74   : 			{	// construct with pointer _Ptr
; 75   : 			_Myptr = _Ptr;

  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Ptr$[esp-4]
  00006	89 08		 mov	 DWORD PTR [eax], ecx

; 76   : 			}

  00008	c2 04 00	 ret	 4
??0const_iterator@?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@QAE@PAU__ITEMINFO@@@Z ENDP ; std::vector<__ITEMINFO,std::allocator<__ITEMINFO> >::const_iterator::const_iterator
_TEXT	ENDS
PUBLIC	??Gconst_iterator@?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@QBEHABV012@@Z ; std::vector<__ITEMINFO,std::allocator<__ITEMINFO> >::const_iterator::operator-
; Function compile flags: /Ogty
;	COMDAT ??Gconst_iterator@?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@QBEHABV012@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??Gconst_iterator@?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@QBEHABV012@@Z PROC NEAR ; std::vector<__ITEMINFO,std::allocator<__ITEMINFO> >::const_iterator::operator-, COMDAT
; _this$ = ecx

; 141  : 
; 142  : 
; 143  : 			return (_Myptr - _Right._Myptr);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Right$[esp-4]
  00004	8b 10		 mov	 edx, DWORD PTR [eax]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	2b ca		 sub	 ecx, edx
  0000a	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0000f	f7 e9		 imul	 ecx
  00011	d1 fa		 sar	 edx, 1
  00013	8b c2		 mov	 eax, edx
  00015	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00018	03 c2		 add	 eax, edx

; 144  : 			}

  0001a	c2 04 00	 ret	 4
??Gconst_iterator@?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@QBEHABV012@@Z ENDP ; std::vector<__ITEMINFO,std::allocator<__ITEMINFO> >::const_iterator::operator-
_TEXT	ENDS
PUBLIC	??0_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE@PAU012@0ABQAU__JOINPLAYER@CGuildCombat@@@Z ; std::_List_nod<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Node::_Node
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\list
;	COMDAT ??0_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE@PAU012@0ABQAU__JOINPLAYER@CGuildCombat@@@Z
_TEXT	SEGMENT
__Nextarg$ = 8						; size = 4
__Prevarg$ = 12						; size = 4
__Myvalarg$ = 16					; size = 4
??0_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE@PAU012@0ABQAU__JOINPLAYER@CGuildCombat@@@Z PROC NEAR ; std::_List_nod<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Node::_Node, COMDAT
; _this$ = ecx

; 34   : 			{	// construct a node with value

  00000	8b 54 24 08	 mov	 edx, DWORD PTR __Prevarg$[esp-4]
  00004	8b c1		 mov	 eax, ecx
  00006	8b 4c 24 04	 mov	 ecx, DWORD PTR __Nextarg$[esp-4]
  0000a	89 08		 mov	 DWORD PTR [eax], ecx
  0000c	8b 4c 24 0c	 mov	 ecx, DWORD PTR __Myvalarg$[esp-4]
  00010	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00013	8b 11		 mov	 edx, DWORD PTR [ecx]
  00015	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 35   : 			}

  00018	c2 0c 00	 ret	 12			; 0000000cH
??0_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE@PAU012@0ABQAU__JOINPLAYER@CGuildCombat@@@Z ENDP ; std::_List_nod<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Node::_Node
_TEXT	ENDS
PUBLIC	??0_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@QAE@PAU012@0ABQAVCUser@@@Z ; std::_List_nod<CUser *,std::allocator<CUser *> >::_Node::_Node
; Function compile flags: /Ogty
;	COMDAT ??0_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@QAE@PAU012@0ABQAVCUser@@@Z
_TEXT	SEGMENT
__Nextarg$ = 8						; size = 4
__Prevarg$ = 12						; size = 4
__Myvalarg$ = 16					; size = 4
??0_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@QAE@PAU012@0ABQAVCUser@@@Z PROC NEAR ; std::_List_nod<CUser *,std::allocator<CUser *> >::_Node::_Node, COMDAT
; _this$ = ecx

; 34   : 			{	// construct a node with value

  00000	8b 54 24 08	 mov	 edx, DWORD PTR __Prevarg$[esp-4]
  00004	8b c1		 mov	 eax, ecx
  00006	8b 4c 24 04	 mov	 ecx, DWORD PTR __Nextarg$[esp-4]
  0000a	89 08		 mov	 DWORD PTR [eax], ecx
  0000c	8b 4c 24 0c	 mov	 ecx, DWORD PTR __Myvalarg$[esp-4]
  00010	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00013	8b 11		 mov	 edx, DWORD PTR [ecx]
  00015	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 35   : 			}

  00018	c2 0c 00	 ret	 12			; 0000000cH
??0_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@QAE@PAU012@0ABQAVCUser@@@Z ENDP ; std::_List_nod<CUser *,std::allocator<CUser *> >::_Node::_Node
_TEXT	ENDS
PUBLIC	??0?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@QAE@U?$less@H@1@@Z ; std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0>::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0>
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\map
;	COMDAT ??0?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@QAE@U?$less@H@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 1
??0?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@QAE@U?$less@H@1@@Z PROC NEAR ; std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0>::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0>, COMDAT
; _this$ = ecx

; 38   : 		{	// construct with specified comparator

  00000	8b c1		 mov	 eax, ecx

; 39   : 		}

  00002	c2 04 00	 ret	 4
??0?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@QAE@U?$less@H@1@@Z ENDP ; std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0>::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0>
_TEXT	ENDS
PUBLIC	??0_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBHH@2@D@Z ; std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node::_Node
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ??0_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBHH@2@D@Z
_TEXT	SEGMENT
__Larg$ = 8						; size = 4
__Parg$ = 12						; size = 4
__Rarg$ = 16						; size = 4
__Val$ = 20						; size = 4
__Carg$ = 24						; size = 1
??0_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBHH@2@D@Z PROC NEAR ; std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node::_Node, COMDAT
; _this$ = ecx

; 40   : 			{	// construct a node with value

  00000	8b 54 24 08	 mov	 edx, DWORD PTR __Parg$[esp-4]
  00004	8b c1		 mov	 eax, ecx
  00006	8b 4c 24 04	 mov	 ecx, DWORD PTR __Larg$[esp-4]
  0000a	89 08		 mov	 DWORD PTR [eax], ecx
  0000c	8b 4c 24 0c	 mov	 ecx, DWORD PTR __Rarg$[esp-4]
  00010	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  00013	8b 4c 24 10	 mov	 ecx, DWORD PTR __Val$[esp-4]
  00017	89 50 04	 mov	 DWORD PTR [eax+4], edx
  0001a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0001c	89 50 0c	 mov	 DWORD PTR [eax+12], edx
  0001f	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00022	8a 54 24 14	 mov	 dl, BYTE PTR __Carg$[esp-4]
  00026	89 48 10	 mov	 DWORD PTR [eax+16], ecx
  00029	88 50 14	 mov	 BYTE PTR [eax+20], dl
  0002c	c6 40 15 00	 mov	 BYTE PTR [eax+21], 0

; 41   : 			}

  00030	c2 14 00	 ret	 20			; 00000014H
??0_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBHH@2@D@Z ENDP ; std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node::_Node
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@QBEIXZ ; std::allocator<CGuildCombat::__JOINPLAYER *>::max_size
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ?max_size@?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@QBEIXZ PROC NEAR ; std::allocator<CGuildCombat::__JOINPLAYER *>::max_size, COMDAT
; _this$ = ecx

; 157  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 158  : 		return (0 < _Count ? _Count : 1);

  00000	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 159  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@QBEIXZ ENDP ; std::allocator<CGuildCombat::__JOINPLAYER *>::max_size
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@PAVCUser@@@std@@QBEIXZ	; std::allocator<CUser *>::max_size
; Function compile flags: /Ogty
;	COMDAT ?max_size@?$allocator@PAVCUser@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@PAVCUser@@@std@@QBEIXZ PROC NEAR	; std::allocator<CUser *>::max_size, COMDAT
; _this$ = ecx

; 157  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 158  : 		return (0 < _Count ? _Count : 1);

  00000	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 159  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@PAVCUser@@@std@@QBEIXZ ENDP	; std::allocator<CUser *>::max_size
_TEXT	ENDS
PUBLIC	??0?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@QAE@U?$less@K@1@@Z ; std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0>::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0>
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\map
;	COMDAT ??0?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@QAE@U?$less@K@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 1
??0?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@QAE@U?$less@K@1@@Z PROC NEAR ; std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0>::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0>, COMDAT
; _this$ = ecx

; 38   : 		{	// construct with specified comparator

  00000	8b c1		 mov	 eax, ecx

; 39   : 		}

  00002	c2 04 00	 ret	 4
??0?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@QAE@U?$less@K@1@@Z ENDP ; std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0>::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0>
_TEXT	ENDS
PUBLIC	??0?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@QAE@U?$less@K@1@@Z ; std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0>::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0>
; Function compile flags: /Ogty
;	COMDAT ??0?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@QAE@U?$less@K@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 1
??0?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@QAE@U?$less@K@1@@Z PROC NEAR ; std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0>::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0>, COMDAT
; _this$ = ecx

; 38   : 		{	// construct with specified comparator

  00000	8b c1		 mov	 eax, ecx

; 39   : 		}

  00002	c2 04 00	 ret	 4
??0?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@QAE@U?$less@K@1@@Z ENDP ; std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0>::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0>
_TEXT	ENDS
PUBLIC	?IsEquip@?$CItemContainer@VCItemElem@@@@QAEHK@Z	; CItemContainer<CItemElem>::IsEquip
PUBLIC	??_C@_0N@GELFDHNG@CONTAINER?1?10?$AA@		; `string'
EXTRN	?WriteError@@YAXPBDZZ:NEAR			; WriteError
;	COMDAT ??_C@_0N@GELFDHNG@CONTAINER?1?10?$AA@
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\item.h
CONST	SEGMENT
??_C@_0N@GELFDHNG@CONTAINER?1?10?$AA@ DB 'CONTAINER//0', 00H ; `string'
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ?IsEquip@?$CItemContainer@VCItemElem@@@@QAEHK@Z
_TEXT	SEGMENT
_dwObjId$ = 8						; size = 4
?IsEquip@?$CItemContainer@VCItemElem@@@@QAEHK@Z PROC NEAR ; CItemContainer<CItemElem>::IsEquip, COMDAT
; _this$ = ecx

; 602  : 	if( !m_apItem )

  00000	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00003	85 d2		 test	 edx, edx
  00005	75 12		 jne	 SHORT $L291725

; 603  : 	{
; 604  : 		WriteError( "CONTAINER//0" );

  00007	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0N@GELFDHNG@CONTAINER?1?10?$AA@
  0000c	e8 00 00 00 00	 call	 ?WriteError@@YAXPBDZZ	; WriteError
  00011	83 c4 04	 add	 esp, 4
$L296903:

; 605  : 		return FALSE;

  00014	33 c0		 xor	 eax, eax

; 612  : 		return TRUE;
; 613  : 	return FALSE;
; 614  : }

  00016	c2 04 00	 ret	 4
$L291725:

; 606  : 	}
; 607  : 
; 608  : 	if( dwObjId >= m_dwItemMax )

  00019	8b 44 24 04	 mov	 eax, DWORD PTR _dwObjId$[esp-4]
  0001d	3b 41 0c	 cmp	 eax, DWORD PTR [ecx+12]

; 609  : 		return FALSE;

  00020	73 f2		 jae	 SHORT $L296903

; 610  : 
; 611  : 	if( m_apItem[ dwObjId ].m_dwObjIndex >= m_dwIndexNum )

  00022	69 c0 b8 00 00
	00		 imul	 eax, 184		; 000000b8H
  00028	8b 44 10 08	 mov	 eax, DWORD PTR [eax+edx+8]
  0002c	3b 41 08	 cmp	 eax, DWORD PTR [ecx+8]
  0002f	1b c0		 sbb	 eax, eax
  00031	40		 inc	 eax

; 612  : 		return TRUE;
; 613  : 	return FALSE;
; 614  : }

  00032	c2 04 00	 ret	 4
?IsEquip@?$CItemContainer@VCItemElem@@@@QAEHK@Z ENDP	; CItemContainer<CItemElem>::IsEquip
_TEXT	ENDS
PUBLIC	?GetAtItemId@?$CItemContainer@VCItemElem@@@@QAEPAVCItemElem@@K@Z ; CItemContainer<CItemElem>::GetAtItemId
; Function compile flags: /Ogty
;	COMDAT ?GetAtItemId@?$CItemContainer@VCItemElem@@@@QAEPAVCItemElem@@K@Z
_TEXT	SEGMENT
_dwItemId$ = 8						; size = 4
?GetAtItemId@?$CItemContainer@VCItemElem@@@@QAEPAVCItemElem@@K@Z PROC NEAR ; CItemContainer<CItemElem>::GetAtItemId, COMDAT
; _this$ = ecx

; 531  : 	}
; 532  : 	return NULL;

  00000	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00003	56		 push	 esi
  00004	33 c0		 xor	 eax, eax
  00006	85 d2		 test	 edx, edx
  00008	57		 push	 edi
  00009	76 19		 jbe	 SHORT $L291737
  0000b	8b 71 10	 mov	 esi, DWORD PTR [ecx+16]
  0000e	8b 7c 24 0c	 mov	 edi, DWORD PTR _dwItemId$[esp+4]
  00012	8d 4e 0c	 lea	 ecx, DWORD PTR [esi+12]
$L291735:
  00015	39 39		 cmp	 DWORD PTR [ecx], edi
  00017	74 12		 je	 SHORT $L296908
  00019	40		 inc	 eax
  0001a	81 c1 b8 00 00
	00		 add	 ecx, 184		; 000000b8H
  00020	3b c2		 cmp	 eax, edx
  00022	72 f1		 jb	 SHORT $L291735
$L291737:
  00024	5f		 pop	 edi
  00025	5e		 pop	 esi
  00026	33 c0		 xor	 eax, eax

; 533  : }

  00028	c2 04 00	 ret	 4
$L296908:

; 527  : 	for( DWORD i = 0; i < m_dwItemMax; i++ )
; 528  : 	{
; 529  : 		if( m_apItem[i].m_dwItemId == dwItemId )
; 530  : 			return &m_apItem[i];

  0002b	69 c0 b8 00 00
	00		 imul	 eax, 184		; 000000b8H
  00031	5f		 pop	 edi
  00032	03 c6		 add	 eax, esi
  00034	5e		 pop	 esi

; 533  : }

  00035	c2 04 00	 ret	 4
?GetAtItemId@?$CItemContainer@VCItemElem@@@@QAEPAVCItemElem@@K@Z ENDP ; CItemContainer<CItemElem>::GetAtItemId
_TEXT	ENDS
PUBLIC	?GetAtItemNum@?$CItemContainer@VCItemElem@@@@QAEHK@Z ; CItemContainer<CItemElem>::GetAtItemNum
; Function compile flags: /Ogty
;	COMDAT ?GetAtItemNum@?$CItemContainer@VCItemElem@@@@QAEHK@Z
_TEXT	SEGMENT
_dwItemId$ = 8						; size = 4
?GetAtItemNum@?$CItemContainer@VCItemElem@@@@QAEHK@Z PROC NEAR ; CItemContainer<CItemElem>::GetAtItemNum, COMDAT
; _this$ = ecx

; 537  : 	int nResult = 0;
; 538  : 	for( DWORD i = 0; i < m_dwItemMax; i++ )
; 539  : 	{
; 540  : 		if( m_apItem[i].m_dwItemId == dwItemId )
; 541  : 			nResult += m_apItem[i].m_nItemNum;
; 542  : 	}
; 543  : 	return nResult;

  00000	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00003	33 c0		 xor	 eax, eax
  00005	85 d2		 test	 edx, edx
  00007	76 24		 jbe	 SHORT $L291748
  00009	8b 49 10	 mov	 ecx, DWORD PTR [ecx+16]
  0000c	56		 push	 esi
  0000d	8b 74 24 08	 mov	 esi, DWORD PTR _dwItemId$[esp]
  00011	57		 push	 edi
  00012	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
$L291746:
  00018	39 71 8c	 cmp	 DWORD PTR [ecx-116], esi
  0001b	75 05		 jne	 SHORT $L291747
  0001d	0f bf 39	 movsx	 edi, WORD PTR [ecx]
  00020	03 c7		 add	 eax, edi
$L291747:
  00022	81 c1 b8 00 00
	00		 add	 ecx, 184		; 000000b8H
  00028	4a		 dec	 edx
  00029	75 ed		 jne	 SHORT $L291746
  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
$L291748:

; 544  : }

  0002d	c2 04 00	 ret	 4
?GetAtItemNum@?$CItemContainer@VCItemElem@@@@QAEHK@Z ENDP ; CItemContainer<CItemElem>::GetAtItemNum
_TEXT	ENDS
PUBLIC	?RemoveAtId@?$CItemContainer@VCItemElem@@@@QAEXK@Z ; CItemContainer<CItemElem>::RemoveAtId
; Function compile flags: /Ogty
;	COMDAT ?RemoveAtId@?$CItemContainer@VCItemElem@@@@QAEXK@Z
_TEXT	SEGMENT
_dwObjId$ = 8						; size = 4
?RemoveAtId@?$CItemContainer@VCItemElem@@@@QAEXK@Z PROC NEAR ; CItemContainer<CItemElem>::RemoveAtId, COMDAT
; _this$ = ecx

; 768  : {

  00000	56		 push	 esi

; 769  : 	if( dwObjId >= m_dwItemMax )

  00001	8b 74 24 08	 mov	 esi, DWORD PTR _dwObjId$[esp]
  00005	57		 push	 edi
  00006	8b f9		 mov	 edi, ecx
  00008	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  0000b	3b f0		 cmp	 esi, eax
  0000d	73 41		 jae	 SHORT $L291757

; 770  : 		return;
; 771  : 	if( m_apItem[ dwObjId ].m_dwObjIndex >= m_dwItemMax )

  0000f	8b 4f 10	 mov	 ecx, DWORD PTR [edi+16]
  00012	69 f6 b8 00 00
	00		 imul	 esi, 184		; 000000b8H
  00018	39 44 31 08	 cmp	 DWORD PTR [ecx+esi+8], eax
  0001c	73 32		 jae	 SHORT $L291757

; 772  : 		return;
; 773  : 	m_apItem[ dwObjId ].Empty();

  0001e	8b d1		 mov	 edx, ecx
  00020	8b 04 32	 mov	 eax, DWORD PTR [edx+esi]
  00023	8d 0c 32	 lea	 ecx, DWORD PTR [edx+esi]
  00026	ff 50 0c	 call	 DWORD PTR [eax+12]

; 774  : 	if( m_apItem[ dwObjId ].m_dwObjIndex >= m_dwIndexNum )

  00029	8b 4f 10	 mov	 ecx, DWORD PTR [edi+16]
  0002c	8b 54 31 08	 mov	 edx, DWORD PTR [ecx+esi+8]
  00030	3b 57 08	 cmp	 edx, DWORD PTR [edi+8]
  00033	72 1b		 jb	 SHORT $L291757

; 775  : 	{
; 776  : 		m_apIndex[ m_apItem[ dwObjId ].m_dwObjIndex ] = NULL_ID;

  00035	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  00038	8b c1		 mov	 eax, ecx
  0003a	8b 4c 30 08	 mov	 ecx, DWORD PTR [eax+esi+8]
  0003e	c7 04 8a ff ff
	ff ff		 mov	 DWORD PTR [edx+ecx*4], -1

; 777  : 		m_apItem[ dwObjId ].m_dwObjIndex = NULL_ID;

  00045	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  00048	c7 44 30 08 ff
	ff ff ff	 mov	 DWORD PTR [eax+esi+8], -1
$L291757:
  00050	5f		 pop	 edi
  00051	5e		 pop	 esi

; 778  : 	}
; 779  : }

  00052	c2 04 00	 ret	 4
?RemoveAtId@?$CItemContainer@VCItemElem@@@@QAEXK@Z ENDP	; CItemContainer<CItemElem>::RemoveAtId
_TEXT	ENDS
PUBLIC	??$_Iter_cat@Viterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@@std@@YA?AUbidirectional_iterator_tag@0@ABViterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@0@@Z ; std::_Iter_cat<std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::iterator>
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xutility
;	COMDAT ??$_Iter_cat@Viterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@@std@@YA?AUbidirectional_iterator_tag@0@ABViterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??$_Iter_cat@Viterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@@std@@YA?AUbidirectional_iterator_tag@0@ABViterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@0@@Z PROC NEAR ; std::_Iter_cat<std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::iterator>, COMDAT

; 202  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 203  : 	return (_Cat);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 204  : 	}

  00004	c3		 ret	 0
??$_Iter_cat@Viterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@@std@@YA?AUbidirectional_iterator_tag@0@ABViterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@0@@Z ENDP ; std::_Iter_cat<std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::iterator>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@KV?$allocator@K@std@@@std@@YAXPAK0AAV?$allocator@K@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<unsigned long,std::allocator<unsigned long> >
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??$_Destroy_range@KV?$allocator@K@std@@@std@@YAXPAK0AAV?$allocator@K@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@KV?$allocator@K@std@@@std@@YAXPAK0AAV?$allocator@K@0@U_Scalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Destroy_range<unsigned long,std::allocator<unsigned long> >, COMDAT

; 234  : 	}

  00000	c3		 ret	 0
??$_Destroy_range@KV?$allocator@K@std@@@std@@YAXPAK0AAV?$allocator@K@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<unsigned long,std::allocator<unsigned long> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@EV?$allocator@E@std@@@std@@YAXPAE0AAV?$allocator@E@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<unsigned char,std::allocator<unsigned char> >
; Function compile flags: /Ogty
;	COMDAT ??$_Destroy_range@EV?$allocator@E@std@@@std@@YAXPAE0AAV?$allocator@E@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@EV?$allocator@E@std@@@std@@YAXPAE0AAV?$allocator@E@0@U_Scalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Destroy_range<unsigned char,std::allocator<unsigned char> >, COMDAT

; 234  : 	}

  00000	c3		 ret	 0
??$_Destroy_range@EV?$allocator@E@std@@@std@@YAXPAE0AAV?$allocator@E@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<unsigned char,std::allocator<unsigned char> >
_TEXT	ENDS
PUBLIC	??$?0KPAVCUser@@@?$pair@$$CBKPAVCUser@@@std@@QAE@ABU?$pair@KPAVCUser@@@1@@Z ; std::pair<unsigned long const ,CUser *>::pair<unsigned long const ,CUser *><unsigned long,CUser *>
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\utility
;	COMDAT ??$?0KPAVCUser@@@?$pair@$$CBKPAVCUser@@@std@@QAE@ABU?$pair@KPAVCUser@@@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??$?0KPAVCUser@@@?$pair@$$CBKPAVCUser@@@std@@QAE@ABU?$pair@KPAVCUser@@@1@@Z PROC NEAR ; std::pair<unsigned long const ,CUser *>::pair<unsigned long const ,CUser *><unsigned long,CUser *>, COMDAT
; _this$ = ecx

; 41   : 		{	// construct from compatible pair

  00000	8b c1		 mov	 eax, ecx
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Right$[esp-4]
  00006	8b 11		 mov	 edx, DWORD PTR [ecx]
  00008	89 10		 mov	 DWORD PTR [eax], edx
  0000a	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0000d	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 42   : 		}

  00010	c2 04 00	 ret	 4
??$?0KPAVCUser@@@?$pair@$$CBKPAVCUser@@@std@@QAE@ABU?$pair@KPAVCUser@@@1@@Z ENDP ; std::pair<unsigned long const ,CUser *>::pair<unsigned long const ,CUser *><unsigned long,CUser *>
_TEXT	ENDS
PUBLIC	?GetName@CPet@@QAEPBDXZ				; CPet::GetName
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\pet.h
;	COMDAT ?GetName@CPet@@QAEPBDXZ
_TEXT	SEGMENT
?GetName@CPet@@QAEPBDXZ PROC NEAR			; CPet::GetName, COMDAT
; _this$ = ecx

; 149  : 	const char*	GetName()	{	return m_szName;	}

  00000	8d 41 16	 lea	 eax, DWORD PTR [ecx+22]
  00003	c3		 ret	 0
?GetName@CPet@@QAEPBDXZ ENDP				; CPet::GetName
_TEXT	ENDS
PUBLIC	??$_Destroy@U_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@@std@@YAXPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@0@@Z ; std::_Destroy<std::_List_nod<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Node>
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??$_Destroy@U_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@@std@@YAXPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@0@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@U_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@@std@@YAXPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@0@@Z PROC NEAR ; std::_Destroy<std::_List_nod<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Node>, COMDAT

; 49   : 	_DESTRUCTOR(_Ty, _Ptr);
; 50   : 	}

  00000	c3		 ret	 0
??$_Destroy@U_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@@std@@YAXPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@0@@Z ENDP ; std::_Destroy<std::_List_nod<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Node>
_TEXT	ENDS
PUBLIC	??$_Destroy@U_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@@std@@YAXPAU_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@0@@Z ; std::_Destroy<std::_List_nod<CUser *,std::allocator<CUser *> >::_Node>
; Function compile flags: /Ogty
;	COMDAT ??$_Destroy@U_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@@std@@YAXPAU_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@0@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@U_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@@std@@YAXPAU_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@0@@Z PROC NEAR ; std::_Destroy<std::_List_nod<CUser *,std::allocator<CUser *> >::_Node>, COMDAT

; 49   : 	_DESTRUCTOR(_Ty, _Ptr);
; 50   : 	}

  00000	c3		 ret	 0
??$_Destroy@U_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@@std@@YAXPAU_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@0@@Z ENDP ; std::_Destroy<std::_List_nod<CUser *,std::allocator<CUser *> >::_Node>
_TEXT	ENDS
PUBLIC	??$_Allocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IPAV10@@Z ; std::_Allocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
EXTRN	??2@YAPAXI@Z:NEAR				; operator new
; Function compile flags: /Ogty
;	COMDAT ??$_Allocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IPAV10@@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IPAV10@@Z PROC NEAR ; std::_Allocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 34   : 	return ((_Ty _FARQ *)operator new(_Count * sizeof (_Ty)));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Count$[esp-4]
  00004	6b c0 1c	 imul	 eax, 28			; 0000001cH
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0000d	83 c4 04	 add	 esp, 4

; 35   : 	}

  00010	c3		 ret	 0
??$_Allocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IPAV10@@Z ENDP ; std::_Allocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
PUBLIC	??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@0@@Z ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Node *>
; Function compile flags: /Ogty
;	COMDAT ??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@0@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@0@@Z PROC NEAR ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Node *>, COMDAT

; 49   : 	_DESTRUCTOR(_Ty, _Ptr);
; 50   : 	}

  00000	c3		 ret	 0
??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@0@@Z ENDP ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Node *>
_TEXT	ENDS
PUBLIC	??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@0@@Z ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::_Node *>
; Function compile flags: /Ogty
;	COMDAT ??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@0@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@0@@Z PROC NEAR ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::_Node *>, COMDAT

; 49   : 	_DESTRUCTOR(_Ty, _Ptr);
; 50   : 	}

  00000	c3		 ret	 0
??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@0@@Z ENDP ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::_Node *>
_TEXT	ENDS
PUBLIC	??$fill@PAKK@std@@YAXPAK0ABK@Z			; std::fill<unsigned long *,unsigned long>
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xutility
;	COMDAT ??$fill@PAKK@std@@YAXPAK0ABK@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAKK@std@@YAXPAK0ABK@Z PROC NEAR		; std::fill<unsigned long *,unsigned long>, COMDAT

; 1135 : 	for (; _First != _Last; ++_First)

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __First$[esp-4]
  00004	8b 4c 24 08	 mov	 ecx, DWORD PTR __Last$[esp-4]
  00008	3b c1		 cmp	 eax, ecx
  0000a	74 11		 je	 SHORT $L292592
  0000c	8b 54 24 0c	 mov	 edx, DWORD PTR __Val$[esp-4]
  00010	56		 push	 esi
$L292590:

; 1136 : 		*_First = _Val;

  00011	8b 32		 mov	 esi, DWORD PTR [edx]
  00013	89 30		 mov	 DWORD PTR [eax], esi
  00015	83 c0 04	 add	 eax, 4
  00018	3b c1		 cmp	 eax, ecx
  0001a	75 f5		 jne	 SHORT $L292590
  0001c	5e		 pop	 esi
$L292592:

; 1137 : 	}

  0001d	c3		 ret	 0
??$fill@PAKK@std@@YAXPAK0ABK@Z ENDP			; std::fill<unsigned long *,unsigned long>
_TEXT	ENDS
PUBLIC	?IsEmpty@CItemBase@@QAEHXZ			; CItemBase::IsEmpty
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\item.h
;	COMDAT ?IsEmpty@CItemBase@@QAEHXZ
_TEXT	SEGMENT
?IsEmpty@CItemBase@@QAEHXZ PROC NEAR			; CItemBase::IsEmpty, COMDAT
; _this$ = ecx

; 48   : 	BOOL			IsEmpty() { return m_dwItemId ? FALSE : TRUE; }

  00000	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00003	33 c0		 xor	 eax, eax
  00005	85 d2		 test	 edx, edx
  00007	0f 94 c0	 sete	 al
  0000a	c3		 ret	 0
?IsEmpty@CItemBase@@QAEHXZ ENDP				; CItemBase::IsEmpty
_TEXT	ENDS
PUBLIC	??$?0U?$pair@$$CBHH@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHH@std@@@1@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node *>::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node *><std::pair<int const ,int> >
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??$?0U?$pair@$$CBHH@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHH@std@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$?0U?$pair@$$CBHH@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHH@std@@@1@@Z PROC NEAR ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node *>::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node *><std::pair<int const ,int> >, COMDAT
; _this$ = ecx

; 120  : 		allocator(const allocator<_Other>&)

  00000	8b c1		 mov	 eax, ecx

; 121  : 		{	// construct from a related allocator (do nothing)
; 122  : 		}

  00002	c2 04 00	 ret	 4
??$?0U?$pair@$$CBHH@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHH@std@@@1@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node *>::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node *><std::pair<int const ,int> >
_TEXT	ENDS
PUBLIC	?GetSerialNumber@CItemBase@@QAEKXZ		; CItemBase::GetSerialNumber
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\item.h
;	COMDAT ?GetSerialNumber@CItemBase@@QAEKXZ
_TEXT	SEGMENT
?GetSerialNumber@CItemBase@@QAEKXZ PROC NEAR		; CItemBase::GetSerialNumber, COMDAT
; _this$ = ecx

; 64   : 	SERIALNUMBER	GetSerialNumber( void )		{	return m_liSerialNumber;	}

  00000	8b 41 38	 mov	 eax, DWORD PTR [ecx+56]
  00003	c3		 ret	 0
?GetSerialNumber@CItemBase@@QAEKXZ ENDP			; CItemBase::GetSerialNumber
_TEXT	ENDS
PUBLIC	?SetExtra@CItemBase@@QAEXH@Z			; CItemBase::SetExtra
; Function compile flags: /Ogty
;	COMDAT ?SetExtra@CItemBase@@QAEXH@Z
_TEXT	SEGMENT
_nExtra$ = 8						; size = 4
?SetExtra@CItemBase@@QAEXH@Z PROC NEAR			; CItemBase::SetExtra, COMDAT
; _this$ = ecx

; 70   : 	m_nExtra = nExtra;

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _nExtra$[esp-4]
  00004	89 41 10	 mov	 DWORD PTR [ecx+16], eax

; 71   : }

  00007	c2 04 00	 ret	 4
?SetExtra@CItemBase@@QAEXH@Z ENDP			; CItemBase::SetExtra
_TEXT	ENDS
PUBLIC	?GetExtra@CItemBase@@QAEHXZ			; CItemBase::GetExtra
; Function compile flags: /Ogty
;	COMDAT ?GetExtra@CItemBase@@QAEHXZ
_TEXT	SEGMENT
?GetExtra@CItemBase@@QAEHXZ PROC NEAR			; CItemBase::GetExtra, COMDAT
; _this$ = ecx

; 75   : 	return m_nExtra;

  00000	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]

; 76   : }

  00003	c3		 ret	 0
?GetExtra@CItemBase@@QAEHXZ ENDP			; CItemBase::GetExtra
_TEXT	ENDS
PUBLIC	??$?0PAU__JOINPLAYER@CGuildCombat@@@?$allocator@PAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@@std@@QAE@ABV?$allocator@PAU__JOINPLAYER@CGuildCombat@@@1@@Z ; std::allocator<std::_List_nod<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Node *>::allocator<std::_List_nod<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Node *><CGuildCombat::__JOINPLAYER *>
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??$?0PAU__JOINPLAYER@CGuildCombat@@@?$allocator@PAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@@std@@QAE@ABV?$allocator@PAU__JOINPLAYER@CGuildCombat@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$?0PAU__JOINPLAYER@CGuildCombat@@@?$allocator@PAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@@std@@QAE@ABV?$allocator@PAU__JOINPLAYER@CGuildCombat@@@1@@Z PROC NEAR ; std::allocator<std::_List_nod<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Node *>::allocator<std::_List_nod<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Node *><CGuildCombat::__JOINPLAYER *>, COMDAT
; _this$ = ecx

; 120  : 		allocator(const allocator<_Other>&)

  00000	8b c1		 mov	 eax, ecx

; 121  : 		{	// construct from a related allocator (do nothing)
; 122  : 		}

  00002	c2 04 00	 ret	 4
??$?0PAU__JOINPLAYER@CGuildCombat@@@?$allocator@PAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@@std@@QAE@ABV?$allocator@PAU__JOINPLAYER@CGuildCombat@@@1@@Z ENDP ; std::allocator<std::_List_nod<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Node *>::allocator<std::_List_nod<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Node *><CGuildCombat::__JOINPLAYER *>
_TEXT	ENDS
PUBLIC	??$_Allocate@U_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@@std@@YAPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_List_nod<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Node>
; Function compile flags: /Ogty
;	COMDAT ??$_Allocate@U_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@@std@@YAPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@0@IPAU120@@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@U_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@@std@@YAPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@0@IPAU120@@Z PROC NEAR ; std::_Allocate<std::_List_nod<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Node>, COMDAT

; 34   : 	return ((_Ty _FARQ *)operator new(_Count * sizeof (_Ty)));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Count$[esp-4]
  00004	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00007	c1 e0 02	 shl	 eax, 2
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00010	83 c4 04	 add	 esp, 4

; 35   : 	}

  00013	c3		 ret	 0
??$_Allocate@U_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@@std@@YAPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@0@IPAU120@@Z ENDP ; std::_Allocate<std::_List_nod<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Node>
_TEXT	ENDS
PUBLIC	??$_Construct@PAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@0@ABQAU120@@Z ; std::_Construct<std::_List_nod<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Node *,std::_List_nod<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Node *>
; Function compile flags: /Ogty
;	COMDAT ??$_Construct@PAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@0@ABQAU120@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@PAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@0@ABQAU120@@Z PROC NEAR ; std::_Construct<std::_List_nod<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Node *,std::_List_nod<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Node *>, COMDAT

; 42   : 	new ((void _FARQ *)_Ptr) _T1(_Val);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Ptr$[esp-4]
  00004	85 c0		 test	 eax, eax
  00006	74 08		 je	 SHORT $L296981
  00008	8b 4c 24 08	 mov	 ecx, DWORD PTR __Val$[esp-4]
  0000c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000e	89 10		 mov	 DWORD PTR [eax], edx
$L296981:

; 43   : 	}

  00010	c3		 ret	 0
??$_Construct@PAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@0@ABQAU120@@Z ENDP ; std::_Construct<std::_List_nod<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Node *,std::_List_nod<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Node *>
_TEXT	ENDS
PUBLIC	??$_Destroy@PAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@@std@@YAXPAPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@0@@Z ; std::_Destroy<std::_List_nod<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Node *>
; Function compile flags: /Ogty
;	COMDAT ??$_Destroy@PAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@@std@@YAXPAPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@0@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@PAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@@std@@YAXPAPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@0@@Z PROC NEAR ; std::_Destroy<std::_List_nod<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Node *>, COMDAT

; 49   : 	_DESTRUCTOR(_Ty, _Ptr);
; 50   : 	}

  00000	c3		 ret	 0
??$_Destroy@PAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@@std@@YAXPAPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@0@@Z ENDP ; std::_Destroy<std::_List_nod<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Node *>
_TEXT	ENDS
PUBLIC	?SerializePiercing@CItemElem@@QAEXAAVCAr@@@Z	; CItemElem::SerializePiercing
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\item.h
;	COMDAT ?SerializePiercing@CItemElem@@QAEXAAVCAr@@@Z
_TEXT	SEGMENT
_ar$ = 8						; size = 4
?SerializePiercing@CItemElem@@QAEXAAVCAr@@@Z PROC NEAR	; CItemElem::SerializePiercing, COMDAT
; _this$ = ecx

; 106  : 	void	SerializePiercing( CAr & ar )	{	m_piercing.Serialize( ar );		}

  00000	8b 41 3c	 mov	 eax, DWORD PTR [ecx+60]
  00003	83 c1 3c	 add	 ecx, 60			; 0000003cH
  00006	ff 60 04	 jmp	 DWORD PTR [eax+4]
?SerializePiercing@CItemElem@@QAEXAAVCAr@@@Z ENDP	; CItemElem::SerializePiercing
_TEXT	ENDS
PUBLIC	?GetRandomOptItemId@CItemElem@@QAE_JXZ		; CItemElem::GetRandomOptItemId
; Function compile flags: /Ogty
;	COMDAT ?GetRandomOptItemId@CItemElem@@QAE_JXZ
_TEXT	SEGMENT
?GetRandomOptItemId@CItemElem@@QAE_JXZ PROC NEAR	; CItemElem::GetRandomOptItemId, COMDAT
; _this$ = ecx

; 167  : 	__int64		GetRandomOptItemId( void )	{	return m_iRandomOptItemId;	}

  00000	8b 81 98 00 00
	00		 mov	 eax, DWORD PTR [ecx+152]
  00006	8b 91 9c 00 00
	00		 mov	 edx, DWORD PTR [ecx+156]
  0000c	c3		 ret	 0
?GetRandomOptItemId@CItemElem@@QAE_JXZ ENDP		; CItemElem::GetRandomOptItemId
_TEXT	ENDS
PUBLIC	??$?0PAVCUser@@@?$allocator@PAU_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCUser@@@1@@Z ; std::allocator<std::_List_nod<CUser *,std::allocator<CUser *> >::_Node *>::allocator<std::_List_nod<CUser *,std::allocator<CUser *> >::_Node *><CUser *>
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??$?0PAVCUser@@@?$allocator@PAU_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCUser@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$?0PAVCUser@@@?$allocator@PAU_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCUser@@@1@@Z PROC NEAR ; std::allocator<std::_List_nod<CUser *,std::allocator<CUser *> >::_Node *>::allocator<std::_List_nod<CUser *,std::allocator<CUser *> >::_Node *><CUser *>, COMDAT
; _this$ = ecx

; 120  : 		allocator(const allocator<_Other>&)

  00000	8b c1		 mov	 eax, ecx

; 121  : 		{	// construct from a related allocator (do nothing)
; 122  : 		}

  00002	c2 04 00	 ret	 4
??$?0PAVCUser@@@?$allocator@PAU_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCUser@@@1@@Z ENDP ; std::allocator<std::_List_nod<CUser *,std::allocator<CUser *> >::_Node *>::allocator<std::_List_nod<CUser *,std::allocator<CUser *> >::_Node *><CUser *>
_TEXT	ENDS
PUBLIC	?GetAbilityOption@CItemElem@@QAEHXZ		; CItemElem::GetAbilityOption
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\item.h
;	COMDAT ?GetAbilityOption@CItemElem@@QAEHXZ
_TEXT	SEGMENT
?GetAbilityOption@CItemElem@@QAEHXZ PROC NEAR		; CItemElem::GetAbilityOption, COMDAT
; _this$ = ecx

; 231  : 	int			GetAbilityOption() { return m_nAbilityOption; }

  00000	8b 41 70	 mov	 eax, DWORD PTR [ecx+112]
  00003	c3		 ret	 0
?GetAbilityOption@CItemElem@@QAEHXZ ENDP		; CItemElem::GetAbilityOption
_TEXT	ENDS
PUBLIC	??$_Allocate@U_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@@std@@YAPAU_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_List_nod<CUser *,std::allocator<CUser *> >::_Node>
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??$_Allocate@U_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@@std@@YAPAU_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@0@IPAU120@@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@U_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@@std@@YAPAU_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@0@IPAU120@@Z PROC NEAR ; std::_Allocate<std::_List_nod<CUser *,std::allocator<CUser *> >::_Node>, COMDAT

; 34   : 	return ((_Ty _FARQ *)operator new(_Count * sizeof (_Ty)));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Count$[esp-4]
  00004	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00007	c1 e0 02	 shl	 eax, 2
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00010	83 c4 04	 add	 esp, 4

; 35   : 	}

  00013	c3		 ret	 0
??$_Allocate@U_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@@std@@YAPAU_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@0@IPAU120@@Z ENDP ; std::_Allocate<std::_List_nod<CUser *,std::allocator<CUser *> >::_Node>
_TEXT	ENDS
PUBLIC	??$_Construct@PAU_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@0@ABQAU120@@Z ; std::_Construct<std::_List_nod<CUser *,std::allocator<CUser *> >::_Node *,std::_List_nod<CUser *,std::allocator<CUser *> >::_Node *>
; Function compile flags: /Ogty
;	COMDAT ??$_Construct@PAU_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@0@ABQAU120@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@PAU_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@0@ABQAU120@@Z PROC NEAR ; std::_Construct<std::_List_nod<CUser *,std::allocator<CUser *> >::_Node *,std::_List_nod<CUser *,std::allocator<CUser *> >::_Node *>, COMDAT

; 42   : 	new ((void _FARQ *)_Ptr) _T1(_Val);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Ptr$[esp-4]
  00004	85 c0		 test	 eax, eax
  00006	74 08		 je	 SHORT $L297008
  00008	8b 4c 24 08	 mov	 ecx, DWORD PTR __Val$[esp-4]
  0000c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000e	89 10		 mov	 DWORD PTR [eax], edx
$L297008:

; 43   : 	}

  00010	c3		 ret	 0
??$_Construct@PAU_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@0@ABQAU120@@Z ENDP ; std::_Construct<std::_List_nod<CUser *,std::allocator<CUser *> >::_Node *,std::_List_nod<CUser *,std::allocator<CUser *> >::_Node *>
_TEXT	ENDS
PUBLIC	?SetAbilityOption@CItemElem@@QAEXH@Z		; CItemElem::SetAbilityOption
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\item.h
;	COMDAT ?SetAbilityOption@CItemElem@@QAEXH@Z
_TEXT	SEGMENT
_nAbilityOption$ = 8					; size = 4
?SetAbilityOption@CItemElem@@QAEXH@Z PROC NEAR		; CItemElem::SetAbilityOption, COMDAT
; _this$ = ecx

; 237  : 	void		SetAbilityOption( int nAbilityOption ) { m_nAbilityOption = nAbilityOption; }

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _nAbilityOption$[esp-4]
  00004	89 41 70	 mov	 DWORD PTR [ecx+112], eax
  00007	c2 04 00	 ret	 4
?SetAbilityOption@CItemElem@@QAEXH@Z ENDP		; CItemElem::SetAbilityOption
_TEXT	ENDS
PUBLIC	?IsExpiring@CItemElem@@QAEHXZ			; CItemElem::IsExpiring
; Function compile flags: /Ogty
;	COMDAT ?IsExpiring@CItemElem@@QAEHXZ
_TEXT	SEGMENT
?IsExpiring@CItemElem@@QAEHXZ PROC NEAR			; CItemElem::IsExpiring, COMDAT
; _this$ = ecx

; 247  : 			if( m_dwKeepTime )

  00000	8b 81 b0 00 00
	00		 mov	 eax, DWORD PTR [ecx+176]
  00006	85 c0		 test	 eax, eax
  00008	74 0e		 je	 SHORT $L204584

; 248  : 			{
; 249  : 				if( time_null() > (time_t)m_dwKeepTime )

  0000a	39 05 00 00 00
	00		 cmp	 DWORD PTR ?g_tCurrent@@3JA, eax ; g_tCurrent
  00010	7e 06		 jle	 SHORT $L204584

; 250  : 					return TRUE;

  00012	b8 01 00 00 00	 mov	 eax, 1

; 253  : 		}

  00017	c3		 ret	 0
$L204584:

; 251  : 			}
; 252  : 			return FALSE;

  00018	33 c0		 xor	 eax, eax

; 253  : 		}

  0001a	c3		 ret	 0
?IsExpiring@CItemElem@@QAEHXZ ENDP			; CItemElem::IsExpiring
_TEXT	ENDS
PUBLIC	??$_Destroy@PAU_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@@std@@YAXPAPAU_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@0@@Z ; std::_Destroy<std::_List_nod<CUser *,std::allocator<CUser *> >::_Node *>
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??$_Destroy@PAU_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@@std@@YAXPAPAU_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@0@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@PAU_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@@std@@YAXPAPAU_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@0@@Z PROC NEAR ; std::_Destroy<std::_List_nod<CUser *,std::allocator<CUser *> >::_Node *>, COMDAT

; 49   : 	_DESTRUCTOR(_Ty, _Ptr);
; 50   : 	}

  00000	c3		 ret	 0
??$_Destroy@PAU_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@@std@@YAXPAPAU_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@0@@Z ENDP ; std::_Destroy<std::_List_nod<CUser *,std::allocator<CUser *> >::_Node *>
_TEXT	ENDS
PUBLIC	?SetFlag@CItemElem@@QAEXE@Z			; CItemElem::SetFlag
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\item.h
;	COMDAT ?SetFlag@CItemElem@@QAEXE@Z
_TEXT	SEGMENT
_byFlag$ = 8						; size = 1
?SetFlag@CItemElem@@QAEXE@Z PROC NEAR			; CItemElem::SetFlag, COMDAT
; _this$ = ecx

; 255  : 	void	SetFlag( BYTE byFlag )		{	m_byFlag	|= byFlag;		}

  00000	8a 91 82 00 00
	00		 mov	 dl, BYTE PTR [ecx+130]
  00006	8a 44 24 04	 mov	 al, BYTE PTR _byFlag$[esp-4]
  0000a	0a d0		 or	 dl, al
  0000c	88 91 82 00 00
	00		 mov	 BYTE PTR [ecx+130], dl
  00012	c2 04 00	 ret	 4
?SetFlag@CItemElem@@QAEXE@Z ENDP			; CItemElem::SetFlag
_TEXT	ENDS
PUBLIC	?IsFlag@CItemElem@@QAEHE@Z			; CItemElem::IsFlag
; Function compile flags: /Ogty
;	COMDAT ?IsFlag@CItemElem@@QAEHE@Z
_TEXT	SEGMENT
_byFlag$ = 8						; size = 1
?IsFlag@CItemElem@@QAEHE@Z PROC NEAR			; CItemElem::IsFlag, COMDAT
; _this$ = ecx

; 256  : 	BOOL	IsFlag( BYTE byFlag )	{	return ( m_byFlag & byFlag ) ? TRUE: FALSE;		}

  00000	8a 81 82 00 00
	00		 mov	 al, BYTE PTR [ecx+130]
  00006	22 44 24 04	 and	 al, BYTE PTR _byFlag$[esp-4]
  0000a	f6 d8		 neg	 al
  0000c	1b c0		 sbb	 eax, eax
  0000e	f7 d8		 neg	 eax
  00010	c2 04 00	 ret	 4
?IsFlag@CItemElem@@QAEHE@Z ENDP				; CItemElem::IsFlag
_TEXT	ENDS
PUBLIC	??$fill@PAU__ITEMINFO@@U1@@std@@YAXPAU__ITEMINFO@@0ABU1@@Z ; std::fill<__ITEMINFO *,__ITEMINFO>
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xutility
;	COMDAT ??$fill@PAU__ITEMINFO@@U1@@std@@YAXPAU__ITEMINFO@@0ABU1@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAU__ITEMINFO@@U1@@std@@YAXPAU__ITEMINFO@@0ABU1@@Z PROC NEAR ; std::fill<__ITEMINFO *,__ITEMINFO>, COMDAT

; 1135 : 	for (; _First != _Last; ++_First)

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __First$[esp-4]
  00004	8b 4c 24 08	 mov	 ecx, DWORD PTR __Last$[esp-4]
  00008	3b c1		 cmp	 eax, ecx
  0000a	74 25		 je	 SHORT $L292927
  0000c	8b 54 24 0c	 mov	 edx, DWORD PTR __Val$[esp-4]
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi
$L292925:

; 1136 : 		*_First = _Val;

  00013	8b f2		 mov	 esi, edx
  00015	8b 1e		 mov	 ebx, DWORD PTR [esi]
  00017	8b f8		 mov	 edi, eax
  00019	89 1f		 mov	 DWORD PTR [edi], ebx
  0001b	8b 5e 04	 mov	 ebx, DWORD PTR [esi+4]
  0001e	89 5f 04	 mov	 DWORD PTR [edi+4], ebx
  00021	8b 76 08	 mov	 esi, DWORD PTR [esi+8]
  00024	83 c0 0c	 add	 eax, 12			; 0000000cH
  00027	3b c1		 cmp	 eax, ecx
  00029	89 77 08	 mov	 DWORD PTR [edi+8], esi
  0002c	75 e5		 jne	 SHORT $L292925
  0002e	5f		 pop	 edi
  0002f	5e		 pop	 esi
  00030	5b		 pop	 ebx
$L292927:

; 1137 : 	}

  00031	c3		 ret	 0
??$fill@PAU__ITEMINFO@@U1@@std@@YAXPAU__ITEMINFO@@0ABU1@@Z ENDP ; std::fill<__ITEMINFO *,__ITEMINFO>
_TEXT	ENDS
PUBLIC	??$_Allocate@U__ITEMINFO@@@std@@YAPAU__ITEMINFO@@IPAU1@@Z ; std::_Allocate<__ITEMINFO>
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??$_Allocate@U__ITEMINFO@@@std@@YAPAU__ITEMINFO@@IPAU1@@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@U__ITEMINFO@@@std@@YAPAU__ITEMINFO@@IPAU1@@Z PROC NEAR ; std::_Allocate<__ITEMINFO>, COMDAT

; 34   : 	return ((_Ty _FARQ *)operator new(_Count * sizeof (_Ty)));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Count$[esp-4]
  00004	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00007	c1 e0 02	 shl	 eax, 2
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00010	83 c4 04	 add	 esp, 4

; 35   : 	}

  00013	c3		 ret	 0
??$_Allocate@U__ITEMINFO@@@std@@YAPAU__ITEMINFO@@IPAU1@@Z ENDP ; std::_Allocate<__ITEMINFO>
_TEXT	ENDS
PUBLIC	??$?0U?$pair@$$CBKPAVCUser@@@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@1@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Node *>::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Node *><std::pair<unsigned long const ,CUser *> >
; Function compile flags: /Ogty
;	COMDAT ??$?0U?$pair@$$CBKPAVCUser@@@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$?0U?$pair@$$CBKPAVCUser@@@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@1@@Z PROC NEAR ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Node *>::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Node *><std::pair<unsigned long const ,CUser *> >, COMDAT
; _this$ = ecx

; 120  : 		allocator(const allocator<_Other>&)

  00000	8b c1		 mov	 eax, ecx

; 121  : 		{	// construct from a related allocator (do nothing)
; 122  : 		}

  00002	c2 04 00	 ret	 4
??$?0U?$pair@$$CBKPAVCUser@@@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@1@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Node *>::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Node *><std::pair<unsigned long const ,CUser *> >
_TEXT	ENDS
PUBLIC	??$?0U?$pair@$$CBKPAVCCtrl@@@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@1@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::_Node *>::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::_Node *><std::pair<unsigned long const ,CCtrl *> >
; Function compile flags: /Ogty
;	COMDAT ??$?0U?$pair@$$CBKPAVCCtrl@@@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$?0U?$pair@$$CBKPAVCCtrl@@@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@1@@Z PROC NEAR ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::_Node *>::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::_Node *><std::pair<unsigned long const ,CCtrl *> >, COMDAT
; _this$ = ecx

; 120  : 		allocator(const allocator<_Other>&)

  00000	8b c1		 mov	 eax, ecx

; 121  : 		{	// construct from a related allocator (do nothing)
; 122  : 		}

  00002	c2 04 00	 ret	 4
??$?0U?$pair@$$CBKPAVCCtrl@@@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@1@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::_Node *>::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::_Node *><std::pair<unsigned long const ,CCtrl *> >
_TEXT	ENDS
PUBLIC	??$?0U?$pair@$$CBHH@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHH@std@@@1@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node><std::pair<int const ,int> >
; Function compile flags: /Ogty
;	COMDAT ??$?0U?$pair@$$CBHH@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHH@std@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$?0U?$pair@$$CBHH@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHH@std@@@1@@Z PROC NEAR ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node><std::pair<int const ,int> >, COMDAT
; _this$ = ecx

; 120  : 		allocator(const allocator<_Other>&)

  00000	8b c1		 mov	 eax, ecx

; 121  : 		{	// construct from a related allocator (do nothing)
; 122  : 		}

  00002	c2 04 00	 ret	 4
??$?0U?$pair@$$CBHH@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHH@std@@@1@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node><std::pair<int const ,int> >
_TEXT	ENDS
PUBLIC	??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node>
; Function compile flags: /Ogty
;	COMDAT ??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@0@IPAU120@@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@0@IPAU120@@Z PROC NEAR ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node>, COMDAT

; 34   : 	return ((_Ty _FARQ *)operator new(_Count * sizeof (_Ty)));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Count$[esp-4]
  00004	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00007	c1 e0 03	 shl	 eax, 3
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00010	83 c4 04	 add	 esp, 4

; 35   : 	}

  00013	c3		 ret	 0
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@0@IPAU120@@Z ENDP ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node>
_TEXT	ENDS
PUBLIC	?GetAttrOption@CItemElem@@QAEHXZ		; CItemElem::GetAttrOption
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\item.h
;	COMDAT ?GetAttrOption@CItemElem@@QAEHXZ
_TEXT	SEGMENT
?GetAttrOption@CItemElem@@QAEHXZ PROC NEAR		; CItemElem::GetAttrOption, COMDAT
; _this$ = ecx

; 288  : 	int nAttr = (int)m_bItemResist;
; 289  : 	int nOption = m_nResistAbilityOption;
; 290  : 	int nRet = m_nAbilityOption;
; 291  : 	
; 292  : 	nRet |= (nAttr << 16);		// D16~D23 : 
; 293  : 	nRet |= (nOption << 24);	// D24~D31 : 
; 294  : 	return nRet;

  00000	0f b6 91 88 00
	00 00		 movzx	 edx, BYTE PTR [ecx+136]
  00007	8b 81 8c 00 00
	00		 mov	 eax, DWORD PTR [ecx+140]
  0000d	c1 e0 08	 shl	 eax, 8
  00010	0b c2		 or	 eax, edx
  00012	8b 51 70	 mov	 edx, DWORD PTR [ecx+112]
  00015	c1 e0 10	 shl	 eax, 16			; 00000010H
  00018	0b c2		 or	 eax, edx

; 295  : }

  0001a	c3		 ret	 0
?GetAttrOption@CItemElem@@QAEHXZ ENDP			; CItemElem::GetAttrOption
_TEXT	ENDS
PUBLIC	??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@0@ABQAU120@@Z ; std::_Construct<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node *,std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node *>
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@0@ABQAU120@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@0@ABQAU120@@Z PROC NEAR ; std::_Construct<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node *,std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node *>, COMDAT

; 42   : 	new ((void _FARQ *)_Ptr) _T1(_Val);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Ptr$[esp-4]
  00004	85 c0		 test	 eax, eax
  00006	74 08		 je	 SHORT $L297058
  00008	8b 4c 24 08	 mov	 ecx, DWORD PTR __Val$[esp-4]
  0000c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000e	89 10		 mov	 DWORD PTR [eax], edx
$L297058:

; 43   : 	}

  00010	c3		 ret	 0
??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@0@ABQAU120@@Z ENDP ; std::_Construct<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node *,std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node *>
_TEXT	ENDS
PUBLIC	??$?0PAU__JOINPLAYER@CGuildCombat@@@?$allocator@U_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@@std@@QAE@ABV?$allocator@PAU__JOINPLAYER@CGuildCombat@@@1@@Z ; std::allocator<std::_List_nod<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Node>::allocator<std::_List_nod<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Node><CGuildCombat::__JOINPLAYER *>
; Function compile flags: /Ogty
;	COMDAT ??$?0PAU__JOINPLAYER@CGuildCombat@@@?$allocator@U_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@@std@@QAE@ABV?$allocator@PAU__JOINPLAYER@CGuildCombat@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$?0PAU__JOINPLAYER@CGuildCombat@@@?$allocator@U_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@@std@@QAE@ABV?$allocator@PAU__JOINPLAYER@CGuildCombat@@@1@@Z PROC NEAR ; std::allocator<std::_List_nod<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Node>::allocator<std::_List_nod<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Node><CGuildCombat::__JOINPLAYER *>, COMDAT
; _this$ = ecx

; 120  : 		allocator(const allocator<_Other>&)

  00000	8b c1		 mov	 eax, ecx

; 121  : 		{	// construct from a related allocator (do nothing)
; 122  : 		}

  00002	c2 04 00	 ret	 4
??$?0PAU__JOINPLAYER@CGuildCombat@@@?$allocator@U_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@@std@@QAE@ABV?$allocator@PAU__JOINPLAYER@CGuildCombat@@@1@@Z ENDP ; std::allocator<std::_List_nod<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Node>::allocator<std::_List_nod<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Node><CGuildCombat::__JOINPLAYER *>
_TEXT	ENDS
PUBLIC	?IsStoring@CAr@@QBEHXZ				; CAr::IsStoring
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_network\misc\include\ar.h
;	COMDAT ?IsStoring@CAr@@QBEHXZ
_TEXT	SEGMENT
?IsStoring@CAr@@QBEHXZ PROC NEAR			; CAr::IsStoring, COMDAT
; _this$ = ecx

; 96   : 	{ return (m_nMode & CAr::load) == 0; }

  00000	33 c0		 xor	 eax, eax
  00002	8a 01		 mov	 al, BYTE PTR [ecx]
  00004	f7 d0		 not	 eax
  00006	83 e0 01	 and	 eax, 1
  00009	c3		 ret	 0
?IsStoring@CAr@@QBEHXZ ENDP				; CAr::IsStoring
_TEXT	ENDS
PUBLIC	??$?0PAVCUser@@@?$allocator@U_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCUser@@@1@@Z ; std::allocator<std::_List_nod<CUser *,std::allocator<CUser *> >::_Node>::allocator<std::_List_nod<CUser *,std::allocator<CUser *> >::_Node><CUser *>
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??$?0PAVCUser@@@?$allocator@U_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCUser@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$?0PAVCUser@@@?$allocator@U_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCUser@@@1@@Z PROC NEAR ; std::allocator<std::_List_nod<CUser *,std::allocator<CUser *> >::_Node>::allocator<std::_List_nod<CUser *,std::allocator<CUser *> >::_Node><CUser *>, COMDAT
; _this$ = ecx

; 120  : 		allocator(const allocator<_Other>&)

  00000	8b c1		 mov	 eax, ecx

; 121  : 		{	// construct from a related allocator (do nothing)
; 122  : 		}

  00002	c2 04 00	 ret	 4
??$?0PAVCUser@@@?$allocator@U_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCUser@@@1@@Z ENDP ; std::allocator<std::_List_nod<CUser *,std::allocator<CUser *> >::_Node>::allocator<std::_List_nod<CUser *,std::allocator<CUser *> >::_Node><CUser *>
_TEXT	ENDS
PUBLIC	??$?0U?$pair@$$CBKPAVCUser@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@1@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Node><std::pair<unsigned long const ,CUser *> >
; Function compile flags: /Ogty
;	COMDAT ??$?0U?$pair@$$CBKPAVCUser@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$?0U?$pair@$$CBKPAVCUser@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@1@@Z PROC NEAR ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Node><std::pair<unsigned long const ,CUser *> >, COMDAT
; _this$ = ecx

; 120  : 		allocator(const allocator<_Other>&)

  00000	8b c1		 mov	 eax, ecx

; 121  : 		{	// construct from a related allocator (do nothing)
; 122  : 		}

  00002	c2 04 00	 ret	 4
??$?0U?$pair@$$CBKPAVCUser@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@1@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Node><std::pair<unsigned long const ,CUser *> >
_TEXT	ENDS
PUBLIC	??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@0@ABQAU120@@Z ; std::_Construct<std::_Tree_nod<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Node *,std::_Tree_nod<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Node *>
; Function compile flags: /Ogty
;	COMDAT ??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@0@ABQAU120@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@0@ABQAU120@@Z PROC NEAR ; std::_Construct<std::_Tree_nod<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Node *,std::_Tree_nod<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Node *>, COMDAT

; 42   : 	new ((void _FARQ *)_Ptr) _T1(_Val);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Ptr$[esp-4]
  00004	85 c0		 test	 eax, eax
  00006	74 08		 je	 SHORT $L297079
  00008	8b 4c 24 08	 mov	 ecx, DWORD PTR __Val$[esp-4]
  0000c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000e	89 10		 mov	 DWORD PTR [eax], edx
$L297079:

; 43   : 	}

  00010	c3		 ret	 0
??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@0@ABQAU120@@Z ENDP ; std::_Construct<std::_Tree_nod<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Node *,std::_Tree_nod<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Node *>
_TEXT	ENDS
PUBLIC	??$?0U?$pair@$$CBKPAVCCtrl@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@1@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::_Node><std::pair<unsigned long const ,CCtrl *> >
; Function compile flags: /Ogty
;	COMDAT ??$?0U?$pair@$$CBKPAVCCtrl@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$?0U?$pair@$$CBKPAVCCtrl@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@1@@Z PROC NEAR ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::_Node><std::pair<unsigned long const ,CCtrl *> >, COMDAT
; _this$ = ecx

; 120  : 		allocator(const allocator<_Other>&)

  00000	8b c1		 mov	 eax, ecx

; 121  : 		{	// construct from a related allocator (do nothing)
; 122  : 		}

  00002	c2 04 00	 ret	 4
??$?0U?$pair@$$CBKPAVCCtrl@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@1@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::_Node><std::pair<unsigned long const ,CCtrl *> >
_TEXT	ENDS
PUBLIC	??6CAr@@QAEAAV0@E@Z				; CAr::operator<<
EXTRN	?CheckBuf@CAr@@QAEXI@Z:NEAR			; CAr::CheckBuf
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_network\misc\include\ar.h
;	COMDAT ??6CAr@@QAEAAV0@E@Z
_TEXT	SEGMENT
_by$ = 8						; size = 1
??6CAr@@QAEAAV0@E@Z PROC NEAR				; CAr::operator<<, COMDAT
; _this$ = ecx

; 107  : 	{ CheckBuf( sizeof(BYTE) );

  00000	56		 push	 esi
  00001	6a 01		 push	 1
  00003	8b f1		 mov	 esi, ecx
  00005	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf

; 108  : 		*(UNALIGNED BYTE*)m_lpBufCur = by; m_lpBufCur += sizeof(BYTE); return *this; }

  0000a	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0000d	8a 4c 24 08	 mov	 cl, BYTE PTR _by$[esp]
  00011	88 08		 mov	 BYTE PTR [eax], cl
  00013	ff 46 08	 inc	 DWORD PTR [esi+8]
  00016	8b c6		 mov	 eax, esi
  00018	5e		 pop	 esi
  00019	c2 04 00	 ret	 4
??6CAr@@QAEAAV0@E@Z ENDP				; CAr::operator<<
_TEXT	ENDS
PUBLIC	??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@0@ABQAU120@@Z ; std::_Construct<std::_Tree_nod<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::_Node *,std::_Tree_nod<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::_Node *>
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@0@ABQAU120@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@0@ABQAU120@@Z PROC NEAR ; std::_Construct<std::_Tree_nod<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::_Node *,std::_Tree_nod<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::_Node *>, COMDAT

; 42   : 	new ((void _FARQ *)_Ptr) _T1(_Val);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Ptr$[esp-4]
  00004	85 c0		 test	 eax, eax
  00006	74 08		 je	 SHORT $L297094
  00008	8b 4c 24 08	 mov	 ecx, DWORD PTR __Val$[esp-4]
  0000c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000e	89 10		 mov	 DWORD PTR [eax], edx
$L297094:

; 43   : 	}

  00010	c3		 ret	 0
??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@0@ABQAU120@@Z ENDP ; std::_Construct<std::_Tree_nod<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::_Node *,std::_Tree_nod<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::_Node *>
_TEXT	ENDS
PUBLIC	??6CAr@@QAEAAV0@G@Z				; CAr::operator<<
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_network\misc\include\ar.h
;	COMDAT ??6CAr@@QAEAAV0@G@Z
_TEXT	SEGMENT
_w$ = 8							; size = 2
??6CAr@@QAEAAV0@G@Z PROC NEAR				; CAr::operator<<, COMDAT
; _this$ = ecx

; 110  : 	{ CheckBuf( sizeof( WORD ) );

  00000	56		 push	 esi
  00001	6a 02		 push	 2
  00003	8b f1		 mov	 esi, ecx
  00005	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf

; 111  : 		*(UNALIGNED WORD*)m_lpBufCur = w; m_lpBufCur += sizeof(WORD); return *this; }

  0000a	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0000d	66 8b 4c 24 08	 mov	 cx, WORD PTR _w$[esp]
  00012	66 89 08	 mov	 WORD PTR [eax], cx
  00015	83 46 08 02	 add	 DWORD PTR [esi+8], 2
  00019	8b c6		 mov	 eax, esi
  0001b	5e		 pop	 esi
  0001c	c2 04 00	 ret	 4
??6CAr@@QAEAAV0@G@Z ENDP				; CAr::operator<<
_TEXT	ENDS
PUBLIC	??6CAr@@QAEAAV0@J@Z				; CAr::operator<<
; Function compile flags: /Ogty
;	COMDAT ??6CAr@@QAEAAV0@J@Z
_TEXT	SEGMENT
_l$ = 8							; size = 4
??6CAr@@QAEAAV0@J@Z PROC NEAR				; CAr::operator<<, COMDAT
; _this$ = ecx

; 113  : 	{ CheckBuf( sizeof(LONG) );

  00000	56		 push	 esi
  00001	6a 04		 push	 4
  00003	8b f1		 mov	 esi, ecx
  00005	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf

; 114  : 		*(UNALIGNED LONG*)m_lpBufCur = l; m_lpBufCur += sizeof(LONG); return *this; }

  0000a	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0000d	8b 4c 24 08	 mov	 ecx, DWORD PTR _l$[esp]
  00011	89 08		 mov	 DWORD PTR [eax], ecx
  00013	83 46 08 04	 add	 DWORD PTR [esi+8], 4
  00017	8b c6		 mov	 eax, esi
  00019	5e		 pop	 esi
  0001a	c2 04 00	 ret	 4
??6CAr@@QAEAAV0@J@Z ENDP				; CAr::operator<<
_TEXT	ENDS
PUBLIC	??6CAr@@QAEAAV0@K@Z				; CAr::operator<<
; Function compile flags: /Ogty
;	COMDAT ??6CAr@@QAEAAV0@K@Z
_TEXT	SEGMENT
_dw$ = 8						; size = 4
??6CAr@@QAEAAV0@K@Z PROC NEAR				; CAr::operator<<, COMDAT
; _this$ = ecx

; 116  : 	{ CheckBuf( sizeof(DWORD) );

  00000	56		 push	 esi
  00001	6a 04		 push	 4
  00003	8b f1		 mov	 esi, ecx
  00005	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf

; 117  : 		*(UNALIGNED DWORD*)m_lpBufCur = dw; m_lpBufCur += sizeof(DWORD); return *this; }

  0000a	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0000d	8b 4c 24 08	 mov	 ecx, DWORD PTR _dw$[esp]
  00011	89 08		 mov	 DWORD PTR [eax], ecx
  00013	83 46 08 04	 add	 DWORD PTR [esi+8], 4
  00017	8b c6		 mov	 eax, esi
  00019	5e		 pop	 esi
  0001a	c2 04 00	 ret	 4
??6CAr@@QAEAAV0@K@Z ENDP				; CAr::operator<<
_TEXT	ENDS
PUBLIC	??6CAr@@QAEAAV0@M@Z				; CAr::operator<<
; Function compile flags: /Ogty
;	COMDAT ??6CAr@@QAEAAV0@M@Z
_TEXT	SEGMENT
_f$ = 8							; size = 4
??6CAr@@QAEAAV0@M@Z PROC NEAR				; CAr::operator<<, COMDAT
; _this$ = ecx

; 119  : 	{ CheckBuf( sizeof(float) );

  00000	56		 push	 esi
  00001	6a 04		 push	 4
  00003	8b f1		 mov	 esi, ecx
  00005	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf

; 120  : 		*(UNALIGNED FLOAT*)m_lpBufCur = *(FLOAT*)&f; m_lpBufCur += sizeof(float); return *this; }

  0000a	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0000d	8b 4c 24 08	 mov	 ecx, DWORD PTR _f$[esp]
  00011	89 08		 mov	 DWORD PTR [eax], ecx
  00013	83 46 08 04	 add	 DWORD PTR [esi+8], 4
  00017	8b c6		 mov	 eax, esi
  00019	5e		 pop	 esi
  0001a	c2 04 00	 ret	 4
??6CAr@@QAEAAV0@M@Z ENDP				; CAr::operator<<
_TEXT	ENDS
PUBLIC	??6CAr@@QAEAAV0@N@Z				; CAr::operator<<
; Function compile flags: /Ogty
;	COMDAT ??6CAr@@QAEAAV0@N@Z
_TEXT	SEGMENT
_d$ = 8							; size = 8
??6CAr@@QAEAAV0@N@Z PROC NEAR				; CAr::operator<<, COMDAT
; _this$ = ecx

; 122  : 	{ CheckBuf( sizeof(double) );

  00000	56		 push	 esi
  00001	6a 08		 push	 8
  00003	8b f1		 mov	 esi, ecx
  00005	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf

; 123  : 		*(UNALIGNED double*)m_lpBufCur = *(double*)&d; m_lpBufCur += sizeof(double); return *this; }

  0000a	dd 44 24 08	 fld	 QWORD PTR _d$[esp]
  0000e	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00011	dd 18		 fstp	 QWORD PTR [eax]
  00013	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00016	83 c0 08	 add	 eax, 8
  00019	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0001c	8b c6		 mov	 eax, esi
  0001e	5e		 pop	 esi
  0001f	c2 08 00	 ret	 8
??6CAr@@QAEAAV0@N@Z ENDP				; CAr::operator<<
_TEXT	ENDS
PUBLIC	??5CAr@@QAEAAV0@AAE@Z				; CAr::operator>>
; Function compile flags: /Ogty
;	COMDAT ??5CAr@@QAEAAV0@AAE@Z
_TEXT	SEGMENT
_by$ = 8						; size = 4
??5CAr@@QAEAAV0@AAE@Z PROC NEAR				; CAr::operator>>, COMDAT
; _this$ = ecx

; 142  : 	{	CAR_SAFE_READ( BYTE, by );	}

  00000	8b c1		 mov	 eax, ecx
  00002	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00005	56		 push	 esi
  00006	8b 70 0c	 mov	 esi, DWORD PTR [eax+12]
  00009	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
  0000c	3b d6		 cmp	 edx, esi
  0000e	5e		 pop	 esi
  0000f	77 0e		 ja	 SHORT $L205448
  00011	8a 09		 mov	 cl, BYTE PTR [ecx]
  00013	8b 54 24 04	 mov	 edx, DWORD PTR _by$[esp-4]
  00017	88 0a		 mov	 BYTE PTR [edx], cl
  00019	ff 40 08	 inc	 DWORD PTR [eax+8]
  0001c	c2 04 00	 ret	 4
$L205448:
  0001f	8b 4c 24 04	 mov	 ecx, DWORD PTR _by$[esp-4]
  00023	c6 01 00	 mov	 BYTE PTR [ecx], 0
  00026	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  00029	89 50 08	 mov	 DWORD PTR [eax+8], edx
  0002c	c2 04 00	 ret	 4
??5CAr@@QAEAAV0@AAE@Z ENDP				; CAr::operator>>
_TEXT	ENDS
PUBLIC	??5CAr@@QAEAAV0@AAG@Z				; CAr::operator>>
; Function compile flags: /Ogty
;	COMDAT ??5CAr@@QAEAAV0@AAG@Z
_TEXT	SEGMENT
_w$ = 8							; size = 4
??5CAr@@QAEAAV0@AAG@Z PROC NEAR				; CAr::operator>>, COMDAT
; _this$ = ecx

; 144  : 	{	CAR_SAFE_READ( WORD, w );	}

  00000	8b c1		 mov	 eax, ecx
  00002	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00005	56		 push	 esi
  00006	8b 70 0c	 mov	 esi, DWORD PTR [eax+12]
  00009	8d 51 02	 lea	 edx, DWORD PTR [ecx+2]
  0000c	3b d6		 cmp	 edx, esi
  0000e	5e		 pop	 esi
  0000f	77 11		 ja	 SHORT $L205458
  00011	66 8b 09	 mov	 cx, WORD PTR [ecx]
  00014	8b 54 24 04	 mov	 edx, DWORD PTR _w$[esp-4]
  00018	66 89 0a	 mov	 WORD PTR [edx], cx
  0001b	83 40 08 02	 add	 DWORD PTR [eax+8], 2
  0001f	c2 04 00	 ret	 4
$L205458:
  00022	8b 4c 24 04	 mov	 ecx, DWORD PTR _w$[esp-4]
  00026	66 c7 01 00 00	 mov	 WORD PTR [ecx], 0
  0002b	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  0002e	89 50 08	 mov	 DWORD PTR [eax+8], edx
  00031	c2 04 00	 ret	 4
??5CAr@@QAEAAV0@AAG@Z ENDP				; CAr::operator>>
_TEXT	ENDS
PUBLIC	??5CAr@@QAEAAV0@AAK@Z				; CAr::operator>>
; Function compile flags: /Ogty
;	COMDAT ??5CAr@@QAEAAV0@AAK@Z
_TEXT	SEGMENT
_dw$ = 8						; size = 4
??5CAr@@QAEAAV0@AAK@Z PROC NEAR				; CAr::operator>>, COMDAT
; _this$ = ecx

; 146  : 	{	CAR_SAFE_READ( DWORD, dw );	}

  00000	8b c1		 mov	 eax, ecx
  00002	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00005	56		 push	 esi
  00006	8b 70 0c	 mov	 esi, DWORD PTR [eax+12]
  00009	8d 51 04	 lea	 edx, DWORD PTR [ecx+4]
  0000c	3b d6		 cmp	 edx, esi
  0000e	5e		 pop	 esi
  0000f	77 0f		 ja	 SHORT $L205468
  00011	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00013	8b 54 24 04	 mov	 edx, DWORD PTR _dw$[esp-4]
  00017	89 0a		 mov	 DWORD PTR [edx], ecx
  00019	83 40 08 04	 add	 DWORD PTR [eax+8], 4
  0001d	c2 04 00	 ret	 4
$L205468:
  00020	8b 4c 24 04	 mov	 ecx, DWORD PTR _dw$[esp-4]
  00024	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  0002a	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  0002d	89 50 08	 mov	 DWORD PTR [eax+8], edx
  00030	c2 04 00	 ret	 4
??5CAr@@QAEAAV0@AAK@Z ENDP				; CAr::operator>>
_TEXT	ENDS
PUBLIC	??5CAr@@QAEAAV0@AAM@Z				; CAr::operator>>
; Function compile flags: /Ogty
;	COMDAT ??5CAr@@QAEAAV0@AAM@Z
_TEXT	SEGMENT
_f$ = 8							; size = 4
??5CAr@@QAEAAV0@AAM@Z PROC NEAR				; CAr::operator>>, COMDAT
; _this$ = ecx

; 148  : 	{	CAR_SAFE_READ( float, f );	}

  00000	8b c1		 mov	 eax, ecx
  00002	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00005	56		 push	 esi
  00006	8b 70 0c	 mov	 esi, DWORD PTR [eax+12]
  00009	8d 51 04	 lea	 edx, DWORD PTR [ecx+4]
  0000c	3b d6		 cmp	 edx, esi
  0000e	5e		 pop	 esi
  0000f	77 0f		 ja	 SHORT $L205478
  00011	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00013	8b 54 24 04	 mov	 edx, DWORD PTR _f$[esp-4]
  00017	89 0a		 mov	 DWORD PTR [edx], ecx
  00019	83 40 08 04	 add	 DWORD PTR [eax+8], 4
  0001d	c2 04 00	 ret	 4
$L205478:
  00020	8b 4c 24 04	 mov	 ecx, DWORD PTR _f$[esp-4]
  00024	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  0002a	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  0002d	89 50 08	 mov	 DWORD PTR [eax+8], edx
  00030	c2 04 00	 ret	 4
??5CAr@@QAEAAV0@AAM@Z ENDP				; CAr::operator>>
_TEXT	ENDS
PUBLIC	??5CAr@@QAEAAV0@AAJ@Z				; CAr::operator>>
; Function compile flags: /Ogty
;	COMDAT ??5CAr@@QAEAAV0@AAJ@Z
_TEXT	SEGMENT
_l$ = 8							; size = 4
??5CAr@@QAEAAV0@AAJ@Z PROC NEAR				; CAr::operator>>, COMDAT
; _this$ = ecx

; 152  : 	{	CAR_SAFE_READ( LONG, l );	}

  00000	8b c1		 mov	 eax, ecx
  00002	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00005	56		 push	 esi
  00006	8b 70 0c	 mov	 esi, DWORD PTR [eax+12]
  00009	8d 51 04	 lea	 edx, DWORD PTR [ecx+4]
  0000c	3b d6		 cmp	 edx, esi
  0000e	5e		 pop	 esi
  0000f	77 0f		 ja	 SHORT $L205498
  00011	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00013	8b 54 24 04	 mov	 edx, DWORD PTR _l$[esp-4]
  00017	89 0a		 mov	 DWORD PTR [edx], ecx
  00019	83 40 08 04	 add	 DWORD PTR [eax+8], 4
  0001d	c2 04 00	 ret	 4
$L205498:
  00020	8b 4c 24 04	 mov	 ecx, DWORD PTR _l$[esp-4]
  00024	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  0002a	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  0002d	89 50 08	 mov	 DWORD PTR [eax+8], edx
  00030	c2 04 00	 ret	 4
??5CAr@@QAEAAV0@AAJ@Z ENDP				; CAr::operator>>
_TEXT	ENDS
PUBLIC	??6@YAAAVCAr@@AAV0@UD3DXVECTOR3@@@Z		; operator<<
EXTRN	?Write@CAr@@QAEXPBXI@Z:NEAR			; CAr::Write
; Function compile flags: /Ogty
;	COMDAT ??6@YAAAVCAr@@AAV0@UD3DXVECTOR3@@@Z
_TEXT	SEGMENT
_ar$ = 8						; size = 4
_v$ = 12						; size = 12
??6@YAAAVCAr@@AAV0@UD3DXVECTOR3@@@Z PROC NEAR		; operator<<, COMDAT

; 157  : 	{	ar.Write( &v, sizeof(D3DXVECTOR3) );	return ar;	}

  00000	56		 push	 esi
  00001	8b 74 24 08	 mov	 esi, DWORD PTR _ar$[esp]
  00005	6a 0c		 push	 12			; 0000000cH
  00007	8d 44 24 10	 lea	 eax, DWORD PTR _v$[esp+4]
  0000b	50		 push	 eax
  0000c	8b ce		 mov	 ecx, esi
  0000e	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
  00013	8b c6		 mov	 eax, esi
  00015	5e		 pop	 esi
  00016	c3		 ret	 0
??6@YAAAVCAr@@AAV0@UD3DXVECTOR3@@@Z ENDP		; operator<<
_TEXT	ENDS
PUBLIC	??5@YAAAVCAr@@AAV0@AAUD3DXVECTOR3@@@Z		; operator>>
EXTRN	?Read@CAr@@QAEXPAXI@Z:NEAR			; CAr::Read
; Function compile flags: /Ogty
;	COMDAT ??5@YAAAVCAr@@AAV0@AAUD3DXVECTOR3@@@Z
_TEXT	SEGMENT
_ar$ = 8						; size = 4
_v$ = 12						; size = 4
??5@YAAAVCAr@@AAV0@AAUD3DXVECTOR3@@@Z PROC NEAR		; operator>>, COMDAT

; 160  : 	{	ar.Read( &v, sizeof(D3DXVECTOR3) );		return ar;	}

  00000	8b 44 24 08	 mov	 eax, DWORD PTR _v$[esp-4]
  00004	56		 push	 esi
  00005	8b 74 24 08	 mov	 esi, DWORD PTR _ar$[esp]
  00009	6a 0c		 push	 12			; 0000000cH
  0000b	50		 push	 eax
  0000c	8b ce		 mov	 ecx, esi
  0000e	e8 00 00 00 00	 call	 ?Read@CAr@@QAEXPAXI@Z	; CAr::Read
  00013	8b c6		 mov	 eax, esi
  00015	5e		 pop	 esi
  00016	c3		 ret	 0
??5@YAAAVCAr@@AAV0@AAUD3DXVECTOR3@@@Z ENDP		; operator>>
_TEXT	ENDS
PUBLIC	??6@YAAAVCAr@@AAV0@_J@Z				; operator<<
; Function compile flags: /Ogty
;	COMDAT ??6@YAAAVCAr@@AAV0@_J@Z
_TEXT	SEGMENT
_ar$ = 8						; size = 4
_i$ = 12						; size = 8
??6@YAAAVCAr@@AAV0@_J@Z PROC NEAR			; operator<<, COMDAT

; 163  : 	{	ar.Write( &i, sizeof(__int64) );	return ar;	}

  00000	56		 push	 esi
  00001	8b 74 24 08	 mov	 esi, DWORD PTR _ar$[esp]
  00005	6a 08		 push	 8
  00007	8d 44 24 10	 lea	 eax, DWORD PTR _i$[esp+4]
  0000b	50		 push	 eax
  0000c	8b ce		 mov	 ecx, esi
  0000e	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
  00013	8b c6		 mov	 eax, esi
  00015	5e		 pop	 esi
  00016	c3		 ret	 0
??6@YAAAVCAr@@AAV0@_J@Z ENDP				; operator<<
_TEXT	ENDS
PUBLIC	??0?$pair@KPAVCUser@@@std@@QAE@ABKABQAVCUser@@@Z ; std::pair<unsigned long,CUser *>::pair<unsigned long,CUser *>
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\utility
;	COMDAT ??0?$pair@KPAVCUser@@@std@@QAE@ABKABQAVCUser@@@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$pair@KPAVCUser@@@std@@QAE@ABKABQAVCUser@@@Z PROC NEAR ; std::pair<unsigned long,CUser *>::pair<unsigned long,CUser *>, COMDAT
; _this$ = ecx

; 34   : 		{	// construct from specified values

  00000	8b c1		 mov	 eax, ecx
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Val1$[esp-4]
  00006	8b 11		 mov	 edx, DWORD PTR [ecx]
  00008	8b 4c 24 08	 mov	 ecx, DWORD PTR __Val2$[esp-4]
  0000c	89 10		 mov	 DWORD PTR [eax], edx
  0000e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00010	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 35   : 		}

  00013	c2 08 00	 ret	 8
??0?$pair@KPAVCUser@@@std@@QAE@ABKABQAVCUser@@@Z ENDP	; std::pair<unsigned long,CUser *>::pair<unsigned long,CUser *>
_TEXT	ENDS
PUBLIC	?GetOffset@CAr@@QAEKXZ				; CAr::GetOffset
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_network\misc\include\ar.h
;	COMDAT ?GetOffset@CAr@@QAEKXZ
_TEXT	SEGMENT
?GetOffset@CAr@@QAEKXZ PROC NEAR			; CAr::GetOffset, COMDAT
; _this$ = ecx

; 190  : 	ASSERT( IsStoring() );
; 191  : 	return( m_lpBufCur - m_lpBufStart );

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00003	2b 41 10	 sub	 eax, DWORD PTR [ecx+16]

; 192  : }

  00006	c3		 ret	 0
?GetOffset@CAr@@QAEKXZ ENDP				; CAr::GetOffset
_TEXT	ENDS
PUBLIC	?IsExpired@CPocket@@QAEHXZ			; CPocket::IsExpired
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\pocket.h
;	COMDAT ?IsExpired@CPocket@@QAEHXZ
_TEXT	SEGMENT
?IsExpired@CPocket@@QAEHXZ PROC NEAR			; CPocket::IsExpired, COMDAT
; _this$ = ecx

; 19   : 	BOOL	IsExpired( void )	{	return m_bExpired;	}

  00000	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]
  00003	c3		 ret	 0
?IsExpired@CPocket@@QAEHXZ ENDP				; CPocket::IsExpired
_TEXT	ENDS
PUBLIC	?IsAvailable@CPocketController@@QAEHHH@Z	; CPocketController::IsAvailable
; Function compile flags: /Ogty
;	COMDAT ?IsAvailable@CPocketController@@QAEHHH@Z
_TEXT	SEGMENT
_nPocket$ = 8						; size = 4
_bExpiration$ = 12					; size = 4
?IsAvailable@CPocketController@@QAEHHH@Z PROC NEAR	; CPocketController::IsAvailable, COMDAT
; _this$ = ecx

; 70   : 		{	return( m_apPocket[nPocket] && ( !bExpiration || !m_apPocket[nPocket]->IsExpired() ) );		}

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _nPocket$[esp-4]
  00004	8b 44 81 08	 mov	 eax, DWORD PTR [ecx+eax*4+8]
  00008	85 c0		 test	 eax, eax
  0000a	74 17		 je	 SHORT $L297151
  0000c	8b 4c 24 08	 mov	 ecx, DWORD PTR _bExpiration$[esp-4]
  00010	85 c9		 test	 ecx, ecx
  00012	74 07		 je	 SHORT $L297150
  00014	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00017	85 c9		 test	 ecx, ecx
  00019	75 08		 jne	 SHORT $L297151
$L297150:
  0001b	b8 01 00 00 00	 mov	 eax, 1
  00020	c2 08 00	 ret	 8
$L297151:
  00023	33 c0		 xor	 eax, eax
  00025	c2 08 00	 ret	 8
?IsAvailable@CPocketController@@QAEHHH@Z ENDP		; CPocketController::IsAvailable
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAKPAK@std@@YAPAKPAK00U_Scalar_ptr_iterator_tag@0@@Z ; std::_Copy_opt<unsigned long *,unsigned long *>
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xutility
;	COMDAT ??$_Copy_opt@PAKPAK@std@@YAPAKPAK00U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Copy_opt@PAKPAK@std@@YAPAKPAK00U_Scalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Copy_opt<unsigned long *,unsigned long *>, COMDAT

; 1031 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR __First$[esp-4]
  00004	8b 44 24 08	 mov	 eax, DWORD PTR __Last$[esp-4]
  00008	2b c1		 sub	 eax, ecx
  0000a	56		 push	 esi
  0000b	c1 f8 02	 sar	 eax, 2

; 1032 : 	return ((_OutIt)::memmove(&*_Dest, &*_First,
; 1033 : 		_Off * sizeof (*_First)) + _Off);

  0000e	8d 34 85 00 00
	00 00		 lea	 esi, DWORD PTR [eax*4]
  00015	8b 44 24 10	 mov	 eax, DWORD PTR __Dest$[esp]
  00019	56		 push	 esi
  0001a	51		 push	 ecx
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 _memmove
  00021	83 c4 0c	 add	 esp, 12			; 0000000cH
  00024	03 c6		 add	 eax, esi
  00026	5e		 pop	 esi

; 1034 : 	}

  00027	c3		 ret	 0
??$_Copy_opt@PAKPAK@std@@YAPAKPAK00U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Copy_opt<unsigned long *,unsigned long *>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::_Ptr_cat<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
; Function compile flags: /Ogty
;	COMDAT ??$_Ptr_cat@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z PROC NEAR ; std::_Ptr_cat<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>, COMDAT

; 211  : 	{	// return pointer category from arbitrary arguments

  00000	51		 push	 ecx

; 212  : 	_Nonscalar_ptr_iterator_tag _Cat;
; 213  : 	return (_Cat);

  00001	8a 44 24 03	 mov	 al, BYTE PTR __Cat$[esp+4]

; 214  : 	}

  00005	59		 pop	 ecx
  00006	c3		 ret	 0
??$_Ptr_cat@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ENDP ; std::_Ptr_cat<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAU__ITEMINFO@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU__ITEMINFO@@0@Z ; std::_Ptr_cat<__ITEMINFO *,__ITEMINFO *>
; Function compile flags: /Ogty
;	COMDAT ??$_Ptr_cat@PAU__ITEMINFO@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU__ITEMINFO@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAU__ITEMINFO@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU__ITEMINFO@@0@Z PROC NEAR ; std::_Ptr_cat<__ITEMINFO *,__ITEMINFO *>, COMDAT

; 211  : 	{	// return pointer category from arbitrary arguments

  00000	51		 push	 ecx

; 212  : 	_Nonscalar_ptr_iterator_tag _Cat;
; 213  : 	return (_Cat);

  00001	8a 44 24 03	 mov	 al, BYTE PTR __Cat$[esp+4]

; 214  : 	}

  00005	59		 pop	 ecx
  00006	c3		 ret	 0
??$_Ptr_cat@PAU__ITEMINFO@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU__ITEMINFO@@0@Z ENDP ; std::_Ptr_cat<__ITEMINFO *,__ITEMINFO *>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAKPAK@std@@YAPAKPAK00U_Scalar_ptr_iterator_tag@0@@Z ; std::_Copy_backward_opt<unsigned long *,unsigned long *>
; Function compile flags: /Ogty
;	COMDAT ??$_Copy_backward_opt@PAKPAK@std@@YAPAKPAK00U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Copy_backward_opt@PAKPAK@std@@YAPAKPAK00U_Scalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Copy_backward_opt<unsigned long *,unsigned long *>, COMDAT

; 1059 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR __First$[esp-4]
  00004	8b 44 24 08	 mov	 eax, DWORD PTR __Last$[esp-4]
  00008	2b c1		 sub	 eax, ecx
  0000a	c1 f8 02	 sar	 eax, 2

; 1060 : 	return ((_OutIt)memmove(&*_Dest - _Off, &*_First,
; 1061 : 		_Off * sizeof (*_First)));

  0000d	c1 e0 02	 shl	 eax, 2
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	8b 4c 24 14	 mov	 ecx, DWORD PTR __Dest$[esp+4]
  00016	2b c8		 sub	 ecx, eax
  00018	51		 push	 ecx
  00019	e8 00 00 00 00	 call	 _memmove
  0001e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1062 : 	}

  00021	c3		 ret	 0
??$_Copy_backward_opt@PAKPAK@std@@YAPAKPAK00U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<unsigned long *,unsigned long *>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAU__REQUESTGUILD@CGuildCombat@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU__REQUESTGUILD@CGuildCombat@@0@Z ; std::_Ptr_cat<CGuildCombat::__REQUESTGUILD *,CGuildCombat::__REQUESTGUILD *>
; Function compile flags: /Ogty
;	COMDAT ??$_Ptr_cat@PAU__REQUESTGUILD@CGuildCombat@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU__REQUESTGUILD@CGuildCombat@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAU__REQUESTGUILD@CGuildCombat@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU__REQUESTGUILD@CGuildCombat@@0@Z PROC NEAR ; std::_Ptr_cat<CGuildCombat::__REQUESTGUILD *,CGuildCombat::__REQUESTGUILD *>, COMDAT

; 211  : 	{	// return pointer category from arbitrary arguments

  00000	51		 push	 ecx

; 212  : 	_Nonscalar_ptr_iterator_tag _Cat;
; 213  : 	return (_Cat);

  00001	8a 44 24 03	 mov	 al, BYTE PTR __Cat$[esp+4]

; 214  : 	}

  00005	59		 pop	 ecx
  00006	c3		 ret	 0
??$_Ptr_cat@PAU__REQUESTGUILD@CGuildCombat@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU__REQUESTGUILD@CGuildCombat@@0@Z ENDP ; std::_Ptr_cat<CGuildCombat::__REQUESTGUILD *,CGuildCombat::__REQUESTGUILD *>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAU__ITEMINFO@@PAU1@@std@@YAPAU__ITEMINFO@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Copy_backward_opt<__ITEMINFO *,__ITEMINFO *>
; Function compile flags: /Ogty
;	COMDAT ??$_Copy_backward_opt@PAU__ITEMINFO@@PAU1@@std@@YAPAU__ITEMINFO@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Copy_backward_opt@PAU__ITEMINFO@@PAU1@@std@@YAPAU__ITEMINFO@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Copy_backward_opt<__ITEMINFO *,__ITEMINFO *>, COMDAT

; 1049 : 	while (_First != _Last)

  00000	8b 54 24 04	 mov	 edx, DWORD PTR __First$[esp-4]
  00004	8b 4c 24 08	 mov	 ecx, DWORD PTR __Last$[esp-4]
  00008	3b d1		 cmp	 edx, ecx
  0000a	8b 44 24 0c	 mov	 eax, DWORD PTR __Dest$[esp-4]
  0000e	74 24		 je	 SHORT $L293441
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi
$L293440:

; 1050 : 		*--_Dest = *--_Last;

  00013	83 e9 0c	 sub	 ecx, 12			; 0000000cH
  00016	83 e8 0c	 sub	 eax, 12			; 0000000cH
  00019	3b ca		 cmp	 ecx, edx
  0001b	8b f1		 mov	 esi, ecx
  0001d	8b 1e		 mov	 ebx, DWORD PTR [esi]
  0001f	8b f8		 mov	 edi, eax
  00021	89 1f		 mov	 DWORD PTR [edi], ebx
  00023	8b 5e 04	 mov	 ebx, DWORD PTR [esi+4]
  00026	89 5f 04	 mov	 DWORD PTR [edi+4], ebx
  00029	8b 76 08	 mov	 esi, DWORD PTR [esi+8]
  0002c	89 77 08	 mov	 DWORD PTR [edi+8], esi
  0002f	75 e2		 jne	 SHORT $L293440
  00031	5f		 pop	 edi
  00032	5e		 pop	 esi
  00033	5b		 pop	 ebx
$L293441:

; 1051 : 	return (_Dest);
; 1052 : 	}

  00034	c3		 ret	 0
??$_Copy_backward_opt@PAU__ITEMINFO@@PAU1@@std@@YAPAU__ITEMINFO@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<__ITEMINFO *,__ITEMINFO *>
_TEXT	ENDS
PUBLIC	?GetState@CAction@@QAEKXZ			; CAction::GetState
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_aiinterface\action.h
;	COMDAT ?GetState@CAction@@QAEKXZ
_TEXT	SEGMENT
?GetState@CAction@@QAEKXZ PROC NEAR			; CAction::GetState, COMDAT
; _this$ = ecx

; 291  : 	DWORD			GetState() { return m_dwState; }

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	c3		 ret	 0
?GetState@CAction@@QAEKXZ ENDP				; CAction::GetState
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@KK@std@@YAPAKPAK00AAV?$allocator@K@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<unsigned long,unsigned long>
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\memory
;	COMDAT ??$_Uninit_copy@KK@std@@YAPAKPAK00AAV?$allocator@K@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
??$_Uninit_copy@KK@std@@YAPAKPAK00AAV?$allocator@K@0@U_Scalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Uninit_copy<unsigned long,unsigned long>, COMDAT

; 106  : 	size_t _Count = (size_t)(_Last - _First);

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR __First$[esp-4]
  00004	8b 44 24 08	 mov	 eax, DWORD PTR __Last$[esp-4]
  00008	2b c1		 sub	 eax, ecx
  0000a	56		 push	 esi
  0000b	c1 f8 02	 sar	 eax, 2

; 107  : 	return ((_Ty2 *)memmove(&*_Dest, &*_First,
; 108  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  0000e	8d 34 85 00 00
	00 00		 lea	 esi, DWORD PTR [eax*4]
  00015	8b 44 24 10	 mov	 eax, DWORD PTR __Dest$[esp]
  00019	56		 push	 esi
  0001a	51		 push	 ecx
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 _memmove
  00021	83 c4 0c	 add	 esp, 12			; 0000000cH
  00024	03 c6		 add	 eax, esi
  00026	5e		 pop	 esi

; 109  : 	}

  00027	c3		 ret	 0
??$_Uninit_copy@KK@std@@YAPAKPAK00AAV?$allocator@K@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<unsigned long,unsigned long>
_TEXT	ENDS
PUBLIC	??$fill_n@PAKIK@std@@YAXPAKIABK@Z		; std::fill_n<unsigned long *,unsigned int,unsigned long>
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xutility
;	COMDAT ??$fill_n@PAKIK@std@@YAXPAKIABK@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill_n@PAKIK@std@@YAXPAKIABK@Z PROC NEAR		; std::fill_n<unsigned long *,unsigned int,unsigned long>, COMDAT

; 1160 : 	for (; 0 < _Count; --_Count, ++_First)

  00000	8b 4c 24 08	 mov	 ecx, DWORD PTR __Count$[esp-4]
  00004	85 c9		 test	 ecx, ecx
  00006	76 14		 jbe	 SHORT $L293608
  00008	8b 54 24 0c	 mov	 edx, DWORD PTR __Val$[esp-4]
  0000c	8b 44 24 04	 mov	 eax, DWORD PTR __First$[esp-4]
  00010	56		 push	 esi
$L293606:

; 1161 : 		*_First = _Val;

  00011	8b 32		 mov	 esi, DWORD PTR [edx]
  00013	89 30		 mov	 DWORD PTR [eax], esi
  00015	83 c0 04	 add	 eax, 4
  00018	49		 dec	 ecx
  00019	75 f6		 jne	 SHORT $L293606
  0001b	5e		 pop	 esi
$L293608:

; 1162 : 	}

  0001c	c3		 ret	 0
??$fill_n@PAKIK@std@@YAXPAKIABK@Z ENDP			; std::fill_n<unsigned long *,unsigned int,unsigned long>
_TEXT	ENDS
PUBLIC	?GetActionState@CAction@@QAEKXZ			; CAction::GetActionState
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_aiinterface\action.h
;	COMDAT ?GetActionState@CAction@@QAEKXZ
_TEXT	SEGMENT
?GetActionState@CAction@@QAEKXZ PROC NEAR		; CAction::GetActionState, COMDAT
; _this$ = ecx

; 305  : 	DWORD			GetActionState() { return m_dwState & OBJSTA_ACTION_ALL; }

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	25 00 00 00 f0	 and	 eax, -268435456		; f0000000H
  00008	c3		 ret	 0
?GetActionState@CAction@@QAEKXZ ENDP			; CAction::GetActionState
_TEXT	ENDS
PUBLIC	?IsStateFlag@CAction@@QAEHK@Z			; CAction::IsStateFlag
; Function compile flags: /Ogty
;	COMDAT ?IsStateFlag@CAction@@QAEHK@Z
_TEXT	SEGMENT
_dwStateFlag$ = 8					; size = 4
?IsStateFlag@CAction@@QAEHK@Z PROC NEAR			; CAction::IsStateFlag, COMDAT
; _this$ = ecx

; 308  : 	BOOL			IsStateFlag( DWORD dwStateFlag ) { return ( m_dwStateFlag & dwStateFlag ) ? TRUE : FALSE; }

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00003	23 44 24 04	 and	 eax, DWORD PTR _dwStateFlag$[esp-4]
  00007	f7 d8		 neg	 eax
  00009	1b c0		 sbb	 eax, eax
  0000b	f7 d8		 neg	 eax
  0000d	c2 04 00	 ret	 4
?IsStateFlag@CAction@@QAEHK@Z ENDP			; CAction::IsStateFlag
_TEXT	ENDS
PUBLIC	?IsFly@CAction@@QAEHXZ				; CAction::IsFly
; Function compile flags: /Ogty
;	COMDAT ?IsFly@CAction@@QAEHXZ
_TEXT	SEGMENT
?IsFly@CAction@@QAEHXZ PROC NEAR			; CAction::IsFly, COMDAT
; _this$ = ecx

; 309  : 	BOOL			IsFly() { return (m_dwStateFlag & OBJSTAF_FLY) ? TRUE : FALSE; }

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00003	c1 e8 03	 shr	 eax, 3
  00006	83 e0 01	 and	 eax, 1
  00009	c3		 ret	 0
?IsFly@CAction@@QAEHXZ ENDP				; CAction::IsFly
_TEXT	ENDS
PUBLIC	?IsDie@CAction@@QAEHXZ				; CAction::IsDie
; Function compile flags: /Ogty
;	COMDAT ?IsDie@CAction@@QAEHXZ
_TEXT	SEGMENT
?IsDie@CAction@@QAEHXZ PROC NEAR			; CAction::IsDie, COMDAT
; _this$ = ecx

; 310  : 	BOOL			IsDie() { return (m_dwState & OBJSTA_DIE_ALL) ? TRUE : FALSE; }

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	c1 e8 1b	 shr	 eax, 27			; 0000001bH
  00006	83 e0 01	 and	 eax, 1
  00009	c3		 ret	 0
?IsDie@CAction@@QAEHXZ ENDP				; CAction::IsDie
_TEXT	ENDS
PUBLIC	??$_Destroy@U__REQUESTGUILD@CGuildCombat@@@std@@YAXPAU__REQUESTGUILD@CGuildCombat@@@Z ; std::_Destroy<CGuildCombat::__REQUESTGUILD>
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??$_Destroy@U__REQUESTGUILD@CGuildCombat@@@std@@YAXPAU__REQUESTGUILD@CGuildCombat@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@U__REQUESTGUILD@CGuildCombat@@@std@@YAXPAU__REQUESTGUILD@CGuildCombat@@@Z PROC NEAR ; std::_Destroy<CGuildCombat::__REQUESTGUILD>, COMDAT

; 49   : 	_DESTRUCTOR(_Ty, _Ptr);
; 50   : 	}

  00000	c3		 ret	 0
??$_Destroy@U__REQUESTGUILD@CGuildCombat@@@std@@YAXPAU__REQUESTGUILD@CGuildCombat@@@Z ENDP ; std::_Destroy<CGuildCombat::__REQUESTGUILD>
_TEXT	ENDS
PUBLIC	??$_Construct@U__ITEMINFO@@U1@@std@@YAXPAU__ITEMINFO@@ABU1@@Z ; std::_Construct<__ITEMINFO,__ITEMINFO>
; Function compile flags: /Ogty
;	COMDAT ??$_Construct@U__ITEMINFO@@U1@@std@@YAXPAU__ITEMINFO@@ABU1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@U__ITEMINFO@@U1@@std@@YAXPAU__ITEMINFO@@ABU1@@Z PROC NEAR ; std::_Construct<__ITEMINFO,__ITEMINFO>, COMDAT

; 42   : 	new ((void _FARQ *)_Ptr) _T1(_Val);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Ptr$[esp-4]
  00004	85 c0		 test	 eax, eax
  00006	74 14		 je	 SHORT $L297208
  00008	8b 4c 24 08	 mov	 ecx, DWORD PTR __Val$[esp-4]
  0000c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000e	89 10		 mov	 DWORD PTR [eax], edx
  00010	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00013	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00016	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  00019	89 48 08	 mov	 DWORD PTR [eax+8], ecx
$L297208:

; 43   : 	}

  0001c	c3		 ret	 0
??$_Construct@U__ITEMINFO@@U1@@std@@YAXPAU__ITEMINFO@@ABU1@@Z ENDP ; std::_Construct<__ITEMINFO,__ITEMINFO>
_TEXT	ENDS
PUBLIC	??$_Destroy@U__ITEMINFO@@@std@@YAXPAU__ITEMINFO@@@Z ; std::_Destroy<__ITEMINFO>
; Function compile flags: /Ogty
;	COMDAT ??$_Destroy@U__ITEMINFO@@@std@@YAXPAU__ITEMINFO@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@U__ITEMINFO@@@std@@YAXPAU__ITEMINFO@@@Z PROC NEAR ; std::_Destroy<__ITEMINFO>, COMDAT

; 49   : 	_DESTRUCTOR(_Ty, _Ptr);
; 50   : 	}

  00000	c3		 ret	 0
??$_Destroy@U__ITEMINFO@@@std@@YAXPAU__ITEMINFO@@@Z ENDP ; std::_Destroy<__ITEMINFO>
_TEXT	ENDS
PUBLIC	?GetOtherID@CVTInfo@@QAEKXZ			; CVTInfo::GetOtherID
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\mover.h
;	COMDAT ?GetOtherID@CVTInfo@@QAEKXZ
_TEXT	SEGMENT
?GetOtherID@CVTInfo@@QAEKXZ PROC NEAR			; CVTInfo::GetOtherID, COMDAT
; _this$ = ecx

; 373  : 	OBJID					GetOtherID() { return m_objId; }

  00000	8b 41 7c	 mov	 eax, DWORD PTR [ecx+124]
  00003	c3		 ret	 0
?GetOtherID@CVTInfo@@QAEKXZ ENDP			; CVTInfo::GetOtherID
_TEXT	ENDS
PUBLIC	?GetTutorialState@CMover@@QAEHXZ		; CMover::GetTutorialState
; Function compile flags: /Ogty
;	COMDAT ?GetTutorialState@CMover@@QAEHXZ
_TEXT	SEGMENT
?GetTutorialState@CMover@@QAEHXZ PROC NEAR		; CMover::GetTutorialState, COMDAT
; _this$ = ecx

; 559  : 	int		GetTutorialState( void )	{	return m_nTutorialState;	}

  00000	8b 81 f8 05 00
	00		 mov	 eax, DWORD PTR [ecx+1528]
  00006	c3		 ret	 0
?GetTutorialState@CMover@@QAEHXZ ENDP			; CMover::GetTutorialState
_TEXT	ENDS
PUBLIC	?HasActivatedEatPet@CMover@@QAEHXZ		; CMover::HasActivatedEatPet
; Function compile flags: /Ogty
;	COMDAT ?HasActivatedEatPet@CMover@@QAEHXZ
_TEXT	SEGMENT
?HasActivatedEatPet@CMover@@QAEHXZ PROC NEAR		; CMover::HasActivatedEatPet, COMDAT
; _this$ = ecx

; 827  : 	BOOL	HasActivatedEatPet( void )		{	return m_oiEatPet != NULL_ID;	}

  00000	8b 91 7c 06 00
	00		 mov	 edx, DWORD PTR [ecx+1660]
  00006	33 c0		 xor	 eax, eax
  00008	83 fa ff	 cmp	 edx, -1
  0000b	0f 95 c0	 setne	 al
  0000e	c3		 ret	 0
?HasActivatedEatPet@CMover@@QAEHXZ ENDP			; CMover::HasActivatedEatPet
_TEXT	ENDS
PUBLIC	?GetEatPetId@CMover@@QAEKXZ			; CMover::GetEatPetId
; Function compile flags: /Ogty
;	COMDAT ?GetEatPetId@CMover@@QAEKXZ
_TEXT	SEGMENT
?GetEatPetId@CMover@@QAEKXZ PROC NEAR			; CMover::GetEatPetId, COMDAT
; _this$ = ecx

; 829  : 	OBJID	GetEatPetId( void )		{	return m_oiEatPet;		}

  00000	8b 81 7c 06 00
	00		 mov	 eax, DWORD PTR [ecx+1660]
  00006	c3		 ret	 0
?GetEatPetId@CMover@@QAEKXZ ENDP			; CMover::GetEatPetId
_TEXT	ENDS
PUBLIC	?IsCollecting@CMover@@QAEHXZ			; CMover::IsCollecting
; Function compile flags: /Ogty
;	COMDAT ?IsCollecting@CMover@@QAEHXZ
_TEXT	SEGMENT
?IsCollecting@CMover@@QAEHXZ PROC NEAR			; CMover::IsCollecting, COMDAT
; _this$ = ecx

; 887  : 	BOOL	IsCollecting( void )	{	return	m_pActMover->GetActionState() == OBJSTA_COLLECT;	}

  00000	8b 81 3c 02 00
	00		 mov	 eax, DWORD PTR [ecx+572]
  00006	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00009	25 00 00 00 f0	 and	 eax, -268435456		; f0000000H
  0000e	2d 00 00 00 10	 sub	 eax, 268435456		; 10000000H
  00013	f7 d8		 neg	 eax
  00015	1b c0		 sbb	 eax, eax
  00017	40		 inc	 eax
  00018	c3		 ret	 0
?IsCollecting@CMover@@QAEHXZ ENDP			; CMover::IsCollecting
_TEXT	ENDS
PUBLIC	?GetCampusId@CMover@@QAEKXZ			; CMover::GetCampusId
; Function compile flags: /Ogty
;	COMDAT ?GetCampusId@CMover@@QAEKXZ
_TEXT	SEGMENT
?GetCampusId@CMover@@QAEKXZ PROC NEAR			; CMover::GetCampusId, COMDAT
; _this$ = ecx

; 961  : 	u_long	GetCampusId()		{	return m_idCampus;	}

  00000	8b 81 70 16 00
	00		 mov	 eax, DWORD PTR [ecx+5744]
  00006	c3		 ret	 0
?GetCampusId@CMover@@QAEKXZ ENDP			; CMover::GetCampusId
_TEXT	ENDS
PUBLIC	?GetCampusPoint@CMover@@QAEHXZ			; CMover::GetCampusPoint
; Function compile flags: /Ogty
;	COMDAT ?GetCampusPoint@CMover@@QAEHXZ
_TEXT	SEGMENT
?GetCampusPoint@CMover@@QAEHXZ PROC NEAR		; CMover::GetCampusPoint, COMDAT
; _this$ = ecx

; 963  : 	int		GetCampusPoint()	{	return m_nCampusPoint;	}

  00000	8b 81 74 16 00
	00		 mov	 eax, DWORD PTR [ecx+5748]
  00006	c3		 ret	 0
?GetCampusPoint@CMover@@QAEHXZ ENDP			; CMover::GetCampusPoint
_TEXT	ENDS
PUBLIC	?SetMode@CMover@@QAEXK@Z			; CMover::SetMode
; Function compile flags: /Ogty
;	COMDAT ?SetMode@CMover@@QAEXK@Z
_TEXT	SEGMENT
_dwMode$ = 8						; size = 4
?SetMode@CMover@@QAEXK@Z PROC NEAR			; CMover::SetMode, COMDAT
; _this$ = ecx

; 1027 : 	void			SetMode( DWORD dwMode )		{ m_dwMode |= dwMode; }	//  V

  00000	8b 91 44 02 00
	00		 mov	 edx, DWORD PTR [ecx+580]
  00006	8b 44 24 04	 mov	 eax, DWORD PTR _dwMode$[esp-4]
  0000a	0b d0		 or	 edx, eax
  0000c	89 91 44 02 00
	00		 mov	 DWORD PTR [ecx+580], edx
  00012	c2 04 00	 ret	 4
?SetMode@CMover@@QAEXK@Z ENDP				; CMover::SetMode
_TEXT	ENDS
PUBLIC	?SetNotMode@CMover@@QAEXK@Z			; CMover::SetNotMode
; Function compile flags: /Ogty
;	COMDAT ?SetNotMode@CMover@@QAEXK@Z
_TEXT	SEGMENT
_dwMode$ = 8						; size = 4
?SetNotMode@CMover@@QAEXK@Z PROC NEAR			; CMover::SetNotMode, COMDAT
; _this$ = ecx

; 1028 : 	void			SetNotMode( DWORD dwMode )	{ m_dwMode &= (~dwMode); } //  V

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _dwMode$[esp-4]
  00004	8b 91 44 02 00
	00		 mov	 edx, DWORD PTR [ecx+580]
  0000a	f7 d0		 not	 eax
  0000c	23 d0		 and	 edx, eax
  0000e	89 91 44 02 00
	00		 mov	 DWORD PTR [ecx+580], edx
  00014	c2 04 00	 ret	 4
?SetNotMode@CMover@@QAEXK@Z ENDP			; CMover::SetNotMode
_TEXT	ENDS
PUBLIC	?IsPlayer@CMover@@QAEHXZ			; CMover::IsPlayer
; Function compile flags: /Ogty
;	COMDAT ?IsPlayer@CMover@@QAEHXZ
_TEXT	SEGMENT
?IsPlayer@CMover@@QAEHXZ PROC NEAR			; CMover::IsPlayer, COMDAT
; _this$ = ecx

; 1042 : 	BOOL			IsPlayer()			{ return m_bPlayer; }

  00000	8b 81 34 02 00
	00		 mov	 eax, DWORD PTR [ecx+564]
  00006	c3		 ret	 0
?IsPlayer@CMover@@QAEHXZ ENDP				; CMover::IsPlayer
_TEXT	ENDS
PUBLIC	?ClearDestObj@CMover@@QAEXXZ			; CMover::ClearDestObj
; Function compile flags: /Ogty
;	COMDAT ?ClearDestObj@CMover@@QAEXXZ
_TEXT	SEGMENT
?ClearDestObj@CMover@@QAEXXZ PROC NEAR			; CMover::ClearDestObj, COMDAT
; _this$ = ecx

; 1056 : 	void			ClearDestObj()     	{ m_idDest = NULL_ID; m_fArrivalRange = 0.0f; }

  00000	c7 81 5c 02 00
	00 ff ff ff ff	 mov	 DWORD PTR [ecx+604], -1
  0000a	c7 81 58 02 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+600], 0
  00014	c3		 ret	 0
?ClearDestObj@CMover@@QAEXXZ ENDP			; CMover::ClearDestObj
_TEXT	ENDS
PUBLIC	?ClearDestPos@CMover@@QAEXXZ			; CMover::ClearDestPos
; Function compile flags: /Ogty
;	COMDAT ?ClearDestPos@CMover@@QAEXXZ
_TEXT	SEGMENT
$T297255 = -12						; size = 12
?ClearDestPos@CMover@@QAEXXZ PROC NEAR			; CMover::ClearDestPos, COMDAT
; _this$ = ecx

; 1057 : 	void			ClearDestPos()		{ m_vDestPos = D3DXVECTOR3( 0.0f, 0.0f, 0.0f ); }		

  00000	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00003	c7 04 24 00 00
	00 00		 mov	 DWORD PTR $T297255[esp+12], 0
  0000a	8b 04 24	 mov	 eax, DWORD PTR $T297255[esp+12]
  0000d	81 c1 60 02 00
	00		 add	 ecx, 608		; 00000260H
  00013	89 01		 mov	 DWORD PTR [ecx], eax
  00015	c7 44 24 04 00
	00 00 00	 mov	 DWORD PTR $T297255[esp+16], 0
  0001d	8b 54 24 04	 mov	 edx, DWORD PTR $T297255[esp+16]
  00021	c7 44 24 08 00
	00 00 00	 mov	 DWORD PTR $T297255[esp+20], 0
  00029	8b 44 24 08	 mov	 eax, DWORD PTR $T297255[esp+20]
  0002d	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  00030	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  00033	83 c4 0c	 add	 esp, 12			; 0000000cH
  00036	c3		 ret	 0
?ClearDestPos@CMover@@QAEXXZ ENDP			; CMover::ClearDestPos
_TEXT	ENDS
PUBLIC	?ClearDest@CMover@@QAEXXZ			; CMover::ClearDest
; Function compile flags: /Ogty
;	COMDAT ?ClearDest@CMover@@QAEXXZ
_TEXT	SEGMENT
$T297273 = -12						; size = 12
?ClearDest@CMover@@QAEXXZ PROC NEAR			; CMover::ClearDest, COMDAT
; _this$ = ecx

; 1058 : 	void			ClearDest()			{ ClearDestObj(); ClearDestPos(); }

  00000	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00003	c7 81 5c 02 00
	00 ff ff ff ff	 mov	 DWORD PTR [ecx+604], -1
  0000d	c7 81 58 02 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+600], 0
  00017	c7 04 24 00 00
	00 00		 mov	 DWORD PTR $T297273[esp+12], 0
  0001e	8b 04 24	 mov	 eax, DWORD PTR $T297273[esp+12]
  00021	81 c1 60 02 00
	00		 add	 ecx, 608		; 00000260H
  00027	89 01		 mov	 DWORD PTR [ecx], eax
  00029	c7 44 24 04 00
	00 00 00	 mov	 DWORD PTR $T297273[esp+16], 0
  00031	8b 54 24 04	 mov	 edx, DWORD PTR $T297273[esp+16]
  00035	c7 44 24 08 00
	00 00 00	 mov	 DWORD PTR $T297273[esp+20], 0
  0003d	8b 44 24 08	 mov	 eax, DWORD PTR $T297273[esp+20]
  00041	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  00044	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  00047	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004a	c3		 ret	 0
?ClearDest@CMover@@QAEXXZ ENDP				; CMover::ClearDest
_TEXT	ENDS
PUBLIC	?ClearDestAngle@CMover@@QAEXXZ			; CMover::ClearDestAngle
; Function compile flags: /Ogty
;	COMDAT ?ClearDestAngle@CMover@@QAEXXZ
_TEXT	SEGMENT
?ClearDestAngle@CMover@@QAEXXZ PROC NEAR		; CMover::ClearDestAngle, COMDAT
; _this$ = ecx

; 1065 : 	void			ClearDestAngle()	{ m_fDestAngle	= -1.0f; }

  00000	c7 81 6c 02 00
	00 00 00 80 bf	 mov	 DWORD PTR [ecx+620], -1082130432 ; bf800000H
  0000a	c3		 ret	 0
?ClearDestAngle@CMover@@QAEXXZ ENDP			; CMover::ClearDestAngle
_TEXT	ENDS
PUBLIC	?IsRegionAttr@CMover@@QAEHK@Z			; CMover::IsRegionAttr
; Function compile flags: /Ogty
;	COMDAT ?IsRegionAttr@CMover@@QAEHK@Z
_TEXT	SEGMENT
_dwAttribite$ = 8					; size = 4
?IsRegionAttr@CMover@@QAEHK@Z PROC NEAR			; CMover::IsRegionAttr, COMDAT
; _this$ = ecx

; 1066 : 	BOOL			IsRegionAttr( DWORD dwAttribite ) { return ( m_dwRegionAttr & dwAttribite ) == dwAttribite ? TRUE : FALSE; }

  00000	8b 81 d4 02 00
	00		 mov	 eax, DWORD PTR [ecx+724]
  00006	8b 4c 24 04	 mov	 ecx, DWORD PTR _dwAttribite$[esp-4]
  0000a	23 c1		 and	 eax, ecx
  0000c	2b c1		 sub	 eax, ecx
  0000e	f7 d8		 neg	 eax
  00010	1b c0		 sbb	 eax, eax
  00012	40		 inc	 eax
  00013	c2 04 00	 ret	 4
?IsRegionAttr@CMover@@QAEHK@Z ENDP			; CMover::IsRegionAttr
_TEXT	ENDS
PUBLIC	?IsAuthHigher@CMover@@QAEKK@Z			; CMover::IsAuthHigher
; Function compile flags: /Ogty
;	COMDAT ?IsAuthHigher@CMover@@QAEKK@Z
_TEXT	SEGMENT
_dwAuthorization$ = 8					; size = 4
?IsAuthHigher@CMover@@QAEKK@Z PROC NEAR			; CMover::IsAuthHigher, COMDAT
; _this$ = ecx

; 1116 : 	DWORD			IsAuthHigher( DWORD dwAuthorization ) { return dwAuthorization <= m_dwAuthorization; }

  00000	8b 81 48 06 00
	00		 mov	 eax, DWORD PTR [ecx+1608]
  00006	3b 44 24 04	 cmp	 eax, DWORD PTR _dwAuthorization$[esp-4]
  0000a	1b c0		 sbb	 eax, eax
  0000c	40		 inc	 eax
  0000d	c2 04 00	 ret	 4
?IsAuthHigher@CMover@@QAEKK@Z ENDP			; CMover::IsAuthHigher
_TEXT	ENDS
PUBLIC	?GetSex@CMover@@QAEEXZ				; CMover::GetSex
; Function compile flags: /Ogty
;	COMDAT ?GetSex@CMover@@QAEEXZ
_TEXT	SEGMENT
?GetSex@CMover@@QAEEXZ PROC NEAR			; CMover::GetSex, COMDAT
; _this$ = ecx

; 1144 : 	BYTE			GetSex() { return m_bySex; }

  00000	8a 81 20 06 00
	00		 mov	 al, BYTE PTR [ecx+1568]
  00006	c3		 ret	 0
?GetSex@CMover@@QAEEXZ ENDP				; CMover::GetSex
_TEXT	ENDS
PUBLIC	?GetLevel@CMover@@QAEHXZ			; CMover::GetLevel
; Function compile flags: /Ogty
;	COMDAT ?GetLevel@CMover@@QAEHXZ
_TEXT	SEGMENT
?GetLevel@CMover@@QAEHXZ PROC NEAR			; CMover::GetLevel, COMDAT
; _this$ = ecx

; 1159 : 	int				GetLevel() { return m_nLevel; }

  00000	8b 81 e0 05 00
	00		 mov	 eax, DWORD PTR [ecx+1504]
  00006	c3		 ret	 0
?GetLevel@CMover@@QAEHXZ ENDP				; CMover::GetLevel
_TEXT	ENDS
PUBLIC	?GetExp1@CMover@@QAE_JXZ			; CMover::GetExp1
; Function compile flags: /Ogty
;	COMDAT ?GetExp1@CMover@@QAE_JXZ
_TEXT	SEGMENT
?GetExp1@CMover@@QAE_JXZ PROC NEAR			; CMover::GetExp1, COMDAT
; _this$ = ecx

; 1162 : 	EXPINTEGER		GetExp1()	{	return m_nExp1;	}

  00000	8b 81 e8 05 00
	00		 mov	 eax, DWORD PTR [ecx+1512]
  00006	8b 91 ec 05 00
	00		 mov	 edx, DWORD PTR [ecx+1516]
  0000c	c3		 ret	 0
?GetExp1@CMover@@QAE_JXZ ENDP				; CMover::GetExp1
_TEXT	ENDS
PUBLIC	?GetMaxExp1@CMover@@QAE_JXZ			; CMover::GetMaxExp1
EXTRN	?prj@@3VCProject@@A:BYTE			; prj
; Function compile flags: /Ogty
;	COMDAT ?GetMaxExp1@CMover@@QAE_JXZ
_TEXT	SEGMENT
?GetMaxExp1@CMover@@QAE_JXZ PROC NEAR			; CMover::GetMaxExp1, COMDAT
; _this$ = ecx

; 1163 : 	EXPINTEGER		GetMaxExp1()	{	return prj.m_aExpCharacter[m_nLevel+1].nExp1;	}

  00000	8b 89 e0 05 00
	00		 mov	 ecx, DWORD PTR [ecx+1504]
  00006	c1 e1 05	 shl	 ecx, 5
  00009	8b 81 10 50 00
	00		 mov	 eax, DWORD PTR ?prj@@3VCProject@@A[ecx+20496]
  0000f	8b 91 14 50 00
	00		 mov	 edx, DWORD PTR ?prj@@3VCProject@@A[ecx+20500]
  00015	c3		 ret	 0
?GetMaxExp1@CMover@@QAE_JXZ ENDP			; CMover::GetMaxExp1
_TEXT	ENDS
PUBLIC	?IsDie@CMover@@QAEHXZ				; CMover::IsDie
; Function compile flags: /Ogty
;	COMDAT ?IsDie@CMover@@QAEHXZ
_TEXT	SEGMENT
?IsDie@CMover@@QAEHXZ PROC NEAR				; CMover::IsDie, COMDAT
; _this$ = ecx

; 1276 : 	BOOL			IsDie() { return m_pActMover->IsDie() || m_nHitPoint == 0; }

  00000	8b 81 3c 02 00
	00		 mov	 eax, DWORD PTR [ecx+572]
  00006	f7 40 04 00 00
	00 08		 test	 DWORD PTR [eax+4], 134217728 ; 08000000H
  0000d	75 0d		 jne	 SHORT $L297301
  0000f	8b 81 00 06 00
	00		 mov	 eax, DWORD PTR [ecx+1536]
  00015	85 c0		 test	 eax, eax
  00017	74 03		 je	 SHORT $L297301
  00019	33 c0		 xor	 eax, eax
  0001b	c3		 ret	 0
$L297301:
  0001c	b8 01 00 00 00	 mov	 eax, 1
  00021	c3		 ret	 0
?IsDie@CMover@@QAEHXZ ENDP				; CMover::IsDie
_TEXT	ENDS
PUBLIC	?IsLive@CMover@@QAEHXZ				; CMover::IsLive
; Function compile flags: /Ogty
;	COMDAT ?IsLive@CMover@@QAEHXZ
_TEXT	SEGMENT
?IsLive@CMover@@QAEHXZ PROC NEAR			; CMover::IsLive, COMDAT
; _this$ = ecx

; 1277 : 	BOOL			IsLive() { return m_pActMover->IsDie() == FALSE || m_nHitPoint > 0; }		// &&   || .  != > 

  00000	8b 81 3c 02 00
	00		 mov	 eax, DWORD PTR [ecx+572]
  00006	f7 40 04 00 00
	00 08		 test	 DWORD PTR [eax+4], 134217728 ; 08000000H
  0000d	74 0d		 je	 SHORT $L297309
  0000f	8b 81 00 06 00
	00		 mov	 eax, DWORD PTR [ecx+1536]
  00015	85 c0		 test	 eax, eax
  00017	7f 03		 jg	 SHORT $L297309
  00019	33 c0		 xor	 eax, eax
  0001b	c3		 ret	 0
$L297309:
  0001c	b8 01 00 00 00	 mov	 eax, 1
  00021	c3		 ret	 0
?IsLive@CMover@@QAEHXZ ENDP				; CMover::IsLive
_TEXT	ENDS
PUBLIC	?SetPKPink@CMover@@QAEXK@Z			; CMover::SetPKPink
; Function compile flags: /Ogty
;	COMDAT ?SetPKPink@CMover@@QAEXK@Z
_TEXT	SEGMENT
_dwTime$ = 8						; size = 4
?SetPKPink@CMover@@QAEXK@Z PROC NEAR			; CMover::SetPKPink, COMDAT
; _this$ = ecx

; 1280 : 	void			SetPKPink( DWORD dwTime ) { if( dwTime == 0 || m_dwPKTime < dwTime ) m_dwPKTime = dwTime; }

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _dwTime$[esp-4]
  00004	85 c0		 test	 eax, eax
  00006	74 08		 je	 SHORT $L212436
  00008	39 81 58 07 00
	00		 cmp	 DWORD PTR [ecx+1880], eax
  0000e	73 06		 jae	 SHORT $L212435
$L212436:
  00010	89 81 58 07 00
	00		 mov	 DWORD PTR [ecx+1880], eax
$L212435:
  00016	c2 04 00	 ret	 4
?SetPKPink@CMover@@QAEXK@Z ENDP				; CMover::SetPKPink
_TEXT	ENDS
PUBLIC	?GetPKPink@CMover@@QAEKXZ			; CMover::GetPKPink
; Function compile flags: /Ogty
;	COMDAT ?GetPKPink@CMover@@QAEKXZ
_TEXT	SEGMENT
?GetPKPink@CMover@@QAEKXZ PROC NEAR			; CMover::GetPKPink, COMDAT
; _this$ = ecx

; 1281 : 	DWORD			GetPKPink( void ) { return m_dwPKTime; }

  00000	8b 81 58 07 00
	00		 mov	 eax, DWORD PTR [ecx+1880]
  00006	c3		 ret	 0
?GetPKPink@CMover@@QAEKXZ ENDP				; CMover::GetPKPink
_TEXT	ENDS
PUBLIC	?IsPKPink@CMover@@QAEHXZ			; CMover::IsPKPink
; Function compile flags: /Ogty
;	COMDAT ?IsPKPink@CMover@@QAEHXZ
_TEXT	SEGMENT
?IsPKPink@CMover@@QAEHXZ PROC NEAR			; CMover::IsPKPink, COMDAT
; _this$ = ecx

; 1282 : 	BOOL			IsPKPink( void )	{ return m_dwPKTime > 0; }			/// PK  

  00000	8b 91 58 07 00
	00		 mov	 edx, DWORD PTR [ecx+1880]
  00006	33 c0		 xor	 eax, eax
  00008	3b c2		 cmp	 eax, edx
  0000a	1b c0		 sbb	 eax, eax
  0000c	f7 d8		 neg	 eax
  0000e	c3		 ret	 0
?IsPKPink@CMover@@QAEHXZ ENDP				; CMover::IsPKPink
_TEXT	ENDS
PUBLIC	?IsChaotic@CMover@@QAEHXZ			; CMover::IsChaotic
; Function compile flags: /Ogty
;	COMDAT ?IsChaotic@CMover@@QAEHXZ
_TEXT	SEGMENT
?IsChaotic@CMover@@QAEHXZ PROC NEAR			; CMover::IsChaotic, COMDAT
; _this$ = ecx

; 1283 : 	BOOL			IsChaotic( void ) { return m_dwPKPropensity > 0; }	/// 

  00000	8b 91 60 07 00
	00		 mov	 edx, DWORD PTR [ecx+1888]
  00006	33 c0		 xor	 eax, eax
  00008	3b c2		 cmp	 eax, edx
  0000a	1b c0		 sbb	 eax, eax
  0000c	f7 d8		 neg	 eax
  0000e	c3		 ret	 0
?IsChaotic@CMover@@QAEHXZ ENDP				; CMover::IsChaotic
_TEXT	ENDS
PUBLIC	?GetPKValue@CMover@@QAEHXZ			; CMover::GetPKValue
; Function compile flags: /Ogty
;	COMDAT ?GetPKValue@CMover@@QAEHXZ
_TEXT	SEGMENT
?GetPKValue@CMover@@QAEHXZ PROC NEAR			; CMover::GetPKValue, COMDAT
; _this$ = ecx

; 1285 : 	int				GetPKValue( void ) { return m_nPKValue; }

  00000	8b 81 5c 07 00
	00		 mov	 eax, DWORD PTR [ecx+1884]
  00006	c3		 ret	 0
?GetPKValue@CMover@@QAEHXZ ENDP				; CMover::GetPKValue
_TEXT	ENDS
PUBLIC	?GetPKPropensity@CMover@@QAEKXZ			; CMover::GetPKPropensity
; Function compile flags: /Ogty
;	COMDAT ?GetPKPropensity@CMover@@QAEKXZ
_TEXT	SEGMENT
?GetPKPropensity@CMover@@QAEKXZ PROC NEAR		; CMover::GetPKPropensity, COMDAT
; _this$ = ecx

; 1287 : 	DWORD			GetPKPropensity( void ) { return m_dwPKPropensity; }

  00000	8b 81 60 07 00
	00		 mov	 eax, DWORD PTR [ecx+1888]
  00006	c3		 ret	 0
?GetPKPropensity@CMover@@QAEKXZ ENDP			; CMover::GetPKPropensity
_TEXT	ENDS
PUBLIC	?IsMode@CMover@@QAEHK@Z				; CMover::IsMode
EXTRN	?GetAdjParam@CMover@@QAEHH@Z:NEAR		; CMover::GetAdjParam
; Function compile flags: /Ogty
;	COMDAT ?IsMode@CMover@@QAEHK@Z
_TEXT	SEGMENT
_dwMode$ = 8						; size = 4
?IsMode@CMover@@QAEHK@Z PROC NEAR			; CMover::IsMode, COMDAT
; _this$ = ecx

; 1762 : { 

  00000	53		 push	 ebx

; 1763 : #ifdef __HACK_0516
; 1764 : 	switch( dwMode )
; 1765 : 	{
; 1766 : 		case MATCHLESS_MODE:		//  
; 1767 : 		case ONEKILL_MODE:		//  
; 1768 : 		case MATCHLESS2_MODE:	//  2
; 1769 : 			if( m_dwAuthorization == AUTH_GENERAL )
; 1770 : 				return FALSE;
; 1771 : 			break;
; 1772 : 	}
; 1773 : #endif	// __HACK_0516
; 1774 : 	if( (dwMode & TRANSPARENT_MODE) )	//   

  00001	8b 5c 24 08	 mov	 ebx, DWORD PTR _dwMode$[esp]
  00005	f6 c3 02	 test	 bl, 2
  00008	56		 push	 esi
  00009	8b f1		 mov	 esi, ecx
  0000b	74 16		 je	 SHORT $L212480

; 1775 : 		if( GetAdjParam(DST_CHRSTATE) & CHS_INVISIBILITY )	//  ?

  0000d	6a 40		 push	 64			; 00000040H
  0000f	e8 00 00 00 00	 call	 ?GetAdjParam@CMover@@QAEHH@Z ; CMover::GetAdjParam
  00014	f6 c4 04	 test	 ah, 4
  00017	74 0a		 je	 SHORT $L212480
  00019	5e		 pop	 esi

; 1776 : 			return TRUE;

  0001a	b8 01 00 00 00	 mov	 eax, 1
  0001f	5b		 pop	 ebx

; 1778 : }	

  00020	c2 04 00	 ret	 4
$L212480:

; 1777 : 	return ( ( m_dwMode & dwMode ) == dwMode ) ? TRUE : FALSE; 

  00023	8b 86 44 02 00
	00		 mov	 eax, DWORD PTR [esi+580]
  00029	23 c3		 and	 eax, ebx
  0002b	2b c3		 sub	 eax, ebx
  0002d	f7 d8		 neg	 eax
  0002f	1b c0		 sbb	 eax, eax
  00031	5e		 pop	 esi
  00032	40		 inc	 eax
  00033	5b		 pop	 ebx

; 1778 : }	

  00034	c2 04 00	 ret	 4
?IsMode@CMover@@QAEHK@Z ENDP				; CMover::IsMode
_TEXT	ENDS
PUBLIC	?IsStateMode@CMover@@QAEHK@Z			; CMover::IsStateMode
; Function compile flags: /Ogty
;	COMDAT ?IsStateMode@CMover@@QAEHK@Z
_TEXT	SEGMENT
_dwMode$ = 8						; size = 4
?IsStateMode@CMover@@QAEHK@Z PROC NEAR			; CMover::IsStateMode, COMDAT
; _this$ = ecx

; 1782 : 	return ( ( m_dwStateMode & dwMode ) == dwMode ) ? TRUE : FALSE; 

  00000	8b 81 4c 02 00
	00		 mov	 eax, DWORD PTR [ecx+588]
  00006	8b 4c 24 04	 mov	 ecx, DWORD PTR _dwMode$[esp-4]
  0000a	23 c1		 and	 eax, ecx
  0000c	2b c1		 sub	 eax, ecx
  0000e	f7 d8		 neg	 eax
  00010	1b c0		 sbb	 eax, eax
  00012	40		 inc	 eax

; 1783 : }	

  00013	c2 04 00	 ret	 4
?IsStateMode@CMover@@QAEHK@Z ENDP			; CMover::IsStateMode
_TEXT	ENDS
PUBLIC	?IsFly@CMover@@QAEHXZ				; CMover::IsFly
; Function compile flags: /Ogty
;	COMDAT ?IsFly@CMover@@QAEHXZ
_TEXT	SEGMENT
?IsFly@CMover@@QAEHXZ PROC NEAR				; CMover::IsFly, COMDAT
; _this$ = ecx

; 1787 : #ifdef _DEBUG
; 1788 : 	if( IsNPC() )
; 1789 : 	{
; 1790 : 		Error( _T( "CMover::IsFly : NPC IsFly()  . IsFlyingNPC() ! %s" ), m_szName );
; 1791 : 		return FALSE;
; 1792 : 	}
; 1793 : #endif
; 1794 : 	return m_pActMover->IsFly();

  00000	8b 81 3c 02 00
	00		 mov	 eax, DWORD PTR [ecx+572]
  00006	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00009	c1 e8 03	 shr	 eax, 3
  0000c	83 e0 01	 and	 eax, 1

; 1795 : }

  0000f	c3		 ret	 0
?IsFly@CMover@@QAEHXZ ENDP				; CMover::IsFly
_TEXT	ENDS
PUBLIC	?SendActMsg@CMover@@QAEHW4OBJMSG@@HHHH@Z	; CMover::SendActMsg
; Function compile flags: /Ogty
;	COMDAT ?SendActMsg@CMover@@QAEHW4OBJMSG@@HHHH@Z
_TEXT	SEGMENT
_dwMsg$ = 8						; size = 4
_nParam1$ = 12						; size = 4
_nParam2$ = 16						; size = 4
_nParam3$ = 20						; size = 4
_nParam4$ = 24						; size = 4
?SendActMsg@CMover@@QAEHW4OBJMSG@@HHHH@Z PROC NEAR	; CMover::SendActMsg, COMDAT
; _this$ = ecx

; 1820 : 	if( m_pActMover )	

  00000	8b 81 3c 02 00
	00		 mov	 eax, DWORD PTR [ecx+572]
  00006	85 c0		 test	 eax, eax
  00008	74 25		 je	 SHORT $L212505

; 1821 : 		return m_pActMover->SendActMsg( dwMsg, nParam1, nParam2, nParam3, nParam4 );	

  0000a	8b 54 24 14	 mov	 edx, DWORD PTR _nParam4$[esp-4]
  0000e	6a 00		 push	 0
  00010	52		 push	 edx
  00011	8b 54 24 18	 mov	 edx, DWORD PTR _nParam3$[esp+4]
  00015	52		 push	 edx
  00016	8b 54 24 18	 mov	 edx, DWORD PTR _nParam2$[esp+8]
  0001a	52		 push	 edx
  0001b	8b 54 24 18	 mov	 edx, DWORD PTR _nParam1$[esp+12]
  0001f	52		 push	 edx
  00020	8b 54 24 18	 mov	 edx, DWORD PTR _dwMsg$[esp+16]
  00024	8b c8		 mov	 ecx, eax
  00026	8b 01		 mov	 eax, DWORD PTR [ecx]
  00028	52		 push	 edx
  00029	ff 50 04	 call	 DWORD PTR [eax+4]

; 1824 : }

  0002c	c2 14 00	 ret	 20			; 00000014H
$L212505:

; 1822 : 	else
; 1823 : 		return 0;

  0002f	33 c0		 xor	 eax, eax

; 1824 : }

  00031	c2 14 00	 ret	 20			; 00000014H
?SendActMsg@CMover@@QAEHW4OBJMSG@@HHHH@Z ENDP		; CMover::SendActMsg
_TEXT	ENDS
PUBLIC	?GetGold@CMover@@QAEHXZ				; CMover::GetGold
; Function compile flags: /Ogty
;	COMDAT ?GetGold@CMover@@QAEHXZ
_TEXT	SEGMENT
?GetGold@CMover@@QAEHXZ PROC NEAR			; CMover::GetGold, COMDAT
; _this$ = ecx

; 1829 : 	int nGold = m_dwGold;
; 1830 : //	nGold -= m_vtInfo.TradeGetGold();
; 1831 : 	ASSERT( nGold >= 0 );
; 1832 : 	return nGold;

  00000	8b 81 84 16 00
	00		 mov	 eax, DWORD PTR [ecx+5764]

; 1833 : }

  00006	c3		 ret	 0
?GetGold@CMover@@QAEHXZ ENDP				; CMover::GetGold
_TEXT	ENDS
PUBLIC	?GetID@CWorld@@QAEKXZ				; CWorld::GetID
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\world.h
;	COMDAT ?GetID@CWorld@@QAEKXZ
_TEXT	SEGMENT
?GetID@CWorld@@QAEKXZ PROC NEAR				; CWorld::GetID, COMDAT
; _this$ = ecx

; 413  : 	DWORD			GetID()	{ return m_dwWorldID; }

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	c3		 ret	 0
?GetID@CWorld@@QAEKXZ ENDP				; CWorld::GetID
_TEXT	ENDS
PUBLIC	??B?$CSimpleStringT@D$0A@@ATL@@QBEPBDXZ		; ATL::CSimpleStringT<char,0>::operator char const *
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlsimpstr.h
;	COMDAT ??B?$CSimpleStringT@D$0A@@ATL@@QBEPBDXZ
_TEXT	SEGMENT
??B?$CSimpleStringT@D$0A@@ATL@@QBEPBDXZ PROC NEAR	; ATL::CSimpleStringT<char,0>::operator char const *, COMDAT
; _this$ = ecx

; 379  : 		return( m_pszData );

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 380  : 	}

  00002	c3		 ret	 0
??B?$CSimpleStringT@D$0A@@ATL@@QBEPBDXZ ENDP		; ATL::CSimpleStringT<char,0>::operator char const *
_TEXT	ENDS
PUBLIC	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size, COMDAT
; _this$ = ecx

; 1109 : 		return (_Mysize);

  00000	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]

; 1110 : 		}

  00003	c3		 ret	 0
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
_TEXT	ENDS
PUBLIC	??8const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::const_iterator::operator==
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::const_iterator::operator==, COMDAT
; _this$ = ecx

; 241  : 			return (_Ptr == _Right._Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Right$[esp-4]
  00006	2b 01		 sub	 eax, DWORD PTR [ecx]
  00008	f7 d8		 neg	 eax
  0000a	1b c0		 sbb	 eax, eax
  0000c	40		 inc	 eax

; 242  : 			}

  0000d	c2 04 00	 ret	 4
??8const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::const_iterator::operator==
_TEXT	ENDS
PUBLIC	?GetSize@?$CFixedArray@UItemProp@@@@QAEHXZ	; CFixedArray<ItemProp>::GetSize
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\data.h
;	COMDAT ?GetSize@?$CFixedArray@UItemProp@@@@QAEHXZ
_TEXT	SEGMENT
?GetSize@?$CFixedArray@UItemProp@@@@QAEHXZ PROC NEAR	; CFixedArray<ItemProp>::GetSize, COMDAT
; _this$ = ecx

; 221  : 	int  GetSize() { return m_nMaxIndex; }

  00000	8b 41 18	 mov	 eax, DWORD PTR [ecx+24]
  00003	c3		 ret	 0
?GetSize@?$CFixedArray@UItemProp@@@@QAEHXZ ENDP		; CFixedArray<ItemProp>::GetSize
_TEXT	ENDS
PUBLIC	?GetSize@?$CFixedArray@UtagColorText@@@@QAEHXZ	; CFixedArray<tagColorText>::GetSize
; Function compile flags: /Ogty
;	COMDAT ?GetSize@?$CFixedArray@UtagColorText@@@@QAEHXZ
_TEXT	SEGMENT
?GetSize@?$CFixedArray@UtagColorText@@@@QAEHXZ PROC NEAR ; CFixedArray<tagColorText>::GetSize, COMDAT
; _this$ = ecx

; 221  : 	int  GetSize() { return m_nMaxIndex; }

  00000	8b 41 18	 mov	 eax, DWORD PTR [ecx+24]
  00003	c3		 ret	 0
?GetSize@?$CFixedArray@UtagColorText@@@@QAEHXZ ENDP	; CFixedArray<tagColorText>::GetSize
_TEXT	ENDS
PUBLIC	?GetString@?$CSimpleStringT@D$0A@@ATL@@QBEPBDXZ	; ATL::CSimpleStringT<char,0>::GetString
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlsimpstr.h
;	COMDAT ?GetString@?$CSimpleStringT@D$0A@@ATL@@QBEPBDXZ
_TEXT	SEGMENT
?GetString@?$CSimpleStringT@D$0A@@ATL@@QBEPBDXZ PROC NEAR ; ATL::CSimpleStringT<char,0>::GetString, COMDAT
; _this$ = ecx

; 510  : 		return( m_pszData );

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 511  : 	}

  00002	c3		 ret	 0
?GetString@?$CSimpleStringT@D$0A@@ATL@@QBEPBDXZ ENDP	; ATL::CSimpleStringT<char,0>::GetString
_TEXT	ENDS
PUBLIC	?StringLength@?$CSimpleStringT@D$0A@@ATL@@SAHPBD@Z ; ATL::CSimpleStringT<char,0>::StringLength
; Function compile flags: /Ogty
;	COMDAT ?StringLength@?$CSimpleStringT@D$0A@@ATL@@SAHPBD@Z
_TEXT	SEGMENT
_psz$ = 8						; size = 4
?StringLength@?$CSimpleStringT@D$0A@@ATL@@SAHPBD@Z PROC NEAR ; ATL::CSimpleStringT<char,0>::StringLength, COMDAT

; 678  : 		if( psz == NULL )

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _psz$[esp-4]
  00004	85 c0		 test	 eax, eax
  00006	75 01		 jne	 SHORT $L219971

; 683  : 	}

  00008	c3		 ret	 0
$L219971:

; 679  : 		{
; 680  : 			return( 0 );
; 681  : 		}
; 682  : 		return( int( strlen( psz ) ) );

  00009	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  0000c	8d 64 24 00	 npad	 4
$L297374:
  00010	8a 08		 mov	 cl, BYTE PTR [eax]
  00012	40		 inc	 eax
  00013	84 c9		 test	 cl, cl
  00015	75 f9		 jne	 SHORT $L297374
  00017	2b c2		 sub	 eax, edx

; 683  : 	}

  00019	c3		 ret	 0
?StringLength@?$CSimpleStringT@D$0A@@ATL@@SAHPBD@Z ENDP	; ATL::CSimpleStringT<char,0>::StringLength
_TEXT	ENDS
PUBLIC	?GetData@?$CSimpleStringT@D$0A@@ATL@@ABEPAUCStringData@2@XZ ; ATL::CSimpleStringT<char,0>::GetData
; Function compile flags: /Ogty
;	COMDAT ?GetData@?$CSimpleStringT@D$0A@@ATL@@ABEPAUCStringData@2@XZ
_TEXT	SEGMENT
?GetData@?$CSimpleStringT@D$0A@@ATL@@ABEPAUCStringData@2@XZ PROC NEAR ; ATL::CSimpleStringT<char,0>::GetData, COMDAT
; _this$ = ecx

; 731  : 		return( reinterpret_cast< CStringData* >( m_pszData )-1 );

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 e8 10	 sub	 eax, 16			; 00000010H

; 732  : 	}

  00005	c3		 ret	 0
?GetData@?$CSimpleStringT@D$0A@@ATL@@ABEPAUCStringData@2@XZ ENDP ; ATL::CSimpleStringT<char,0>::GetData
_TEXT	ENDS
PUBLIC	?SetLength@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z	; ATL::CSimpleStringT<char,0>::SetLength
; Function compile flags: /Ogty
;	COMDAT ?SetLength@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z
_TEXT	SEGMENT
_nLength$ = 8						; size = 4
?SetLength@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z PROC NEAR ; ATL::CSimpleStringT<char,0>::SetLength, COMDAT
; _this$ = ecx

; 790  : 		ATLASSERT( nLength >= 0 );
; 791  : 		ATLASSERT( nLength <= GetData()->nAllocLength );
; 792  : 
; 793  : 		if( nLength < 0 || nLength > GetData()->nAllocLength)

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _nLength$[esp-4]
  00004	85 c0		 test	 eax, eax
  00006	7c 13		 jl	 SHORT $L219986
  00008	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000a	3b 42 f8	 cmp	 eax, DWORD PTR [edx-8]
  0000d	7f 0c		 jg	 SHORT $L219986

; 794  : 			AtlThrow(E_INVALIDARG);
; 795  : 			
; 796  : 		GetData()->nDataLength = nLength;

  0000f	89 42 f4	 mov	 DWORD PTR [edx-12], eax

; 797  : 		m_pszData[nLength] = 0;

  00012	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00014	c6 04 08 00	 mov	 BYTE PTR [eax+ecx], 0

; 798  : 	}

  00018	c2 04 00	 ret	 4
$L219986:
  0001b	68 57 00 07 80	 push	 -2147024809		; 80070057H
  00020	e8 00 00 00 00	 call	 ?AtlThrow@ATL@@YGXJ@Z	; ATL::AtlThrow
$L297388:
$L297387:
  00025	cc		 int	 3
?SetLength@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z ENDP	; ATL::CSimpleStringT<char,0>::SetLength
_TEXT	ENDS
PUBLIC	?FindStringResourceInstance@?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@SAPAUHINSTANCE__@@I@Z ; StrTraitMFC<char,ATL::ChTraitsCRT<char> >::FindStringResourceInstance
EXTRN	?AfxFindStringResourceHandle@@YGPAUHINSTANCE__@@I@Z:NEAR ; AfxFindStringResourceHandle
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\afxstr.h
;	COMDAT ?FindStringResourceInstance@?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@SAPAUHINSTANCE__@@I@Z
_TEXT	SEGMENT
_nID$ = 8						; size = 4
?FindStringResourceInstance@?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@SAPAUHINSTANCE__@@I@Z PROC NEAR ; StrTraitMFC<char,ATL::ChTraitsCRT<char> >::FindStringResourceInstance, COMDAT

; 45   : 		return( AfxFindStringResourceHandle( nID ) );

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _nID$[esp-4]
  00004	50		 push	 eax
  00005	e8 00 00 00 00	 call	 ?AfxFindStringResourceHandle@@YGPAUHINSTANCE__@@I@Z ; AfxFindStringResourceHandle

; 46   : 	}

  0000a	c3		 ret	 0
?FindStringResourceInstance@?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@SAPAUHINSTANCE__@@I@Z ENDP ; StrTraitMFC<char,ATL::ChTraitsCRT<char> >::FindStringResourceInstance
_TEXT	ENDS
PUBLIC	?GetDefaultManager@?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@SAPAUIAtlStringMgr@ATL@@XZ ; StrTraitMFC<char,ATL::ChTraitsCRT<char> >::GetDefaultManager
EXTRN	?AfxGetStringManager@@YGPAUIAtlStringMgr@ATL@@XZ:NEAR ; AfxGetStringManager
; Function compile flags: /Ogty
;	COMDAT ?GetDefaultManager@?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@SAPAUIAtlStringMgr@ATL@@XZ
_TEXT	SEGMENT
?GetDefaultManager@?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@SAPAUIAtlStringMgr@ATL@@XZ PROC NEAR ; StrTraitMFC<char,ATL::ChTraitsCRT<char> >::GetDefaultManager, COMDAT

; 50   : 		return( AfxGetStringManager() );

  00000	e9 00 00 00 00	 jmp	 ?AfxGetStringManager@@YGPAUIAtlStringMgr@ATL@@XZ ; AfxGetStringManager
?GetDefaultManager@?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@SAPAUIAtlStringMgr@ATL@@XZ ENDP ; StrTraitMFC<char,ATL::ChTraitsCRT<char> >::GetDefaultManager
_TEXT	ENDS
PUBLIC	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr, COMDAT
; _this$ = ecx

; 1537 : 		return (_BUF_SIZE <= _Myres ? _Bx._Ptr : _Bx._Buf);

  00000	83 79 18 10	 cmp	 DWORD PTR [ecx+24], 16	; 00000010H
  00004	72 04		 jb	 SHORT $L297399
  00006	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 1538 : 		}

  00009	c3		 ret	 0
$L297399:

; 1537 : 		return (_BUF_SIZE <= _Myres ? _Bx._Ptr : _Bx._Buf);

  0000a	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]

; 1538 : 		}

  0000d	c3		 ret	 0
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
_TEXT	ENDS
PUBLIC	??0?$allocator@D@std@@QAE@XZ			; std::allocator<char>::allocator<char>
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@D@std@@QAE@XZ PROC NEAR			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 111  : 	allocator()

  00000	8b c1		 mov	 eax, ecx

; 112  : 		{	// construct default allocator (do nothing)
; 113  : 		}

  00002	c3		 ret	 0
??0?$allocator@D@std@@QAE@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
PUBLIC	??0?$allocator@D@std@@QAE@ABV01@@Z		; std::allocator<char>::allocator<char>
; Function compile flags: /Ogty
;	COMDAT ??0?$allocator@D@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@D@std@@QAE@ABV01@@Z PROC NEAR		; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 115  : 	allocator(const allocator<_Ty>&)

  00000	8b c1		 mov	 eax, ecx

; 116  : 		{	// construct by copying (do nothing)
; 117  : 		}

  00002	c2 04 00	 ret	 4
??0?$allocator@D@std@@QAE@ABV01@@Z ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
PUBLIC	??R?$less@K@std@@QBE_NABK0@Z			; std::less<unsigned long>::operator()
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\functional
;	COMDAT ??R?$less@K@std@@QBE_NABK0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??R?$less@K@std@@QBE_NABK0@Z PROC NEAR			; std::less<unsigned long>::operator(), COMDAT
; _this$ = ecx

; 139  : 		return (_Left < _Right);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Left$[esp-4]
  00004	8b 08		 mov	 ecx, DWORD PTR [eax]
  00006	8b 54 24 08	 mov	 edx, DWORD PTR __Right$[esp-4]
  0000a	3b 0a		 cmp	 ecx, DWORD PTR [edx]
  0000c	1b c0		 sbb	 eax, eax
  0000e	f7 d8		 neg	 eax

; 140  : 		}

  00010	c2 08 00	 ret	 8
??R?$less@K@std@@QBE_NABK0@Z ENDP			; std::less<unsigned long>::operator()
_TEXT	ENDS
PUBLIC	??0?$allocator@K@std@@QAE@XZ			; std::allocator<unsigned long>::allocator<unsigned long>
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??0?$allocator@K@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@K@std@@QAE@XZ PROC NEAR			; std::allocator<unsigned long>::allocator<unsigned long>, COMDAT
; _this$ = ecx

; 111  : 	allocator()

  00000	8b c1		 mov	 eax, ecx

; 112  : 		{	// construct default allocator (do nothing)
; 113  : 		}

  00002	c3		 ret	 0
??0?$allocator@K@std@@QAE@XZ ENDP			; std::allocator<unsigned long>::allocator<unsigned long>
_TEXT	ENDS
PUBLIC	??8const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::const_iterator::operator==
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::const_iterator::operator==, COMDAT
; _this$ = ecx

; 241  : 			return (_Ptr == _Right._Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Right$[esp-4]
  00006	2b 01		 sub	 eax, DWORD PTR [ecx]
  00008	f7 d8		 neg	 eax
  0000a	1b c0		 sbb	 eax, eax
  0000c	40		 inc	 eax

; 242  : 			}

  0000d	c2 04 00	 ret	 4
??8const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::const_iterator::operator==
_TEXT	ENDS
PUBLIC	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::const_iterator::_Mynode
; Function compile flags: /Ogty
;	COMDAT ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@3@XZ
_TEXT	SEGMENT
?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@3@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::const_iterator::_Mynode, COMDAT
; _this$ = ecx

; 284  : 			return (_Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 285  : 			}

  00002	c3		 ret	 0
?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@3@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::const_iterator::_Mynode
_TEXT	ENDS
PUBLIC	?_Isnil@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::_Isnil
; Function compile flags: /Ogty
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Isnil@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::_Isnil, COMDAT

; 137  : 		return ((_Charref)(*_Pnode)._Isnil);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]
  00004	83 c0 15	 add	 eax, 21			; 00000015H

; 138  : 		}

  00007	c3		 ret	 0
?_Isnil@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::_Isnil
_TEXT	ENDS
PUBLIC	?_Left@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::_Left
; Function compile flags: /Ogty
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Left@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::_Left, COMDAT

; 147  : 		return ((_Nodepref)(*_Pnode)._Left);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]

; 148  : 		}

  00004	c3		 ret	 0
?_Left@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::_Left
_TEXT	ENDS
PUBLIC	?_Right@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::_Right
; Function compile flags: /Ogty
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Right@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::_Right, COMDAT

; 157  : 		return ((_Nodepref)(*_Pnode)._Right);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]
  00004	83 c0 08	 add	 eax, 8

; 158  : 		}

  00007	c3		 ret	 0
?_Right@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::_Right
_TEXT	ENDS
PUBLIC	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::const_iterator::_Mynode
; Function compile flags: /Ogty
;	COMDAT ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@3@XZ
_TEXT	SEGMENT
?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@3@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::const_iterator::_Mynode, COMDAT
; _this$ = ecx

; 284  : 			return (_Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 285  : 			}

  00002	c3		 ret	 0
?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@3@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::const_iterator::_Mynode
_TEXT	ENDS
PUBLIC	?size@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::size
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ?size@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ PROC NEAR ; std::vector<unsigned char,std::allocator<unsigned char> >::size, COMDAT
; _this$ = ecx

; 516  : 		return (_Myfirst == 0 ? 0 : _Mylast - _Myfirst);

  00000	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00003	85 d2		 test	 edx, edx
  00005	75 03		 jne	 SHORT $L297434
  00007	33 c0		 xor	 eax, eax

; 517  : 		}

  00009	c3		 ret	 0
$L297434:

; 516  : 		return (_Myfirst == 0 ? 0 : _Mylast - _Myfirst);

  0000a	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  0000d	2b c2		 sub	 eax, edx

; 517  : 		}

  0000f	c3		 ret	 0
?size@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ ENDP	; std::vector<unsigned char,std::allocator<unsigned char> >::size
_TEXT	ENDS
PUBLIC	??0const_iterator@?$vector@EV?$allocator@E@std@@@std@@QAE@PAE@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::const_iterator::const_iterator
; Function compile flags: /Ogty
;	COMDAT ??0const_iterator@?$vector@EV?$allocator@E@std@@@std@@QAE@PAE@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0const_iterator@?$vector@EV?$allocator@E@std@@@std@@QAE@PAE@Z PROC NEAR ; std::vector<unsigned char,std::allocator<unsigned char> >::const_iterator::const_iterator, COMDAT
; _this$ = ecx

; 73   : 		const_iterator(_Tptr _Ptr)

  00000	8b c1		 mov	 eax, ecx

; 74   : 			{	// construct with pointer _Ptr
; 75   : 			_Myptr = _Ptr;

  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Ptr$[esp-4]
  00006	89 08		 mov	 DWORD PTR [eax], ecx

; 76   : 			}

  00008	c2 04 00	 ret	 4
??0const_iterator@?$vector@EV?$allocator@E@std@@@std@@QAE@PAE@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::const_iterator::const_iterator
_TEXT	ENDS
PUBLIC	??8const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::const_iterator::operator==
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::const_iterator::operator==, COMDAT
; _this$ = ecx

; 241  : 			return (_Ptr == _Right._Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Right$[esp-4]
  00006	2b 01		 sub	 eax, DWORD PTR [ecx]
  00008	f7 d8		 neg	 eax
  0000a	1b c0		 sbb	 eax, eax
  0000c	40		 inc	 eax

; 242  : 			}

  0000d	c2 04 00	 ret	 4
??8const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::const_iterator::operator==
_TEXT	ENDS
PUBLIC	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::const_iterator::_Mynode
; Function compile flags: /Ogty
;	COMDAT ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@3@XZ
_TEXT	SEGMENT
?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@3@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::const_iterator::_Mynode, COMDAT
; _this$ = ecx

; 284  : 			return (_Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 285  : 			}

  00002	c3		 ret	 0
?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@3@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::const_iterator::_Mynode
_TEXT	ENDS
PUBLIC	??0?$pair@$$CBKPAVCUser@@@std@@QAE@ABKABQAVCUser@@@Z ; std::pair<unsigned long const ,CUser *>::pair<unsigned long const ,CUser *>
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\utility
;	COMDAT ??0?$pair@$$CBKPAVCUser@@@std@@QAE@ABKABQAVCUser@@@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$pair@$$CBKPAVCUser@@@std@@QAE@ABKABQAVCUser@@@Z PROC NEAR ; std::pair<unsigned long const ,CUser *>::pair<unsigned long const ,CUser *>, COMDAT
; _this$ = ecx

; 34   : 		{	// construct from specified values

  00000	8b c1		 mov	 eax, ecx
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Val1$[esp-4]
  00006	8b 11		 mov	 edx, DWORD PTR [ecx]
  00008	8b 4c 24 08	 mov	 ecx, DWORD PTR __Val2$[esp-4]
  0000c	89 10		 mov	 DWORD PTR [eax], edx
  0000e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00010	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 35   : 		}

  00013	c2 08 00	 ret	 8
??0?$pair@$$CBKPAVCUser@@@std@@QAE@ABKABQAVCUser@@@Z ENDP ; std::pair<unsigned long const ,CUser *>::pair<unsigned long const ,CUser *>
_TEXT	ENDS
PUBLIC	?Attach@?$CSimpleStringT@D$0A@@ATL@@AAEXPAUCStringData@2@@Z ; ATL::CSimpleStringT<char,0>::Attach
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlsimpstr.h
;	COMDAT ?Attach@?$CSimpleStringT@D$0A@@ATL@@AAEXPAUCStringData@2@@Z
_TEXT	SEGMENT
_pData$ = 8						; size = 4
?Attach@?$CSimpleStringT@D$0A@@ATL@@AAEXPAUCStringData@2@@Z PROC NEAR ; ATL::CSimpleStringT<char,0>::Attach, COMDAT
; _this$ = ecx

; 712  : 		m_pszData = static_cast< PXSTR >( pData->data() );

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _pData$[esp-4]
  00004	83 c0 10	 add	 eax, 16			; 00000010H
  00007	89 01		 mov	 DWORD PTR [ecx], eax

; 713  : 	}

  00009	c2 04 00	 ret	 4
?Attach@?$CSimpleStringT@D$0A@@ATL@@AAEXPAUCStringData@2@@Z ENDP ; ATL::CSimpleStringT<char,0>::Attach
_TEXT	ENDS
PUBLIC	?GetBaseTypeLength@?$ChTraitsCRT@D@ATL@@SAHPBGH@Z ; ATL::ChTraitsCRT<char>::GetBaseTypeLength
EXTRN	__imp__WideCharToMultiByte@32:NEAR
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\cstringt.h
;	COMDAT ?GetBaseTypeLength@?$ChTraitsCRT@D@ATL@@SAHPBGH@Z
_TEXT	SEGMENT
_pszSource$ = 8						; size = 4
_nLength$ = 12						; size = 4
?GetBaseTypeLength@?$ChTraitsCRT@D@ATL@@SAHPBGH@Z PROC NEAR ; ATL::ChTraitsCRT<char>::GetBaseTypeLength, COMDAT

; 437  : 		// Returns required buffer length in XCHARs
; 438  : 		return ::WideCharToMultiByte( _AtlGetConversionACP(), 0, pszSource, nLength, NULL, 0, NULL, NULL );

  00000	ff 15 00 00 00
	00		 call	 DWORD PTR ?g_pfnGetThreadACP@ATL@@3P6GIXZA ; ATL::g_pfnGetThreadACP
  00006	8b 4c 24 08	 mov	 ecx, DWORD PTR _nLength$[esp-4]
  0000a	8b 54 24 04	 mov	 edx, DWORD PTR _pszSource$[esp-4]
  0000e	6a 00		 push	 0
  00010	6a 00		 push	 0
  00012	6a 00		 push	 0
  00014	6a 00		 push	 0
  00016	51		 push	 ecx
  00017	52		 push	 edx
  00018	6a 00		 push	 0
  0001a	50		 push	 eax
  0001b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WideCharToMultiByte@32

; 439  : 	}

  00021	c3		 ret	 0
?GetBaseTypeLength@?$ChTraitsCRT@D@ATL@@SAHPBGH@Z ENDP	; ATL::ChTraitsCRT<char>::GetBaseTypeLength
_TEXT	ENDS
PUBLIC	?ConvertToBaseType@?$ChTraitsCRT@D@ATL@@SAXPADHPBGH@Z ; ATL::ChTraitsCRT<char>::ConvertToBaseType
; Function compile flags: /Ogty
;	COMDAT ?ConvertToBaseType@?$ChTraitsCRT@D@ATL@@SAXPADHPBGH@Z
_TEXT	SEGMENT
_pszDest$ = 8						; size = 4
_nDestLength$ = 12					; size = 4
_pszSrc$ = 16						; size = 4
_nSrcLength$ = 20					; size = 4
?ConvertToBaseType@?$ChTraitsCRT@D@ATL@@SAXPADHPBGH@Z PROC NEAR ; ATL::ChTraitsCRT<char>::ConvertToBaseType, COMDAT

; 452  : 		// nLen is in XCHARs
; 453  : 		::WideCharToMultiByte( _AtlGetConversionACP(), 0, pszSrc, nSrcLength, pszDest, nDestLength, NULL, NULL );

  00000	8b 44 24 08	 mov	 eax, DWORD PTR _nDestLength$[esp-4]
  00004	8b 4c 24 04	 mov	 ecx, DWORD PTR _pszDest$[esp-4]
  00008	8b 54 24 10	 mov	 edx, DWORD PTR _nSrcLength$[esp-4]
  0000c	6a 00		 push	 0
  0000e	6a 00		 push	 0
  00010	50		 push	 eax
  00011	8b 44 24 18	 mov	 eax, DWORD PTR _pszSrc$[esp+8]
  00015	51		 push	 ecx
  00016	52		 push	 edx
  00017	50		 push	 eax
  00018	6a 00		 push	 0
  0001a	ff 15 00 00 00
	00		 call	 DWORD PTR ?g_pfnGetThreadACP@ATL@@3P6GIXZA ; ATL::g_pfnGetThreadACP
  00020	50		 push	 eax
  00021	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WideCharToMultiByte@32

; 454  : 	}

  00027	c3		 ret	 0
?ConvertToBaseType@?$ChTraitsCRT@D@ATL@@SAXPADHPBGH@Z ENDP ; ATL::ChTraitsCRT<char>::ConvertToBaseType
_TEXT	ENDS
PUBLIC	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ
_TEXT	SEGMENT
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr, COMDAT
; _this$ = ecx

; 1532 : 		return (_BUF_SIZE <= _Myres ? _Bx._Ptr : _Bx._Buf);

  00000	83 79 18 10	 cmp	 DWORD PTR [ecx+24], 16	; 00000010H
  00004	72 04		 jb	 SHORT $L297470
  00006	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 1533 : 		}

  00009	c3		 ret	 0
$L297470:

; 1532 : 		return (_BUF_SIZE <= _Myres ? _Bx._Ptr : _Bx._Buf);

  0000a	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]

; 1533 : 		}

  0000d	c3		 ret	 0
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@D@std@@QAEXPADI@Z	; std::allocator<char>::deallocate
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@D@std@@QAEXPADI@Z PROC NEAR	; std::allocator<char>::deallocate, COMDAT
; _this$ = ecx

; 132  : 		operator delete(_Ptr);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Ptr$[esp-4]
  00004	50		 push	 eax
  00005	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000a	59		 pop	 ecx

; 133  : 		}

  0000b	c2 08 00	 ret	 8
?deallocate@?$allocator@D@std@@QAEXPADI@Z ENDP		; std::allocator<char>::deallocate
_TEXT	ENDS
PUBLIC	?_Isnil@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Isnil
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Isnil@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Isnil, COMDAT

; 137  : 		return ((_Charref)(*_Pnode)._Isnil);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]
  00004	83 c0 15	 add	 eax, 21			; 00000015H

; 138  : 		}

  00007	c3		 ret	 0
?_Isnil@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Isnil
_TEXT	ENDS
PUBLIC	?_Right@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Right
; Function compile flags: /Ogty
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Right@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Right, COMDAT

; 157  : 		return ((_Nodepref)(*_Pnode)._Right);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]
  00004	83 c0 08	 add	 eax, 8

; 158  : 		}

  00007	c3		 ret	 0
?_Right@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Right
_TEXT	ENDS
PUBLIC	?_Myval@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBKPAVCUser@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Myval
; Function compile flags: /Ogty
;	COMDAT ?_Myval@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBKPAVCUser@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Myval@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBKPAVCUser@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Myval, COMDAT

; 162  : 		return ((_Vref)(*_Pnode)._Myval);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]
  00004	83 c0 0c	 add	 eax, 12			; 0000000cH

; 163  : 		}

  00007	c3		 ret	 0
?_Myval@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBKPAVCUser@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Myval
_TEXT	ENDS
PUBLIC	?size@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::size
; Function compile flags: /Ogty
;	COMDAT ?size@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QBEIXZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::size, COMDAT
; _this$ = ecx

; 448  : 		return (_Mysize);

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]

; 449  : 		}

  00003	c3		 ret	 0
?size@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::size
_TEXT	ENDS
PUBLIC	?_Rmost@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Rmost
; Function compile flags: /Ogty
;	COMDAT ?_Rmost@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Rmost@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Rmost, COMDAT
; _this$ = ecx

; 1049 : 		return (_Right(_Myhead));

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	83 c0 08	 add	 eax, 8

; 1050 : 		}

  00006	c3		 ret	 0
?_Rmost@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Rmost
_TEXT	ENDS
PUBLIC	?_Kfn@?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@SAABKABU?$pair@$$CBKPAVCUser@@@2@@Z ; std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0>::_Kfn
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\map
;	COMDAT ?_Kfn@?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@SAABKABU?$pair@$$CBKPAVCUser@@@2@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?_Kfn@?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@SAABKABU?$pair@$$CBKPAVCUser@@@2@@Z PROC NEAR ; std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0>::_Kfn, COMDAT

; 64   : 		return (_Val.first);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Val$[esp-4]

; 65   : 		}

  00004	c3		 ret	 0
?_Kfn@?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@SAABKABU?$pair@$$CBKPAVCUser@@@2@@Z ENDP ; std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0>::_Kfn
_TEXT	ENDS
PUBLIC	??0?$allocator@K@std@@QAE@ABV01@@Z		; std::allocator<unsigned long>::allocator<unsigned long>
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??0?$allocator@K@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@K@std@@QAE@ABV01@@Z PROC NEAR		; std::allocator<unsigned long>::allocator<unsigned long>, COMDAT
; _this$ = ecx

; 115  : 	allocator(const allocator<_Ty>&)

  00000	8b c1		 mov	 eax, ecx

; 116  : 		{	// construct by copying (do nothing)
; 117  : 		}

  00002	c2 04 00	 ret	 4
??0?$allocator@K@std@@QAE@ABV01@@Z ENDP			; std::allocator<unsigned long>::allocator<unsigned long>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@K@std@@QAEXPAKI@Z	; std::allocator<unsigned long>::deallocate
; Function compile flags: /Ogty
;	COMDAT ?deallocate@?$allocator@K@std@@QAEXPAKI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@K@std@@QAEXPAKI@Z PROC NEAR	; std::allocator<unsigned long>::deallocate, COMDAT
; _this$ = ecx

; 132  : 		operator delete(_Ptr);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Ptr$[esp-4]
  00004	50		 push	 eax
  00005	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000a	59		 pop	 ecx

; 133  : 		}

  0000b	c2 08 00	 ret	 8
?deallocate@?$allocator@K@std@@QAEXPAKI@Z ENDP		; std::allocator<unsigned long>::deallocate
_TEXT	ENDS
PUBLIC	??Dconst_iterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QBEABU?$pair@$$CBKPAVCUser@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::const_iterator::operator*
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ??Dconst_iterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QBEABU?$pair@$$CBKPAVCUser@@@2@XZ
_TEXT	SEGMENT
??Dconst_iterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QBEABU?$pair@$$CBKPAVCUser@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::const_iterator::operator*, COMDAT
; _this$ = ecx

; 205  : 			return (_Myval(_Ptr));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 0c	 add	 eax, 12			; 0000000cH

; 206  : 			}

  00005	c3		 ret	 0
??Dconst_iterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QBEABU?$pair@$$CBKPAVCUser@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::const_iterator::operator*
_TEXT	ENDS
PUBLIC	??9const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::const_iterator::operator!=
; Function compile flags: /Ogty
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::const_iterator::operator!=, COMDAT
; _this$ = ecx

; 246  : 			return (!(*this == _Right));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 54 24 04	 mov	 edx, DWORD PTR __Right$[esp-4]
  00006	56		 push	 esi
  00007	8b 32		 mov	 esi, DWORD PTR [edx]
  00009	33 c9		 xor	 ecx, ecx
  0000b	3b c6		 cmp	 eax, esi
  0000d	0f 95 c1	 setne	 cl
  00010	8a c1		 mov	 al, cl
  00012	5e		 pop	 esi

; 247  : 			}

  00013	c2 04 00	 ret	 4
??9const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::const_iterator::operator!=
_TEXT	ENDS
PUBLIC	?_Color@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::_Color
; Function compile flags: /Ogty
;	COMDAT ?_Color@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Color@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::_Color, COMDAT

; 132  : 		return ((_Charref)(*_Pnode)._Color);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]
  00004	83 c0 14	 add	 eax, 20			; 00000014H

; 133  : 		}

  00007	c3		 ret	 0
?_Color@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::_Color
_TEXT	ENDS
PUBLIC	?_Parent@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::_Parent
; Function compile flags: /Ogty
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Parent@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::_Parent, COMDAT

; 152  : 		return ((_Nodepref)(*_Pnode)._Parent);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]
  00004	83 c0 04	 add	 eax, 4

; 153  : 		}

  00007	c3		 ret	 0
?_Parent@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::_Parent
_TEXT	ENDS
PUBLIC	?_Myval@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBKPAVCCtrl@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::_Myval
; Function compile flags: /Ogty
;	COMDAT ?_Myval@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBKPAVCCtrl@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Myval@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBKPAVCCtrl@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::_Myval, COMDAT

; 162  : 		return ((_Vref)(*_Pnode)._Myval);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]
  00004	83 c0 0c	 add	 eax, 12			; 0000000cH

; 163  : 		}

  00007	c3		 ret	 0
?_Myval@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBKPAVCCtrl@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::_Myval
_TEXT	ENDS
PUBLIC	?_Lmost@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::_Lmost
; Function compile flags: /Ogty
;	COMDAT ?_Lmost@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Lmost@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::_Lmost, COMDAT
; _this$ = ecx

; 1005 : 		return (_Left(_Myhead));

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 1006 : 		}

  00003	c3		 ret	 0
?_Lmost@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::_Lmost
_TEXT	ENDS
PUBLIC	?_Rmost@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::_Rmost
; Function compile flags: /Ogty
;	COMDAT ?_Rmost@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Rmost@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::_Rmost, COMDAT
; _this$ = ecx

; 1049 : 		return (_Right(_Myhead));

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	83 c0 08	 add	 eax, 8

; 1050 : 		}

  00006	c3		 ret	 0
?_Rmost@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::_Rmost
_TEXT	ENDS
PUBLIC	??0const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::const_iterator::const_iterator
; Function compile flags: /Ogty
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
??0const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::const_iterator::const_iterator, COMDAT
; _this$ = ecx

; 200  : 			{	// construct with node pointer _Pnode

  00000	8b c1		 mov	 eax, ecx
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Pnode$[esp-4]
  00006	89 08		 mov	 DWORD PTR [eax], ecx

; 201  : 			}

  00008	c2 04 00	 ret	 4
??0const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::const_iterator::const_iterator
_TEXT	ENDS
PUBLIC	??Dconst_iterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QBEABU?$pair@$$CBKPAVCCtrl@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::const_iterator::operator*
; Function compile flags: /Ogty
;	COMDAT ??Dconst_iterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QBEABU?$pair@$$CBKPAVCCtrl@@@2@XZ
_TEXT	SEGMENT
??Dconst_iterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QBEABU?$pair@$$CBKPAVCCtrl@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::const_iterator::operator*, COMDAT
; _this$ = ecx

; 205  : 			return (_Myval(_Ptr));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 0c	 add	 eax, 12			; 0000000cH

; 206  : 			}

  00005	c3		 ret	 0
??Dconst_iterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QBEABU?$pair@$$CBKPAVCCtrl@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::const_iterator::operator*
_TEXT	ENDS
PUBLIC	??9const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::const_iterator::operator!=
; Function compile flags: /Ogty
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::const_iterator::operator!=, COMDAT
; _this$ = ecx

; 246  : 			return (!(*this == _Right));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 54 24 04	 mov	 edx, DWORD PTR __Right$[esp-4]
  00006	56		 push	 esi
  00007	8b 32		 mov	 esi, DWORD PTR [edx]
  00009	33 c9		 xor	 ecx, ecx
  0000b	3b c6		 cmp	 eax, esi
  0000d	0f 95 c1	 setne	 cl
  00010	8a c1		 mov	 al, cl
  00012	5e		 pop	 esi

; 247  : 			}

  00013	c2 04 00	 ret	 4
??9const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::const_iterator::operator!=
_TEXT	ENDS
PUBLIC	?_Left@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Left
; Function compile flags: /Ogty
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Left@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Left, COMDAT

; 147  : 		return ((_Nodepref)(*_Pnode)._Left);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]

; 148  : 		}

  00004	c3		 ret	 0
?_Left@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Left
_TEXT	ENDS
PUBLIC	?_Parent@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent
; Function compile flags: /Ogty
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Parent@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent, COMDAT

; 152  : 		return ((_Nodepref)(*_Pnode)._Parent);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]
  00004	83 c0 04	 add	 eax, 4

; 153  : 		}

  00007	c3		 ret	 0
?_Parent@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent
_TEXT	ENDS
PUBLIC	?_Right@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Right
; Function compile flags: /Ogty
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Right@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Right, COMDAT

; 157  : 		return ((_Nodepref)(*_Pnode)._Right);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]
  00004	83 c0 08	 add	 eax, 8

; 158  : 		}

  00007	c3		 ret	 0
?_Right@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Right
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node>::deallocate
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@I@Z PROC NEAR ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node>::deallocate, COMDAT
; _this$ = ecx

; 132  : 		operator delete(_Ptr);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Ptr$[esp-4]
  00004	50		 push	 eax
  00005	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000a	59		 pop	 ecx

; 133  : 		}

  0000b	c2 08 00	 ret	 8
?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node>::deallocate
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@E@std@@QAEXPAEI@Z	; std::allocator<unsigned char>::deallocate
; Function compile flags: /Ogty
;	COMDAT ?deallocate@?$allocator@E@std@@QAEXPAEI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@E@std@@QAEXPAEI@Z PROC NEAR	; std::allocator<unsigned char>::deallocate, COMDAT
; _this$ = ecx

; 132  : 		operator delete(_Ptr);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Ptr$[esp-4]
  00004	50		 push	 eax
  00005	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000a	59		 pop	 ecx

; 133  : 		}

  0000b	c2 08 00	 ret	 8
?deallocate@?$allocator@E@std@@QAEXPAEI@Z ENDP		; std::allocator<unsigned char>::deallocate
_TEXT	ENDS
PUBLIC	?_Myval@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBKPAVCMover@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::_Myval
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ?_Myval@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBKPAVCMover@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Myval@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBKPAVCMover@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::_Myval, COMDAT

; 162  : 		return ((_Vref)(*_Pnode)._Myval);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]
  00004	83 c0 0c	 add	 eax, 12			; 0000000cH

; 163  : 		}

  00007	c3		 ret	 0
?_Myval@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBKPAVCMover@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::_Myval
_TEXT	ENDS
PUBLIC	?_Kfn@?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@SAABKABU?$pair@$$CBKPAVCMover@@@2@@Z ; std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0>::_Kfn
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\map
;	COMDAT ?_Kfn@?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@SAABKABU?$pair@$$CBKPAVCMover@@@2@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?_Kfn@?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@SAABKABU?$pair@$$CBKPAVCMover@@@2@@Z PROC NEAR ; std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0>::_Kfn, COMDAT

; 64   : 		return (_Val.first);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Val$[esp-4]

; 65   : 		}

  00004	c3		 ret	 0
?_Kfn@?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@SAABKABU?$pair@$$CBKPAVCMover@@@2@@Z ENDP ; std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0>::_Kfn
_TEXT	ENDS
PUBLIC	??0const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::const_iterator::const_iterator
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
??0const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::const_iterator::const_iterator, COMDAT
; _this$ = ecx

; 200  : 			{	// construct with node pointer _Pnode

  00000	8b c1		 mov	 eax, ecx
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Pnode$[esp-4]
  00006	89 08		 mov	 DWORD PTR [eax], ecx

; 201  : 			}

  00008	c2 04 00	 ret	 4
??0const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::const_iterator::const_iterator
_TEXT	ENDS
PUBLIC	??Dconst_iterator@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QBEABU?$pair@$$CBKPAVCMover@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::const_iterator::operator*
; Function compile flags: /Ogty
;	COMDAT ??Dconst_iterator@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QBEABU?$pair@$$CBKPAVCMover@@@2@XZ
_TEXT	SEGMENT
??Dconst_iterator@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QBEABU?$pair@$$CBKPAVCMover@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::const_iterator::operator*, COMDAT
; _this$ = ecx

; 205  : 			return (_Myval(_Ptr));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 0c	 add	 eax, 12			; 0000000cH

; 206  : 			}

  00005	c3		 ret	 0
??Dconst_iterator@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QBEABU?$pair@$$CBKPAVCMover@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::const_iterator::operator*
_TEXT	ENDS
PUBLIC	??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@V123@@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@1@0@Z ; std::pair<std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::iterator,std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::iterator>::pair<std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::iterator,std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::iterator>
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\utility
;	COMDAT ??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@V123@@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@1@0@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@V123@@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@1@0@Z PROC NEAR ; std::pair<std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::iterator,std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::iterator>::pair<std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::iterator,std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::iterator>, COMDAT
; _this$ = ecx

; 34   : 		{	// construct from specified values

  00000	8b c1		 mov	 eax, ecx
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Val1$[esp-4]
  00006	8b 11		 mov	 edx, DWORD PTR [ecx]
  00008	8b 4c 24 08	 mov	 ecx, DWORD PTR __Val2$[esp-4]
  0000c	89 10		 mov	 DWORD PTR [eax], edx
  0000e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00010	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 35   : 		}

  00013	c2 08 00	 ret	 8
??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@V123@@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@1@0@Z ENDP ; std::pair<std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::iterator,std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::iterator>::pair<std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::iterator,std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::iterator>
_TEXT	ENDS
PUBLIC	?CopyChars@?$CSimpleStringT@D$0A@@ATL@@SAXPADPBDH@Z ; ATL::CSimpleStringT<char,0>::CopyChars
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlsimpstr.h
;	COMDAT ?CopyChars@?$CSimpleStringT@D$0A@@ATL@@SAXPADPBDH@Z
_TEXT	SEGMENT
_pchDest$ = 8						; size = 4
_pchSrc$ = 12						; size = 4
_nChars$ = 16						; size = 4
?CopyChars@?$CSimpleStringT@D$0A@@ATL@@SAXPADPBDH@Z PROC NEAR ; ATL::CSimpleStringT<char,0>::CopyChars, COMDAT

; 653  : 		memcpy( pchDest, pchSrc, nChars*sizeof( XCHAR ) );

  00000	8b 4c 24 0c	 mov	 ecx, DWORD PTR _nChars$[esp-4]
  00004	56		 push	 esi
  00005	8b 74 24 0c	 mov	 esi, DWORD PTR _pchSrc$[esp]
  00009	8b c1		 mov	 eax, ecx
  0000b	57		 push	 edi
  0000c	8b 7c 24 0c	 mov	 edi, DWORD PTR _pchDest$[esp+4]
  00010	c1 e9 02	 shr	 ecx, 2
  00013	f3 a5		 rep movsd
  00015	8b c8		 mov	 ecx, eax
  00017	83 e1 03	 and	 ecx, 3
  0001a	f3 a4		 rep movsb
  0001c	5f		 pop	 edi
  0001d	5e		 pop	 esi

; 654  : 	}

  0001e	c3		 ret	 0
?CopyChars@?$CSimpleStringT@D$0A@@ATL@@SAXPADPBDH@Z ENDP ; ATL::CSimpleStringT<char,0>::CopyChars
_TEXT	ENDS
PUBLIC	?CopyCharsOverlapped@?$CSimpleStringT@D$0A@@ATL@@SAXPADPBDH@Z ; ATL::CSimpleStringT<char,0>::CopyCharsOverlapped
; Function compile flags: /Ogty
;	COMDAT ?CopyCharsOverlapped@?$CSimpleStringT@D$0A@@ATL@@SAXPADPBDH@Z
_TEXT	SEGMENT
_pchDest$ = 8						; size = 4
_pchSrc$ = 12						; size = 4
_nChars$ = 16						; size = 4
?CopyCharsOverlapped@?$CSimpleStringT@D$0A@@ATL@@SAXPADPBDH@Z PROC NEAR ; ATL::CSimpleStringT<char,0>::CopyCharsOverlapped, COMDAT

; 657  : 		memmove( pchDest, pchSrc, nChars*sizeof( XCHAR ) );

  00000	e9 00 00 00 00	 jmp	 _memmove
?CopyCharsOverlapped@?$CSimpleStringT@D$0A@@ATL@@SAXPADPBDH@Z ENDP ; ATL::CSimpleStringT<char,0>::CopyCharsOverlapped
_TEXT	ENDS
PUBLIC	?ThrowMemoryException@?$CSimpleStringT@D$0A@@ATL@@KAXXZ ; ATL::CSimpleStringT<char,0>::ThrowMemoryException
; Function compile flags: /Ogty
;	COMDAT ?ThrowMemoryException@?$CSimpleStringT@D$0A@@ATL@@KAXXZ
_TEXT	SEGMENT
?ThrowMemoryException@?$CSimpleStringT@D$0A@@ATL@@KAXXZ PROC NEAR ; ATL::CSimpleStringT<char,0>::ThrowMemoryException, COMDAT

; 705  : 		AtlThrow( E_OUTOFMEMORY );

  00000	68 0e 00 07 80	 push	 -2147024882		; 8007000eH
  00005	e8 00 00 00 00	 call	 ?AtlThrow@ATL@@YGXJ@Z	; ATL::AtlThrow
$L297594:
$L297593:
  0000a	cc		 int	 3
?ThrowMemoryException@?$CSimpleStringT@D$0A@@ATL@@KAXXZ ENDP ; ATL::CSimpleStringT<char,0>::ThrowMemoryException
_TEXT	ENDS
PUBLIC	?Fork@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z	; ATL::CSimpleStringT<char,0>::Fork
; Function compile flags: /Ogty
;	COMDAT ?Fork@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
tv181 = 8						; size = 4
_nLength$ = 8						; size = 4
?Fork@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z PROC NEAR	; ATL::CSimpleStringT<char,0>::Fork, COMDAT
; _this$ = ecx

; 715  : 	{

  00000	51		 push	 ecx
  00001	53		 push	 ebx

; 716  : 		CStringData* pOldData = GetData();

  00002	8b 19		 mov	 ebx, DWORD PTR [ecx]
  00004	83 eb 10	 sub	 ebx, 16			; 00000010H
  00007	55		 push	 ebp

; 717  : 		int nOldLength = pOldData->nDataLength;

  00008	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  0000b	89 4c 24 08	 mov	 DWORD PTR _this$[esp+12], ecx

; 718  : 		CStringData* pNewData = pOldData->pStringMgr->Clone()->Allocate( nLength, sizeof( XCHAR ) );

  0000f	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  00011	8b 01		 mov	 eax, DWORD PTR [ecx]
  00013	56		 push	 esi
  00014	ff 50 10	 call	 DWORD PTR [eax+16]
  00017	8b 74 24 14	 mov	 esi, DWORD PTR _nLength$[esp+12]
  0001b	8b 10		 mov	 edx, DWORD PTR [eax]
  0001d	6a 01		 push	 1
  0001f	56		 push	 esi
  00020	8b c8		 mov	 ecx, eax
  00022	ff 12		 call	 DWORD PTR [edx]

; 719  : 		if( pNewData == NULL )

  00024	85 c0		 test	 eax, eax
  00026	75 05		 jne	 SHORT $L222762

; 720  : 		{
; 721  : 			ThrowMemoryException();

  00028	e8 00 00 00 00	 call	 ?ThrowMemoryException@?$CSimpleStringT@D$0A@@ATL@@KAXXZ ; ATL::CSimpleStringT<char,0>::ThrowMemoryException
$L297625:
$L222762:

; 722  : 		}
; 723  : 		int nCharsToCopy = ((nOldLength < nLength) ? nOldLength : nLength)+1;  // Copy '\0'

  0002d	3b ee		 cmp	 ebp, esi
  0002f	7d 02		 jge	 SHORT $L297599
  00031	8b f5		 mov	 esi, ebp
$L297599:
  00033	8d 4e 01	 lea	 ecx, DWORD PTR [esi+1]

; 724  : 		CopyChars( PXSTR( pNewData->data() ), PCXSTR( pOldData->data() ), nCharsToCopy );

  00036	8b d1		 mov	 edx, ecx
  00038	57		 push	 edi
  00039	c1 e9 02	 shr	 ecx, 2
  0003c	8d 78 10	 lea	 edi, DWORD PTR [eax+16]
  0003f	89 7c 24 18	 mov	 DWORD PTR tv181[esp+16], edi
  00043	8d 73 10	 lea	 esi, DWORD PTR [ebx+16]
  00046	f3 a5		 rep movsd
  00048	8b ca		 mov	 ecx, edx
  0004a	83 e1 03	 and	 ecx, 3
  0004d	f3 a4		 rep movsb

; 725  : 		pNewData->nDataLength = nOldLength;

  0004f	89 68 04	 mov	 DWORD PTR [eax+4], ebp

; 726  : 		pOldData->Release();

  00052	8d 43 0c	 lea	 eax, DWORD PTR [ebx+12]
  00055	83 c9 ff	 or	 ecx, -1
  00058	f0 0f c1 08	 lock	  xadd	 DWORD PTR [eax], ecx
  0005c	49		 dec	 ecx
  0005d	85 c9		 test	 ecx, ecx
  0005f	5f		 pop	 edi
  00060	7f 08		 jg	 SHORT $L297615
  00062	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  00064	8b 11		 mov	 edx, DWORD PTR [ecx]
  00066	53		 push	 ebx
  00067	ff 52 04	 call	 DWORD PTR [edx+4]
$L297615:

; 727  : 		Attach( pNewData );

  0006a	8b 44 24 14	 mov	 eax, DWORD PTR tv181[esp+12]
  0006e	8b 4c 24 0c	 mov	 ecx, DWORD PTR _this$[esp+16]
  00072	5e		 pop	 esi
  00073	5d		 pop	 ebp
  00074	89 01		 mov	 DWORD PTR [ecx], eax
  00076	5b		 pop	 ebx

; 728  : 	}

  00077	59		 pop	 ecx
  00078	c2 04 00	 ret	 4
$L297624:
?Fork@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z ENDP		; ATL::CSimpleStringT<char,0>::Fork
_TEXT	ENDS
PUBLIC	?Reallocate@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z	; ATL::CSimpleStringT<char,0>::Reallocate
; Function compile flags: /Ogty
;	COMDAT ?Reallocate@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z
_TEXT	SEGMENT
_nLength$ = 8						; size = 4
?Reallocate@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z PROC NEAR ; ATL::CSimpleStringT<char,0>::Reallocate, COMDAT
; _this$ = ecx

; 776  : 	{

  00000	56		 push	 esi
  00001	57		 push	 edi

; 777  : 		CStringData* pOldData = GetData();
; 778  : 		ATLASSERT( pOldData->nAllocLength < nLength );
; 779  : 		IAtlStringMgr* pStringMgr = pOldData->pStringMgr;
; 780  : 		CStringData* pNewData = pStringMgr->Reallocate( pOldData, nLength, sizeof( XCHAR ) );

  00002	8b 7c 24 0c	 mov	 edi, DWORD PTR _nLength$[esp+4]
  00006	8b f1		 mov	 esi, ecx
  00008	8b 06		 mov	 eax, DWORD PTR [esi]
  0000a	8b 48 f0	 mov	 ecx, DWORD PTR [eax-16]
  0000d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000f	83 e8 10	 sub	 eax, 16			; 00000010H
  00012	6a 01		 push	 1
  00014	57		 push	 edi
  00015	50		 push	 eax
  00016	ff 52 08	 call	 DWORD PTR [edx+8]

; 781  : 		if( pNewData == NULL )

  00019	85 c0		 test	 eax, eax
  0001b	75 05		 jne	 SHORT $L222771

; 782  : 		{
; 783  : 			ThrowMemoryException();

  0001d	e8 00 00 00 00	 call	 ?ThrowMemoryException@?$CSimpleStringT@D$0A@@ATL@@KAXXZ ; ATL::CSimpleStringT<char,0>::ThrowMemoryException
$L297641:
$L222771:

; 784  : 		}
; 785  : 		Attach( pNewData );

  00022	83 c0 10	 add	 eax, 16			; 00000010H
  00025	5f		 pop	 edi
  00026	89 06		 mov	 DWORD PTR [esi], eax
  00028	5e		 pop	 esi

; 786  : 	}

  00029	c2 04 00	 ret	 4
$L297640:
?Reallocate@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z ENDP	; ATL::CSimpleStringT<char,0>::Reallocate
_TEXT	ENDS
PUBLIC	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NPBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NPBD@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside, COMDAT
; _this$ = ecx

; 1494 : 		{	// test if _Ptr points inside string

  00000	56		 push	 esi

; 1495 : 		if (_Ptr < _Myptr() || _Myptr() + _Mysize <= _Ptr)

  00001	8b 71 18	 mov	 esi, DWORD PTR [ecx+24]
  00004	83 fe 10	 cmp	 esi, 16			; 00000010H
  00007	57		 push	 edi
  00008	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  0000b	72 04		 jb	 SHORT $L297650
  0000d	8b 10		 mov	 edx, DWORD PTR [eax]
  0000f	eb 02		 jmp	 SHORT $L297651
$L297650:
  00011	8b d0		 mov	 edx, eax
$L297651:
  00013	8b 7c 24 0c	 mov	 edi, DWORD PTR __Ptr$[esp+4]
  00017	3b fa		 cmp	 edi, edx
  00019	72 17		 jb	 SHORT $L222788
  0001b	83 fe 10	 cmp	 esi, 16			; 00000010H
  0001e	72 02		 jb	 SHORT $L297658
  00020	8b 00		 mov	 eax, DWORD PTR [eax]
$L297658:
  00022	8b 49 14	 mov	 ecx, DWORD PTR [ecx+20]
  00025	03 c8		 add	 ecx, eax
  00027	3b cf		 cmp	 ecx, edi
  00029	76 07		 jbe	 SHORT $L222788
  0002b	5f		 pop	 edi

; 1497 : 		else
; 1498 : 			return (true);

  0002c	b0 01		 mov	 al, 1
  0002e	5e		 pop	 esi

; 1499 : 		}

  0002f	c2 04 00	 ret	 4
$L222788:
  00032	5f		 pop	 edi

; 1496 : 			return (false);	// don't ask

  00033	32 c0		 xor	 al, al
  00035	5e		 pop	 esi

; 1499 : 		}

  00036	c2 04 00	 ret	 4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NPBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
_TEXT	ENDS
PUBLIC	?_Color@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Color
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ?_Color@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Color@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Color, COMDAT

; 132  : 		return ((_Charref)(*_Pnode)._Color);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]
  00004	83 c0 14	 add	 eax, 20			; 00000014H

; 133  : 		}

  00007	c3		 ret	 0
?_Color@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Color
_TEXT	ENDS
PUBLIC	?_Left@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Left
; Function compile flags: /Ogty
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Left@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Left, COMDAT

; 147  : 		return ((_Nodepref)(*_Pnode)._Left);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]

; 148  : 		}

  00004	c3		 ret	 0
?_Left@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Left
_TEXT	ENDS
PUBLIC	?_Parent@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Parent
; Function compile flags: /Ogty
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Parent@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Parent, COMDAT

; 152  : 		return ((_Nodepref)(*_Pnode)._Parent);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]
  00004	83 c0 04	 add	 eax, 4

; 153  : 		}

  00007	c3		 ret	 0
?_Parent@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Parent
_TEXT	ENDS
PUBLIC	?_Lmost@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Lmost
; Function compile flags: /Ogty
;	COMDAT ?_Lmost@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Lmost@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Lmost, COMDAT
; _this$ = ecx

; 1005 : 		return (_Left(_Myhead));

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 1006 : 		}

  00003	c3		 ret	 0
?_Lmost@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Lmost
_TEXT	ENDS
PUBLIC	?_Max@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Max
; Function compile flags: /Ogty
;	COMDAT ?_Max@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Max@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Max, COMDAT

; 1035 : 		while (!_Isnil(_Right(_Pnode)))

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]
  00004	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00007	8a 51 15	 mov	 dl, BYTE PTR [ecx+21]
  0000a	84 d2		 test	 dl, dl
  0000c	75 0e		 jne	 SHORT $L222822
  0000e	8b ff		 npad	 2
$L222821:

; 1036 : 			_Pnode = _Right(_Pnode);

  00010	8b c1		 mov	 eax, ecx
  00012	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00015	8a 51 15	 mov	 dl, BYTE PTR [ecx+21]
  00018	84 d2		 test	 dl, dl
  0001a	74 f4		 je	 SHORT $L222821
$L222822:

; 1037 : 		return (_Pnode);
; 1038 : 		}

  0001c	c3		 ret	 0
?_Max@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Max
_TEXT	ENDS
PUBLIC	?_Min@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Min
; Function compile flags: /Ogty
;	COMDAT ?_Min@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Min@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Min, COMDAT

; 1042 : 		while (!_Isnil(_Left(_Pnode)))

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]
  00004	8b 08		 mov	 ecx, DWORD PTR [eax]
  00006	8a 51 15	 mov	 dl, BYTE PTR [ecx+21]
  00009	84 d2		 test	 dl, dl
  0000b	75 0e		 jne	 SHORT $L222826
  0000d	8d 49 00	 npad	 3
$L222825:

; 1043 : 			_Pnode = _Left(_Pnode);

  00010	8b c1		 mov	 eax, ecx
  00012	8b 08		 mov	 ecx, DWORD PTR [eax]
  00014	8a 51 15	 mov	 dl, BYTE PTR [ecx+21]
  00017	84 d2		 test	 dl, dl
  00019	74 f5		 je	 SHORT $L222825
$L222826:

; 1044 : 		return (_Pnode);
; 1045 : 		}

  0001b	c3		 ret	 0
?_Min@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Min
_TEXT	ENDS
PUBLIC	?_Root@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Root
; Function compile flags: /Ogty
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Root@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Root, COMDAT
; _this$ = ecx

; 1059 : 		return (_Parent(_Myhead));

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	83 c0 04	 add	 eax, 4

; 1060 : 		}

  00006	c3		 ret	 0
?_Root@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Root
_TEXT	ENDS
PUBLIC	?_Root@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Root
; Function compile flags: /Ogty
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Root@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Root, COMDAT
; _this$ = ecx

; 1064 : 		return (_Parent(_Myhead));

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	83 c0 04	 add	 eax, 4

; 1065 : 		}

  00006	c3		 ret	 0
?_Root@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Root
_TEXT	ENDS
PUBLIC	?_Rrotate@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Rrotate
; Function compile flags: /Ogty
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Wherenode$ = 8					; size = 4
?_Rrotate@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Rrotate, COMDAT
; _this$ = ecx

; 1069 : 		_Nodeptr _Pnode = _Left(_Wherenode);

  00000	8b 54 24 04	 mov	 edx, DWORD PTR __Wherenode$[esp-4]
  00004	8b 02		 mov	 eax, DWORD PTR [edx]
  00006	53		 push	 ebx
  00007	56		 push	 esi

; 1070 : 		_Left(_Wherenode) = _Right(_Pnode);

  00008	8b 70 08	 mov	 esi, DWORD PTR [eax+8]
  0000b	89 32		 mov	 DWORD PTR [edx], esi

; 1071 : 
; 1072 : 		if (!_Isnil(_Right(_Pnode)))

  0000d	8b 70 08	 mov	 esi, DWORD PTR [eax+8]
  00010	8a 5e 15	 mov	 bl, BYTE PTR [esi+21]
  00013	84 db		 test	 bl, bl
  00015	75 03		 jne	 SHORT $L222834

; 1073 : 			_Parent(_Right(_Pnode)) = _Wherenode;

  00017	89 56 04	 mov	 DWORD PTR [esi+4], edx
$L222834:

; 1074 : 		_Parent(_Pnode) = _Parent(_Wherenode);

  0001a	8b 72 04	 mov	 esi, DWORD PTR [edx+4]
  0001d	89 70 04	 mov	 DWORD PTR [eax+4], esi

; 1075 : 
; 1076 : 		if (_Wherenode == _Root())

  00020	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00023	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  00026	75 0e		 jne	 SHORT $L222835

; 1077 : 			_Root() = _Pnode;

  00028	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  0002b	5e		 pop	 esi

; 1082 : 
; 1083 : 		_Right(_Pnode) = _Wherenode;

  0002c	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 1084 : 		_Parent(_Wherenode) = _Pnode;

  0002f	89 42 04	 mov	 DWORD PTR [edx+4], eax
  00032	5b		 pop	 ebx

; 1085 : 		}

  00033	c2 04 00	 ret	 4
$L222835:

; 1078 : 		else if (_Wherenode == _Right(_Parent(_Wherenode)))

  00036	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00039	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  0003c	75 0e		 jne	 SHORT $L222837

; 1079 : 			_Right(_Parent(_Wherenode)) = _Pnode;

  0003e	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  00041	5e		 pop	 esi

; 1082 : 
; 1083 : 		_Right(_Pnode) = _Wherenode;

  00042	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 1084 : 		_Parent(_Wherenode) = _Pnode;

  00045	89 42 04	 mov	 DWORD PTR [edx+4], eax
  00048	5b		 pop	 ebx

; 1085 : 		}

  00049	c2 04 00	 ret	 4
$L222837:

; 1080 : 		else
; 1081 : 			_Left(_Parent(_Wherenode)) = _Pnode;

  0004c	89 01		 mov	 DWORD PTR [ecx], eax
  0004e	5e		 pop	 esi

; 1082 : 
; 1083 : 		_Right(_Pnode) = _Wherenode;

  0004f	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 1084 : 		_Parent(_Wherenode) = _Pnode;

  00052	89 42 04	 mov	 DWORD PTR [edx+4], eax
  00055	5b		 pop	 ebx

; 1085 : 		}

  00056	c2 04 00	 ret	 4
?_Rrotate@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Rrotate
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Node>::deallocate
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@I@Z PROC NEAR ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Node>::deallocate, COMDAT
; _this$ = ecx

; 132  : 		operator delete(_Ptr);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Ptr$[esp-4]
  00004	50		 push	 eax
  00005	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000a	59		 pop	 ecx

; 133  : 		}

  0000b	c2 08 00	 ret	 8
?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Node>::deallocate
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@K@std@@QBEIXZ		; std::allocator<unsigned long>::max_size
; Function compile flags: /Ogty
;	COMDAT ?max_size@?$allocator@K@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@K@std@@QBEIXZ PROC NEAR		; std::allocator<unsigned long>::max_size, COMDAT
; _this$ = ecx

; 157  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 158  : 		return (0 < _Count ? _Count : 1);

  00000	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 159  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@K@std@@QBEIXZ ENDP		; std::allocator<unsigned long>::max_size
_TEXT	ENDS
PUBLIC	??0const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::const_iterator::const_iterator
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAE@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::const_iterator::const_iterator, COMDAT
; _this$ = ecx

; 193  : 			{	// construct with null node pointer

  00000	8b c1		 mov	 eax, ecx
  00002	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 194  : 			}

  00008	c3		 ret	 0
??0const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::const_iterator::const_iterator
_TEXT	ENDS
PUBLIC	??0const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::const_iterator::const_iterator
; Function compile flags: /Ogty
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
??0const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::const_iterator::const_iterator, COMDAT
; _this$ = ecx

; 200  : 			{	// construct with node pointer _Pnode

  00000	8b c1		 mov	 eax, ecx
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Pnode$[esp-4]
  00006	89 08		 mov	 DWORD PTR [eax], ecx

; 201  : 			}

  00008	c2 04 00	 ret	 4
??0const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::const_iterator::const_iterator
_TEXT	ENDS
PUBLIC	?_Max@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::_Max
; Function compile flags: /Ogty
;	COMDAT ?_Max@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Max@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::_Max, COMDAT

; 1035 : 		while (!_Isnil(_Right(_Pnode)))

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]
  00004	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00007	8a 51 15	 mov	 dl, BYTE PTR [ecx+21]
  0000a	84 d2		 test	 dl, dl
  0000c	75 0e		 jne	 SHORT $L222887
  0000e	8b ff		 npad	 2
$L222886:

; 1036 : 			_Pnode = _Right(_Pnode);

  00010	8b c1		 mov	 eax, ecx
  00012	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00015	8a 51 15	 mov	 dl, BYTE PTR [ecx+21]
  00018	84 d2		 test	 dl, dl
  0001a	74 f4		 je	 SHORT $L222886
$L222887:

; 1037 : 		return (_Pnode);
; 1038 : 		}

  0001c	c3		 ret	 0
?_Max@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::_Max
_TEXT	ENDS
PUBLIC	?_Min@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::_Min
; Function compile flags: /Ogty
;	COMDAT ?_Min@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Min@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::_Min, COMDAT

; 1042 : 		while (!_Isnil(_Left(_Pnode)))

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]
  00004	8b 08		 mov	 ecx, DWORD PTR [eax]
  00006	8a 51 15	 mov	 dl, BYTE PTR [ecx+21]
  00009	84 d2		 test	 dl, dl
  0000b	75 0e		 jne	 SHORT $L222891
  0000d	8d 49 00	 npad	 3
$L222890:

; 1043 : 			_Pnode = _Left(_Pnode);

  00010	8b c1		 mov	 eax, ecx
  00012	8b 08		 mov	 ecx, DWORD PTR [eax]
  00014	8a 51 15	 mov	 dl, BYTE PTR [ecx+21]
  00017	84 d2		 test	 dl, dl
  00019	74 f5		 je	 SHORT $L222890
$L222891:

; 1044 : 		return (_Pnode);
; 1045 : 		}

  0001b	c3		 ret	 0
?_Min@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::_Min
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::_Node>::deallocate
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@I@Z PROC NEAR ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::_Node>::deallocate, COMDAT
; _this$ = ecx

; 132  : 		operator delete(_Ptr);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Ptr$[esp-4]
  00004	50		 push	 eax
  00005	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000a	59		 pop	 ecx

; 133  : 		}

  0000b	c2 08 00	 ret	 8
?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::_Node>::deallocate
_TEXT	ENDS
PUBLIC	?_Lmost@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Lmost
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ?_Lmost@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Lmost@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Lmost, COMDAT
; _this$ = ecx

; 1005 : 		return (_Left(_Myhead));

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 1006 : 		}

  00003	c3		 ret	 0
?_Lmost@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Lmost
_TEXT	ENDS
PUBLIC	?_Isnil@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::_Isnil
; Function compile flags: /Ogty
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Isnil@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::_Isnil, COMDAT

; 137  : 		return ((_Charref)(*_Pnode)._Isnil);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]
  00004	83 c0 15	 add	 eax, 21			; 00000015H

; 138  : 		}

  00007	c3		 ret	 0
?_Isnil@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::_Isnil
_TEXT	ENDS
PUBLIC	?_Left@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::_Left
; Function compile flags: /Ogty
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Left@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::_Left, COMDAT

; 147  : 		return ((_Nodepref)(*_Pnode)._Left);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]

; 148  : 		}

  00004	c3		 ret	 0
?_Left@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::_Left
_TEXT	ENDS
PUBLIC	?_Right@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::_Right
; Function compile flags: /Ogty
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Right@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::_Right, COMDAT

; 157  : 		return ((_Nodepref)(*_Pnode)._Right);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]
  00004	83 c0 08	 add	 eax, 8

; 158  : 		}

  00007	c3		 ret	 0
?_Right@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::_Right
_TEXT	ENDS
PUBLIC	??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@1@AB_N@Z ; std::pair<std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::iterator,bool>::pair<std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::iterator,bool>
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\utility
;	COMDAT ??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@1@AB_N@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@1@AB_N@Z PROC NEAR ; std::pair<std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::iterator,bool>::pair<std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::iterator,bool>, COMDAT
; _this$ = ecx

; 34   : 		{	// construct from specified values

  00000	8b c1		 mov	 eax, ecx
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Val1$[esp-4]
  00006	8b 11		 mov	 edx, DWORD PTR [ecx]
  00008	8b 4c 24 08	 mov	 ecx, DWORD PTR __Val2$[esp-4]
  0000c	89 10		 mov	 DWORD PTR [eax], edx
  0000e	8a 11		 mov	 dl, BYTE PTR [ecx]
  00010	88 50 04	 mov	 BYTE PTR [eax+4], dl

; 35   : 		}

  00013	c2 08 00	 ret	 8
??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@1@AB_N@Z ENDP ; std::pair<std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::iterator,bool>::pair<std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::iterator,bool>
_TEXT	ENDS
PUBLIC	??8const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::const_iterator::operator==
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::const_iterator::operator==, COMDAT
; _this$ = ecx

; 241  : 			return (_Ptr == _Right._Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Right$[esp-4]
  00006	2b 01		 sub	 eax, DWORD PTR [ecx]
  00008	f7 d8		 neg	 eax
  0000a	1b c0		 sbb	 eax, eax
  0000c	40		 inc	 eax

; 242  : 			}

  0000d	c2 04 00	 ret	 4
??8const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::const_iterator::operator==
_TEXT	ENDS
PUBLIC	??9const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::const_iterator::operator!=
; Function compile flags: /Ogty
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::const_iterator::operator!=, COMDAT
; _this$ = ecx

; 246  : 			return (!(*this == _Right));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 54 24 04	 mov	 edx, DWORD PTR __Right$[esp-4]
  00006	56		 push	 esi
  00007	8b 32		 mov	 esi, DWORD PTR [edx]
  00009	33 c9		 xor	 ecx, ecx
  0000b	3b c6		 cmp	 eax, esi
  0000d	0f 95 c1	 setne	 cl
  00010	8a c1		 mov	 al, cl
  00012	5e		 pop	 esi

; 247  : 			}

  00013	c2 04 00	 ret	 4
??9const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::const_iterator::operator!=
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@D@std@@QBEIXZ		; std::allocator<char>::max_size
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@D@std@@QBEIXZ PROC NEAR		; std::allocator<char>::max_size, COMDAT
; _this$ = ecx

; 157  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 158  : 		return (0 < _Count ? _Count : 1);

  00000	83 c8 ff	 or	 eax, -1

; 159  : 		}

  00003	c3		 ret	 0
?max_size@?$allocator@D@std@@QBEIXZ ENDP		; std::allocator<char>::max_size
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@std@@QBEIXZ ; std::allocator<std::pair<unsigned long const ,CUser *> >::max_size
; Function compile flags: /Ogty
;	COMDAT ?max_size@?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@std@@QBEIXZ PROC NEAR ; std::allocator<std::pair<unsigned long const ,CUser *> >::max_size, COMDAT
; _this$ = ecx

; 157  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 158  : 		return (0 < _Count ? _Count : 1);

  00000	b8 ff ff ff 1f	 mov	 eax, 536870911		; 1fffffffH

; 159  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@std@@QBEIXZ ENDP ; std::allocator<std::pair<unsigned long const ,CUser *> >::max_size
_TEXT	ENDS
PUBLIC	?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::const_iterator::_Dec
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAEXXZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::const_iterator::_Dec, COMDAT
; _this$ = ecx

; 251  : 			if (_Isnil(_Ptr))

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8a 50 15	 mov	 dl, BYTE PTR [eax+21]
  00005	84 d2		 test	 dl, dl
  00007	74 06		 je	 SHORT $L223616

; 252  : 				_Ptr = _Right(_Ptr);	// end() ==> rightmost

  00009	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0000c	89 01		 mov	 DWORD PTR [ecx], eax

; 263  : 				}
; 264  : 			}

  0000e	c3		 ret	 0
$L223616:

; 253  : 			else if (!_Isnil(_Left(_Ptr)))

  0000f	8b 10		 mov	 edx, DWORD PTR [eax]
  00011	53		 push	 ebx
  00012	8a 5a 15	 mov	 bl, BYTE PTR [edx+21]
  00015	84 db		 test	 bl, bl
  00017	75 1a		 jne	 SHORT $L297928

; 254  : 				_Ptr = _Max(_Left(_Ptr));	// ==> largest of left subtree

  00019	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0001c	8a 58 15	 mov	 bl, BYTE PTR [eax+21]
  0001f	84 db		 test	 bl, bl
  00021	75 0c		 jne	 SHORT $L297906
$L297905:
  00023	8b d0		 mov	 edx, eax
  00025	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00028	8a 58 15	 mov	 bl, BYTE PTR [eax+21]
  0002b	84 db		 test	 bl, bl
  0002d	74 f4		 je	 SHORT $L297905
$L297906:
  0002f	89 11		 mov	 DWORD PTR [ecx], edx
  00031	5b		 pop	 ebx

; 263  : 				}
; 264  : 			}

  00032	c3		 ret	 0
$L297928:

; 255  : 			else
; 256  : 				{	// climb looking for left subtree
; 257  : 				_Nodeptr _Pnode;
; 258  : 				while (!_Isnil(_Pnode = _Parent(_Ptr))
; 259  : 					&& _Ptr == _Left(_Pnode))

  00033	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00036	8a 50 15	 mov	 dl, BYTE PTR [eax+21]
  00039	84 d2		 test	 dl, dl
  0003b	75 1e		 jne	 SHORT $L297931
  0003d	8d 49 00	 npad	 3
$L223622:
  00040	8b 11		 mov	 edx, DWORD PTR [ecx]
  00042	3b 10		 cmp	 edx, DWORD PTR [eax]
  00044	75 0c		 jne	 SHORT $L223623

; 260  : 					_Ptr = _Pnode;	// ==> parent while left subtree

  00046	89 01		 mov	 DWORD PTR [ecx], eax
  00048	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0004b	8a 50 15	 mov	 dl, BYTE PTR [eax+21]
  0004e	84 d2		 test	 dl, dl
  00050	74 ee		 je	 SHORT $L223622
$L223623:

; 261  : 				if (!_Isnil(_Pnode))

  00052	8a 50 15	 mov	 dl, BYTE PTR [eax+21]
  00055	84 d2		 test	 dl, dl
  00057	75 02		 jne	 SHORT $L297931

; 262  : 					_Ptr = _Pnode;	// ==> parent if not head

  00059	89 01		 mov	 DWORD PTR [ecx], eax
$L297931:
  0005b	5b		 pop	 ebx

; 263  : 				}
; 264  : 			}

  0005c	c3		 ret	 0
?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::const_iterator::_Dec
_TEXT	ENDS
PUBLIC	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::const_iterator::_Inc
; Function compile flags: /Ogty
;	COMDAT ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAEXXZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::const_iterator::_Inc, COMDAT
; _this$ = ecx

; 268  : 			if (_Isnil(_Ptr))

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8a 50 15	 mov	 dl, BYTE PTR [eax+21]
  00005	84 d2		 test	 dl, dl
  00007	75 4d		 jne	 SHORT $L223630

; 269  : 				;	// end() shouldn't be incremented, don't move
; 270  : 			else if (!_Isnil(_Right(_Ptr)))

  00009	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0000c	53		 push	 ebx
  0000d	8a 5a 15	 mov	 bl, BYTE PTR [edx+21]
  00010	84 db		 test	 bl, bl
  00012	75 1b		 jne	 SHORT $L297979

; 271  : 				_Ptr = _Min(_Right(_Ptr));	// ==> smallest of right subtree

  00014	8b 02		 mov	 eax, DWORD PTR [edx]
  00016	8a 58 15	 mov	 bl, BYTE PTR [eax+21]
  00019	84 db		 test	 bl, bl
  0001b	75 0e		 jne	 SHORT $L297960
  0001d	8d 49 00	 npad	 3
$L297959:
  00020	8b d0		 mov	 edx, eax
  00022	8b 02		 mov	 eax, DWORD PTR [edx]
  00024	8a 58 15	 mov	 bl, BYTE PTR [eax+21]
  00027	84 db		 test	 bl, bl
  00029	74 f5		 je	 SHORT $L297959
$L297960:
  0002b	89 11		 mov	 DWORD PTR [ecx], edx
  0002d	5b		 pop	 ebx

; 279  : 				}
; 280  : 			}

  0002e	c3		 ret	 0
$L297979:

; 272  : 			else
; 273  : 				{	// climb looking for right subtree
; 274  : 				_Nodeptr _Pnode;
; 275  : 				while (!_Isnil(_Pnode = _Parent(_Ptr))
; 276  : 					&& _Ptr == _Right(_Pnode))

  0002f	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00032	8a 50 15	 mov	 dl, BYTE PTR [eax+21]
  00035	84 d2		 test	 dl, dl
  00037	75 1a		 jne	 SHORT $L223634
  00039	8d a4 24 00 00
	00 00		 npad	 7
$L223633:
  00040	8b 11		 mov	 edx, DWORD PTR [ecx]
  00042	3b 50 08	 cmp	 edx, DWORD PTR [eax+8]
  00045	75 0c		 jne	 SHORT $L223634

; 277  : 					_Ptr = _Pnode;	// ==> parent while right subtree

  00047	89 01		 mov	 DWORD PTR [ecx], eax
  00049	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0004c	8a 50 15	 mov	 dl, BYTE PTR [eax+21]
  0004f	84 d2		 test	 dl, dl
  00051	74 ed		 je	 SHORT $L223633
$L223634:

; 278  : 				_Ptr = _Pnode;	// ==> parent (head if end())

  00053	89 01		 mov	 DWORD PTR [ecx], eax
  00055	5b		 pop	 ebx
$L223630:

; 279  : 				}
; 280  : 			}

  00056	c3		 ret	 0
?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::const_iterator::_Inc
_TEXT	ENDS
PUBLIC	?_Color@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Color
; Function compile flags: /Ogty
;	COMDAT ?_Color@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Color@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Color, COMDAT

; 132  : 		return ((_Charref)(*_Pnode)._Color);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]
  00004	83 c0 14	 add	 eax, 20			; 00000014H

; 133  : 		}

  00007	c3		 ret	 0
?_Color@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Color
_TEXT	ENDS
PUBLIC	?_Isnil@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Isnil
; Function compile flags: /Ogty
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Isnil@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Isnil, COMDAT

; 137  : 		return ((_Charref)(*_Pnode)._Isnil);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]
  00004	83 c0 15	 add	 eax, 21			; 00000015H

; 138  : 		}

  00007	c3		 ret	 0
?_Isnil@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Isnil
_TEXT	ENDS
PUBLIC	?_Max@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Max
; Function compile flags: /Ogty
;	COMDAT ?_Max@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Max@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Max, COMDAT

; 1035 : 		while (!_Isnil(_Right(_Pnode)))

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]
  00004	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00007	8a 51 15	 mov	 dl, BYTE PTR [ecx+21]
  0000a	84 d2		 test	 dl, dl
  0000c	75 0e		 jne	 SHORT $L223658
  0000e	8b ff		 npad	 2
$L223657:

; 1036 : 			_Pnode = _Right(_Pnode);

  00010	8b c1		 mov	 eax, ecx
  00012	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00015	8a 51 15	 mov	 dl, BYTE PTR [ecx+21]
  00018	84 d2		 test	 dl, dl
  0001a	74 f4		 je	 SHORT $L223657
$L223658:

; 1037 : 		return (_Pnode);
; 1038 : 		}

  0001c	c3		 ret	 0
?_Max@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Max
_TEXT	ENDS
PUBLIC	?_Min@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Min
; Function compile flags: /Ogty
;	COMDAT ?_Min@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Min@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Min, COMDAT

; 1042 : 		while (!_Isnil(_Left(_Pnode)))

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]
  00004	8b 08		 mov	 ecx, DWORD PTR [eax]
  00006	8a 51 15	 mov	 dl, BYTE PTR [ecx+21]
  00009	84 d2		 test	 dl, dl
  0000b	75 0e		 jne	 SHORT $L223662
  0000d	8d 49 00	 npad	 3
$L223661:

; 1043 : 			_Pnode = _Left(_Pnode);

  00010	8b c1		 mov	 eax, ecx
  00012	8b 08		 mov	 ecx, DWORD PTR [eax]
  00014	8a 51 15	 mov	 dl, BYTE PTR [ecx+21]
  00017	84 d2		 test	 dl, dl
  00019	74 f5		 je	 SHORT $L223661
$L223662:

; 1044 : 		return (_Pnode);
; 1045 : 		}

  0001b	c3		 ret	 0
?_Min@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Min
_TEXT	ENDS
PUBLIC	?_Rmost@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Rmost
; Function compile flags: /Ogty
;	COMDAT ?_Rmost@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Rmost@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Rmost, COMDAT
; _this$ = ecx

; 1049 : 		return (_Right(_Myhead));

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	83 c0 08	 add	 eax, 8

; 1050 : 		}

  00006	c3		 ret	 0
?_Rmost@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Rmost
_TEXT	ENDS
PUBLIC	?_Root@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Root
; Function compile flags: /Ogty
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Root@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Root, COMDAT
; _this$ = ecx

; 1059 : 		return (_Parent(_Myhead));

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	83 c0 04	 add	 eax, 4

; 1060 : 		}

  00006	c3		 ret	 0
?_Root@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Root
_TEXT	ENDS
PUBLIC	?_Rrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Rrotate
; Function compile flags: /Ogty
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Wherenode$ = 8					; size = 4
?_Rrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Rrotate, COMDAT
; _this$ = ecx

; 1069 : 		_Nodeptr _Pnode = _Left(_Wherenode);

  00000	8b 54 24 04	 mov	 edx, DWORD PTR __Wherenode$[esp-4]
  00004	8b 02		 mov	 eax, DWORD PTR [edx]
  00006	53		 push	 ebx
  00007	56		 push	 esi

; 1070 : 		_Left(_Wherenode) = _Right(_Pnode);

  00008	8b 70 08	 mov	 esi, DWORD PTR [eax+8]
  0000b	89 32		 mov	 DWORD PTR [edx], esi

; 1071 : 
; 1072 : 		if (!_Isnil(_Right(_Pnode)))

  0000d	8b 70 08	 mov	 esi, DWORD PTR [eax+8]
  00010	8a 5e 15	 mov	 bl, BYTE PTR [esi+21]
  00013	84 db		 test	 bl, bl
  00015	75 03		 jne	 SHORT $L223670

; 1073 : 			_Parent(_Right(_Pnode)) = _Wherenode;

  00017	89 56 04	 mov	 DWORD PTR [esi+4], edx
$L223670:

; 1074 : 		_Parent(_Pnode) = _Parent(_Wherenode);

  0001a	8b 72 04	 mov	 esi, DWORD PTR [edx+4]
  0001d	89 70 04	 mov	 DWORD PTR [eax+4], esi

; 1075 : 
; 1076 : 		if (_Wherenode == _Root())

  00020	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00023	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  00026	75 0e		 jne	 SHORT $L223671

; 1077 : 			_Root() = _Pnode;

  00028	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  0002b	5e		 pop	 esi

; 1082 : 
; 1083 : 		_Right(_Pnode) = _Wherenode;

  0002c	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 1084 : 		_Parent(_Wherenode) = _Pnode;

  0002f	89 42 04	 mov	 DWORD PTR [edx+4], eax
  00032	5b		 pop	 ebx

; 1085 : 		}

  00033	c2 04 00	 ret	 4
$L223671:

; 1078 : 		else if (_Wherenode == _Right(_Parent(_Wherenode)))

  00036	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00039	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  0003c	75 0e		 jne	 SHORT $L223673

; 1079 : 			_Right(_Parent(_Wherenode)) = _Pnode;

  0003e	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  00041	5e		 pop	 esi

; 1082 : 
; 1083 : 		_Right(_Pnode) = _Wherenode;

  00042	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 1084 : 		_Parent(_Wherenode) = _Pnode;

  00045	89 42 04	 mov	 DWORD PTR [edx+4], eax
  00048	5b		 pop	 ebx

; 1085 : 		}

  00049	c2 04 00	 ret	 4
$L223673:

; 1080 : 		else
; 1081 : 			_Left(_Parent(_Wherenode)) = _Pnode;

  0004c	89 01		 mov	 DWORD PTR [ecx], eax
  0004e	5e		 pop	 esi

; 1082 : 
; 1083 : 		_Right(_Pnode) = _Wherenode;

  0004f	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 1084 : 		_Parent(_Wherenode) = _Pnode;

  00052	89 42 04	 mov	 DWORD PTR [edx+4], eax
  00055	5b		 pop	 ebx

; 1085 : 		}

  00056	c2 04 00	 ret	 4
?_Rrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Rrotate
_TEXT	ENDS
PUBLIC	?_Parent@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::_Parent
; Function compile flags: /Ogty
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Parent@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::_Parent, COMDAT

; 152  : 		return ((_Nodepref)(*_Pnode)._Parent);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]
  00004	83 c0 04	 add	 eax, 4

; 153  : 		}

  00007	c3		 ret	 0
?_Parent@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::_Parent
_TEXT	ENDS
PUBLIC	??0const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::const_iterator::const_iterator
; Function compile flags: /Ogty
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
??0const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::const_iterator::const_iterator, COMDAT
; _this$ = ecx

; 200  : 			{	// construct with node pointer _Pnode

  00000	8b c1		 mov	 eax, ecx
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Pnode$[esp-4]
  00006	89 08		 mov	 DWORD PTR [eax], ecx

; 201  : 			}

  00008	c2 04 00	 ret	 4
??0const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::const_iterator::const_iterator
_TEXT	ENDS
PUBLIC	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::const_iterator::_Mynode
; Function compile flags: /Ogty
;	COMDAT ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@3@XZ
_TEXT	SEGMENT
?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@3@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::const_iterator::_Mynode, COMDAT
; _this$ = ecx

; 284  : 			return (_Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 285  : 			}

  00002	c3		 ret	 0
?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@3@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::const_iterator::_Mynode
_TEXT	ENDS
PUBLIC	??0_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBKPAVCUser@@@2@D@Z ; std::_Tree_nod<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Node::_Node
; Function compile flags: /Ogty
;	COMDAT ??0_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBKPAVCUser@@@2@D@Z
_TEXT	SEGMENT
__Larg$ = 8						; size = 4
__Parg$ = 12						; size = 4
__Rarg$ = 16						; size = 4
__Val$ = 20						; size = 4
__Carg$ = 24						; size = 1
??0_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBKPAVCUser@@@2@D@Z PROC NEAR ; std::_Tree_nod<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Node::_Node, COMDAT
; _this$ = ecx

; 40   : 			{	// construct a node with value

  00000	8b 54 24 08	 mov	 edx, DWORD PTR __Parg$[esp-4]
  00004	8b c1		 mov	 eax, ecx
  00006	8b 4c 24 04	 mov	 ecx, DWORD PTR __Larg$[esp-4]
  0000a	89 08		 mov	 DWORD PTR [eax], ecx
  0000c	8b 4c 24 0c	 mov	 ecx, DWORD PTR __Rarg$[esp-4]
  00010	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  00013	8b 4c 24 10	 mov	 ecx, DWORD PTR __Val$[esp-4]
  00017	89 50 04	 mov	 DWORD PTR [eax+4], edx
  0001a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0001c	89 50 0c	 mov	 DWORD PTR [eax+12], edx
  0001f	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00022	8a 54 24 14	 mov	 dl, BYTE PTR __Carg$[esp-4]
  00026	89 48 10	 mov	 DWORD PTR [eax+16], ecx
  00029	88 50 14	 mov	 BYTE PTR [eax+20], dl
  0002c	c6 40 15 00	 mov	 BYTE PTR [eax+21], 0

; 41   : 			}

  00030	c2 14 00	 ret	 20			; 00000014H
??0_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBKPAVCUser@@@2@D@Z ENDP ; std::_Tree_nod<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Node::_Node
_TEXT	ENDS
PUBLIC	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::const_iterator::_Inc
; Function compile flags: /Ogty
;	COMDAT ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAEXXZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::const_iterator::_Inc, COMDAT
; _this$ = ecx

; 268  : 			if (_Isnil(_Ptr))

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8a 50 15	 mov	 dl, BYTE PTR [eax+21]
  00005	84 d2		 test	 dl, dl
  00007	75 4d		 jne	 SHORT $L223994

; 269  : 				;	// end() shouldn't be incremented, don't move
; 270  : 			else if (!_Isnil(_Right(_Ptr)))

  00009	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0000c	53		 push	 ebx
  0000d	8a 5a 15	 mov	 bl, BYTE PTR [edx+21]
  00010	84 db		 test	 bl, bl
  00012	75 1b		 jne	 SHORT $L298161

; 271  : 				_Ptr = _Min(_Right(_Ptr));	// ==> smallest of right subtree

  00014	8b 02		 mov	 eax, DWORD PTR [edx]
  00016	8a 58 15	 mov	 bl, BYTE PTR [eax+21]
  00019	84 db		 test	 bl, bl
  0001b	75 0e		 jne	 SHORT $L298149
  0001d	8d 49 00	 npad	 3
$L298148:
  00020	8b d0		 mov	 edx, eax
  00022	8b 02		 mov	 eax, DWORD PTR [edx]
  00024	8a 58 15	 mov	 bl, BYTE PTR [eax+21]
  00027	84 db		 test	 bl, bl
  00029	74 f5		 je	 SHORT $L298148
$L298149:
  0002b	89 11		 mov	 DWORD PTR [ecx], edx
  0002d	5b		 pop	 ebx

; 279  : 				}
; 280  : 			}

  0002e	c3		 ret	 0
$L298161:

; 272  : 			else
; 273  : 				{	// climb looking for right subtree
; 274  : 				_Nodeptr _Pnode;
; 275  : 				while (!_Isnil(_Pnode = _Parent(_Ptr))
; 276  : 					&& _Ptr == _Right(_Pnode))

  0002f	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00032	8a 50 15	 mov	 dl, BYTE PTR [eax+21]
  00035	84 d2		 test	 dl, dl
  00037	75 1a		 jne	 SHORT $L223998
  00039	8d a4 24 00 00
	00 00		 npad	 7
$L223997:
  00040	8b 11		 mov	 edx, DWORD PTR [ecx]
  00042	3b 50 08	 cmp	 edx, DWORD PTR [eax+8]
  00045	75 0c		 jne	 SHORT $L223998

; 277  : 					_Ptr = _Pnode;	// ==> parent while right subtree

  00047	89 01		 mov	 DWORD PTR [ecx], eax
  00049	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0004c	8a 50 15	 mov	 dl, BYTE PTR [eax+21]
  0004f	84 d2		 test	 dl, dl
  00051	74 ed		 je	 SHORT $L223997
$L223998:

; 278  : 				_Ptr = _Pnode;	// ==> parent (head if end())

  00053	89 01		 mov	 DWORD PTR [ecx], eax
  00055	5b		 pop	 ebx
$L223994:

; 279  : 				}
; 280  : 			}

  00056	c3		 ret	 0
?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::const_iterator::_Inc
_TEXT	ENDS
PUBLIC	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::const_iterator::_Inc
; Function compile flags: /Ogty
;	COMDAT ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEXXZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::const_iterator::_Inc, COMDAT
; _this$ = ecx

; 268  : 			if (_Isnil(_Ptr))

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8a 50 15	 mov	 dl, BYTE PTR [eax+21]
  00005	84 d2		 test	 dl, dl
  00007	75 4d		 jne	 SHORT $L224042

; 269  : 				;	// end() shouldn't be incremented, don't move
; 270  : 			else if (!_Isnil(_Right(_Ptr)))

  00009	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0000c	53		 push	 ebx
  0000d	8a 5a 15	 mov	 bl, BYTE PTR [edx+21]
  00010	84 db		 test	 bl, bl
  00012	75 1b		 jne	 SHORT $L298211

; 271  : 				_Ptr = _Min(_Right(_Ptr));	// ==> smallest of right subtree

  00014	8b 02		 mov	 eax, DWORD PTR [edx]
  00016	8a 58 15	 mov	 bl, BYTE PTR [eax+21]
  00019	84 db		 test	 bl, bl
  0001b	75 0e		 jne	 SHORT $L298199
  0001d	8d 49 00	 npad	 3
$L298198:
  00020	8b d0		 mov	 edx, eax
  00022	8b 02		 mov	 eax, DWORD PTR [edx]
  00024	8a 58 15	 mov	 bl, BYTE PTR [eax+21]
  00027	84 db		 test	 bl, bl
  00029	74 f5		 je	 SHORT $L298198
$L298199:
  0002b	89 11		 mov	 DWORD PTR [ecx], edx
  0002d	5b		 pop	 ebx

; 279  : 				}
; 280  : 			}

  0002e	c3		 ret	 0
$L298211:

; 272  : 			else
; 273  : 				{	// climb looking for right subtree
; 274  : 				_Nodeptr _Pnode;
; 275  : 				while (!_Isnil(_Pnode = _Parent(_Ptr))
; 276  : 					&& _Ptr == _Right(_Pnode))

  0002f	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00032	8a 50 15	 mov	 dl, BYTE PTR [eax+21]
  00035	84 d2		 test	 dl, dl
  00037	75 1a		 jne	 SHORT $L224046
  00039	8d a4 24 00 00
	00 00		 npad	 7
$L224045:
  00040	8b 11		 mov	 edx, DWORD PTR [ecx]
  00042	3b 50 08	 cmp	 edx, DWORD PTR [eax+8]
  00045	75 0c		 jne	 SHORT $L224046

; 277  : 					_Ptr = _Pnode;	// ==> parent while right subtree

  00047	89 01		 mov	 DWORD PTR [ecx], eax
  00049	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0004c	8a 50 15	 mov	 dl, BYTE PTR [eax+21]
  0004f	84 d2		 test	 dl, dl
  00051	74 ed		 je	 SHORT $L224045
$L224046:

; 278  : 				_Ptr = _Pnode;	// ==> parent (head if end())

  00053	89 01		 mov	 DWORD PTR [ecx], eax
  00055	5b		 pop	 ebx
$L224042:

; 279  : 				}
; 280  : 			}

  00056	c3		 ret	 0
?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::const_iterator::_Inc
_TEXT	ENDS
PUBLIC	?GetAt@?$CFixedArray@UItemProp@@@@QAEPAUItemProp@@K@Z ; CFixedArray<ItemProp>::GetAt
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\data.h
;	COMDAT ?GetAt@?$CFixedArray@UItemProp@@@@QAEPAUItemProp@@K@Z
_TEXT	SEGMENT
_dwIndex$ = 8						; size = 4
?GetAt@?$CFixedArray@UItemProp@@@@QAEPAUItemProp@@K@Z PROC NEAR ; CFixedArray<ItemProp>::GetAt, COMDAT
; _this$ = ecx

; 270  : 	if( dwIndex >= (DWORD)m_nMaxIndex )

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _dwIndex$[esp-4]
  00004	3b 41 18	 cmp	 eax, DWORD PTR [ecx+24]
  00007	72 05		 jb	 SHORT $L224299

; 271  : 		return NULL;

  00009	33 c0		 xor	 eax, eax

; 273  : }

  0000b	c2 04 00	 ret	 4
$L224299:

; 272  : 	return (T*) m_apOffset[ dwIndex ];

  0000e	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  00011	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]

; 273  : }

  00014	c2 04 00	 ret	 4
?GetAt@?$CFixedArray@UItemProp@@@@QAEPAUItemProp@@K@Z ENDP ; CFixedArray<ItemProp>::GetAt
_TEXT	ENDS
PUBLIC	?GetAt@?$CFixedArray@UtagColorText@@@@QAEPAUtagColorText@@K@Z ; CFixedArray<tagColorText>::GetAt
; Function compile flags: /Ogty
;	COMDAT ?GetAt@?$CFixedArray@UtagColorText@@@@QAEPAUtagColorText@@K@Z
_TEXT	SEGMENT
_dwIndex$ = 8						; size = 4
?GetAt@?$CFixedArray@UtagColorText@@@@QAEPAUtagColorText@@K@Z PROC NEAR ; CFixedArray<tagColorText>::GetAt, COMDAT
; _this$ = ecx

; 270  : 	if( dwIndex >= (DWORD)m_nMaxIndex )

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _dwIndex$[esp-4]
  00004	3b 41 18	 cmp	 eax, DWORD PTR [ecx+24]
  00007	72 05		 jb	 SHORT $L224363

; 271  : 		return NULL;

  00009	33 c0		 xor	 eax, eax

; 273  : }

  0000b	c2 04 00	 ret	 4
$L224363:

; 272  : 	return (T*) m_apOffset[ dwIndex ];

  0000e	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  00011	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]

; 273  : }

  00014	c2 04 00	 ret	 4
?GetAt@?$CFixedArray@UtagColorText@@@@QAEPAUtagColorText@@K@Z ENDP ; CFixedArray<tagColorText>::GetAt
_TEXT	ENDS
PUBLIC	?GetAt@?$CFixedArray@UQuestProp@@@@QAEPAUQuestProp@@K@Z ; CFixedArray<QuestProp>::GetAt
; Function compile flags: /Ogty
;	COMDAT ?GetAt@?$CFixedArray@UQuestProp@@@@QAEPAUQuestProp@@K@Z
_TEXT	SEGMENT
_dwIndex$ = 8						; size = 4
?GetAt@?$CFixedArray@UQuestProp@@@@QAEPAUQuestProp@@K@Z PROC NEAR ; CFixedArray<QuestProp>::GetAt, COMDAT
; _this$ = ecx

; 270  : 	if( dwIndex >= (DWORD)m_nMaxIndex )

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _dwIndex$[esp-4]
  00004	3b 41 18	 cmp	 eax, DWORD PTR [ecx+24]
  00007	72 05		 jb	 SHORT $L224391

; 271  : 		return NULL;

  00009	33 c0		 xor	 eax, eax

; 273  : }

  0000b	c2 04 00	 ret	 4
$L224391:

; 272  : 	return (T*) m_apOffset[ dwIndex ];

  0000e	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  00011	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]

; 273  : }

  00014	c2 04 00	 ret	 4
?GetAt@?$CFixedArray@UQuestProp@@@@QAEPAUQuestProp@@K@Z ENDP ; CFixedArray<QuestProp>::GetAt
_TEXT	ENDS
PUBLIC	?GetAtId@?$CItemContainer@VCItemElem@@@@QAEPAVCItemElem@@K@Z ; CItemContainer<CItemElem>::GetAtId
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\item.h
;	COMDAT ?GetAtId@?$CItemContainer@VCItemElem@@@@QAEPAVCItemElem@@K@Z
_TEXT	SEGMENT
_dwId$ = 8						; size = 4
?GetAtId@?$CItemContainer@VCItemElem@@@@QAEPAVCItemElem@@K@Z PROC NEAR ; CItemContainer<CItemElem>::GetAtId, COMDAT
; _this$ = ecx

; 518  : 	if( dwId >= (DWORD)( GetMax() ) ) return NULL;

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _dwId$[esp-4]
  00004	3b 41 0c	 cmp	 eax, DWORD PTR [ecx+12]
  00007	72 05		 jb	 SHORT $L224421
  00009	33 c0		 xor	 eax, eax

; 521  : 		return NULL;
; 522  : 	return pItemElem;
; 523  : }

  0000b	c2 04 00	 ret	 4
$L224421:

; 519  : 	T* pItemElem = &m_apItem[ dwId ];

  0000e	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00011	69 c0 b8 00 00
	00		 imul	 eax, 184		; 000000b8H
  00017	03 c2		 add	 eax, edx
  00019	8b c8		 mov	 ecx, eax

; 520  : 	if( pItemElem->IsEmpty() ) 

  0001b	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  0001e	f7 d8		 neg	 eax
  00020	1b c0		 sbb	 eax, eax
  00022	23 c1		 and	 eax, ecx

; 521  : 		return NULL;
; 522  : 	return pItemElem;
; 523  : }

  00024	c2 04 00	 ret	 4
?GetAtId@?$CItemContainer@VCItemElem@@@@QAEPAVCItemElem@@K@Z ENDP ; CItemContainer<CItemElem>::GetAtId
_TEXT	ENDS
PUBLIC	??$swap@D@std@@YAXAAD0@Z			; std::swap<char>
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\utility
;	COMDAT ??$swap@D@std@@YAXAAD0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@D@std@@YAXAAD0@Z PROC NEAR			; std::swap<char>, COMDAT

; 15   : 	_Ty _Tmp = _Left;

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Left$[esp-4]
  00004	8a 08		 mov	 cl, BYTE PTR [eax]
  00006	56		 push	 esi

; 16   : 	_Left = _Right, _Right = _Tmp;

  00007	8b 74 24 0c	 mov	 esi, DWORD PTR __Right$[esp]
  0000b	8a 16		 mov	 dl, BYTE PTR [esi]
  0000d	88 10		 mov	 BYTE PTR [eax], dl
  0000f	88 0e		 mov	 BYTE PTR [esi], cl
  00011	5e		 pop	 esi

; 17   : 	}

  00012	c3		 ret	 0
??$swap@D@std@@YAXAAD0@Z ENDP				; std::swap<char>
_TEXT	ENDS
PUBLIC	??$_Allocate@K@std@@YAPAKIPAK@Z			; std::_Allocate<unsigned long>
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??$_Allocate@K@std@@YAPAKIPAK@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@K@std@@YAPAKIPAK@Z PROC NEAR		; std::_Allocate<unsigned long>, COMDAT

; 34   : 	return ((_Ty _FARQ *)operator new(_Count * sizeof (_Ty)));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Count$[esp-4]
  00004	8d 0c 85 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*4]
  0000b	51		 push	 ecx
  0000c	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00011	83 c4 04	 add	 esp, 4

; 35   : 	}

  00014	c3		 ret	 0
??$_Allocate@K@std@@YAPAKIPAK@Z ENDP			; std::_Allocate<unsigned long>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@KV?$allocator@K@std@@@std@@YAXPAK0AAV?$allocator@K@0@@Z ; std::_Destroy_range<unsigned long,std::allocator<unsigned long> >
; Function compile flags: /Ogty
;	COMDAT ??$_Destroy_range@KV?$allocator@K@std@@@std@@YAXPAK0AAV?$allocator@K@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@KV?$allocator@K@std@@@std@@YAXPAK0AAV?$allocator@K@0@@Z PROC NEAR ; std::_Destroy_range<unsigned long,std::allocator<unsigned long> >, COMDAT

; 217  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 218  : 	}

  00000	c3		 ret	 0
??$_Destroy_range@KV?$allocator@K@std@@@std@@YAXPAK0AAV?$allocator@K@0@@Z ENDP ; std::_Destroy_range<unsigned long,std::allocator<unsigned long> >
_TEXT	ENDS
PUBLIC	??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@0@@Z ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node *>
; Function compile flags: /Ogty
;	COMDAT ??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@0@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@0@@Z PROC NEAR ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node *>, COMDAT

; 49   : 	_DESTRUCTOR(_Ty, _Ptr);
; 50   : 	}

  00000	c3		 ret	 0
??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@0@@Z ENDP ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@EV?$allocator@E@std@@@std@@YAXPAE0AAV?$allocator@E@0@@Z ; std::_Destroy_range<unsigned char,std::allocator<unsigned char> >
; Function compile flags: /Ogty
;	COMDAT ??$_Destroy_range@EV?$allocator@E@std@@@std@@YAXPAE0AAV?$allocator@E@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@EV?$allocator@E@std@@@std@@YAXPAE0AAV?$allocator@E@0@@Z PROC NEAR ; std::_Destroy_range<unsigned char,std::allocator<unsigned char> >, COMDAT

; 217  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 218  : 	}

  00000	c3		 ret	 0
??$_Destroy_range@EV?$allocator@E@std@@@std@@YAXPAE0AAV?$allocator@E@0@@Z ENDP ; std::_Destroy_range<unsigned char,std::allocator<unsigned char> >
_TEXT	ENDS
PUBLIC	??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@0@@Z ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Node>
; Function compile flags: /Ogty
;	COMDAT ??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@0@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@0@@Z PROC NEAR ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Node>, COMDAT

; 49   : 	_DESTRUCTOR(_Ty, _Ptr);
; 50   : 	}

  00000	c3		 ret	 0
??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@0@@Z ENDP ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Node>
_TEXT	ENDS
PUBLIC	??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::_Node>
; Function compile flags: /Ogty
;	COMDAT ??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@0@IPAU120@@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@0@IPAU120@@Z PROC NEAR ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::_Node>, COMDAT

; 34   : 	return ((_Ty _FARQ *)operator new(_Count * sizeof (_Ty)));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Count$[esp-4]
  00004	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00007	c1 e0 03	 shl	 eax, 3
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00010	83 c4 04	 add	 esp, 4

; 35   : 	}

  00013	c3		 ret	 0
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@0@IPAU120@@Z ENDP ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::_Node>
_TEXT	ENDS
PUBLIC	??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@0@@Z ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::_Node>
; Function compile flags: /Ogty
;	COMDAT ??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@0@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@0@@Z PROC NEAR ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::_Node>, COMDAT

; 49   : 	_DESTRUCTOR(_Ty, _Ptr);
; 50   : 	}

  00000	c3		 ret	 0
??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@0@@Z ENDP ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::_Node>
_TEXT	ENDS
PUBLIC	??$_Allocate@D@std@@YAPADIPAD@Z			; std::_Allocate<char>
; Function compile flags: /Ogty
;	COMDAT ??$_Allocate@D@std@@YAPADIPAD@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@D@std@@YAPADIPAD@Z PROC NEAR		; std::_Allocate<char>, COMDAT

; 34   : 	return ((_Ty _FARQ *)operator new(_Count * sizeof (_Ty)));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Count$[esp-4]
  00004	50		 push	 eax
  00005	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0000a	83 c4 04	 add	 esp, 4

; 35   : 	}

  0000d	c3		 ret	 0
??$_Allocate@D@std@@YAPADIPAD@Z ENDP			; std::_Allocate<char>
_TEXT	ENDS
PUBLIC	??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Node>
; Function compile flags: /Ogty
;	COMDAT ??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@0@IPAU120@@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@0@IPAU120@@Z PROC NEAR ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Node>, COMDAT

; 34   : 	return ((_Ty _FARQ *)operator new(_Count * sizeof (_Ty)));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Count$[esp-4]
  00004	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00007	c1 e0 03	 shl	 eax, 3
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00010	83 c4 04	 add	 esp, 4

; 35   : 	}

  00013	c3		 ret	 0
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@0@IPAU120@@Z ENDP ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Node>
_TEXT	ENDS
PUBLIC	??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@0@@Z ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node>
; Function compile flags: /Ogty
;	COMDAT ??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@0@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@0@@Z PROC NEAR ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node>, COMDAT

; 49   : 	_DESTRUCTOR(_Ty, _Ptr);
; 50   : 	}

  00000	c3		 ret	 0
??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@0@@Z ENDP ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node>
_TEXT	ENDS
PUBLIC	?Serialize@CGuildRank@@QAEXAAVCAr@@@Z		; CGuildRank::Serialize
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\guild.h
;	COMDAT ?Serialize@CGuildRank@@QAEXAAVCAr@@@Z
_TEXT	SEGMENT
_ar$ = 8						; size = 4
?Serialize@CGuildRank@@QAEXAAVCAr@@@Z PROC NEAR		; CGuildRank::Serialize, COMDAT
; _this$ = ecx

; 552  : 	{

  00000	53		 push	 ebx
  00001	55		 push	 ebp
  00002	56		 push	 esi

; 553  : #if !defined(__WORLDSERVER) && !defined(__CLIENT)
; 554  : 		m_Lock.Enter( theLineFile );
; 555  : #endif
; 556  : 
; 557  : 		if( ar.IsStoring() )

  00003	8b 74 24 10	 mov	 esi, DWORD PTR _ar$[esp+8]
  00007	33 c0		 xor	 eax, eax
  00009	8a 06		 mov	 al, BYTE PTR [esi]
  0000b	57		 push	 edi
  0000c	8b f9		 mov	 edi, ecx
  0000e	f7 d0		 not	 eax
  00010	a8 01		 test	 al, 1
  00012	74 57		 je	 SHORT $L237468

; 558  : 		{
; 559  : 			ar << m_Version;

  00014	8b 9f a0 2f 00
	00		 mov	 ebx, DWORD PTR [edi+12192]
  0001a	6a 04		 push	 4
  0001c	8b ce		 mov	 ecx, esi
  0001e	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00023	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00026	89 19		 mov	 DWORD PTR [ecx], ebx
  00028	8b 56 08	 mov	 edx, DWORD PTR [esi+8]

; 560  : 			ar.Write( m_Total, sizeof(int)*RANK_END );

  0002b	6a 20		 push	 32			; 00000020H
  0002d	83 c2 04	 add	 edx, 4
  00030	8d 9f 80 2f 00
	00		 lea	 ebx, DWORD PTR [edi+12160]
  00036	53		 push	 ebx
  00037	8b ce		 mov	 ecx, esi
  00039	89 56 08	 mov	 DWORD PTR [esi+8], edx
  0003c	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
  00041	bd 08 00 00 00	 mov	 ebp, 8
$L237471:

; 561  : 			for ( int i=R1; i<RANK_END; i++ )
; 562  : 			{
; 563  : 				if ( m_Total[i] )

  00046	8b 03		 mov	 eax, DWORD PTR [ebx]
  00048	85 c0		 test	 eax, eax
  0004a	74 0c		 je	 SHORT $L237472

; 564  : 				{
; 565  : 					ar.Write( m_Ranking[i], sizeof(GUILD_RANKING)*m_Total[i] );

  0004c	6b c0 4c	 imul	 eax, 76			; 0000004cH
  0004f	50		 push	 eax
  00050	57		 push	 edi
  00051	8b ce		 mov	 ecx, esi
  00053	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
$L237472:
  00058	83 c3 04	 add	 ebx, 4
  0005b	81 c7 f0 05 00
	00		 add	 edi, 1520		; 000005f0H
  00061	4d		 dec	 ebp
  00062	75 e2		 jne	 SHORT $L237471
  00064	5f		 pop	 edi
  00065	5e		 pop	 esi
  00066	5d		 pop	 ebp
  00067	5b		 pop	 ebx

; 578  : 				}
; 579  : 			}
; 580  : 		}
; 581  : 
; 582  : #if !defined(__WORLDSERVER) && !defined(__CLIENT)
; 583  : 		m_Lock.Leave( theLineFile );
; 584  : #endif	// __WORLDSERVER
; 585  : 	}

  00068	c2 04 00	 ret	 4
$L237468:

; 566  : 				}
; 567  : 			}
; 568  : 		}
; 569  : 		else
; 570  : 		{
; 571  : 			ar >> m_Version;

  0006b	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0006e	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  00071	8d 50 04	 lea	 edx, DWORD PTR [eax+4]
  00074	3b d1		 cmp	 edx, ecx
  00076	77 0e		 ja	 SHORT $L298296
  00078	8b 00		 mov	 eax, DWORD PTR [eax]
  0007a	89 87 a0 2f 00
	00		 mov	 DWORD PTR [edi+12192], eax
  00080	83 46 08 04	 add	 DWORD PTR [esi+8], 4
  00084	eb 10		 jmp	 SHORT $L298297
$L298296:
  00086	c7 87 a0 2f 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+12192], 0
  00090	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  00093	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
$L298297:

; 572  : 			ar.Read( m_Total, sizeof(int)*RANK_END );

  00096	6a 20		 push	 32			; 00000020H
  00098	8d 9f 80 2f 00
	00		 lea	 ebx, DWORD PTR [edi+12160]
  0009e	53		 push	 ebx
  0009f	8b ce		 mov	 ecx, esi
  000a1	e8 00 00 00 00	 call	 ?Read@CAr@@QAEXPAXI@Z	; CAr::Read
  000a6	bd 08 00 00 00	 mov	 ebp, 8
  000ab	eb 03 8d 49 00	 npad	 5
$L237479:

; 573  : 			for ( int i=R1; i<RANK_END; i++ )
; 574  : 			{
; 575  : 				if ( m_Total[i] )

  000b0	8b 03		 mov	 eax, DWORD PTR [ebx]
  000b2	85 c0		 test	 eax, eax
  000b4	74 0c		 je	 SHORT $L237480

; 576  : 				{
; 577  : 					ar.Read( m_Ranking[i], sizeof(GUILD_RANKING)*m_Total[i] );

  000b6	6b c0 4c	 imul	 eax, 76			; 0000004cH
  000b9	50		 push	 eax
  000ba	57		 push	 edi
  000bb	8b ce		 mov	 ecx, esi
  000bd	e8 00 00 00 00	 call	 ?Read@CAr@@QAEXPAXI@Z	; CAr::Read
$L237480:
  000c2	83 c3 04	 add	 ebx, 4
  000c5	81 c7 f0 05 00
	00		 add	 edi, 1520		; 000005f0H
  000cb	4d		 dec	 ebp
  000cc	75 e2		 jne	 SHORT $L237479
  000ce	5f		 pop	 edi
  000cf	5e		 pop	 esi
  000d0	5d		 pop	 ebp
  000d1	5b		 pop	 ebx

; 578  : 				}
; 579  : 			}
; 580  : 		}
; 581  : 
; 582  : #if !defined(__WORLDSERVER) && !defined(__CLIENT)
; 583  : 		m_Lock.Leave( theLineFile );
; 584  : #endif	// __WORLDSERVER
; 585  : 	}

  000d2	c2 04 00	 ret	 4
?Serialize@CGuildRank@@QAEXAAVCAr@@@Z ENDP		; CGuildRank::Serialize
_TEXT	ENDS
PUBLIC	?GetApplicantNum@CRainbowRaceMng@@QAEHXZ	; CRainbowRaceMng::GetApplicantNum
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\rainbowrace.h
;	COMDAT ?GetApplicantNum@CRainbowRaceMng@@QAEHXZ
_TEXT	SEGMENT
?GetApplicantNum@CRainbowRaceMng@@QAEHXZ PROC NEAR	; CRainbowRaceMng::GetApplicantNum, COMDAT
; _this$ = ecx

; 85   : 	int				GetApplicantNum() { return m_mapRainbowRace.size(); }	//   

  00000	8b 41 18	 mov	 eax, DWORD PTR [ecx+24]
  00003	c3		 ret	 0
?GetApplicantNum@CRainbowRaceMng@@QAEHXZ ENDP		; CRainbowRaceMng::GetApplicantNum
_TEXT	ENDS
PUBLIC	__real@3c23d70a
PUBLIC	?SetIncRestPoint@CUser@@QAEHH@Z			; CUser::SetIncRestPoint
EXTRN	?GetParam@CMover@@QAEHHH@Z:NEAR			; CMover::GetParam
;	COMDAT __real@3c23d70a
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.h
CONST	SEGMENT
__real@3c23d70a DD 03c23d70ar			; 0.01
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ?SetIncRestPoint@CUser@@QAEHH@Z
_TEXT	SEGMENT
tv81 = -4						; size = 4
_nRestPoint$ = 8					; size = 4
?SetIncRestPoint@CUser@@QAEHH@Z PROC NEAR		; CUser::SetIncRestPoint, COMDAT
; _this$ = ecx

; 731  : 	int		SetIncRestPoint( int nRestPoint )	{ return SetAddRestPoint( (int)( nRestPoint * static_cast<float>( GetParam( DST_RESTPOINT_RATE, 0 ) / 100.0f ) ) ); }

  00000	51		 push	 ecx
  00001	56		 push	 esi
  00002	6a 00		 push	 0
  00004	6a 5d		 push	 93			; 0000005dH
  00006	8b f1		 mov	 esi, ecx
  00008	e8 00 00 00 00	 call	 ?GetParam@CMover@@QAEHHH@Z ; CMover::GetParam
  0000d	89 44 24 04	 mov	 DWORD PTR tv81[esp+8], eax
  00011	db 44 24 04	 fild	 DWORD PTR tv81[esp+8]
  00015	da 4c 24 0c	 fimul	 DWORD PTR _nRestPoint$[esp+4]
  00019	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3c23d70a
  0001f	e8 00 00 00 00	 call	 __ftol2
  00024	50		 push	 eax
  00025	8b ce		 mov	 ecx, esi
  00027	e8 00 00 00 00	 call	 ?SetAddRestPoint@CUser@@AAEHH@Z ; CUser::SetAddRestPoint
  0002c	5e		 pop	 esi
  0002d	59		 pop	 ecx
  0002e	c2 04 00	 ret	 4
?SetIncRestPoint@CUser@@QAEHH@Z ENDP			; CUser::SetIncRestPoint
_TEXT	ENDS
PUBLIC	?SetDecRestPoint@CUser@@QAEHH@Z			; CUser::SetDecRestPoint
; Function compile flags: /Ogty
;	COMDAT ?SetDecRestPoint@CUser@@QAEHH@Z
_TEXT	SEGMENT
_nRestPoint$ = 8					; size = 4
?SetDecRestPoint@CUser@@QAEHH@Z PROC NEAR		; CUser::SetDecRestPoint, COMDAT
; _this$ = ecx

; 732  : 	int		SetDecRestPoint( int nRestPoint )	{ return SetAddRestPoint( -nRestPoint ); }

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _nRestPoint$[esp-4]
  00004	f7 d8		 neg	 eax
  00006	89 44 24 04	 mov	 DWORD PTR _nRestPoint$[esp-4], eax
  0000a	e9 00 00 00 00	 jmp	 ?SetAddRestPoint@CUser@@AAEHH@Z ; CUser::SetAddRestPoint
?SetDecRestPoint@CUser@@QAEHH@Z ENDP			; CUser::SetDecRestPoint
_TEXT	ENDS
PUBLIC	?SetRestPointTick@CUser@@QAEXXZ			; CUser::SetRestPointTick
; Function compile flags: /Ogty
;	COMDAT ?SetRestPointTick@CUser@@QAEXXZ
_TEXT	SEGMENT
?SetRestPointTick@CUser@@QAEXXZ PROC NEAR		; CUser::SetRestPointTick, COMDAT
; _this$ = ecx

; 734  : 	void	SetRestPointTick()					{ m_tRestPointTick = time_null() + REST_POINT_TICK; }

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_tCurrent@@3JA ; g_tCurrent
  00005	05 f0 00 00 00	 add	 eax, 240		; 000000f0H
  0000a	89 81 b0 96 00
	00		 mov	 DWORD PTR [ecx+38576], eax
  00010	c3		 ret	 0
?SetRestPointTick@CUser@@QAEXXZ ENDP			; CUser::SetRestPointTick
_TEXT	ENDS
PUBLIC	?GetTickCount@CTime@ATL@@SG?AV12@XZ		; ATL::CTime::GetTickCount
EXTRN	__time64:NEAR
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atltime.inl
;	COMDAT ?GetTickCount@CTime@ATL@@SG?AV12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?GetTickCount@CTime@ATL@@SG?AV12@XZ PROC NEAR		; ATL::CTime::GetTickCount, COMDAT

; 139  : 	return( CTime( ::_time64( NULL ) ) );

  00000	6a 00		 push	 0
  00002	e8 00 00 00 00	 call	 __time64
  00007	8b 4c 24 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[esp]
  0000b	89 01		 mov	 DWORD PTR [ecx], eax
  0000d	83 c4 04	 add	 esp, 4
  00010	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  00013	8b c1		 mov	 eax, ecx

; 140  : }

  00015	c2 04 00	 ret	 4
?GetTickCount@CTime@ATL@@SG?AV12@XZ ENDP		; ATL::CTime::GetTickCount
_TEXT	ENDS
PUBLIC	?IsValid@CUser@@QAEHXZ				; CUser::IsValid
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
;	COMDAT ?IsValid@CUser@@QAEHXZ
_TEXT	SEGMENT
?IsValid@CUser@@QAEHXZ PROC NEAR			; CUser::IsValid, COMDAT
; _this$ = ecx

; 126  : 	if( IsDelete() )

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	74 03		 je	 SHORT $L277872

; 127  : 		return FALSE;

  00006	33 c0		 xor	 eax, eax

; 130  : }

  00008	c3		 ret	 0
$L277872:

; 128  : 	else
; 129  : 		return m_bValid;

  00009	8b 81 e8 16 00
	00		 mov	 eax, DWORD PTR [ecx+5864]

; 130  : }

  0000f	c3		 ret	 0
?IsValid@CUser@@QAEHXZ ENDP				; CUser::IsValid
_TEXT	ENDS
PUBLIC	?Init@CUser@@AAEXKK@Z				; CUser::Init
EXTRN	__imp__timeGetTime@0:NEAR
; Function compile flags: /Ogty
;	COMDAT ?Init@CUser@@AAEXKK@Z
_TEXT	SEGMENT
$T298341 = -12						; size = 12
_dpidCache$ = 8						; size = 4
_dpidUser$ = 12						; size = 4
?Init@CUser@@AAEXKK@Z PROC NEAR				; CUser::Init, COMDAT
; _this$ = ecx

; 133  : {

  00000	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 134  : 	CMover::m_bPlayer	= TRUE;
; 135  : 
; 136  : 	
; 137  : 	//////////////////////////////////////////////////////////////////////////
; 138  : 	m_bCheckTransMailBox = FALSE;
; 139  : 	m_nCountFromClient = 0;
; 140  : 	m_dwTickFromClient = 0;
; 141  : 	//////////////////////////////////////////////////////////////////////////
; 142  : 
; 143  : 
; 144  : 	m_dwSerial = 0;	
; 145  : 	m_bValid = FALSE;
; 146  : 	m_Snapshot.dpidCache = dpidCache;

  00003	8b 44 24 10	 mov	 eax, DWORD PTR _dpidCache$[esp+8]
  00007	53		 push	 ebx
  00008	33 db		 xor	 ebx, ebx
  0000a	56		 push	 esi
  0000b	8b f1		 mov	 esi, ecx

; 147  : 	m_Snapshot.dpidUser  = dpidUser;

  0000d	8b 4c 24 1c	 mov	 ecx, DWORD PTR _dpidUser$[esp+16]
  00011	89 86 f0 16 00
	00		 mov	 DWORD PTR [esi+5872], eax
  00017	89 8e f4 16 00
	00		 mov	 DWORD PTR [esi+5876], ecx
  0001d	c7 86 34 02 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+564], 1
  00027	89 9e d8 16 00
	00		 mov	 DWORD PTR [esi+5848], ebx
  0002d	89 9e dc 16 00
	00		 mov	 DWORD PTR [esi+5852], ebx
  00033	89 9e e0 16 00
	00		 mov	 DWORD PTR [esi+5856], ebx
  00039	89 9e e4 16 00
	00		 mov	 DWORD PTR [esi+5860], ebx
  0003f	89 9e e8 16 00
	00		 mov	 DWORD PTR [esi+5864], ebx

; 148  : 
; 149  : 	m_dwAuthKey		= 0;

  00045	89 9e 34 57 00
	00		 mov	 DWORD PTR [esi+22324], ebx

; 150  : 	m_idSetTarget	= NULL_ID;

  0004b	c7 86 48 95 00
	00 ff ff ff ff	 mov	 DWORD PTR [esi+38216], -1

; 151  : 	m_nOverHeal		= 0;

  00055	89 9e 88 95 00
	00		 mov	 DWORD PTR [esi+38280], ebx

; 152  : 	*m_szPartyName	= '\0';

  0005b	88 9e 60 95 00
	00		 mov	 BYTE PTR [esi+38240], bl

; 153  : 
; 154  : 	memset( (void*)m_szBankPass, 0, sizeof(char) * 5 );

  00061	33 d2		 xor	 edx, edx
  00063	8d 86 80 95 00
	00		 lea	 eax, DWORD PTR [esi+38272]
  00069	89 10		 mov	 DWORD PTR [eax], edx
  0006b	88 50 04	 mov	 BYTE PTR [eax+4], dl

; 155  : 	memset( &m_playAccount, 0, sizeof(PLAY_ACCOUNT) );

  0006e	33 c0		 xor	 eax, eax
  00070	57		 push	 edi
  00071	b9 11 00 00 00	 mov	 ecx, 17			; 00000011H
  00076	8d be 38 57 00
	00		 lea	 edi, DWORD PTR [esi+22328]
  0007c	f3 ab		 rep stosd

; 156  : 
; 157  : 
; 158  : //	m_idTargetCollect = NULL_ID;	
; 159  : //	m_nCollect = 0;					
; 160  : //	m_tmCollect = 0;
; 161  : 	m_idChatting = 0;

  0007e	89 9e 98 95 00
	00		 mov	 DWORD PTR [esi+38296], ebx

; 162  : 	memset( m_pWall, 0, sizeof(m_pWall) );

  00084	33 c9		 xor	 ecx, ecx
  00086	8d 96 8c 95 00
	00		 lea	 edx, DWORD PTR [esi+38284]
  0008c	89 0a		 mov	 DWORD PTR [edx], ecx
  0008e	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 163  : 	m_dwLeavePenatyTime = 0;
; 164  : 	m_dwDestroyTime = 0;
; 165  : 	m_tmEscape = 0;
; 166  : 	m_idSnoop		= 0;
; 167  : 
; 168  : 	m_dwReturnWorldID = 0;
; 169  : 	m_vReturnPos = D3DXVECTOR3( 0.0f, 0.0f, 0.0f );

  00091	8d 86 c4 95 00
	00		 lea	 eax, DWORD PTR [esi+38340]
  00097	89 08		 mov	 DWORD PTR [eax], ecx
  00099	8b d1		 mov	 edx, ecx
  0009b	89 50 04	 mov	 DWORD PTR [eax+4], edx
  0009e	89 9e 28 57 00
	00		 mov	 DWORD PTR [esi+22312], ebx
  000a4	89 9e 2c 57 00
	00		 mov	 DWORD PTR [esi+22316], ebx
  000aa	89 9e c0 95 00
	00		 mov	 DWORD PTR [esi+38336], ebx
  000b0	89 9e 9c 95 00
	00		 mov	 DWORD PTR [esi+38300], ebx
  000b6	89 9e d0 95 00
	00		 mov	 DWORD PTR [esi+38352], ebx
  000bc	89 4c 24 0c	 mov	 DWORD PTR $T298341[esp+24], ecx
  000c0	89 4c 24 10	 mov	 DWORD PTR $T298341[esp+28], ecx
  000c4	89 4c 24 14	 mov	 DWORD PTR $T298341[esp+32], ecx
  000c8	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 170  : 	m_lpszVillage = NULL;

  000cb	89 9e d4 95 00
	00		 mov	 DWORD PTR [esi+38356], ebx

; 171  : 
; 172  : 	m_bPosting	= FALSE;

  000d1	89 9e 94 95 00
	00		 mov	 DWORD PTR [esi+38292], ebx

; 173  : 	m_bInstantBank	= FALSE;

  000d7	89 9e a0 95 00
	00		 mov	 DWORD PTR [esi+38304], ebx

; 174  : 
; 175  : 	DWORD dwTick = ::timeGetTime();

  000dd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__timeGetTime@0

; 176  : 	m_dwTickSFS = dwTick + 1000;
; 177  : 	m_dwTickNotify = dwTick + 200;
; 178  : 	m_dwTimeout4Save = SEC_SAVEPLAYER;
; 179  : 
; 180  : #ifdef __EVENT_1101
; 181  : #ifdef __EVENT_1101_2
; 182  : 	m_nEventFlag = 0;
; 183  : #else // __EVENT_1101_2
; 184  : 	m_dwEventFlag	= 0;
; 185  : #endif // __EVENT_1101_2
; 186  : 	m_dwEventTime	= 0;
; 187  : 	m_dwEventElapsed	= 0;
; 188  : #endif	// __EVENT_1101
; 189  : #ifdef __HACK_1130
; 190  : 	m_tmDuelRequest		= 0;
; 191  : #endif	// __HACK_1130
; 192  : 
; 193  : #ifdef __S_SERVER_UNIFY
; 194  : 	m_bAllAction = TRUE;
; 195  : #endif // __S_SERVER_UNIFY
; 196  : #ifdef __QUEST_1208
; 197  : 	m_tickScript	= GetTickCount();

  000e3	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__GetTickCount@0
  000e9	8d 90 e8 03 00
	00		 lea	 edx, DWORD PTR [eax+1000]
  000ef	05 c8 00 00 00	 add	 eax, 200		; 000000c8H
  000f4	89 96 1c 57 00
	00		 mov	 DWORD PTR [esi+22300], edx
  000fa	89 86 20 57 00
	00		 mov	 DWORD PTR [esi+22304], eax
  00100	c7 86 24 57 00
	00 84 03 00 00	 mov	 DWORD PTR [esi+22308], 900 ; 00000384H
  0010a	89 9e e0 95 00
	00		 mov	 DWORD PTR [esi+38368], ebx
  00110	89 9e e4 95 00
	00		 mov	 DWORD PTR [esi+38372], ebx
  00116	89 9e e8 95 00
	00		 mov	 DWORD PTR [esi+38376], ebx
  0011c	89 9e ec 95 00
	00		 mov	 DWORD PTR [esi+38380], ebx
  00122	89 9e f0 95 00
	00		 mov	 DWORD PTR [esi+38384], ebx
  00128	c7 86 f8 95 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+38392], 1
  00132	ff d7		 call	 edi
  00134	89 86 f4 95 00
	00		 mov	 DWORD PTR [esi+38388], eax

; 198  : #endif	// __QUEST_1208
; 199  : 	
; 200  : #ifdef __EVE_MINIGAME
; 201  : 	m_nKawibawiboWin	= 0;

  0013a	89 9e fc 95 00
	00		 mov	 DWORD PTR [esi+38396], ebx

; 202  : 	m_nKawibawiboState  = 3;

  00140	c7 86 00 96 00
	00 03 00 00 00	 mov	 DWORD PTR [esi+38400], 3

; 203  : 	for ( int i=0; i<6; ++i )
; 204  : 		m_nBetFiveSystem[i] = 0;

  0014a	89 9e 04 96 00
	00		 mov	 DWORD PTR [esi+38404], ebx
  00150	89 9e 08 96 00
	00		 mov	 DWORD PTR [esi+38408], ebx
  00156	89 9e 0c 96 00
	00		 mov	 DWORD PTR [esi+38412], ebx
  0015c	89 9e 10 96 00
	00		 mov	 DWORD PTR [esi+38416], ebx
  00162	89 9e 14 96 00
	00		 mov	 DWORD PTR [esi+38420], ebx
  00168	89 9e 18 96 00
	00		 mov	 DWORD PTR [esi+38424], ebx

; 205  : #endif // __EVE_MINIGAME
; 206  : 
; 207  : #ifdef __EXP_ANGELEXP_LOG
; 208  : 	m_nExpLog = 0;

  0016e	89 9e 1c 96 00
	00		 mov	 DWORD PTR [esi+38428], ebx

; 209  : 	m_nAngelExpLog = 0;

  00174	89 9e 20 96 00
	00		 mov	 DWORD PTR [esi+38432], ebx

; 210  : #endif // __EXP_ANGELEXP_LOG
; 211  : 
; 212  : #if __VER >= 11 // __SYS_COLLECTING
; 213  : 	m_nCollecting	= 0;

  0017a	89 9e 38 96 00
	00		 mov	 DWORD PTR [esi+38456], ebx

; 214  : #endif	// __SYS_COLLECTING
; 215  : 
; 216  : #ifdef __EVENTLUA_COUPON
; 217  : 	m_nCoupon = 0;

  00180	89 9e 24 96 00
	00		 mov	 DWORD PTR [esi+38436], ebx

; 218  : 	m_dwTickCoupon = GetTickCount();

  00186	ff d7		 call	 edi
  00188	89 86 28 96 00
	00		 mov	 DWORD PTR [esi+38440], eax

; 219  : #endif // __EVENTLUA_COUPON
; 220  : 
; 221  : #if __VER >= 12 // __LORD
; 222  : 	m_idElection	= NULL_ID;

  0018e	c7 86 3c 96 00
	00 ff ff ff ff	 mov	 DWORD PTR [esi+38460], -1

; 223  : 	m_bQuerying		= FALSE;

  00198	89 9e 40 96 00
	00		 mov	 DWORD PTR [esi+38464], ebx

; 224  : #endif	// __LORD
; 225  : 
; 226  : #ifdef __AZRIA_1023
; 227  : 	m_szInput[0]	= '\0';

  0019e	88 9e 44 96 00
	00		 mov	 BYTE PTR [esi+38468], bl

; 228  : #endif	// __AZRIA_1023
; 229  : 
; 230  : #if __VER >= 13 // __COUPLE_1117
; 231  : 	m_idProposer	= 0;

  001a4	89 9e b8 96 00
	00		 mov	 DWORD PTR [esi+38584], ebx

; 232  : #if __VER >= 13 // __COUPLE_1202
; 233  : 	m_cbProcessCouple	= 0;

  001aa	89 9e bc 96 00
	00		 mov	 DWORD PTR [esi+38588], ebx

; 234  : #endif	// __COUPLE_1202
; 235  : #endif	// __COUPLE_1117
; 236  : 
; 237  : #ifdef __EVENTLUA_KEEPCONNECT
; 238  : 	m_dwTickKeepConnect = GetTickCount();

  001b0	ff d7		 call	 edi
  001b2	89 86 2c 96 00
	00		 mov	 DWORD PTR [esi+38444], eax

; 239  : #endif // __EVENTLUA_KEEPCONNECT
; 240  : #if __VER >= 15 // __GUILD_HOUSE
; 241  : 	m_nRestPoint = 0;

  001b8	89 9e a8 96 00
	00		 mov	 DWORD PTR [esi+38568], ebx

; 242  : 	m_nPrevRestPoint = 0;

  001be	89 9e ac 96 00
	00		 mov	 DWORD PTR [esi+38572], ebx

; 243  : 	m_tRestPointTick = time_null();

  001c4	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_tCurrent@@3JA ; g_tCurrent
  001c9	89 86 b0 96 00
	00		 mov	 DWORD PTR [esi+38576], eax

; 244  : #endif // __GUILD_HOUSE
; 245  : 
; 246  : #ifdef __PERIN_BUY_BUG
; 247  : 	m_dwLastTryBuyItem = NULL_ID;

  001cf	c7 86 30 96 00
	00 ff ff ff ff	 mov	 DWORD PTR [esi+38448], -1

; 248  : 	m_dwLastBuyItemTick = GetTickCount();

  001d9	ff d7		 call	 edi
  001db	5f		 pop	 edi
  001dc	89 86 34 96 00
	00		 mov	 DWORD PTR [esi+38452], eax
  001e2	5e		 pop	 esi
  001e3	5b		 pop	 ebx

; 249  : #endif // __PERIN_BUY_BUG
; 250  : }

  001e4	83 c4 0c	 add	 esp, 12			; 0000000cH
  001e7	c2 08 00	 ret	 8
?Init@CUser@@AAEXKK@Z ENDP				; CUser::Init
_TEXT	ENDS
PUBLIC	?ExpUpSetting@CUser@@QAEXXZ			; CUser::ExpUpSetting
EXTRN	?g_dpDBClient@@3VCDPDatabaseClient@@A:BYTE	; g_dpDBClient
EXTRN	?SendLogLevelUp@CDPDatabaseClient@@QAEXPAVCMover@@H@Z:NEAR ; CDPDatabaseClient::SendLogLevelUp
EXTRN	__alldiv:NEAR
; Function compile flags: /Ogty
;	COMDAT ?ExpUpSetting@CUser@@QAEXXZ
_TEXT	SEGMENT
?ExpUpSetting@CUser@@QAEXXZ PROC NEAR			; CUser::ExpUpSetting, COMDAT
; _this$ = ecx

; 268  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	57		 push	 edi

; 269  : 	//  5 _   
; 270  : 	// 20%   
; 271  : 	if( GetLevel() > 5 ) //  5

  00004	8b be e0 05 00
	00		 mov	 edi, DWORD PTR [esi+1504]
  0000a	83 ff 05	 cmp	 edi, 5
  0000d	7e 67		 jle	 SHORT $L277902

; 272  : 	{
; 273  : #ifdef __EXP_ANGELEXP_LOG
; 274  : 		int nNextExpLog = (int)(m_nExpLog/20 + 1) * 20;	
; 275  : 		int nExpPercent = (int)( GetExp1() * 100 / GetMaxExp1() );

  0000f	8b 86 ec 05 00
	00		 mov	 eax, DWORD PTR [esi+1516]
  00015	8b 8e e8 05 00
	00		 mov	 ecx, DWORD PTR [esi+1512]
  0001b	6a 00		 push	 0
  0001d	6a 64		 push	 100			; 00000064H
  0001f	50		 push	 eax
  00020	51		 push	 ecx
  00021	c1 e7 05	 shl	 edi, 5
  00024	e8 00 00 00 00	 call	 __allmul
  00029	8b 8f 14 50 00
	00		 mov	 ecx, DWORD PTR ?prj@@3VCProject@@A[edi+20500]
  0002f	51		 push	 ecx
  00030	8b 8f 10 50 00
	00		 mov	 ecx, DWORD PTR ?prj@@3VCProject@@A[edi+20496]
  00036	51		 push	 ecx
  00037	52		 push	 edx
  00038	50		 push	 eax
  00039	e8 00 00 00 00	 call	 __alldiv
  0003e	8b 96 1c 96 00
	00		 mov	 edx, DWORD PTR [esi+38428]
  00044	8b c8		 mov	 ecx, eax
  00046	b8 67 66 66 66	 mov	 eax, 1717986919		; 66666667H
  0004b	f7 ea		 imul	 edx
  0004d	c1 fa 03	 sar	 edx, 3
  00050	8b c2		 mov	 eax, edx
  00052	c1 e8 1f	 shr	 eax, 31			; 0000001fH

; 276  : 		if( nExpPercent >= nNextExpLog )

  00055	8d 44 02 01	 lea	 eax, DWORD PTR [edx+eax+1]
  00059	8d 14 80	 lea	 edx, DWORD PTR [eax+eax*4]
  0005c	c1 e2 02	 shl	 edx, 2
  0005f	3b ca		 cmp	 ecx, edx
  00061	7c 13		 jl	 SHORT $L277902

; 277  : 		{
; 278  : 			m_nExpLog = nExpPercent;
; 279  : 			g_dpDBClient.SendLogLevelUp( this, 5 );

  00063	6a 05		 push	 5
  00065	89 8e 1c 96 00
	00		 mov	 DWORD PTR [esi+38428], ecx
  0006b	56		 push	 esi
  0006c	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_dpDBClient@@3VCDPDatabaseClient@@A
  00071	e8 00 00 00 00	 call	 ?SendLogLevelUp@CDPDatabaseClient@@QAEXPAVCMover@@H@Z ; CDPDatabaseClient::SendLogLevelUp
$L277902:
  00076	5f		 pop	 edi
  00077	5e		 pop	 esi

; 280  : 		}
; 281  : #else // __EXP_ANGELEXP_LOG
; 282  : 		int iLogExp = GetExp1() * 100 / GetMaxExp1();
; 283  : 		iLogExp /= 20;
; 284  : 		
; 285  : 		if( ( 20 * ( iLogExp + 1 ) ) <= ( GetExp1() * 100 / GetMaxExp1() ) )
; 286  : 			g_dpDBClient.SendLogLevelUp( this, 5 );
; 287  : #endif // __EXP_ANGELEXP_LOG
; 288  : 	}
; 289  : }

  00078	c3		 ret	 0
?ExpUpSetting@CUser@@QAEXXZ ENDP			; CUser::ExpUpSetting
_TEXT	ENDS
PUBLIC	?Notify@CUser@@QAEHXZ				; CUser::Notify
EXTRN	?g_DPSrvr@@3VCDPSrvr@@A:BYTE			; g_DPSrvr
EXTRN	?ReelIn@CAr@@QAEXI@Z:NEAR			; CAr::ReelIn
EXTRN	?GetBuffer@CAr@@QAEPAEPAH@Z:NEAR		; CAr::GetBuffer
;	COMDAT ?uOffset@?5??Notify@CUser@@QAEHXZ@4IA
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_network\net\include\dpmng.h
_DATA	SEGMENT
?uOffset@?5??Notify@CUser@@QAEHXZ@4IA DD 0eH		; `CUser::Notify'::`6'::uOffset
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
_DATA	ENDS
;	COMDAT ?Notify@CUser@@QAEHXZ
_TEXT	SEGMENT
_nBufSize$ = -4						; size = 4
?Notify@CUser@@QAEHXZ PROC NEAR				; CUser::Notify, COMDAT
; _this$ = ecx

; 584  : {

  00000	51		 push	 ecx
  00001	56		 push	 esi
  00002	8b f1		 mov	 esi, ecx

; 585  : 	if( IsValid() == FALSE )

  00004	f6 46 04 01	 test	 BYTE PTR [esi+4], 1
  00008	0f 85 82 00 00
	00		 jne	 $L278017
  0000e	8b 86 e8 16 00
	00		 mov	 eax, DWORD PTR [esi+5864]
  00014	85 c0		 test	 eax, eax

; 586  : 		return	0;

  00016	74 78		 je	 SHORT $L278017

; 587  : 
; 588  : 	if( m_dwDestroyTime )		//   Notify .

  00018	8b 86 2c 57 00
	00		 mov	 eax, DWORD PTR [esi+22316]
  0001e	85 c0		 test	 eax, eax

; 589  : 		return 0;

  00020	75 6e		 jne	 SHORT $L278017

; 590  : 
; 591  : 	static u_int uOffset	= sizeof(DPID)+sizeof(DWORD)+sizeof(OBJID)+sizeof(short);
; 592  : 	LPBYTE lpBuf;
; 593  : 	int nBufSize;
; 594  : 
; 595  : 	if( m_Snapshot.cb > 0 )

  00022	66 83 be 0c 57
	00 00 00	 cmp	 WORD PTR [esi+22284], 0
  0002a	7e 64		 jle	 SHORT $L278017
  0002c	53		 push	 ebx
  0002d	57		 push	 edi

; 596  : 	{
; 597  : 		lpBuf	= m_Snapshot.ar.GetBuffer( &nBufSize );

  0002e	8d 44 24 0c	 lea	 eax, DWORD PTR _nBufSize$[esp+16]
  00032	8d 9e f8 16 00
	00		 lea	 ebx, DWORD PTR [esi+5880]
  00038	50		 push	 eax
  00039	8b cb		 mov	 ecx, ebx
  0003b	e8 00 00 00 00	 call	 ?GetBuffer@CAr@@QAEPAEPAH@Z ; CAr::GetBuffer

; 598  : 		*(UNALIGNED WORD*)( lpBuf + sizeof(DPID) + sizeof(DWORD) + sizeof(OBJID) )	= m_Snapshot.cb;

  00040	66 8b 8e 0c 57
	00 00		 mov	 cx, WORD PTR [esi+22284]
  00047	8b f8		 mov	 edi, eax
  00049	66 89 4f 0c	 mov	 WORD PTR [edi+12], cx

; 599  : 		g_DPSrvr.Send( (LPVOID)lpBuf, nBufSize, m_Snapshot.dpidCache );

  0004d	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR ?g_DPSrvr@@3VCDPSrvr@@A+4
  00053	85 c9		 test	 ecx, ecx
  00055	74 12		 je	 SHORT $L298386
  00057	8b 96 f0 16 00
	00		 mov	 edx, DWORD PTR [esi+5872]
  0005d	8b 44 24 0c	 mov	 eax, DWORD PTR _nBufSize$[esp+16]
  00061	52		 push	 edx
  00062	50		 push	 eax
  00063	57		 push	 edi
  00064	e8 00 00 00 00	 call	 ?Send@CDPSock@@QAEHPADKK@Z ; CDPSock::Send
$L298386:

; 600  : 		*(UNALIGNED DWORD*)( lpBuf + sizeof(DPID) )		= PACKETTYPE_SNAPSHOT;
; 601  : 		m_Snapshot.cb	= 0;
; 602  : 		m_Snapshot.ar.ReelIn( uOffset );

  00069	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?uOffset@?5??Notify@CUser@@QAEHXZ@4IA
  0006f	51		 push	 ecx
  00070	c7 47 04 00 ff
	ff ff		 mov	 DWORD PTR [edi+4], -256	; ffffff00H
  00077	8b cb		 mov	 ecx, ebx
  00079	66 c7 86 0c 57
	00 00 00 00	 mov	 WORD PTR [esi+22284], 0
  00082	e8 00 00 00 00	 call	 ?ReelIn@CAr@@QAEXI@Z	; CAr::ReelIn

; 603  : 		return nBufSize;

  00087	8b 44 24 0c	 mov	 eax, DWORD PTR _nBufSize$[esp+16]
  0008b	5f		 pop	 edi
  0008c	5b		 pop	 ebx
  0008d	5e		 pop	 esi

; 606  : }

  0008e	59		 pop	 ecx
  0008f	c3		 ret	 0
$L278017:

; 604  : 	}
; 605  : 	return 0;

  00090	33 c0		 xor	 eax, eax
  00092	5e		 pop	 esi

; 606  : }

  00093	59		 pop	 ecx
  00094	c3		 ret	 0
?Notify@CUser@@QAEHXZ ENDP				; CUser::Notify
_TEXT	ENDS
PUBLIC	?AddBlock@CUser@@QAEXPAEK@Z			; CUser::AddBlock
; Function compile flags: /Ogty
;	COMDAT ?AddBlock@CUser@@QAEXPAEK@Z
_TEXT	SEGMENT
_lpBlock$ = 8						; size = 4
_uBlockSize$ = 12					; size = 4
?AddBlock@CUser@@QAEXPAEK@Z PROC NEAR			; CUser::AddBlock, COMDAT
; _this$ = ecx

; 646  : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	75 12		 jne	 SHORT $L278045

; 647  : 
; 648  : 	m_Snapshot.cb++;

  00006	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]

; 649  : 	m_Snapshot.ar.Write( lpBlock, uBlockSize );

  0000d	81 c1 f8 16 00
	00		 add	 ecx, 5880		; 000016f8H
  00013	e9 00 00 00 00	 jmp	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
$L278045:

; 650  : }

  00018	c2 08 00	 ret	 8
?AddBlock@CUser@@QAEXPAEK@Z ENDP			; CUser::AddBlock
_TEXT	ENDS
PUBLIC	?AddHdr@CUser@@QAEXKG@Z				; CUser::AddHdr
; Function compile flags: /Ogty
;	COMDAT ?AddHdr@CUser@@QAEXKG@Z
_TEXT	SEGMENT
_objid$ = 8						; size = 4
_wHdr$ = 12						; size = 2
?AddHdr@CUser@@QAEXKG@Z PROC NEAR			; CUser::AddHdr, COMDAT
; _this$ = ecx

; 654  : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	75 42		 jne	 SHORT $L298410

; 655  : 
; 656  : 	m_Snapshot.cb++;

  00006	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  0000d	56		 push	 esi

; 657  : 	m_Snapshot.ar << objid;

  0000e	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  00014	6a 04		 push	 4
  00016	8b ce		 mov	 ecx, esi
  00018	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0001d	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00020	8b 4c 24 08	 mov	 ecx, DWORD PTR _objid$[esp]
  00024	89 08		 mov	 DWORD PTR [eax], ecx
  00026	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00029	83 c2 04	 add	 edx, 4

; 658  : 	m_Snapshot.ar << wHdr;

  0002c	6a 02		 push	 2
  0002e	8b ce		 mov	 ecx, esi
  00030	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00033	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00038	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0003b	66 8b 44 24 0c	 mov	 ax, WORD PTR _wHdr$[esp]
  00040	66 89 02	 mov	 WORD PTR [edx], ax
  00043	83 46 08 02	 add	 DWORD PTR [esi+8], 2
  00047	5e		 pop	 esi
$L298410:

; 659  : }

  00048	c2 08 00	 ret	 8
?AddHdr@CUser@@QAEXKG@Z ENDP				; CUser::AddHdr
_TEXT	ENDS
PUBLIC	?AddAddObj@CUser@@QAEXPAVCCtrl@@@Z		; CUser::AddAddObj
; Function compile flags: /Ogty
;	COMDAT ?AddAddObj@CUser@@QAEXPAVCCtrl@@@Z
_TEXT	SEGMENT
$T298425 = -4						; size = 4
$T298429 = 8						; size = 4
_pCtrl$ = 8						; size = 4
?AddAddObj@CUser@@QAEXPAVCCtrl@@@Z PROC NEAR		; CUser::AddAddObj, COMDAT
; _this$ = ecx

; 663  : {

  00000	51		 push	 ecx
  00001	55		 push	 ebp
  00002	8b e9		 mov	 ebp, ecx

; 664  : 	if( IsDelete() )	return;

  00004	f6 45 04 01	 test	 BYTE PTR [ebp+4], 1
  00008	0f 85 ae 00 00
	00		 jne	 $L278056
  0000e	57		 push	 edi

; 665  : 
; 666  : 	//	mulcom	BEGIN100430
; 667  : 	if( pCtrl == NULL )

  0000f	8b 7c 24 10	 mov	 edi, DWORD PTR _pCtrl$[esp+8]
  00013	85 ff		 test	 edi, edi
  00015	0f 84 a0 00 00
	00		 je	 $L298446

; 668  : 	{
; 669  : 		return;
; 670  : 	}
; 671  : 	//	mulcom	END100430
; 672  : 
; 673  : 	m_Snapshot.cb++;

  0001b	66 ff 85 0c 57
	00 00		 inc	 WORD PTR [ebp+22284]

; 674  : 	m_Snapshot.ar << pCtrl->GetId() << SNAPSHOTTYPE_ADD_OBJ << (BYTE)pCtrl->GetType() << pCtrl->GetIndex();

  00022	8b 8f bc 01 00
	00		 mov	 ecx, DWORD PTR [edi+444]
  00028	8b 87 70 01 00
	00		 mov	 eax, DWORD PTR [edi+368]
  0002e	53		 push	 ebx
  0002f	8b 9f 74 01 00
	00		 mov	 ebx, DWORD PTR [edi+372]
  00035	56		 push	 esi
  00036	89 4c 24 18	 mov	 DWORD PTR $T298429[esp+16], ecx
  0003a	8d b5 f8 16 00
	00		 lea	 esi, DWORD PTR [ebp+5880]
  00040	6a 04		 push	 4
  00042	8b ce		 mov	 ecx, esi
  00044	89 44 24 14	 mov	 DWORD PTR $T298425[esp+24], eax
  00048	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0004d	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00050	8b 44 24 18	 mov	 eax, DWORD PTR $T298429[esp+16]
  00054	89 02		 mov	 DWORD PTR [edx], eax
  00056	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00059	83 c0 04	 add	 eax, 4
  0005c	6a 02		 push	 2
  0005e	8b ce		 mov	 ecx, esi
  00060	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00063	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00068	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0006b	66 c7 01 f0 00	 mov	 WORD PTR [ecx], 240	; 000000f0H
  00070	83 46 08 02	 add	 DWORD PTR [esi+8], 2
  00074	6a 01		 push	 1
  00076	8b ce		 mov	 ecx, esi
  00078	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0007d	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00080	8a 44 24 10	 mov	 al, BYTE PTR $T298425[esp+20]
  00084	88 02		 mov	 BYTE PTR [edx], al
  00086	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00089	42		 inc	 edx
  0008a	6a 04		 push	 4
  0008c	8b ce		 mov	 ecx, esi
  0008e	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00091	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00096	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00099	89 19		 mov	 DWORD PTR [ecx], ebx
  0009b	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0009e	83 c0 04	 add	 eax, 4

; 675  : 	CObj::SetMethod( pCtrl == this ? METHOD_NONE : METHOD_EXCLUDE_ITEM );

  000a1	33 d2		 xor	 edx, edx
  000a3	3b fd		 cmp	 edi, ebp
  000a5	0f 95 c2	 setne	 dl
  000a8	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 676  : 	pCtrl->Serialize( m_Snapshot.ar );

  000ab	56		 push	 esi
  000ac	8b cf		 mov	 ecx, edi
  000ae	89 15 00 00 00
	00		 mov	 DWORD PTR ?m_nMethod@CObj@@2HA, edx ; CObj::m_nMethod
  000b4	8b 07		 mov	 eax, DWORD PTR [edi]
  000b6	ff 50 20	 call	 DWORD PTR [eax+32]
  000b9	5e		 pop	 esi
  000ba	5b		 pop	 ebx
$L298446:
  000bb	5f		 pop	 edi
$L278056:
  000bc	5d		 pop	 ebp

; 677  : }

  000bd	59		 pop	 ecx
  000be	c2 04 00	 ret	 4
?AddAddObj@CUser@@QAEXPAVCCtrl@@@Z ENDP			; CUser::AddAddObj
_TEXT	ENDS
PUBLIC	?AddCreateItem@CUser@@QAEXPAVCItemBase@@PAEPAFE@Z ; CUser::AddCreateItem
; Function compile flags: /Ogty
;	COMDAT ?AddCreateItem@CUser@@QAEXPAVCItemBase@@PAEPAFE@Z
_TEXT	SEGMENT
_pItemBase$ = 8						; size = 4
_pnId$ = 12						; size = 4
_pnNum$ = 16						; size = 4
_nCount$ = 20						; size = 1
?AddCreateItem@CUser@@QAEXPAVCItemBase@@PAEPAFE@Z PROC NEAR ; CUser::AddCreateItem, COMDAT
; _this$ = ecx

; 734  : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	0f 85 98 00 00
	00		 jne	 $L278092

; 735  : 	
; 736  : 	m_Snapshot.cb++;

  0000a	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  00011	56		 push	 esi
  00012	57		 push	 edi

; 737  : 	m_Snapshot.ar << GetId();

  00013	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  00019	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  0001f	6a 04		 push	 4
  00021	8b ce		 mov	 ecx, esi
  00023	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00028	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0002b	89 38		 mov	 DWORD PTR [eax], edi
  0002d	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  00030	83 c7 04	 add	 edi, 4

; 738  : 	m_Snapshot.ar << SNAPSHOTTYPE_CREATEITEM;

  00033	6a 02		 push	 2
  00035	8b ce		 mov	 ecx, esi
  00037	89 7e 08	 mov	 DWORD PTR [esi+8], edi
  0003a	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003f	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00042	66 c7 01 03 00	 mov	 WORD PTR [ecx], 3
  00047	83 46 08 02	 add	 DWORD PTR [esi+8], 2

; 739  : 	m_Snapshot.ar << (BYTE)0;

  0004b	6a 01		 push	 1
  0004d	8b ce		 mov	 ecx, esi
  0004f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00054	8b 56 08	 mov	 edx, DWORD PTR [esi+8]

; 740  : 	pItemBase->Serialize( m_Snapshot.ar );

  00057	8b 4c 24 0c	 mov	 ecx, DWORD PTR _pItemBase$[esp+4]
  0005b	c6 02 00	 mov	 BYTE PTR [edx], 0
  0005e	ff 46 08	 inc	 DWORD PTR [esi+8]
  00061	8b 01		 mov	 eax, DWORD PTR [ecx]
  00063	56		 push	 esi
  00064	ff 50 08	 call	 DWORD PTR [eax+8]

; 741  : 	m_Snapshot.ar << nCount;

  00067	6a 01		 push	 1
  00069	8b ce		 mov	 ecx, esi
  0006b	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00070	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00073	8a 44 24 18	 mov	 al, BYTE PTR _nCount$[esp+4]
  00077	88 01		 mov	 BYTE PTR [ecx], al
  00079	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0007c	42		 inc	 edx

; 742  : 	m_Snapshot.ar.Write( (void*)pnId, sizeof(BYTE) * nCount );

  0007d	0f b6 f8	 movzx	 edi, al
  00080	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00083	8b 54 24 10	 mov	 edx, DWORD PTR _pnId$[esp+4]
  00087	57		 push	 edi
  00088	52		 push	 edx
  00089	8b ce		 mov	 ecx, esi
  0008b	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write

; 743  : 	m_Snapshot.ar.Write( (void*)pnNum, sizeof(short) * nCount );

  00090	8b 4c 24 14	 mov	 ecx, DWORD PTR _pnNum$[esp+4]
  00094	8d 04 3f	 lea	 eax, DWORD PTR [edi+edi]
  00097	50		 push	 eax
  00098	51		 push	 ecx
  00099	8b ce		 mov	 ecx, esi
  0009b	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
  000a0	5f		 pop	 edi
  000a1	5e		 pop	 esi
$L278092:

; 744  : }

  000a2	c2 10 00	 ret	 16			; 00000010H
?AddCreateItem@CUser@@QAEXPAVCItemBase@@PAEPAFE@Z ENDP	; CUser::AddCreateItem
_TEXT	ENDS
PUBLIC	?AddMoveItem@CUser@@QAEXEEE@Z			; CUser::AddMoveItem
; Function compile flags: /Ogty
;	COMDAT ?AddMoveItem@CUser@@QAEXEEE@Z
_TEXT	SEGMENT
_nItemType$ = 8						; size = 1
_nSrcIndex$ = 12					; size = 1
_nDestIndex$ = 16					; size = 1
?AddMoveItem@CUser@@QAEXEEE@Z PROC NEAR			; CUser::AddMoveItem, COMDAT
; _this$ = ecx

; 748  : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	0f 85 93 00 00
	00		 jne	 $L298500

; 749  : 	
; 750  : 	m_Snapshot.cb++;

  0000a	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  00011	56		 push	 esi
  00012	57		 push	 edi

; 751  : 	m_Snapshot.ar << GetId();

  00013	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  00019	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  0001f	6a 04		 push	 4
  00021	8b ce		 mov	 ecx, esi
  00023	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00028	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0002b	89 38		 mov	 DWORD PTR [eax], edi
  0002d	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00030	83 c0 04	 add	 eax, 4

; 752  : 	m_Snapshot.ar << SNAPSHOTTYPE_MOVEITEM;

  00033	6a 02		 push	 2
  00035	8b ce		 mov	 ecx, esi
  00037	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0003a	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003f	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00042	66 c7 01 04 00	 mov	 WORD PTR [ecx], 4
  00047	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0004a	83 c2 02	 add	 edx, 2

; 753  : 	m_Snapshot.ar << nItemType << nSrcIndex << nDestIndex;

  0004d	6a 01		 push	 1
  0004f	8b ce		 mov	 ecx, esi
  00051	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00054	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00059	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0005c	8a 44 24 0c	 mov	 al, BYTE PTR _nItemType$[esp+4]
  00060	88 02		 mov	 BYTE PTR [edx], al
  00062	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00065	40		 inc	 eax
  00066	6a 01		 push	 1
  00068	8b ce		 mov	 ecx, esi
  0006a	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0006d	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00072	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00075	8a 54 24 10	 mov	 dl, BYTE PTR _nSrcIndex$[esp+4]
  00079	88 11		 mov	 BYTE PTR [ecx], dl
  0007b	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0007e	42		 inc	 edx
  0007f	6a 01		 push	 1
  00081	8b ce		 mov	 ecx, esi
  00083	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00086	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0008b	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0008e	8a 4c 24 14	 mov	 cl, BYTE PTR _nDestIndex$[esp+4]
  00092	88 08		 mov	 BYTE PTR [eax], cl
  00094	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00097	40		 inc	 eax
  00098	5f		 pop	 edi
  00099	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0009c	5e		 pop	 esi
$L298500:

; 754  : }

  0009d	c2 0c 00	 ret	 12			; 0000000cH
?AddMoveItem@CUser@@QAEXEEE@Z ENDP			; CUser::AddMoveItem
_TEXT	ENDS
PUBLIC	?AddComfirmTrade@CUser@@QAEXK@Z			; CUser::AddComfirmTrade
; Function compile flags: /Ogty
;	COMDAT ?AddComfirmTrade@CUser@@QAEXK@Z
_TEXT	SEGMENT
_objid$ = 8						; size = 4
?AddComfirmTrade@CUser@@QAEXK@Z PROC NEAR		; CUser::AddComfirmTrade, COMDAT
; _this$ = ecx

; 770  : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	75 3f		 jne	 SHORT $L298513

; 771  : 	
; 772  : 	m_Snapshot.cb++;

  00006	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  0000d	56		 push	 esi

; 773  : 	m_Snapshot.ar << objid;

  0000e	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  00014	6a 04		 push	 4
  00016	8b ce		 mov	 ecx, esi
  00018	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0001d	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00020	8b 4c 24 08	 mov	 ecx, DWORD PTR _objid$[esp]
  00024	89 08		 mov	 DWORD PTR [eax], ecx
  00026	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00029	83 c2 04	 add	 edx, 4

; 774  : 	m_Snapshot.ar << SNAPSHOTTYPE_CONFIRMTRADE;

  0002c	6a 02		 push	 2
  0002e	8b ce		 mov	 ecx, esi
  00030	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00033	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00038	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0003b	66 c7 02 22 00	 mov	 WORD PTR [edx], 34	; 00000022H
  00040	83 46 08 02	 add	 DWORD PTR [esi+8], 2
  00044	5e		 pop	 esi
$L298513:

; 775  : }

  00045	c2 04 00	 ret	 4
?AddComfirmTrade@CUser@@QAEXK@Z ENDP			; CUser::AddComfirmTrade
_TEXT	ENDS
PUBLIC	?AddComfirmTradeCancel@CUser@@QAEXK@Z		; CUser::AddComfirmTradeCancel
; Function compile flags: /Ogty
;	COMDAT ?AddComfirmTradeCancel@CUser@@QAEXK@Z
_TEXT	SEGMENT
_objid$ = 8						; size = 4
?AddComfirmTradeCancel@CUser@@QAEXK@Z PROC NEAR		; CUser::AddComfirmTradeCancel, COMDAT
; _this$ = ecx

; 779  : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	75 3f		 jne	 SHORT $L298527

; 780  : 	
; 781  : 	m_Snapshot.cb++;

  00006	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  0000d	56		 push	 esi

; 782  : 	m_Snapshot.ar << objid;

  0000e	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  00014	6a 04		 push	 4
  00016	8b ce		 mov	 ecx, esi
  00018	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0001d	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00020	8b 4c 24 08	 mov	 ecx, DWORD PTR _objid$[esp]
  00024	89 08		 mov	 DWORD PTR [eax], ecx
  00026	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00029	83 c2 04	 add	 edx, 4

; 783  : 	m_Snapshot.ar << SNAPSHOTTYPE_CONFIRMTRADECANCEL;

  0002c	6a 02		 push	 2
  0002e	8b ce		 mov	 ecx, esi
  00030	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00033	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00038	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0003b	66 c7 02 23 00	 mov	 WORD PTR [edx], 35	; 00000023H
  00040	83 46 08 02	 add	 DWORD PTR [esi+8], 2
  00044	5e		 pop	 esi
$L298527:

; 784  : }

  00045	c2 04 00	 ret	 4
?AddComfirmTradeCancel@CUser@@QAEXK@Z ENDP		; CUser::AddComfirmTradeCancel
_TEXT	ENDS
PUBLIC	?AddExpBoxCoolTime@CUser@@QAEXKK@Z		; CUser::AddExpBoxCoolTime
; Function compile flags: /Ogty
;	COMDAT ?AddExpBoxCoolTime@CUser@@QAEXKK@Z
_TEXT	SEGMENT
_objid$ = 8						; size = 4
_dwTime$ = 12						; size = 4
?AddExpBoxCoolTime@CUser@@QAEXKK@Z PROC NEAR		; CUser::AddExpBoxCoolTime, COMDAT
; _this$ = ecx

; 788  : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	75 7e		 jne	 SHORT $L298553

; 789  : 	
; 790  : 	m_Snapshot.cb++;

  00006	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  0000d	56		 push	 esi
  0000e	57		 push	 edi

; 791  : 	m_Snapshot.ar << GetId();

  0000f	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  00015	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  0001b	6a 04		 push	 4
  0001d	8b ce		 mov	 ecx, esi
  0001f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00024	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00027	89 38		 mov	 DWORD PTR [eax], edi
  00029	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0002c	83 c2 04	 add	 edx, 4

; 792  : 	m_Snapshot.ar << SNAPSHOTTYPE_EXPBOXCOLLTIME;

  0002f	6a 02		 push	 2
  00031	8b ce		 mov	 ecx, esi
  00033	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00036	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003b	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003e	66 c7 01 be 00	 mov	 WORD PTR [ecx], 190	; 000000beH
  00043	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00046	83 c0 02	 add	 eax, 2

; 793  : 	m_Snapshot.ar << objid;

  00049	6a 04		 push	 4
  0004b	8b ce		 mov	 ecx, esi
  0004d	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00050	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00055	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00058	8b 44 24 0c	 mov	 eax, DWORD PTR _objid$[esp+4]
  0005c	89 02		 mov	 DWORD PTR [edx], eax
  0005e	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00061	83 c2 04	 add	 edx, 4

; 794  : 	m_Snapshot.ar << dwTime;

  00064	6a 04		 push	 4
  00066	8b ce		 mov	 ecx, esi
  00068	89 56 08	 mov	 DWORD PTR [esi+8], edx
  0006b	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00070	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00073	8b 54 24 10	 mov	 edx, DWORD PTR _dwTime$[esp+4]
  00077	89 11		 mov	 DWORD PTR [ecx], edx
  00079	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0007c	83 c0 04	 add	 eax, 4
  0007f	5f		 pop	 edi
  00080	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00083	5e		 pop	 esi
$L298553:

; 795  : }

  00084	c2 08 00	 ret	 8
?AddExpBoxCoolTime@CUser@@QAEXKK@Z ENDP			; CUser::AddExpBoxCoolTime
_TEXT	ENDS
PUBLIC	?AddCommonSkill@CUser@@QAEXKK@Z			; CUser::AddCommonSkill
; Function compile flags: /Ogty
;	COMDAT ?AddCommonSkill@CUser@@QAEXKK@Z
_TEXT	SEGMENT
_dwSkill$ = 8						; size = 4
_dwLevel$ = 12						; size = 4
?AddCommonSkill@CUser@@QAEXKK@Z PROC NEAR		; CUser::AddCommonSkill, COMDAT
; _this$ = ecx

; 800  : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	75 7e		 jne	 SHORT $L298579

; 801  : 	
; 802  : 	m_Snapshot.cb++;

  00006	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  0000d	56		 push	 esi
  0000e	57		 push	 edi

; 803  : 	m_Snapshot.ar << GetId();

  0000f	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  00015	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  0001b	6a 04		 push	 4
  0001d	8b ce		 mov	 ecx, esi
  0001f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00024	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00027	89 38		 mov	 DWORD PTR [eax], edi
  00029	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0002c	83 c2 04	 add	 edx, 4

; 804  : 	m_Snapshot.ar << SNAPSHOTTYPE_COMMONSKILL;

  0002f	6a 02		 push	 2
  00031	8b ce		 mov	 ecx, esi
  00033	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00036	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003b	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003e	66 c7 01 dd 00	 mov	 WORD PTR [ecx], 221	; 000000ddH
  00043	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00046	83 c0 02	 add	 eax, 2

; 805  : 	m_Snapshot.ar << dwSkill << dwLevel;

  00049	6a 04		 push	 4
  0004b	8b ce		 mov	 ecx, esi
  0004d	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00050	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00055	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00058	8b 44 24 0c	 mov	 eax, DWORD PTR _dwSkill$[esp+4]
  0005c	89 02		 mov	 DWORD PTR [edx], eax
  0005e	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00061	83 c2 04	 add	 edx, 4
  00064	6a 04		 push	 4
  00066	8b ce		 mov	 ecx, esi
  00068	89 56 08	 mov	 DWORD PTR [esi+8], edx
  0006b	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00070	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00073	8b 54 24 10	 mov	 edx, DWORD PTR _dwLevel$[esp+4]
  00077	89 11		 mov	 DWORD PTR [ecx], edx
  00079	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0007c	83 c0 04	 add	 eax, 4
  0007f	5f		 pop	 edi
  00080	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00083	5e		 pop	 esi
$L298579:

; 806  : }

  00084	c2 08 00	 ret	 8
?AddCommonSkill@CUser@@QAEXKK@Z ENDP			; CUser::AddCommonSkill
_TEXT	ENDS
PUBLIC	?AddTradePutError@CUser@@QAEXXZ			; CUser::AddTradePutError
; Function compile flags: /Ogty
;	COMDAT ?AddTradePutError@CUser@@QAEXXZ
_TEXT	SEGMENT
?AddTradePutError@CUser@@QAEXXZ PROC NEAR		; CUser::AddTradePutError, COMDAT
; _this$ = ecx

; 820  : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	75 48		 jne	 SHORT $L298595

; 821  : 	
; 822  : 	m_Snapshot.cb++;

  00006	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  0000d	56		 push	 esi
  0000e	57		 push	 edi

; 823  : 	m_Snapshot.ar << GetId();

  0000f	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  00015	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  0001b	6a 04		 push	 4
  0001d	8b ce		 mov	 ecx, esi
  0001f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00024	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00027	89 38		 mov	 DWORD PTR [eax], edi
  00029	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0002c	83 c2 04	 add	 edx, 4

; 824  : 	m_Snapshot.ar << SNAPSHOTTYPE_TRADEPUTERROR;

  0002f	6a 02		 push	 2
  00031	8b ce		 mov	 ecx, esi
  00033	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00036	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003b	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003e	66 c7 01 05 00	 mov	 WORD PTR [ecx], 5
  00043	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00046	83 c0 02	 add	 eax, 2
  00049	5f		 pop	 edi
  0004a	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0004d	5e		 pop	 esi
$L298595:

; 825  : }

  0004e	c3		 ret	 0
?AddTradePutError@CUser@@QAEXXZ ENDP			; CUser::AddTradePutError
_TEXT	ENDS
PUBLIC	?AddTradePull@CUser@@QAEXKE@Z			; CUser::AddTradePull
; Function compile flags: /Ogty
;	COMDAT ?AddTradePull@CUser@@QAEXKE@Z
_TEXT	SEGMENT
_objid$ = 8						; size = 4
_i$ = 12						; size = 1
?AddTradePull@CUser@@QAEXKE@Z PROC NEAR			; CUser::AddTradePull, COMDAT
; _this$ = ecx

; 829  : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	75 54		 jne	 SHORT $L298613

; 830  : 
; 831  : 	m_Snapshot.cb++;

  00006	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  0000d	56		 push	 esi

; 832  : 	m_Snapshot.ar << objid;

  0000e	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  00014	6a 04		 push	 4
  00016	8b ce		 mov	 ecx, esi
  00018	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0001d	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00020	8b 4c 24 08	 mov	 ecx, DWORD PTR _objid$[esp]
  00024	89 08		 mov	 DWORD PTR [eax], ecx
  00026	83 46 08 04	 add	 DWORD PTR [esi+8], 4

; 833  : 	m_Snapshot.ar << SNAPSHOTTYPE_TRADEPULL;

  0002a	6a 02		 push	 2
  0002c	8b ce		 mov	 ecx, esi
  0002e	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00033	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00036	66 c7 02 09 00	 mov	 WORD PTR [edx], 9
  0003b	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0003e	83 c2 02	 add	 edx, 2

; 834  : 	m_Snapshot.ar << i;

  00041	6a 01		 push	 1
  00043	8b ce		 mov	 ecx, esi
  00045	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00048	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0004d	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00050	8a 4c 24 0c	 mov	 cl, BYTE PTR _i$[esp]
  00054	88 08		 mov	 BYTE PTR [eax], cl
  00056	ff 46 08	 inc	 DWORD PTR [esi+8]
  00059	5e		 pop	 esi
$L298613:

; 835  : }

  0005a	c2 08 00	 ret	 8
?AddTradePull@CUser@@QAEXKE@Z ENDP			; CUser::AddTradePull
_TEXT	ENDS
PUBLIC	?AddTradePutGold@CUser@@QAEXKK@Z		; CUser::AddTradePutGold
; Function compile flags: /Ogty
;	COMDAT ?AddTradePutGold@CUser@@QAEXKK@Z
_TEXT	SEGMENT
_objid$ = 8						; size = 4
_dwGold$ = 12						; size = 4
?AddTradePutGold@CUser@@QAEXKK@Z PROC NEAR		; CUser::AddTradePutGold, COMDAT
; _this$ = ecx

; 839  : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	75 55		 jne	 SHORT $L298631

; 840  : 
; 841  : 	m_Snapshot.cb++;

  00006	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  0000d	56		 push	 esi

; 842  : 	m_Snapshot.ar << objid;

  0000e	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  00014	6a 04		 push	 4
  00016	8b ce		 mov	 ecx, esi
  00018	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0001d	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00020	8b 4c 24 08	 mov	 ecx, DWORD PTR _objid$[esp]
  00024	89 08		 mov	 DWORD PTR [eax], ecx
  00026	83 46 08 04	 add	 DWORD PTR [esi+8], 4

; 843  : 	m_Snapshot.ar << SNAPSHOTTYPE_TRADEPUTGOLD;

  0002a	6a 02		 push	 2
  0002c	8b ce		 mov	 ecx, esi
  0002e	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00033	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00036	66 c7 02 20 00	 mov	 WORD PTR [edx], 32	; 00000020H
  0003b	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0003e	83 c2 02	 add	 edx, 2

; 844  : 	m_Snapshot.ar << dwGold;

  00041	6a 04		 push	 4
  00043	8b ce		 mov	 ecx, esi
  00045	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00048	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0004d	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00050	8b 4c 24 0c	 mov	 ecx, DWORD PTR _dwGold$[esp]
  00054	89 08		 mov	 DWORD PTR [eax], ecx
  00056	83 46 08 04	 add	 DWORD PTR [esi+8], 4
  0005a	5e		 pop	 esi
$L298631:

; 845  : }

  0005b	c2 08 00	 ret	 8
?AddTradePutGold@CUser@@QAEXKK@Z ENDP			; CUser::AddTradePutGold
_TEXT	ENDS
PUBLIC	?AddUnregisterPVendorItem@CUser@@QAEXE@Z	; CUser::AddUnregisterPVendorItem
; Function compile flags: /Ogty
;	COMDAT ?AddUnregisterPVendorItem@CUser@@QAEXE@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 1
?AddUnregisterPVendorItem@CUser@@QAEXE@Z PROC NEAR	; CUser::AddUnregisterPVendorItem, COMDAT
; _this$ = ecx

; 882  : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	75 61		 jne	 SHORT $L298653

; 883  : 	m_Snapshot.cb++;

  00006	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  0000d	56		 push	 esi
  0000e	57		 push	 edi

; 884  : 	m_Snapshot.ar << GetId();

  0000f	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  00015	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  0001b	6a 04		 push	 4
  0001d	8b ce		 mov	 ecx, esi
  0001f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00024	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00027	89 38		 mov	 DWORD PTR [eax], edi
  00029	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0002c	83 c0 04	 add	 eax, 4

; 885  : 	m_Snapshot.ar << SNAPSHOTTYPE_UNREGISTER_PVENDOR_ITEM;

  0002f	6a 02		 push	 2
  00031	8b ce		 mov	 ecx, esi
  00033	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00036	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003b	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003e	66 c7 01 47 00	 mov	 WORD PTR [ecx], 71	; 00000047H
  00043	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00046	83 c2 02	 add	 edx, 2

; 886  : 	m_Snapshot.ar << iIndex;

  00049	6a 01		 push	 1
  0004b	8b ce		 mov	 ecx, esi
  0004d	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00050	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00055	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00058	8a 44 24 0c	 mov	 al, BYTE PTR _iIndex$[esp+4]
  0005c	88 02		 mov	 BYTE PTR [edx], al
  0005e	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00061	40		 inc	 eax
  00062	5f		 pop	 edi
  00063	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00066	5e		 pop	 esi
$L298653:

; 887  : }

  00067	c2 04 00	 ret	 4
?AddUnregisterPVendorItem@CUser@@QAEXE@Z ENDP		; CUser::AddUnregisterPVendorItem
_TEXT	ENDS
PUBLIC	?AddPVendorClose@CUser@@QAEXK@Z			; CUser::AddPVendorClose
; Function compile flags: /Ogty
;	COMDAT ?AddPVendorClose@CUser@@QAEXK@Z
_TEXT	SEGMENT
_objidVendor$ = 8					; size = 4
?AddPVendorClose@CUser@@QAEXK@Z PROC NEAR		; CUser::AddPVendorClose, COMDAT
; _this$ = ecx

; 900  : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	75 51		 jne	 SHORT $L298671

; 901  : 	m_Snapshot.cb++;

  00006	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  0000d	56		 push	 esi

; 902  : 	m_Snapshot.ar << objidVendor;

  0000e	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  00014	6a 04		 push	 4
  00016	8b ce		 mov	 ecx, esi
  00018	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0001d	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00020	8b 4c 24 08	 mov	 ecx, DWORD PTR _objidVendor$[esp]
  00024	89 08		 mov	 DWORD PTR [eax], ecx
  00026	83 46 08 04	 add	 DWORD PTR [esi+8], 4

; 903  : 	m_Snapshot.ar << SNAPSHOTTYPE_PVENDOR_CLOSE;

  0002a	6a 02		 push	 2
  0002c	8b ce		 mov	 ecx, esi
  0002e	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00033	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00036	66 c7 02 43 00	 mov	 WORD PTR [edx], 67	; 00000043H
  0003b	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0003e	83 c2 02	 add	 edx, 2

; 904  : 	m_Snapshot.ar << (BYTE)0;

  00041	6a 01		 push	 1
  00043	8b ce		 mov	 ecx, esi
  00045	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00048	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0004d	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00050	c6 00 00	 mov	 BYTE PTR [eax], 0
  00053	ff 46 08	 inc	 DWORD PTR [esi+8]
  00056	5e		 pop	 esi
$L298671:

; 905  : }

  00057	c2 04 00	 ret	 4
?AddPVendorClose@CUser@@QAEXK@Z ENDP			; CUser::AddPVendorClose
_TEXT	ENDS
PUBLIC	?AddPutItemGuildBank@CUser@@QAEXPAVCItemElem@@@Z ; CUser::AddPutItemGuildBank
; Function compile flags: /Ogty
;	COMDAT ?AddPutItemGuildBank@CUser@@QAEXPAVCItemElem@@@Z
_TEXT	SEGMENT
_pItemElem$ = 8						; size = 4
?AddPutItemGuildBank@CUser@@QAEXPAVCItemElem@@@Z PROC NEAR ; CUser::AddPutItemGuildBank, COMDAT
; _this$ = ecx

; 939  : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	75 5f		 jne	 SHORT $L278235

; 940  : 	m_Snapshot.cb++;

  00006	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  0000d	56		 push	 esi
  0000e	57		 push	 edi

; 941  : 	m_Snapshot.ar << GetId();

  0000f	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  00015	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  0001b	6a 04		 push	 4
  0001d	8b ce		 mov	 ecx, esi
  0001f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00024	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00027	89 38		 mov	 DWORD PTR [eax], edi
  00029	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  0002c	83 c7 04	 add	 edi, 4

; 942  : 	m_Snapshot.ar << SNAPSHOTTYPE_PUTITEMGUILDBANK;

  0002f	6a 02		 push	 2
  00031	8b ce		 mov	 ecx, esi
  00033	89 7e 08	 mov	 DWORD PTR [esi+8], edi
  00036	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003b	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003e	66 c7 01 ef 00	 mov	 WORD PTR [ecx], 239	; 000000efH
  00043	83 46 08 02	 add	 DWORD PTR [esi+8], 2

; 943  : 	m_Snapshot.ar << (BYTE)1; //   

  00047	6a 01		 push	 1
  00049	8b ce		 mov	 ecx, esi
  0004b	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00050	8b 56 08	 mov	 edx, DWORD PTR [esi+8]

; 944  : 	pItemElem->Serialize( m_Snapshot.ar );

  00053	8b 4c 24 0c	 mov	 ecx, DWORD PTR _pItemElem$[esp+4]
  00057	c6 02 01	 mov	 BYTE PTR [edx], 1
  0005a	ff 46 08	 inc	 DWORD PTR [esi+8]
  0005d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0005f	56		 push	 esi
  00060	ff 50 08	 call	 DWORD PTR [eax+8]
  00063	5f		 pop	 edi
  00064	5e		 pop	 esi
$L278235:

; 945  : }

  00065	c2 04 00	 ret	 4
?AddPutItemGuildBank@CUser@@QAEXPAVCItemElem@@@Z ENDP	; CUser::AddPutItemGuildBank
_TEXT	ENDS
PUBLIC	?AddGetItemGuildBank@CUser@@QAEXPAVCItemElem@@@Z ; CUser::AddGetItemGuildBank
; Function compile flags: /Ogty
;	COMDAT ?AddGetItemGuildBank@CUser@@QAEXPAVCItemElem@@@Z
_TEXT	SEGMENT
_pItemElem$ = 8						; size = 4
?AddGetItemGuildBank@CUser@@QAEXPAVCItemElem@@@Z PROC NEAR ; CUser::AddGetItemGuildBank, COMDAT
; _this$ = ecx

; 949  : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	75 5f		 jne	 SHORT $L278242

; 950  : 	m_Snapshot.cb++;

  00006	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  0000d	56		 push	 esi
  0000e	57		 push	 edi

; 951  : 	m_Snapshot.ar << GetId();

  0000f	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  00015	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  0001b	6a 04		 push	 4
  0001d	8b ce		 mov	 ecx, esi
  0001f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00024	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00027	89 38		 mov	 DWORD PTR [eax], edi
  00029	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  0002c	83 c7 04	 add	 edi, 4

; 952  : 	m_Snapshot.ar << SNAPSHOTTYPE_GETITEMGUILDBANK;

  0002f	6a 02		 push	 2
  00031	8b ce		 mov	 ecx, esi
  00033	89 7e 08	 mov	 DWORD PTR [esi+8], edi
  00036	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003b	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003e	66 c7 01 d4 00	 mov	 WORD PTR [ecx], 212	; 000000d4H
  00043	83 46 08 02	 add	 DWORD PTR [esi+8], 2

; 953  : 	m_Snapshot.ar << (BYTE)1; //   

  00047	6a 01		 push	 1
  00049	8b ce		 mov	 ecx, esi
  0004b	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00050	8b 56 08	 mov	 edx, DWORD PTR [esi+8]

; 954  : 	pItemElem->Serialize( m_Snapshot.ar );

  00053	8b 4c 24 0c	 mov	 ecx, DWORD PTR _pItemElem$[esp+4]
  00057	c6 02 01	 mov	 BYTE PTR [edx], 1
  0005a	ff 46 08	 inc	 DWORD PTR [esi+8]
  0005d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0005f	56		 push	 esi
  00060	ff 50 08	 call	 DWORD PTR [eax+8]
  00063	5f		 pop	 edi
  00064	5e		 pop	 esi
$L278242:

; 955  : }

  00065	c2 04 00	 ret	 4
?AddGetItemGuildBank@CUser@@QAEXPAVCItemElem@@@Z ENDP	; CUser::AddGetItemGuildBank
_TEXT	ENDS
PUBLIC	?AddGetGoldGuildBank@CUser@@QAEXKEKE@Z		; CUser::AddGetGoldGuildBank
; Function compile flags: /Ogty
;	COMDAT ?AddGetGoldGuildBank@CUser@@QAEXKEKE@Z
_TEXT	SEGMENT
_p_Gold$ = 8						; size = 4
_p_Mode$ = 12						; size = 1
_playerID$ = 16						; size = 4
_cbCloak$ = 20						; size = 1
?AddGetGoldGuildBank@CUser@@QAEXKEKE@Z PROC NEAR	; CUser::AddGetGoldGuildBank, COMDAT
; _this$ = ecx

; 959  : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	0f 85 b0 00 00
	00		 jne	 $L298749

; 960  : 	m_Snapshot.cb++;

  0000a	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  00011	56		 push	 esi
  00012	57		 push	 edi

; 961  : 	m_Snapshot.ar << GetId();

  00013	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  00019	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  0001f	6a 04		 push	 4
  00021	8b ce		 mov	 ecx, esi
  00023	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00028	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0002b	89 38		 mov	 DWORD PTR [eax], edi
  0002d	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00030	83 c2 04	 add	 edx, 4

; 962  : 	m_Snapshot.ar << SNAPSHOTTYPE_GETITEMGUILDBANK;

  00033	6a 02		 push	 2
  00035	8b ce		 mov	 ecx, esi
  00037	89 56 08	 mov	 DWORD PTR [esi+8], edx
  0003a	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003f	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00042	66 c7 01 d4 00	 mov	 WORD PTR [ecx], 212	; 000000d4H
  00047	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0004a	83 c0 02	 add	 eax, 2

; 963  : 	m_Snapshot.ar << (BYTE)p_Mode; // Gold  (0, 2 .)

  0004d	6a 01		 push	 1
  0004f	8b ce		 mov	 ecx, esi
  00051	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00054	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00059	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0005c	8a 44 24 10	 mov	 al, BYTE PTR _p_Mode$[esp+4]
  00060	88 02		 mov	 BYTE PTR [edx], al
  00062	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00065	42		 inc	 edx

; 964  : 	m_Snapshot.ar << p_Gold;

  00066	6a 04		 push	 4
  00068	8b ce		 mov	 ecx, esi
  0006a	89 56 08	 mov	 DWORD PTR [esi+8], edx
  0006d	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00072	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00075	8b 54 24 0c	 mov	 edx, DWORD PTR _p_Gold$[esp+4]
  00079	89 11		 mov	 DWORD PTR [ecx], edx
  0007b	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0007e	83 c0 04	 add	 eax, 4

; 965  : 	m_Snapshot.ar << playerID;	   //   

  00081	6a 04		 push	 4
  00083	8b ce		 mov	 ecx, esi
  00085	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00088	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0008d	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00090	8b 4c 24 14	 mov	 ecx, DWORD PTR _playerID$[esp+4]
  00094	89 08		 mov	 DWORD PTR [eax], ecx
  00096	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00099	83 c2 04	 add	 edx, 4

; 966  : 	m_Snapshot.ar << cbCloak;	   //   (= 1)

  0009c	6a 01		 push	 1
  0009e	8b ce		 mov	 ecx, esi
  000a0	89 56 08	 mov	 DWORD PTR [esi+8], edx
  000a3	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000a8	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  000ab	8a 44 24 18	 mov	 al, BYTE PTR _cbCloak$[esp+4]
  000af	88 02		 mov	 BYTE PTR [edx], al
  000b1	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000b4	40		 inc	 eax
  000b5	5f		 pop	 edi
  000b6	89 46 08	 mov	 DWORD PTR [esi+8], eax
  000b9	5e		 pop	 esi
$L298749:

; 967  : }

  000ba	c2 10 00	 ret	 16			; 00000010H
?AddGetGoldGuildBank@CUser@@QAEXKEKE@Z ENDP		; CUser::AddGetGoldGuildBank
_TEXT	ENDS
PUBLIC	?AddPutItemBank@CUser@@QAEXEPAVCItemElem@@@Z	; CUser::AddPutItemBank
; Function compile flags: /Ogty
;	COMDAT ?AddPutItemBank@CUser@@QAEXEPAVCItemElem@@@Z
_TEXT	SEGMENT
_nSlot$ = 8						; size = 1
_pItemElem$ = 12					; size = 4
?AddPutItemBank@CUser@@QAEXEPAVCItemElem@@@Z PROC NEAR	; CUser::AddPutItemBank, COMDAT
; _this$ = ecx

; 972  : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	75 62		 jne	 SHORT $L278260

; 973  : 	m_Snapshot.cb++;

  00006	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  0000d	56		 push	 esi
  0000e	57		 push	 edi

; 974  : 	m_Snapshot.ar << GetId();

  0000f	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  00015	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  0001b	6a 04		 push	 4
  0001d	8b ce		 mov	 ecx, esi
  0001f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00024	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00027	89 38		 mov	 DWORD PTR [eax], edi
  00029	83 46 08 04	 add	 DWORD PTR [esi+8], 4

; 975  : 	m_Snapshot.ar << SNAPSHOTTYPE_PUTITEMBANK;

  0002d	6a 02		 push	 2
  0002f	8b ce		 mov	 ecx, esi
  00031	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00036	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00039	66 c7 01 50 00	 mov	 WORD PTR [ecx], 80	; 00000050H
  0003e	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  00041	83 c7 02	 add	 edi, 2

; 976  : 	m_Snapshot.ar << nSlot;

  00044	6a 01		 push	 1
  00046	8b ce		 mov	 ecx, esi
  00048	89 7e 08	 mov	 DWORD PTR [esi+8], edi
  0004b	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00050	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00053	8a 44 24 0c	 mov	 al, BYTE PTR _nSlot$[esp+4]
  00057	88 02		 mov	 BYTE PTR [edx], al
  00059	ff 46 08	 inc	 DWORD PTR [esi+8]

; 977  : 	pItemElem->Serialize( m_Snapshot.ar );

  0005c	8b 4c 24 10	 mov	 ecx, DWORD PTR _pItemElem$[esp+4]
  00060	8b 11		 mov	 edx, DWORD PTR [ecx]
  00062	56		 push	 esi
  00063	ff 52 08	 call	 DWORD PTR [edx+8]
  00066	5f		 pop	 edi
  00067	5e		 pop	 esi
$L278260:

; 978  : }

  00068	c2 08 00	 ret	 8
?AddPutItemBank@CUser@@QAEXEPAVCItemElem@@@Z ENDP	; CUser::AddPutItemBank
_TEXT	ENDS
PUBLIC	?AddGetItemBank@CUser@@QAEXPAVCItemElem@@@Z	; CUser::AddGetItemBank
; Function compile flags: /Ogty
;	COMDAT ?AddGetItemBank@CUser@@QAEXPAVCItemElem@@@Z
_TEXT	SEGMENT
_pItemElem$ = 8						; size = 4
?AddGetItemBank@CUser@@QAEXPAVCItemElem@@@Z PROC NEAR	; CUser::AddGetItemBank, COMDAT
; _this$ = ecx

; 982  : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	75 4d		 jne	 SHORT $L278266

; 983  : 	m_Snapshot.cb++;

  00006	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  0000d	56		 push	 esi
  0000e	57		 push	 edi

; 984  : 	m_Snapshot.ar << GetId();

  0000f	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  00015	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  0001b	6a 04		 push	 4
  0001d	8b ce		 mov	 ecx, esi
  0001f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00024	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00027	89 38		 mov	 DWORD PTR [eax], edi
  00029	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  0002c	83 c7 04	 add	 edi, 4

; 985  : 	m_Snapshot.ar << SNAPSHOTTYPE_GETITEMBANK;

  0002f	6a 02		 push	 2
  00031	8b ce		 mov	 ecx, esi
  00033	89 7e 08	 mov	 DWORD PTR [esi+8], edi
  00036	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003b	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003e	66 c7 01 51 00	 mov	 WORD PTR [ecx], 81	; 00000051H
  00043	83 46 08 02	 add	 DWORD PTR [esi+8], 2

; 986  : 	pItemElem->Serialize( m_Snapshot.ar );

  00047	8b 4c 24 0c	 mov	 ecx, DWORD PTR _pItemElem$[esp+4]
  0004b	8b 11		 mov	 edx, DWORD PTR [ecx]
  0004d	56		 push	 esi
  0004e	ff 52 08	 call	 DWORD PTR [edx+8]
  00051	5f		 pop	 edi
  00052	5e		 pop	 esi
$L278266:

; 987  : }

  00053	c2 04 00	 ret	 4
?AddGetItemBank@CUser@@QAEXPAVCItemElem@@@Z ENDP	; CUser::AddGetItemBank
_TEXT	ENDS
PUBLIC	?AddPutGoldBank@CUser@@QAEXEKK@Z		; CUser::AddPutGoldBank
; Function compile flags: /Ogty
;	COMDAT ?AddPutGoldBank@CUser@@QAEXEKK@Z
_TEXT	SEGMENT
_nSlot$ = 8						; size = 1
_dwGold$ = 12						; size = 4
_dwGoldBank$ = 16					; size = 4
?AddPutGoldBank@CUser@@QAEXEKK@Z PROC NEAR		; CUser::AddPutGoldBank, COMDAT
; _this$ = ecx

; 991  : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	0f 85 97 00 00
	00		 jne	 $L298818

; 992  : 	m_Snapshot.cb++;

  0000a	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  00011	56		 push	 esi
  00012	57		 push	 edi

; 993  : 	m_Snapshot.ar << GetId();

  00013	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  00019	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  0001f	6a 04		 push	 4
  00021	8b ce		 mov	 ecx, esi
  00023	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00028	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0002b	89 38		 mov	 DWORD PTR [eax], edi
  0002d	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00030	83 c0 04	 add	 eax, 4

; 994  : 	m_Snapshot.ar << SNAPSHOTTYPE_PUTGOLDBANK;

  00033	6a 02		 push	 2
  00035	8b ce		 mov	 ecx, esi
  00037	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0003a	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003f	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00042	66 c7 01 52 00	 mov	 WORD PTR [ecx], 82	; 00000052H
  00047	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0004a	83 c2 02	 add	 edx, 2

; 995  : 	m_Snapshot.ar << nSlot << dwGold << dwGoldBank;

  0004d	6a 01		 push	 1
  0004f	8b ce		 mov	 ecx, esi
  00051	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00054	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00059	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0005c	8a 44 24 0c	 mov	 al, BYTE PTR _nSlot$[esp+4]
  00060	88 02		 mov	 BYTE PTR [edx], al
  00062	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00065	40		 inc	 eax
  00066	6a 04		 push	 4
  00068	8b ce		 mov	 ecx, esi
  0006a	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0006d	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00072	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00075	8b 54 24 10	 mov	 edx, DWORD PTR _dwGold$[esp+4]
  00079	89 11		 mov	 DWORD PTR [ecx], edx
  0007b	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0007e	83 c2 04	 add	 edx, 4
  00081	6a 04		 push	 4
  00083	8b ce		 mov	 ecx, esi
  00085	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00088	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0008d	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00090	8b 4c 24 14	 mov	 ecx, DWORD PTR _dwGoldBank$[esp+4]
  00094	89 08		 mov	 DWORD PTR [eax], ecx
  00096	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00099	83 c0 04	 add	 eax, 4
  0009c	5f		 pop	 edi
  0009d	89 46 08	 mov	 DWORD PTR [esi+8], eax
  000a0	5e		 pop	 esi
$L298818:

; 996  : }

  000a1	c2 0c 00	 ret	 12			; 0000000cH
?AddPutGoldBank@CUser@@QAEXEKK@Z ENDP			; CUser::AddPutGoldBank
_TEXT	ENDS
PUBLIC	?AddMoveBankItem@CUser@@QAEXEE@Z		; CUser::AddMoveBankItem
; Function compile flags: /Ogty
;	COMDAT ?AddMoveBankItem@CUser@@QAEXEE@Z
_TEXT	SEGMENT
_nSrcIndex$ = 8						; size = 1
_nDestIndex$ = 12					; size = 1
?AddMoveBankItem@CUser@@QAEXEE@Z PROC NEAR		; CUser::AddMoveBankItem, COMDAT
; _this$ = ecx

; 1000 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	75 7a		 jne	 SHORT $L298843

; 1001 : 	
; 1002 : 	m_Snapshot.cb++;

  00006	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  0000d	56		 push	 esi
  0000e	57		 push	 edi

; 1003 : 	m_Snapshot.ar << GetId();

  0000f	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  00015	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  0001b	6a 04		 push	 4
  0001d	8b ce		 mov	 ecx, esi
  0001f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00024	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00027	89 38		 mov	 DWORD PTR [eax], edi
  00029	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0002c	83 c2 04	 add	 edx, 4

; 1004 : 	m_Snapshot.ar << SNAPSHOTTYPE_MOVEBANKITEM;

  0002f	6a 02		 push	 2
  00031	8b ce		 mov	 ecx, esi
  00033	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00036	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003b	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003e	66 c7 01 53 00	 mov	 WORD PTR [ecx], 83	; 00000053H
  00043	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00046	83 c0 02	 add	 eax, 2

; 1005 : 	m_Snapshot.ar << nSrcIndex << nDestIndex;

  00049	6a 01		 push	 1
  0004b	8b ce		 mov	 ecx, esi
  0004d	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00050	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00055	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00058	8a 44 24 0c	 mov	 al, BYTE PTR _nSrcIndex$[esp+4]
  0005c	88 02		 mov	 BYTE PTR [edx], al
  0005e	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00061	42		 inc	 edx
  00062	6a 01		 push	 1
  00064	8b ce		 mov	 ecx, esi
  00066	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00069	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0006e	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00071	8a 54 24 10	 mov	 dl, BYTE PTR _nDestIndex$[esp+4]
  00075	88 11		 mov	 BYTE PTR [ecx], dl
  00077	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0007a	40		 inc	 eax
  0007b	5f		 pop	 edi
  0007c	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0007f	5e		 pop	 esi
$L298843:

; 1006 : }

  00080	c2 08 00	 ret	 8
?AddMoveBankItem@CUser@@QAEXEE@Z ENDP			; CUser::AddMoveBankItem
_TEXT	ENDS
PUBLIC	?AddBankIsFull@CUser@@QAEXXZ			; CUser::AddBankIsFull
; Function compile flags: /Ogty
;	COMDAT ?AddBankIsFull@CUser@@QAEXXZ
_TEXT	SEGMENT
?AddBankIsFull@CUser@@QAEXXZ PROC NEAR			; CUser::AddBankIsFull, COMDAT
; _this$ = ecx

; 1010 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	75 48		 jne	 SHORT $L298860

; 1011 : 	
; 1012 : 	m_Snapshot.cb++;

  00006	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  0000d	56		 push	 esi
  0000e	57		 push	 edi

; 1013 : 	m_Snapshot.ar << GetId();

  0000f	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  00015	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  0001b	6a 04		 push	 4
  0001d	8b ce		 mov	 ecx, esi
  0001f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00024	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00027	89 38		 mov	 DWORD PTR [eax], edi
  00029	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0002c	83 c2 04	 add	 edx, 4

; 1014 : 	m_Snapshot.ar << SNAPSHOTTYPE_BANKISFULL;

  0002f	6a 02		 push	 2
  00031	8b ce		 mov	 ecx, esi
  00033	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00036	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003b	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003e	66 c7 01 55 00	 mov	 WORD PTR [ecx], 85	; 00000055H
  00043	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00046	83 c0 02	 add	 eax, 2
  00049	5f		 pop	 edi
  0004a	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0004d	5e		 pop	 esi
$L298860:

; 1015 : }

  0004e	c3		 ret	 0
?AddBankIsFull@CUser@@QAEXXZ ENDP			; CUser::AddBankIsFull
_TEXT	ENDS
PUBLIC	?AddRemoveSkillInfluence@CUser@@QAEXGG@Z	; CUser::AddRemoveSkillInfluence
; Function compile flags: /Ogty
;	COMDAT ?AddRemoveSkillInfluence@CUser@@QAEXGG@Z
_TEXT	SEGMENT
_wType$ = 8						; size = 2
_wID$ = 12						; size = 2
?AddRemoveSkillInfluence@CUser@@QAEXGG@Z PROC NEAR	; CUser::AddRemoveSkillInfluence, COMDAT
; _this$ = ecx

; 1019 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	75 77		 jne	 SHORT $L298886

; 1020 : 	
; 1021 : 	m_Snapshot.cb++;

  00006	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  0000d	56		 push	 esi
  0000e	57		 push	 edi

; 1022 : 	m_Snapshot.ar << GetId();

  0000f	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  00015	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  0001b	6a 04		 push	 4
  0001d	8b ce		 mov	 ecx, esi
  0001f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00024	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00027	89 38		 mov	 DWORD PTR [eax], edi
  00029	83 46 08 04	 add	 DWORD PTR [esi+8], 4

; 1023 : 	m_Snapshot.ar << SNAPSHOTTYPE_REMOVESKILLINFULENCE;

  0002d	bf 02 00 00 00	 mov	 edi, 2
  00032	57		 push	 edi
  00033	8b ce		 mov	 ecx, esi
  00035	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003a	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003d	66 c7 01 f8 00	 mov	 WORD PTR [ecx], 248	; 000000f8H
  00042	01 7e 08	 add	 DWORD PTR [esi+8], edi

; 1024 : 	m_Snapshot.ar << wType;

  00045	57		 push	 edi
  00046	8b ce		 mov	 ecx, esi
  00048	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0004d	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00050	66 8b 44 24 0c	 mov	 ax, WORD PTR _wType$[esp+4]
  00055	66 89 02	 mov	 WORD PTR [edx], ax
  00058	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0005b	03 d7		 add	 edx, edi

; 1025 : 	m_Snapshot.ar << wID;

  0005d	57		 push	 edi
  0005e	8b ce		 mov	 ecx, esi
  00060	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00063	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00068	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0006b	66 8b 54 24 10	 mov	 dx, WORD PTR _wID$[esp+4]
  00070	66 89 11	 mov	 WORD PTR [ecx], dx
  00073	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00076	03 c7		 add	 eax, edi
  00078	5f		 pop	 edi
  00079	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0007c	5e		 pop	 esi
$L298886:

; 1026 : 	
; 1027 : }

  0007d	c2 08 00	 ret	 8
?AddRemoveSkillInfluence@CUser@@QAEXGG@Z ENDP		; CUser::AddRemoveSkillInfluence
_TEXT	ENDS
PUBLIC	?AddSetFxp@CUser@@QAEXHH@Z			; CUser::AddSetFxp
; Function compile flags: /Ogty
;	COMDAT ?AddSetFxp@CUser@@QAEXHH@Z
_TEXT	SEGMENT
_nFxp$ = 8						; size = 4
_nFlightLv$ = 12					; size = 4
?AddSetFxp@CUser@@QAEXHH@Z PROC NEAR			; CUser::AddSetFxp, COMDAT
; _this$ = ecx

; 1134 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	75 77		 jne	 SHORT $L298912

; 1135 : 	
; 1136 : 	m_Snapshot.cb++;

  00006	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  0000d	56		 push	 esi
  0000e	57		 push	 edi

; 1137 : 	m_Snapshot.ar << GetId();

  0000f	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  00015	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  0001b	6a 04		 push	 4
  0001d	8b ce		 mov	 ecx, esi
  0001f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00024	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00027	89 38		 mov	 DWORD PTR [eax], edi
  00029	83 46 08 04	 add	 DWORD PTR [esi+8], 4

; 1138 : 	m_Snapshot.ar << SNAPSHOTTYPE_SETFXP;

  0002d	bf 02 00 00 00	 mov	 edi, 2
  00032	57		 push	 edi
  00033	8b ce		 mov	 ecx, esi
  00035	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003a	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003d	66 c7 01 29 00	 mov	 WORD PTR [ecx], 41	; 00000029H
  00042	01 7e 08	 add	 DWORD PTR [esi+8], edi

; 1139 : 	m_Snapshot.ar << (WORD)nFxp << (WORD)nFlightLv;

  00045	57		 push	 edi
  00046	8b ce		 mov	 ecx, esi
  00048	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0004d	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00050	66 8b 44 24 0c	 mov	 ax, WORD PTR _nFxp$[esp+4]
  00055	66 89 02	 mov	 WORD PTR [edx], ax
  00058	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0005b	03 d7		 add	 edx, edi
  0005d	57		 push	 edi
  0005e	8b ce		 mov	 ecx, esi
  00060	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00063	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00068	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0006b	66 8b 54 24 10	 mov	 dx, WORD PTR _nFlightLv$[esp+4]
  00070	66 89 11	 mov	 WORD PTR [ecx], dx
  00073	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00076	03 c7		 add	 eax, edi
  00078	5f		 pop	 edi
  00079	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0007c	5e		 pop	 esi
$L298912:

; 1140 : }

  0007d	c2 08 00	 ret	 8
?AddSetFxp@CUser@@QAEXHH@Z ENDP				; CUser::AddSetFxp
_TEXT	ENDS
PUBLIC	?AddSetGrowthLearningPoint@CUser@@QAEXJ@Z	; CUser::AddSetGrowthLearningPoint
; Function compile flags: /Ogty
;	COMDAT ?AddSetGrowthLearningPoint@CUser@@QAEXJ@Z
_TEXT	SEGMENT
_nRemainGP$ = 8						; size = 4
?AddSetGrowthLearningPoint@CUser@@QAEXJ@Z PROC NEAR	; CUser::AddSetGrowthLearningPoint, COMDAT
; _this$ = ecx

; 1144 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	75 7e		 jne	 SHORT $L298937

; 1145 : 
; 1146 : 	m_Snapshot.cb++;

  00006	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  0000d	56		 push	 esi
  0000e	57		 push	 edi

; 1147 : 	m_Snapshot.ar << GetId();

  0000f	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  00015	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  0001b	6a 04		 push	 4
  0001d	8b ce		 mov	 ecx, esi
  0001f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00024	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00027	89 38		 mov	 DWORD PTR [eax], edi
  00029	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0002c	83 c2 04	 add	 edx, 4

; 1148 : 	m_Snapshot.ar << SNAPSHOTTYPE_SET_GROWTH_LEARNING_POINT;

  0002f	6a 02		 push	 2
  00031	8b ce		 mov	 ecx, esi
  00033	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00036	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003b	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003e	66 c7 01 a6 00	 mov	 WORD PTR [ecx], 166	; 000000a6H
  00043	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00046	83 c0 02	 add	 eax, 2

; 1149 : 	m_Snapshot.ar << nRemainGP << (long)0;

  00049	6a 04		 push	 4
  0004b	8b ce		 mov	 ecx, esi
  0004d	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00050	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00055	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00058	8b 44 24 0c	 mov	 eax, DWORD PTR _nRemainGP$[esp+4]
  0005c	89 02		 mov	 DWORD PTR [edx], eax
  0005e	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00061	83 c2 04	 add	 edx, 4
  00064	6a 04		 push	 4
  00066	8b ce		 mov	 ecx, esi
  00068	89 56 08	 mov	 DWORD PTR [esi+8], edx
  0006b	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00070	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00073	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  00079	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0007c	83 c0 04	 add	 eax, 4
  0007f	5f		 pop	 edi
  00080	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00083	5e		 pop	 esi
$L298937:

; 1150 : }

  00084	c2 04 00	 ret	 4
?AddSetGrowthLearningPoint@CUser@@QAEXJ@Z ENDP		; CUser::AddSetGrowthLearningPoint
_TEXT	ENDS
PUBLIC	?AddGameTimer@CUser@@QAEXN@Z			; CUser::AddGameTimer
; Function compile flags: /Ogty
;	COMDAT ?AddGameTimer@CUser@@QAEXN@Z
_TEXT	SEGMENT
_dCurrentTime$ = 8					; size = 8
?AddGameTimer@CUser@@QAEXN@Z PROC NEAR			; CUser::AddGameTimer, COMDAT
; _this$ = ecx

; 1197 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	75 63		 jne	 SHORT $L298958

; 1198 : 	
; 1199 : 	m_Snapshot.cb++;

  00006	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  0000d	56		 push	 esi
  0000e	57		 push	 edi

; 1200 : 	m_Snapshot.ar << GetId();

  0000f	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  00015	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  0001b	6a 04		 push	 4
  0001d	8b ce		 mov	 ecx, esi
  0001f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00024	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00027	89 38		 mov	 DWORD PTR [eax], edi
  00029	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0002c	83 c0 04	 add	 eax, 4

; 1201 : 	m_Snapshot.ar << SNAPSHOTTYPE_GAMETIMER;

  0002f	6a 02		 push	 2
  00031	8b ce		 mov	 ecx, esi
  00033	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00036	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003b	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003e	66 c7 01 96 00	 mov	 WORD PTR [ecx], 150	; 00000096H
  00043	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00046	83 c2 02	 add	 edx, 2

; 1202 : 	m_Snapshot.ar << dCurrentTime;

  00049	6a 08		 push	 8
  0004b	8b ce		 mov	 ecx, esi
  0004d	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00050	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00055	dd 44 24 0c	 fld	 QWORD PTR _dCurrentTime$[esp+4]
  00059	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0005c	dd 1a		 fstp	 QWORD PTR [edx]
  0005e	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00061	83 c0 08	 add	 eax, 8
  00064	5f		 pop	 edi
  00065	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00068	5e		 pop	 esi
$L298958:

; 1203 : 	
; 1204 : }

  00069	c2 08 00	 ret	 8
?AddGameTimer@CUser@@QAEXN@Z ENDP			; CUser::AddGameTimer
_TEXT	ENDS
PUBLIC	?AddDoEquip@CUser@@QAEXEKE@Z			; CUser::AddDoEquip
; Function compile flags: /Ogty
;	COMDAT ?AddDoEquip@CUser@@QAEXEKE@Z
_TEXT	SEGMENT
_nId$ = 8						; size = 1
_dwItemId$ = 12						; size = 4
_fEquip$ = 16						; size = 1
?AddDoEquip@CUser@@QAEXEKE@Z PROC NEAR			; CUser::AddDoEquip, COMDAT
; _this$ = ecx

; 1208 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	0f 85 95 00 00
	00		 jne	 $L298987

; 1209 : 	
; 1210 : 	m_Snapshot.cb++;

  0000a	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  00011	56		 push	 esi
  00012	57		 push	 edi

; 1211 : 	m_Snapshot.ar << GetId();

  00013	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  00019	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  0001f	6a 04		 push	 4
  00021	8b ce		 mov	 ecx, esi
  00023	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00028	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0002b	89 38		 mov	 DWORD PTR [eax], edi
  0002d	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00030	83 c0 04	 add	 eax, 4

; 1212 : 	m_Snapshot.ar << SNAPSHOTTYPE_DOEQUIP;

  00033	6a 02		 push	 2
  00035	8b ce		 mov	 ecx, esi
  00037	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0003a	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003f	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00042	66 c7 01 06 00	 mov	 WORD PTR [ecx], 6
  00047	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0004a	83 c2 02	 add	 edx, 2

; 1213 : 	m_Snapshot.ar << nId << dwItemId << fEquip;

  0004d	6a 01		 push	 1
  0004f	8b ce		 mov	 ecx, esi
  00051	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00054	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00059	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0005c	8a 44 24 0c	 mov	 al, BYTE PTR _nId$[esp+4]
  00060	88 02		 mov	 BYTE PTR [edx], al
  00062	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00065	40		 inc	 eax
  00066	6a 04		 push	 4
  00068	8b ce		 mov	 ecx, esi
  0006a	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0006d	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00072	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00075	8b 54 24 10	 mov	 edx, DWORD PTR _dwItemId$[esp+4]
  00079	89 11		 mov	 DWORD PTR [ecx], edx
  0007b	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0007e	83 c2 04	 add	 edx, 4
  00081	6a 01		 push	 1
  00083	8b ce		 mov	 ecx, esi
  00085	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00088	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0008d	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00090	8a 4c 24 14	 mov	 cl, BYTE PTR _fEquip$[esp+4]
  00094	88 08		 mov	 BYTE PTR [eax], cl
  00096	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00099	40		 inc	 eax
  0009a	5f		 pop	 edi
  0009b	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0009e	5e		 pop	 esi
$L298987:

; 1214 : 	
; 1215 : }

  0009f	c2 0c 00	 ret	 12			; 0000000cH
?AddDoEquip@CUser@@QAEXEKE@Z ENDP			; CUser::AddDoEquip
_TEXT	ENDS
PUBLIC	?AddTaskBar@CUser@@QAEXXZ			; CUser::AddTaskBar
EXTRN	?Serialize@CUserTaskBar@@QAEXAAVCAr@@@Z:NEAR	; CUserTaskBar::Serialize
; Function compile flags: /Ogty
;	COMDAT ?AddTaskBar@CUser@@QAEXXZ
_TEXT	SEGMENT
?AddTaskBar@CUser@@QAEXXZ PROC NEAR			; CUser::AddTaskBar, COMDAT
; _this$ = ecx

; 1218 : {

  00000	57		 push	 edi
  00001	8b f9		 mov	 edi, ecx

; 1219 : 	if( IsDelete() )	return;

  00003	f6 47 04 01	 test	 BYTE PTR [edi+4], 1
  00007	75 4f		 jne	 SHORT $L278425

; 1220 : 	
; 1221 : 	m_Snapshot.cb++;

  00009	66 ff 87 0c 57
	00 00		 inc	 WORD PTR [edi+22284]
  00010	53		 push	 ebx

; 1222 : 	m_Snapshot.ar << GetId();

  00011	8b 9f bc 01 00
	00		 mov	 ebx, DWORD PTR [edi+444]
  00017	56		 push	 esi
  00018	8d b7 f8 16 00
	00		 lea	 esi, DWORD PTR [edi+5880]
  0001e	6a 04		 push	 4
  00020	8b ce		 mov	 ecx, esi
  00022	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00027	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0002a	89 18		 mov	 DWORD PTR [eax], ebx
  0002c	8b 5e 08	 mov	 ebx, DWORD PTR [esi+8]
  0002f	83 c3 04	 add	 ebx, 4

; 1223 : 	m_Snapshot.ar << SNAPSHOTTYPE_TASKBAR;

  00032	6a 02		 push	 2
  00034	8b ce		 mov	 ecx, esi
  00036	89 5e 08	 mov	 DWORD PTR [esi+8], ebx
  00039	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003e	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00041	66 c7 01 97 00	 mov	 WORD PTR [ecx], 151	; 00000097H
  00046	83 46 08 02	 add	 DWORD PTR [esi+8], 2

; 1224 : 	m_playTaskBar.Serialize( m_Snapshot.ar );

  0004a	56		 push	 esi
  0004b	8d 8f 7c 57 00
	00		 lea	 ecx, DWORD PTR [edi+22396]
  00051	e8 00 00 00 00	 call	 ?Serialize@CUserTaskBar@@QAEXAAVCAr@@@Z ; CUserTaskBar::Serialize
  00056	5e		 pop	 esi
  00057	5b		 pop	 ebx
$L278425:
  00058	5f		 pop	 edi

; 1225 : 	
; 1226 : }

  00059	c3		 ret	 0
?AddTaskBar@CUser@@QAEXXZ ENDP				; CUser::AddTaskBar
_TEXT	ENDS
PUBLIC	?AddSendErrorParty@CUser@@QAEXKK@Z		; CUser::AddSendErrorParty
; Function compile flags: /Ogty
;	COMDAT ?AddSendErrorParty@CUser@@QAEXKK@Z
_TEXT	SEGMENT
_dw$ = 8						; size = 4
_dwSkill$ = 12						; size = 4
?AddSendErrorParty@CUser@@QAEXKK@Z PROC NEAR		; CUser::AddSendErrorParty, COMDAT
; _this$ = ecx

; 1230 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	0f 85 80 00 00
	00		 jne	 $L299031

; 1231 : 	
; 1232 : 	m_Snapshot.cb++;

  0000a	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  00011	56		 push	 esi
  00012	57		 push	 edi

; 1233 : 	m_Snapshot.ar << GetId();

  00013	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  00019	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  0001f	6a 04		 push	 4
  00021	8b ce		 mov	 ecx, esi
  00023	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00028	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0002b	89 38		 mov	 DWORD PTR [eax], edi
  0002d	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00030	83 c2 04	 add	 edx, 4

; 1234 : 	m_Snapshot.ar << SNAPSHOTTYPE_ERRORPARTY;

  00033	6a 02		 push	 2
  00035	8b ce		 mov	 ecx, esi
  00037	89 56 08	 mov	 DWORD PTR [esi+8], edx
  0003a	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003f	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00042	66 c7 01 81 00	 mov	 WORD PTR [ecx], 129	; 00000081H
  00047	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0004a	83 c0 02	 add	 eax, 2

; 1235 : 	m_Snapshot.ar << dw;

  0004d	6a 04		 push	 4
  0004f	8b ce		 mov	 ecx, esi
  00051	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00054	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00059	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0005c	8b 44 24 0c	 mov	 eax, DWORD PTR _dw$[esp+4]
  00060	89 02		 mov	 DWORD PTR [edx], eax
  00062	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00065	83 c2 04	 add	 edx, 4

; 1236 : 	if( dw == ERROR_NOTTARGET )

  00068	3d cf 00 00 00	 cmp	 eax, 207		; 000000cfH
  0006d	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00070	75 16		 jne	 SHORT $L299033

; 1237 : 	{
; 1238 : 		m_Snapshot.ar << dwSkill;

  00072	6a 04		 push	 4
  00074	8b ce		 mov	 ecx, esi
  00076	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0007b	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0007e	8b 4c 24 10	 mov	 ecx, DWORD PTR _dwSkill$[esp+4]
  00082	89 08		 mov	 DWORD PTR [eax], ecx
  00084	83 46 08 04	 add	 DWORD PTR [esi+8], 4
$L299033:
  00088	5f		 pop	 edi
  00089	5e		 pop	 esi
$L299031:

; 1239 : 	}
; 1240 : 	
; 1241 : }

  0008a	c2 08 00	 ret	 8
?AddSendErrorParty@CUser@@QAEXKK@Z ENDP			; CUser::AddSendErrorParty
_TEXT	ENDS
PUBLIC	?AddPartyChangeName@CUser@@QAEXPBD@Z		; CUser::AddPartyChangeName
EXTRN	?WriteString@CAr@@QAEXPBD@Z:NEAR		; CAr::WriteString
; Function compile flags: /Ogty
;	COMDAT ?AddPartyChangeName@CUser@@QAEXPBD@Z
_TEXT	SEGMENT
_szPartyName$ = 8					; size = 4
?AddPartyChangeName@CUser@@QAEXPBD@Z PROC NEAR		; CUser::AddPartyChangeName, COMDAT
; _this$ = ecx

; 1342 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	75 4f		 jne	 SHORT $L278489

; 1343 : 	
; 1344 : 	m_Snapshot.cb++;

  00006	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  0000d	56		 push	 esi
  0000e	57		 push	 edi

; 1345 : 	m_Snapshot.ar << GetId();

  0000f	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  00015	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  0001b	6a 04		 push	 4
  0001d	8b ce		 mov	 ecx, esi
  0001f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00024	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00027	89 38		 mov	 DWORD PTR [eax], edi
  00029	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  0002c	83 c7 04	 add	 edi, 4

; 1346 : 	m_Snapshot.ar << SNAPSHOTTYPE_PARTYCHANGENAME;

  0002f	6a 02		 push	 2
  00031	8b ce		 mov	 ecx, esi
  00033	89 7e 08	 mov	 DWORD PTR [esi+8], edi
  00036	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003b	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]

; 1347 : 	m_Snapshot.ar.WriteString( szPartyName );

  0003e	8b 54 24 0c	 mov	 edx, DWORD PTR _szPartyName$[esp+4]
  00042	66 c7 01 89 00	 mov	 WORD PTR [ecx], 137	; 00000089H
  00047	83 46 08 02	 add	 DWORD PTR [esi+8], 2
  0004b	52		 push	 edx
  0004c	8b ce		 mov	 ecx, esi
  0004e	e8 00 00 00 00	 call	 ?WriteString@CAr@@QAEXPBD@Z ; CAr::WriteString
  00053	5f		 pop	 edi
  00054	5e		 pop	 esi
$L278489:

; 1348 : 	
; 1349 : }

  00055	c2 04 00	 ret	 4
?AddPartyChangeName@CUser@@QAEXPBD@Z ENDP		; CUser::AddPartyChangeName
_TEXT	ENDS
PUBLIC	?AddPartyChangeTroup@CUser@@QAEXPBD@Z		; CUser::AddPartyChangeTroup
; Function compile flags: /Ogty
;	COMDAT ?AddPartyChangeTroup@CUser@@QAEXPBD@Z
_TEXT	SEGMENT
_szPartyName$ = 8					; size = 4
?AddPartyChangeTroup@CUser@@QAEXPBD@Z PROC NEAR		; CUser::AddPartyChangeTroup, COMDAT
; _this$ = ecx

; 1353 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	75 4f		 jne	 SHORT $L278495

; 1354 : 	
; 1355 : 	m_Snapshot.cb++;

  00006	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  0000d	56		 push	 esi
  0000e	57		 push	 edi

; 1356 : 	m_Snapshot.ar << GetId();

  0000f	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  00015	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  0001b	6a 04		 push	 4
  0001d	8b ce		 mov	 ecx, esi
  0001f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00024	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00027	89 38		 mov	 DWORD PTR [eax], edi
  00029	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  0002c	83 c7 04	 add	 edi, 4

; 1357 : 	m_Snapshot.ar << SNAPSHOTTYPE_PARTYCHANGETROUP;

  0002f	6a 02		 push	 2
  00031	8b ce		 mov	 ecx, esi
  00033	89 7e 08	 mov	 DWORD PTR [esi+8], edi
  00036	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003b	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]

; 1358 : 	m_Snapshot.ar.WriteString( szPartyName );

  0003e	8b 54 24 0c	 mov	 edx, DWORD PTR _szPartyName$[esp+4]
  00042	66 c7 01 88 00	 mov	 WORD PTR [ecx], 136	; 00000088H
  00047	83 46 08 02	 add	 DWORD PTR [esi+8], 2
  0004b	52		 push	 edx
  0004c	8b ce		 mov	 ecx, esi
  0004e	e8 00 00 00 00	 call	 ?WriteString@CAr@@QAEXPBD@Z ; CAr::WriteString
  00053	5f		 pop	 edi
  00054	5e		 pop	 esi
$L278495:

; 1359 : 	
; 1360 : }

  00055	c2 04 00	 ret	 4
?AddPartyChangeTroup@CUser@@QAEXPBD@Z ENDP		; CUser::AddPartyChangeTroup
_TEXT	ENDS
PUBLIC	?AddPartyName@CUser@@QAEXXZ			; CUser::AddPartyName
; Function compile flags: /Ogty
;	COMDAT ?AddPartyName@CUser@@QAEXXZ
_TEXT	SEGMENT
?AddPartyName@CUser@@QAEXXZ PROC NEAR			; CUser::AddPartyName, COMDAT
; _this$ = ecx

; 1392 : {

  00000	57		 push	 edi
  00001	8b f9		 mov	 edi, ecx

; 1393 : 	if( IsDelete() )	return;

  00003	f6 47 04 01	 test	 BYTE PTR [edi+4], 1
  00007	75 56		 jne	 SHORT $L278516

; 1394 : 	
; 1395 : 	m_Snapshot.cb++;

  00009	66 ff 87 0c 57
	00 00		 inc	 WORD PTR [edi+22284]
  00010	53		 push	 ebx

; 1396 : 	m_Snapshot.ar << GetId();

  00011	8b 9f bc 01 00
	00		 mov	 ebx, DWORD PTR [edi+444]
  00017	56		 push	 esi
  00018	8d b7 f8 16 00
	00		 lea	 esi, DWORD PTR [edi+5880]
  0001e	6a 04		 push	 4
  00020	8b ce		 mov	 ecx, esi
  00022	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00027	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0002a	89 18		 mov	 DWORD PTR [eax], ebx
  0002c	8b 5e 08	 mov	 ebx, DWORD PTR [esi+8]
  0002f	83 c3 04	 add	 ebx, 4

; 1397 : 	m_Snapshot.ar << SNAPSHOTTYPE_ADDPARTYNAME;

  00032	6a 02		 push	 2
  00034	8b ce		 mov	 ecx, esi
  00036	89 5e 08	 mov	 DWORD PTR [esi+8], ebx
  00039	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003e	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00041	66 c7 01 68 00	 mov	 WORD PTR [ecx], 104	; 00000068H
  00046	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00049	83 c1 02	 add	 ecx, 2

; 1398 : 	m_Snapshot.ar.WriteString( m_szPartyName );

  0004c	81 c7 60 95 00
	00		 add	 edi, 38240		; 00009560H
  00052	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  00055	57		 push	 edi
  00056	8b ce		 mov	 ecx, esi
  00058	e8 00 00 00 00	 call	 ?WriteString@CAr@@QAEXPBD@Z ; CAr::WriteString
  0005d	5e		 pop	 esi
  0005e	5b		 pop	 ebx
$L278516:
  0005f	5f		 pop	 edi

; 1399 : 	
; 1400 : }

  00060	c3		 ret	 0
?AddPartyName@CUser@@QAEXXZ ENDP			; CUser::AddPartyName
_TEXT	ENDS
PUBLIC	?AddPartySkillCall@CUser@@QAEXABUD3DXVECTOR3@@@Z ; CUser::AddPartySkillCall
; Function compile flags: /Ogty
;	COMDAT ?AddPartySkillCall@CUser@@QAEXABUD3DXVECTOR3@@@Z
_TEXT	SEGMENT
$T299109 = -12						; size = 12
_vLeader$ = 8						; size = 4
?AddPartySkillCall@CUser@@QAEXABUD3DXVECTOR3@@@Z PROC NEAR ; CUser::AddPartySkillCall, COMDAT
; _this$ = ecx

; 1406 : 	if( IsDelete() )	return;

  00000	8a 41 04	 mov	 al, BYTE PTR [ecx+4]
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	a8 01		 test	 al, 1
  00008	75 64		 jne	 SHORT $L299108

; 1407 : 	
; 1408 : 	m_Snapshot.cb++;

  0000a	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  00011	56		 push	 esi
  00012	57		 push	 edi

; 1409 : 	m_Snapshot.ar << GetId();

  00013	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  00019	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  0001f	6a 04		 push	 4
  00021	8b ce		 mov	 ecx, esi
  00023	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00028	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0002b	89 38		 mov	 DWORD PTR [eax], edi
  0002d	83 46 08 04	 add	 DWORD PTR [esi+8], 4

; 1410 : 	m_Snapshot.ar << SNAPSHOTTYPE_PARTYSKILL_CALL;

  00031	6a 02		 push	 2
  00033	8b ce		 mov	 ecx, esi
  00035	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003a	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]

; 1411 : 	m_Snapshot.ar << vLeader;

  0003d	8b 54 24 18	 mov	 edx, DWORD PTR _vLeader$[esp+16]
  00041	66 c7 01 8a 00	 mov	 WORD PTR [ecx], 138	; 0000008aH
  00046	83 46 08 02	 add	 DWORD PTR [esi+8], 2
  0004a	8b 02		 mov	 eax, DWORD PTR [edx]
  0004c	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  0004f	8b 52 08	 mov	 edx, DWORD PTR [edx+8]
  00052	89 44 24 08	 mov	 DWORD PTR $T299109[esp+20], eax
  00056	6a 0c		 push	 12			; 0000000cH
  00058	8d 44 24 0c	 lea	 eax, DWORD PTR $T299109[esp+24]
  0005c	89 4c 24 10	 mov	 DWORD PTR $T299109[esp+28], ecx
  00060	50		 push	 eax
  00061	8b ce		 mov	 ecx, esi
  00063	89 54 24 18	 mov	 DWORD PTR $T299109[esp+36], edx
  00067	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
  0006c	5f		 pop	 edi
  0006d	5e		 pop	 esi
$L299108:

; 1412 : 	
; 1413 : }

  0006e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00071	c2 04 00	 ret	 4
?AddPartySkillCall@CUser@@QAEXABUD3DXVECTOR3@@@Z ENDP	; CUser::AddPartySkillCall
_TEXT	ENDS
PUBLIC	?AddPartySkillBlitz@CUser@@QAEXK@Z		; CUser::AddPartySkillBlitz
; Function compile flags: /Ogty
;	COMDAT ?AddPartySkillBlitz@CUser@@QAEXK@Z
_TEXT	SEGMENT
_idTarget$ = 8						; size = 4
?AddPartySkillBlitz@CUser@@QAEXK@Z PROC NEAR		; CUser::AddPartySkillBlitz, COMDAT
; _this$ = ecx

; 1417 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	75 63		 jne	 SHORT $L299131

; 1418 : 	
; 1419 : 	m_Snapshot.cb++;

  00006	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  0000d	56		 push	 esi
  0000e	57		 push	 edi

; 1420 : 	m_Snapshot.ar << GetId();

  0000f	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  00015	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  0001b	6a 04		 push	 4
  0001d	8b ce		 mov	 ecx, esi
  0001f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00024	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00027	89 38		 mov	 DWORD PTR [eax], edi
  00029	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0002c	83 c0 04	 add	 eax, 4

; 1421 : 	m_Snapshot.ar << SNAPSHOTTYPE_PARTYSKILL_BLITZ;

  0002f	6a 02		 push	 2
  00031	8b ce		 mov	 ecx, esi
  00033	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00036	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003b	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003e	66 c7 01 8b 00	 mov	 WORD PTR [ecx], 139	; 0000008bH
  00043	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00046	83 c2 02	 add	 edx, 2

; 1422 : 	m_Snapshot.ar << idTarget;

  00049	6a 04		 push	 4
  0004b	8b ce		 mov	 ecx, esi
  0004d	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00050	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00055	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00058	8b 44 24 0c	 mov	 eax, DWORD PTR _idTarget$[esp+4]
  0005c	89 02		 mov	 DWORD PTR [edx], eax
  0005e	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00061	83 c0 04	 add	 eax, 4
  00064	5f		 pop	 edi
  00065	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00068	5e		 pop	 esi
$L299131:

; 1423 : 	
; 1424 : }

  00069	c2 04 00	 ret	 4
?AddPartySkillBlitz@CUser@@QAEXK@Z ENDP			; CUser::AddPartySkillBlitz
_TEXT	ENDS
PUBLIC	?AddFriendGameJoin@CUser@@QAEXXZ		; CUser::AddFriendGameJoin
EXTRN	?Serialize@CRTMessenger@@QAEHAAVCAr@@@Z:NEAR	; CRTMessenger::Serialize
; Function compile flags: /Ogty
;	COMDAT ?AddFriendGameJoin@CUser@@QAEXXZ
_TEXT	SEGMENT
?AddFriendGameJoin@CUser@@QAEXXZ PROC NEAR		; CUser::AddFriendGameJoin, COMDAT
; _this$ = ecx

; 1427 : {

  00000	57		 push	 edi
  00001	8b f9		 mov	 edi, ecx

; 1428 : 	if( IsDelete() )	return;

  00003	f6 47 04 01	 test	 BYTE PTR [edi+4], 1
  00007	75 4f		 jne	 SHORT $L278533

; 1429 : 	
; 1430 : 	m_Snapshot.cb++;

  00009	66 ff 87 0c 57
	00 00		 inc	 WORD PTR [edi+22284]
  00010	53		 push	 ebx

; 1431 : 	m_Snapshot.ar << GetId();

  00011	8b 9f bc 01 00
	00		 mov	 ebx, DWORD PTR [edi+444]
  00017	56		 push	 esi
  00018	8d b7 f8 16 00
	00		 lea	 esi, DWORD PTR [edi+5880]
  0001e	6a 04		 push	 4
  00020	8b ce		 mov	 ecx, esi
  00022	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00027	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0002a	89 18		 mov	 DWORD PTR [eax], ebx
  0002c	8b 5e 08	 mov	 ebx, DWORD PTR [esi+8]
  0002f	83 c3 04	 add	 ebx, 4

; 1432 : 	m_Snapshot.ar << SNAPSHOTTYPE_ADDFRIENDGAMEJOIN;

  00032	6a 02		 push	 2
  00034	8b ce		 mov	 ecx, esi
  00036	89 5e 08	 mov	 DWORD PTR [esi+8], ebx
  00039	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003e	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00041	66 c7 01 74 00	 mov	 WORD PTR [ecx], 116	; 00000074H
  00046	83 46 08 02	 add	 DWORD PTR [esi+8], 2

; 1433 : #ifdef __RT_1025
; 1434 : 	m_RTMessenger.Serialize( m_Snapshot.ar );

  0004a	56		 push	 esi
  0004b	8d 8f 4c 95 00
	00		 lea	 ecx, DWORD PTR [edi+38220]
  00051	e8 00 00 00 00	 call	 ?Serialize@CRTMessenger@@QAEHAAVCAr@@@Z ; CRTMessenger::Serialize
  00056	5e		 pop	 esi
  00057	5b		 pop	 ebx
$L278533:
  00058	5f		 pop	 edi

; 1435 : #else	// __RT_1025
; 1436 : 	m_Messenger.Serialize( m_Snapshot.ar );
; 1437 : #endif	// __RT_1025
; 1438 : }

  00059	c3		 ret	 0
?AddFriendGameJoin@CUser@@QAEXXZ ENDP			; CUser::AddFriendGameJoin
_TEXT	ENDS
PUBLIC	?AddPartyChangeLeader@CUser@@QAEXK@Z		; CUser::AddPartyChangeLeader
; Function compile flags: /Ogty
;	COMDAT ?AddPartyChangeLeader@CUser@@QAEXK@Z
_TEXT	SEGMENT
_uidChangeLeader$ = 8					; size = 4
?AddPartyChangeLeader@CUser@@QAEXK@Z PROC NEAR		; CUser::AddPartyChangeLeader, COMDAT
; _this$ = ecx

; 1442 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	75 63		 jne	 SHORT $L299171

; 1443 : 	
; 1444 : 	m_Snapshot.cb++;

  00006	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  0000d	56		 push	 esi
  0000e	57		 push	 edi

; 1445 : 	m_Snapshot.ar << GetId();

  0000f	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  00015	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  0001b	6a 04		 push	 4
  0001d	8b ce		 mov	 ecx, esi
  0001f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00024	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00027	89 38		 mov	 DWORD PTR [eax], edi
  00029	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0002c	83 c0 04	 add	 eax, 4

; 1446 : 	m_Snapshot.ar << SNAPSHOTTYPE_ADDPARTYCHANGELEADER;

  0002f	6a 02		 push	 2
  00031	8b ce		 mov	 ecx, esi
  00033	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00036	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003b	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003e	66 c7 01 79 00	 mov	 WORD PTR [ecx], 121	; 00000079H
  00043	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00046	83 c2 02	 add	 edx, 2

; 1447 : 	m_Snapshot.ar << uidChangeLeader;

  00049	6a 04		 push	 4
  0004b	8b ce		 mov	 ecx, esi
  0004d	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00050	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00055	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00058	8b 44 24 0c	 mov	 eax, DWORD PTR _uidChangeLeader$[esp+4]
  0005c	89 02		 mov	 DWORD PTR [edx], eax
  0005e	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00061	83 c0 04	 add	 eax, 4
  00064	5f		 pop	 edi
  00065	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00068	5e		 pop	 esi
$L299171:

; 1448 : 	
; 1449 : }

  00069	c2 04 00	 ret	 4
?AddPartyChangeLeader@CUser@@QAEXK@Z ENDP		; CUser::AddPartyChangeLeader
_TEXT	ENDS
PUBLIC	?ADDGameJoin@CUser@@QAEXXZ			; CUser::ADDGameJoin
; Function compile flags: /Ogty
;	COMDAT ?ADDGameJoin@CUser@@QAEXXZ
_TEXT	SEGMENT
?ADDGameJoin@CUser@@QAEXXZ PROC NEAR			; CUser::ADDGameJoin, COMDAT
; _this$ = ecx

; 1495 : {

  00000	57		 push	 edi
  00001	8b f9		 mov	 edi, ecx

; 1496 : 	if( IsDelete() )	return;

  00003	f6 47 04 01	 test	 BYTE PTR [edi+4], 1
  00007	75 5b		 jne	 SHORT $L299193

; 1497 : 	
; 1498 : 	m_Snapshot.cb++;

  00009	66 ff 87 0c 57
	00 00		 inc	 WORD PTR [edi+22284]
  00010	53		 push	 ebx

; 1499 : 	m_Snapshot.ar << GetId();

  00011	8b 9f bc 01 00
	00		 mov	 ebx, DWORD PTR [edi+444]
  00017	56		 push	 esi
  00018	8d b7 f8 16 00
	00		 lea	 esi, DWORD PTR [edi+5880]
  0001e	6a 04		 push	 4
  00020	8b ce		 mov	 ecx, esi
  00022	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00027	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0002a	89 18		 mov	 DWORD PTR [eax], ebx
  0002c	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0002f	83 c0 04	 add	 eax, 4

; 1500 : 	m_Snapshot.ar << SNAPSHOTTYPE_ADDGAMEJOIN;

  00032	6a 02		 push	 2
  00034	8b ce		 mov	 ecx, esi
  00036	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00039	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003e	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00041	66 c7 01 78 00	 mov	 WORD PTR [ecx], 120	; 00000078H
  00046	83 46 08 02	 add	 DWORD PTR [esi+8], 2

; 1501 : 	m_Snapshot.ar << m_dwSavePlayerTime;

  0004a	8b bf dc 95 00
	00		 mov	 edi, DWORD PTR [edi+38364]
  00050	6a 04		 push	 4
  00052	8b ce		 mov	 ecx, esi
  00054	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00059	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0005c	89 3a		 mov	 DWORD PTR [edx], edi
  0005e	83 46 08 04	 add	 DWORD PTR [esi+8], 4
  00062	5e		 pop	 esi
  00063	5b		 pop	 ebx
$L299193:
  00064	5f		 pop	 edi

; 1502 : 	
; 1503 : }

  00065	c3		 ret	 0
?ADDGameJoin@CUser@@QAEXXZ ENDP				; CUser::ADDGameJoin
_TEXT	ENDS
PUBLIC	?AddFriendReqest@CUser@@QAEXKJEPBD@Z		; CUser::AddFriendReqest
; Function compile flags: /Ogty
;	COMDAT ?AddFriendReqest@CUser@@QAEXKJEPBD@Z
_TEXT	SEGMENT
_uLeader$ = 8						; size = 4
_nJob$ = 12						; size = 4
_nSex$ = 16						; size = 1
_szName$ = 20						; size = 4
?AddFriendReqest@CUser@@QAEXKJEPBD@Z PROC NEAR		; CUser::AddFriendReqest, COMDAT
; _this$ = ecx

; 1507 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	0f 85 94 00 00
	00		 jne	 $L278582

; 1508 : 	
; 1509 : 	m_Snapshot.cb++;

  0000a	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  00011	56		 push	 esi
  00012	57		 push	 edi

; 1510 : 	m_Snapshot.ar << GetId();

  00013	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  00019	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  0001f	6a 04		 push	 4
  00021	8b ce		 mov	 ecx, esi
  00023	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00028	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0002b	89 38		 mov	 DWORD PTR [eax], edi
  0002d	83 46 08 04	 add	 DWORD PTR [esi+8], 4

; 1511 : 	m_Snapshot.ar << SNAPSHOTTYPE_ADDFRIENDREQEST;

  00031	6a 02		 push	 2
  00033	8b ce		 mov	 ecx, esi
  00035	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003a	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003d	66 c7 01 71 00	 mov	 WORD PTR [ecx], 113	; 00000071H
  00042	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  00045	83 c7 02	 add	 edi, 2

; 1512 : 	m_Snapshot.ar << uLeader;

  00048	6a 04		 push	 4
  0004a	8b ce		 mov	 ecx, esi
  0004c	89 7e 08	 mov	 DWORD PTR [esi+8], edi
  0004f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00054	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00057	8b 44 24 0c	 mov	 eax, DWORD PTR _uLeader$[esp+4]
  0005b	89 02		 mov	 DWORD PTR [edx], eax
  0005d	83 46 08 04	 add	 DWORD PTR [esi+8], 4

; 1513 : 	m_Snapshot.ar << nSex;

  00061	6a 01		 push	 1
  00063	8b ce		 mov	 ecx, esi
  00065	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0006a	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0006d	8a 54 24 14	 mov	 dl, BYTE PTR _nSex$[esp+4]
  00071	88 11		 mov	 BYTE PTR [ecx], dl
  00073	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  00076	47		 inc	 edi

; 1514 : 	m_Snapshot.ar << nJob;

  00077	6a 04		 push	 4
  00079	8b ce		 mov	 ecx, esi
  0007b	89 7e 08	 mov	 DWORD PTR [esi+8], edi
  0007e	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00083	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00086	8b 4c 24 10	 mov	 ecx, DWORD PTR _nJob$[esp+4]

; 1515 : 	m_Snapshot.ar.WriteString( szName );

  0008a	8b 54 24 18	 mov	 edx, DWORD PTR _szName$[esp+4]
  0008e	89 08		 mov	 DWORD PTR [eax], ecx
  00090	83 46 08 04	 add	 DWORD PTR [esi+8], 4
  00094	52		 push	 edx
  00095	8b ce		 mov	 ecx, esi
  00097	e8 00 00 00 00	 call	 ?WriteString@CAr@@QAEXPBD@Z ; CAr::WriteString
  0009c	5f		 pop	 edi
  0009d	5e		 pop	 esi
$L278582:

; 1516 : 	
; 1517 : }

  0009e	c2 10 00	 ret	 16			; 00000010H
?AddFriendReqest@CUser@@QAEXKJEPBD@Z ENDP		; CUser::AddFriendReqest
_TEXT	ENDS
PUBLIC	?AddFriendCancel@CUser@@QAEXXZ			; CUser::AddFriendCancel
; Function compile flags: /Ogty
;	COMDAT ?AddFriendCancel@CUser@@QAEXXZ
_TEXT	SEGMENT
?AddFriendCancel@CUser@@QAEXXZ PROC NEAR		; CUser::AddFriendCancel, COMDAT
; _this$ = ecx

; 1521 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	75 48		 jne	 SHORT $L299242

; 1522 : 	
; 1523 : 	m_Snapshot.cb++;

  00006	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  0000d	56		 push	 esi
  0000e	57		 push	 edi

; 1524 : 	m_Snapshot.ar << GetId();

  0000f	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  00015	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  0001b	6a 04		 push	 4
  0001d	8b ce		 mov	 ecx, esi
  0001f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00024	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00027	89 38		 mov	 DWORD PTR [eax], edi
  00029	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0002c	83 c2 04	 add	 edx, 4

; 1525 : 	m_Snapshot.ar << SNAPSHOTTYPE_ADDFRIENDCANCEL;

  0002f	6a 02		 push	 2
  00031	8b ce		 mov	 ecx, esi
  00033	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00036	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003b	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003e	66 c7 01 72 00	 mov	 WORD PTR [ecx], 114	; 00000072H
  00043	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00046	83 c0 02	 add	 eax, 2
  00049	5f		 pop	 edi
  0004a	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0004d	5e		 pop	 esi
$L299242:

; 1526 : 	
; 1527 : }

  0004e	c3		 ret	 0
?AddFriendCancel@CUser@@QAEXXZ ENDP			; CUser::AddFriendCancel
_TEXT	ENDS
PUBLIC	?AddFriendError@CUser@@QAEXEPBD@Z		; CUser::AddFriendError
; Function compile flags: /Ogty
;	COMDAT ?AddFriendError@CUser@@QAEXEPBD@Z
_TEXT	SEGMENT
_nError$ = 8						; size = 1
_szName$ = 12						; size = 4
?AddFriendError@CUser@@QAEXEPBD@Z PROC NEAR		; CUser::AddFriendError, COMDAT
; _this$ = ecx

; 1531 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	75 64		 jne	 SHORT $L278594

; 1532 : 	
; 1533 : 	m_Snapshot.cb++;

  00006	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  0000d	56		 push	 esi
  0000e	57		 push	 edi

; 1534 : 	m_Snapshot.ar << GetId();

  0000f	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  00015	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  0001b	6a 04		 push	 4
  0001d	8b ce		 mov	 ecx, esi
  0001f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00024	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00027	89 38		 mov	 DWORD PTR [eax], edi
  00029	83 46 08 04	 add	 DWORD PTR [esi+8], 4

; 1535 : 	m_Snapshot.ar << SNAPSHOTTYPE_ADDFRIENDERROR;

  0002d	6a 02		 push	 2
  0002f	8b ce		 mov	 ecx, esi
  00031	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00036	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00039	66 c7 01 76 00	 mov	 WORD PTR [ecx], 118	; 00000076H
  0003e	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  00041	83 c7 02	 add	 edi, 2

; 1536 : 	m_Snapshot.ar << nError;

  00044	6a 01		 push	 1
  00046	8b ce		 mov	 ecx, esi
  00048	89 7e 08	 mov	 DWORD PTR [esi+8], edi
  0004b	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00050	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00053	8a 44 24 0c	 mov	 al, BYTE PTR _nError$[esp+4]
  00057	88 02		 mov	 BYTE PTR [edx], al
  00059	ff 46 08	 inc	 DWORD PTR [esi+8]

; 1537 : 	m_Snapshot.ar.WriteString( szName );

  0005c	8b 4c 24 10	 mov	 ecx, DWORD PTR _szName$[esp+4]
  00060	51		 push	 ecx
  00061	8b ce		 mov	 ecx, esi
  00063	e8 00 00 00 00	 call	 ?WriteString@CAr@@QAEXPBD@Z ; CAr::WriteString
  00068	5f		 pop	 edi
  00069	5e		 pop	 esi
$L278594:

; 1538 : 	
; 1539 : }

  0006a	c2 08 00	 ret	 8
?AddFriendError@CUser@@QAEXEPBD@Z ENDP			; CUser::AddFriendError
_TEXT	ENDS
PUBLIC	?AddPartyChat@CUser@@QAEXPBD0K@Z		; CUser::AddPartyChat
; Function compile flags: /Ogty
;	COMDAT ?AddPartyChat@CUser@@QAEXPBD0K@Z
_TEXT	SEGMENT
_lpName$ = 8						; size = 4
_lpString$ = 12						; size = 4
_objid$ = 16						; size = 4
?AddPartyChat@CUser@@QAEXPBD0K@Z PROC NEAR		; CUser::AddPartyChat, COMDAT
; _this$ = ecx

; 1606 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	75 76		 jne	 SHORT $L278615

; 1607 : 	
; 1608 : 	m_Snapshot.cb++;

  00006	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  0000d	56		 push	 esi
  0000e	57		 push	 edi

; 1609 : 	m_Snapshot.ar << GetId();

  0000f	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  00015	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  0001b	6a 04		 push	 4
  0001d	8b ce		 mov	 ecx, esi
  0001f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00024	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00027	89 38		 mov	 DWORD PTR [eax], edi
  00029	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  0002c	83 c7 04	 add	 edi, 4

; 1610 : 	m_Snapshot.ar << SNAPSHOTTYPE_PARTYCHAT;

  0002f	6a 02		 push	 2
  00031	8b ce		 mov	 ecx, esi
  00033	89 7e 08	 mov	 DWORD PTR [esi+8], edi
  00036	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003b	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003e	66 c7 01 69 00	 mov	 WORD PTR [ecx], 105	; 00000069H
  00043	83 46 08 02	 add	 DWORD PTR [esi+8], 2

; 1611 : 	m_Snapshot.ar << objid;

  00047	6a 04		 push	 4
  00049	8b ce		 mov	 ecx, esi
  0004b	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00050	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00053	8b 44 24 14	 mov	 eax, DWORD PTR _objid$[esp+4]

; 1612 : 
; 1613 : 	m_Snapshot.ar.WriteString( lpName );

  00057	8b 4c 24 0c	 mov	 ecx, DWORD PTR _lpName$[esp+4]
  0005b	89 02		 mov	 DWORD PTR [edx], eax
  0005d	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  00060	51		 push	 ecx
  00061	83 c7 04	 add	 edi, 4
  00064	8b ce		 mov	 ecx, esi
  00066	89 7e 08	 mov	 DWORD PTR [esi+8], edi
  00069	e8 00 00 00 00	 call	 ?WriteString@CAr@@QAEXPBD@Z ; CAr::WriteString

; 1614 : 	m_Snapshot.ar.WriteString( lpString );

  0006e	8b 54 24 10	 mov	 edx, DWORD PTR _lpString$[esp+4]
  00072	52		 push	 edx
  00073	8b ce		 mov	 ecx, esi
  00075	e8 00 00 00 00	 call	 ?WriteString@CAr@@QAEXPBD@Z ; CAr::WriteString
  0007a	5f		 pop	 edi
  0007b	5e		 pop	 esi
$L278615:

; 1615 : 	
; 1616 : }

  0007c	c2 0c 00	 ret	 12			; 0000000cH
?AddPartyChat@CUser@@QAEXPBD0K@Z ENDP			; CUser::AddPartyChat
_TEXT	ENDS
PUBLIC	?AddAddFriend@CUser@@QAEXKPBD@Z			; CUser::AddAddFriend
; Function compile flags: /Ogty
;	COMDAT ?AddAddFriend@CUser@@QAEXKPBD@Z
_TEXT	SEGMENT
_idPlayer$ = 8						; size = 4
_lpszPlayer$ = 12					; size = 4
?AddAddFriend@CUser@@QAEXKPBD@Z PROC NEAR		; CUser::AddAddFriend, COMDAT
; _this$ = ecx

; 1624 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	75 65		 jne	 SHORT $L278622

; 1625 : 	
; 1626 : 	m_Snapshot.cb++;

  00006	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  0000d	56		 push	 esi
  0000e	57		 push	 edi

; 1627 : 	m_Snapshot.ar << GetId();

  0000f	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  00015	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  0001b	6a 04		 push	 4
  0001d	8b ce		 mov	 ecx, esi
  0001f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00024	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00027	89 38		 mov	 DWORD PTR [eax], edi
  00029	83 46 08 04	 add	 DWORD PTR [esi+8], 4

; 1628 : 	m_Snapshot.ar << SNAPSHOTTYPE_ADDFRIEND;

  0002d	6a 02		 push	 2
  0002f	8b ce		 mov	 ecx, esi
  00031	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00036	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00039	66 c7 01 70 00	 mov	 WORD PTR [ecx], 112	; 00000070H
  0003e	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  00041	83 c7 02	 add	 edi, 2

; 1629 : 	m_Snapshot.ar << idPlayer;

  00044	6a 04		 push	 4
  00046	8b ce		 mov	 ecx, esi
  00048	89 7e 08	 mov	 DWORD PTR [esi+8], edi
  0004b	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00050	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00053	8b 44 24 0c	 mov	 eax, DWORD PTR _idPlayer$[esp+4]
  00057	89 02		 mov	 DWORD PTR [edx], eax
  00059	83 46 08 04	 add	 DWORD PTR [esi+8], 4

; 1630 : #ifndef __RT_1025
; 1631 : 	m_Snapshot.ar << nJob;
; 1632 : 	m_Snapshot.ar << (BYTE)dwSex;
; 1633 : #endif	// __RT_1025
; 1634 : 	m_Snapshot.ar.WriteString( lpszPlayer );

  0005d	8b 4c 24 10	 mov	 ecx, DWORD PTR _lpszPlayer$[esp+4]
  00061	51		 push	 ecx
  00062	8b ce		 mov	 ecx, esi
  00064	e8 00 00 00 00	 call	 ?WriteString@CAr@@QAEXPBD@Z ; CAr::WriteString
  00069	5f		 pop	 edi
  0006a	5e		 pop	 esi
$L278622:

; 1635 : 	
; 1636 : }

  0006b	c2 08 00	 ret	 8
?AddAddFriend@CUser@@QAEXKPBD@Z ENDP			; CUser::AddAddFriend
_TEXT	ENDS
PUBLIC	?AddRemoveFriend@CUser@@QAEXK@Z			; CUser::AddRemoveFriend
; Function compile flags: /Ogty
;	COMDAT ?AddRemoveFriend@CUser@@QAEXK@Z
_TEXT	SEGMENT
_uidSender$ = 8						; size = 4
?AddRemoveFriend@CUser@@QAEXK@Z PROC NEAR		; CUser::AddRemoveFriend, COMDAT
; _this$ = ecx

; 1640 : 	if( IsDelete() ) return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	75 63		 jne	 SHORT $L299330

; 1641 : 	
; 1642 : 	m_Snapshot.cb++;

  00006	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  0000d	56		 push	 esi
  0000e	57		 push	 edi

; 1643 : 	m_Snapshot.ar << GetId();

  0000f	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  00015	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  0001b	6a 04		 push	 4
  0001d	8b ce		 mov	 ecx, esi
  0001f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00024	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00027	89 38		 mov	 DWORD PTR [eax], edi
  00029	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0002c	83 c0 04	 add	 eax, 4

; 1644 : 	m_Snapshot.ar << SNAPSHOTTYPE_REMOVEFRIEND;

  0002f	6a 02		 push	 2
  00031	8b ce		 mov	 ecx, esi
  00033	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00036	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003b	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003e	66 c7 01 75 00	 mov	 WORD PTR [ecx], 117	; 00000075H
  00043	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00046	83 c2 02	 add	 edx, 2

; 1645 : 	m_Snapshot.ar << uidSender;

  00049	6a 04		 push	 4
  0004b	8b ce		 mov	 ecx, esi
  0004d	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00050	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00055	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00058	8b 44 24 0c	 mov	 eax, DWORD PTR _uidSender$[esp+4]
  0005c	89 02		 mov	 DWORD PTR [edx], eax
  0005e	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00061	83 c0 04	 add	 eax, 4
  00064	5f		 pop	 edi
  00065	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00068	5e		 pop	 esi
$L299330:

; 1646 : 	
; 1647 : }

  00069	c2 04 00	 ret	 4
?AddRemoveFriend@CUser@@QAEXK@Z ENDP			; CUser::AddRemoveFriend
_TEXT	ENDS
PUBLIC	?AddDuelRequest@CUser@@QAEXKK@Z			; CUser::AddDuelRequest
; Function compile flags: /Ogty
;	COMDAT ?AddDuelRequest@CUser@@QAEXKK@Z
_TEXT	SEGMENT
_uidSrc$ = 8						; size = 4
_uidDst$ = 12						; size = 4
?AddDuelRequest@CUser@@QAEXKK@Z PROC NEAR		; CUser::AddDuelRequest, COMDAT
; _this$ = ecx

; 1651 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	75 7e		 jne	 SHORT $L299356

; 1652 : 	
; 1653 : 	m_Snapshot.cb++;

  00006	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  0000d	56		 push	 esi
  0000e	57		 push	 edi

; 1654 : 	m_Snapshot.ar << GetId();

  0000f	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  00015	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  0001b	6a 04		 push	 4
  0001d	8b ce		 mov	 ecx, esi
  0001f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00024	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00027	89 38		 mov	 DWORD PTR [eax], edi
  00029	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0002c	83 c2 04	 add	 edx, 4

; 1655 : 	m_Snapshot.ar << SNAPSHOTTYPE_DUELREQUEST;

  0002f	6a 02		 push	 2
  00031	8b ce		 mov	 ecx, esi
  00033	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00036	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003b	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003e	66 c7 01 30 00	 mov	 WORD PTR [ecx], 48	; 00000030H
  00043	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00046	83 c0 02	 add	 eax, 2

; 1656 : 	m_Snapshot.ar << uidSrc << uidDst;

  00049	6a 04		 push	 4
  0004b	8b ce		 mov	 ecx, esi
  0004d	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00050	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00055	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00058	8b 44 24 0c	 mov	 eax, DWORD PTR _uidSrc$[esp+4]
  0005c	89 02		 mov	 DWORD PTR [edx], eax
  0005e	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00061	83 c2 04	 add	 edx, 4
  00064	6a 04		 push	 4
  00066	8b ce		 mov	 ecx, esi
  00068	89 56 08	 mov	 DWORD PTR [esi+8], edx
  0006b	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00070	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00073	8b 54 24 10	 mov	 edx, DWORD PTR _uidDst$[esp+4]
  00077	89 11		 mov	 DWORD PTR [ecx], edx
  00079	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0007c	83 c0 04	 add	 eax, 4
  0007f	5f		 pop	 edi
  00080	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00083	5e		 pop	 esi
$L299356:

; 1657 : 	
; 1658 : }

  00084	c2 08 00	 ret	 8
?AddDuelRequest@CUser@@QAEXKK@Z ENDP			; CUser::AddDuelRequest
_TEXT	ENDS
PUBLIC	?AddDuelNo@CUser@@QAEXK@Z			; CUser::AddDuelNo
; Function compile flags: /Ogty
;	COMDAT ?AddDuelNo@CUser@@QAEXK@Z
_TEXT	SEGMENT
_idTarget$ = 8						; size = 4
?AddDuelNo@CUser@@QAEXK@Z PROC NEAR			; CUser::AddDuelNo, COMDAT
; _this$ = ecx

; 1685 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	75 63		 jne	 SHORT $L299377

; 1686 : 	
; 1687 : 	m_Snapshot.cb++;

  00006	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  0000d	56		 push	 esi
  0000e	57		 push	 edi

; 1688 : 	m_Snapshot.ar << GetId();

  0000f	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  00015	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  0001b	6a 04		 push	 4
  0001d	8b ce		 mov	 ecx, esi
  0001f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00024	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00027	89 38		 mov	 DWORD PTR [eax], edi
  00029	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0002c	83 c0 04	 add	 eax, 4

; 1689 : 	m_Snapshot.ar << SNAPSHOTTYPE_DUELNO;

  0002f	6a 02		 push	 2
  00031	8b ce		 mov	 ecx, esi
  00033	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00036	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003b	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003e	66 c7 01 32 00	 mov	 WORD PTR [ecx], 50	; 00000032H
  00043	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00046	83 c2 02	 add	 edx, 2

; 1690 : 	m_Snapshot.ar << idTarget;

  00049	6a 04		 push	 4
  0004b	8b ce		 mov	 ecx, esi
  0004d	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00050	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00055	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00058	8b 44 24 0c	 mov	 eax, DWORD PTR _idTarget$[esp+4]
  0005c	89 02		 mov	 DWORD PTR [edx], eax
  0005e	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00061	83 c0 04	 add	 eax, 4
  00064	5f		 pop	 edi
  00065	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00068	5e		 pop	 esi
$L299377:

; 1691 : 	
; 1692 : }

  00069	c2 04 00	 ret	 4
?AddDuelNo@CUser@@QAEXK@Z ENDP				; CUser::AddDuelNo
_TEXT	ENDS
PUBLIC	?AddDuelCancel@CUser@@QAEXK@Z			; CUser::AddDuelCancel
; Function compile flags: /Ogty
;	COMDAT ?AddDuelCancel@CUser@@QAEXK@Z
_TEXT	SEGMENT
_idTarget$ = 8						; size = 4
?AddDuelCancel@CUser@@QAEXK@Z PROC NEAR			; CUser::AddDuelCancel, COMDAT
; _this$ = ecx

; 1696 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	75 63		 jne	 SHORT $L299399

; 1697 : 	
; 1698 : 	m_Snapshot.cb++;

  00006	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  0000d	56		 push	 esi
  0000e	57		 push	 edi

; 1699 : 	m_Snapshot.ar << GetId();

  0000f	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  00015	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  0001b	6a 04		 push	 4
  0001d	8b ce		 mov	 ecx, esi
  0001f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00024	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00027	89 38		 mov	 DWORD PTR [eax], edi
  00029	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0002c	83 c0 04	 add	 eax, 4

; 1700 : 	m_Snapshot.ar << SNAPSHOTTYPE_DUELCANCEL;

  0002f	6a 02		 push	 2
  00031	8b ce		 mov	 ecx, esi
  00033	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00036	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003b	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003e	66 c7 01 33 00	 mov	 WORD PTR [ecx], 51	; 00000033H
  00043	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00046	83 c2 02	 add	 edx, 2

; 1701 : 	m_Snapshot.ar << idTarget;

  00049	6a 04		 push	 4
  0004b	8b ce		 mov	 ecx, esi
  0004d	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00050	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00055	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00058	8b 44 24 0c	 mov	 eax, DWORD PTR _idTarget$[esp+4]
  0005c	89 02		 mov	 DWORD PTR [edx], eax
  0005e	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00061	83 c0 04	 add	 eax, 4
  00064	5f		 pop	 edi
  00065	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00068	5e		 pop	 esi
$L299399:

; 1702 : 	
; 1703 : }

  00069	c2 04 00	 ret	 4
?AddDuelCancel@CUser@@QAEXK@Z ENDP			; CUser::AddDuelCancel
_TEXT	ENDS
PUBLIC	?AddDuelPartyRequest@CUser@@QAEXKK@Z		; CUser::AddDuelPartyRequest
; Function compile flags: /Ogty
;	COMDAT ?AddDuelPartyRequest@CUser@@QAEXKK@Z
_TEXT	SEGMENT
_uidSrc$ = 8						; size = 4
_uidDst$ = 12						; size = 4
?AddDuelPartyRequest@CUser@@QAEXKK@Z PROC NEAR		; CUser::AddDuelPartyRequest, COMDAT
; _this$ = ecx

; 1707 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	75 7e		 jne	 SHORT $L299425

; 1708 : 	
; 1709 : 	m_Snapshot.cb++;

  00006	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  0000d	56		 push	 esi
  0000e	57		 push	 edi

; 1710 : 	m_Snapshot.ar << GetId();

  0000f	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  00015	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  0001b	6a 04		 push	 4
  0001d	8b ce		 mov	 ecx, esi
  0001f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00024	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00027	89 38		 mov	 DWORD PTR [eax], edi
  00029	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0002c	83 c2 04	 add	 edx, 4

; 1711 : 	m_Snapshot.ar << SNAPSHOTTYPE_DUELPARTYREQUEST;

  0002f	6a 02		 push	 2
  00031	8b ce		 mov	 ecx, esi
  00033	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00036	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003b	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003e	66 c7 01 34 00	 mov	 WORD PTR [ecx], 52	; 00000034H
  00043	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00046	83 c0 02	 add	 eax, 2

; 1712 : 	m_Snapshot.ar << uidSrc << uidDst;

  00049	6a 04		 push	 4
  0004b	8b ce		 mov	 ecx, esi
  0004d	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00050	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00055	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00058	8b 44 24 0c	 mov	 eax, DWORD PTR _uidSrc$[esp+4]
  0005c	89 02		 mov	 DWORD PTR [edx], eax
  0005e	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00061	83 c2 04	 add	 edx, 4
  00064	6a 04		 push	 4
  00066	8b ce		 mov	 ecx, esi
  00068	89 56 08	 mov	 DWORD PTR [esi+8], edx
  0006b	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00070	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00073	8b 54 24 10	 mov	 edx, DWORD PTR _uidDst$[esp+4]
  00077	89 11		 mov	 DWORD PTR [ecx], edx
  00079	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0007c	83 c0 04	 add	 eax, 4
  0007f	5f		 pop	 edi
  00080	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00083	5e		 pop	 esi
$L299425:

; 1713 : 	
; 1714 : }

  00084	c2 08 00	 ret	 8
?AddDuelPartyRequest@CUser@@QAEXKK@Z ENDP		; CUser::AddDuelPartyRequest
_TEXT	ENDS
PUBLIC	?AddDuelPartyNo@CUser@@QAEXK@Z			; CUser::AddDuelPartyNo
; Function compile flags: /Ogty
;	COMDAT ?AddDuelPartyNo@CUser@@QAEXK@Z
_TEXT	SEGMENT
_idTarget$ = 8						; size = 4
?AddDuelPartyNo@CUser@@QAEXK@Z PROC NEAR		; CUser::AddDuelPartyNo, COMDAT
; _this$ = ecx

; 1734 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	75 63		 jne	 SHORT $L299446

; 1735 : 	
; 1736 : 	m_Snapshot.cb++;

  00006	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  0000d	56		 push	 esi
  0000e	57		 push	 edi

; 1737 : 	m_Snapshot.ar << GetId();

  0000f	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  00015	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  0001b	6a 04		 push	 4
  0001d	8b ce		 mov	 ecx, esi
  0001f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00024	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00027	89 38		 mov	 DWORD PTR [eax], edi
  00029	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0002c	83 c0 04	 add	 eax, 4

; 1738 : 	m_Snapshot.ar << SNAPSHOTTYPE_DUELPARTYNO;

  0002f	6a 02		 push	 2
  00031	8b ce		 mov	 ecx, esi
  00033	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00036	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003b	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003e	66 c7 01 36 00	 mov	 WORD PTR [ecx], 54	; 00000036H
  00043	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00046	83 c2 02	 add	 edx, 2

; 1739 : 	m_Snapshot.ar << idTarget;

  00049	6a 04		 push	 4
  0004b	8b ce		 mov	 ecx, esi
  0004d	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00050	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00055	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00058	8b 44 24 0c	 mov	 eax, DWORD PTR _idTarget$[esp+4]
  0005c	89 02		 mov	 DWORD PTR [edx], eax
  0005e	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00061	83 c0 04	 add	 eax, 4
  00064	5f		 pop	 edi
  00065	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00068	5e		 pop	 esi
$L299446:

; 1740 : 	
; 1741 : }

  00069	c2 04 00	 ret	 4
?AddDuelPartyNo@CUser@@QAEXK@Z ENDP			; CUser::AddDuelPartyNo
_TEXT	ENDS
PUBLIC	?AddRemoveGuildBankItem@CUser@@QAEXKKK@Z	; CUser::AddRemoveGuildBankItem
; Function compile flags: /Ogty
;	COMDAT ?AddRemoveGuildBankItem@CUser@@QAEXKKK@Z
_TEXT	SEGMENT
_idGuild$ = 8						; size = 4
_dwId$ = 12						; size = 4
_dwItemNum$ = 16					; size = 4
?AddRemoveGuildBankItem@CUser@@QAEXKKK@Z PROC NEAR	; CUser::AddRemoveGuildBankItem, COMDAT
; _this$ = ecx

; 2229 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	0f 85 98 00 00
	00		 jne	 $L299475

; 2230 : 	
; 2231 : 	m_Snapshot.cb++;

  0000a	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  00011	53		 push	 ebx
  00012	56		 push	 esi
  00013	57		 push	 edi

; 2232 : 	m_Snapshot.ar << GetId();

  00014	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  0001a	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  00020	bb 04 00 00 00	 mov	 ebx, 4
  00025	53		 push	 ebx
  00026	8b ce		 mov	 ecx, esi
  00028	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0002d	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00030	89 38		 mov	 DWORD PTR [eax], edi
  00032	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00035	03 c3		 add	 eax, ebx

; 2233 : 	m_Snapshot.ar << SNAPSHOTTYPE_REMOVE_GUILD_BANK_ITEM;

  00037	6a 02		 push	 2
  00039	8b ce		 mov	 ecx, esi
  0003b	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0003e	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00043	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00046	66 c7 01 f3 00	 mov	 WORD PTR [ecx], 243	; 000000f3H
  0004b	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0004e	83 c2 02	 add	 edx, 2

; 2234 : 	m_Snapshot.ar << idGuild << dwId << dwItemNum;

  00051	53		 push	 ebx
  00052	8b ce		 mov	 ecx, esi
  00054	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00057	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0005c	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0005f	8b 44 24 10	 mov	 eax, DWORD PTR _idGuild$[esp+8]
  00063	89 02		 mov	 DWORD PTR [edx], eax
  00065	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00068	03 c3		 add	 eax, ebx
  0006a	53		 push	 ebx
  0006b	8b ce		 mov	 ecx, esi
  0006d	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00070	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00075	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00078	8b 54 24 14	 mov	 edx, DWORD PTR _dwId$[esp+8]
  0007c	89 11		 mov	 DWORD PTR [ecx], edx
  0007e	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00081	03 d3		 add	 edx, ebx
  00083	53		 push	 ebx
  00084	8b ce		 mov	 ecx, esi
  00086	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00089	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0008e	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00091	8b 4c 24 18	 mov	 ecx, DWORD PTR _dwItemNum$[esp+8]
  00095	89 08		 mov	 DWORD PTR [eax], ecx
  00097	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0009a	03 c3		 add	 eax, ebx
  0009c	5f		 pop	 edi
  0009d	89 46 08	 mov	 DWORD PTR [esi+8], eax
  000a0	5e		 pop	 esi
  000a1	5b		 pop	 ebx
$L299475:

; 2235 : 	
; 2236 : }

  000a2	c2 0c 00	 ret	 12			; 0000000cH
?AddRemoveGuildBankItem@CUser@@QAEXKKK@Z ENDP		; CUser::AddRemoveGuildBankItem
_TEXT	ENDS
PUBLIC	?AddExpBoxInfo@CUser@@QAEXKKKK@Z		; CUser::AddExpBoxInfo
; Function compile flags: /Ogty
;	COMDAT ?AddExpBoxInfo@CUser@@QAEXKKKK@Z
_TEXT	SEGMENT
_objid$ = 8						; size = 4
_dwSet$ = 12						; size = 4
_dwTime$ = 16						; size = 4
_idPlayer$ = 20						; size = 4
?AddExpBoxInfo@CUser@@QAEXKKKK@Z PROC NEAR		; CUser::AddExpBoxInfo, COMDAT
; _this$ = ecx

; 2298 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	0f 85 b1 00 00
	00		 jne	 $L299508

; 2299 : 	
; 2300 : 	
; 2301 : 	m_Snapshot.cb++;

  0000a	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  00011	53		 push	 ebx

; 2302 : 	m_Snapshot.ar << GetId();

  00012	8b 99 bc 01 00
	00		 mov	 ebx, DWORD PTR [ecx+444]
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  00020	bf 04 00 00 00	 mov	 edi, 4
  00025	57		 push	 edi
  00026	8b ce		 mov	 ecx, esi
  00028	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0002d	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00030	89 18		 mov	 DWORD PTR [eax], ebx
  00032	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00035	03 d7		 add	 edx, edi

; 2303 : 	m_Snapshot.ar << SNAPSHOTTYPE_EXPBOXINFO;

  00037	6a 02		 push	 2
  00039	8b ce		 mov	 ecx, esi
  0003b	89 56 08	 mov	 DWORD PTR [esi+8], edx
  0003e	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00043	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00046	66 c7 01 bd 00	 mov	 WORD PTR [ecx], 189	; 000000bdH
  0004b	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0004e	83 c0 02	 add	 eax, 2

; 2304 : 	m_Snapshot.ar << objid;

  00051	57		 push	 edi
  00052	8b ce		 mov	 ecx, esi
  00054	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00057	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0005c	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0005f	8b 44 24 10	 mov	 eax, DWORD PTR _objid$[esp+8]
  00063	89 02		 mov	 DWORD PTR [edx], eax
  00065	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00068	03 d7		 add	 edx, edi

; 2305 : 	m_Snapshot.ar << dwSet;

  0006a	57		 push	 edi
  0006b	8b ce		 mov	 ecx, esi
  0006d	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00070	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00075	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00078	8b 54 24 14	 mov	 edx, DWORD PTR _dwSet$[esp+8]
  0007c	89 11		 mov	 DWORD PTR [ecx], edx
  0007e	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00081	03 c7		 add	 eax, edi

; 2306 : 	m_Snapshot.ar << dwTime;

  00083	57		 push	 edi
  00084	8b ce		 mov	 ecx, esi
  00086	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00089	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0008e	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00091	8b 4c 24 18	 mov	 ecx, DWORD PTR _dwTime$[esp+8]
  00095	89 08		 mov	 DWORD PTR [eax], ecx
  00097	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0009a	03 d7		 add	 edx, edi

; 2307 : 	m_Snapshot.ar << idPlayer;

  0009c	57		 push	 edi
  0009d	8b ce		 mov	 ecx, esi
  0009f	89 56 08	 mov	 DWORD PTR [esi+8], edx
  000a2	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000a7	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  000aa	8b 44 24 1c	 mov	 eax, DWORD PTR _idPlayer$[esp+8]
  000ae	89 02		 mov	 DWORD PTR [edx], eax
  000b0	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000b3	03 c7		 add	 eax, edi
  000b5	5f		 pop	 edi
  000b6	89 46 08	 mov	 DWORD PTR [esi+8], eax
  000b9	5e		 pop	 esi
  000ba	5b		 pop	 ebx
$L299508:

; 2308 : 	
; 2309 : }

  000bb	c2 10 00	 ret	 16			; 00000010H
?AddExpBoxInfo@CUser@@QAEXKKKK@Z ENDP			; CUser::AddExpBoxInfo
_TEXT	ENDS
PUBLIC	?AddSetQuest@CUser@@QAEXPAUtagQuest@@@Z		; CUser::AddSetQuest
; Function compile flags: /Ogty
;	COMDAT ?AddSetQuest@CUser@@QAEXPAUtagQuest@@@Z
_TEXT	SEGMENT
_lpQuest$ = 8						; size = 4
?AddSetQuest@CUser@@QAEXPAUtagQuest@@@Z PROC NEAR	; CUser::AddSetQuest, COMDAT
; _this$ = ecx

; 2359 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	75 51		 jne	 SHORT $L279255

; 2360 : 	
; 2361 : 	m_Snapshot.cb++;

  00006	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  0000d	56		 push	 esi
  0000e	57		 push	 edi

; 2362 : 	m_Snapshot.ar << GetId();

  0000f	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  00015	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  0001b	6a 04		 push	 4
  0001d	8b ce		 mov	 ecx, esi
  0001f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00024	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00027	89 38		 mov	 DWORD PTR [eax], edi
  00029	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0002c	83 c0 04	 add	 eax, 4

; 2363 : 	m_Snapshot.ar << SNAPSHOTTYPE_SETQUEST;

  0002f	6a 02		 push	 2
  00031	8b ce		 mov	 ecx, esi
  00033	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00036	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003b	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003e	66 c7 01 b0 00	 mov	 WORD PTR [ecx], 176	; 000000b0H
  00043	83 46 08 02	 add	 DWORD PTR [esi+8], 2

; 2364 : 	m_Snapshot.ar.Write( lpQuest, sizeof( QUEST ) );//ar << nQuestIdx << nState;

  00047	8b 54 24 0c	 mov	 edx, DWORD PTR _lpQuest$[esp+4]
  0004b	6a 0e		 push	 14			; 0000000eH
  0004d	52		 push	 edx
  0004e	8b ce		 mov	 ecx, esi
  00050	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
  00055	5f		 pop	 edi
  00056	5e		 pop	 esi
$L279255:

; 2365 : 	
; 2366 : }

  00057	c2 04 00	 ret	 4
?AddSetQuest@CUser@@QAEXPAUtagQuest@@@Z ENDP		; CUser::AddSetQuest
_TEXT	ENDS
PUBLIC	?AddQueryGetDestObj@CUser@@QAEXK@Z		; CUser::AddQueryGetDestObj
; Function compile flags: /Ogty
;	COMDAT ?AddQueryGetDestObj@CUser@@QAEXK@Z
_TEXT	SEGMENT
_idFrom$ = 8						; size = 4
?AddQueryGetDestObj@CUser@@QAEXK@Z PROC NEAR		; CUser::AddQueryGetDestObj, COMDAT
; _this$ = ecx

; 2370 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	75 63		 jne	 SHORT $L299548

; 2371 : 	
; 2372 : 	m_Snapshot.cb++;

  00006	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  0000d	56		 push	 esi
  0000e	57		 push	 edi

; 2373 : 	m_Snapshot.ar << GetId();

  0000f	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  00015	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  0001b	6a 04		 push	 4
  0001d	8b ce		 mov	 ecx, esi
  0001f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00024	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00027	89 38		 mov	 DWORD PTR [eax], edi
  00029	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0002c	83 c0 04	 add	 eax, 4

; 2374 : 	m_Snapshot.ar << SNAPSHOTTYPE_QUERYGETDESTOBJ;

  0002f	6a 02		 push	 2
  00031	8b ce		 mov	 ecx, esi
  00033	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00036	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003b	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003e	66 c7 01 49 00	 mov	 WORD PTR [ecx], 73	; 00000049H
  00043	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00046	83 c2 02	 add	 edx, 2

; 2375 : 	m_Snapshot.ar << idFrom;

  00049	6a 04		 push	 4
  0004b	8b ce		 mov	 ecx, esi
  0004d	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00050	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00055	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00058	8b 44 24 0c	 mov	 eax, DWORD PTR _idFrom$[esp+4]
  0005c	89 02		 mov	 DWORD PTR [edx], eax
  0005e	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00061	83 c0 04	 add	 eax, 4
  00064	5f		 pop	 edi
  00065	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00068	5e		 pop	 esi
$L299548:

; 2376 : 	
; 2377 : }

  00069	c2 04 00	 ret	 4
?AddQueryGetDestObj@CUser@@QAEXK@Z ENDP			; CUser::AddQueryGetDestObj
_TEXT	ENDS
PUBLIC	?AddGetDestObj@CUser@@QAEXKKM@Z			; CUser::AddGetDestObj
; Function compile flags: /Ogty
;	COMDAT ?AddGetDestObj@CUser@@QAEXKKM@Z
_TEXT	SEGMENT
_objid$ = 8						; size = 4
_objidDest$ = 12					; size = 4
_fRange$ = 16						; size = 4
?AddGetDestObj@CUser@@QAEXKKM@Z PROC NEAR		; CUser::AddGetDestObj, COMDAT
; _this$ = ecx

; 2381 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	75 70		 jne	 SHORT $L299570

; 2382 : 	
; 2383 : 	m_Snapshot.cb++;

  00006	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  0000d	56		 push	 esi

; 2384 : 	m_Snapshot.ar << objid;

  0000e	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  00014	6a 04		 push	 4
  00016	8b ce		 mov	 ecx, esi
  00018	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0001d	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00020	8b 4c 24 08	 mov	 ecx, DWORD PTR _objid$[esp]
  00024	89 08		 mov	 DWORD PTR [eax], ecx
  00026	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00029	83 c0 04	 add	 eax, 4

; 2385 : 	m_Snapshot.ar << SNAPSHOTTYPE_GETDESTOBJ;

  0002c	6a 02		 push	 2
  0002e	8b ce		 mov	 ecx, esi
  00030	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00033	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00038	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0003b	66 c7 02 4a 00	 mov	 WORD PTR [edx], 74	; 0000004aH
  00040	83 46 08 02	 add	 DWORD PTR [esi+8], 2

; 2386 : 	m_Snapshot.ar << objidDest;

  00044	6a 04		 push	 4
  00046	8b ce		 mov	 ecx, esi
  00048	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0004d	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00050	8b 4c 24 0c	 mov	 ecx, DWORD PTR _objidDest$[esp]
  00054	89 08		 mov	 DWORD PTR [eax], ecx
  00056	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00059	83 c2 04	 add	 edx, 4

; 2387 : 	m_Snapshot.ar << fRange;

  0005c	6a 04		 push	 4
  0005e	8b ce		 mov	 ecx, esi
  00060	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00063	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00068	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0006b	8b 44 24 10	 mov	 eax, DWORD PTR _fRange$[esp]
  0006f	89 02		 mov	 DWORD PTR [edx], eax
  00071	83 46 08 04	 add	 DWORD PTR [esi+8], 4
  00075	5e		 pop	 esi
$L299570:

; 2388 : 
; 2389 : 	
; 2390 : }

  00076	c2 0c 00	 ret	 12			; 0000000cH
?AddGetDestObj@CUser@@QAEXKKM@Z ENDP			; CUser::AddGetDestObj
_TEXT	ENDS
PUBLIC	?AddQueryGetPos@CUser@@QAEXK@Z			; CUser::AddQueryGetPos
; Function compile flags: /Ogty
;	COMDAT ?AddQueryGetPos@CUser@@QAEXK@Z
_TEXT	SEGMENT
_idFrom$ = 8						; size = 4
?AddQueryGetPos@CUser@@QAEXK@Z PROC NEAR		; CUser::AddQueryGetPos, COMDAT
; _this$ = ecx

; 2394 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	75 63		 jne	 SHORT $L299592

; 2395 : 	
; 2396 : 	m_Snapshot.cb++;

  00006	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  0000d	56		 push	 esi
  0000e	57		 push	 edi

; 2397 : 	m_Snapshot.ar << GetId();

  0000f	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  00015	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  0001b	6a 04		 push	 4
  0001d	8b ce		 mov	 ecx, esi
  0001f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00024	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00027	89 38		 mov	 DWORD PTR [eax], edi
  00029	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0002c	83 c0 04	 add	 eax, 4

; 2398 : 	m_Snapshot.ar << SNAPSHOTTYPE_QUERYGETPOS;

  0002f	6a 02		 push	 2
  00031	8b ce		 mov	 ecx, esi
  00033	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00036	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003b	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003e	66 c7 01 1b 00	 mov	 WORD PTR [ecx], 27	; 0000001bH
  00043	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00046	83 c2 02	 add	 edx, 2

; 2399 : 	m_Snapshot.ar << idFrom;

  00049	6a 04		 push	 4
  0004b	8b ce		 mov	 ecx, esi
  0004d	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00050	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00055	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00058	8b 44 24 0c	 mov	 eax, DWORD PTR _idFrom$[esp+4]
  0005c	89 02		 mov	 DWORD PTR [edx], eax
  0005e	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00061	83 c0 04	 add	 eax, 4
  00064	5f		 pop	 edi
  00065	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00068	5e		 pop	 esi
$L299592:

; 2400 : 	
; 2401 : }

  00069	c2 04 00	 ret	 4
?AddQueryGetPos@CUser@@QAEXK@Z ENDP			; CUser::AddQueryGetPos
_TEXT	ENDS
PUBLIC	?AddGetPos@CUser@@QAEXKABUD3DXVECTOR3@@M@Z	; CUser::AddGetPos
; Function compile flags: /Ogty
;	COMDAT ?AddGetPos@CUser@@QAEXKABUD3DXVECTOR3@@M@Z
_TEXT	SEGMENT
$T299611 = -12						; size = 12
_objid$ = 8						; size = 4
_vPos$ = 12						; size = 4
_fAngle$ = 16						; size = 4
?AddGetPos@CUser@@QAEXKABUD3DXVECTOR3@@M@Z PROC NEAR	; CUser::AddGetPos, COMDAT
; _this$ = ecx

; 2405 : 	if( IsDelete() )	return;

  00000	8a 41 04	 mov	 al, BYTE PTR [ecx+4]
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	a8 01		 test	 al, 1
  00008	75 7b		 jne	 SHORT $L299615

; 2406 : 	
; 2407 : 	m_Snapshot.cb++;

  0000a	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  00011	56		 push	 esi

; 2408 : 	m_Snapshot.ar << objid;

  00012	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  00018	6a 04		 push	 4
  0001a	8b ce		 mov	 ecx, esi
  0001c	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00021	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00024	8b 4c 24 14	 mov	 ecx, DWORD PTR _objid$[esp+12]
  00028	89 08		 mov	 DWORD PTR [eax], ecx
  0002a	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0002d	83 c0 04	 add	 eax, 4

; 2409 : 	m_Snapshot.ar << SNAPSHOTTYPE_GETPOS;

  00030	6a 02		 push	 2
  00032	8b ce		 mov	 ecx, esi
  00034	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00037	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003c	8b 56 08	 mov	 edx, DWORD PTR [esi+8]

; 2410 : 	m_Snapshot.ar << vPos << fAngle;

  0003f	8b 44 24 18	 mov	 eax, DWORD PTR _vPos$[esp+12]
  00043	66 c7 02 1f 00	 mov	 WORD PTR [edx], 31	; 0000001fH
  00048	83 46 08 02	 add	 DWORD PTR [esi+8], 2
  0004c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0004e	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00051	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00054	89 4c 24 04	 mov	 DWORD PTR $T299611[esp+16], ecx
  00058	6a 0c		 push	 12			; 0000000cH
  0005a	8d 4c 24 08	 lea	 ecx, DWORD PTR $T299611[esp+20]
  0005e	51		 push	 ecx
  0005f	8b ce		 mov	 ecx, esi
  00061	89 54 24 10	 mov	 DWORD PTR $T299611[esp+28], edx
  00065	89 44 24 14	 mov	 DWORD PTR $T299611[esp+32], eax
  00069	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
  0006e	6a 04		 push	 4
  00070	8b ce		 mov	 ecx, esi
  00072	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00077	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0007a	8b 44 24 1c	 mov	 eax, DWORD PTR _fAngle$[esp+12]
  0007e	89 02		 mov	 DWORD PTR [edx], eax
  00080	83 46 08 04	 add	 DWORD PTR [esi+8], 4
  00084	5e		 pop	 esi
$L299615:

; 2411 : 	
; 2412 : }

  00085	83 c4 0c	 add	 esp, 12			; 0000000cH
  00088	c2 0c 00	 ret	 12			; 0000000cH
?AddGetPos@CUser@@QAEXKABUD3DXVECTOR3@@M@Z ENDP		; CUser::AddGetPos
_TEXT	ENDS
PUBLIC	?AddResurrectionMessage@CUser@@QAEXXZ		; CUser::AddResurrectionMessage
; Function compile flags: /Ogty
;	COMDAT ?AddResurrectionMessage@CUser@@QAEXXZ
_TEXT	SEGMENT
?AddResurrectionMessage@CUser@@QAEXXZ PROC NEAR		; CUser::AddResurrectionMessage, COMDAT
; _this$ = ecx

; 2416 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	75 48		 jne	 SHORT $L299631

; 2417 : 	
; 2418 : 	m_Snapshot.cb++;

  00006	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  0000d	56		 push	 esi
  0000e	57		 push	 edi

; 2419 : 	m_Snapshot.ar << GetId();

  0000f	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  00015	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  0001b	6a 04		 push	 4
  0001d	8b ce		 mov	 ecx, esi
  0001f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00024	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00027	89 38		 mov	 DWORD PTR [eax], edi
  00029	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0002c	83 c2 04	 add	 edx, 4

; 2420 : 	m_Snapshot.ar << SNAPSHOTTYPE_RESURRECTION_MESSAGE;

  0002f	6a 02		 push	 2
  00031	8b ce		 mov	 ecx, esi
  00033	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00036	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003b	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003e	66 c7 01 27 00	 mov	 WORD PTR [ecx], 39	; 00000027H
  00043	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00046	83 c0 02	 add	 eax, 2
  00049	5f		 pop	 edi
  0004a	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0004d	5e		 pop	 esi
$L299631:

; 2421 : 	
; 2422 : }

  0004e	c3		 ret	 0
?AddResurrectionMessage@CUser@@QAEXXZ ENDP		; CUser::AddResurrectionMessage
_TEXT	ENDS
PUBLIC	?AddCorrReq@CUser@@QAEXPAVCMover@@@Z		; CUser::AddCorrReq
; Function compile flags: /Ogty
;	COMDAT ?AddCorrReq@CUser@@QAEXPAVCMover@@@Z
_TEXT	SEGMENT
$T299659 = -12						; size = 12
_pMover$ = 8						; size = 4
?AddCorrReq@CUser@@QAEXPAVCMover@@@Z PROC NEAR		; CUser::AddCorrReq, COMDAT
; _this$ = ecx

; 2427 : 	if( IsDelete() )	return;

  00000	8a 41 04	 mov	 al, BYTE PTR [ecx+4]
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	a8 01		 test	 al, 1
  00008	0f 85 8e 00 00
	00		 jne	 $L299662

; 2428 : 	
; 2429 : 	m_Snapshot.cb++;

  0000e	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	57		 push	 edi

; 2430 : 	m_Snapshot.ar << pMover->GetId();

  00018	8b 7c 24 1c	 mov	 edi, DWORD PTR _pMover$[esp+20]
  0001c	8b 9f bc 01 00
	00		 mov	 ebx, DWORD PTR [edi+444]
  00022	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  00028	6a 04		 push	 4
  0002a	8b ce		 mov	 ecx, esi
  0002c	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00031	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00034	89 18		 mov	 DWORD PTR [eax], ebx
  00036	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00039	83 c2 04	 add	 edx, 4

; 2431 : 	m_Snapshot.ar << SNAPSHOTTYPE_CORRREQ;

  0003c	6a 02		 push	 2
  0003e	8b ce		 mov	 ecx, esi
  00040	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00043	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00048	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0004b	66 c7 01 41 00	 mov	 WORD PTR [ecx], 65	; 00000041H
  00050	83 46 08 02	 add	 DWORD PTR [esi+8], 2

; 2432 : 	m_Snapshot.ar << pMover->GetPos();

  00054	8d 97 60 01 00
	00		 lea	 edx, DWORD PTR [edi+352]
  0005a	8b 02		 mov	 eax, DWORD PTR [edx]
  0005c	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  0005f	8b 52 08	 mov	 edx, DWORD PTR [edx+8]
  00062	89 44 24 0c	 mov	 DWORD PTR $T299659[esp+24], eax
  00066	6a 0c		 push	 12			; 0000000cH
  00068	8d 44 24 10	 lea	 eax, DWORD PTR $T299659[esp+28]
  0006c	89 4c 24 14	 mov	 DWORD PTR $T299659[esp+32], ecx
  00070	50		 push	 eax
  00071	8b ce		 mov	 ecx, esi
  00073	89 54 24 1c	 mov	 DWORD PTR $T299659[esp+40], edx
  00077	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write

; 2433 : 	m_Snapshot.ar << pMover->m_idAttacker;

  0007c	8b bf 9c 06 00
	00		 mov	 edi, DWORD PTR [edi+1692]
  00082	6a 04		 push	 4
  00084	8b ce		 mov	 ecx, esi
  00086	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0008b	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0008e	89 39		 mov	 DWORD PTR [ecx], edi
  00090	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00093	83 c0 04	 add	 eax, 4
  00096	5f		 pop	 edi
  00097	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0009a	5e		 pop	 esi
  0009b	5b		 pop	 ebx
$L299662:

; 2434 : 	
; 2435 : }

  0009c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0009f	c2 04 00	 ret	 4
?AddCorrReq@CUser@@QAEXPAVCMover@@@Z ENDP		; CUser::AddCorrReq
_TEXT	ENDS
PUBLIC	?AddSetState@CUser@@QAEXJJJJJ@Z			; CUser::AddSetState
; Function compile flags: /Ogty
;	COMDAT ?AddSetState@CUser@@QAEXJJJJJ@Z
_TEXT	SEGMENT
_nStr$ = 8						; size = 4
_nSta$ = 12						; size = 4
_nDex$ = 16						; size = 4
_nInt$ = 20						; size = 4
_nGP$ = 24						; size = 4
?AddSetState@CUser@@QAEXJJJJJ@Z PROC NEAR		; CUser::AddSetState, COMDAT
; _this$ = ecx

; 2451 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	0f 85 e3 00 00
	00		 jne	 $L299702

; 2452 : 	
; 2453 : 	m_Snapshot.cb++;

  0000a	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  00011	53		 push	 ebx

; 2454 : 	m_Snapshot.ar << GetId();

  00012	8b 99 bc 01 00
	00		 mov	 ebx, DWORD PTR [ecx+444]
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  00020	bf 04 00 00 00	 mov	 edi, 4
  00025	57		 push	 edi
  00026	8b ce		 mov	 ecx, esi
  00028	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0002d	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00030	89 18		 mov	 DWORD PTR [eax], ebx
  00032	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00035	03 d7		 add	 edx, edi

; 2455 : 	m_Snapshot.ar << SNAPSHOTTYPE_SETSTATE;

  00037	6a 02		 push	 2
  00039	8b ce		 mov	 ecx, esi
  0003b	89 56 08	 mov	 DWORD PTR [esi+8], edx
  0003e	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00043	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00046	66 c7 01 6a 00	 mov	 WORD PTR [ecx], 106	; 0000006aH
  0004b	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0004e	83 c0 02	 add	 eax, 2

; 2456 : 	m_Snapshot.ar << nStr << nSta << nDex << nInt;

  00051	57		 push	 edi
  00052	8b ce		 mov	 ecx, esi
  00054	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00057	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0005c	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0005f	8b 44 24 10	 mov	 eax, DWORD PTR _nStr$[esp+8]
  00063	89 02		 mov	 DWORD PTR [edx], eax
  00065	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00068	03 d7		 add	 edx, edi
  0006a	57		 push	 edi
  0006b	8b ce		 mov	 ecx, esi
  0006d	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00070	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00075	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00078	8b 54 24 14	 mov	 edx, DWORD PTR _nSta$[esp+8]
  0007c	89 11		 mov	 DWORD PTR [ecx], edx
  0007e	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00081	03 c7		 add	 eax, edi
  00083	57		 push	 edi
  00084	8b ce		 mov	 ecx, esi
  00086	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00089	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0008e	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00091	8b 4c 24 18	 mov	 ecx, DWORD PTR _nDex$[esp+8]
  00095	89 08		 mov	 DWORD PTR [eax], ecx
  00097	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0009a	03 d7		 add	 edx, edi
  0009c	57		 push	 edi
  0009d	8b ce		 mov	 ecx, esi
  0009f	89 56 08	 mov	 DWORD PTR [esi+8], edx
  000a2	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000a7	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  000aa	8b 44 24 1c	 mov	 eax, DWORD PTR _nInt$[esp+8]
  000ae	89 02		 mov	 DWORD PTR [edx], eax
  000b0	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000b3	03 c7		 add	 eax, edi

; 2457 : 	m_Snapshot.ar << (LONG)0 << nGP;

  000b5	57		 push	 edi
  000b6	8b ce		 mov	 ecx, esi
  000b8	89 46 08	 mov	 DWORD PTR [esi+8], eax
  000bb	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000c0	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  000c3	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  000c9	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  000cc	03 d7		 add	 edx, edi
  000ce	57		 push	 edi
  000cf	8b ce		 mov	 ecx, esi
  000d1	89 56 08	 mov	 DWORD PTR [esi+8], edx
  000d4	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000d9	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  000dc	8b 44 24 20	 mov	 eax, DWORD PTR _nGP$[esp+8]
  000e0	89 02		 mov	 DWORD PTR [edx], eax
  000e2	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000e5	03 c7		 add	 eax, edi
  000e7	5f		 pop	 edi
  000e8	89 46 08	 mov	 DWORD PTR [esi+8], eax
  000eb	5e		 pop	 esi
  000ec	5b		 pop	 ebx
$L299702:

; 2458 : 	
; 2459 : }

  000ed	c2 14 00	 ret	 20			; 00000014H
?AddSetState@CUser@@QAEXJJJJJ@Z ENDP			; CUser::AddSetState
_TEXT	ENDS
PUBLIC	?AddSetSkill@CUser@@QAEXKK@Z			; CUser::AddSetSkill
; Function compile flags: /Ogty
;	COMDAT ?AddSetSkill@CUser@@QAEXKK@Z
_TEXT	SEGMENT
_dwSkill$ = 8						; size = 4
_dwSkillLevel$ = 12					; size = 4
?AddSetSkill@CUser@@QAEXKK@Z PROC NEAR			; CUser::AddSetSkill, COMDAT
; _this$ = ecx

; 2463 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	75 7e		 jne	 SHORT $L299727

; 2464 : 	
; 2465 : 	m_Snapshot.cb++;

  00006	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  0000d	56		 push	 esi
  0000e	57		 push	 edi

; 2466 : 	m_Snapshot.ar << GetId();

  0000f	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  00015	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  0001b	6a 04		 push	 4
  0001d	8b ce		 mov	 ecx, esi
  0001f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00024	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00027	89 38		 mov	 DWORD PTR [eax], edi
  00029	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0002c	83 c2 04	 add	 edx, 4

; 2467 : 	m_Snapshot.ar << SNAPSHOTTYPE_CMDSETSKILLLEVEL;

  0002f	6a 02		 push	 2
  00031	8b ce		 mov	 ecx, esi
  00033	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00036	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003b	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003e	66 c7 01 6b 00	 mov	 WORD PTR [ecx], 107	; 0000006bH
  00043	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00046	83 c0 02	 add	 eax, 2

; 2468 : 	m_Snapshot.ar << dwSkill << dwSkillLevel;

  00049	6a 04		 push	 4
  0004b	8b ce		 mov	 ecx, esi
  0004d	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00050	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00055	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00058	8b 44 24 0c	 mov	 eax, DWORD PTR _dwSkill$[esp+4]
  0005c	89 02		 mov	 DWORD PTR [edx], eax
  0005e	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00061	83 c2 04	 add	 edx, 4
  00064	6a 04		 push	 4
  00066	8b ce		 mov	 ecx, esi
  00068	89 56 08	 mov	 DWORD PTR [esi+8], edx
  0006b	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00070	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00073	8b 54 24 10	 mov	 edx, DWORD PTR _dwSkillLevel$[esp+4]
  00077	89 11		 mov	 DWORD PTR [ecx], edx
  00079	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0007c	83 c0 04	 add	 eax, 4
  0007f	5f		 pop	 edi
  00080	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00083	5e		 pop	 esi
$L299727:

; 2469 : 	
; 2470 : }

  00084	c2 08 00	 ret	 8
?AddSetSkill@CUser@@QAEXKK@Z ENDP			; CUser::AddSetSkill
_TEXT	ENDS
PUBLIC	?AddMotionError@CUser@@QAEXXZ			; CUser::AddMotionError
; Function compile flags: /Ogty
;	COMDAT ?AddMotionError@CUser@@QAEXXZ
_TEXT	SEGMENT
?AddMotionError@CUser@@QAEXXZ PROC NEAR			; CUser::AddMotionError, COMDAT
; _this$ = ecx

; 2474 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	75 63		 jne	 SHORT $L299748

; 2475 : 	
; 2476 : 	m_Snapshot.cb++;

  00006	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  0000d	56		 push	 esi
  0000e	57		 push	 edi

; 2477 : 	m_Snapshot.ar << GetId();

  0000f	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  00015	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  0001b	6a 04		 push	 4
  0001d	8b ce		 mov	 ecx, esi
  0001f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00024	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00027	89 38		 mov	 DWORD PTR [eax], edi
  00029	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0002c	83 c0 04	 add	 eax, 4

; 2478 : 	m_Snapshot.ar << SNAPSHOTTYPE_MOTION;

  0002f	6a 02		 push	 2
  00031	8b ce		 mov	 ecx, esi
  00033	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00036	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003b	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003e	66 c7 01 98 00	 mov	 WORD PTR [ecx], 152	; 00000098H
  00043	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00046	83 c2 02	 add	 edx, 2

; 2479 : 	m_Snapshot.ar << (DWORD)OBJMSG_NONE;

  00049	6a 04		 push	 4
  0004b	8b ce		 mov	 ecx, esi
  0004d	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00050	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00055	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00058	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0
  0005e	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00061	83 c0 04	 add	 eax, 4
  00064	5f		 pop	 edi
  00065	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00068	5e		 pop	 esi
$L299748:

; 2480 : 	
; 2481 : }

  00069	c3		 ret	 0
?AddMotionError@CUser@@QAEXXZ ENDP			; CUser::AddMotionError
_TEXT	ENDS
PUBLIC	?AddSetSkillState@CUser@@QAEXPAVCMover@@KKK@Z	; CUser::AddSetSkillState
; Function compile flags: /Ogty
;	COMDAT ?AddSetSkillState@CUser@@QAEXPAVCMover@@KKK@Z
_TEXT	SEGMENT
_pMover$ = 8						; size = 4
_dwSkill$ = 12						; size = 4
_dwLevel$ = 16						; size = 4
_dwTime$ = 20						; size = 4
?AddSetSkillState@CUser@@QAEXPAVCMover@@KKK@Z PROC NEAR	; CUser::AddSetSkillState, COMDAT
; _this$ = ecx

; 2527 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	0f 85 9c 00 00
	00		 jne	 $L299778

; 2528 : 	
; 2529 : 	m_Snapshot.cb++;

  0000a	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]

; 2530 : 	m_Snapshot.ar << pMover->GetId();

  00011	8b 44 24 04	 mov	 eax, DWORD PTR _pMover$[esp-4]
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	8b b8 bc 01 00
	00		 mov	 edi, DWORD PTR [eax+444]
  0001e	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  00024	bb 04 00 00 00	 mov	 ebx, 4
  00029	53		 push	 ebx
  0002a	8b ce		 mov	 ecx, esi
  0002c	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00031	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00034	89 39		 mov	 DWORD PTR [ecx], edi
  00036	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00039	03 c3		 add	 eax, ebx

; 2531 : 	m_Snapshot.ar << SNAPSHOTTYPE_SETSKILLSTATE;

  0003b	6a 02		 push	 2
  0003d	8b ce		 mov	 ecx, esi
  0003f	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00042	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00047	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0004a	66 c7 02 4c 00	 mov	 WORD PTR [edx], 76	; 0000004cH
  0004f	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00052	83 c2 02	 add	 edx, 2

; 2532 : 	m_Snapshot.ar << dwSkill;

  00055	53		 push	 ebx
  00056	8b ce		 mov	 ecx, esi
  00058	89 56 08	 mov	 DWORD PTR [esi+8], edx
  0005b	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00060	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00063	8b 4c 24 14	 mov	 ecx, DWORD PTR _dwSkill$[esp+8]
  00067	89 08		 mov	 DWORD PTR [eax], ecx
  00069	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0006c	03 c3		 add	 eax, ebx

; 2533 : 	m_Snapshot.ar << dwLevel;

  0006e	53		 push	 ebx
  0006f	8b ce		 mov	 ecx, esi
  00071	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00074	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00079	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0007c	8b 44 24 18	 mov	 eax, DWORD PTR _dwLevel$[esp+8]
  00080	89 02		 mov	 DWORD PTR [edx], eax
  00082	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00085	03 d3		 add	 edx, ebx

; 2534 : 	m_Snapshot.ar << dwTime;

  00087	53		 push	 ebx
  00088	8b ce		 mov	 ecx, esi
  0008a	89 56 08	 mov	 DWORD PTR [esi+8], edx
  0008d	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00092	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00095	8b 54 24 1c	 mov	 edx, DWORD PTR _dwTime$[esp+8]
  00099	89 11		 mov	 DWORD PTR [ecx], edx
  0009b	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0009e	03 c3		 add	 eax, ebx
  000a0	5f		 pop	 edi
  000a1	89 46 08	 mov	 DWORD PTR [esi+8], eax
  000a4	5e		 pop	 esi
  000a5	5b		 pop	 ebx
$L299778:

; 2535 : }

  000a6	c2 10 00	 ret	 16			; 00000010H
?AddSetSkillState@CUser@@QAEXPAVCMover@@KKK@Z ENDP	; CUser::AddSetSkillState
_TEXT	ENDS
PUBLIC	?AddSetNaviPoint@CUser@@QAEXABUNaviPoint@@KPBD@Z ; CUser::AddSetNaviPoint
; Function compile flags: /Ogty
;	COMDAT ?AddSetNaviPoint@CUser@@QAEXABUNaviPoint@@KPBD@Z
_TEXT	SEGMENT
$T299798 = -12						; size = 12
_nv$ = 8						; size = 4
_objid$ = 12						; size = 4
_Name$ = 16						; size = 4
?AddSetNaviPoint@CUser@@QAEXABUNaviPoint@@KPBD@Z PROC NEAR ; CUser::AddSetNaviPoint, COMDAT
; _this$ = ecx

; 2599 : 	if( IsDelete() )	return;

  00000	8a 41 04	 mov	 al, BYTE PTR [ecx+4]
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	a8 01		 test	 al, 1
  00008	75 71		 jne	 SHORT $L279397

; 2600 : 	
; 2601 : 	m_Snapshot.cb++;

  0000a	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  00011	56		 push	 esi

; 2602 : 	m_Snapshot.ar << objid;

  00012	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  00018	6a 04		 push	 4
  0001a	8b ce		 mov	 ecx, esi
  0001c	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00021	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00024	8b 4c 24 18	 mov	 ecx, DWORD PTR _objid$[esp+12]
  00028	89 08		 mov	 DWORD PTR [eax], ecx
  0002a	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0002d	83 c0 04	 add	 eax, 4

; 2603 : 	m_Snapshot.ar << SNAPSHOTTYPE_SETNAVIPOINT;

  00030	6a 02		 push	 2
  00032	8b ce		 mov	 ecx, esi
  00034	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00037	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003c	8b 56 08	 mov	 edx, DWORD PTR [esi+8]

; 2604 : 	m_Snapshot.ar << nv.Pos;// << nv.On;

  0003f	8b 44 24 14	 mov	 eax, DWORD PTR _nv$[esp+12]
  00043	66 c7 02 c6 00	 mov	 WORD PTR [edx], 198	; 000000c6H
  00048	83 46 08 02	 add	 DWORD PTR [esi+8], 2
  0004c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0004e	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00051	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00054	89 4c 24 04	 mov	 DWORD PTR $T299798[esp+16], ecx
  00058	6a 0c		 push	 12			; 0000000cH
  0005a	8d 4c 24 08	 lea	 ecx, DWORD PTR $T299798[esp+20]
  0005e	51		 push	 ecx
  0005f	8b ce		 mov	 ecx, esi
  00061	89 54 24 10	 mov	 DWORD PTR $T299798[esp+28], edx
  00065	89 44 24 14	 mov	 DWORD PTR $T299798[esp+32], eax
  00069	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write

; 2605 : 	m_Snapshot.ar.WriteString( Name );

  0006e	8b 54 24 1c	 mov	 edx, DWORD PTR _Name$[esp+12]
  00072	52		 push	 edx
  00073	8b ce		 mov	 ecx, esi
  00075	e8 00 00 00 00	 call	 ?WriteString@CAr@@QAEXPBD@Z ; CAr::WriteString
  0007a	5e		 pop	 esi
$L279397:

; 2606 : 	
; 2607 : }

  0007b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0007e	c2 0c 00	 ret	 12			; 0000000cH
?AddSetNaviPoint@CUser@@QAEXABUNaviPoint@@KPBD@Z ENDP	; CUser::AddSetNaviPoint
_TEXT	ENDS
PUBLIC	?AddSummonFriendUse@CUser@@QAEXPAVCItemElem@@@Z	; CUser::AddSummonFriendUse
; Function compile flags: /Ogty
;	COMDAT ?AddSummonFriendUse@CUser@@QAEXPAVCItemElem@@@Z
_TEXT	SEGMENT
_pItemElem$ = 8						; size = 4
?AddSummonFriendUse@CUser@@QAEXPAVCItemElem@@@Z PROC NEAR ; CUser::AddSummonFriendUse, COMDAT
; _this$ = ecx

; 2709 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	0f 85 8e 00 00
	00		 jne	 $L299831

; 2710 : 	
; 2711 : 	m_Snapshot.cb++;

  0000a	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  00011	53		 push	 ebx
  00012	56		 push	 esi
  00013	57		 push	 edi

; 2712 : 	m_Snapshot.ar << GETID( this );

  00014	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  0001a	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  00020	6a 04		 push	 4
  00022	8b ce		 mov	 ecx, esi
  00024	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00029	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0002c	89 38		 mov	 DWORD PTR [eax], edi
  0002e	83 46 08 04	 add	 DWORD PTR [esi+8], 4

; 2713 : 	m_Snapshot.ar << SNAPSHOTTYPE_SUMMON;

  00032	6a 02		 push	 2
  00034	8b ce		 mov	 ecx, esi
  00036	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003b	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003e	66 c7 01 ed 00	 mov	 WORD PTR [ecx], 237	; 000000edH
  00043	8b 5e 08	 mov	 ebx, DWORD PTR [esi+8]
  00046	83 c3 02	 add	 ebx, 2

; 2714 : 	m_Snapshot.ar << SOMMON_FRIEND;

  00049	6a 01		 push	 1
  0004b	8b ce		 mov	 ecx, esi
  0004d	89 5e 08	 mov	 DWORD PTR [esi+8], ebx
  00050	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00055	8b 56 08	 mov	 edx, DWORD PTR [esi+8]

; 2715 : 	m_Snapshot.ar << MAKELONG( ITYPE_ITEM, pItemElem->m_dwObjId );

  00058	8b 5c 24 10	 mov	 ebx, DWORD PTR _pItemElem$[esp+8]
  0005c	c6 02 00	 mov	 BYTE PTR [edx], 0
  0005f	ff 46 08	 inc	 DWORD PTR [esi+8]
  00062	0f b7 7b 04	 movzx	 edi, WORD PTR [ebx+4]
  00066	6a 04		 push	 4
  00068	8b ce		 mov	 ecx, esi
  0006a	c1 e7 10	 shl	 edi, 16			; 00000010H
  0006d	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00072	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00075	89 38		 mov	 DWORD PTR [eax], edi
  00077	83 46 08 04	 add	 DWORD PTR [esi+8], 4

; 2716 : 	m_Snapshot.ar << pItemElem->m_dwObjId;

  0007b	8b 5b 04	 mov	 ebx, DWORD PTR [ebx+4]
  0007e	6a 04		 push	 4
  00080	8b ce		 mov	 ecx, esi
  00082	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00087	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0008a	89 19		 mov	 DWORD PTR [ecx], ebx
  0008c	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0008f	83 c0 04	 add	 eax, 4
  00092	5f		 pop	 edi
  00093	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00096	5e		 pop	 esi
  00097	5b		 pop	 ebx
$L299831:

; 2717 : 	
; 2718 : }

  00098	c2 04 00	 ret	 4
?AddSummonFriendUse@CUser@@QAEXPAVCItemElem@@@Z ENDP	; CUser::AddSummonFriendUse
_TEXT	ENDS
PUBLIC	?AddSummonFriendConfirm@CUser@@QAEXKKPBD0@Z	; CUser::AddSummonFriendConfirm
; Function compile flags: /Ogty
;	COMDAT ?AddSummonFriendConfirm@CUser@@QAEXKKPBD0@Z
_TEXT	SEGMENT
_objid$ = 8						; size = 4
_dwData$ = 12						; size = 4
_szName$ = 16						; size = 4
_szWorldName$ = 20					; size = 4
?AddSummonFriendConfirm@CUser@@QAEXKKPBD0@Z PROC NEAR	; CUser::AddSummonFriendConfirm, COMDAT
; _this$ = ecx

; 2721 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	0f 85 a2 00 00
	00		 jne	 $L279464

; 2722 : 	
; 2723 : 	m_Snapshot.cb++;

  0000a	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  00011	56		 push	 esi
  00012	57		 push	 edi

; 2724 : 	m_Snapshot.ar << GETID( this );

  00013	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  00019	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  0001f	6a 04		 push	 4
  00021	8b ce		 mov	 ecx, esi
  00023	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00028	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0002b	89 38		 mov	 DWORD PTR [eax], edi
  0002d	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  00030	83 c7 04	 add	 edi, 4

; 2725 : 	m_Snapshot.ar << SNAPSHOTTYPE_SUMMON;

  00033	6a 02		 push	 2
  00035	8b ce		 mov	 ecx, esi
  00037	89 7e 08	 mov	 DWORD PTR [esi+8], edi
  0003a	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003f	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00042	66 c7 01 ed 00	 mov	 WORD PTR [ecx], 237	; 000000edH
  00047	83 46 08 02	 add	 DWORD PTR [esi+8], 2

; 2726 : 	m_Snapshot.ar << SOMMON_FRIEND_CONFIRM;

  0004b	6a 01		 push	 1
  0004d	8b ce		 mov	 ecx, esi
  0004f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00054	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00057	c6 02 01	 mov	 BYTE PTR [edx], 1
  0005a	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  0005d	47		 inc	 edi

; 2727 : 	m_Snapshot.ar << objid << dwData;

  0005e	6a 04		 push	 4
  00060	8b ce		 mov	 ecx, esi
  00062	89 7e 08	 mov	 DWORD PTR [esi+8], edi
  00065	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0006a	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0006d	8b 4c 24 0c	 mov	 ecx, DWORD PTR _objid$[esp+4]
  00071	89 08		 mov	 DWORD PTR [eax], ecx
  00073	83 46 08 04	 add	 DWORD PTR [esi+8], 4
  00077	6a 04		 push	 4
  00079	8b ce		 mov	 ecx, esi
  0007b	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00080	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00083	8b 44 24 10	 mov	 eax, DWORD PTR _dwData$[esp+4]

; 2728 : 	m_Snapshot.ar.WriteString( szName );

  00087	8b 4c 24 14	 mov	 ecx, DWORD PTR _szName$[esp+4]
  0008b	89 02		 mov	 DWORD PTR [edx], eax
  0008d	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  00090	51		 push	 ecx
  00091	83 c7 04	 add	 edi, 4
  00094	8b ce		 mov	 ecx, esi
  00096	89 7e 08	 mov	 DWORD PTR [esi+8], edi
  00099	e8 00 00 00 00	 call	 ?WriteString@CAr@@QAEXPBD@Z ; CAr::WriteString

; 2729 : 	m_Snapshot.ar.WriteString( szWorldName );

  0009e	8b 54 24 18	 mov	 edx, DWORD PTR _szWorldName$[esp+4]
  000a2	52		 push	 edx
  000a3	8b ce		 mov	 ecx, esi
  000a5	e8 00 00 00 00	 call	 ?WriteString@CAr@@QAEXPBD@Z ; CAr::WriteString
  000aa	5f		 pop	 edi
  000ab	5e		 pop	 esi
$L279464:

; 2730 : 	
; 2731 : }

  000ac	c2 10 00	 ret	 16			; 00000010H
?AddSummonFriendConfirm@CUser@@QAEXKKPBD0@Z ENDP	; CUser::AddSummonFriendConfirm
_TEXT	ENDS
PUBLIC	?AddSummonPartyConfirm@CUser@@QAEXKKPBD@Z	; CUser::AddSummonPartyConfirm
; Function compile flags: /Ogty
;	COMDAT ?AddSummonPartyConfirm@CUser@@QAEXKKPBD@Z
_TEXT	SEGMENT
_objid$ = 8						; size = 4
_dwData$ = 12						; size = 4
_szWorldName$ = 16					; size = 4
?AddSummonPartyConfirm@CUser@@QAEXKKPBD@Z PROC NEAR	; CUser::AddSummonPartyConfirm, COMDAT
; _this$ = ecx

; 2734 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	0f 85 92 00 00
	00		 jne	 $L279472

; 2735 : 	
; 2736 : 	m_Snapshot.cb++;

  0000a	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  00011	56		 push	 esi
  00012	57		 push	 edi

; 2737 : 	m_Snapshot.ar << GETID( this );

  00013	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  00019	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  0001f	6a 04		 push	 4
  00021	8b ce		 mov	 ecx, esi
  00023	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00028	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0002b	89 38		 mov	 DWORD PTR [eax], edi
  0002d	83 46 08 04	 add	 DWORD PTR [esi+8], 4

; 2738 : 	m_Snapshot.ar << SNAPSHOTTYPE_SUMMON;

  00031	6a 02		 push	 2
  00033	8b ce		 mov	 ecx, esi
  00035	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003a	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003d	66 c7 01 ed 00	 mov	 WORD PTR [ecx], 237	; 000000edH
  00042	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  00045	83 c7 02	 add	 edi, 2

; 2739 : 	m_Snapshot.ar << SOMMON_PARTY_CONFIRM;

  00048	6a 01		 push	 1
  0004a	8b ce		 mov	 ecx, esi
  0004c	89 7e 08	 mov	 DWORD PTR [esi+8], edi
  0004f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00054	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00057	c6 02 10	 mov	 BYTE PTR [edx], 16	; 00000010H
  0005a	ff 46 08	 inc	 DWORD PTR [esi+8]

; 2740 : 	m_Snapshot.ar << objid << dwData;

  0005d	6a 04		 push	 4
  0005f	8b ce		 mov	 ecx, esi
  00061	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00066	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00069	8b 4c 24 0c	 mov	 ecx, DWORD PTR _objid$[esp+4]
  0006d	89 08		 mov	 DWORD PTR [eax], ecx
  0006f	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  00072	83 c7 04	 add	 edi, 4
  00075	6a 04		 push	 4
  00077	8b ce		 mov	 ecx, esi
  00079	89 7e 08	 mov	 DWORD PTR [esi+8], edi
  0007c	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00081	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00084	8b 44 24 10	 mov	 eax, DWORD PTR _dwData$[esp+4]
  00088	89 02		 mov	 DWORD PTR [edx], eax
  0008a	83 46 08 04	 add	 DWORD PTR [esi+8], 4

; 2741 : 	m_Snapshot.ar.WriteString( szWorldName );

  0008e	8b 4c 24 14	 mov	 ecx, DWORD PTR _szWorldName$[esp+4]
  00092	51		 push	 ecx
  00093	8b ce		 mov	 ecx, esi
  00095	e8 00 00 00 00	 call	 ?WriteString@CAr@@QAEXPBD@Z ; CAr::WriteString
  0009a	5f		 pop	 edi
  0009b	5e		 pop	 esi
$L279472:

; 2742 : 	
; 2743 : }

  0009c	c2 0c 00	 ret	 12			; 0000000cH
?AddSummonPartyConfirm@CUser@@QAEXKKPBD@Z ENDP		; CUser::AddSummonPartyConfirm
_TEXT	ENDS
PUBLIC	?SetReturnPos@CUser@@QAEXABUD3DXVECTOR3@@@Z	; CUser::SetReturnPos
; Function compile flags: /Ogty
;	COMDAT ?SetReturnPos@CUser@@QAEXABUD3DXVECTOR3@@@Z
_TEXT	SEGMENT
_vPos$ = 8						; size = 4
?SetReturnPos@CUser@@QAEXABUD3DXVECTOR3@@@Z PROC NEAR	; CUser::SetReturnPos, COMDAT
; _this$ = ecx

; 2747 : 	ASSERT( GetWorld() );
; 2748 : 
; 2749 : 	m_dwReturnWorldID = GetWorld()->GetID();

  00000	8b 81 6c 01 00
	00		 mov	 eax, DWORD PTR [ecx+364]
  00006	8b 10		 mov	 edx, DWORD PTR [eax]

; 2750 : 	m_vReturnPos = vPos;

  00008	8b 44 24 04	 mov	 eax, DWORD PTR _vPos$[esp-4]
  0000c	89 91 d0 95 00
	00		 mov	 DWORD PTR [ecx+38352], edx
  00012	8b 10		 mov	 edx, DWORD PTR [eax]
  00014	81 c1 c4 95 00
	00		 add	 ecx, 38340		; 000095c4H
  0001a	89 11		 mov	 DWORD PTR [ecx], edx
  0001c	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0001f	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  00022	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00025	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 2751 : 	TRACE("SetReturnPos: %f %f %f\n", m_vReturnPos.x, m_vReturnPos.y, m_vReturnPos.z );
; 2752 : }

  00028	c2 04 00	 ret	 4
?SetReturnPos@CUser@@QAEXABUD3DXVECTOR3@@@Z ENDP	; CUser::SetReturnPos
_TEXT	ENDS
PUBLIC	?AddPetState@CUser@@QAEXKGGK@Z			; CUser::AddPetState
; Function compile flags: /Ogty
;	COMDAT ?AddPetState@CUser@@QAEXKGGK@Z
_TEXT	SEGMENT
_dwPetId$ = 8						; size = 4
_wLife$ = 12						; size = 2
_wEnergy$ = 16						; size = 2
_dwExp$ = 20						; size = 4
?AddPetState@CUser@@QAEXKGGK@Z PROC NEAR		; CUser::AddPetState, COMDAT
; _this$ = ecx

; 3040 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	0f 85 ad 00 00
	00		 jne	 $L299942

; 3041 : 	
; 3042 : 	m_Snapshot.cb++;

  0000a	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  00011	56		 push	 esi
  00012	57		 push	 edi

; 3043 : 	m_Snapshot.ar << GETID( this );

  00013	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  00019	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  0001f	6a 04		 push	 4
  00021	8b ce		 mov	 ecx, esi
  00023	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00028	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0002b	89 38		 mov	 DWORD PTR [eax], edi
  0002d	83 46 08 04	 add	 DWORD PTR [esi+8], 4

; 3044 : 	m_Snapshot.ar << SNAPSHOTTYPE_PET_STATE;

  00031	bf 02 00 00 00	 mov	 edi, 2
  00036	57		 push	 edi
  00037	8b ce		 mov	 ecx, esi
  00039	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003e	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00041	66 c7 01 15 01	 mov	 WORD PTR [ecx], 277	; 00000115H
  00046	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00049	03 d7		 add	 edx, edi

; 3045 : 	m_Snapshot.ar << dwPetId << wLife << wEnergy << dwExp;

  0004b	6a 04		 push	 4
  0004d	8b ce		 mov	 ecx, esi
  0004f	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00052	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00057	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0005a	8b 44 24 0c	 mov	 eax, DWORD PTR _dwPetId$[esp+4]
  0005e	89 02		 mov	 DWORD PTR [edx], eax
  00060	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00063	83 c0 04	 add	 eax, 4
  00066	57		 push	 edi
  00067	8b ce		 mov	 ecx, esi
  00069	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0006c	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00071	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00074	66 8b 54 24 10	 mov	 dx, WORD PTR _wLife$[esp+4]
  00079	66 89 11	 mov	 WORD PTR [ecx], dx
  0007c	01 7e 08	 add	 DWORD PTR [esi+8], edi
  0007f	57		 push	 edi
  00080	8b ce		 mov	 ecx, esi
  00082	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00087	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0008a	66 8b 4c 24 14	 mov	 cx, WORD PTR _wEnergy$[esp+4]
  0008f	66 89 08	 mov	 WORD PTR [eax], cx
  00092	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00095	03 d7		 add	 edx, edi
  00097	6a 04		 push	 4
  00099	8b ce		 mov	 ecx, esi
  0009b	89 56 08	 mov	 DWORD PTR [esi+8], edx
  0009e	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000a3	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  000a6	8b 44 24 18	 mov	 eax, DWORD PTR _dwExp$[esp+4]
  000aa	89 02		 mov	 DWORD PTR [edx], eax
  000ac	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000af	83 c0 04	 add	 eax, 4
  000b2	5f		 pop	 edi
  000b3	89 46 08	 mov	 DWORD PTR [esi+8], eax
  000b6	5e		 pop	 esi
$L299942:

; 3046 : }

  000b7	c2 10 00	 ret	 16			; 00000010H
?AddPetState@CUser@@QAEXKGGK@Z ENDP			; CUser::AddPetState
_TEXT	ENDS
PUBLIC	?AddPetSetExp@CUser@@QAEXK@Z			; CUser::AddPetSetExp
; Function compile flags: /Ogty
;	COMDAT ?AddPetSetExp@CUser@@QAEXK@Z
_TEXT	SEGMENT
_dwExp$ = 8						; size = 4
?AddPetSetExp@CUser@@QAEXK@Z PROC NEAR			; CUser::AddPetSetExp, COMDAT
; _this$ = ecx

; 3050 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	75 63		 jne	 SHORT $L299966

; 3051 : 	
; 3052 : 	m_Snapshot.cb++;

  00006	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  0000d	56		 push	 esi
  0000e	57		 push	 edi

; 3053 : 	m_Snapshot.ar << GETID( this );

  0000f	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  00015	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  0001b	6a 04		 push	 4
  0001d	8b ce		 mov	 ecx, esi
  0001f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00024	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00027	89 38		 mov	 DWORD PTR [eax], edi
  00029	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0002c	83 c0 04	 add	 eax, 4

; 3054 : 	m_Snapshot.ar << SNAPSHOTTYPE_PET_SET_EXP;

  0002f	6a 02		 push	 2
  00031	8b ce		 mov	 ecx, esi
  00033	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00036	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003b	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003e	66 c7 01 13 01	 mov	 WORD PTR [ecx], 275	; 00000113H
  00043	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00046	83 c2 02	 add	 edx, 2

; 3055 : 	m_Snapshot.ar << dwExp;

  00049	6a 04		 push	 4
  0004b	8b ce		 mov	 ecx, esi
  0004d	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00050	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00055	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00058	8b 44 24 0c	 mov	 eax, DWORD PTR _dwExp$[esp+4]
  0005c	89 02		 mov	 DWORD PTR [edx], eax
  0005e	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00061	83 c0 04	 add	 eax, 4
  00064	5f		 pop	 edi
  00065	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00068	5e		 pop	 esi
$L299966:

; 3056 : }

  00069	c2 04 00	 ret	 4
?AddPetSetExp@CUser@@QAEXK@Z ENDP			; CUser::AddPetSetExp
_TEXT	ENDS
PUBLIC	?AddPet@CUser@@QAEXPAVCPet@@E@Z			; CUser::AddPet
EXTRN	?Serialize@CPet@@QAEXAAVCAr@@@Z:NEAR		; CPet::Serialize
; Function compile flags: /Ogty
;	COMDAT ?AddPet@CUser@@QAEXPAVCPet@@E@Z
_TEXT	SEGMENT
_pPet$ = 8						; size = 4
_nPetLevelup$ = 12					; size = 1
?AddPet@CUser@@QAEXPAVCPet@@E@Z PROC NEAR		; CUser::AddPet, COMDAT
; _this$ = ecx

; 3060 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	75 66		 jne	 SHORT $L299991

; 3061 : 	
; 3062 : 	m_Snapshot.cb++;

  00006	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  0000d	56		 push	 esi
  0000e	57		 push	 edi

; 3063 : 	m_Snapshot.ar << GETID( this );

  0000f	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  00015	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  0001b	6a 04		 push	 4
  0001d	8b ce		 mov	 ecx, esi
  0001f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00024	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00027	89 38		 mov	 DWORD PTR [eax], edi
  00029	83 46 08 04	 add	 DWORD PTR [esi+8], 4

; 3064 : 	m_Snapshot.ar << SNAPSHOTTYPE_PET;

  0002d	6a 02		 push	 2
  0002f	8b ce		 mov	 ecx, esi
  00031	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00036	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00039	66 c7 01 14 01	 mov	 WORD PTR [ecx], 276	; 00000114H
  0003e	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]

; 3065 : 	pPet->Serialize( m_Snapshot.ar );

  00041	8b 4c 24 0c	 mov	 ecx, DWORD PTR _pPet$[esp+4]
  00045	83 c7 02	 add	 edi, 2
  00048	56		 push	 esi
  00049	89 7e 08	 mov	 DWORD PTR [esi+8], edi
  0004c	e8 00 00 00 00	 call	 ?Serialize@CPet@@QAEXAAVCAr@@@Z ; CPet::Serialize

; 3066 : 	m_Snapshot.ar << nPetLevelup;

  00051	6a 01		 push	 1
  00053	8b ce		 mov	 ecx, esi
  00055	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0005a	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0005d	8a 44 24 10	 mov	 al, BYTE PTR _nPetLevelup$[esp+4]
  00061	88 02		 mov	 BYTE PTR [edx], al
  00063	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00066	40		 inc	 eax
  00067	5f		 pop	 edi
  00068	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0006b	5e		 pop	 esi
$L299991:

; 3067 : }

  0006c	c2 08 00	 ret	 8
?AddPet@CUser@@QAEXPAVCPet@@E@Z ENDP			; CUser::AddPet
_TEXT	ENDS
PUBLIC	?AddRestartCollecting@CUser@@QAEXK@Z		; CUser::AddRestartCollecting
; Function compile flags: /Ogty
;	COMDAT ?AddRestartCollecting@CUser@@QAEXK@Z
_TEXT	SEGMENT
_dwItemId$ = 8						; size = 4
?AddRestartCollecting@CUser@@QAEXK@Z PROC NEAR		; CUser::AddRestartCollecting, COMDAT
; _this$ = ecx

; 3156 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	75 63		 jne	 SHORT $L300016

; 3157 : 	
; 3158 : 	m_Snapshot.cb++;

  00006	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  0000d	56		 push	 esi
  0000e	57		 push	 edi

; 3159 : 	m_Snapshot.ar << GETID( this );

  0000f	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  00015	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  0001b	6a 04		 push	 4
  0001d	8b ce		 mov	 ecx, esi
  0001f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00024	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00027	89 38		 mov	 DWORD PTR [eax], edi
  00029	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0002c	83 c0 04	 add	 eax, 4

; 3160 : 	m_Snapshot.ar << SNAPSHOTTYPE_RESTART_COLLECTING;

  0002f	6a 02		 push	 2
  00031	8b ce		 mov	 ecx, esi
  00033	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00036	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003b	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003e	66 c7 01 43 01	 mov	 WORD PTR [ecx], 323	; 00000143H
  00043	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00046	83 c2 02	 add	 edx, 2

; 3161 : 	m_Snapshot.ar << dwItemId;

  00049	6a 04		 push	 4
  0004b	8b ce		 mov	 ecx, esi
  0004d	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00050	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00055	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00058	8b 44 24 0c	 mov	 eax, DWORD PTR _dwItemId$[esp+4]
  0005c	89 02		 mov	 DWORD PTR [edx], eax
  0005e	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00061	83 c0 04	 add	 eax, 4
  00064	5f		 pop	 edi
  00065	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00068	5e		 pop	 esi
$L300016:

; 3162 : }

  00069	c2 04 00	 ret	 4
?AddRestartCollecting@CUser@@QAEXK@Z ENDP		; CUser::AddRestartCollecting
_TEXT	ENDS
PUBLIC	?DoUseItemBattery@CUser@@QAEHXZ			; CUser::DoUseItemBattery
EXTRN	?GetInstance@CCollectingProperty@@SAPAV1@XZ:NEAR ; CCollectingProperty::GetInstance
EXTRN	?GetCollector@CMover@@QAEPAVCItemElem@@XZ:NEAR	; CMover::GetCollector
EXTRN	?UpdateItem@CMover@@QAEXEDKK@Z:NEAR		; CMover::UpdateItem
; Function compile flags: /Ogty
;	COMDAT ?DoUseItemBattery@CUser@@QAEHXZ
_TEXT	SEGMENT
?DoUseItemBattery@CUser@@QAEHXZ PROC NEAR		; CUser::DoUseItemBattery, COMDAT
; _this$ = ecx

; 3211 : {

  00000	56		 push	 esi
  00001	57		 push	 edi
  00002	8b f1		 mov	 esi, ecx

; 3212 : 	CItemElem* pCol		= GetCollector();

  00004	e8 00 00 00 00	 call	 ?GetCollector@CMover@@QAEPAVCItemElem@@XZ ; CMover::GetCollector
  00009	8b f8		 mov	 edi, eax

; 3213 : 	if( pCol == NULL || m_pActMover->GetActionState() == OBJSTA_COLLECT )

  0000b	85 ff		 test	 edi, edi
  0000d	74 39		 je	 SHORT $L279695
  0000f	8b 86 3c 02 00
	00		 mov	 eax, DWORD PTR [esi+572]
  00015	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00018	81 e1 00 00 00
	f0		 and	 ecx, -268435456		; f0000000H
  0001e	81 f9 00 00 00
	10		 cmp	 ecx, 268435456		; 10000000H
  00024	74 22		 je	 SHORT $L279695

; 3215 : 	UpdateItem( (BYTE)( pCol->m_dwObjId ), UI_HP, CCollectingProperty::GetInstance()->GetMaxBattery() );

  00026	e8 00 00 00 00	 call	 ?GetInstance@CCollectingProperty@@SAPAV1@XZ ; CCollectingProperty::GetInstance
  0002b	8b 50 34	 mov	 edx, DWORD PTR [eax+52]
  0002e	33 c0		 xor	 eax, eax
  00030	8a 47 04	 mov	 al, BYTE PTR [edi+4]
  00033	6a 00		 push	 0
  00035	52		 push	 edx
  00036	6a 01		 push	 1
  00038	8b ce		 mov	 ecx, esi
  0003a	50		 push	 eax
  0003b	e8 00 00 00 00	 call	 ?UpdateItem@CMover@@QAEXEDKK@Z ; CMover::UpdateItem
  00040	5f		 pop	 edi

; 3216 : 
; 3217 : 	return TRUE;

  00041	b8 01 00 00 00	 mov	 eax, 1
  00046	5e		 pop	 esi

; 3218 : }

  00047	c3		 ret	 0
$L279695:
  00048	5f		 pop	 edi

; 3214 : 		return FALSE;

  00049	33 c0		 xor	 eax, eax
  0004b	5e		 pop	 esi

; 3218 : }

  0004c	c3		 ret	 0
?DoUseItemBattery@CUser@@QAEHXZ ENDP			; CUser::DoUseItemBattery
_TEXT	ENDS
PUBLIC	?FindActiveTicket@CUser@@AAEPAVCItemElem@@K@Z	; CUser::FindActiveTicket
EXTRN	?IsActiveTicket@CItemElem@@QAEHK@Z:NEAR		; CItemElem::IsActiveTicket
EXTRN	?GetPocket@CPocketController@@QAEPAVCPocket@@H@Z:NEAR ; CPocketController::GetPocket
; Function compile flags: /Ogty
;	COMDAT ?FindActiveTicket@CUser@@AAEPAVCItemElem@@K@Z
_TEXT	SEGMENT
tv324 = -12						; size = 4
_i$279701 = -8						; size = 4
_this$ = -4						; size = 4
_dwItemId$ = 8						; size = 4
?FindActiveTicket@CUser@@AAEPAVCItemElem@@K@Z PROC NEAR	; CUser::FindActiveTicket, COMDAT
; _this$ = ecx

; 3380 : {

  00000	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00003	53		 push	 ebx
  00004	55		 push	 ebp
  00005	8b e9		 mov	 ebp, ecx

; 3381 : 	for( int i = 0; i < m_Inventory.GetMax(); i++ )

  00007	8b 85 9c 0b 00
	00		 mov	 eax, DWORD PTR [ebp+2972]
  0000d	56		 push	 esi
  0000e	57		 push	 edi
  0000f	33 ff		 xor	 edi, edi
  00011	85 c0		 test	 eax, eax
  00013	89 6c 24 18	 mov	 DWORD PTR _this$[esp+28], ebp
  00017	7e 3b		 jle	 SHORT $L279704
  00019	33 db		 xor	 ebx, ebx

; 3382 : 	{
; 3383 : 		CItemElem* pItem	= m_Inventory.GetAtId( i );

  0001b	3b f8		 cmp	 edi, eax
$L300105:
  0001d	73 24		 jae	 SHORT $L279703
  0001f	8b b5 a0 0b 00
	00		 mov	 esi, DWORD PTR [ebp+2976]
  00025	8b 44 1e 0c	 mov	 eax, DWORD PTR [esi+ebx+12]
  00029	03 f3		 add	 esi, ebx
  0002b	85 c0		 test	 eax, eax
  0002d	74 14		 je	 SHORT $L279703

; 3384 : 		if( pItem && pItem->IsActiveTicket( dwItemId ) )

  0002f	8b 44 24 20	 mov	 eax, DWORD PTR _dwItemId$[esp+24]
  00033	50		 push	 eax
  00034	8b ce		 mov	 ecx, esi
  00036	e8 00 00 00 00	 call	 ?IsActiveTicket@CItemElem@@QAEHK@Z ; CItemElem::IsActiveTicket
  0003b	85 c0		 test	 eax, eax
  0003d	0f 85 9b 00 00
	00		 jne	 $L300096
$L279703:

; 3381 : 	for( int i = 0; i < m_Inventory.GetMax(); i++ )

  00043	8b 85 9c 0b 00
	00		 mov	 eax, DWORD PTR [ebp+2972]
  00049	47		 inc	 edi
  0004a	81 c3 b8 00 00
	00		 add	 ebx, 184		; 000000b8H
  00050	3b f8		 cmp	 edi, eax
  00052	7c c9		 jl	 SHORT $L300105
$L279704:

; 3385 : 			return pItem;
; 3386 : 	}
; 3387 : 	for( i = 0; i < MAX_POCKET; i++ )

  00054	33 f6		 xor	 esi, esi
  00056	8d 8d fc 0b 00
	00		 lea	 ecx, DWORD PTR [ebp+3068]
  0005c	89 74 24 14	 mov	 DWORD PTR _i$279701[esp+28], esi
  00060	89 4c 24 10	 mov	 DWORD PTR tv324[esp+28], ecx
$L300104:

; 3388 : 	{
; 3389 : 		if( !m_Pocket.IsAvailable( i, FALSE ) )

  00064	8b 54 24 10	 mov	 edx, DWORD PTR tv324[esp+28]
  00068	83 3a 00	 cmp	 DWORD PTR [edx], 0
  0006b	74 50		 je	 SHORT $L279708

; 3390 : 			continue;
; 3391 : 		CPocket* pPocket	= m_Pocket.GetPocket( i );

  0006d	56		 push	 esi
  0006e	8d 8d f4 0b 00
	00		 lea	 ecx, DWORD PTR [ebp+3060]
  00074	e8 00 00 00 00	 call	 ?GetPocket@CPocketController@@QAEPAVCPocket@@H@Z ; CPocketController::GetPocket
  00079	8b f8		 mov	 edi, eax

; 3392 : 		for( int j = 0; j < pPocket->GetMax(); j++ )

  0007b	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  0007e	33 db		 xor	 ebx, ebx
  00080	85 c0		 test	 eax, eax
  00082	7e 39		 jle	 SHORT $L279708
  00084	33 ed		 xor	 ebp, ebp

; 3393 : 		{
; 3394 : 			CItemElem* pItem	= pPocket->GetAtId( j );

  00086	3b d8		 cmp	 ebx, eax
$L300106:
  00088	73 1d		 jae	 SHORT $L279714
  0008a	8b 77 10	 mov	 esi, DWORD PTR [edi+16]
  0008d	8b 44 2e 0c	 mov	 eax, DWORD PTR [esi+ebp+12]
  00091	03 f5		 add	 esi, ebp
  00093	85 c0		 test	 eax, eax
  00095	74 10		 je	 SHORT $L279714

; 3395 : 			if( pItem && pItem->IsActiveTicket( dwItemId ) )

  00097	8b 44 24 20	 mov	 eax, DWORD PTR _dwItemId$[esp+24]
  0009b	50		 push	 eax
  0009c	8b ce		 mov	 ecx, esi
  0009e	e8 00 00 00 00	 call	 ?IsActiveTicket@CItemElem@@QAEHK@Z ; CItemElem::IsActiveTicket
  000a3	85 c0		 test	 eax, eax
  000a5	75 37		 jne	 SHORT $L300096
$L279714:

; 3392 : 		for( int j = 0; j < pPocket->GetMax(); j++ )

  000a7	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  000aa	43		 inc	 ebx
  000ab	81 c5 b8 00 00
	00		 add	 ebp, 184		; 000000b8H
  000b1	3b d8		 cmp	 ebx, eax
  000b3	7c d3		 jl	 SHORT $L300106
  000b5	8b 6c 24 18	 mov	 ebp, DWORD PTR _this$[esp+28]
  000b9	8b 74 24 14	 mov	 esi, DWORD PTR _i$279701[esp+28]
$L279708:
  000bd	8b 4c 24 10	 mov	 ecx, DWORD PTR tv324[esp+28]
  000c1	46		 inc	 esi
  000c2	83 c1 04	 add	 ecx, 4
  000c5	83 fe 03	 cmp	 esi, 3
  000c8	89 74 24 14	 mov	 DWORD PTR _i$279701[esp+28], esi
  000cc	89 4c 24 10	 mov	 DWORD PTR tv324[esp+28], ecx
  000d0	7c 92		 jl	 SHORT $L300104
  000d2	5f		 pop	 edi
  000d3	5e		 pop	 esi
  000d4	5d		 pop	 ebp

; 3397 : 		}
; 3398 : 	}
; 3399 : 	return NULL;

  000d5	33 c0		 xor	 eax, eax
  000d7	5b		 pop	 ebx

; 3400 : }

  000d8	83 c4 0c	 add	 esp, 12			; 0000000cH
  000db	c2 04 00	 ret	 4
$L300096:
  000de	5f		 pop	 edi

; 3396 : 				return pItem;

  000df	8b c6		 mov	 eax, esi
  000e1	5e		 pop	 esi
  000e2	5d		 pop	 ebp
  000e3	5b		 pop	 ebx

; 3400 : }

  000e4	83 c4 0c	 add	 esp, 12			; 0000000cH
  000e7	c2 04 00	 ret	 4
?FindActiveTicket@CUser@@AAEPAVCItemElem@@K@Z ENDP	; CUser::FindActiveTicket
_TEXT	ENDS
PUBLIC	?AdjustGuildQuest@CUser@@QAEXK@Z		; CUser::AdjustGuildQuest
EXTRN	?SetPos@CObj@@QAEXABUD3DXVECTOR3@@@Z:NEAR	; CObj::SetPos
EXTRN	?g_WorldMng@@3VCWorldMng@@A:BYTE		; g_WorldMng
EXTRN	?GetWorld@CWorldMng@@QAEPAVCWorld@@K@Z:NEAR	; CWorldMng::GetWorld
EXTRN	?GetRevivalPosChao@CWorldMng@@QAEPAUREGIONELEM@@KPBD@Z:NEAR ; CWorldMng::GetRevivalPosChao
EXTRN	?GetNearRevivalPosChao@CWorldMng@@QAEPAUREGIONELEM@@KAAUD3DXVECTOR3@@@Z:NEAR ; CWorldMng::GetNearRevivalPosChao
EXTRN	?GetRevivalPos@CWorldMng@@QAEPAUREGIONELEM@@KPBD@Z:NEAR ; CWorldMng::GetRevivalPos
EXTRN	?GetNearRevivalPos@CWorldMng@@QAEPAUREGIONELEM@@KAAUD3DXVECTOR3@@@Z:NEAR ; CWorldMng::GetNearRevivalPos
EXTRN	?GetGuildQuest@CGuildQuestProcessor@@QAEPAU_GUILDQUESTELEM@@H@Z:NEAR ; CGuildQuestProcessor::GetGuildQuest
EXTRN	?GetInstance@CGuildQuestProcessor@@SAPAV1@XZ:NEAR ; CGuildQuestProcessor::GetInstance
EXTRN	?PtInQuestRect@CGuildQuestProcessor@@QAEHABUD3DXVECTOR3@@@Z:NEAR ; CGuildQuestProcessor::PtInQuestRect
; Function compile flags: /Ogty
;	COMDAT ?AdjustGuildQuest@CUser@@QAEXK@Z
_TEXT	SEGMENT
$T300112 = -12						; size = 12
$T300111 = -12						; size = 12
$T300110 = -12						; size = 12
_dwWorldId$ = 8						; size = 4
?AdjustGuildQuest@CUser@@QAEXK@Z PROC NEAR		; CUser::AdjustGuildQuest, COMDAT
; _this$ = ecx

; 3686 : {

  00000	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	8b d9		 mov	 ebx, ecx

; 3687 : 	CGuildQuestProcessor* pProcessor	= CGuildQuestProcessor::GetInstance();

  00007	e8 00 00 00 00	 call	 ?GetInstance@CGuildQuestProcessor@@SAPAV1@XZ ; CGuildQuestProcessor::GetInstance
  0000c	8b f0		 mov	 esi, eax

; 3688 : 	int nId = -1;
; 3689 : 	if( dwWorldId == WI_WORLD_MADRIGAL )

  0000e	83 7c 24 18 01	 cmp	 DWORD PTR _dwWorldId$[esp+16], 1
  00013	0f 85 0f 01 00
	00		 jne	 $L279908
  00019	57		 push	 edi

; 3690 : 		nId = pProcessor->PtInQuestRect( GetPos() );

  0001a	8d bb 60 01 00
	00		 lea	 edi, DWORD PTR [ebx+352]
  00020	8b c7		 mov	 eax, edi
  00022	8b 08		 mov	 ecx, DWORD PTR [eax]
  00024	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00027	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0002a	89 4c 24 0c	 mov	 DWORD PTR $T300110[esp+24], ecx
  0002e	8d 4c 24 0c	 lea	 ecx, DWORD PTR $T300110[esp+24]
  00032	51		 push	 ecx
  00033	8b ce		 mov	 ecx, esi
  00035	89 54 24 14	 mov	 DWORD PTR $T300110[esp+32], edx
  00039	89 44 24 18	 mov	 DWORD PTR $T300110[esp+36], eax
  0003d	e8 00 00 00 00	 call	 ?PtInQuestRect@CGuildQuestProcessor@@QAEHABUD3DXVECTOR3@@@Z ; CGuildQuestProcessor::PtInQuestRect

; 3691 : 
; 3692 : 	if( nId > -1 )

  00042	83 f8 ff	 cmp	 eax, -1
  00045	0f 8e dc 00 00
	00		 jle	 $L300144

; 3693 : 	{
; 3694 : 		PGUILDQUESTELEM pElem	= pProcessor->GetGuildQuest( nId );

  0004b	50		 push	 eax
  0004c	8b ce		 mov	 ecx, esi
  0004e	e8 00 00 00 00	 call	 ?GetGuildQuest@CGuildQuestProcessor@@QAEPAU_GUILDQUESTELEM@@H@Z ; CGuildQuestProcessor::GetGuildQuest

; 3695 : 		if( !pElem || pElem->idGuild != m_idGuild )

  00053	85 c0		 test	 eax, eax
  00055	74 0f		 je	 SHORT $L279896
  00057	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0005a	3b 93 1c 07 00
	00		 cmp	 edx, DWORD PTR [ebx+1820]
  00060	0f 84 c1 00 00
	00		 je	 $L300144
$L279896:

; 3696 : 		{
; 3697 : 			CWorld* pWorld	= g_WorldMng.GetWorld( dwWorldId );

  00066	6a 01		 push	 1
  00068	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_WorldMng@@3VCWorldMng@@A
  0006d	e8 00 00 00 00	 call	 ?GetWorld@CWorldMng@@QAEPAVCWorld@@K@Z ; CWorldMng::GetWorld
  00072	8b f0		 mov	 esi, eax

; 3698 : 			if( pWorld )

  00074	85 f6		 test	 esi, esi
  00076	0f 84 ab 00 00
	00		 je	 $L300144

; 3699 : 			{
; 3700 : 				PRegionElem pRgnElem	= NULL;
; 3701 : 				if( IsChaotic() )

  0007c	8b 83 60 07 00
	00		 mov	 eax, DWORD PTR [ebx+1888]

; 3702 : 				{
; 3703 : 					if( pWorld->GetID() != pWorld->m_dwIdWorldRevival && pWorld->m_dwIdWorldRevival != 0 )

  00082	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00084	85 c0		 test	 eax, eax
  00086	8b 86 18 93 08
	00		 mov	 eax, DWORD PTR [esi+561944]
  0008c	76 46		 jbe	 SHORT $L279900
  0008e	3b c8		 cmp	 ecx, eax
  00090	74 1a		 je	 SHORT $L300142
  00092	85 c0		 test	 eax, eax
  00094	74 16		 je	 SHORT $L300142

; 3704 : 						pRgnElem	= g_WorldMng.GetRevivalPosChao( pWorld->m_dwIdWorldRevival, pWorld->m_szKeyRevival );

  00096	8d 8e f8 92 08
	00		 lea	 ecx, DWORD PTR [esi+561912]
  0009c	51		 push	 ecx
  0009d	50		 push	 eax
  0009e	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_WorldMng@@3VCWorldMng@@A
  000a3	e8 00 00 00 00	 call	 ?GetRevivalPosChao@CWorldMng@@QAEPAUREGIONELEM@@KPBD@Z ; CWorldMng::GetRevivalPosChao

; 3705 : 					if( !pRgnElem )	// Find near revival pos

  000a8	85 c0		 test	 eax, eax
  000aa	75 70		 jne	 SHORT $L300141
$L300142:

; 3706 : 						pRgnElem	= g_WorldMng.GetNearRevivalPosChao( pWorld->GetID(), GetPos() );

  000ac	8b 17		 mov	 edx, DWORD PTR [edi]
  000ae	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  000b1	8b 36		 mov	 esi, DWORD PTR [esi]
  000b3	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  000b6	89 54 24 0c	 mov	 DWORD PTR $T300111[esp+24], edx
  000ba	8d 54 24 0c	 lea	 edx, DWORD PTR $T300111[esp+24]
  000be	52		 push	 edx
  000bf	89 4c 24 18	 mov	 DWORD PTR $T300111[esp+36], ecx
  000c3	56		 push	 esi
  000c4	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_WorldMng@@3VCWorldMng@@A
  000c9	89 44 24 18	 mov	 DWORD PTR $T300111[esp+36], eax
  000cd	e8 00 00 00 00	 call	 ?GetNearRevivalPosChao@CWorldMng@@QAEPAUREGIONELEM@@KAAUD3DXVECTOR3@@@Z ; CWorldMng::GetNearRevivalPosChao

; 3707 : 				}
; 3708 : 				else

  000d2	eb 44		 jmp	 SHORT $L279906
$L279900:

; 3709 : 				{
; 3710 : 					if( pWorld->GetID() != pWorld->m_dwIdWorldRevival && pWorld->m_dwIdWorldRevival != 0 )

  000d4	3b c8		 cmp	 ecx, eax
  000d6	74 1a		 je	 SHORT $L300143
  000d8	85 c0		 test	 eax, eax
  000da	74 16		 je	 SHORT $L300143

; 3711 : 						pRgnElem	= g_WorldMng.GetRevivalPos( pWorld->m_dwIdWorldRevival, pWorld->m_szKeyRevival );

  000dc	8d 8e f8 92 08
	00		 lea	 ecx, DWORD PTR [esi+561912]
  000e2	51		 push	 ecx
  000e3	50		 push	 eax
  000e4	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_WorldMng@@3VCWorldMng@@A
  000e9	e8 00 00 00 00	 call	 ?GetRevivalPos@CWorldMng@@QAEPAUREGIONELEM@@KPBD@Z ; CWorldMng::GetRevivalPos

; 3712 : 					if( !pRgnElem )	// Find near revival pos

  000ee	85 c0		 test	 eax, eax
  000f0	75 2a		 jne	 SHORT $L300141
$L300143:

; 3713 : 						pRgnElem	= g_WorldMng.GetNearRevivalPos( pWorld->GetID(), GetPos() );

  000f2	8b 17		 mov	 edx, DWORD PTR [edi]
  000f4	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  000f7	8b 36		 mov	 esi, DWORD PTR [esi]
  000f9	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  000fc	89 54 24 0c	 mov	 DWORD PTR $T300112[esp+24], edx
  00100	8d 54 24 0c	 lea	 edx, DWORD PTR $T300112[esp+24]
  00104	52		 push	 edx
  00105	89 4c 24 18	 mov	 DWORD PTR $T300112[esp+36], ecx
  00109	56		 push	 esi
  0010a	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_WorldMng@@3VCWorldMng@@A
  0010f	89 44 24 18	 mov	 DWORD PTR $T300112[esp+36], eax
  00113	e8 00 00 00 00	 call	 ?GetNearRevivalPos@CWorldMng@@QAEPAUREGIONELEM@@KAAUD3DXVECTOR3@@@Z ; CWorldMng::GetNearRevivalPos
$L279906:

; 3714 : 				}
; 3715 : 				if( pRgnElem )

  00118	85 c0		 test	 eax, eax
  0011a	74 0b		 je	 SHORT $L300144
$L300141:

; 3716 : 					SetPos( pRgnElem->m_vPos );

  0011c	83 c0 10	 add	 eax, 16			; 00000010H
  0011f	50		 push	 eax
  00120	8b cb		 mov	 ecx, ebx
  00122	e8 00 00 00 00	 call	 ?SetPos@CObj@@QAEXABUD3DXVECTOR3@@@Z ; CObj::SetPos
$L300144:
  00127	5f		 pop	 edi
$L279908:
  00128	5e		 pop	 esi
  00129	5b		 pop	 ebx

; 3717 : 			}
; 3718 : 		}
; 3719 : 	}
; 3720 : }

  0012a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0012d	c2 04 00	 ret	 4
?AdjustGuildQuest@CUser@@QAEXK@Z ENDP			; CUser::AdjustGuildQuest
_TEXT	ENDS
PUBLIC	?AdjustMailboxState@CUser@@QAEXXZ		; CUser::AdjustMailboxState
EXTRN	?GetMailBox@CPost@@QAEPAVCMailBox@@K@Z:NEAR	; CPost::GetMailBox
EXTRN	?GetInstance@CPost@@SAPAV1@XZ:NEAR		; CPost::GetInstance
EXTRN	?IsStampedMailExists@CMailBox@@QAEHXZ:NEAR	; CMailBox::IsStampedMailExists
; Function compile flags: /Ogty
;	COMDAT ?AdjustMailboxState@CUser@@QAEXXZ
_TEXT	SEGMENT
?AdjustMailboxState@CUser@@QAEXXZ PROC NEAR		; CUser::AdjustMailboxState, COMDAT
; _this$ = ecx

; 3723 : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 3724 : 	CMailBox* pMailBox	= CPost::GetInstance()->GetMailBox( m_idPlayer );

  00003	8b 86 38 02 00
	00		 mov	 eax, DWORD PTR [esi+568]
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ?GetInstance@CPost@@SAPAV1@XZ ; CPost::GetInstance
  0000f	8b c8		 mov	 ecx, eax
  00011	e8 00 00 00 00	 call	 ?GetMailBox@CPost@@QAEPAVCMailBox@@K@Z ; CPost::GetMailBox

; 3725 : 	if( pMailBox && pMailBox->IsStampedMailExists() )

  00016	85 c0		 test	 eax, eax
  00018	74 17		 je	 SHORT $L279914
  0001a	8b c8		 mov	 ecx, eax
  0001c	e8 00 00 00 00	 call	 ?IsStampedMailExists@CMailBox@@QAEHXZ ; CMailBox::IsStampedMailExists
  00021	85 c0		 test	 eax, eax
  00023	74 0c		 je	 SHORT $L279914

; 3726 : 		SetMode( MODE_MAILBOX );

  00025	81 8e 44 02 00
	00 00 80 00 00	 or	 DWORD PTR [esi+580], 32768 ; 00008000H

; 3727 : 	else
; 3728 : 		SetNotMode( MODE_MAILBOX );

  0002f	5e		 pop	 esi

; 3729 : }

  00030	c3		 ret	 0
$L279914:

; 3727 : 	else
; 3728 : 		SetNotMode( MODE_MAILBOX );

  00031	81 a6 44 02 00
	00 ff 7f ff ff	 and	 DWORD PTR [esi+580], -32769 ; ffff7fffH
  0003b	5e		 pop	 esi

; 3729 : }

  0003c	c3		 ret	 0
?AdjustMailboxState@CUser@@QAEXXZ ENDP			; CUser::AdjustMailboxState
_TEXT	ENDS
PUBLIC	?AddCouple@CUser@@QAEXXZ			; CUser::AddCouple
EXTRN	?Instance@CCoupleHelper@@SAPAV1@XZ:NEAR		; CCoupleHelper::Instance
EXTRN	?Serialize@CCouple@@QAEXAAVCAr@@@Z:NEAR		; CCouple::Serialize
; Function compile flags: /Ogty
;	COMDAT ?AddCouple@CUser@@QAEXXZ
_TEXT	SEGMENT
?AddCouple@CUser@@QAEXXZ PROC NEAR			; CUser::AddCouple, COMDAT
; _this$ = ecx

; 3759 : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 3760 : 	if( IsDelete() )	return;

  00003	f6 46 04 01	 test	 BYTE PTR [esi+4], 1
  00007	75 65		 jne	 SHORT $L279952
  00009	57		 push	 edi

; 3761 : 	CCouple* pCouple	= CCoupleHelper::Instance()->GetCouple( m_idPlayer );

  0000a	8b be 38 02 00
	00		 mov	 edi, DWORD PTR [esi+568]
  00010	e8 00 00 00 00	 call	 ?Instance@CCoupleHelper@@SAPAV1@XZ ; CCoupleHelper::Instance
  00015	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00018	57		 push	 edi
  00019	e8 00 00 00 00	 call	 ?GetCouple@CCoupleMgr@@QAEPAVCCouple@@K@Z ; CCoupleMgr::GetCouple
  0001e	8b f8		 mov	 edi, eax

; 3762 : 	if( pCouple )

  00020	85 ff		 test	 edi, edi
  00022	74 49		 je	 SHORT $L300178

; 3763 : 	{
; 3764 : 		m_Snapshot.cb++;

  00024	66 ff 86 0c 57
	00 00		 inc	 WORD PTR [esi+22284]
  0002b	53		 push	 ebx

; 3765 : 		m_Snapshot.ar << GetId();

  0002c	8b 9e bc 01 00
	00		 mov	 ebx, DWORD PTR [esi+444]
  00032	81 c6 f8 16 00
	00		 add	 esi, 5880		; 000016f8H
  00038	6a 04		 push	 4
  0003a	8b ce		 mov	 ecx, esi
  0003c	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00041	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00044	89 18		 mov	 DWORD PTR [eax], ebx
  00046	8b 5e 08	 mov	 ebx, DWORD PTR [esi+8]
  00049	83 c3 04	 add	 ebx, 4

; 3766 : 		m_Snapshot.ar << SNAPSHOTTYPE_COUPLE;

  0004c	6a 02		 push	 2
  0004e	8b ce		 mov	 ecx, esi
  00050	89 5e 08	 mov	 DWORD PTR [esi+8], ebx
  00053	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00058	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0005b	66 c7 01 00 97	 mov	 WORD PTR [ecx], 38656	; 00009700H
  00060	83 46 08 02	 add	 DWORD PTR [esi+8], 2

; 3767 : 		pCouple->Serialize( m_Snapshot.ar );

  00064	56		 push	 esi
  00065	8b cf		 mov	 ecx, edi
  00067	e8 00 00 00 00	 call	 ?Serialize@CCouple@@QAEXAAVCAr@@@Z ; CCouple::Serialize
  0006c	5b		 pop	 ebx
$L300178:
  0006d	5f		 pop	 edi
$L279952:
  0006e	5e		 pop	 esi

; 3768 : 	}
; 3769 : }

  0006f	c3		 ret	 0
?AddCouple@CUser@@QAEXXZ ENDP				; CUser::AddCouple
_TEXT	ENDS
PUBLIC	?AddProposeResult@CUser@@QAEXKPBD@Z		; CUser::AddProposeResult
; Function compile flags: /Ogty
;	COMDAT ?AddProposeResult@CUser@@QAEXKPBD@Z
_TEXT	SEGMENT
_idProposer$ = 8					; size = 4
_pszProposer$ = 12					; size = 4
?AddProposeResult@CUser@@QAEXKPBD@Z PROC NEAR		; CUser::AddProposeResult, COMDAT
; _this$ = ecx

; 3773 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	75 65		 jne	 SHORT $L279958

; 3774 : 	m_Snapshot.cb++;

  00006	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  0000d	56		 push	 esi
  0000e	57		 push	 edi

; 3775 : 	m_Snapshot.ar << GetId();

  0000f	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  00015	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  0001b	6a 04		 push	 4
  0001d	8b ce		 mov	 ecx, esi
  0001f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00024	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00027	89 38		 mov	 DWORD PTR [eax], edi
  00029	83 46 08 04	 add	 DWORD PTR [esi+8], 4

; 3776 : 	m_Snapshot.ar << SNAPSHOTTYPE_PROPOSE_RESULT;

  0002d	6a 02		 push	 2
  0002f	8b ce		 mov	 ecx, esi
  00031	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00036	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00039	66 c7 01 01 97	 mov	 WORD PTR [ecx], 38657	; 00009701H
  0003e	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  00041	83 c7 02	 add	 edi, 2

; 3777 : 	m_Snapshot.ar << idProposer;

  00044	6a 04		 push	 4
  00046	8b ce		 mov	 ecx, esi
  00048	89 7e 08	 mov	 DWORD PTR [esi+8], edi
  0004b	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00050	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00053	8b 44 24 0c	 mov	 eax, DWORD PTR _idProposer$[esp+4]
  00057	89 02		 mov	 DWORD PTR [edx], eax
  00059	83 46 08 04	 add	 DWORD PTR [esi+8], 4

; 3778 : 	m_Snapshot.ar.WriteString( pszProposer );

  0005d	8b 4c 24 10	 mov	 ecx, DWORD PTR _pszProposer$[esp+4]
  00061	51		 push	 ecx
  00062	8b ce		 mov	 ecx, esi
  00064	e8 00 00 00 00	 call	 ?WriteString@CAr@@QAEXPBD@Z ; CAr::WriteString
  00069	5f		 pop	 edi
  0006a	5e		 pop	 esi
$L279958:

; 3779 : }

  0006b	c2 08 00	 ret	 8
?AddProposeResult@CUser@@QAEXKPBD@Z ENDP		; CUser::AddProposeResult
_TEXT	ENDS
PUBLIC	?AddCoupleResult@CUser@@QAEXKPBD@Z		; CUser::AddCoupleResult
; Function compile flags: /Ogty
;	COMDAT ?AddCoupleResult@CUser@@QAEXKPBD@Z
_TEXT	SEGMENT
_idPartner$ = 8						; size = 4
_pszPartner$ = 12					; size = 4
?AddCoupleResult@CUser@@QAEXKPBD@Z PROC NEAR		; CUser::AddCoupleResult, COMDAT
; _this$ = ecx

; 3783 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	75 65		 jne	 SHORT $L279965

; 3784 : 	m_Snapshot.cb++;

  00006	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  0000d	56		 push	 esi
  0000e	57		 push	 edi

; 3785 : 	m_Snapshot.ar << GetId();

  0000f	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  00015	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  0001b	6a 04		 push	 4
  0001d	8b ce		 mov	 ecx, esi
  0001f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00024	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00027	89 38		 mov	 DWORD PTR [eax], edi
  00029	83 46 08 04	 add	 DWORD PTR [esi+8], 4

; 3786 : 	m_Snapshot.ar << SNAPSHOTTYPE_COUPLE_RESULT;

  0002d	6a 02		 push	 2
  0002f	8b ce		 mov	 ecx, esi
  00031	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00036	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00039	66 c7 01 03 97	 mov	 WORD PTR [ecx], 38659	; 00009703H
  0003e	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  00041	83 c7 02	 add	 edi, 2

; 3787 : 	m_Snapshot.ar << idPartner;

  00044	6a 04		 push	 4
  00046	8b ce		 mov	 ecx, esi
  00048	89 7e 08	 mov	 DWORD PTR [esi+8], edi
  0004b	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00050	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00053	8b 44 24 0c	 mov	 eax, DWORD PTR _idPartner$[esp+4]
  00057	89 02		 mov	 DWORD PTR [edx], eax
  00059	83 46 08 04	 add	 DWORD PTR [esi+8], 4

; 3788 : 	m_Snapshot.ar.WriteString( pszPartner );

  0005d	8b 4c 24 10	 mov	 ecx, DWORD PTR _pszPartner$[esp+4]
  00061	51		 push	 ecx
  00062	8b ce		 mov	 ecx, esi
  00064	e8 00 00 00 00	 call	 ?WriteString@CAr@@QAEXPBD@Z ; CAr::WriteString
  00069	5f		 pop	 edi
  0006a	5e		 pop	 esi
$L279965:

; 3789 : }

  0006b	c2 08 00	 ret	 8
?AddCoupleResult@CUser@@QAEXKPBD@Z ENDP			; CUser::AddCoupleResult
_TEXT	ENDS
PUBLIC	?AddDecoupleResult@CUser@@QAEXXZ		; CUser::AddDecoupleResult
; Function compile flags: /Ogty
;	COMDAT ?AddDecoupleResult@CUser@@QAEXXZ
_TEXT	SEGMENT
?AddDecoupleResult@CUser@@QAEXXZ PROC NEAR		; CUser::AddDecoupleResult, COMDAT
; _this$ = ecx

; 3793 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	75 48		 jne	 SHORT $L300239

; 3794 : 	m_Snapshot.cb++;

  00006	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  0000d	56		 push	 esi
  0000e	57		 push	 edi

; 3795 : 	m_Snapshot.ar << GetId();

  0000f	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  00015	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  0001b	6a 04		 push	 4
  0001d	8b ce		 mov	 ecx, esi
  0001f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00024	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00027	89 38		 mov	 DWORD PTR [eax], edi
  00029	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0002c	83 c2 04	 add	 edx, 4

; 3796 : 	m_Snapshot.ar << SNAPSHOTTYPE_DECOUPLE_RESULT;

  0002f	6a 02		 push	 2
  00031	8b ce		 mov	 ecx, esi
  00033	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00036	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003b	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003e	66 c7 01 04 97	 mov	 WORD PTR [ecx], 38660	; 00009704H
  00043	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00046	83 c0 02	 add	 eax, 2
  00049	5f		 pop	 edi
  0004a	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0004d	5e		 pop	 esi
$L300239:

; 3797 : }

  0004e	c3		 ret	 0
?AddDecoupleResult@CUser@@QAEXXZ ENDP			; CUser::AddDecoupleResult
_TEXT	ENDS
PUBLIC	?AddRunScriptFunc@CUser@@QAEXABU_runscriptfunc@@@Z ; CUser::AddRunScriptFunc
; Function compile flags: /Ogty
;	COMDAT ?AddRunScriptFunc@CUser@@QAEXABU_runscriptfunc@@@Z
_TEXT	SEGMENT
_runScriptFunc$ = 8					; size = 4
?AddRunScriptFunc@CUser@@QAEXABU_runscriptfunc@@@Z PROC NEAR ; CUser::AddRunScriptFunc, COMDAT
; _this$ = ecx

; 6303 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	53		 push	 ebx
  00005	56		 push	 esi
  00006	57		 push	 edi
  00007	0f 85 5e 01 00
	00		 jne	 $L283019

; 6304 : 	
; 6305 : 	m_Snapshot.cb++;

  0000d	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]

; 6306 : 	m_Snapshot.ar << GetId();

  00014	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  0001a	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  00020	6a 04		 push	 4
  00022	8b ce		 mov	 ecx, esi
  00024	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00029	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0002c	89 38		 mov	 DWORD PTR [eax], edi
  0002e	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  00031	83 c7 04	 add	 edi, 4

; 6307 : 	m_Snapshot.ar << SNAPSHOTTYPE_RUNSCRIPTFUNC;

  00034	6a 02		 push	 2
  00036	8b ce		 mov	 ecx, esi
  00038	89 7e 08	 mov	 DWORD PTR [esi+8], edi
  0003b	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00040	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]

; 6308 : 	m_Snapshot.ar << runScriptFunc.wFuncType;

  00043	8b 7c 24 10	 mov	 edi, DWORD PTR _runScriptFunc$[esp+8]
  00047	66 c7 01 24 00	 mov	 WORD PTR [ecx], 36	; 00000024H
  0004c	83 46 08 02	 add	 DWORD PTR [esi+8], 2
  00050	66 8b 9f 08 08
	00 00		 mov	 bx, WORD PTR [edi+2056]
  00057	6a 02		 push	 2
  00059	8b ce		 mov	 ecx, esi
  0005b	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00060	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00063	66 89 1a	 mov	 WORD PTR [edx], bx
  00066	83 46 08 02	 add	 DWORD PTR [esi+8], 2

; 6309 : 	switch( runScriptFunc.wFuncType )

  0006a	0f b7 87 08 08
	00 00		 movzx	 eax, WORD PTR [edi+2056]
  00071	83 c0 f0	 add	 eax, -16		; fffffff0H
  00074	83 f8 17	 cmp	 eax, 23			; 00000017H
  00077	0f 87 ee 00 00
	00		 ja	 $L283019
  0007d	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR $L300264[eax]
  00084	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $L300267[eax*4]
$L283001:

; 6310 : 	{
; 6311 : 		case FUNCTYPE_ADDKEY:
; 6312 : 		case FUNCTYPE_ADDANSWER:
; 6313 : 			{
; 6314 : 				m_Snapshot.ar.WriteString( runScriptFunc.lpszVal1 );

  0008b	57		 push	 edi
  0008c	8b ce		 mov	 ecx, esi
  0008e	e8 00 00 00 00	 call	 ?WriteString@CAr@@QAEXPBD@Z ; CAr::WriteString

; 6315 : 				m_Snapshot.ar.WriteString( runScriptFunc.lpszVal2 );

  00093	8d 8f 00 04 00
	00		 lea	 ecx, DWORD PTR [edi+1024]
  00099	51		 push	 ecx
  0009a	8b ce		 mov	 ecx, esi
  0009c	e8 00 00 00 00	 call	 ?WriteString@CAr@@QAEXPBD@Z ; CAr::WriteString

; 6316 : 				m_Snapshot.ar << runScriptFunc.dwVal1;

  000a1	8b 97 00 08 00
	00		 mov	 edx, DWORD PTR [edi+2048]
  000a7	52		 push	 edx
  000a8	8b ce		 mov	 ecx, esi
  000aa	e8 00 00 00 00	 call	 ??6CAr@@QAEAAV0@K@Z	; CAr::operator<<

; 6317 : 				m_Snapshot.ar << runScriptFunc.dwVal2;

  000af	8b 87 04 08 00
	00		 mov	 eax, DWORD PTR [edi+2052]
  000b5	50		 push	 eax

; 6354 : 				m_Snapshot.ar << runScriptFunc.dwVal2;

  000b6	8b ce		 mov	 ecx, esi
  000b8	e8 00 00 00 00	 call	 ??6CAr@@QAEAAV0@K@Z	; CAr::operator<<

; 6355 : 				break;
; 6356 : 			}
; 6357 : #endif // __IMPROVE_QUEST_INTERFACE
; 6358 : 		default:
; 6359 : 			break;
; 6360 : 	}
; 6361 : 	
; 6362 : }

  000bd	5f		 pop	 edi
  000be	5e		 pop	 esi
  000bf	5b		 pop	 ebx
  000c0	c2 04 00	 ret	 4
$L283004:

; 6318 : 				break;
; 6319 : 			}
; 6320 : 		case FUNCTYPE_REMOVEKEY:
; 6321 : 			{
; 6322 : 				m_Snapshot.ar.WriteString( runScriptFunc.lpszVal1 );

  000c3	57		 push	 edi
  000c4	8b ce		 mov	 ecx, esi
  000c6	e8 00 00 00 00	 call	 ?WriteString@CAr@@QAEXPBD@Z ; CAr::WriteString

; 6355 : 				break;
; 6356 : 			}
; 6357 : #endif // __IMPROVE_QUEST_INTERFACE
; 6358 : 		default:
; 6359 : 			break;
; 6360 : 	}
; 6361 : 	
; 6362 : }

  000cb	5f		 pop	 edi
  000cc	5e		 pop	 esi
  000cd	5b		 pop	 ebx
  000ce	c2 04 00	 ret	 4
$L283006:

; 6323 : 				break;
; 6324 : 			}
; 6325 : 		case FUNCTYPE_SAY:
; 6326 : 		case FUNCTYPE_SAYQUEST:
; 6327 : 			{
; 6328 : 				m_Snapshot.ar.WriteString( runScriptFunc.lpszVal1 );

  000d1	57		 push	 edi
  000d2	8b ce		 mov	 ecx, esi
  000d4	e8 00 00 00 00	 call	 ?WriteString@CAr@@QAEXPBD@Z ; CAr::WriteString

; 6329 : 				m_Snapshot.ar << runScriptFunc.dwVal2;

  000d9	8b 8f 04 08 00
	00		 mov	 ecx, DWORD PTR [edi+2052]
  000df	51		 push	 ecx

; 6354 : 				m_Snapshot.ar << runScriptFunc.dwVal2;

  000e0	8b ce		 mov	 ecx, esi
  000e2	e8 00 00 00 00	 call	 ??6CAr@@QAEAAV0@K@Z	; CAr::operator<<

; 6355 : 				break;
; 6356 : 			}
; 6357 : #endif // __IMPROVE_QUEST_INTERFACE
; 6358 : 		default:
; 6359 : 			break;
; 6360 : 	}
; 6361 : 	
; 6362 : }

  000e7	5f		 pop	 edi
  000e8	5e		 pop	 esi
  000e9	5b		 pop	 ebx
  000ea	c2 04 00	 ret	 4
$L283009:

; 6330 : 				break;
; 6331 : 			}
; 6332 : 		case FUNCTYPE_INITSTAT:
; 6333 : 		case FUNCTYPE_INITSTR:
; 6334 : 		case FUNCTYPE_INITSTA:			
; 6335 : 		case FUNCTYPE_INITDEX:
; 6336 : 		case FUNCTYPE_INITINT:
; 6337 : 			{
; 6338 : 				m_Snapshot.ar << runScriptFunc.dwVal1;

  000ed	8b 97 00 08 00
	00		 mov	 edx, DWORD PTR [edi+2048]

; 6354 : 				m_Snapshot.ar << runScriptFunc.dwVal2;

  000f3	52		 push	 edx
  000f4	8b ce		 mov	 ecx, esi
  000f6	e8 00 00 00 00	 call	 ??6CAr@@QAEAAV0@K@Z	; CAr::operator<<

; 6355 : 				break;
; 6356 : 			}
; 6357 : #endif // __IMPROVE_QUEST_INTERFACE
; 6358 : 		default:
; 6359 : 			break;
; 6360 : 	}
; 6361 : 	
; 6362 : }

  000fb	5f		 pop	 edi
  000fc	5e		 pop	 esi
  000fd	5b		 pop	 ebx
  000fe	c2 04 00	 ret	 4
$L283015:

; 6339 : 				break;
; 6340 : 			}
; 6341 : 		case FUNCTYPE_SETNAVIGATOR:
; 6342 : 			{
; 6343 : 				m_Snapshot.ar << runScriptFunc.dwVal1;

  00101	8b 87 00 08 00
	00		 mov	 eax, DWORD PTR [edi+2048]
  00107	50		 push	 eax
  00108	8b ce		 mov	 ecx, esi
  0010a	e8 00 00 00 00	 call	 ??6CAr@@QAEAAV0@K@Z	; CAr::operator<<

; 6344 : 				m_Snapshot.ar << runScriptFunc.vPos;

  0010f	81 c7 0c 08 00
	00		 add	 edi, 2060		; 0000080cH
  00115	8b 17		 mov	 edx, DWORD PTR [edi]
  00117	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0011a	83 ec 0c	 sub	 esp, 12			; 0000000cH
  0011d	8b cc		 mov	 ecx, esp
  0011f	89 11		 mov	 DWORD PTR [ecx], edx
  00121	8b 57 08	 mov	 edx, DWORD PTR [edi+8]
  00124	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00127	56		 push	 esi
  00128	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  0012b	e8 00 00 00 00	 call	 ??6@YAAAVCAr@@AAV0@UD3DXVECTOR3@@@Z ; operator<<
  00130	83 c4 10	 add	 esp, 16			; 00000010H

; 6355 : 				break;
; 6356 : 			}
; 6357 : #endif // __IMPROVE_QUEST_INTERFACE
; 6358 : 		default:
; 6359 : 			break;
; 6360 : 	}
; 6361 : 	
; 6362 : }

  00133	5f		 pop	 edi
  00134	5e		 pop	 esi
  00135	5b		 pop	 ebx
  00136	c2 04 00	 ret	 4
$L283017:

; 6345 : 				break;
; 6346 : 			}
; 6347 : #if __VER >= 15 // __IMPROVE_QUEST_INTERFACE
; 6348 : 		case FUNCTYPE_NEWQUEST:
; 6349 : 		case FUNCTYPE_CURRQUEST:
; 6350 : 			{
; 6351 : 				m_Snapshot.ar.WriteString( runScriptFunc.lpszVal1 );

  00139	57		 push	 edi
  0013a	8b ce		 mov	 ecx, esi
  0013c	e8 00 00 00 00	 call	 ?WriteString@CAr@@QAEXPBD@Z ; CAr::WriteString

; 6352 : 				m_Snapshot.ar.WriteString( runScriptFunc.lpszVal2 );

  00141	8d 87 00 04 00
	00		 lea	 eax, DWORD PTR [edi+1024]
  00147	50		 push	 eax
  00148	8b ce		 mov	 ecx, esi
  0014a	e8 00 00 00 00	 call	 ?WriteString@CAr@@QAEXPBD@Z ; CAr::WriteString

; 6353 : 				m_Snapshot.ar << runScriptFunc.dwVal1;

  0014f	8b 8f 00 08 00
	00		 mov	 ecx, DWORD PTR [edi+2048]
  00155	51		 push	 ecx
  00156	8b ce		 mov	 ecx, esi
  00158	e8 00 00 00 00	 call	 ??6CAr@@QAEAAV0@K@Z	; CAr::operator<<

; 6354 : 				m_Snapshot.ar << runScriptFunc.dwVal2;

  0015d	8b 97 04 08 00
	00		 mov	 edx, DWORD PTR [edi+2052]
  00163	52		 push	 edx
  00164	8b ce		 mov	 ecx, esi
  00166	e8 00 00 00 00	 call	 ??6CAr@@QAEAAV0@K@Z	; CAr::operator<<
$L283019:

; 6355 : 				break;
; 6356 : 			}
; 6357 : #endif // __IMPROVE_QUEST_INTERFACE
; 6358 : 		default:
; 6359 : 			break;
; 6360 : 	}
; 6361 : 	
; 6362 : }

  0016b	5f		 pop	 edi
  0016c	5e		 pop	 esi
  0016d	5b		 pop	 ebx
  0016e	c2 04 00	 ret	 4
  00171	8d 49 00	 npad	 3
$L300267:
  00174	00 00 00 00	 DD	 $L283001
  00178	00 00 00 00	 DD	 $L283004
  0017c	00 00 00 00	 DD	 $L283006
  00180	00 00 00 00	 DD	 $L283009
  00184	00 00 00 00	 DD	 $L283015
  00188	00 00 00 00	 DD	 $L283017
  0018c	00 00 00 00	 DD	 $L283019
$L300264:
  00190	00		 DB	 0
  00191	01		 DB	 1
  00192	02		 DB	 2
  00193	00		 DB	 0
  00194	06		 DB	 6
  00195	06		 DB	 6
  00196	06		 DB	 6
  00197	06		 DB	 6
  00198	06		 DB	 6
  00199	06		 DB	 6
  0019a	03		 DB	 3
  0019b	04		 DB	 4
  0019c	06		 DB	 6
  0019d	06		 DB	 6
  0019e	02		 DB	 2
  0019f	06		 DB	 6
  001a0	03		 DB	 3
  001a1	03		 DB	 3
  001a2	03		 DB	 3
  001a3	03		 DB	 3
  001a4	06		 DB	 6
  001a5	06		 DB	 6
  001a6	05		 DB	 5
  001a7	05		 DB	 5
?AddRunScriptFunc@CUser@@QAEXABU_runscriptfunc@@@Z ENDP	; CUser::AddRunScriptFunc
_TEXT	ENDS
PUBLIC	?AddEnterChatting@CUser@@QAEXPAV1@@Z		; CUser::AddEnterChatting
EXTRN	?GetName@CMover@@QAEPBDH@Z:NEAR			; CMover::GetName
; Function compile flags: /Ogty
;	COMDAT ?AddEnterChatting@CUser@@QAEXPAV1@@Z
_TEXT	SEGMENT
_pUser$ = 8						; size = 4
?AddEnterChatting@CUser@@QAEXPAV1@@Z PROC NEAR		; CUser::AddEnterChatting, COMDAT
; _this$ = ecx

; 6366 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	0f 85 8e 00 00
	00		 jne	 $L283023

; 6367 : 	
; 6368 : 	m_Snapshot.cb++;

  0000a	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  00011	53		 push	 ebx
  00012	56		 push	 esi
  00013	57		 push	 edi

; 6369 : 	m_Snapshot.ar << GetId();

  00014	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  0001a	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  00020	6a 04		 push	 4
  00022	8b ce		 mov	 ecx, esi
  00024	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00029	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0002c	89 38		 mov	 DWORD PTR [eax], edi
  0002e	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00031	83 c0 04	 add	 eax, 4

; 6370 : 	m_Snapshot.ar << SNAPSHOTTYPE_CHATTING;

  00034	6a 02		 push	 2
  00036	8b ce		 mov	 ecx, esi
  00038	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0003b	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00040	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00043	66 c7 01 7b 00	 mov	 WORD PTR [ecx], 123	; 0000007bH
  00048	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  0004b	83 c7 02	 add	 edi, 2

; 6371 : 	m_Snapshot.ar << CHATTING_ENTERMEMBER;

  0004e	6a 01		 push	 1
  00050	8b ce		 mov	 ecx, esi
  00052	89 7e 08	 mov	 DWORD PTR [esi+8], edi
  00055	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0005a	8b 56 08	 mov	 edx, DWORD PTR [esi+8]

; 6372 : 	m_Snapshot.ar << pUser->m_idPlayer;

  0005d	8b 7c 24 10	 mov	 edi, DWORD PTR _pUser$[esp+8]
  00061	c6 02 00	 mov	 BYTE PTR [edx], 0
  00064	ff 46 08	 inc	 DWORD PTR [esi+8]
  00067	8b 9f 38 02 00
	00		 mov	 ebx, DWORD PTR [edi+568]
  0006d	6a 04		 push	 4
  0006f	8b ce		 mov	 ecx, esi
  00071	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00076	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00079	89 18		 mov	 DWORD PTR [eax], ebx
  0007b	8b 5e 08	 mov	 ebx, DWORD PTR [esi+8]
  0007e	83 c3 04	 add	 ebx, 4

; 6373 : 	m_Snapshot.ar.WriteString( pUser->GetName() );

  00081	6a 00		 push	 0
  00083	8b cf		 mov	 ecx, edi
  00085	89 5e 08	 mov	 DWORD PTR [esi+8], ebx
  00088	e8 00 00 00 00	 call	 ?GetName@CMover@@QAEPBDH@Z ; CMover::GetName
  0008d	50		 push	 eax
  0008e	8b ce		 mov	 ecx, esi
  00090	e8 00 00 00 00	 call	 ?WriteString@CAr@@QAEXPBD@Z ; CAr::WriteString
  00095	5f		 pop	 edi
  00096	5e		 pop	 esi
  00097	5b		 pop	 ebx
$L283023:

; 6374 : 	
; 6375 : }

  00098	c2 04 00	 ret	 4
?AddEnterChatting@CUser@@QAEXPAV1@@Z ENDP		; CUser::AddEnterChatting
_TEXT	ENDS
PUBLIC	?AddRemoveChatting@CUser@@QAEXK@Z		; CUser::AddRemoveChatting
; Function compile flags: /Ogty
;	COMDAT ?AddRemoveChatting@CUser@@QAEXK@Z
_TEXT	SEGMENT
_uidPlayer$ = 8						; size = 4
?AddRemoveChatting@CUser@@QAEXK@Z PROC NEAR		; CUser::AddRemoveChatting, COMDAT
; _this$ = ecx

; 6440 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	75 79		 jne	 SHORT $L300319

; 6441 : 	
; 6442 : 	m_Snapshot.cb++;

  00006	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  0000d	56		 push	 esi
  0000e	57		 push	 edi

; 6443 : 	m_Snapshot.ar << GetId();

  0000f	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  00015	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  0001b	6a 04		 push	 4
  0001d	8b ce		 mov	 ecx, esi
  0001f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00024	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00027	89 38		 mov	 DWORD PTR [eax], edi
  00029	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0002c	83 c2 04	 add	 edx, 4

; 6444 : 	m_Snapshot.ar << SNAPSHOTTYPE_CHATTING;

  0002f	6a 02		 push	 2
  00031	8b ce		 mov	 ecx, esi
  00033	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00036	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003b	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003e	66 c7 01 7b 00	 mov	 WORD PTR [ecx], 123	; 0000007bH
  00043	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00046	83 c0 02	 add	 eax, 2

; 6445 : 	m_Snapshot.ar << CHATTING_REMOVEMEMBER;

  00049	6a 01		 push	 1
  0004b	8b ce		 mov	 ecx, esi
  0004d	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00050	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00055	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00058	c6 02 03	 mov	 BYTE PTR [edx], 3
  0005b	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0005e	42		 inc	 edx

; 6446 : 	m_Snapshot.ar << uidPlayer;

  0005f	6a 04		 push	 4
  00061	8b ce		 mov	 ecx, esi
  00063	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00066	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0006b	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0006e	8b 4c 24 0c	 mov	 ecx, DWORD PTR _uidPlayer$[esp+4]
  00072	89 08		 mov	 DWORD PTR [eax], ecx
  00074	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00077	83 c0 04	 add	 eax, 4
  0007a	5f		 pop	 edi
  0007b	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0007e	5e		 pop	 esi
$L300319:

; 6447 : 	
; 6448 : }

  0007f	c2 04 00	 ret	 4
?AddRemoveChatting@CUser@@QAEXK@Z ENDP			; CUser::AddRemoveChatting
_TEXT	ENDS
PUBLIC	?AddDeleteChatting@CUser@@QAEXXZ		; CUser::AddDeleteChatting
; Function compile flags: /Ogty
;	COMDAT ?AddDeleteChatting@CUser@@QAEXXZ
_TEXT	SEGMENT
?AddDeleteChatting@CUser@@QAEXXZ PROC NEAR		; CUser::AddDeleteChatting, COMDAT
; _this$ = ecx

; 6452 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	75 5e		 jne	 SHORT $L300341

; 6453 : 	
; 6454 : 	m_Snapshot.cb++;

  00006	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  0000d	56		 push	 esi
  0000e	57		 push	 edi

; 6455 : 	m_Snapshot.ar << GetId();

  0000f	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  00015	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  0001b	6a 04		 push	 4
  0001d	8b ce		 mov	 ecx, esi
  0001f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00024	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00027	89 38		 mov	 DWORD PTR [eax], edi
  00029	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0002c	83 c0 04	 add	 eax, 4

; 6456 : 	m_Snapshot.ar << SNAPSHOTTYPE_CHATTING;

  0002f	6a 02		 push	 2
  00031	8b ce		 mov	 ecx, esi
  00033	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00036	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003b	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003e	66 c7 01 7b 00	 mov	 WORD PTR [ecx], 123	; 0000007bH
  00043	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00046	83 c2 02	 add	 edx, 2

; 6457 : 	m_Snapshot.ar << CHATTING_DELETECHATTING;

  00049	6a 01		 push	 1
  0004b	8b ce		 mov	 ecx, esi
  0004d	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00050	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00055	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00058	c6 02 02	 mov	 BYTE PTR [edx], 2
  0005b	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0005e	40		 inc	 eax
  0005f	5f		 pop	 edi
  00060	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00063	5e		 pop	 esi
$L300341:

; 6458 : 	
; 6459 : }

  00064	c3		 ret	 0
?AddDeleteChatting@CUser@@QAEXXZ ENDP			; CUser::AddDeleteChatting
_TEXT	ENDS
PUBLIC	?AddChatting@CUser@@QAEXKPAD@Z			; CUser::AddChatting
; Function compile flags: /Ogty
;	COMDAT ?AddChatting@CUser@@QAEXKPAD@Z
_TEXT	SEGMENT
_uidPlayer$ = 8						; size = 4
_pszChat$ = 12						; size = 4
?AddChatting@CUser@@QAEXKPAD@Z PROC NEAR		; CUser::AddChatting, COMDAT
; _this$ = ecx

; 6463 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	75 7b		 jne	 SHORT $L283064

; 6464 : 	
; 6465 : 	m_Snapshot.cb++;

  00006	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  0000d	56		 push	 esi
  0000e	57		 push	 edi

; 6466 : 	m_Snapshot.ar << GetId();

  0000f	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  00015	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  0001b	6a 04		 push	 4
  0001d	8b ce		 mov	 ecx, esi
  0001f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00024	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00027	89 38		 mov	 DWORD PTR [eax], edi
  00029	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  0002c	83 c7 04	 add	 edi, 4

; 6467 : 	m_Snapshot.ar << SNAPSHOTTYPE_CHATTING;

  0002f	6a 02		 push	 2
  00031	8b ce		 mov	 ecx, esi
  00033	89 7e 08	 mov	 DWORD PTR [esi+8], edi
  00036	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003b	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003e	66 c7 01 7b 00	 mov	 WORD PTR [ecx], 123	; 0000007bH
  00043	83 46 08 02	 add	 DWORD PTR [esi+8], 2

; 6468 : 	m_Snapshot.ar << CHATTING_CHATTING;

  00047	6a 01		 push	 1
  00049	8b ce		 mov	 ecx, esi
  0004b	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00050	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00053	c6 02 04	 mov	 BYTE PTR [edx], 4
  00056	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  00059	47		 inc	 edi

; 6469 : 	m_Snapshot.ar << uidPlayer;

  0005a	6a 04		 push	 4
  0005c	8b ce		 mov	 ecx, esi
  0005e	89 7e 08	 mov	 DWORD PTR [esi+8], edi
  00061	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00066	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00069	8b 4c 24 0c	 mov	 ecx, DWORD PTR _uidPlayer$[esp+4]

; 6470 : 	m_Snapshot.ar.WriteString( pszChat );

  0006d	8b 54 24 10	 mov	 edx, DWORD PTR _pszChat$[esp+4]
  00071	89 08		 mov	 DWORD PTR [eax], ecx
  00073	83 46 08 04	 add	 DWORD PTR [esi+8], 4
  00077	52		 push	 edx
  00078	8b ce		 mov	 ecx, esi
  0007a	e8 00 00 00 00	 call	 ?WriteString@CAr@@QAEXPBD@Z ; CAr::WriteString
  0007f	5f		 pop	 edi
  00080	5e		 pop	 esi
$L283064:

; 6471 : 	
; 6472 : }

  00081	c2 08 00	 ret	 8
?AddChatting@CUser@@QAEXKPAD@Z ENDP			; CUser::AddChatting
_TEXT	ENDS
PUBLIC	?AddGameRate@CUser@@QAEXME@Z			; CUser::AddGameRate
; Function compile flags: /Ogty
;	COMDAT ?AddGameRate@CUser@@QAEXME@Z
_TEXT	SEGMENT
_fRate$ = 8						; size = 4
_nFlag$ = 12						; size = 1
?AddGameRate@CUser@@QAEXME@Z PROC NEAR			; CUser::AddGameRate, COMDAT
; _this$ = ecx

; 6488 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	75 7c		 jne	 SHORT $L300393

; 6489 : 	
; 6490 : 	m_Snapshot.cb++;

  00006	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  0000d	56		 push	 esi
  0000e	57		 push	 edi

; 6491 : 	m_Snapshot.ar << GetId();

  0000f	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  00015	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  0001b	6a 04		 push	 4
  0001d	8b ce		 mov	 ecx, esi
  0001f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00024	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00027	89 38		 mov	 DWORD PTR [eax], edi
  00029	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0002c	83 c2 04	 add	 edx, 4

; 6492 : 	m_Snapshot.ar << SNAPSHOTTYPE_GAMERATE;

  0002f	6a 02		 push	 2
  00031	8b ce		 mov	 ecx, esi
  00033	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00036	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003b	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003e	66 c7 01 2e 00	 mov	 WORD PTR [ecx], 46	; 0000002eH
  00043	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00046	83 c0 02	 add	 eax, 2

; 6493 : 	m_Snapshot.ar << fRate;

  00049	6a 04		 push	 4
  0004b	8b ce		 mov	 ecx, esi
  0004d	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00050	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00055	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00058	8b 44 24 0c	 mov	 eax, DWORD PTR _fRate$[esp+4]
  0005c	89 02		 mov	 DWORD PTR [edx], eax
  0005e	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00061	83 c2 04	 add	 edx, 4

; 6494 : 	m_Snapshot.ar << nFlag;

  00064	6a 01		 push	 1
  00066	8b ce		 mov	 ecx, esi
  00068	89 56 08	 mov	 DWORD PTR [esi+8], edx
  0006b	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00070	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00073	8a 54 24 10	 mov	 dl, BYTE PTR _nFlag$[esp+4]
  00077	88 11		 mov	 BYTE PTR [ecx], dl
  00079	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0007c	40		 inc	 eax
  0007d	5f		 pop	 edi
  0007e	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00081	5e		 pop	 esi
$L300393:

; 6495 : 	
; 6496 : }

  00082	c2 08 00	 ret	 8
?AddGameRate@CUser@@QAEXME@Z ENDP			; CUser::AddGameRate
_TEXT	ENDS
PUBLIC	?AddGameSetting@CUser@@QAEXXZ			; CUser::AddGameSetting
PUBLIC	__real@4f800000
EXTRN	?m_fItemDropRate@CProject@@2MA:DWORD		; CProject::m_fItemDropRate
EXTRN	?m_fGoldDropRate@CProject@@2MA:DWORD		; CProject::m_fGoldDropRate
EXTRN	?m_fMonsterExpRate@CProject@@2MA:DWORD		; CProject::m_fMonsterExpRate
EXTRN	?m_fMonsterHitRate@CProject@@2MA:DWORD		; CProject::m_fMonsterHitRate
EXTRN	?m_fShopCost@CProject@@2MA:DWORD		; CProject::m_fShopCost
EXTRN	?m_dwVagSP@CProject@@2KA:DWORD			; CProject::m_dwVagSP
EXTRN	?m_dwExpertSP@CProject@@2KA:DWORD		; CProject::m_dwExpertSP
EXTRN	?m_dwProSP@CProject@@2KA:DWORD			; CProject::m_dwProSP
EXTRN	?GetShopBuyFactor@CEventLua@@QAEMH@Z:NEAR	; CEventLua::GetShopBuyFactor
EXTRN	?GetShopSellFactor@CEventLua@@QAEMH@Z:NEAR	; CEventLua::GetShopSellFactor
;	COMDAT __real@4f800000
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\mover.h
CONST	SEGMENT
__real@4f800000 DD 04f800000r			; 4.29497e+009
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
CONST	ENDS
;	COMDAT ?AddGameSetting@CUser@@QAEXXZ
_TEXT	SEGMENT
tv198 = -4						; size = 4
tv195 = -4						; size = 4
tv192 = -4						; size = 4
?AddGameSetting@CUser@@QAEXXZ PROC NEAR			; CUser::AddGameSetting, COMDAT
; _this$ = ecx

; 6500 : {

  00000	51		 push	 ecx
  00001	56		 push	 esi
  00002	8b f1		 mov	 esi, ecx

; 6501 : 	if( IsDelete() )	return;

  00004	f6 46 04 01	 test	 BYTE PTR [esi+4], 1
  00008	0f 85 1e 01 00
	00		 jne	 $L283096

; 6502 : 
; 6503 : 	AddGameRate( prj.m_fShopCost, GAME_RATE_SHOPCOST );

  0000e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?m_fShopCost@CProject@@2MA
  00013	6a 00		 push	 0
  00015	50		 push	 eax
  00016	e8 00 00 00 00	 call	 ?AddGameRate@CUser@@QAEXME@Z ; CUser::AddGameRate

; 6504 : 	AddGameRate( (float)( prj.m_dwVagSP ), GAME_SKILL_VAGSP );

  0001b	db 05 00 00 00
	00		 fild	 DWORD PTR ?m_dwVagSP@CProject@@2KA ; CProject::m_dwVagSP
  00021	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?m_dwVagSP@CProject@@2KA ; CProject::m_dwVagSP
  00027	85 c9		 test	 ecx, ecx
  00029	6a 10		 push	 16			; 00000010H
  0002b	7d 06		 jge	 SHORT $L300404
  0002d	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$L300404:
  00033	51		 push	 ecx
  00034	8b ce		 mov	 ecx, esi
  00036	d9 1c 24	 fstp	 DWORD PTR [esp]
  00039	e8 00 00 00 00	 call	 ?AddGameRate@CUser@@QAEXME@Z ; CUser::AddGameRate

; 6505 : 	AddGameRate( (float)( prj.m_dwExpertSP ), GAME_SKILL_EXPERTSP );

  0003e	db 05 00 00 00
	00		 fild	 DWORD PTR ?m_dwExpertSP@CProject@@2KA ; CProject::m_dwExpertSP
  00044	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?m_dwExpertSP@CProject@@2KA ; CProject::m_dwExpertSP
  0004a	85 d2		 test	 edx, edx
  0004c	6a 11		 push	 17			; 00000011H
  0004e	7d 06		 jge	 SHORT $L300407
  00050	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$L300407:
  00056	51		 push	 ecx
  00057	8b ce		 mov	 ecx, esi
  00059	d9 1c 24	 fstp	 DWORD PTR [esp]
  0005c	e8 00 00 00 00	 call	 ?AddGameRate@CUser@@QAEXME@Z ; CUser::AddGameRate

; 6506 : 	AddGameRate( (float)( prj.m_dwProSP ), GAME_SKILL_PROSP );

  00061	db 05 00 00 00
	00		 fild	 DWORD PTR ?m_dwProSP@CProject@@2KA ; CProject::m_dwProSP
  00067	a1 00 00 00 00	 mov	 eax, DWORD PTR ?m_dwProSP@CProject@@2KA ; CProject::m_dwProSP
  0006c	85 c0		 test	 eax, eax
  0006e	6a 12		 push	 18			; 00000012H
  00070	7d 06		 jge	 SHORT $L300408
  00072	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$L300408:
  00078	51		 push	 ecx
  00079	8b ce		 mov	 ecx, esi
  0007b	d9 1c 24	 fstp	 DWORD PTR [esp]
  0007e	e8 00 00 00 00	 call	 ?AddGameRate@CUser@@QAEXME@Z ; CUser::AddGameRate

; 6507 : #ifdef __SHOP_COST_RATE
; 6508 : 	AddGameRate( prj.m_EventLua.GetShopBuyFactor(), GAME_RATE_SHOP_BUY );

  00083	6a 13		 push	 19			; 00000013H
  00085	6a 01		 push	 1
  00087	b9 f8 91 11 00	 mov	 ecx, OFFSET FLAT:?prj@@3VCProject@@A+1151480
  0008c	e8 00 00 00 00	 call	 ?GetShopBuyFactor@CEventLua@@QAEMH@Z ; CEventLua::GetShopBuyFactor
  00091	51		 push	 ecx
  00092	8b ce		 mov	 ecx, esi
  00094	d9 1c 24	 fstp	 DWORD PTR [esp]
  00097	e8 00 00 00 00	 call	 ?AddGameRate@CUser@@QAEXME@Z ; CUser::AddGameRate

; 6509 : 	AddGameRate( prj.m_EventLua.GetShopSellFactor(), GAME_RATE_SHOP_SELL );

  0009c	6a 14		 push	 20			; 00000014H
  0009e	6a 01		 push	 1
  000a0	b9 f8 91 11 00	 mov	 ecx, OFFSET FLAT:?prj@@3VCProject@@A+1151480
  000a5	e8 00 00 00 00	 call	 ?GetShopSellFactor@CEventLua@@QAEMH@Z ; CEventLua::GetShopSellFactor
  000aa	51		 push	 ecx
  000ab	8b ce		 mov	 ecx, esi
  000ad	d9 1c 24	 fstp	 DWORD PTR [esp]
  000b0	e8 00 00 00 00	 call	 ?AddGameRate@CUser@@QAEXME@Z ; CUser::AddGameRate

; 6510 : #endif // __SHOP_COST_RATE
; 6511 : 	if( ((CMover*)this)->IsAuthHigher( AUTH_GAMEMASTER ) )

  000b5	83 be 48 06 00
	00 4c		 cmp	 DWORD PTR [esi+1608], 76 ; 0000004cH
  000bc	72 6e		 jb	 SHORT $L283096

; 6512 : 	{
; 6513 : 		AddGameRate( prj.m_fItemDropRate, GAME_RATE_ITEMDROP );

  000be	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?m_fItemDropRate@CProject@@2MA
  000c4	6a 01		 push	 1
  000c6	51		 push	 ecx
  000c7	8b ce		 mov	 ecx, esi
  000c9	e8 00 00 00 00	 call	 ?AddGameRate@CUser@@QAEXME@Z ; CUser::AddGameRate

; 6514 : 		AddGameRate( prj.m_fGoldDropRate, GAME_RATE_GOLDDROP );

  000ce	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?m_fGoldDropRate@CProject@@2MA
  000d4	6a 02		 push	 2
  000d6	52		 push	 edx
  000d7	8b ce		 mov	 ecx, esi
  000d9	e8 00 00 00 00	 call	 ?AddGameRate@CUser@@QAEXME@Z ; CUser::AddGameRate

; 6515 : 		AddGameRate( prj.m_fMonsterExpRate, GAME_RATE_MONSTEREXP );

  000de	a1 00 00 00 00	 mov	 eax, DWORD PTR ?m_fMonsterExpRate@CProject@@2MA
  000e3	6a 03		 push	 3
  000e5	50		 push	 eax
  000e6	8b ce		 mov	 ecx, esi
  000e8	e8 00 00 00 00	 call	 ?AddGameRate@CUser@@QAEXME@Z ; CUser::AddGameRate

; 6516 : 		AddGameRate( prj.m_fMonsterHitRate, GAME_RATE_MONSTERHIT );

  000ed	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?m_fMonsterHitRate@CProject@@2MA
  000f3	6a 04		 push	 4
  000f5	51		 push	 ecx
  000f6	8b ce		 mov	 ecx, esi
  000f8	e8 00 00 00 00	 call	 ?AddGameRate@CUser@@QAEXME@Z ; CUser::AddGameRate

; 6517 : 		
; 6518 : #ifdef __S1108_BACK_END_SYSTEM
; 6519 : 		AddGameRate( prj.m_fMonsterRebirthRate, GAME_RATE_REBIRTH );

  000fd	8b 15 b4 46 0f
	00		 mov	 edx, DWORD PTR ?prj@@3VCProject@@A+1001140
  00103	6a 06		 push	 6
  00105	52		 push	 edx
  00106	8b ce		 mov	 ecx, esi
  00108	e8 00 00 00 00	 call	 ?AddGameRate@CUser@@QAEXME@Z ; CUser::AddGameRate

; 6520 : 		AddGameRate( prj.m_fMonsterHitpointRate, GAME_RATE_HITPOINT );

  0010d	a1 b8 46 0f 00	 mov	 eax, DWORD PTR ?prj@@3VCProject@@A+1001144
  00112	6a 07		 push	 7
  00114	50		 push	 eax
  00115	8b ce		 mov	 ecx, esi
  00117	e8 00 00 00 00	 call	 ?AddGameRate@CUser@@QAEXME@Z ; CUser::AddGameRate

; 6521 : 		AddGameRate( prj.m_fMonsterAggressiveRate, GAME_RATE_AGGRESSIVE );

  0011c	8b 0d bc 46 0f
	00		 mov	 ecx, DWORD PTR ?prj@@3VCProject@@A+1001148
  00122	6a 08		 push	 8
  00124	51		 push	 ecx
  00125	8b ce		 mov	 ecx, esi
  00127	e8 00 00 00 00	 call	 ?AddGameRate@CUser@@QAEXME@Z ; CUser::AddGameRate
$L283096:
  0012c	5e		 pop	 esi

; 6522 : #endif // __S1108_BACK_END_SYSTEM
; 6523 : 	}	
; 6524 : }

  0012d	59		 pop	 ecx
  0012e	c3		 ret	 0
?AddGameSetting@CUser@@QAEXXZ ENDP			; CUser::AddGameSetting
_TEXT	ENDS
PUBLIC	?AddWantedInfo@CUser@@QAEXABUD3DXVECTOR3@@EKPBD@Z ; CUser::AddWantedInfo
; Function compile flags: /Ogty
;	COMDAT ?AddWantedInfo@CUser@@QAEXABUD3DXVECTOR3@@EKPBD@Z
_TEXT	SEGMENT
$T300430 = -12						; size = 12
_vPos$ = 8						; size = 4
_byOnline$ = 12						; size = 1
_dwWorldID$ = 16					; size = 4
_lpszWorld$ = 20					; size = 4
?AddWantedInfo@CUser@@QAEXABUD3DXVECTOR3@@EKPBD@Z PROC NEAR ; CUser::AddWantedInfo, COMDAT
; _this$ = ecx

; 6589 : 	if( IsDelete() )	return;

  00000	8a 41 04	 mov	 al, BYTE PTR [ecx+4]
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	a8 01		 test	 al, 1
  00008	0f 85 9f 00 00
	00		 jne	 $L283139

; 6590 : 
; 6591 : 	
; 6592 : 	m_Snapshot.cb++;

  0000e	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  00015	56		 push	 esi
  00016	57		 push	 edi

; 6593 : 	m_Snapshot.ar << GetId();

  00017	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  0001d	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  00023	6a 04		 push	 4
  00025	8b ce		 mov	 ecx, esi
  00027	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0002c	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0002f	89 38		 mov	 DWORD PTR [eax], edi
  00031	83 46 08 04	 add	 DWORD PTR [esi+8], 4

; 6594 : 	m_Snapshot.ar << SNAPSHOTTYPE_WANTED_INFO;

  00035	6a 02		 push	 2
  00037	8b ce		 mov	 ecx, esi
  00039	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003e	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]

; 6595 : 	m_Snapshot.ar << vPos;

  00041	8b 54 24 18	 mov	 edx, DWORD PTR _vPos$[esp+16]
  00045	66 c7 01 80 00	 mov	 WORD PTR [ecx], 128	; 00000080H
  0004a	83 46 08 02	 add	 DWORD PTR [esi+8], 2
  0004e	8b 02		 mov	 eax, DWORD PTR [edx]
  00050	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00053	8b 52 08	 mov	 edx, DWORD PTR [edx+8]
  00056	89 44 24 08	 mov	 DWORD PTR $T300430[esp+20], eax
  0005a	6a 0c		 push	 12			; 0000000cH
  0005c	8d 44 24 0c	 lea	 eax, DWORD PTR $T300430[esp+24]
  00060	89 4c 24 10	 mov	 DWORD PTR $T300430[esp+28], ecx
  00064	50		 push	 eax
  00065	8b ce		 mov	 ecx, esi
  00067	89 54 24 18	 mov	 DWORD PTR $T300430[esp+36], edx
  0006b	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write

; 6596 : 	m_Snapshot.ar << byOnline;

  00070	6a 01		 push	 1
  00072	8b ce		 mov	 ecx, esi
  00074	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00079	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0007c	8a 54 24 1c	 mov	 dl, BYTE PTR _byOnline$[esp+16]
  00080	88 11		 mov	 BYTE PTR [ecx], dl
  00082	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  00085	47		 inc	 edi

; 6597 : 	m_Snapshot.ar << dwWorldID;		

  00086	6a 04		 push	 4
  00088	8b ce		 mov	 ecx, esi
  0008a	89 7e 08	 mov	 DWORD PTR [esi+8], edi
  0008d	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00092	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00095	8b 4c 24 20	 mov	 ecx, DWORD PTR _dwWorldID$[esp+16]

; 6598 : 	m_Snapshot.ar.WriteString( lpszWorld );

  00099	8b 54 24 24	 mov	 edx, DWORD PTR _lpszWorld$[esp+16]
  0009d	89 08		 mov	 DWORD PTR [eax], ecx
  0009f	83 46 08 04	 add	 DWORD PTR [esi+8], 4
  000a3	52		 push	 edx
  000a4	8b ce		 mov	 ecx, esi
  000a6	e8 00 00 00 00	 call	 ?WriteString@CAr@@QAEXPBD@Z ; CAr::WriteString
  000ab	5f		 pop	 edi
  000ac	5e		 pop	 esi
$L283139:

; 6599 : 	
; 6600 : }

  000ad	83 c4 0c	 add	 esp, 12			; 0000000cH
  000b0	c2 10 00	 ret	 16			; 00000010H
?AddWantedInfo@CUser@@QAEXABUD3DXVECTOR3@@EKPBD@Z ENDP	; CUser::AddWantedInfo
_TEXT	ENDS
PUBLIC	?AddReturnScroll@CUser@@QAEXXZ			; CUser::AddReturnScroll
; Function compile flags: /Ogty
;	COMDAT ?AddReturnScroll@CUser@@QAEXXZ
_TEXT	SEGMENT
?AddReturnScroll@CUser@@QAEXXZ PROC NEAR		; CUser::AddReturnScroll, COMDAT
; _this$ = ecx

; 6618 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	75 48		 jne	 SHORT $L300456

; 6619 : 
; 6620 : 	
; 6621 : 	m_Snapshot.cb++;

  00006	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  0000d	56		 push	 esi
  0000e	57		 push	 edi

; 6622 : 	m_Snapshot.ar << GetId();

  0000f	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  00015	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  0001b	6a 04		 push	 4
  0001d	8b ce		 mov	 ecx, esi
  0001f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00024	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00027	89 38		 mov	 DWORD PTR [eax], edi
  00029	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0002c	83 c2 04	 add	 edx, 4

; 6623 : 	m_Snapshot.ar << SNAPSHOTTYPE_RETURNSCORLL;

  0002f	6a 02		 push	 2
  00031	8b ce		 mov	 ecx, esi
  00033	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00036	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003b	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003e	66 c7 01 ad 00	 mov	 WORD PTR [ecx], 173	; 000000adH
  00043	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00046	83 c0 02	 add	 eax, 2
  00049	5f		 pop	 edi
  0004a	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0004d	5e		 pop	 esi
$L300456:

; 6624 : 	
; 6625 : }

  0004e	c3		 ret	 0
?AddReturnScroll@CUser@@QAEXXZ ENDP			; CUser::AddReturnScroll
_TEXT	ENDS
PUBLIC	?AddPostMail@CUser@@QAEXPAVCMail@@@Z		; CUser::AddPostMail
EXTRN	?Serialize@CMail@@QAEXAAVCAr@@H@Z:NEAR		; CMail::Serialize
; Function compile flags: /Ogty
;	COMDAT ?AddPostMail@CUser@@QAEXPAVCMail@@@Z
_TEXT	SEGMENT
_pMail$ = 8						; size = 4
?AddPostMail@CUser@@QAEXPAVCMail@@@Z PROC NEAR		; CUser::AddPostMail, COMDAT
; _this$ = ecx

; 6721 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	75 54		 jne	 SHORT $L283214

; 6722 : 	
; 6723 : 	m_Snapshot.cb++;

  00006	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  0000d	56		 push	 esi
  0000e	57		 push	 edi

; 6724 : 	m_Snapshot.ar << GetId();

  0000f	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  00015	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  0001b	6a 04		 push	 4
  0001d	8b ce		 mov	 ecx, esi
  0001f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00024	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00027	89 38		 mov	 DWORD PTR [eax], edi
  00029	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0002c	83 c0 04	 add	 eax, 4

; 6725 : 	m_Snapshot.ar << SNAPSHOTTYPE_POSTMAIL;

  0002f	6a 02		 push	 2
  00031	8b ce		 mov	 ecx, esi
  00033	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00036	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003b	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003e	66 c7 01 e6 00	 mov	 WORD PTR [ecx], 230	; 000000e6H
  00043	8b 56 08	 mov	 edx, DWORD PTR [esi+8]

; 6726 : 	pMail->Serialize( m_Snapshot.ar );

  00046	8b 4c 24 0c	 mov	 ecx, DWORD PTR _pMail$[esp+4]
  0004a	6a 01		 push	 1
  0004c	83 c2 02	 add	 edx, 2
  0004f	56		 push	 esi
  00050	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00053	e8 00 00 00 00	 call	 ?Serialize@CMail@@QAEXAAVCAr@@H@Z ; CMail::Serialize
  00058	5f		 pop	 edi
  00059	5e		 pop	 esi
$L283214:

; 6727 : 	
; 6728 : }

  0005a	c2 04 00	 ret	 4
?AddPostMail@CUser@@QAEXPAVCMail@@@Z ENDP		; CUser::AddPostMail
_TEXT	ENDS
PUBLIC	?AddMailBox@CUser@@QAEXPAVCMailBox@@@Z		; CUser::AddMailBox
EXTRN	?Serialize@CMailBox@@QAEXAAVCAr@@H@Z:NEAR	; CMailBox::Serialize
; Function compile flags: /Ogty
;	COMDAT ?AddMailBox@CUser@@QAEXPAVCMailBox@@@Z
_TEXT	SEGMENT
_pMailBox$ = 8						; size = 4
?AddMailBox@CUser@@QAEXPAVCMailBox@@@Z PROC NEAR	; CUser::AddMailBox, COMDAT
; _this$ = ecx

; 6743 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	75 54		 jne	 SHORT $L283227

; 6744 : 	
; 6745 : 	m_Snapshot.cb++;

  00006	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  0000d	56		 push	 esi
  0000e	57		 push	 edi

; 6746 : 	m_Snapshot.ar << GetId();

  0000f	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  00015	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  0001b	6a 04		 push	 4
  0001d	8b ce		 mov	 ecx, esi
  0001f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00024	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00027	89 38		 mov	 DWORD PTR [eax], edi
  00029	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0002c	83 c0 04	 add	 eax, 4

; 6747 : 	m_Snapshot.ar << SNAPSHOTTYPE_QUERYMAILBOX;

  0002f	6a 02		 push	 2
  00031	8b ce		 mov	 ecx, esi
  00033	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00036	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003b	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003e	66 c7 01 e9 00	 mov	 WORD PTR [ecx], 233	; 000000e9H
  00043	8b 56 08	 mov	 edx, DWORD PTR [esi+8]

; 6748 : 	pMailBox->Serialize( m_Snapshot.ar );

  00046	8b 4c 24 0c	 mov	 ecx, DWORD PTR _pMailBox$[esp+4]
  0004a	6a 01		 push	 1
  0004c	83 c2 02	 add	 edx, 2
  0004f	56		 push	 esi
  00050	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00053	e8 00 00 00 00	 call	 ?Serialize@CMailBox@@QAEXAAVCAr@@H@Z ; CMailBox::Serialize
  00058	5f		 pop	 edi
  00059	5e		 pop	 esi
$L283227:

; 6749 : 	
; 6750 : }

  0005a	c2 04 00	 ret	 4
?AddMailBox@CUser@@QAEXPAVCMailBox@@@Z ENDP		; CUser::AddMailBox
_TEXT	ENDS
PUBLIC	?AddGCWindow@CUser@@QAEX_JKK@Z			; CUser::AddGCWindow
; Function compile flags: /Ogty
;	COMDAT ?AddGCWindow@CUser@@QAEX_JKK@Z
_TEXT	SEGMENT
$T300519 = -8						; size = 8
_nPrizePenya$ = 8					; size = 8
_dwRequstPenya$ = 16					; size = 4
_dwMinRequestPenya$ = 20				; size = 4
?AddGCWindow@CUser@@QAEX_JKK@Z PROC NEAR		; CUser::AddGCWindow, COMDAT
; _this$ = ecx

; 6799 : 	if( IsDelete() )	return;

  00000	8a 41 04	 mov	 al, BYTE PTR [ecx+4]
  00003	83 ec 08	 sub	 esp, 8
  00006	a8 01		 test	 al, 1
  00008	0f 85 ae 00 00
	00		 jne	 $L300526

; 6800 : 	
; 6801 : 	m_Snapshot.cb++;

  0000e	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  00015	56		 push	 esi
  00016	57		 push	 edi

; 6802 : 	m_Snapshot.ar << GetId();

  00017	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  0001d	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  00023	6a 04		 push	 4
  00025	8b ce		 mov	 ecx, esi
  00027	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0002c	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0002f	89 38		 mov	 DWORD PTR [eax], edi
  00031	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00034	83 c2 04	 add	 edx, 4

; 6803 : 	m_Snapshot.ar << SNAPSHOTTYPE_GUILDCOMBAT;

  00037	6a 02		 push	 2
  00039	8b ce		 mov	 ecx, esi
  0003b	89 56 08	 mov	 DWORD PTR [esi+8], edx
  0003e	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00043	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00046	66 c7 01 b8 00	 mov	 WORD PTR [ecx], 184	; 000000b8H
  0004b	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0004e	83 c0 02	 add	 eax, 2

; 6804 : 	m_Snapshot.ar << GC_IN_WINDOW;

  00051	6a 01		 push	 1
  00053	8b ce		 mov	 ecx, esi
  00055	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00058	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0005d	8b 56 08	 mov	 edx, DWORD PTR [esi+8]

; 6805 : 	m_Snapshot.ar << nPrizePenya << dwRequstPenya << dwMinRequestPenya;

  00060	8b 4c 24 18	 mov	 ecx, DWORD PTR _nPrizePenya$[esp+16]
  00064	8b 44 24 14	 mov	 eax, DWORD PTR _nPrizePenya$[esp+12]
  00068	c6 02 01	 mov	 BYTE PTR [edx], 1
  0006b	ff 46 08	 inc	 DWORD PTR [esi+8]
  0006e	6a 08		 push	 8
  00070	8d 54 24 0c	 lea	 edx, DWORD PTR $T300519[esp+20]
  00074	89 4c 24 10	 mov	 DWORD PTR $T300519[esp+24], ecx
  00078	52		 push	 edx
  00079	8b ce		 mov	 ecx, esi
  0007b	89 44 24 10	 mov	 DWORD PTR $T300519[esp+24], eax
  0007f	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
  00084	6a 04		 push	 4
  00086	8b ce		 mov	 ecx, esi
  00088	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0008d	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00090	8b 4c 24 1c	 mov	 ecx, DWORD PTR _dwRequstPenya$[esp+12]
  00094	89 08		 mov	 DWORD PTR [eax], ecx
  00096	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00099	83 c2 04	 add	 edx, 4
  0009c	6a 04		 push	 4
  0009e	8b ce		 mov	 ecx, esi
  000a0	89 56 08	 mov	 DWORD PTR [esi+8], edx
  000a3	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000a8	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  000ab	8b 44 24 20	 mov	 eax, DWORD PTR _dwMinRequestPenya$[esp+12]
  000af	89 02		 mov	 DWORD PTR [edx], eax
  000b1	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000b4	83 c0 04	 add	 eax, 4
  000b7	5f		 pop	 edi
  000b8	89 46 08	 mov	 DWORD PTR [esi+8], eax
  000bb	5e		 pop	 esi
$L300526:

; 6806 : 	
; 6807 : }

  000bc	83 c4 08	 add	 esp, 8
  000bf	c2 10 00	 ret	 16			; 00000010H
?AddGCWindow@CUser@@QAEX_JKK@Z ENDP			; CUser::AddGCWindow
_TEXT	ENDS
PUBLIC	?AddGCBestPlayer@CUser@@QAEXXZ			; CUser::AddGCBestPlayer
EXTRN	?g_GuildCombatMng@@3VCGuildCombat@@A:BYTE	; g_GuildCombatMng
; Function compile flags: /Ogty
;	COMDAT ?AddGCBestPlayer@CUser@@QAEXXZ
_TEXT	SEGMENT
?AddGCBestPlayer@CUser@@QAEXXZ PROC NEAR		; CUser::AddGCBestPlayer, COMDAT
; _this$ = ecx

; 6895 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	75 77		 jne	 SHORT $L300551

; 6896 : 	
; 6897 : 	m_Snapshot.cb++;

  00006	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  0000d	56		 push	 esi
  0000e	57		 push	 edi

; 6898 : 	m_Snapshot.ar << GetId();

  0000f	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  00015	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  0001b	6a 04		 push	 4
  0001d	8b ce		 mov	 ecx, esi
  0001f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00024	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00027	89 38		 mov	 DWORD PTR [eax], edi
  00029	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0002c	83 c2 04	 add	 edx, 4

; 6899 : 	m_Snapshot.ar << SNAPSHOTTYPE_GUILDCOMBAT;

  0002f	6a 02		 push	 2
  00031	8b ce		 mov	 ecx, esi
  00033	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00036	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003b	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003e	66 c7 01 b8 00	 mov	 WORD PTR [ecx], 184	; 000000b8H
  00043	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00046	83 c0 02	 add	 eax, 2

; 6900 : 	m_Snapshot.ar << GC_BESTPLAYER;

  00049	6a 01		 push	 1
  0004b	8b ce		 mov	 ecx, esi
  0004d	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00050	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00055	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00058	c6 02 07	 mov	 BYTE PTR [edx], 7
  0005b	ff 46 08	 inc	 DWORD PTR [esi+8]

; 6901 : 	m_Snapshot.ar << g_GuildCombatMng.m_uBestPlayer;

  0005e	8b 3d 4c 00 00
	00		 mov	 edi, DWORD PTR ?g_GuildCombatMng@@3VCGuildCombat@@A+76
  00064	6a 04		 push	 4
  00066	8b ce		 mov	 ecx, esi
  00068	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0006d	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00070	89 38		 mov	 DWORD PTR [eax], edi
  00072	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00075	83 c0 04	 add	 eax, 4
  00078	5f		 pop	 edi
  00079	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0007c	5e		 pop	 esi
$L300551:

; 6902 : 	
; 6903 : }

  0007d	c3		 ret	 0
?AddGCBestPlayer@CUser@@QAEXXZ ENDP			; CUser::AddGCBestPlayer
_TEXT	ENDS
PUBLIC	?AddGCDiagMessage@CUser@@QAEXPBD@Z		; CUser::AddGCDiagMessage
; Function compile flags: /Ogty
;	COMDAT ?AddGCDiagMessage@CUser@@QAEXPBD@Z
_TEXT	SEGMENT
_str$ = 8						; size = 4
?AddGCDiagMessage@CUser@@QAEXPBD@Z PROC NEAR		; CUser::AddGCDiagMessage, COMDAT
; _this$ = ecx

; 6941 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	75 6a		 jne	 SHORT $L283602

; 6942 : 	
; 6943 : 	m_Snapshot.cb++;

  00006	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  0000d	56		 push	 esi
  0000e	57		 push	 edi

; 6944 : 	m_Snapshot.ar << GetId();

  0000f	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  00015	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  0001b	6a 04		 push	 4
  0001d	8b ce		 mov	 ecx, esi
  0001f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00024	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00027	89 38		 mov	 DWORD PTR [eax], edi
  00029	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0002c	83 c2 04	 add	 edx, 4

; 6945 : 	m_Snapshot.ar << SNAPSHOTTYPE_GUILDCOMBAT;

  0002f	6a 02		 push	 2
  00031	8b ce		 mov	 ecx, esi
  00033	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00036	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003b	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003e	66 c7 01 b8 00	 mov	 WORD PTR [ecx], 184	; 000000b8H
  00043	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00046	83 c0 02	 add	 eax, 2

; 6946 : 	m_Snapshot.ar << GC_DIAGMESSAGE;

  00049	6a 01		 push	 1
  0004b	8b ce		 mov	 ecx, esi
  0004d	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00050	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00055	8b 56 08	 mov	 edx, DWORD PTR [esi+8]

; 6947 : 	m_Snapshot.ar.WriteString( str );

  00058	8b 44 24 0c	 mov	 eax, DWORD PTR _str$[esp+4]
  0005c	c6 02 33	 mov	 BYTE PTR [edx], 51	; 00000033H
  0005f	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00062	42		 inc	 edx
  00063	50		 push	 eax
  00064	8b ce		 mov	 ecx, esi
  00066	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00069	e8 00 00 00 00	 call	 ?WriteString@CAr@@QAEXPBD@Z ; CAr::WriteString
  0006e	5f		 pop	 edi
  0006f	5e		 pop	 esi
$L283602:

; 6948 : 	
; 6949 : }

  00070	c2 04 00	 ret	 4
?AddGCDiagMessage@CUser@@QAEXPBD@Z ENDP			; CUser::AddGCDiagMessage
_TEXT	ENDS
PUBLIC	?AddGCTele@CUser@@QAEXPBD@Z			; CUser::AddGCTele
; Function compile flags: /Ogty
;	COMDAT ?AddGCTele@CUser@@QAEXPBD@Z
_TEXT	SEGMENT
_str$ = 8						; size = 4
?AddGCTele@CUser@@QAEXPBD@Z PROC NEAR			; CUser::AddGCTele, COMDAT
; _this$ = ecx

; 6952 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	75 6a		 jne	 SHORT $L283608

; 6953 : 	
; 6954 : 	m_Snapshot.cb++;

  00006	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  0000d	56		 push	 esi
  0000e	57		 push	 edi

; 6955 : 	m_Snapshot.ar << GetId();

  0000f	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  00015	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  0001b	6a 04		 push	 4
  0001d	8b ce		 mov	 ecx, esi
  0001f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00024	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00027	89 38		 mov	 DWORD PTR [eax], edi
  00029	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0002c	83 c2 04	 add	 edx, 4

; 6956 : 	m_Snapshot.ar << SNAPSHOTTYPE_GUILDCOMBAT;

  0002f	6a 02		 push	 2
  00031	8b ce		 mov	 ecx, esi
  00033	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00036	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003b	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003e	66 c7 01 b8 00	 mov	 WORD PTR [ecx], 184	; 000000b8H
  00043	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00046	83 c0 02	 add	 eax, 2

; 6957 : 	m_Snapshot.ar << GC_TELE;

  00049	6a 01		 push	 1
  0004b	8b ce		 mov	 ecx, esi
  0004d	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00050	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00055	8b 56 08	 mov	 edx, DWORD PTR [esi+8]

; 6958 : 	m_Snapshot.ar.WriteString( str );

  00058	8b 44 24 0c	 mov	 eax, DWORD PTR _str$[esp+4]
  0005c	c6 02 34	 mov	 BYTE PTR [edx], 52	; 00000034H
  0005f	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00062	42		 inc	 edx
  00063	50		 push	 eax
  00064	8b ce		 mov	 ecx, esi
  00066	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00069	e8 00 00 00 00	 call	 ?WriteString@CAr@@QAEXPBD@Z ; CAr::WriteString
  0006e	5f		 pop	 edi
  0006f	5e		 pop	 esi
$L283608:

; 6959 : 	
; 6960 : }

  00070	c2 04 00	 ret	 4
?AddGCTele@CUser@@QAEXPBD@Z ENDP			; CUser::AddGCTele
_TEXT	ENDS
PUBLIC	?AddGuildCombatNextTime@CUser@@QAEXKK@Z		; CUser::AddGuildCombatNextTime
; Function compile flags: /Ogty
;	COMDAT ?AddGuildCombatNextTime@CUser@@QAEXKK@Z
_TEXT	SEGMENT
_dwTime$ = 8						; size = 4
_dwState$ = 12						; size = 4
?AddGuildCombatNextTime@CUser@@QAEXKK@Z PROC NEAR	; CUser::AddGuildCombatNextTime, COMDAT
; _this$ = ecx

; 6963 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	0f 85 94 00 00
	00		 jne	 $L300626

; 6964 : 	
; 6965 : 	m_Snapshot.cb++;

  0000a	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  00011	56		 push	 esi
  00012	57		 push	 edi

; 6966 : 	m_Snapshot.ar << GetId();

  00013	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  00019	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  0001f	6a 04		 push	 4
  00021	8b ce		 mov	 ecx, esi
  00023	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00028	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0002b	89 38		 mov	 DWORD PTR [eax], edi
  0002d	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00030	83 c0 04	 add	 eax, 4

; 6967 : 	m_Snapshot.ar << SNAPSHOTTYPE_GUILDCOMBAT;

  00033	6a 02		 push	 2
  00035	8b ce		 mov	 ecx, esi
  00037	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0003a	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003f	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00042	66 c7 01 b8 00	 mov	 WORD PTR [ecx], 184	; 000000b8H
  00047	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0004a	83 c2 02	 add	 edx, 2

; 6968 : 	m_Snapshot.ar << GC_NEXTTIMESTATE;

  0004d	6a 01		 push	 1
  0004f	8b ce		 mov	 ecx, esi
  00051	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00054	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00059	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0005c	c6 02 31	 mov	 BYTE PTR [edx], 49	; 00000031H
  0005f	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00062	40		 inc	 eax

; 6969 : 	m_Snapshot.ar << dwTime << dwState;

  00063	6a 04		 push	 4
  00065	8b ce		 mov	 ecx, esi
  00067	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0006a	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0006f	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00072	8b 4c 24 0c	 mov	 ecx, DWORD PTR _dwTime$[esp+4]
  00076	89 08		 mov	 DWORD PTR [eax], ecx
  00078	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0007b	83 c2 04	 add	 edx, 4
  0007e	6a 04		 push	 4
  00080	8b ce		 mov	 ecx, esi
  00082	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00085	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0008a	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0008d	8b 44 24 10	 mov	 eax, DWORD PTR _dwState$[esp+4]
  00091	89 02		 mov	 DWORD PTR [edx], eax
  00093	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00096	83 c0 04	 add	 eax, 4
  00099	5f		 pop	 edi
  0009a	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0009d	5e		 pop	 esi
$L300626:

; 6970 : 	
; 6971 : }

  0009e	c2 08 00	 ret	 8
?AddGuildCombatNextTime@CUser@@QAEXKK@Z ENDP		; CUser::AddGuildCombatNextTime
_TEXT	ENDS
PUBLIC	?AddGuildCombatEnterTime@CUser@@QAEXK@Z		; CUser::AddGuildCombatEnterTime
; Function compile flags: /Ogty
;	COMDAT ?AddGuildCombatEnterTime@CUser@@QAEXK@Z
_TEXT	SEGMENT
_dwTime$ = 8						; size = 4
?AddGuildCombatEnterTime@CUser@@QAEXK@Z PROC NEAR	; CUser::AddGuildCombatEnterTime, COMDAT
; _this$ = ecx

; 6974 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	75 79		 jne	 SHORT $L300650

; 6975 : 	
; 6976 : 	m_Snapshot.cb++;

  00006	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  0000d	56		 push	 esi
  0000e	57		 push	 edi

; 6977 : 	m_Snapshot.ar << GetId();

  0000f	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  00015	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  0001b	6a 04		 push	 4
  0001d	8b ce		 mov	 ecx, esi
  0001f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00024	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00027	89 38		 mov	 DWORD PTR [eax], edi
  00029	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0002c	83 c2 04	 add	 edx, 4

; 6978 : 	m_Snapshot.ar << SNAPSHOTTYPE_GUILDCOMBAT;

  0002f	6a 02		 push	 2
  00031	8b ce		 mov	 ecx, esi
  00033	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00036	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003b	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003e	66 c7 01 b8 00	 mov	 WORD PTR [ecx], 184	; 000000b8H
  00043	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00046	83 c0 02	 add	 eax, 2

; 6979 : 	m_Snapshot.ar << GC_ENTERTIME;

  00049	6a 01		 push	 1
  0004b	8b ce		 mov	 ecx, esi
  0004d	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00050	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00055	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00058	c6 02 32	 mov	 BYTE PTR [edx], 50	; 00000032H
  0005b	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0005e	42		 inc	 edx

; 6980 : 	m_Snapshot.ar << dwTime ;

  0005f	6a 04		 push	 4
  00061	8b ce		 mov	 ecx, esi
  00063	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00066	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0006b	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0006e	8b 4c 24 0c	 mov	 ecx, DWORD PTR _dwTime$[esp+4]
  00072	89 08		 mov	 DWORD PTR [eax], ecx
  00074	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00077	83 c0 04	 add	 eax, 4
  0007a	5f		 pop	 edi
  0007b	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0007e	5e		 pop	 esi
$L300650:

; 6981 : 	
; 6982 : }

  0007f	c2 04 00	 ret	 4
?AddGuildCombatEnterTime@CUser@@QAEXK@Z ENDP		; CUser::AddGuildCombatEnterTime
_TEXT	ENDS
PUBLIC	?AddGCWarPlayerlist@CUser@@QAEXXZ		; CUser::AddGCWarPlayerlist
EXTRN	?SerializeGCWarPlayerList@CGuildCombat@@QAEXAAVCAr@@@Z:NEAR ; CGuildCombat::SerializeGCWarPlayerList
; Function compile flags: /Ogty
;	COMDAT ?AddGCWarPlayerlist@CUser@@QAEXXZ
_TEXT	SEGMENT
?AddGCWarPlayerlist@CUser@@QAEXXZ PROC NEAR		; CUser::AddGCWarPlayerlist, COMDAT
; _this$ = ecx

; 6986 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	75 60		 jne	 SHORT $L283626

; 6987 : 	
; 6988 : 	m_Snapshot.cb++;

  00006	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  0000d	56		 push	 esi
  0000e	57		 push	 edi

; 6989 : 	m_Snapshot.ar << GetId();

  0000f	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  00015	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  0001b	6a 04		 push	 4
  0001d	8b ce		 mov	 ecx, esi
  0001f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00024	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00027	89 38		 mov	 DWORD PTR [eax], edi
  00029	83 46 08 04	 add	 DWORD PTR [esi+8], 4

; 6990 : 	m_Snapshot.ar << SNAPSHOTTYPE_GUILDCOMBAT;

  0002d	6a 02		 push	 2
  0002f	8b ce		 mov	 ecx, esi
  00031	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00036	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00039	66 c7 01 b8 00	 mov	 WORD PTR [ecx], 184	; 000000b8H
  0003e	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  00041	83 c7 02	 add	 edi, 2

; 6991 : 	m_Snapshot.ar << GC_WARPLAYERLIST;

  00044	6a 01		 push	 1
  00046	8b ce		 mov	 ecx, esi
  00048	89 7e 08	 mov	 DWORD PTR [esi+8], edi
  0004b	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00050	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00053	c6 02 11	 mov	 BYTE PTR [edx], 17	; 00000011H
  00056	ff 46 08	 inc	 DWORD PTR [esi+8]

; 6992 : 	g_GuildCombatMng.SerializeGCWarPlayerList( m_Snapshot.ar );

  00059	56		 push	 esi
  0005a	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_GuildCombatMng@@3VCGuildCombat@@A
  0005f	e8 00 00 00 00	 call	 ?SerializeGCWarPlayerList@CGuildCombat@@QAEXAAVCAr@@@Z ; CGuildCombat::SerializeGCWarPlayerList
  00064	5f		 pop	 edi
  00065	5e		 pop	 esi
$L283626:

; 6993 : 	
; 6994 : }

  00066	c3		 ret	 0
?AddGCWarPlayerlist@CUser@@QAEXXZ ENDP			; CUser::AddGCWarPlayerlist
_TEXT	ENDS
PUBLIC	?AddCtrlCoolTimeCancel@CUser@@QAEXXZ		; CUser::AddCtrlCoolTimeCancel
; Function compile flags: /Ogty
;	COMDAT ?AddCtrlCoolTimeCancel@CUser@@QAEXXZ
_TEXT	SEGMENT
?AddCtrlCoolTimeCancel@CUser@@QAEXXZ PROC NEAR		; CUser::AddCtrlCoolTimeCancel, COMDAT
; _this$ = ecx

; 6998 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	75 48		 jne	 SHORT $L300690

; 6999 : 	
; 7000 : 	m_Snapshot.cb++;

  00006	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  0000d	56		 push	 esi
  0000e	57		 push	 edi

; 7001 : 	m_Snapshot.ar << GetId();

  0000f	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  00015	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  0001b	6a 04		 push	 4
  0001d	8b ce		 mov	 ecx, esi
  0001f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00024	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00027	89 38		 mov	 DWORD PTR [eax], edi
  00029	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0002c	83 c2 04	 add	 edx, 4

; 7002 : 	m_Snapshot.ar << SNAPSHOTTYPE_EXPBOXCOLLTIMECANCEL;

  0002f	6a 02		 push	 2
  00031	8b ce		 mov	 ecx, esi
  00033	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00036	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003b	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003e	66 c7 01 bf 00	 mov	 WORD PTR [ecx], 191	; 000000bfH
  00043	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00046	83 c0 02	 add	 eax, 2
  00049	5f		 pop	 edi
  0004a	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0004d	5e		 pop	 esi
$L300690:

; 7003 : 	
; 7004 : }

  0004e	c3		 ret	 0
?AddCtrlCoolTimeCancel@CUser@@QAEXXZ ENDP		; CUser::AddCtrlCoolTimeCancel
_TEXT	ENDS
PUBLIC	?AddFocusObj@CUser@@QAEXK@Z			; CUser::AddFocusObj
; Function compile flags: /Ogty
;	COMDAT ?AddFocusObj@CUser@@QAEXK@Z
_TEXT	SEGMENT
_objid$ = 8						; size = 4
?AddFocusObj@CUser@@QAEXK@Z PROC NEAR			; CUser::AddFocusObj, COMDAT
; _this$ = ecx

; 7073 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	75 63		 jne	 SHORT $L300712

; 7074 : 	
; 7075 : 	m_Snapshot.cb++;

  00006	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  0000d	56		 push	 esi
  0000e	57		 push	 edi

; 7076 : 	m_Snapshot.ar << GetId();

  0000f	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  00015	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  0001b	6a 04		 push	 4
  0001d	8b ce		 mov	 ecx, esi
  0001f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00024	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00027	89 38		 mov	 DWORD PTR [eax], edi
  00029	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0002c	83 c0 04	 add	 eax, 4

; 7077 : 	m_Snapshot.ar << SNAPSHOTTYPE_FOCUSOBJ;

  0002f	6a 02		 push	 2
  00031	8b ce		 mov	 ecx, esi
  00033	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00036	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003b	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003e	66 c7 01 af 00	 mov	 WORD PTR [ecx], 175	; 000000afH
  00043	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00046	83 c2 02	 add	 edx, 2

; 7078 : 	m_Snapshot.ar << objid;

  00049	6a 04		 push	 4
  0004b	8b ce		 mov	 ecx, esi
  0004d	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00050	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00055	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00058	8b 44 24 0c	 mov	 eax, DWORD PTR _objid$[esp+4]
  0005c	89 02		 mov	 DWORD PTR [edx], eax
  0005e	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00061	83 c0 04	 add	 eax, 4
  00064	5f		 pop	 edi
  00065	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00068	5e		 pop	 esi
$L300712:

; 7079 : 	
; 7080 : }

  00069	c2 04 00	 ret	 4
?AddFocusObj@CUser@@QAEXK@Z ENDP			; CUser::AddFocusObj
_TEXT	ENDS
PUBLIC	?AddCallTheRoll@CUser@@QAEXXZ			; CUser::AddCallTheRoll
; Function compile flags: /Ogty
;	COMDAT ?AddCallTheRoll@CUser@@QAEXXZ
_TEXT	SEGMENT
$T300736 = -8						; size = 8
?AddCallTheRoll@CUser@@QAEXXZ PROC NEAR			; CUser::AddCallTheRoll, COMDAT
; _this$ = ecx

; 7533 : {

  00000	83 ec 08	 sub	 esp, 8
  00003	57		 push	 edi
  00004	8b f9		 mov	 edi, ecx

; 7534 : 	if( IsDelete() )	return;

  00006	f6 47 04 01	 test	 BYTE PTR [edi+4], 1
  0000a	75 65		 jne	 SHORT $L300735

; 7535 : 	m_Snapshot.cb++;

  0000c	66 ff 87 0c 57
	00 00		 inc	 WORD PTR [edi+22284]
  00013	53		 push	 ebx

; 7536 : 	m_Snapshot.ar << GetId();

  00014	8b 9f bc 01 00
	00		 mov	 ebx, DWORD PTR [edi+444]
  0001a	56		 push	 esi
  0001b	8d b7 f8 16 00
	00		 lea	 esi, DWORD PTR [edi+5880]
  00021	6a 04		 push	 4
  00023	8b ce		 mov	 ecx, esi
  00025	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0002a	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0002d	89 18		 mov	 DWORD PTR [eax], ebx
  0002f	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00032	83 c0 04	 add	 eax, 4

; 7537 : 	m_Snapshot.ar << SNAPSHOTTYPE_CALLTHEROLL;

  00035	6a 02		 push	 2
  00037	8b ce		 mov	 ecx, esi
  00039	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0003c	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00041	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00044	66 c7 01 3d 00	 mov	 WORD PTR [ecx], 61	; 0000003dH
  00049	83 46 08 02	 add	 DWORD PTR [esi+8], 2

; 7538 : #ifdef __EVENT_1101_2
; 7539 : 	m_Snapshot.ar << m_nEventFlag;

  0004d	8b 97 e0 95 00
	00		 mov	 edx, DWORD PTR [edi+38368]
  00053	8b 87 e4 95 00
	00		 mov	 eax, DWORD PTR [edi+38372]
  00059	6a 08		 push	 8
  0005b	8d 4c 24 10	 lea	 ecx, DWORD PTR $T300736[esp+24]
  0005f	51		 push	 ecx
  00060	8b ce		 mov	 ecx, esi
  00062	89 54 24 14	 mov	 DWORD PTR $T300736[esp+28], edx
  00066	89 44 24 18	 mov	 DWORD PTR $T300736[esp+32], eax
  0006a	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
  0006f	5e		 pop	 esi
  00070	5b		 pop	 ebx
$L300735:
  00071	5f		 pop	 edi

; 7540 : #else // __EVENT_1101_2
; 7541 : 	m_Snapshot.ar << m_dwEventFlag;
; 7542 : #endif // __EVENT_1101_2
; 7543 : }

  00072	83 c4 08	 add	 esp, 8
  00075	c3		 ret	 0
?AddCallTheRoll@CUser@@QAEXXZ ENDP			; CUser::AddCallTheRoll
_TEXT	ENDS
PUBLIC	?AddSealCharSet@CUser@@QAEXXZ			; CUser::AddSealCharSet
; Function compile flags: /Ogty
;	COMDAT ?AddSealCharSet@CUser@@QAEXXZ
_TEXT	SEGMENT
?AddSealCharSet@CUser@@QAEXXZ PROC NEAR			; CUser::AddSealCharSet, COMDAT
; _this$ = ecx

; 8049 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	75 48		 jne	 SHORT $L300753

; 8050 : 	
; 8051 : 	m_Snapshot.cb++;

  00006	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  0000d	56		 push	 esi
  0000e	57		 push	 edi

; 8052 : 	m_Snapshot.ar << GetId();

  0000f	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  00015	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  0001b	6a 04		 push	 4
  0001d	8b ce		 mov	 ecx, esi
  0001f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00024	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00027	89 38		 mov	 DWORD PTR [eax], edi
  00029	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0002c	83 c2 04	 add	 edx, 4

; 8053 : 	m_Snapshot.ar << SNAPSHOTTYPE_SEALCHARGET_REQ;

  0002f	6a 02		 push	 2
  00031	8b ce		 mov	 ecx, esi
  00033	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00036	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003b	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003e	66 c7 01 45 01	 mov	 WORD PTR [ecx], 325	; 00000145H
  00043	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00046	83 c0 02	 add	 eax, 2
  00049	5f		 pop	 edi
  0004a	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0004d	5e		 pop	 esi
$L300753:

; 8054 : }

  0004e	c3		 ret	 0
?AddSealCharSet@CUser@@QAEXXZ ENDP			; CUser::AddSealCharSet
_TEXT	ENDS
PUBLIC	?IsTeleportable@CUser@@QAEHXZ			; CUser::IsTeleportable
EXTRN	?GetSummonState@CMover@@QAEHXZ:NEAR		; CMover::GetSummonState
EXTRN	?IsGuildQuestRegion@CProject@@QAEHABUD3DXVECTOR3@@@Z:NEAR ; CProject::IsGuildQuestRegion
EXTRN	?GetInstance@CInstanceDungeonHelper@@SAPAV1@XZ:NEAR ; CInstanceDungeonHelper::GetInstance
; Function compile flags: /Ogty
;	COMDAT ?IsTeleportable@CUser@@QAEHXZ
_TEXT	SEGMENT
$T300759 = -12						; size = 12
?IsTeleportable@CUser@@QAEHXZ PROC NEAR			; CUser::IsTeleportable, COMDAT
; _this$ = ecx

; 8208 : {

  00000	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00003	56		 push	 esi
  00004	57		 push	 edi
  00005	8b f9		 mov	 edi, ecx

; 8209 : 	DWORD dwWorld	= GetWorld()->GetID();

  00007	8b 87 6c 01 00
	00		 mov	 eax, DWORD PTR [edi+364]
  0000d	8b 30		 mov	 esi, DWORD PTR [eax]

; 8210 : 	if( dwWorld == WI_WORLD_GUILDWAR
; 8211 : 		|| ( dwWorld >= WI_WORLD_GUILDWAR1TO1_0 &&  dwWorld <= WI_WORLD_GUILDWAR1TO1_L )
; 8212 : 		|| dwWorld == WI_DUNGEON_MUSCLE
; 8213 : 		|| dwWorld == WI_DUNGEON_KRRR
; 8214 : 		|| dwWorld == WI_DUNGEON_BEAR
; 8215 : 		|| dwWorld == WI_WORLD_KEBARAS
; 8216 : 		|| ( dwWorld == WI_WORLD_MADRIGAL && prj.IsGuildQuestRegion( GetPos() ) )
; 8217 : 		|| dwWorld == WI_DUNGEON_SECRET_0
; 8218 : 		|| ( dwWorld >= WI_DUNGEON_SECRET_1 && dwWorld <= WI_DUNGEON_SECRET_L )
; 8219 : 		|| dwWorld == WI_WORLD_CISLAND	// 2008.01.21    
; 8220 : //		|| ( dwWorld >= WI_WORLD_HEAVEN01 && dwWorld <= WI_WORLD_HEAVEN05 )
; 8221 : #if __VER >= 14 // __INSTANCE_DUNGEON
; 8222 : 		|| CInstanceDungeonHelper::GetInstance()->IsInstanceDungeon( dwWorld )
; 8223 : #endif // __INSTANCE_DUNGEON
; 8224 : #ifdef __QUIZ
; 8225 : 		|| dwWorld == WI_WORLD_QUIZ
; 8226 : #endif // __QUIZ
; 8227 : 	)

  0000f	81 fe ca 00 00
	00		 cmp	 esi, 202		; 000000caH
  00015	74 4d		 je	 SHORT $L285254
  00017	81 fe f1 00 00
	00		 cmp	 esi, 241		; 000000f1H
  0001d	72 08		 jb	 SHORT $L285255
  0001f	81 fe f4 00 00
	00		 cmp	 esi, 244		; 000000f4H
  00025	76 3d		 jbe	 SHORT $L285254
$L285255:
  00027	81 fe d2 00 00
	00		 cmp	 esi, 210		; 000000d2H
  0002d	74 35		 je	 SHORT $L285254
  0002f	81 fe dc 00 00
	00		 cmp	 esi, 220		; 000000dcH
  00035	74 2d		 je	 SHORT $L285254
  00037	81 fe e6 00 00
	00		 cmp	 esi, 230		; 000000e6H
  0003d	74 25		 je	 SHORT $L285254
  0003f	83 fe 02	 cmp	 esi, 2
  00042	74 20		 je	 SHORT $L285254
  00044	83 fe 01	 cmp	 esi, 1
  00047	75 23		 jne	 SHORT $L285256
  00049	8d 4c 24 08	 lea	 ecx, DWORD PTR $T300759[esp+20]
  0004d	51		 push	 ecx
  0004e	8b cf		 mov	 ecx, edi
  00050	e8 00 00 00 00	 call	 ?GetPos@CObj@@QAE?AUD3DXVECTOR3@@XZ ; CObj::GetPos
  00055	50		 push	 eax
  00056	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?prj@@3VCProject@@A
  0005b	e8 00 00 00 00	 call	 ?IsGuildQuestRegion@CProject@@QAEHABUD3DXVECTOR3@@@Z ; CProject::IsGuildQuestRegion
  00060	85 c0		 test	 eax, eax
  00062	74 25		 je	 SHORT $L300768
$L285254:
  00064	5f		 pop	 edi

; 8228 : 		return FALSE;

  00065	33 c0		 xor	 eax, eax
  00067	5e		 pop	 esi

; 8230 : }

  00068	83 c4 0c	 add	 esp, 12			; 0000000cH
  0006b	c3		 ret	 0
$L285256:

; 8210 : 	if( dwWorld == WI_WORLD_GUILDWAR
; 8211 : 		|| ( dwWorld >= WI_WORLD_GUILDWAR1TO1_0 &&  dwWorld <= WI_WORLD_GUILDWAR1TO1_L )
; 8212 : 		|| dwWorld == WI_DUNGEON_MUSCLE
; 8213 : 		|| dwWorld == WI_DUNGEON_KRRR
; 8214 : 		|| dwWorld == WI_DUNGEON_BEAR
; 8215 : 		|| dwWorld == WI_WORLD_KEBARAS
; 8216 : 		|| ( dwWorld == WI_WORLD_MADRIGAL && prj.IsGuildQuestRegion( GetPos() ) )
; 8217 : 		|| dwWorld == WI_DUNGEON_SECRET_0
; 8218 : 		|| ( dwWorld >= WI_DUNGEON_SECRET_1 && dwWorld <= WI_DUNGEON_SECRET_L )
; 8219 : 		|| dwWorld == WI_WORLD_CISLAND	// 2008.01.21    
; 8220 : //		|| ( dwWorld >= WI_WORLD_HEAVEN01 && dwWorld <= WI_WORLD_HEAVEN05 )
; 8221 : #if __VER >= 14 // __INSTANCE_DUNGEON
; 8222 : 		|| CInstanceDungeonHelper::GetInstance()->IsInstanceDungeon( dwWorld )
; 8223 : #endif // __INSTANCE_DUNGEON
; 8224 : #ifdef __QUIZ
; 8225 : 		|| dwWorld == WI_WORLD_QUIZ
; 8226 : #endif // __QUIZ
; 8227 : 	)

  0006c	81 fe 97 00 00
	00		 cmp	 esi, 151		; 00000097H
  00072	74 f0		 je	 SHORT $L285254
  00074	81 fe 98 00 00
	00		 cmp	 esi, 152		; 00000098H
  0007a	72 08		 jb	 SHORT $L285257
  0007c	81 fe a7 00 00
	00		 cmp	 esi, 167		; 000000a7H
  00082	76 e0		 jbe	 SHORT $L285254
$L285257:
  00084	83 fe 03	 cmp	 esi, 3
  00087	74 db		 je	 SHORT $L285254
$L300768:
  00089	56		 push	 esi
  0008a	e8 00 00 00 00	 call	 ?GetInstance@CInstanceDungeonHelper@@SAPAV1@XZ ; CInstanceDungeonHelper::GetInstance
  0008f	8b c8		 mov	 ecx, eax
  00091	e8 00 00 00 00	 call	 ?IsInstanceDungeon@CInstanceDungeonHelper@@QAEHK@Z ; CInstanceDungeonHelper::IsInstanceDungeon
  00096	85 c0		 test	 eax, eax
  00098	75 ca		 jne	 SHORT $L285254
  0009a	81 fe d3 00 00
	00		 cmp	 esi, 211		; 000000d3H
  000a0	74 c2		 je	 SHORT $L285254

; 8229 : 	return ( GetSummonState() == 0 );

  000a2	8b cf		 mov	 ecx, edi
  000a4	e8 00 00 00 00	 call	 ?GetSummonState@CMover@@QAEHXZ ; CMover::GetSummonState
  000a9	f7 d8		 neg	 eax
  000ab	1b c0		 sbb	 eax, eax
  000ad	5f		 pop	 edi
  000ae	40		 inc	 eax
  000af	5e		 pop	 esi

; 8230 : }

  000b0	83 c4 0c	 add	 esp, 12			; 0000000cH
  000b3	c3		 ret	 0
?IsTeleportable@CUser@@QAEHXZ ENDP			; CUser::IsTeleportable
_TEXT	ENDS
PUBLIC	?AddTaxInfo@CUser@@QAEXXZ			; CUser::AddTaxInfo
EXTRN	?GetInstance@CTax@@SAPAV1@XZ:NEAR		; CTax::GetInstance
EXTRN	?Serialize@CTax@@QAEXAAVCAr@@@Z:NEAR		; CTax::Serialize
; Function compile flags: /Ogty
;	COMDAT ?AddTaxInfo@CUser@@QAEXXZ
_TEXT	SEGMENT
?AddTaxInfo@CUser@@QAEXXZ PROC NEAR			; CUser::AddTaxInfo, COMDAT
; _this$ = ecx

; 8358 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	75 55		 jne	 SHORT $L285382

; 8359 : 	m_Snapshot.cb++;

  00006	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  0000d	56		 push	 esi
  0000e	57		 push	 edi

; 8360 : 	m_Snapshot.ar << GetId();

  0000f	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  00015	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  0001b	6a 04		 push	 4
  0001d	8b ce		 mov	 ecx, esi
  0001f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00024	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00027	89 38		 mov	 DWORD PTR [eax], edi
  00029	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  0002c	83 c7 04	 add	 edi, 4

; 8361 : 	m_Snapshot.ar << SNAPSHOTTYPE_TAX_ALLINFO;

  0002f	6a 02		 push	 2
  00031	8b ce		 mov	 ecx, esi
  00033	89 7e 08	 mov	 DWORD PTR [esi+8], edi
  00036	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003b	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003e	66 c7 01 00 04	 mov	 WORD PTR [ecx], 1024	; 00000400H
  00043	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00046	83 c1 02	 add	 ecx, 2

; 8362 : 	CTax::GetInstance()->Serialize( m_Snapshot.ar );

  00049	56		 push	 esi
  0004a	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  0004d	e8 00 00 00 00	 call	 ?GetInstance@CTax@@SAPAV1@XZ ; CTax::GetInstance
  00052	8b c8		 mov	 ecx, eax
  00054	e8 00 00 00 00	 call	 ?Serialize@CTax@@QAEXAAVCAr@@@Z ; CTax::Serialize
  00059	5f		 pop	 edi
  0005a	5e		 pop	 esi
$L285382:

; 8363 : }

  0005b	c3		 ret	 0
?AddTaxInfo@CUser@@QAEXXZ ENDP				; CUser::AddTaxInfo
_TEXT	ENDS
PUBLIC	?AddRainbowRaceState@CUser@@QAEXPAVCRainbowRace@@@Z ; CUser::AddRainbowRaceState
EXTRN	?Serialize@CRainbowRace@@QAEXAAVCAr@@@Z:NEAR	; CRainbowRace::Serialize
; Function compile flags: /Ogty
;	COMDAT ?AddRainbowRaceState@CUser@@QAEXPAVCRainbowRace@@@Z
_TEXT	SEGMENT
_pRainbowRace$ = 8					; size = 4
?AddRainbowRaceState@CUser@@QAEXPAVCRainbowRace@@@Z PROC NEAR ; CUser::AddRainbowRaceState, COMDAT
; _this$ = ecx

; 8413 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	75 4d		 jne	 SHORT $L285429

; 8414 : 	m_Snapshot.cb++;

  00006	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  0000d	56		 push	 esi
  0000e	57		 push	 edi

; 8415 : 	m_Snapshot.ar << GetId();

  0000f	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  00015	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  0001b	6a 04		 push	 4
  0001d	8b ce		 mov	 ecx, esi
  0001f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00024	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00027	89 38		 mov	 DWORD PTR [eax], edi
  00029	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  0002c	83 c7 04	 add	 edi, 4

; 8416 : 	m_Snapshot.ar << SNAPSHOTTYPE_RAINBOWRACE_NOWSTATE;

  0002f	6a 02		 push	 2
  00031	8b ce		 mov	 ecx, esi
  00033	89 7e 08	 mov	 DWORD PTR [esi+8], edi
  00036	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003b	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003e	66 c7 01 02 90	 mov	 WORD PTR [ecx], 36866	; 00009002H
  00043	83 46 08 02	 add	 DWORD PTR [esi+8], 2

; 8417 : 	pRainbowRace->Serialize( m_Snapshot.ar );

  00047	8b 4c 24 0c	 mov	 ecx, DWORD PTR _pRainbowRace$[esp+4]
  0004b	56		 push	 esi
  0004c	e8 00 00 00 00	 call	 ?Serialize@CRainbowRace@@QAEXAAVCAr@@@Z ; CRainbowRace::Serialize
  00051	5f		 pop	 edi
  00052	5e		 pop	 esi
$L285429:

; 8418 : }

  00053	c2 04 00	 ret	 4
?AddRainbowRaceState@CUser@@QAEXPAVCRainbowRace@@@Z ENDP ; CUser::AddRainbowRaceState
_TEXT	ENDS
PUBLIC	?AddHousingAllInfo@CUser@@QAEXPAVCHousing@@@Z	; CUser::AddHousingAllInfo
EXTRN	?Serialize@CHousing@@QAEXAAVCAr@@@Z:NEAR	; CHousing::Serialize
; Function compile flags: /Ogty
;	COMDAT ?AddHousingAllInfo@CUser@@QAEXPAVCHousing@@@Z
_TEXT	SEGMENT
_pHousing$ = 8						; size = 4
?AddHousingAllInfo@CUser@@QAEXPAVCHousing@@@Z PROC NEAR	; CUser::AddHousingAllInfo, COMDAT
; _this$ = ecx

; 8442 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	75 4d		 jne	 SHORT $L285449

; 8443 : 	m_Snapshot.cb++;

  00006	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  0000d	56		 push	 esi
  0000e	57		 push	 edi

; 8444 : 	m_Snapshot.ar << GetId();

  0000f	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  00015	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  0001b	6a 04		 push	 4
  0001d	8b ce		 mov	 ecx, esi
  0001f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00024	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00027	89 38		 mov	 DWORD PTR [eax], edi
  00029	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  0002c	83 c7 04	 add	 edi, 4

; 8445 : 	m_Snapshot.ar << SNAPSHOTTYPE_HOUSING_ALLINFO;

  0002f	6a 02		 push	 2
  00031	8b ce		 mov	 ecx, esi
  00033	89 7e 08	 mov	 DWORD PTR [esi+8], edi
  00036	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003b	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003e	66 c7 01 00 92	 mov	 WORD PTR [ecx], 37376	; 00009200H
  00043	83 46 08 02	 add	 DWORD PTR [esi+8], 2

; 8446 : 	pHousing->Serialize( m_Snapshot.ar );

  00047	8b 4c 24 0c	 mov	 ecx, DWORD PTR _pHousing$[esp+4]
  0004b	56		 push	 esi
  0004c	e8 00 00 00 00	 call	 ?Serialize@CHousing@@QAEXAAVCAr@@@Z ; CHousing::Serialize
  00051	5f		 pop	 edi
  00052	5e		 pop	 esi
$L285449:

; 8447 : }

  00053	c2 04 00	 ret	 4
?AddHousingAllInfo@CUser@@QAEXPAVCHousing@@@Z ENDP	; CUser::AddHousingAllInfo
_TEXT	ENDS
PUBLIC	?AddNPCPos@CUser@@QAEXABUD3DXVECTOR3@@@Z	; CUser::AddNPCPos
; Function compile flags: /Ogty
;	COMDAT ?AddNPCPos@CUser@@QAEXABUD3DXVECTOR3@@@Z
_TEXT	SEGMENT
$T300844 = -12						; size = 12
_vPos$ = 8						; size = 4
?AddNPCPos@CUser@@QAEXABUD3DXVECTOR3@@@Z PROC NEAR	; CUser::AddNPCPos, COMDAT
; _this$ = ecx

; 8515 : 	if( IsDelete() )	return;

  00000	8a 41 04	 mov	 al, BYTE PTR [ecx+4]
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	a8 01		 test	 al, 1
  00008	75 64		 jne	 SHORT $L300842

; 8516 : 	m_Snapshot.cb++;

  0000a	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  00011	56		 push	 esi
  00012	57		 push	 edi

; 8517 : 	m_Snapshot.ar << GetId();

  00013	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  00019	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  0001f	6a 04		 push	 4
  00021	8b ce		 mov	 ecx, esi
  00023	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00028	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0002b	89 38		 mov	 DWORD PTR [eax], edi
  0002d	83 46 08 04	 add	 DWORD PTR [esi+8], 4

; 8518 : 	m_Snapshot.ar << SNAPSHOTTYPE_QUESTHELPER_NPCPOS;

  00031	6a 02		 push	 2
  00033	8b ce		 mov	 ecx, esi
  00035	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003a	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]

; 8519 : 	m_Snapshot.ar << vPos;

  0003d	8b 54 24 18	 mov	 edx, DWORD PTR _vPos$[esp+16]
  00041	66 c7 01 00 94	 mov	 WORD PTR [ecx], 37888	; 00009400H
  00046	83 46 08 02	 add	 DWORD PTR [esi+8], 2
  0004a	8b 02		 mov	 eax, DWORD PTR [edx]
  0004c	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  0004f	8b 52 08	 mov	 edx, DWORD PTR [edx+8]
  00052	89 44 24 08	 mov	 DWORD PTR $T300844[esp+20], eax
  00056	6a 0c		 push	 12			; 0000000cH
  00058	8d 44 24 0c	 lea	 eax, DWORD PTR $T300844[esp+24]
  0005c	89 4c 24 10	 mov	 DWORD PTR $T300844[esp+28], ecx
  00060	50		 push	 eax
  00061	8b ce		 mov	 ecx, esi
  00063	89 54 24 18	 mov	 DWORD PTR $T300844[esp+36], edx
  00067	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
  0006c	5f		 pop	 edi
  0006d	5e		 pop	 esi
$L300842:

; 8520 : }

  0006e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00071	c2 04 00	 ret	 4
?AddNPCPos@CUser@@QAEXABUD3DXVECTOR3@@@Z ENDP		; CUser::AddNPCPos
_TEXT	ENDS
PUBLIC	?AddClearTarget@CUser@@QAEXXZ			; CUser::AddClearTarget
; Function compile flags: /Ogty
;	COMDAT ?AddClearTarget@CUser@@QAEXXZ
_TEXT	SEGMENT
?AddClearTarget@CUser@@QAEXXZ PROC NEAR			; CUser::AddClearTarget, COMDAT
; _this$ = ecx

; 8525 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	75 48		 jne	 SHORT $L300861

; 8526 : 	m_Snapshot.cb++;

  00006	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  0000d	56		 push	 esi
  0000e	57		 push	 edi

; 8527 : 	m_Snapshot.ar << GetId();

  0000f	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  00015	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  0001b	6a 04		 push	 4
  0001d	8b ce		 mov	 ecx, esi
  0001f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00024	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00027	89 38		 mov	 DWORD PTR [eax], edi
  00029	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0002c	83 c2 04	 add	 edx, 4

; 8528 : 	m_Snapshot.ar << SNAPSHOTTYPE_CLEAR_TARGET;

  0002f	6a 02		 push	 2
  00031	8b ce		 mov	 ecx, esi
  00033	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00036	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003b	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003e	66 c7 01 00 95	 mov	 WORD PTR [ecx], 38144	; 00009500H
  00043	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00046	83 c0 02	 add	 eax, 2
  00049	5f		 pop	 edi
  0004a	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0004d	5e		 pop	 esi
$L300861:

; 8529 : }

  0004e	c3		 ret	 0
?AddClearTarget@CUser@@QAEXXZ ENDP			; CUser::AddClearTarget
_TEXT	ENDS
PUBLIC	?AddPCBangInfo@CUser@@QAEXPAVCPCBangInfo@@@Z	; CUser::AddPCBangInfo
EXTRN	?Serialize@CPCBangInfo@@QAEXAAVCAr@@@Z:NEAR	; CPCBangInfo::Serialize
; Function compile flags: /Ogty
;	COMDAT ?AddPCBangInfo@CUser@@QAEXPAVCPCBangInfo@@@Z
_TEXT	SEGMENT
_pPI$ = 8						; size = 4
?AddPCBangInfo@CUser@@QAEXPAVCPCBangInfo@@@Z PROC NEAR	; CUser::AddPCBangInfo, COMDAT
; _this$ = ecx

; 8585 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	75 4d		 jne	 SHORT $L285554

; 8586 : 	m_Snapshot.cb++;

  00006	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  0000d	56		 push	 esi
  0000e	57		 push	 edi

; 8587 : 	m_Snapshot.ar << GetId();

  0000f	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  00015	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  0001b	6a 04		 push	 4
  0001d	8b ce		 mov	 ecx, esi
  0001f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00024	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00027	89 38		 mov	 DWORD PTR [eax], edi
  00029	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  0002c	83 c7 04	 add	 edi, 4

; 8588 : 	m_Snapshot.ar << SNAPSHOTTYPE_PCBANG_INFO;

  0002f	6a 02		 push	 2
  00031	8b ce		 mov	 ecx, esi
  00033	89 7e 08	 mov	 DWORD PTR [esi+8], edi
  00036	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003b	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003e	66 c7 01 10 98	 mov	 WORD PTR [ecx], 38928	; 00009810H
  00043	83 46 08 02	 add	 DWORD PTR [esi+8], 2

; 8589 : 	pPI->Serialize( m_Snapshot.ar );

  00047	8b 4c 24 0c	 mov	 ecx, DWORD PTR _pPI$[esp+4]
  0004b	56		 push	 esi
  0004c	e8 00 00 00 00	 call	 ?Serialize@CPCBangInfo@@QAEXAAVCAr@@@Z ; CPCBangInfo::Serialize
  00051	5f		 pop	 edi
  00052	5e		 pop	 esi
$L285554:

; 8590 : }

  00053	c2 04 00	 ret	 4
?AddPCBangInfo@CUser@@QAEXPAVCPCBangInfo@@@Z ENDP	; CUser::AddPCBangInfo
_TEXT	ENDS
PUBLIC	?AddSmeltSafety@CUser@@QAEXE@Z			; CUser::AddSmeltSafety
; Function compile flags: /Ogty
;	COMDAT ?AddSmeltSafety@CUser@@QAEXE@Z
_TEXT	SEGMENT
_nResult$ = 8						; size = 1
?AddSmeltSafety@CUser@@QAEXE@Z PROC NEAR		; CUser::AddSmeltSafety, COMDAT
; _this$ = ecx

; 8621 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	75 61		 jne	 SHORT $L300901

; 8622 : 	
; 8623 : 	m_Snapshot.cb++;

  00006	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  0000d	56		 push	 esi
  0000e	57		 push	 edi

; 8624 : 	m_Snapshot.ar << GetId();

  0000f	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  00015	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  0001b	6a 04		 push	 4
  0001d	8b ce		 mov	 ecx, esi
  0001f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00024	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00027	89 38		 mov	 DWORD PTR [eax], edi
  00029	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0002c	83 c0 04	 add	 eax, 4

; 8625 : 	m_Snapshot.ar << SNAPSHOTTYPE_SMELT_SAFETY;

  0002f	6a 02		 push	 2
  00031	8b ce		 mov	 ecx, esi
  00033	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00036	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003b	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003e	66 c7 01 00 99	 mov	 WORD PTR [ecx], 39168	; 00009900H
  00043	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00046	83 c2 02	 add	 edx, 2

; 8626 : 	m_Snapshot.ar << nResult;

  00049	6a 01		 push	 1
  0004b	8b ce		 mov	 ecx, esi
  0004d	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00050	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00055	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00058	8a 44 24 0c	 mov	 al, BYTE PTR _nResult$[esp+4]
  0005c	88 02		 mov	 BYTE PTR [edx], al
  0005e	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00061	40		 inc	 eax
  00062	5f		 pop	 edi
  00063	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00066	5e		 pop	 esi
$L300901:

; 8627 : }

  00067	c2 04 00	 ret	 4
?AddSmeltSafety@CUser@@QAEXE@Z ENDP			; CUser::AddSmeltSafety
_TEXT	ENDS
PUBLIC	?AddWorldReadInfo@CUser@@QAEXKUD3DXVECTOR3@@@Z	; CUser::AddWorldReadInfo
; Function compile flags: /Ogty
;	COMDAT ?AddWorldReadInfo@CUser@@QAEXKUD3DXVECTOR3@@@Z
_TEXT	SEGMENT
$T300929 = -12						; size = 12
_dwWorldId$ = 8						; size = 4
_vPos$ = 12						; size = 12
?AddWorldReadInfo@CUser@@QAEXKUD3DXVECTOR3@@@Z PROC NEAR ; CUser::AddWorldReadInfo, COMDAT
; _this$ = ecx

; 8633 : 	if( IsDelete() )	return;

  00000	8a 41 04	 mov	 al, BYTE PTR [ecx+4]
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	a8 01		 test	 al, 1
  00008	0f 85 89 00 00
	00		 jne	 $L300927

; 8634 : 	
; 8635 : 	m_Snapshot.cb++;

  0000e	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  00015	56		 push	 esi
  00016	57		 push	 edi

; 8636 : 	m_Snapshot.ar << GetId();

  00017	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  0001d	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  00023	6a 04		 push	 4
  00025	8b ce		 mov	 ecx, esi
  00027	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0002c	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0002f	89 38		 mov	 DWORD PTR [eax], edi
  00031	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00034	83 c2 04	 add	 edx, 4

; 8637 : 	m_Snapshot.ar << SNAPSHOTTYPE_WORLD_READINFO;

  00037	6a 02		 push	 2
  00039	8b ce		 mov	 ecx, esi
  0003b	89 56 08	 mov	 DWORD PTR [esi+8], edx
  0003e	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00043	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00046	66 c7 01 10 99	 mov	 WORD PTR [ecx], 39184	; 00009910H
  0004b	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0004e	83 c0 02	 add	 eax, 2

; 8638 : 	m_Snapshot.ar << dwWorldId << vPos;

  00051	6a 04		 push	 4
  00053	8b ce		 mov	 ecx, esi
  00055	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00058	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0005d	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00060	8b 44 24 18	 mov	 eax, DWORD PTR _dwWorldId$[esp+16]
  00064	8b 4c 24 1c	 mov	 ecx, DWORD PTR _vPos$[esp+16]
  00068	89 02		 mov	 DWORD PTR [edx], eax
  0006a	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0006d	8b 44 24 24	 mov	 eax, DWORD PTR _vPos$[esp+24]
  00071	83 c2 04	 add	 edx, 4
  00074	89 4c 24 08	 mov	 DWORD PTR $T300929[esp+20], ecx
  00078	6a 0c		 push	 12			; 0000000cH
  0007a	8d 4c 24 0c	 lea	 ecx, DWORD PTR $T300929[esp+24]
  0007e	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00081	8b 54 24 24	 mov	 edx, DWORD PTR _vPos$[esp+24]
  00085	51		 push	 ecx
  00086	8b ce		 mov	 ecx, esi
  00088	89 54 24 14	 mov	 DWORD PTR $T300929[esp+32], edx
  0008c	89 44 24 18	 mov	 DWORD PTR $T300929[esp+36], eax
  00090	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
  00095	5f		 pop	 edi
  00096	5e		 pop	 esi
$L300927:

; 8639 : }

  00097	83 c4 0c	 add	 esp, 12			; 0000000cH
  0009a	c2 10 00	 ret	 16			; 00000010H
?AddWorldReadInfo@CUser@@QAEXKUD3DXVECTOR3@@@Z ENDP	; CUser::AddWorldReadInfo
_TEXT	ENDS
PUBLIC	?AddActivateVisPet@CUser@@QAEXKK@Z		; CUser::AddActivateVisPet
; Function compile flags: /Ogty
;	COMDAT ?AddActivateVisPet@CUser@@QAEXKK@Z
_TEXT	SEGMENT
_objIdVisPetItem$ = 8					; size = 4
_objIdVisPetId$ = 12					; size = 4
?AddActivateVisPet@CUser@@QAEXKK@Z PROC NEAR		; CUser::AddActivateVisPet, COMDAT
; _this$ = ecx

; 8682 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	75 7e		 jne	 SHORT $L300953

; 8683 : 	
; 8684 : 	m_Snapshot.cb++;

  00006	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  0000d	56		 push	 esi
  0000e	57		 push	 edi

; 8685 : 	m_Snapshot.ar << GetId();

  0000f	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  00015	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  0001b	6a 04		 push	 4
  0001d	8b ce		 mov	 ecx, esi
  0001f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00024	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00027	89 38		 mov	 DWORD PTR [eax], edi
  00029	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0002c	83 c2 04	 add	 edx, 4

; 8686 : 	m_Snapshot.ar << SNAPSHOTTYPE_VISPET_ACTIVATE;

  0002f	6a 02		 push	 2
  00031	8b ce		 mov	 ecx, esi
  00033	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00036	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003b	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003e	66 c7 01 01 88	 mov	 WORD PTR [ecx], 34817	; 00008801H
  00043	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00046	83 c0 02	 add	 eax, 2

; 8687 : 	m_Snapshot.ar << objIdVisPetItem << objIdVisPetId;

  00049	6a 04		 push	 4
  0004b	8b ce		 mov	 ecx, esi
  0004d	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00050	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00055	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00058	8b 44 24 0c	 mov	 eax, DWORD PTR _objIdVisPetItem$[esp+4]
  0005c	89 02		 mov	 DWORD PTR [edx], eax
  0005e	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00061	83 c2 04	 add	 edx, 4
  00064	6a 04		 push	 4
  00066	8b ce		 mov	 ecx, esi
  00068	89 56 08	 mov	 DWORD PTR [esi+8], edx
  0006b	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00070	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00073	8b 54 24 10	 mov	 edx, DWORD PTR _objIdVisPetId$[esp+4]
  00077	89 11		 mov	 DWORD PTR [ecx], edx
  00079	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0007c	83 c0 04	 add	 eax, 4
  0007f	5f		 pop	 edi
  00080	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00083	5e		 pop	 esi
$L300953:

; 8688 : }

  00084	c2 08 00	 ret	 8
?AddActivateVisPet@CUser@@QAEXKK@Z ENDP			; CUser::AddActivateVisPet
_TEXT	ENDS
PUBLIC	?AddGuildHouseRemvoe@CUser@@QAEXXZ		; CUser::AddGuildHouseRemvoe
; Function compile flags: /Ogty
;	COMDAT ?AddGuildHouseRemvoe@CUser@@QAEXXZ
_TEXT	SEGMENT
?AddGuildHouseRemvoe@CUser@@QAEXXZ PROC NEAR		; CUser::AddGuildHouseRemvoe, COMDAT
; _this$ = ecx

; 8735 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	75 48		 jne	 SHORT $L300970

; 8736 : 	m_Snapshot.cb++;

  00006	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  0000d	56		 push	 esi
  0000e	57		 push	 edi

; 8737 : 	m_Snapshot.ar << GetId();

  0000f	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  00015	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  0001b	6a 04		 push	 4
  0001d	8b ce		 mov	 ecx, esi
  0001f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00024	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00027	89 38		 mov	 DWORD PTR [eax], edi
  00029	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0002c	83 c2 04	 add	 edx, 4

; 8738 : 	m_Snapshot.ar << SNAPSHOTTYPE_GUILDHOUSE_REMOVE;

  0002f	6a 02		 push	 2
  00031	8b ce		 mov	 ecx, esi
  00033	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00036	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003b	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003e	66 c7 01 13 88	 mov	 WORD PTR [ecx], 34835	; 00008813H
  00043	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00046	83 c0 02	 add	 eax, 2
  00049	5f		 pop	 edi
  0004a	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0004d	5e		 pop	 esi
$L300970:

; 8739 : }

  0004e	c3		 ret	 0
?AddGuildHouseRemvoe@CUser@@QAEXXZ ENDP			; CUser::AddGuildHouseRemvoe
_TEXT	ENDS
PUBLIC	?GetAddExpAfterApplyRestPoint@CUser@@QAE_J_J@Z	; CUser::GetAddExpAfterApplyRestPoint
PUBLIC	__real@49742400
EXTRN	?GetRestExpFactor@CGuildHouseMng@@QAEMH@Z:NEAR	; CGuildHouseMng::GetRestExpFactor
;	COMDAT __real@49742400
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.h
CONST	SEGMENT
__real@49742400 DD 049742400r			; 1e+006
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
CONST	ENDS
;	COMDAT ?GetAddExpAfterApplyRestPoint@CUser@@QAE_J_J@Z
_TEXT	SEGMENT
tv78 = 8						; size = 8
_fTemp$285655 = 8					; size = 8
_nExp$ = 8						; size = 8
?GetAddExpAfterApplyRestPoint@CUser@@QAE_J_J@Z PROC NEAR ; CUser::GetAddExpAfterApplyRestPoint, COMDAT
; _this$ = ecx

; 8742 : {

  00000	53		 push	 ebx
  00001	55		 push	 ebp
  00002	56		 push	 esi
  00003	57		 push	 edi
  00004	8b f9		 mov	 edi, ecx

; 8743 : 	if( m_nRestPoint > 0 )

  00006	8b 87 a8 96 00
	00		 mov	 eax, DWORD PTR [edi+38568]
  0000c	85 c0		 test	 eax, eax
  0000e	0f 8e cf 00 00
	00		 jle	 $L285664

; 8744 : 	{
; 8745 : 		EXPINTEGER nAddExp = (EXPINTEGER)( nExp * GuildHouseMng->GetRestExpFactor( m_nLevel ) );	//   .

  00014	8b 87 e0 05 00
	00		 mov	 eax, DWORD PTR [edi+1504]
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 ?GetInstance@CGuildHouseMng@@SAPAV1@XZ ; CGuildHouseMng::GetInstance
  00020	8b c8		 mov	 ecx, eax
  00022	e8 00 00 00 00	 call	 ?GetRestExpFactor@CGuildHouseMng@@QAEMH@Z ; CGuildHouseMng::GetRestExpFactor
  00027	df 6c 24 14	 fild	 QWORD PTR _nExp$[esp+12]
  0002b	de c9		 fmulp	 ST(1), ST(0)
  0002d	e8 00 00 00 00	 call	 __ftol2

; 8746 : 		EXPFLOAT fTemp = static_cast<EXPFLOAT>( nExp * min( m_nLevel / 5, 1 ) ) / static_cast<EXPFLOAT>( prj.m_aExpCharacter[m_nLevel + 1].nExp1 );

  00032	8b b7 e0 05 00
	00		 mov	 esi, DWORD PTR [edi+1504]
  00038	8b d8		 mov	 ebx, eax
  0003a	8b ea		 mov	 ebp, edx
  0003c	b8 67 66 66 66	 mov	 eax, 1717986919		; 66666667H
  00041	f7 ee		 imul	 esi
  00043	d1 fa		 sar	 edx, 1
  00045	8b c2		 mov	 eax, edx
  00047	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0004a	03 c2		 add	 eax, edx
  0004c	83 f8 01	 cmp	 eax, 1
  0004f	7c 05		 jl	 SHORT $L300977
  00051	b8 01 00 00 00	 mov	 eax, 1
$L300977:
  00056	8b 4c 24 18	 mov	 ecx, DWORD PTR _nExp$[esp+16]
  0005a	51		 push	 ecx
  0005b	8b 4c 24 18	 mov	 ecx, DWORD PTR _nExp$[esp+16]
  0005f	99		 cdq
  00060	51		 push	 ecx
  00061	52		 push	 edx
  00062	50		 push	 eax
  00063	e8 00 00 00 00	 call	 __allmul
  00068	89 44 24 14	 mov	 DWORD PTR tv78[esp+12], eax
  0006c	89 54 24 18	 mov	 DWORD PTR tv78[esp+16], edx
  00070	df 6c 24 14	 fild	 QWORD PTR tv78[esp+12]
  00074	c1 e6 05	 shl	 esi, 5
  00077	df ae 10 50 00
	00		 fild	 QWORD PTR ?prj@@3VCProject@@A[esi+20496]

; 8747 : 		int nSubRestPoint = (int)( fTemp * static_cast<EXPFLOAT>( MAX_REST_POINT * GuildHouseMng->GetRestPointFactor(  this ) ) );	//  

  0007d	57		 push	 edi
  0007e	de f9		 fdivp	 ST(1), ST(0)
  00080	dd 5c 24 18	 fstp	 QWORD PTR _fTemp$285655[esp+16]
  00084	e8 00 00 00 00	 call	 ?GetInstance@CGuildHouseMng@@SAPAV1@XZ ; CGuildHouseMng::GetInstance
  00089	8b c8		 mov	 ecx, eax
  0008b	e8 00 00 00 00	 call	 ?GetRestPointFactor@CGuildHouseMng@@QAEMPAVCUser@@@Z ; CGuildHouseMng::GetRestPointFactor
  00090	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@49742400
  00096	dc 4c 24 14	 fmul	 QWORD PTR _fTemp$285655[esp+12]
  0009a	e8 00 00 00 00	 call	 __ftol2
  0009f	8b f0		 mov	 esi, eax

; 8748 : 		if( nSubRestPoint > 0 )	//        .

  000a1	85 f6		 test	 esi, esi
  000a3	7e 3e		 jle	 SHORT $L285664

; 8749 : 		{
; 8750 : 			int nRemainPoint = SetDecRestPoint( nSubRestPoint );	//     .

  000a5	8b d6		 mov	 edx, esi
  000a7	f7 da		 neg	 edx
  000a9	52		 push	 edx
  000aa	8b cf		 mov	 ecx, edi
  000ac	e8 00 00 00 00	 call	 ?SetAddRestPoint@CUser@@AAEHH@Z ; CUser::SetAddRestPoint

; 8751 : 			if( nRemainPoint < 0 )	//        .

  000b1	85 c0		 test	 eax, eax
  000b3	7d 23		 jge	 SHORT $L285663

; 8752 : 				return nAddExp * ( nSubRestPoint + nRemainPoint ) / nSubRestPoint;

  000b5	55		 push	 ebp
  000b6	03 c6		 add	 eax, esi
  000b8	99		 cdq
  000b9	53		 push	 ebx
  000ba	52		 push	 edx
  000bb	50		 push	 eax
  000bc	e8 00 00 00 00	 call	 __allmul
  000c1	8b c8		 mov	 ecx, eax
  000c3	8b fa		 mov	 edi, edx
  000c5	8b c6		 mov	 eax, esi
  000c7	99		 cdq
  000c8	52		 push	 edx
  000c9	50		 push	 eax
  000ca	57		 push	 edi
  000cb	51		 push	 ecx
  000cc	e8 00 00 00 00	 call	 __alldiv
  000d1	5f		 pop	 edi
  000d2	5e		 pop	 esi
  000d3	5d		 pop	 ebp
  000d4	5b		 pop	 ebx

; 8759 : }

  000d5	c2 08 00	 ret	 8
$L285663:
  000d8	5f		 pop	 edi
  000d9	5e		 pop	 esi

; 8753 : 			else	//      .
; 8754 : 				return nAddExp;

  000da	8b d5		 mov	 edx, ebp
  000dc	5d		 pop	 ebp
  000dd	8b c3		 mov	 eax, ebx
  000df	5b		 pop	 ebx

; 8759 : }

  000e0	c2 08 00	 ret	 8
$L285664:
  000e3	5f		 pop	 edi
  000e4	5e		 pop	 esi
  000e5	5d		 pop	 ebp

; 8755 : 		}
; 8756 : 	}
; 8757 : 
; 8758 : 	return 0;

  000e6	33 c0		 xor	 eax, eax
  000e8	33 d2		 xor	 edx, edx
  000ea	5b		 pop	 ebx

; 8759 : }

  000eb	c2 08 00	 ret	 8
?GetAddExpAfterApplyRestPoint@CUser@@QAE_J_J@Z ENDP	; CUser::GetAddExpAfterApplyRestPoint
_TEXT	ENDS
PUBLIC	?AddCheckedQuest@CUser@@QAEXXZ			; CUser::AddCheckedQuest
; Function compile flags: /Ogty
;	COMDAT ?AddCheckedQuest@CUser@@QAEXXZ
_TEXT	SEGMENT
?AddCheckedQuest@CUser@@QAEXXZ PROC NEAR		; CUser::AddCheckedQuest, COMDAT
; _this$ = ecx

; 8801 : {

  00000	57		 push	 edi
  00001	8b f9		 mov	 edi, ecx

; 8802 : 	if( IsDelete() )	return;

  00003	f6 47 04 01	 test	 BYTE PTR [edi+4], 1
  00007	75 78		 jne	 SHORT $L285703

; 8803 : 	m_Snapshot.cb++;

  00009	66 ff 87 0c 57
	00 00		 inc	 WORD PTR [edi+22284]
  00010	53		 push	 ebx

; 8804 : 	m_Snapshot.ar << GetId();

  00011	8b 9f bc 01 00
	00		 mov	 ebx, DWORD PTR [edi+444]
  00017	56		 push	 esi
  00018	8d b7 f8 16 00
	00		 lea	 esi, DWORD PTR [edi+5880]
  0001e	6a 04		 push	 4
  00020	8b ce		 mov	 ecx, esi
  00022	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00027	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0002a	89 18		 mov	 DWORD PTR [eax], ebx
  0002c	8b 5e 08	 mov	 ebx, DWORD PTR [esi+8]
  0002f	83 c3 04	 add	 ebx, 4

; 8805 : 	m_Snapshot.ar << SNAPSHOTTYPE_QUEST_CHECKED;

  00032	6a 02		 push	 2
  00034	8b ce		 mov	 ecx, esi
  00036	89 5e 08	 mov	 DWORD PTR [esi+8], ebx
  00039	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003e	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00041	66 c7 01 20 88	 mov	 WORD PTR [ecx], 34848	; 00008820H
  00046	83 46 08 02	 add	 DWORD PTR [esi+8], 2

; 8806 : 	m_Snapshot.ar << this->m_nCheckedQuestSize;

  0004a	8a 9f 8c 0e 00
	00		 mov	 bl, BYTE PTR [edi+3724]
  00050	6a 01		 push	 1
  00052	8b ce		 mov	 ecx, esi
  00054	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00059	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0005c	88 1a		 mov	 BYTE PTR [edx], bl
  0005e	ff 46 08	 inc	 DWORD PTR [esi+8]

; 8807 : 	if( this->m_nCheckedQuestSize )

  00061	8a 87 8c 0e 00
	00		 mov	 al, BYTE PTR [edi+3724]
  00067	84 c0		 test	 al, al
  00069	74 14		 je	 SHORT $L301006

; 8808 : 		m_Snapshot.ar.Write( this->m_aCheckedQuest, sizeof(WORD) * this->m_nCheckedQuestSize ); 

  0006b	8b 8f 90 0e 00
	00		 mov	 ecx, DWORD PTR [edi+3728]
  00071	0f b6 c0	 movzx	 eax, al
  00074	d1 e0		 shl	 eax, 1
  00076	50		 push	 eax
  00077	51		 push	 ecx
  00078	8b ce		 mov	 ecx, esi
  0007a	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
$L301006:
  0007f	5e		 pop	 esi
  00080	5b		 pop	 ebx
$L285703:
  00081	5f		 pop	 edi

; 8809 : }

  00082	c3		 ret	 0
?AddCheckedQuest@CUser@@QAEXXZ ENDP			; CUser::AddCheckedQuest
_TEXT	ENDS
PUBLIC	?AddInviteCampusMember@CUser@@QAEXPAV1@@Z	; CUser::AddInviteCampusMember
; Function compile flags: /Ogty
;	COMDAT ?AddInviteCampusMember@CUser@@QAEXPAV1@@Z
_TEXT	SEGMENT
_pRequest$ = 8						; size = 4
?AddInviteCampusMember@CUser@@QAEXPAV1@@Z PROC NEAR	; CUser::AddInviteCampusMember, COMDAT
; _this$ = ecx

; 8815 : 	if( IsDelete() )	return;

  00000	8a 51 04	 mov	 dl, BYTE PTR [ecx+4]
  00003	b0 01		 mov	 al, 1
  00005	84 d0		 test	 dl, al
  00007	0f 85 80 00 00
	00		 jne	 $L285708
  0000d	57		 push	 edi

; 8816 : 	if( !IsValidObj( pRequest ) )	return;

  0000e	8b 7c 24 08	 mov	 edi, DWORD PTR _pRequest$[esp]
  00012	85 ff		 test	 edi, edi
  00014	74 76		 je	 SHORT $L301043
  00016	84 47 04	 test	 BYTE PTR [edi+4], al
  00019	75 71		 jne	 SHORT $L301043

; 8817 : 
; 8818 : 	m_Snapshot.cb++;

  0001b	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  00022	53		 push	 ebx

; 8819 : 	m_Snapshot.ar << GetId();

  00023	8b 99 bc 01 00
	00		 mov	 ebx, DWORD PTR [ecx+444]
  00029	56		 push	 esi
  0002a	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  00030	6a 04		 push	 4
  00032	8b ce		 mov	 ecx, esi
  00034	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00039	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0003c	89 18		 mov	 DWORD PTR [eax], ebx
  0003e	8b 5e 08	 mov	 ebx, DWORD PTR [esi+8]
  00041	83 c3 04	 add	 ebx, 4

; 8820 : 	m_Snapshot.ar << SNAPSHOTTYPE_CAMPUS_INVITE;

  00044	6a 02		 push	 2
  00046	8b ce		 mov	 ecx, esi
  00048	89 5e 08	 mov	 DWORD PTR [esi+8], ebx
  0004b	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00050	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00053	66 c7 01 30 88	 mov	 WORD PTR [ecx], 34864	; 00008830H
  00058	83 46 08 02	 add	 DWORD PTR [esi+8], 2

; 8821 : 	m_Snapshot.ar << pRequest->m_idPlayer;

  0005c	8b 9f 38 02 00
	00		 mov	 ebx, DWORD PTR [edi+568]
  00062	6a 04		 push	 4
  00064	8b ce		 mov	 ecx, esi
  00066	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0006b	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0006e	89 1a		 mov	 DWORD PTR [edx], ebx
  00070	8b 5e 08	 mov	 ebx, DWORD PTR [esi+8]
  00073	83 c3 04	 add	 ebx, 4

; 8822 : 	m_Snapshot.ar.WriteString( pRequest->GetName() );

  00076	6a 00		 push	 0
  00078	8b cf		 mov	 ecx, edi
  0007a	89 5e 08	 mov	 DWORD PTR [esi+8], ebx
  0007d	e8 00 00 00 00	 call	 ?GetName@CMover@@QAEPBDH@Z ; CMover::GetName
  00082	50		 push	 eax
  00083	8b ce		 mov	 ecx, esi
  00085	e8 00 00 00 00	 call	 ?WriteString@CAr@@QAEXPBD@Z ; CAr::WriteString
  0008a	5e		 pop	 esi
  0008b	5b		 pop	 ebx
$L301043:
  0008c	5f		 pop	 edi
$L285708:

; 8823 : }

  0008d	c2 04 00	 ret	 4
?AddInviteCampusMember@CUser@@QAEXPAV1@@Z ENDP		; CUser::AddInviteCampusMember
_TEXT	ENDS
PUBLIC	?AddUpdateCampus@CUser@@QAEXPAVCCampus@@@Z	; CUser::AddUpdateCampus
EXTRN	?Serialize@CCampus@@QAEXAAVCAr@@@Z:NEAR		; CCampus::Serialize
; Function compile flags: /Ogty
;	COMDAT ?AddUpdateCampus@CUser@@QAEXPAVCCampus@@@Z
_TEXT	SEGMENT
_pCampus$ = 8						; size = 4
?AddUpdateCampus@CUser@@QAEXPAVCCampus@@@Z PROC NEAR	; CUser::AddUpdateCampus, COMDAT
; _this$ = ecx

; 8827 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	75 55		 jne	 SHORT $L285715
  00006	53		 push	 ebx

; 8828 : 	if( !pCampus )		return;

  00007	8b 5c 24 08	 mov	 ebx, DWORD PTR _pCampus$[esp]
  0000b	85 db		 test	 ebx, ebx
  0000d	74 4b		 je	 SHORT $L301062

; 8829 : 
; 8830 : 	m_Snapshot.cb++;

  0000f	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  00016	56		 push	 esi
  00017	57		 push	 edi

; 8831 : 	m_Snapshot.ar << GetId();

  00018	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  0001e	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  00024	6a 04		 push	 4
  00026	8b ce		 mov	 ecx, esi
  00028	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0002d	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00030	89 38		 mov	 DWORD PTR [eax], edi
  00032	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  00035	83 c7 04	 add	 edi, 4

; 8832 : 	m_Snapshot.ar << SNAPSHOTTYPE_CAMPUS_UPDATE;

  00038	6a 02		 push	 2
  0003a	8b ce		 mov	 ecx, esi
  0003c	89 7e 08	 mov	 DWORD PTR [esi+8], edi
  0003f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00044	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00047	66 c7 01 31 88	 mov	 WORD PTR [ecx], 34865	; 00008831H
  0004c	83 46 08 02	 add	 DWORD PTR [esi+8], 2

; 8833 : 	pCampus->Serialize( m_Snapshot.ar );

  00050	56		 push	 esi
  00051	8b cb		 mov	 ecx, ebx
  00053	e8 00 00 00 00	 call	 ?Serialize@CCampus@@QAEXAAVCAr@@@Z ; CCampus::Serialize
  00058	5f		 pop	 edi
  00059	5e		 pop	 esi
$L301062:
  0005a	5b		 pop	 ebx
$L285715:

; 8834 : }

  0005b	c2 04 00	 ret	 4
?AddUpdateCampus@CUser@@QAEXPAVCCampus@@@Z ENDP		; CUser::AddUpdateCampus
_TEXT	ENDS
PUBLIC	?AddRemoveCampus@CUser@@QAEXK@Z			; CUser::AddRemoveCampus
; Function compile flags: /Ogty
;	COMDAT ?AddRemoveCampus@CUser@@QAEXK@Z
_TEXT	SEGMENT
_idCampus$ = 8						; size = 4
?AddRemoveCampus@CUser@@QAEXK@Z PROC NEAR		; CUser::AddRemoveCampus, COMDAT
; _this$ = ecx

; 8838 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	75 63		 jne	 SHORT $L301083

; 8839 : 
; 8840 : 	m_Snapshot.cb++;

  00006	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  0000d	56		 push	 esi
  0000e	57		 push	 edi

; 8841 : 	m_Snapshot.ar << GetId();

  0000f	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  00015	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  0001b	6a 04		 push	 4
  0001d	8b ce		 mov	 ecx, esi
  0001f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00024	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00027	89 38		 mov	 DWORD PTR [eax], edi
  00029	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0002c	83 c0 04	 add	 eax, 4

; 8842 : 	m_Snapshot.ar << SNAPSHOTTYPE_CAMPUS_REMOVE;

  0002f	6a 02		 push	 2
  00031	8b ce		 mov	 ecx, esi
  00033	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00036	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003b	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003e	66 c7 01 32 88	 mov	 WORD PTR [ecx], 34866	; 00008832H
  00043	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00046	83 c2 02	 add	 edx, 2

; 8843 : 	m_Snapshot.ar << idCampus;

  00049	6a 04		 push	 4
  0004b	8b ce		 mov	 ecx, esi
  0004d	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00050	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00055	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00058	8b 44 24 0c	 mov	 eax, DWORD PTR _idCampus$[esp+4]
  0005c	89 02		 mov	 DWORD PTR [edx], eax
  0005e	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00061	83 c0 04	 add	 eax, 4
  00064	5f		 pop	 edi
  00065	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00068	5e		 pop	 esi
$L301083:

; 8844 : }

  00069	c2 04 00	 ret	 4
?AddRemoveCampus@CUser@@QAEXK@Z ENDP			; CUser::AddRemoveCampus
_TEXT	ENDS
PUBLIC	?GetPointByType@CUser@@QAEHH@Z			; CUser::GetPointByType
; Function compile flags: /Ogty
;	COMDAT ?GetPointByType@CUser@@QAEHH@Z
_TEXT	SEGMENT
_nType$ = 8						; size = 4
?GetPointByType@CUser@@QAEHH@Z PROC NEAR		; CUser::GetPointByType, COMDAT
; _this$ = ecx

; 8888 : 	int nPoint = 0;
; 8889 : 
; 8890 : 	switch( nType )

  00000	8b 54 24 04	 mov	 edx, DWORD PTR _nType$[esp-4]
  00004	33 c0		 xor	 eax, eax
  00006	4a		 dec	 edx
  00007	75 06		 jne	 SHORT $L301090

; 8894 : 		break;
; 8895 : 
; 8896 : 	default:
; 8897 : 		break;
; 8898 : 	}
; 8899 : 	
; 8900 : 	return nPoint;

  00009	8b 81 74 16 00
	00		 mov	 eax, DWORD PTR [ecx+5748]

; 8891 : 	{
; 8892 : 	case POINTTYPE_CAMPUS:
; 8893 : 		nPoint = GetCampusPoint();

$L301090:

; 8901 : }

  0000f	c2 04 00	 ret	 4
?GetPointByType@CUser@@QAEHH@Z ENDP			; CUser::GetPointByType
_TEXT	ENDS
PUBLIC	??_C@_0EB@EMOECFFH@pItem?5is?5NULL?5in?5SelectAwakening@ ; `string'
PUBLIC	??_C@_0DN@GIFNBFBB@Item?5SerialNumber?5is?5different?4?5@ ; `string'
PUBLIC	??_C@_0CG@DCOGLGC@This?5item?5have?5not?5new?5random?5op@ ; `string'
PUBLIC	??_C@_0BI@JPOENJFP@SELECT?5_AWAKE_OLD_VALUE?$AA@ ; `string'
PUBLIC	??_C@_0BI@COLBDCPC@SELECT?5_AWAKE_NEW_VALUE?$AA@ ; `string'
PUBLIC	??_C@_0N@DOANKLPK@SELECT?5ERROR?$AA@		; `string'
PUBLIC	??_C@_01GLPGHMHM@z?$AA@				; `string'
PUBLIC	?SelectAwakeningValue@CUser@@QAEXKKE@Z		; CUser::SelectAwakeningValue
EXTRN	?PutItemLog@CDPSrvr@@QAEXPAVCUser@@PBD1PAVCItemElem@@H@Z:NEAR ; CDPSrvr::PutItemLog
EXTRN	?WriteLog@@YAXPBDZZ:NEAR			; WriteLog
EXTRN	_sprintf:NEAR
EXTRN	?GetNewRandomOption@CItemElem@@QAE_JXZ:NEAR	; CItemElem::GetNewRandomOption
EXTRN	?SelectRandomOption@CItemElem@@QAE_NE@Z:NEAR	; CItemElem::SelectRandomOption
EXTRN	?UpdateItemEx@CMover@@QAEXED_J@Z:NEAR		; CMover::UpdateItemEx
EXTRN	?GetItemId@CMover@@QAEPAVCItemBase@@K@Z:NEAR	; CMover::GetItemId
;	COMDAT ??_C@_0EB@EMOECFFH@pItem?5is?5NULL?5in?5SelectAwakening@
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\item.h
CONST	SEGMENT
??_C@_0EB@EMOECFFH@pItem?5is?5NULL?5in?5SelectAwakening@ DB 'pItem is NUL'
	DB	'L in SelectAwakeningValue function. ItemObjID : [%d]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@GIFNBFBB@Item?5SerialNumber?5is?5different?4?5@
CONST	SEGMENT
??_C@_0DN@GIFNBFBB@Item?5SerialNumber?5is?5different?4?5@ DB 'Item Serial'
	DB	'Number is different. ItemSerialNumber : [%d] [%d]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@DCOGLGC@This?5item?5have?5not?5new?5random?5op@
CONST	SEGMENT
??_C@_0CG@DCOGLGC@This?5item?5have?5not?5new?5random?5op@ DB 'This item h'
	DB	'ave not new random option.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@JPOENJFP@SELECT?5_AWAKE_OLD_VALUE?$AA@
CONST	SEGMENT
??_C@_0BI@JPOENJFP@SELECT?5_AWAKE_OLD_VALUE?$AA@ DB 'SELECT _AWAKE_OLD_VA'
	DB	'LUE', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@COLBDCPC@SELECT?5_AWAKE_NEW_VALUE?$AA@
CONST	SEGMENT
??_C@_0BI@COLBDCPC@SELECT?5_AWAKE_NEW_VALUE?$AA@ DB 'SELECT _AWAKE_NEW_VA'
	DB	'LUE', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@DOANKLPK@SELECT?5ERROR?$AA@
CONST	SEGMENT
??_C@_0N@DOANKLPK@SELECT?5ERROR?$AA@ DB 'SELECT ERROR', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01GLPGHMHM@z?$AA@
CONST	SEGMENT
??_C@_01GLPGHMHM@z?$AA@ DB 'z', 00H			; `string'
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
CONST	ENDS
;	COMDAT ?SelectAwakeningValue@CUser@@QAEXKKE@Z
_TEXT	SEGMENT
_szSelectValue$285779 = -136				; size = 128
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
_dwItemObjID$ = 8					; size = 4
_dwSerialNumber$ = 12					; size = 4
_bySelectFlag$ = 16					; size = 1
?SelectAwakeningValue@CUser@@QAEXKKE@Z PROC NEAR	; CUser::SelectAwakeningValue, COMDAT
; _this$ = ecx

; 8909 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	81 ec 8c 00 00
	00		 sub	 esp, 140		; 0000008cH
  0000c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00011	53		 push	 ebx
  00012	56		 push	 esi
  00013	57		 push	 edi

; 8910 : 	CItemElem *	pItem = NULL;
; 8911 : 	pItem	= (CItemElem*)( GetItemId( dwItemObjID ) );

  00014	8b 7d 08	 mov	 edi, DWORD PTR _dwItemObjID$[ebp]
  00017	33 c5		 xor	 eax, ebp
  00019	57		 push	 edi
  0001a	89 84 24 98 00
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+156], eax
  00021	8b d9		 mov	 ebx, ecx
  00023	e8 00 00 00 00	 call	 ?GetItemId@CMover@@QAEPAVCItemBase@@K@Z ; CMover::GetItemId
  00028	8b f0		 mov	 esi, eax

; 8912 : 
; 8913 : 	if( pItem == NULL )

  0002a	85 f6		 test	 esi, esi
  0002c	75 25		 jne	 SHORT $L285768

; 8914 : 	{
; 8915 : 		WriteLog( "pItem is NULL in SelectAwakeningValue function. ItemObjID : [%d]", dwItemObjID );

  0002e	57		 push	 edi
  0002f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EB@EMOECFFH@pItem?5is?5NULL?5in?5SelectAwakening@
  00034	e8 00 00 00 00	 call	 ?WriteLog@@YAXPBDZZ	; WriteLog
  00039	83 c4 08	 add	 esp, 8

; 8965 : 		//	mulcom	END100426	   .
; 8966 : 
; 8967 : 	}
; 8968 : 
; 8969 : 	return;
; 8970 : }

  0003c	5f		 pop	 edi
  0003d	5e		 pop	 esi
  0003e	5b		 pop	 ebx
  0003f	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+140]
  00046	33 cd		 xor	 ecx, ebp
  00048	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0004d	8b e5		 mov	 esp, ebp
  0004f	5d		 pop	 ebp
  00050	c2 0c 00	 ret	 12			; 0000000cH
$L285768:

; 8916 : 
; 8917 : 		return;
; 8918 : 	}
; 8919 : 
; 8920 : 	DWORD	dwItemSerialNumber = 0;
; 8921 : 	dwItemSerialNumber	= (DWORD)( pItem->GetSerialNumber() );

  00053	8b 46 38	 mov	 eax, DWORD PTR [esi+56]

; 8922 : 
; 8923 : 	if( dwItemSerialNumber != dwSerialNumber )

  00056	8b 4d 0c	 mov	 ecx, DWORD PTR _dwSerialNumber$[ebp]
  00059	3b c1		 cmp	 eax, ecx
  0005b	74 26		 je	 SHORT $L285772

; 8924 : 	{
; 8925 : 		WriteLog( "Item SerialNumber is different. ItemSerialNumber : [%d] [%d]", dwItemSerialNumber, dwSerialNumber );

  0005d	51		 push	 ecx
  0005e	50		 push	 eax
  0005f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DN@GIFNBFBB@Item?5SerialNumber?5is?5different?4?5@
  00064	e8 00 00 00 00	 call	 ?WriteLog@@YAXPBDZZ	; WriteLog
  00069	83 c4 0c	 add	 esp, 12			; 0000000cH

; 8965 : 		//	mulcom	END100426	   .
; 8966 : 
; 8967 : 	}
; 8968 : 
; 8969 : 	return;
; 8970 : }

  0006c	5f		 pop	 edi
  0006d	5e		 pop	 esi
  0006e	5b		 pop	 ebx
  0006f	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+140]
  00076	33 cd		 xor	 ecx, ebp
  00078	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0007d	8b e5		 mov	 esp, ebp
  0007f	5d		 pop	 ebp
  00080	c2 0c 00	 ret	 12			; 0000000cH
$L285772:

; 8926 : 
; 8927 : 		return;
; 8928 : 	}
; 8929 : 
; 8930 : 	if( pItem->GetNewRandomOption() == 0 )

  00083	8b ce		 mov	 ecx, esi
  00085	e8 00 00 00 00	 call	 ?GetNewRandomOption@CItemElem@@QAE_JXZ ; CItemElem::GetNewRandomOption
  0008a	0b c2		 or	 eax, edx
  0008c	75 24		 jne	 SHORT $L285774

; 8931 : 	{
; 8932 : 		WriteLog( "This item have not new random option." );

  0008e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CG@DCOGLGC@This?5item?5have?5not?5new?5random?5op@
  00093	e8 00 00 00 00	 call	 ?WriteLog@@YAXPBDZZ	; WriteLog
  00098	83 c4 04	 add	 esp, 4

; 8965 : 		//	mulcom	END100426	   .
; 8966 : 
; 8967 : 	}
; 8968 : 
; 8969 : 	return;
; 8970 : }

  0009b	5f		 pop	 edi
  0009c	5e		 pop	 esi
  0009d	5b		 pop	 ebx
  0009e	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+140]
  000a5	33 cd		 xor	 ecx, ebp
  000a7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000ac	8b e5		 mov	 esp, ebp
  000ae	5d		 pop	 ebp
  000af	c2 0c 00	 ret	 12			; 0000000cH
$L285774:

; 8933 : 
; 8934 : 		return;
; 8935 : 	}
; 8936 : 
; 8937 : 	bool	bRetValue	= false;
; 8938 : 
; 8939 : 	bRetValue	= pItem->SelectRandomOption( bySelectFlag );

  000b2	8b 45 10	 mov	 eax, DWORD PTR _bySelectFlag$[ebp]
  000b5	50		 push	 eax
  000b6	8b ce		 mov	 ecx, esi
  000b8	e8 00 00 00 00	 call	 ?SelectRandomOption@CItemElem@@QAE_NE@Z ; CItemElem::SelectRandomOption

; 8940 : 
; 8941 : 	if( bRetValue == true )

  000bd	3c 01		 cmp	 al, 1
  000bf	75 77		 jne	 SHORT $L285777

; 8942 : 	{
; 8943 : 		UpdateItemEx( (BYTE)( pItem->m_dwObjId ), UI_RANDOMOPTITEMID, pItem->GetRandomOptItemId() );

  000c1	8b 8e 9c 00 00
	00		 mov	 ecx, DWORD PTR [esi+156]
  000c7	8b 96 98 00 00
	00		 mov	 edx, DWORD PTR [esi+152]
  000cd	33 c0		 xor	 eax, eax
  000cf	8a 46 04	 mov	 al, BYTE PTR [esi+4]
  000d2	51		 push	 ecx
  000d3	52		 push	 edx
  000d4	6a 0a		 push	 10			; 0000000aH
  000d6	8b cb		 mov	 ecx, ebx
  000d8	50		 push	 eax
  000d9	e8 00 00 00 00	 call	 ?UpdateItemEx@CMover@@QAEXED_J@Z ; CMover::UpdateItemEx

; 8944 : 
; 8945 : 		//	mulcom	BEGIN100426	   .
; 8946 : 		//WriteLog( "UserID [%d] : ItemSerialNumber[%d] SelectAwakeningValue bySelectFlag[%d]", (int)( GetId() ), (int)( pItem->GetSerialNumber() ), (int)( bySelectFlag ) );
; 8947 : 
; 8948 :  		TCHAR	szSelectValue[128];
; 8949 :  		::memset( szSelectValue, 0, sizeof(szSelectValue) );

  000de	33 c0		 xor	 eax, eax
  000e0	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  000e5	8d 7c 24 10	 lea	 edi, DWORD PTR _szSelectValue$285779[esp+152]
  000e9	f3 ab		 rep stosd

; 8950 : 
; 8951 : 		if( bySelectFlag == 1 )			//	_AWAKE_OLD_VALUE

  000eb	8a 45 10	 mov	 al, BYTE PTR _bySelectFlag$[ebp]
  000ee	3c 01		 cmp	 al, 1
  000f0	75 0c		 jne	 SHORT $L285780

; 8952 : 		{
; 8953 :  			::_stprintf( szSelectValue, "SELECT _AWAKE_OLD_VALUE" );

  000f2	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BI@JPOENJFP@SELECT?5_AWAKE_OLD_VALUE?$AA@
  000f7	8d 4c 24 14	 lea	 ecx, DWORD PTR _szSelectValue$285779[esp+156]
  000fb	51		 push	 ecx

; 8954 : 		}
; 8955 : 		else if( bySelectFlag == 2 )	//	_AWAKE_NEW_VALUE

  000fc	eb 1a		 jmp	 SHORT $L301105
$L285780:
  000fe	3c 02		 cmp	 al, 2
  00100	75 0c		 jne	 SHORT $L285783

; 8956 : 		{
; 8957 : 			::_stprintf( szSelectValue, "SELECT _AWAKE_NEW_VALUE" );

  00102	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BI@COLBDCPC@SELECT?5_AWAKE_NEW_VALUE?$AA@
  00107	8d 54 24 14	 lea	 edx, DWORD PTR _szSelectValue$285779[esp+156]
  0010b	52		 push	 edx

; 8958 : 		}
; 8959 : 		else

  0010c	eb 0a		 jmp	 SHORT $L301105
$L285783:

; 8960 : 		{
; 8961 : 			::_stprintf( szSelectValue, "SELECT ERROR" );

  0010e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0N@DOANKLPK@SELECT?5ERROR?$AA@
  00113	8d 44 24 14	 lea	 eax, DWORD PTR _szSelectValue$285779[esp+156]
  00117	50		 push	 eax
$L301105:
  00118	e8 00 00 00 00	 call	 _sprintf
  0011d	83 c4 08	 add	 esp, 8

; 8962 : 		}
; 8963 : 
; 8964 :  		g_DPSrvr.PutItemLog( this, "z", szSelectValue, pItem, 1 );

  00120	6a 01		 push	 1
  00122	56		 push	 esi
  00123	8d 4c 24 18	 lea	 ecx, DWORD PTR _szSelectValue$285779[esp+160]
  00127	51		 push	 ecx
  00128	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_01GLPGHMHM@z?$AA@
  0012d	53		 push	 ebx
  0012e	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_DPSrvr@@3VCDPSrvr@@A
  00133	e8 00 00 00 00	 call	 ?PutItemLog@CDPSrvr@@QAEXPAVCUser@@PBD1PAVCItemElem@@H@Z ; CDPSrvr::PutItemLog
$L285777:

; 8965 : 		//	mulcom	END100426	   .
; 8966 : 
; 8967 : 	}
; 8968 : 
; 8969 : 	return;
; 8970 : }

  00138	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+152]
  0013f	5f		 pop	 edi
  00140	5e		 pop	 esi
  00141	33 cd		 xor	 ecx, ebp
  00143	5b		 pop	 ebx
  00144	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00149	8b e5		 mov	 esp, ebp
  0014b	5d		 pop	 ebp
  0014c	c2 0c 00	 ret	 12			; 0000000cH
?SelectAwakeningValue@CUser@@QAEXKKE@Z ENDP		; CUser::SelectAwakeningValue
_TEXT	ENDS
PUBLIC	?SendNewRandomOption@CUser@@QAEXEK_J@Z		; CUser::SendNewRandomOption
; Function compile flags: /Ogty
;	COMDAT ?SendNewRandomOption@CUser@@QAEXEK_J@Z
_TEXT	SEGMENT
$T301133 = -8						; size = 8
_id$ = 8						; size = 1
_dwSerialNumber$ = 12					; size = 4
_n64NewRandomOption$ = 16				; size = 8
?SendNewRandomOption@CUser@@QAEXEK_J@Z PROC NEAR	; CUser::SendNewRandomOption, COMDAT
; _this$ = ecx

; 8974 : 	if( IsDelete() )	return;

  00000	8a 41 04	 mov	 al, BYTE PTR [ecx+4]
  00003	83 ec 08	 sub	 esp, 8
  00006	a8 01		 test	 al, 1
  00008	0f 85 9a 00 00
	00		 jne	 $L301132

; 8975 : 
; 8976 : 	m_Snapshot.cb++;

  0000e	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  00015	56		 push	 esi
  00016	57		 push	 edi

; 8977 : 	m_Snapshot.ar << GetId();

  00017	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  0001d	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  00023	6a 04		 push	 4
  00025	8b ce		 mov	 ecx, esi
  00027	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0002c	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0002f	89 38		 mov	 DWORD PTR [eax], edi
  00031	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00034	83 c0 04	 add	 eax, 4

; 8978 : 	m_Snapshot.ar << SNAPSHOTTYPE_ITEM_SELECT_AWAKENING_VALUE;

  00037	6a 02		 push	 2
  00039	8b ce		 mov	 ecx, esi
  0003b	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0003e	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00043	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00046	66 c7 01 34 88	 mov	 WORD PTR [ecx], 34868	; 00008834H
  0004b	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0004e	83 c2 02	 add	 edx, 2

; 8979 : 	m_Snapshot.ar << id << dwSerialNumber << n64NewRandomOption;

  00051	6a 01		 push	 1
  00053	8b ce		 mov	 ecx, esi
  00055	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00058	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0005d	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00060	8a 44 24 14	 mov	 al, BYTE PTR _id$[esp+12]
  00064	88 02		 mov	 BYTE PTR [edx], al
  00066	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00069	40		 inc	 eax
  0006a	6a 04		 push	 4
  0006c	8b ce		 mov	 ecx, esi
  0006e	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00071	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00076	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00079	8b 54 24 18	 mov	 edx, DWORD PTR _dwSerialNumber$[esp+12]
  0007d	8b 44 24 1c	 mov	 eax, DWORD PTR _n64NewRandomOption$[esp+12]
  00081	89 11		 mov	 DWORD PTR [ecx], edx
  00083	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00086	8b 4c 24 20	 mov	 ecx, DWORD PTR _n64NewRandomOption$[esp+16]
  0008a	83 c2 04	 add	 edx, 4
  0008d	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00090	6a 08		 push	 8
  00092	8d 54 24 0c	 lea	 edx, DWORD PTR $T301133[esp+20]
  00096	89 4c 24 10	 mov	 DWORD PTR $T301133[esp+24], ecx
  0009a	52		 push	 edx
  0009b	8b ce		 mov	 ecx, esi
  0009d	89 44 24 10	 mov	 DWORD PTR $T301133[esp+24], eax
  000a1	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
  000a6	5f		 pop	 edi
  000a7	5e		 pop	 esi
$L301132:

; 8980 : }

  000a8	83 c4 08	 add	 esp, 8
  000ab	c2 10 00	 ret	 16			; 00000010H
?SendNewRandomOption@CUser@@QAEXEK_J@Z ENDP		; CUser::SendNewRandomOption
_TEXT	ENDS
PUBLIC	?SendColosseumEnter@CUser@@QAEXXZ		; CUser::SendColosseumEnter
; Function compile flags: /Ogty
;	COMDAT ?SendColosseumEnter@CUser@@QAEXXZ
_TEXT	SEGMENT
?SendColosseumEnter@CUser@@QAEXXZ PROC NEAR		; CUser::SendColosseumEnter, COMDAT
; _this$ = ecx

; 9028 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	75 48		 jne	 SHORT $L301150

; 9029 : 	
; 9030 : 	m_Snapshot.cb++;

  00006	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  0000d	56		 push	 esi
  0000e	57		 push	 edi

; 9031 : 	m_Snapshot.ar << GetId();

  0000f	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  00015	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  0001b	6a 04		 push	 4
  0001d	8b ce		 mov	 ecx, esi
  0001f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00024	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00027	89 38		 mov	 DWORD PTR [eax], edi
  00029	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0002c	83 c2 04	 add	 edx, 4

; 9032 : 	m_Snapshot.ar << SNAPSHOTTYPE_COLOSSEUM_ENTER;

  0002f	6a 02		 push	 2
  00031	8b ce		 mov	 ecx, esi
  00033	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00036	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003b	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003e	66 c7 01 80 88	 mov	 WORD PTR [ecx], 34944	; 00008880H
  00043	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00046	83 c0 02	 add	 eax, 2
  00049	5f		 pop	 edi
  0004a	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0004d	5e		 pop	 esi
$L301150:

; 9033 : }

  0004e	c3		 ret	 0
?SendColosseumEnter@CUser@@QAEXXZ ENDP			; CUser::SendColosseumEnter
_TEXT	ENDS
PUBLIC	?GetEmptyCount@?$CItemContainer@VCItemElem@@@@QAEHXZ ; CItemContainer<CItemElem>::GetEmptyCount
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\item.h
;	COMDAT ?GetEmptyCount@?$CItemContainer@VCItemElem@@@@QAEHXZ
_TEXT	SEGMENT
?GetEmptyCount@?$CItemContainer@VCItemElem@@@@QAEHXZ PROC NEAR ; CItemContainer<CItemElem>::GetEmptyCount, COMDAT
; _this$ = ecx

; 417  : 		{

  00000	56		 push	 esi

; 423  : 			}
; 424  : 			return( nCount );

  00001	8b 71 0c	 mov	 esi, DWORD PTR [ecx+12]
  00004	33 c0		 xor	 eax, eax
  00006	85 f6		 test	 esi, esi
  00008	76 20		 jbe	 SHORT $L286229
  0000a	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  0000d	83 c2 08	 add	 edx, 8
  00010	57		 push	 edi
$L286227:
  00011	8b 7a 04	 mov	 edi, DWORD PTR [edx+4]
  00014	85 ff		 test	 edi, edi
  00016	75 08		 jne	 SHORT $L286228
  00018	8b 3a		 mov	 edi, DWORD PTR [edx]
  0001a	3b 79 08	 cmp	 edi, DWORD PTR [ecx+8]
  0001d	73 01		 jae	 SHORT $L286228

; 420  : 			{
; 421  : 				if( m_apItem[i].IsEmpty() && m_apItem[i].m_dwObjIndex < m_dwIndexNum )
; 422  : 					nCount++;

  0001f	40		 inc	 eax
$L286228:

; 418  : 			int nCount	= 0;
; 419  : 			for( DWORD i = 0; i < m_dwItemMax; i++ )

  00020	81 c2 b8 00 00
	00		 add	 edx, 184		; 000000b8H
  00026	4e		 dec	 esi
  00027	75 e8		 jne	 SHORT $L286227
  00029	5f		 pop	 edi
$L286229:
  0002a	5e		 pop	 esi

; 425  : 		}

  0002b	c3		 ret	 0
?GetEmptyCount@?$CItemContainer@VCItemElem@@@@QAEHXZ ENDP ; CItemContainer<CItemElem>::GetEmptyCount
_TEXT	ENDS
PUBLIC	??9const_iterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,_Friend,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,_Friend> >,0> >::const_iterator::operator!=
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9const_iterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,_Friend,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,_Friend> >,0> >::const_iterator::operator!=, COMDAT
; _this$ = ecx

; 246  : 			return (!(*this == _Right));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 54 24 04	 mov	 edx, DWORD PTR __Right$[esp-4]
  00006	56		 push	 esi
  00007	8b 32		 mov	 esi, DWORD PTR [edx]
  00009	33 c9		 xor	 ecx, ecx
  0000b	3b c6		 cmp	 eax, esi
  0000d	0f 95 c1	 setne	 cl
  00010	8a c1		 mov	 al, cl
  00012	5e		 pop	 esi

; 247  : 			}

  00013	c2 04 00	 ret	 4
??9const_iterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,_Friend,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,_Friend> >,0> >::const_iterator::operator!=
_TEXT	ENDS
PUBLIC	??9const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CGuildMember *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuildMember *> >,0> >::const_iterator::operator!=
; Function compile flags: /Ogty
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CGuildMember *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuildMember *> >,0> >::const_iterator::operator!=, COMDAT
; _this$ = ecx

; 246  : 			return (!(*this == _Right));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 54 24 04	 mov	 edx, DWORD PTR __Right$[esp-4]
  00006	56		 push	 esi
  00007	8b 32		 mov	 esi, DWORD PTR [edx]
  00009	33 c9		 xor	 ecx, ecx
  0000b	3b c6		 cmp	 eax, esi
  0000d	0f 95 c1	 setne	 cl
  00010	8a c1		 mov	 al, cl
  00012	5e		 pop	 esi

; 247  : 			}

  00013	c2 04 00	 ret	 4
??9const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CGuildMember *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuildMember *> >,0> >::const_iterator::operator!=
_TEXT	ENDS
PUBLIC	??0iterator@?$_Tree@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,CParty *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CParty *> >,0> >::iterator::iterator
; Function compile flags: /Ogty
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0iterator@?$_Tree@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@std@@QAE@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CParty *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CParty *> >,0> >::iterator::iterator, COMDAT
; _this$ = ecx

; 304  : 		iterator()

  00000	8b c1		 mov	 eax, ecx
  00002	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 305  : 			{	// construct with null node pointer
; 306  : 			}

  00008	c3		 ret	 0
??0iterator@?$_Tree@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CParty *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CParty *> >,0> >::iterator::iterator
_TEXT	ENDS
PUBLIC	??9const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CParty *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CParty *> >,0> >::const_iterator::operator!=
; Function compile flags: /Ogty
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CParty *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CParty *> >,0> >::const_iterator::operator!=, COMDAT
; _this$ = ecx

; 246  : 			return (!(*this == _Right));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 54 24 04	 mov	 edx, DWORD PTR __Right$[esp-4]
  00006	56		 push	 esi
  00007	8b 32		 mov	 esi, DWORD PTR [edx]
  00009	33 c9		 xor	 ecx, ecx
  0000b	3b c6		 cmp	 eax, esi
  0000d	0f 95 c1	 setne	 cl
  00010	8a c1		 mov	 al, cl
  00012	5e		 pop	 esi

; 247  : 			}

  00013	c2 04 00	 ret	 4
??9const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CParty *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CParty *> >,0> >::const_iterator::operator!=
_TEXT	ENDS
PUBLIC	??Eiterator@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAEAAV012@XZ ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::iterator::operator++
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\list
;	COMDAT ??Eiterator@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??Eiterator@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAEAAV012@XZ PROC NEAR ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::iterator::operator++, COMDAT
; _this$ = ecx

; 249  : 			{	// preincrement

  00000	8b c1		 mov	 eax, ecx

; 250  : 			++(*(const_iterator *)this);

  00002	8b 08		 mov	 ecx, DWORD PTR [eax]
  00004	8b 11		 mov	 edx, DWORD PTR [ecx]
  00006	89 10		 mov	 DWORD PTR [eax], edx

; 251  : 			return (*this);
; 252  : 			}

  00008	c3		 ret	 0
??Eiterator@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAEAAV012@XZ ENDP ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::iterator::operator++
_TEXT	ENDS
PUBLIC	??9const_iterator@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBE_NABV012@@Z ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::const_iterator::operator!=
; Function compile flags: /Ogty
;	COMDAT ??9const_iterator@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9const_iterator@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBE_NABV012@@Z PROC NEAR ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::const_iterator::operator!=, COMDAT
; _this$ = ecx

; 202  : 			return (!(*this == _Right));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 54 24 04	 mov	 edx, DWORD PTR __Right$[esp-4]
  00006	56		 push	 esi
  00007	8b 32		 mov	 esi, DWORD PTR [edx]
  00009	33 c9		 xor	 ecx, ecx
  0000b	3b c6		 cmp	 eax, esi
  0000d	0f 95 c1	 setne	 cl
  00010	8a c1		 mov	 al, cl
  00012	5e		 pop	 esi

; 203  : 			}

  00013	c2 04 00	 ret	 4
??9const_iterator@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBE_NABV012@@Z ENDP ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::const_iterator::operator!=
_TEXT	ENDS
PUBLIC	??0iterator@?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@QAE@XZ ; std::list<CUser *,std::allocator<CUser *> >::iterator::iterator
; Function compile flags: /Ogty
;	COMDAT ??0iterator@?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0iterator@?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@QAE@XZ PROC NEAR ; std::list<CUser *,std::allocator<CUser *> >::iterator::iterator, COMDAT
; _this$ = ecx

; 229  : 		iterator()

  00000	8b c1		 mov	 eax, ecx
  00002	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 230  : 			{	// construct with null node
; 231  : 			}

  00008	c3		 ret	 0
??0iterator@?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@QAE@XZ ENDP ; std::list<CUser *,std::allocator<CUser *> >::iterator::iterator
_TEXT	ENDS
PUBLIC	??Eiterator@?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@QAEAAV012@XZ ; std::list<CUser *,std::allocator<CUser *> >::iterator::operator++
; Function compile flags: /Ogty
;	COMDAT ??Eiterator@?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??Eiterator@?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@QAEAAV012@XZ PROC NEAR ; std::list<CUser *,std::allocator<CUser *> >::iterator::operator++, COMDAT
; _this$ = ecx

; 249  : 			{	// preincrement

  00000	8b c1		 mov	 eax, ecx

; 250  : 			++(*(const_iterator *)this);

  00002	8b 08		 mov	 ecx, DWORD PTR [eax]
  00004	8b 11		 mov	 edx, DWORD PTR [ecx]
  00006	89 10		 mov	 DWORD PTR [eax], edx

; 251  : 			return (*this);
; 252  : 			}

  00008	c3		 ret	 0
??Eiterator@?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@QAEAAV012@XZ ENDP ; std::list<CUser *,std::allocator<CUser *> >::iterator::operator++
_TEXT	ENDS
PUBLIC	??9const_iterator@?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@QBE_NABV012@@Z ; std::list<CUser *,std::allocator<CUser *> >::const_iterator::operator!=
; Function compile flags: /Ogty
;	COMDAT ??9const_iterator@?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9const_iterator@?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@QBE_NABV012@@Z PROC NEAR ; std::list<CUser *,std::allocator<CUser *> >::const_iterator::operator!=, COMDAT
; _this$ = ecx

; 202  : 			return (!(*this == _Right));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 54 24 04	 mov	 edx, DWORD PTR __Right$[esp-4]
  00006	56		 push	 esi
  00007	8b 32		 mov	 esi, DWORD PTR [edx]
  00009	33 c9		 xor	 ecx, ecx
  0000b	3b c6		 cmp	 eax, esi
  0000d	0f 95 c1	 setne	 cl
  00010	8a c1		 mov	 al, cl
  00012	5e		 pop	 esi

; 203  : 			}

  00013	c2 04 00	 ret	 4
??9const_iterator@?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@QBE_NABV012@@Z ENDP ; std::list<CUser *,std::allocator<CUser *> >::const_iterator::operator!=
_TEXT	ENDS
PUBLIC	?get_allocator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBE?AV?$allocator@U?$pair@$$CBHH@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::get_allocator
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ?get_allocator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBE?AV?$allocator@U?$pair@$$CBHH@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?get_allocator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBE?AV?$allocator@U?$pair@$$CBHH@std@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::get_allocator, COMDAT
; _this$ = ecx

; 463  : 		return (this->_Alval);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 464  : 		}

  00004	c2 04 00	 ret	 4
?get_allocator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBE?AV?$allocator@U?$pair@$$CBHH@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::get_allocator
_TEXT	ENDS
PUBLIC	?_Lmost@?$_Tree@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,CParty *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CParty *> >,0> >::_Lmost
; Function compile flags: /Ogty
;	COMDAT ?_Lmost@?$_Tree@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Lmost@?$_Tree@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CParty *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CParty *> >,0> >::_Lmost, COMDAT
; _this$ = ecx

; 1005 : 		return (_Left(_Myhead));

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 1006 : 		}

  00003	c3		 ret	 0
?_Lmost@?$_Tree@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CParty *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CParty *> >,0> >::_Lmost
_TEXT	ENDS
PUBLIC	?_Lmost@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,_Friend,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,_Friend> >,0> >::_Lmost
; Function compile flags: /Ogty
;	COMDAT ?_Lmost@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Lmost@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,_Friend,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,_Friend> >,0> >::_Lmost, COMDAT
; _this$ = ecx

; 1005 : 		return (_Left(_Myhead));

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 1006 : 		}

  00003	c3		 ret	 0
?_Lmost@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,_Friend,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,_Friend> >,0> >::_Lmost
_TEXT	ENDS
PUBLIC	??0iterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,_Friend,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,_Friend> >,0> >::iterator::iterator
; Function compile flags: /Ogty
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
??0iterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,_Friend,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,_Friend> >,0> >::iterator::iterator, COMDAT
; _this$ = ecx

; 312  : 			{	// construct with node pointer _Pnode

  00000	8b c1		 mov	 eax, ecx
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Pnode$[esp-4]
  00006	89 08		 mov	 DWORD PTR [eax], ecx

; 313  : 			}

  00008	c2 04 00	 ret	 4
??0iterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,_Friend,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,_Friend> >,0> >::iterator::iterator
_TEXT	ENDS
PUBLIC	?_Lmost@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,CGuildMember *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuildMember *> >,0> >::_Lmost
; Function compile flags: /Ogty
;	COMDAT ?_Lmost@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Lmost@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CGuildMember *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuildMember *> >,0> >::_Lmost, COMDAT
; _this$ = ecx

; 1005 : 		return (_Left(_Myhead));

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 1006 : 		}

  00003	c3		 ret	 0
?_Lmost@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CGuildMember *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuildMember *> >,0> >::_Lmost
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@U_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@@Z ; std::allocator<std::_List_nod<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Node>::destroy
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ?destroy@?$allocator@U_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@U_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@@Z PROC NEAR ; std::allocator<std::_List_nod<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Node>::destroy, COMDAT
; _this$ = ecx

; 152  : 		_Destroy(_Ptr);
; 153  : 		}

  00000	c2 04 00	 ret	 4
?destroy@?$allocator@U_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@@Z ENDP ; std::allocator<std::_List_nod<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Node>::destroy
_TEXT	ENDS
PUBLIC	??0iterator@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CGuildMember *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuildMember *> >,0> >::iterator::iterator
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
??0iterator@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CGuildMember *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuildMember *> >,0> >::iterator::iterator, COMDAT
; _this$ = ecx

; 312  : 			{	// construct with node pointer _Pnode

  00000	8b c1		 mov	 eax, ecx
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Pnode$[esp-4]
  00006	89 08		 mov	 DWORD PTR [eax], ecx

; 313  : 			}

  00008	c2 04 00	 ret	 4
??0iterator@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CGuildMember *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuildMember *> >,0> >::iterator::iterator
_TEXT	ENDS
PUBLIC	??0iterator@?$_Tree@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CParty *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CParty *> >,0> >::iterator::iterator
; Function compile flags: /Ogty
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
??0iterator@?$_Tree@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CParty *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CParty *> >,0> >::iterator::iterator, COMDAT
; _this$ = ecx

; 312  : 			{	// construct with node pointer _Pnode

  00000	8b c1		 mov	 eax, ecx
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Pnode$[esp-4]
  00006	89 08		 mov	 DWORD PTR [eax], ecx

; 313  : 			}

  00008	c2 04 00	 ret	 4
??0iterator@?$_Tree@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CParty *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CParty *> >,0> >::iterator::iterator
_TEXT	ENDS
PUBLIC	??0iterator@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE@PAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@@Z ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::iterator::iterator
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\list
;	COMDAT ??0iterator@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE@PAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
??0iterator@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE@PAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@@Z PROC NEAR ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::iterator::iterator, COMDAT
; _this$ = ecx

; 235  : 			{	// construct with node pointer _Pnode

  00000	8b c1		 mov	 eax, ecx
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Pnode$[esp-4]
  00006	89 08		 mov	 DWORD PTR [eax], ecx

; 236  : 			}

  00008	c2 04 00	 ret	 4
??0iterator@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE@PAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@@Z ENDP ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::iterator::iterator
_TEXT	ENDS
PUBLIC	??Dconst_iterator@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEABQAU__JOINPLAYER@CGuildCombat@@XZ ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::const_iterator::operator*
; Function compile flags: /Ogty
;	COMDAT ??Dconst_iterator@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEABQAU__JOINPLAYER@CGuildCombat@@XZ
_TEXT	SEGMENT
??Dconst_iterator@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEABQAU__JOINPLAYER@CGuildCombat@@XZ PROC NEAR ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::const_iterator::operator*, COMDAT
; _this$ = ecx

; 161  : 			return (_Myval(_Ptr));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 08	 add	 eax, 8

; 162  : 			}

  00005	c3		 ret	 0
??Dconst_iterator@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEABQAU__JOINPLAYER@CGuildCombat@@XZ ENDP ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::const_iterator::operator*
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@U_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@2@@Z ; std::allocator<std::_List_nod<CUser *,std::allocator<CUser *> >::_Node>::destroy
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ?destroy@?$allocator@U_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@U_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@2@@Z PROC NEAR ; std::allocator<std::_List_nod<CUser *,std::allocator<CUser *> >::_Node>::destroy, COMDAT
; _this$ = ecx

; 152  : 		_Destroy(_Ptr);
; 153  : 		}

  00000	c2 04 00	 ret	 4
?destroy@?$allocator@U_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@2@@Z ENDP ; std::allocator<std::_List_nod<CUser *,std::allocator<CUser *> >::_Node>::destroy
_TEXT	ENDS
PUBLIC	??0iterator@?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@QAE@PAU_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@2@@Z ; std::list<CUser *,std::allocator<CUser *> >::iterator::iterator
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\list
;	COMDAT ??0iterator@?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@QAE@PAU_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
??0iterator@?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@QAE@PAU_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@2@@Z PROC NEAR ; std::list<CUser *,std::allocator<CUser *> >::iterator::iterator, COMDAT
; _this$ = ecx

; 235  : 			{	// construct with node pointer _Pnode

  00000	8b c1		 mov	 eax, ecx
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Pnode$[esp-4]
  00006	89 08		 mov	 DWORD PTR [eax], ecx

; 236  : 			}

  00008	c2 04 00	 ret	 4
??0iterator@?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@QAE@PAU_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@2@@Z ENDP ; std::list<CUser *,std::allocator<CUser *> >::iterator::iterator
_TEXT	ENDS
PUBLIC	??Dconst_iterator@?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@QBEABQAVCUser@@XZ ; std::list<CUser *,std::allocator<CUser *> >::const_iterator::operator*
; Function compile flags: /Ogty
;	COMDAT ??Dconst_iterator@?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@QBEABQAVCUser@@XZ
_TEXT	SEGMENT
??Dconst_iterator@?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@QBEABQAVCUser@@XZ PROC NEAR ; std::list<CUser *,std::allocator<CUser *> >::const_iterator::operator*, COMDAT
; _this$ = ecx

; 161  : 			return (_Myval(_Ptr));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 08	 add	 eax, 8

; 162  : 			}

  00005	c3		 ret	 0
??Dconst_iterator@?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@QBEABQAVCUser@@XZ ENDP ; std::list<CUser *,std::allocator<CUser *> >::const_iterator::operator*
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@IAE@V?$allocator@U__ITEMINFO@@@1@@Z ; std::_Vector_val<__ITEMINFO,std::allocator<__ITEMINFO> >::_Vector_val<__ITEMINFO,std::allocator<__ITEMINFO> >
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ??0?$_Vector_val@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@IAE@V?$allocator@U__ITEMINFO@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@IAE@V?$allocator@U__ITEMINFO@@@1@@Z PROC NEAR ; std::_Vector_val<__ITEMINFO,std::allocator<__ITEMINFO> >::_Vector_val<__ITEMINFO,std::allocator<__ITEMINFO> >, COMDAT
; _this$ = ecx

; 21   : 		{	// construct allocator from _Al

  00000	8b c1		 mov	 eax, ecx

; 22   : 		}

  00002	c2 04 00	 ret	 4
??0?$_Vector_val@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@IAE@V?$allocator@U__ITEMINFO@@@1@@Z ENDP ; std::_Vector_val<__ITEMINFO,std::allocator<__ITEMINFO> >::_Vector_val<__ITEMINFO,std::allocator<__ITEMINFO> >
_TEXT	ENDS
PUBLIC	??Diterator@?$vector@KV?$allocator@K@std@@@std@@QBEAAKXZ ; std::vector<unsigned long,std::allocator<unsigned long> >::iterator::operator*
; Function compile flags: /Ogty
;	COMDAT ??Diterator@?$vector@KV?$allocator@K@std@@@std@@QBEAAKXZ
_TEXT	SEGMENT
??Diterator@?$vector@KV?$allocator@K@std@@@std@@QBEAAKXZ PROC NEAR ; std::vector<unsigned long,std::allocator<unsigned long> >::iterator::operator*, COMDAT
; _this$ = ecx

; 220  : 			return ((reference)**(const_iterator *)this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 221  : 			}

  00002	c3		 ret	 0
??Diterator@?$vector@KV?$allocator@K@std@@@std@@QBEAAKXZ ENDP ; std::vector<unsigned long,std::allocator<unsigned long> >::iterator::operator*
_TEXT	ENDS
PUBLIC	??Hiterator@?$vector@KV?$allocator@K@std@@@std@@QBE?AV012@H@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::iterator::operator+
; Function compile flags: /Ogty
;	COMDAT ??Hiterator@?$vector@KV?$allocator@K@std@@@std@@QBE?AV012@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??Hiterator@?$vector@KV?$allocator@K@std@@@std@@QBE?AV012@H@Z PROC NEAR ; std::vector<unsigned long,std::allocator<unsigned long> >::iterator::operator+, COMDAT
; _this$ = ecx

; 262  : 			iterator _Tmp = *this;
; 263  : 			return (_Tmp += _Off);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 4c 24 08	 mov	 ecx, DWORD PTR __Off$[esp-4]
  00006	8d 14 88	 lea	 edx, DWORD PTR [eax+ecx*4]
  00009	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  0000d	89 10		 mov	 DWORD PTR [eax], edx

; 264  : 			}

  0000f	c2 08 00	 ret	 8
??Hiterator@?$vector@KV?$allocator@K@std@@@std@@QBE?AV012@H@Z ENDP ; std::vector<unsigned long,std::allocator<unsigned long> >::iterator::operator+
_TEXT	ENDS
PUBLIC	??Diterator@?$vector@HV?$allocator@H@std@@@std@@QBEAAHXZ ; std::vector<int,std::allocator<int> >::iterator::operator*
; Function compile flags: /Ogty
;	COMDAT ??Diterator@?$vector@HV?$allocator@H@std@@@std@@QBEAAHXZ
_TEXT	SEGMENT
??Diterator@?$vector@HV?$allocator@H@std@@@std@@QBEAAHXZ PROC NEAR ; std::vector<int,std::allocator<int> >::iterator::operator*, COMDAT
; _this$ = ecx

; 220  : 			return ((reference)**(const_iterator *)this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 221  : 			}

  00002	c3		 ret	 0
??Diterator@?$vector@HV?$allocator@H@std@@@std@@QBEAAHXZ ENDP ; std::vector<int,std::allocator<int> >::iterator::operator*
_TEXT	ENDS
PUBLIC	??Hiterator@?$vector@HV?$allocator@H@std@@@std@@QBE?AV012@H@Z ; std::vector<int,std::allocator<int> >::iterator::operator+
; Function compile flags: /Ogty
;	COMDAT ??Hiterator@?$vector@HV?$allocator@H@std@@@std@@QBE?AV012@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??Hiterator@?$vector@HV?$allocator@H@std@@@std@@QBE?AV012@H@Z PROC NEAR ; std::vector<int,std::allocator<int> >::iterator::operator+, COMDAT
; _this$ = ecx

; 262  : 			iterator _Tmp = *this;
; 263  : 			return (_Tmp += _Off);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 4c 24 08	 mov	 ecx, DWORD PTR __Off$[esp-4]
  00006	8d 14 88	 lea	 edx, DWORD PTR [eax+ecx*4]
  00009	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  0000d	89 10		 mov	 DWORD PTR [eax], edx

; 264  : 			}

  0000f	c2 08 00	 ret	 8
??Hiterator@?$vector@HV?$allocator@H@std@@@std@@QBE?AV012@H@Z ENDP ; std::vector<int,std::allocator<int> >::iterator::operator+
_TEXT	ENDS
PUBLIC	??Diterator@?$vector@EV?$allocator@E@std@@@std@@QBEAAEXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::iterator::operator*
; Function compile flags: /Ogty
;	COMDAT ??Diterator@?$vector@EV?$allocator@E@std@@@std@@QBEAAEXZ
_TEXT	SEGMENT
??Diterator@?$vector@EV?$allocator@E@std@@@std@@QBEAAEXZ PROC NEAR ; std::vector<unsigned char,std::allocator<unsigned char> >::iterator::operator*, COMDAT
; _this$ = ecx

; 220  : 			return ((reference)**(const_iterator *)this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 221  : 			}

  00002	c3		 ret	 0
??Diterator@?$vector@EV?$allocator@E@std@@@std@@QBEAAEXZ ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::iterator::operator*
_TEXT	ENDS
PUBLIC	??Hiterator@?$vector@EV?$allocator@E@std@@@std@@QBE?AV012@H@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::iterator::operator+
; Function compile flags: /Ogty
;	COMDAT ??Hiterator@?$vector@EV?$allocator@E@std@@@std@@QBE?AV012@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??Hiterator@?$vector@EV?$allocator@E@std@@@std@@QBE?AV012@H@Z PROC NEAR ; std::vector<unsigned char,std::allocator<unsigned char> >::iterator::operator+, COMDAT
; _this$ = ecx

; 262  : 			iterator _Tmp = *this;
; 263  : 			return (_Tmp += _Off);

  00000	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00002	03 4c 24 08	 add	 ecx, DWORD PTR __Off$[esp-4]
  00006	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  0000a	89 08		 mov	 DWORD PTR [eax], ecx

; 264  : 			}

  0000c	c2 08 00	 ret	 8
??Hiterator@?$vector@EV?$allocator@E@std@@@std@@QBE?AV012@H@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::iterator::operator+
_TEXT	ENDS
PUBLIC	??Diterator@?$vector@VCGuildCombat1to1@@V?$allocator@VCGuildCombat1to1@@@std@@@std@@QBEAAVCGuildCombat1to1@@XZ ; std::vector<CGuildCombat1to1,std::allocator<CGuildCombat1to1> >::iterator::operator*
; Function compile flags: /Ogty
;	COMDAT ??Diterator@?$vector@VCGuildCombat1to1@@V?$allocator@VCGuildCombat1to1@@@std@@@std@@QBEAAVCGuildCombat1to1@@XZ
_TEXT	SEGMENT
??Diterator@?$vector@VCGuildCombat1to1@@V?$allocator@VCGuildCombat1to1@@@std@@@std@@QBEAAVCGuildCombat1to1@@XZ PROC NEAR ; std::vector<CGuildCombat1to1,std::allocator<CGuildCombat1to1> >::iterator::operator*, COMDAT
; _this$ = ecx

; 220  : 			return ((reference)**(const_iterator *)this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 221  : 			}

  00002	c3		 ret	 0
??Diterator@?$vector@VCGuildCombat1to1@@V?$allocator@VCGuildCombat1to1@@@std@@@std@@QBEAAVCGuildCombat1to1@@XZ ENDP ; std::vector<CGuildCombat1to1,std::allocator<CGuildCombat1to1> >::iterator::operator*
_TEXT	ENDS
PUBLIC	??Hiterator@?$vector@VCGuildCombat1to1@@V?$allocator@VCGuildCombat1to1@@@std@@@std@@QBE?AV012@H@Z ; std::vector<CGuildCombat1to1,std::allocator<CGuildCombat1to1> >::iterator::operator+
; Function compile flags: /Ogty
;	COMDAT ??Hiterator@?$vector@VCGuildCombat1to1@@V?$allocator@VCGuildCombat1to1@@@std@@@std@@QBE?AV012@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??Hiterator@?$vector@VCGuildCombat1to1@@V?$allocator@VCGuildCombat1to1@@@std@@@std@@QBE?AV012@H@Z PROC NEAR ; std::vector<CGuildCombat1to1,std::allocator<CGuildCombat1to1> >::iterator::operator+, COMDAT
; _this$ = ecx

; 262  : 			iterator _Tmp = *this;
; 263  : 			return (_Tmp += _Off);

  00000	8b 44 24 08	 mov	 eax, DWORD PTR __Off$[esp-4]
  00004	8d 14 40	 lea	 edx, DWORD PTR [eax+eax*2]
  00007	8b 01		 mov	 eax, DWORD PTR [ecx]
  00009	c1 e2 04	 shl	 edx, 4
  0000c	03 d0		 add	 edx, eax
  0000e	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  00012	89 10		 mov	 DWORD PTR [eax], edx

; 264  : 			}

  00014	c2 08 00	 ret	 8
??Hiterator@?$vector@VCGuildCombat1to1@@V?$allocator@VCGuildCombat1to1@@@std@@@std@@QBE?AV012@H@Z ENDP ; std::vector<CGuildCombat1to1,std::allocator<CGuildCombat1to1> >::iterator::operator+
_TEXT	ENDS
PUBLIC	??Diterator@?$vector@U__GC1TO1TENDER@CGuildCombat1to1Mng@@V?$allocator@U__GC1TO1TENDER@CGuildCombat1to1Mng@@@std@@@std@@QBEAAU__GC1TO1TENDER@CGuildCombat1to1Mng@@XZ ; std::vector<CGuildCombat1to1Mng::__GC1TO1TENDER,std::allocator<CGuildCombat1to1Mng::__GC1TO1TENDER> >::iterator::operator*
; Function compile flags: /Ogty
;	COMDAT ??Diterator@?$vector@U__GC1TO1TENDER@CGuildCombat1to1Mng@@V?$allocator@U__GC1TO1TENDER@CGuildCombat1to1Mng@@@std@@@std@@QBEAAU__GC1TO1TENDER@CGuildCombat1to1Mng@@XZ
_TEXT	SEGMENT
??Diterator@?$vector@U__GC1TO1TENDER@CGuildCombat1to1Mng@@V?$allocator@U__GC1TO1TENDER@CGuildCombat1to1Mng@@@std@@@std@@QBEAAU__GC1TO1TENDER@CGuildCombat1to1Mng@@XZ PROC NEAR ; std::vector<CGuildCombat1to1Mng::__GC1TO1TENDER,std::allocator<CGuildCombat1to1Mng::__GC1TO1TENDER> >::iterator::operator*, COMDAT
; _this$ = ecx

; 220  : 			return ((reference)**(const_iterator *)this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 221  : 			}

  00002	c3		 ret	 0
??Diterator@?$vector@U__GC1TO1TENDER@CGuildCombat1to1Mng@@V?$allocator@U__GC1TO1TENDER@CGuildCombat1to1Mng@@@std@@@std@@QBEAAU__GC1TO1TENDER@CGuildCombat1to1Mng@@XZ ENDP ; std::vector<CGuildCombat1to1Mng::__GC1TO1TENDER,std::allocator<CGuildCombat1to1Mng::__GC1TO1TENDER> >::iterator::operator*
_TEXT	ENDS
PUBLIC	??Hiterator@?$vector@U__GC1TO1TENDER@CGuildCombat1to1Mng@@V?$allocator@U__GC1TO1TENDER@CGuildCombat1to1Mng@@@std@@@std@@QBE?AV012@H@Z ; std::vector<CGuildCombat1to1Mng::__GC1TO1TENDER,std::allocator<CGuildCombat1to1Mng::__GC1TO1TENDER> >::iterator::operator+
; Function compile flags: /Ogty
;	COMDAT ??Hiterator@?$vector@U__GC1TO1TENDER@CGuildCombat1to1Mng@@V?$allocator@U__GC1TO1TENDER@CGuildCombat1to1Mng@@@std@@@std@@QBE?AV012@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??Hiterator@?$vector@U__GC1TO1TENDER@CGuildCombat1to1Mng@@V?$allocator@U__GC1TO1TENDER@CGuildCombat1to1Mng@@@std@@@std@@QBE?AV012@H@Z PROC NEAR ; std::vector<CGuildCombat1to1Mng::__GC1TO1TENDER,std::allocator<CGuildCombat1to1Mng::__GC1TO1TENDER> >::iterator::operator+, COMDAT
; _this$ = ecx

; 262  : 			iterator _Tmp = *this;
; 263  : 			return (_Tmp += _Off);

  00000	8b 44 24 08	 mov	 eax, DWORD PTR __Off$[esp-4]
  00004	8d 14 40	 lea	 edx, DWORD PTR [eax+eax*2]
  00007	8b 01		 mov	 eax, DWORD PTR [ecx]
  00009	c1 e2 04	 shl	 edx, 4
  0000c	03 d0		 add	 edx, eax
  0000e	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  00012	89 10		 mov	 DWORD PTR [eax], edx

; 264  : 			}

  00014	c2 08 00	 ret	 8
??Hiterator@?$vector@U__GC1TO1TENDER@CGuildCombat1to1Mng@@V?$allocator@U__GC1TO1TENDER@CGuildCombat1to1Mng@@@std@@@std@@QBE?AV012@H@Z ENDP ; std::vector<CGuildCombat1to1Mng::__GC1TO1TENDER,std::allocator<CGuildCombat1to1Mng::__GC1TO1TENDER> >::iterator::operator+
_TEXT	ENDS
PUBLIC	??Diterator@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEAAPAU__JOINPLAYER@CGuildCombat@@XZ ; std::vector<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::iterator::operator*
; Function compile flags: /Ogty
;	COMDAT ??Diterator@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEAAPAU__JOINPLAYER@CGuildCombat@@XZ
_TEXT	SEGMENT
??Diterator@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEAAPAU__JOINPLAYER@CGuildCombat@@XZ PROC NEAR ; std::vector<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::iterator::operator*, COMDAT
; _this$ = ecx

; 220  : 			return ((reference)**(const_iterator *)this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 221  : 			}

  00002	c3		 ret	 0
??Diterator@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEAAPAU__JOINPLAYER@CGuildCombat@@XZ ENDP ; std::vector<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::iterator::operator*
_TEXT	ENDS
PUBLIC	??Hiterator@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBE?AV012@H@Z ; std::vector<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::iterator::operator+
; Function compile flags: /Ogty
;	COMDAT ??Hiterator@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBE?AV012@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??Hiterator@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBE?AV012@H@Z PROC NEAR ; std::vector<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::iterator::operator+, COMDAT
; _this$ = ecx

; 262  : 			iterator _Tmp = *this;
; 263  : 			return (_Tmp += _Off);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 4c 24 08	 mov	 ecx, DWORD PTR __Off$[esp-4]
  00006	8d 14 88	 lea	 edx, DWORD PTR [eax+ecx*4]
  00009	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  0000d	89 10		 mov	 DWORD PTR [eax], edx

; 264  : 			}

  0000f	c2 08 00	 ret	 8
??Hiterator@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBE?AV012@H@Z ENDP ; std::vector<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::iterator::operator+
_TEXT	ENDS
PUBLIC	??Diterator@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@QBEAAU__GCGETPOINT@CGuildCombat@@XZ ; std::vector<CGuildCombat::__GCGETPOINT,std::allocator<CGuildCombat::__GCGETPOINT> >::iterator::operator*
; Function compile flags: /Ogty
;	COMDAT ??Diterator@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@QBEAAU__GCGETPOINT@CGuildCombat@@XZ
_TEXT	SEGMENT
??Diterator@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@QBEAAU__GCGETPOINT@CGuildCombat@@XZ PROC NEAR ; std::vector<CGuildCombat::__GCGETPOINT,std::allocator<CGuildCombat::__GCGETPOINT> >::iterator::operator*, COMDAT
; _this$ = ecx

; 220  : 			return ((reference)**(const_iterator *)this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 221  : 			}

  00002	c3		 ret	 0
??Diterator@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@QBEAAU__GCGETPOINT@CGuildCombat@@XZ ENDP ; std::vector<CGuildCombat::__GCGETPOINT,std::allocator<CGuildCombat::__GCGETPOINT> >::iterator::operator*
_TEXT	ENDS
PUBLIC	??Hiterator@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@QBE?AV012@H@Z ; std::vector<CGuildCombat::__GCGETPOINT,std::allocator<CGuildCombat::__GCGETPOINT> >::iterator::operator+
; Function compile flags: /Ogty
;	COMDAT ??Hiterator@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@QBE?AV012@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??Hiterator@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@QBE?AV012@H@Z PROC NEAR ; std::vector<CGuildCombat::__GCGETPOINT,std::allocator<CGuildCombat::__GCGETPOINT> >::iterator::operator+, COMDAT
; _this$ = ecx

; 262  : 			iterator _Tmp = *this;
; 263  : 			return (_Tmp += _Off);

  00000	8b 44 24 08	 mov	 eax, DWORD PTR __Off$[esp-4]
  00004	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00006	8d 04 c0	 lea	 eax, DWORD PTR [eax+eax*8]
  00009	8d 14 81	 lea	 edx, DWORD PTR [ecx+eax*4]
  0000c	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  00010	89 10		 mov	 DWORD PTR [eax], edx

; 264  : 			}

  00012	c2 08 00	 ret	 8
??Hiterator@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@QBE?AV012@H@Z ENDP ; std::vector<CGuildCombat::__GCGETPOINT,std::allocator<CGuildCombat::__GCGETPOINT> >::iterator::operator+
_TEXT	ENDS
PUBLIC	??Diterator@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@QBEAAU__GCPLAYERPOINT@CGuildCombat@@XZ ; std::vector<CGuildCombat::__GCPLAYERPOINT,std::allocator<CGuildCombat::__GCPLAYERPOINT> >::iterator::operator*
; Function compile flags: /Ogty
;	COMDAT ??Diterator@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@QBEAAU__GCPLAYERPOINT@CGuildCombat@@XZ
_TEXT	SEGMENT
??Diterator@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@QBEAAU__GCPLAYERPOINT@CGuildCombat@@XZ PROC NEAR ; std::vector<CGuildCombat::__GCPLAYERPOINT,std::allocator<CGuildCombat::__GCPLAYERPOINT> >::iterator::operator*, COMDAT
; _this$ = ecx

; 220  : 			return ((reference)**(const_iterator *)this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 221  : 			}

  00002	c3		 ret	 0
??Diterator@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@QBEAAU__GCPLAYERPOINT@CGuildCombat@@XZ ENDP ; std::vector<CGuildCombat::__GCPLAYERPOINT,std::allocator<CGuildCombat::__GCPLAYERPOINT> >::iterator::operator*
_TEXT	ENDS
PUBLIC	??Hiterator@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@QBE?AV012@H@Z ; std::vector<CGuildCombat::__GCPLAYERPOINT,std::allocator<CGuildCombat::__GCPLAYERPOINT> >::iterator::operator+
; Function compile flags: /Ogty
;	COMDAT ??Hiterator@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@QBE?AV012@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??Hiterator@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@QBE?AV012@H@Z PROC NEAR ; std::vector<CGuildCombat::__GCPLAYERPOINT,std::allocator<CGuildCombat::__GCPLAYERPOINT> >::iterator::operator+, COMDAT
; _this$ = ecx

; 262  : 			iterator _Tmp = *this;
; 263  : 			return (_Tmp += _Off);

  00000	8b 44 24 08	 mov	 eax, DWORD PTR __Off$[esp-4]
  00004	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00006	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00009	8d 14 81	 lea	 edx, DWORD PTR [ecx+eax*4]
  0000c	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  00010	89 10		 mov	 DWORD PTR [eax], edx

; 264  : 			}

  00012	c2 08 00	 ret	 8
??Hiterator@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@QBE?AV012@H@Z ENDP ; std::vector<CGuildCombat::__GCPLAYERPOINT,std::allocator<CGuildCombat::__GCPLAYERPOINT> >::iterator::operator+
_TEXT	ENDS
PUBLIC	??Diterator@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QBEAAPAU__GuildCombatMember@CGuildCombat@@XZ ; std::vector<CGuildCombat::__GuildCombatMember *,std::allocator<CGuildCombat::__GuildCombatMember *> >::iterator::operator*
; Function compile flags: /Ogty
;	COMDAT ??Diterator@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QBEAAPAU__GuildCombatMember@CGuildCombat@@XZ
_TEXT	SEGMENT
??Diterator@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QBEAAPAU__GuildCombatMember@CGuildCombat@@XZ PROC NEAR ; std::vector<CGuildCombat::__GuildCombatMember *,std::allocator<CGuildCombat::__GuildCombatMember *> >::iterator::operator*, COMDAT
; _this$ = ecx

; 220  : 			return ((reference)**(const_iterator *)this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 221  : 			}

  00002	c3		 ret	 0
??Diterator@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QBEAAPAU__GuildCombatMember@CGuildCombat@@XZ ENDP ; std::vector<CGuildCombat::__GuildCombatMember *,std::allocator<CGuildCombat::__GuildCombatMember *> >::iterator::operator*
_TEXT	ENDS
PUBLIC	??Hiterator@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QBE?AV012@H@Z ; std::vector<CGuildCombat::__GuildCombatMember *,std::allocator<CGuildCombat::__GuildCombatMember *> >::iterator::operator+
; Function compile flags: /Ogty
;	COMDAT ??Hiterator@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QBE?AV012@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??Hiterator@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QBE?AV012@H@Z PROC NEAR ; std::vector<CGuildCombat::__GuildCombatMember *,std::allocator<CGuildCombat::__GuildCombatMember *> >::iterator::operator+, COMDAT
; _this$ = ecx

; 262  : 			iterator _Tmp = *this;
; 263  : 			return (_Tmp += _Off);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 4c 24 08	 mov	 ecx, DWORD PTR __Off$[esp-4]
  00006	8d 14 88	 lea	 edx, DWORD PTR [eax+ecx*4]
  00009	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  0000d	89 10		 mov	 DWORD PTR [eax], edx

; 264  : 			}

  0000f	c2 08 00	 ret	 8
??Hiterator@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QBE?AV012@H@Z ENDP ; std::vector<CGuildCombat::__GuildCombatMember *,std::allocator<CGuildCombat::__GuildCombatMember *> >::iterator::operator+
_TEXT	ENDS
PUBLIC	??Diterator@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QBEAAU__REQUESTGUILD@CGuildCombat@@XZ ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::iterator::operator*
; Function compile flags: /Ogty
;	COMDAT ??Diterator@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QBEAAU__REQUESTGUILD@CGuildCombat@@XZ
_TEXT	SEGMENT
??Diterator@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QBEAAU__REQUESTGUILD@CGuildCombat@@XZ PROC NEAR ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::iterator::operator*, COMDAT
; _this$ = ecx

; 220  : 			return ((reference)**(const_iterator *)this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 221  : 			}

  00002	c3		 ret	 0
??Diterator@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QBEAAU__REQUESTGUILD@CGuildCombat@@XZ ENDP ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::iterator::operator*
_TEXT	ENDS
PUBLIC	??Hiterator@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QBE?AV012@H@Z ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::iterator::operator+
; Function compile flags: /Ogty
;	COMDAT ??Hiterator@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QBE?AV012@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??Hiterator@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QBE?AV012@H@Z PROC NEAR ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::iterator::operator+, COMDAT
; _this$ = ecx

; 262  : 			iterator _Tmp = *this;
; 263  : 			return (_Tmp += _Off);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 4c 24 08	 mov	 ecx, DWORD PTR __Off$[esp-4]
  00006	8d 14 c8	 lea	 edx, DWORD PTR [eax+ecx*8]
  00009	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  0000d	89 10		 mov	 DWORD PTR [eax], edx

; 264  : 			}

  0000f	c2 08 00	 ret	 8
??Hiterator@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QBE?AV012@H@Z ENDP ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::iterator::operator+
_TEXT	ENDS
PUBLIC	??Diterator@?$vector@U__SECRETROOM_TENDER@@V?$allocator@U__SECRETROOM_TENDER@@@std@@@std@@QBEAAU__SECRETROOM_TENDER@@XZ ; std::vector<__SECRETROOM_TENDER,std::allocator<__SECRETROOM_TENDER> >::iterator::operator*
; Function compile flags: /Ogty
;	COMDAT ??Diterator@?$vector@U__SECRETROOM_TENDER@@V?$allocator@U__SECRETROOM_TENDER@@@std@@@std@@QBEAAU__SECRETROOM_TENDER@@XZ
_TEXT	SEGMENT
??Diterator@?$vector@U__SECRETROOM_TENDER@@V?$allocator@U__SECRETROOM_TENDER@@@std@@@std@@QBEAAU__SECRETROOM_TENDER@@XZ PROC NEAR ; std::vector<__SECRETROOM_TENDER,std::allocator<__SECRETROOM_TENDER> >::iterator::operator*, COMDAT
; _this$ = ecx

; 220  : 			return ((reference)**(const_iterator *)this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 221  : 			}

  00002	c3		 ret	 0
??Diterator@?$vector@U__SECRETROOM_TENDER@@V?$allocator@U__SECRETROOM_TENDER@@@std@@@std@@QBEAAU__SECRETROOM_TENDER@@XZ ENDP ; std::vector<__SECRETROOM_TENDER,std::allocator<__SECRETROOM_TENDER> >::iterator::operator*
_TEXT	ENDS
PUBLIC	??Hiterator@?$vector@U__SECRETROOM_TENDER@@V?$allocator@U__SECRETROOM_TENDER@@@std@@@std@@QBE?AV012@H@Z ; std::vector<__SECRETROOM_TENDER,std::allocator<__SECRETROOM_TENDER> >::iterator::operator+
; Function compile flags: /Ogty
;	COMDAT ??Hiterator@?$vector@U__SECRETROOM_TENDER@@V?$allocator@U__SECRETROOM_TENDER@@@std@@@std@@QBE?AV012@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??Hiterator@?$vector@U__SECRETROOM_TENDER@@V?$allocator@U__SECRETROOM_TENDER@@@std@@@std@@QBE?AV012@H@Z PROC NEAR ; std::vector<__SECRETROOM_TENDER,std::allocator<__SECRETROOM_TENDER> >::iterator::operator+, COMDAT
; _this$ = ecx

; 262  : 			iterator _Tmp = *this;
; 263  : 			return (_Tmp += _Off);

  00000	8b 54 24 08	 mov	 edx, DWORD PTR __Off$[esp-4]
  00004	8b 01		 mov	 eax, DWORD PTR [ecx]
  00006	6b d2 34	 imul	 edx, 52			; 00000034H
  00009	03 d0		 add	 edx, eax
  0000b	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  0000f	89 10		 mov	 DWORD PTR [eax], edx

; 264  : 			}

  00011	c2 08 00	 ret	 8
??Hiterator@?$vector@U__SECRETROOM_TENDER@@V?$allocator@U__SECRETROOM_TENDER@@@std@@@std@@QBE?AV012@H@Z ENDP ; std::vector<__SECRETROOM_TENDER,std::allocator<__SECRETROOM_TENDER> >::iterator::operator+
_TEXT	ENDS
PUBLIC	??Diterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::iterator::operator*
; Function compile flags: /Ogty
;	COMDAT ??Diterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
??Diterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC NEAR ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::iterator::operator*, COMDAT
; _this$ = ecx

; 220  : 			return ((reference)**(const_iterator *)this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 221  : 			}

  00002	c3		 ret	 0
??Diterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::iterator::operator*
_TEXT	ENDS
PUBLIC	??Hiterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBE?AV012@H@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::iterator::operator+
; Function compile flags: /Ogty
;	COMDAT ??Hiterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBE?AV012@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??Hiterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBE?AV012@H@Z PROC NEAR ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::iterator::operator+, COMDAT
; _this$ = ecx

; 262  : 			iterator _Tmp = *this;
; 263  : 			return (_Tmp += _Off);

  00000	8b 54 24 08	 mov	 edx, DWORD PTR __Off$[esp-4]
  00004	8b 01		 mov	 eax, DWORD PTR [ecx]
  00006	6b d2 1c	 imul	 edx, 28			; 0000001cH
  00009	03 d0		 add	 edx, eax
  0000b	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  0000f	89 10		 mov	 DWORD PTR [eax], edx

; 264  : 			}

  00011	c2 08 00	 ret	 8
??Hiterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBE?AV012@H@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::iterator::operator+
_TEXT	ENDS
PUBLIC	??Diterator@?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEAAU__JOINPLAYER@CGuildCombat@@XZ ; std::vector<CGuildCombat::__JOINPLAYER,std::allocator<CGuildCombat::__JOINPLAYER> >::iterator::operator*
; Function compile flags: /Ogty
;	COMDAT ??Diterator@?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEAAU__JOINPLAYER@CGuildCombat@@XZ
_TEXT	SEGMENT
??Diterator@?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEAAU__JOINPLAYER@CGuildCombat@@XZ PROC NEAR ; std::vector<CGuildCombat::__JOINPLAYER,std::allocator<CGuildCombat::__JOINPLAYER> >::iterator::operator*, COMDAT
; _this$ = ecx

; 220  : 			return ((reference)**(const_iterator *)this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 221  : 			}

  00002	c3		 ret	 0
??Diterator@?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEAAU__JOINPLAYER@CGuildCombat@@XZ ENDP ; std::vector<CGuildCombat::__JOINPLAYER,std::allocator<CGuildCombat::__JOINPLAYER> >::iterator::operator*
_TEXT	ENDS
PUBLIC	??Hiterator@?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@QBE?AV012@H@Z ; std::vector<CGuildCombat::__JOINPLAYER,std::allocator<CGuildCombat::__JOINPLAYER> >::iterator::operator+
; Function compile flags: /Ogty
;	COMDAT ??Hiterator@?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@QBE?AV012@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??Hiterator@?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@QBE?AV012@H@Z PROC NEAR ; std::vector<CGuildCombat::__JOINPLAYER,std::allocator<CGuildCombat::__JOINPLAYER> >::iterator::operator+, COMDAT
; _this$ = ecx

; 262  : 			iterator _Tmp = *this;
; 263  : 			return (_Tmp += _Off);

  00000	8b 44 24 08	 mov	 eax, DWORD PTR __Off$[esp-4]
  00004	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00006	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00009	8d 14 c1	 lea	 edx, DWORD PTR [ecx+eax*8]
  0000c	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  00010	89 10		 mov	 DWORD PTR [eax], edx

; 264  : 			}

  00012	c2 08 00	 ret	 8
??Hiterator@?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@QBE?AV012@H@Z ENDP ; std::vector<CGuildCombat::__JOINPLAYER,std::allocator<CGuildCombat::__JOINPLAYER> >::iterator::operator+
_TEXT	ENDS
PUBLIC	??Diterator@?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@QBEAAU__ITEMINFO@@XZ ; std::vector<__ITEMINFO,std::allocator<__ITEMINFO> >::iterator::operator*
; Function compile flags: /Ogty
;	COMDAT ??Diterator@?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@QBEAAU__ITEMINFO@@XZ
_TEXT	SEGMENT
??Diterator@?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@QBEAAU__ITEMINFO@@XZ PROC NEAR ; std::vector<__ITEMINFO,std::allocator<__ITEMINFO> >::iterator::operator*, COMDAT
; _this$ = ecx

; 220  : 			return ((reference)**(const_iterator *)this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 221  : 			}

  00002	c3		 ret	 0
??Diterator@?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@QBEAAU__ITEMINFO@@XZ ENDP ; std::vector<__ITEMINFO,std::allocator<__ITEMINFO> >::iterator::operator*
_TEXT	ENDS
PUBLIC	??Hiterator@?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@QBE?AV012@H@Z ; std::vector<__ITEMINFO,std::allocator<__ITEMINFO> >::iterator::operator+
; Function compile flags: /Ogty
;	COMDAT ??Hiterator@?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@QBE?AV012@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??Hiterator@?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@QBE?AV012@H@Z PROC NEAR ; std::vector<__ITEMINFO,std::allocator<__ITEMINFO> >::iterator::operator+, COMDAT
; _this$ = ecx

; 262  : 			iterator _Tmp = *this;
; 263  : 			return (_Tmp += _Off);

  00000	8b 44 24 08	 mov	 eax, DWORD PTR __Off$[esp-4]
  00004	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00006	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00009	8d 14 81	 lea	 edx, DWORD PTR [ecx+eax*4]
  0000c	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  00010	89 10		 mov	 DWORD PTR [eax], edx

; 264  : 			}

  00012	c2 08 00	 ret	 8
??Hiterator@?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@QBE?AV012@H@Z ENDP ; std::vector<__ITEMINFO,std::allocator<__ITEMINFO> >::iterator::operator+
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::allocate
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ?allocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z PROC NEAR ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::allocate, COMDAT
; _this$ = ecx

; 137  : 		return (_Allocate(_Count, (pointer)0));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Count$[esp-4]
  00004	6b c0 1c	 imul	 eax, 28			; 0000001cH
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0000d	83 c4 04	 add	 esp, 4

; 138  : 		}

  00010	c2 04 00	 ret	 4
?allocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ENDP ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::allocate
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Node *>::destroy
; Function compile flags: /Ogty
;	COMDAT ?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Node *>::destroy, COMDAT
; _this$ = ecx

; 152  : 		_Destroy(_Ptr);
; 153  : 		}

  00000	c2 04 00	 ret	 4
?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Node *>::destroy
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::_Node *>::destroy
; Function compile flags: /Ogty
;	COMDAT ?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::_Node *>::destroy, COMDAT
; _this$ = ecx

; 152  : 		_Destroy(_Ptr);
; 153  : 		}

  00000	c2 04 00	 ret	 4
?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::_Node *>::destroy
_TEXT	ENDS
PUBLIC	?_Root@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Root
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Root@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Root, COMDAT
; _this$ = ecx

; 1064 : 		return (_Parent(_Myhead));

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	83 c0 04	 add	 eax, 4

; 1065 : 		}

  00006	c3		 ret	 0
?_Root@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Root
_TEXT	ENDS
PUBLIC	??Dconst_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBEABU?$pair@$$CBHH@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::const_iterator::operator*
; Function compile flags: /Ogty
;	COMDAT ??Dconst_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBEABU?$pair@$$CBHH@2@XZ
_TEXT	SEGMENT
??Dconst_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBEABU?$pair@$$CBHH@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::const_iterator::operator*, COMDAT
; _this$ = ecx

; 205  : 			return (_Myval(_Ptr));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 0c	 add	 eax, 12			; 0000000cH

; 206  : 			}

  00005	c3		 ret	 0
??Dconst_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBEABU?$pair@$$CBHH@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::const_iterator::operator*
_TEXT	ENDS
PUBLIC	??Dconst_iterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QBEABU?$pair@$$CBKU_Friend@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,_Friend,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,_Friend> >,0> >::const_iterator::operator*
; Function compile flags: /Ogty
;	COMDAT ??Dconst_iterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QBEABU?$pair@$$CBKU_Friend@@@2@XZ
_TEXT	SEGMENT
??Dconst_iterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QBEABU?$pair@$$CBKU_Friend@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,_Friend,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,_Friend> >,0> >::const_iterator::operator*, COMDAT
; _this$ = ecx

; 205  : 			return (_Myval(_Ptr));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 0c	 add	 eax, 12			; 0000000cH

; 206  : 			}

  00005	c3		 ret	 0
??Dconst_iterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QBEABU?$pair@$$CBKU_Friend@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,_Friend,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,_Friend> >,0> >::const_iterator::operator*
_TEXT	ENDS
PUBLIC	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned long,_Friend,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,_Friend> >,0> >::const_iterator::_Inc
; Function compile flags: /Ogty
;	COMDAT ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QAEXXZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,_Friend,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,_Friend> >,0> >::const_iterator::_Inc, COMDAT
; _this$ = ecx

; 268  : 			if (_Isnil(_Ptr))

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8a 50 19	 mov	 dl, BYTE PTR [eax+25]
  00005	84 d2		 test	 dl, dl
  00007	75 4d		 jne	 SHORT $L289725

; 269  : 				;	// end() shouldn't be incremented, don't move
; 270  : 			else if (!_Isnil(_Right(_Ptr)))

  00009	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0000c	53		 push	 ebx
  0000d	8a 5a 19	 mov	 bl, BYTE PTR [edx+25]
  00010	84 db		 test	 bl, bl
  00012	75 1b		 jne	 SHORT $L301579

; 271  : 				_Ptr = _Min(_Right(_Ptr));	// ==> smallest of right subtree

  00014	8b 02		 mov	 eax, DWORD PTR [edx]
  00016	8a 58 19	 mov	 bl, BYTE PTR [eax+25]
  00019	84 db		 test	 bl, bl
  0001b	75 0e		 jne	 SHORT $L301560
  0001d	8d 49 00	 npad	 3
$L301559:
  00020	8b d0		 mov	 edx, eax
  00022	8b 02		 mov	 eax, DWORD PTR [edx]
  00024	8a 58 19	 mov	 bl, BYTE PTR [eax+25]
  00027	84 db		 test	 bl, bl
  00029	74 f5		 je	 SHORT $L301559
$L301560:
  0002b	89 11		 mov	 DWORD PTR [ecx], edx
  0002d	5b		 pop	 ebx

; 279  : 				}
; 280  : 			}

  0002e	c3		 ret	 0
$L301579:

; 272  : 			else
; 273  : 				{	// climb looking for right subtree
; 274  : 				_Nodeptr _Pnode;
; 275  : 				while (!_Isnil(_Pnode = _Parent(_Ptr))
; 276  : 					&& _Ptr == _Right(_Pnode))

  0002f	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00032	8a 50 19	 mov	 dl, BYTE PTR [eax+25]
  00035	84 d2		 test	 dl, dl
  00037	75 1a		 jne	 SHORT $L289729
  00039	8d a4 24 00 00
	00 00		 npad	 7
$L289728:
  00040	8b 11		 mov	 edx, DWORD PTR [ecx]
  00042	3b 50 08	 cmp	 edx, DWORD PTR [eax+8]
  00045	75 0c		 jne	 SHORT $L289729

; 277  : 					_Ptr = _Pnode;	// ==> parent while right subtree

  00047	89 01		 mov	 DWORD PTR [ecx], eax
  00049	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0004c	8a 50 19	 mov	 dl, BYTE PTR [eax+25]
  0004f	84 d2		 test	 dl, dl
  00051	74 ed		 je	 SHORT $L289728
$L289729:

; 278  : 				_Ptr = _Pnode;	// ==> parent (head if end())

  00053	89 01		 mov	 DWORD PTR [ecx], eax
  00055	5b		 pop	 ebx
$L289725:

; 279  : 				}
; 280  : 			}

  00056	c3		 ret	 0
?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,_Friend,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,_Friend> >,0> >::const_iterator::_Inc
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@U_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@@std@@QAEPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@I@Z ; std::allocator<std::_List_nod<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Node>::allocate
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ?allocate@?$allocator@U_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@@std@@QAEPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@U_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@@std@@QAEPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@I@Z PROC NEAR ; std::allocator<std::_List_nod<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Node>::allocate, COMDAT
; _this$ = ecx

; 137  : 		return (_Allocate(_Count, (pointer)0));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Count$[esp-4]
  00004	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00007	c1 e0 02	 shl	 eax, 2
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00010	83 c4 04	 add	 esp, 4

; 138  : 		}

  00013	c2 04 00	 ret	 4
?allocate@?$allocator@U_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@@std@@QAEPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@I@Z ENDP ; std::allocator<std::_List_nod<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Node>::allocate
_TEXT	ENDS
PUBLIC	?construct@?$allocator@PAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@ABQAU342@@Z ; std::allocator<std::_List_nod<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Node *>::construct
; Function compile flags: /Ogty
;	COMDAT ?construct@?$allocator@PAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@ABQAU342@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@PAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@ABQAU342@@Z PROC NEAR ; std::allocator<std::_List_nod<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Node *>::construct, COMDAT
; _this$ = ecx

; 147  : 		_Construct(_Ptr, _Val);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Ptr$[esp-4]
  00004	85 c0		 test	 eax, eax
  00006	74 08		 je	 SHORT $L301601
  00008	8b 4c 24 08	 mov	 ecx, DWORD PTR __Val$[esp-4]
  0000c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000e	89 10		 mov	 DWORD PTR [eax], edx
$L301601:

; 148  : 		}

  00010	c2 08 00	 ret	 8
?construct@?$allocator@PAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@ABQAU342@@Z ENDP ; std::allocator<std::_List_nod<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Node *>::construct
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@PAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@@Z ; std::allocator<std::_List_nod<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Node *>::destroy
; Function compile flags: /Ogty
;	COMDAT ?destroy@?$allocator@PAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@PAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@@Z PROC NEAR ; std::allocator<std::_List_nod<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Node *>::destroy, COMDAT
; _this$ = ecx

; 152  : 		_Destroy(_Ptr);
; 153  : 		}

  00000	c2 04 00	 ret	 4
?destroy@?$allocator@PAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@@Z ENDP ; std::allocator<std::_List_nod<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Node *>::destroy
_TEXT	ENDS
PUBLIC	?max_size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::max_size
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ?max_size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ PROC NEAR ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::max_size, COMDAT
; _this$ = ecx

; 521  : 		return (this->_Alval.max_size());

  00000	b8 49 92 24 09	 mov	 eax, 153391689		; 09249249H

; 522  : 		}

  00005	c3		 ret	 0
?max_size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::max_size
_TEXT	ENDS
PUBLIC	??Dconst_iterator@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@QBEABU?$pair@$$CBKPAVCGuildMember@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,CGuildMember *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuildMember *> >,0> >::const_iterator::operator*
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ??Dconst_iterator@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@QBEABU?$pair@$$CBKPAVCGuildMember@@@2@XZ
_TEXT	SEGMENT
??Dconst_iterator@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@QBEABU?$pair@$$CBKPAVCGuildMember@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CGuildMember *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuildMember *> >,0> >::const_iterator::operator*, COMDAT
; _this$ = ecx

; 205  : 			return (_Myval(_Ptr));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 0c	 add	 eax, 12			; 0000000cH

; 206  : 			}

  00005	c3		 ret	 0
??Dconst_iterator@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@QBEABU?$pair@$$CBKPAVCGuildMember@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CGuildMember *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuildMember *> >,0> >::const_iterator::operator*
_TEXT	ENDS
PUBLIC	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned long,CGuildMember *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuildMember *> >,0> >::const_iterator::_Inc
; Function compile flags: /Ogty
;	COMDAT ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@QAEXXZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CGuildMember *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuildMember *> >,0> >::const_iterator::_Inc, COMDAT
; _this$ = ecx

; 268  : 			if (_Isnil(_Ptr))

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8a 50 15	 mov	 dl, BYTE PTR [eax+21]
  00005	84 d2		 test	 dl, dl
  00007	75 4d		 jne	 SHORT $L290430

; 269  : 				;	// end() shouldn't be incremented, don't move
; 270  : 			else if (!_Isnil(_Right(_Ptr)))

  00009	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0000c	53		 push	 ebx
  0000d	8a 5a 15	 mov	 bl, BYTE PTR [edx+21]
  00010	84 db		 test	 bl, bl
  00012	75 1b		 jne	 SHORT $L301675

; 271  : 				_Ptr = _Min(_Right(_Ptr));	// ==> smallest of right subtree

  00014	8b 02		 mov	 eax, DWORD PTR [edx]
  00016	8a 58 15	 mov	 bl, BYTE PTR [eax+21]
  00019	84 db		 test	 bl, bl
  0001b	75 0e		 jne	 SHORT $L301656
  0001d	8d 49 00	 npad	 3
$L301655:
  00020	8b d0		 mov	 edx, eax
  00022	8b 02		 mov	 eax, DWORD PTR [edx]
  00024	8a 58 15	 mov	 bl, BYTE PTR [eax+21]
  00027	84 db		 test	 bl, bl
  00029	74 f5		 je	 SHORT $L301655
$L301656:
  0002b	89 11		 mov	 DWORD PTR [ecx], edx
  0002d	5b		 pop	 ebx

; 279  : 				}
; 280  : 			}

  0002e	c3		 ret	 0
$L301675:

; 272  : 			else
; 273  : 				{	// climb looking for right subtree
; 274  : 				_Nodeptr _Pnode;
; 275  : 				while (!_Isnil(_Pnode = _Parent(_Ptr))
; 276  : 					&& _Ptr == _Right(_Pnode))

  0002f	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00032	8a 50 15	 mov	 dl, BYTE PTR [eax+21]
  00035	84 d2		 test	 dl, dl
  00037	75 1a		 jne	 SHORT $L290434
  00039	8d a4 24 00 00
	00 00		 npad	 7
$L290433:
  00040	8b 11		 mov	 edx, DWORD PTR [ecx]
  00042	3b 50 08	 cmp	 edx, DWORD PTR [eax+8]
  00045	75 0c		 jne	 SHORT $L290434

; 277  : 					_Ptr = _Pnode;	// ==> parent while right subtree

  00047	89 01		 mov	 DWORD PTR [ecx], eax
  00049	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0004c	8a 50 15	 mov	 dl, BYTE PTR [eax+21]
  0004f	84 d2		 test	 dl, dl
  00051	74 ed		 je	 SHORT $L290433
$L290434:

; 278  : 				_Ptr = _Pnode;	// ==> parent (head if end())

  00053	89 01		 mov	 DWORD PTR [ecx], eax
  00055	5b		 pop	 ebx
$L290430:

; 279  : 				}
; 280  : 			}

  00056	c3		 ret	 0
?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CGuildMember *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuildMember *> >,0> >::const_iterator::_Inc
_TEXT	ENDS
PUBLIC	??Dconst_iterator@?$_Tree@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@std@@QBEABU?$pair@$$CBKPAVCParty@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,CParty *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CParty *> >,0> >::const_iterator::operator*
; Function compile flags: /Ogty
;	COMDAT ??Dconst_iterator@?$_Tree@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@std@@QBEABU?$pair@$$CBKPAVCParty@@@2@XZ
_TEXT	SEGMENT
??Dconst_iterator@?$_Tree@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@std@@QBEABU?$pair@$$CBKPAVCParty@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CParty *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CParty *> >,0> >::const_iterator::operator*, COMDAT
; _this$ = ecx

; 205  : 			return (_Myval(_Ptr));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 0c	 add	 eax, 12			; 0000000cH

; 206  : 			}

  00005	c3		 ret	 0
??Dconst_iterator@?$_Tree@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@std@@QBEABU?$pair@$$CBKPAVCParty@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CParty *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CParty *> >,0> >::const_iterator::operator*
_TEXT	ENDS
PUBLIC	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned long,CParty *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CParty *> >,0> >::const_iterator::_Inc
; Function compile flags: /Ogty
;	COMDAT ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@std@@QAEXXZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CParty *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CParty *> >,0> >::const_iterator::_Inc, COMDAT
; _this$ = ecx

; 268  : 			if (_Isnil(_Ptr))

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8a 50 15	 mov	 dl, BYTE PTR [eax+21]
  00005	84 d2		 test	 dl, dl
  00007	75 4d		 jne	 SHORT $L290444

; 269  : 				;	// end() shouldn't be incremented, don't move
; 270  : 			else if (!_Isnil(_Right(_Ptr)))

  00009	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0000c	53		 push	 ebx
  0000d	8a 5a 15	 mov	 bl, BYTE PTR [edx+21]
  00010	84 db		 test	 bl, bl
  00012	75 1b		 jne	 SHORT $L301731

; 271  : 				_Ptr = _Min(_Right(_Ptr));	// ==> smallest of right subtree

  00014	8b 02		 mov	 eax, DWORD PTR [edx]
  00016	8a 58 15	 mov	 bl, BYTE PTR [eax+21]
  00019	84 db		 test	 bl, bl
  0001b	75 0e		 jne	 SHORT $L301719
  0001d	8d 49 00	 npad	 3
$L301718:
  00020	8b d0		 mov	 edx, eax
  00022	8b 02		 mov	 eax, DWORD PTR [edx]
  00024	8a 58 15	 mov	 bl, BYTE PTR [eax+21]
  00027	84 db		 test	 bl, bl
  00029	74 f5		 je	 SHORT $L301718
$L301719:
  0002b	89 11		 mov	 DWORD PTR [ecx], edx
  0002d	5b		 pop	 ebx

; 279  : 				}
; 280  : 			}

  0002e	c3		 ret	 0
$L301731:

; 272  : 			else
; 273  : 				{	// climb looking for right subtree
; 274  : 				_Nodeptr _Pnode;
; 275  : 				while (!_Isnil(_Pnode = _Parent(_Ptr))
; 276  : 					&& _Ptr == _Right(_Pnode))

  0002f	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00032	8a 50 15	 mov	 dl, BYTE PTR [eax+21]
  00035	84 d2		 test	 dl, dl
  00037	75 1a		 jne	 SHORT $L290448
  00039	8d a4 24 00 00
	00 00		 npad	 7
$L290447:
  00040	8b 11		 mov	 edx, DWORD PTR [ecx]
  00042	3b 50 08	 cmp	 edx, DWORD PTR [eax+8]
  00045	75 0c		 jne	 SHORT $L290448

; 277  : 					_Ptr = _Pnode;	// ==> parent while right subtree

  00047	89 01		 mov	 DWORD PTR [ecx], eax
  00049	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0004c	8a 50 15	 mov	 dl, BYTE PTR [eax+21]
  0004f	84 d2		 test	 dl, dl
  00051	74 ed		 je	 SHORT $L290447
$L290448:

; 278  : 				_Ptr = _Pnode;	// ==> parent (head if end())

  00053	89 01		 mov	 DWORD PTR [ecx], eax
  00055	5b		 pop	 ebx
$L290444:

; 279  : 				}
; 280  : 			}

  00056	c3		 ret	 0
?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CParty *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CParty *> >,0> >::const_iterator::_Inc
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@U_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@@std@@QAEPAU_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@2@I@Z ; std::allocator<std::_List_nod<CUser *,std::allocator<CUser *> >::_Node>::allocate
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ?allocate@?$allocator@U_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@@std@@QAEPAU_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@2@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@U_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@@std@@QAEPAU_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@2@I@Z PROC NEAR ; std::allocator<std::_List_nod<CUser *,std::allocator<CUser *> >::_Node>::allocate, COMDAT
; _this$ = ecx

; 137  : 		return (_Allocate(_Count, (pointer)0));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Count$[esp-4]
  00004	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00007	c1 e0 02	 shl	 eax, 2
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00010	83 c4 04	 add	 esp, 4

; 138  : 		}

  00013	c2 04 00	 ret	 4
?allocate@?$allocator@U_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@@std@@QAEPAU_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@2@I@Z ENDP ; std::allocator<std::_List_nod<CUser *,std::allocator<CUser *> >::_Node>::allocate
_TEXT	ENDS
PUBLIC	?construct@?$allocator@PAU_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@2@ABQAU342@@Z ; std::allocator<std::_List_nod<CUser *,std::allocator<CUser *> >::_Node *>::construct
; Function compile flags: /Ogty
;	COMDAT ?construct@?$allocator@PAU_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@2@ABQAU342@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@PAU_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@2@ABQAU342@@Z PROC NEAR ; std::allocator<std::_List_nod<CUser *,std::allocator<CUser *> >::_Node *>::construct, COMDAT
; _this$ = ecx

; 147  : 		_Construct(_Ptr, _Val);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Ptr$[esp-4]
  00004	85 c0		 test	 eax, eax
  00006	74 08		 je	 SHORT $L301754
  00008	8b 4c 24 08	 mov	 ecx, DWORD PTR __Val$[esp-4]
  0000c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000e	89 10		 mov	 DWORD PTR [eax], edx
$L301754:

; 148  : 		}

  00010	c2 08 00	 ret	 8
?construct@?$allocator@PAU_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@2@ABQAU342@@Z ENDP ; std::allocator<std::_List_nod<CUser *,std::allocator<CUser *> >::_Node *>::construct
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@PAU_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@2@@Z ; std::allocator<std::_List_nod<CUser *,std::allocator<CUser *> >::_Node *>::destroy
; Function compile flags: /Ogty
;	COMDAT ?destroy@?$allocator@PAU_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@PAU_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@2@@Z PROC NEAR ; std::allocator<std::_List_nod<CUser *,std::allocator<CUser *> >::_Node *>::destroy, COMDAT
; _this$ = ecx

; 152  : 		_Destroy(_Ptr);
; 153  : 		}

  00000	c2 04 00	 ret	 4
?destroy@?$allocator@PAU_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@2@@Z ENDP ; std::allocator<std::_List_nod<CUser *,std::allocator<CUser *> >::_Node *>::destroy
_TEXT	ENDS
PUBLIC	?max_size@?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@QBEIXZ ; std::vector<__ITEMINFO,std::allocator<__ITEMINFO> >::max_size
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ?max_size@?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@QBEIXZ PROC NEAR ; std::vector<__ITEMINFO,std::allocator<__ITEMINFO> >::max_size, COMDAT
; _this$ = ecx

; 521  : 		return (this->_Alval.max_size());

  00000	b8 55 55 55 15	 mov	 eax, 357913941		; 15555555H

; 522  : 		}

  00005	c3		 ret	 0
?max_size@?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@QBEIXZ ENDP ; std::vector<__ITEMINFO,std::allocator<__ITEMINFO> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@U__ITEMINFO@@@std@@QAEPAU__ITEMINFO@@I@Z ; std::allocator<__ITEMINFO>::allocate
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ?allocate@?$allocator@U__ITEMINFO@@@std@@QAEPAU__ITEMINFO@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@U__ITEMINFO@@@std@@QAEPAU__ITEMINFO@@I@Z PROC NEAR ; std::allocator<__ITEMINFO>::allocate, COMDAT
; _this$ = ecx

; 137  : 		return (_Allocate(_Count, (pointer)0));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Count$[esp-4]
  00004	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00007	c1 e0 02	 shl	 eax, 2
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00010	83 c4 04	 add	 esp, 4

; 138  : 		}

  00013	c2 04 00	 ret	 4
?allocate@?$allocator@U__ITEMINFO@@@std@@QAEPAU__ITEMINFO@@I@Z ENDP ; std::allocator<__ITEMINFO>::allocate
_TEXT	ENDS
PUBLIC	??0iterator@?$vector@KV?$allocator@K@std@@@std@@QAE@PAK@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::iterator::iterator
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ??0iterator@?$vector@KV?$allocator@K@std@@@std@@QAE@PAK@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0iterator@?$vector@KV?$allocator@K@std@@@std@@QAE@PAK@Z PROC NEAR ; std::vector<unsigned long,std::allocator<unsigned long> >::iterator::iterator, COMDAT
; _this$ = ecx

; 215  : 			{	// construct with pointer _Ptr

  00000	8b c1		 mov	 eax, ecx
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Ptr$[esp-4]
  00006	89 08		 mov	 DWORD PTR [eax], ecx

; 216  : 			}

  00008	c2 04 00	 ret	 4
??0iterator@?$vector@KV?$allocator@K@std@@@std@@QAE@PAK@Z ENDP ; std::vector<unsigned long,std::allocator<unsigned long> >::iterator::iterator
_TEXT	ENDS
PUBLIC	??Giterator@?$vector@KV?$allocator@K@std@@@std@@QBEHABVconst_iterator@12@@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::iterator::operator-
; Function compile flags: /Ogty
;	COMDAT ??Giterator@?$vector@KV?$allocator@K@std@@@std@@QBEHABVconst_iterator@12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??Giterator@?$vector@KV?$allocator@K@std@@@std@@QBEHABVconst_iterator@12@@Z PROC NEAR ; std::vector<unsigned long,std::allocator<unsigned long> >::iterator::operator-, COMDAT
; _this$ = ecx

; 279  : 			return ((const_iterator)*this - _Right);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Right$[esp-4]
  00006	2b 01		 sub	 eax, DWORD PTR [ecx]
  00008	c1 f8 02	 sar	 eax, 2

; 280  : 			}

  0000b	c2 04 00	 ret	 4
??Giterator@?$vector@KV?$allocator@K@std@@@std@@QBEHABVconst_iterator@12@@Z ENDP ; std::vector<unsigned long,std::allocator<unsigned long> >::iterator::operator-
_TEXT	ENDS
PUBLIC	??0iterator@?$vector@HV?$allocator@H@std@@@std@@QAE@PAH@Z ; std::vector<int,std::allocator<int> >::iterator::iterator
; Function compile flags: /Ogty
;	COMDAT ??0iterator@?$vector@HV?$allocator@H@std@@@std@@QAE@PAH@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0iterator@?$vector@HV?$allocator@H@std@@@std@@QAE@PAH@Z PROC NEAR ; std::vector<int,std::allocator<int> >::iterator::iterator, COMDAT
; _this$ = ecx

; 215  : 			{	// construct with pointer _Ptr

  00000	8b c1		 mov	 eax, ecx
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Ptr$[esp-4]
  00006	89 08		 mov	 DWORD PTR [eax], ecx

; 216  : 			}

  00008	c2 04 00	 ret	 4
??0iterator@?$vector@HV?$allocator@H@std@@@std@@QAE@PAH@Z ENDP ; std::vector<int,std::allocator<int> >::iterator::iterator
_TEXT	ENDS
PUBLIC	??0iterator@?$vector@EV?$allocator@E@std@@@std@@QAE@PAE@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::iterator::iterator
; Function compile flags: /Ogty
;	COMDAT ??0iterator@?$vector@EV?$allocator@E@std@@@std@@QAE@PAE@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0iterator@?$vector@EV?$allocator@E@std@@@std@@QAE@PAE@Z PROC NEAR ; std::vector<unsigned char,std::allocator<unsigned char> >::iterator::iterator, COMDAT
; _this$ = ecx

; 215  : 			{	// construct with pointer _Ptr

  00000	8b c1		 mov	 eax, ecx
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Ptr$[esp-4]
  00006	89 08		 mov	 DWORD PTR [eax], ecx

; 216  : 			}

  00008	c2 04 00	 ret	 4
??0iterator@?$vector@EV?$allocator@E@std@@@std@@QAE@PAE@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::iterator::iterator
_TEXT	ENDS
PUBLIC	??0iterator@?$vector@VCGuildCombat1to1@@V?$allocator@VCGuildCombat1to1@@@std@@@std@@QAE@PAVCGuildCombat1to1@@@Z ; std::vector<CGuildCombat1to1,std::allocator<CGuildCombat1to1> >::iterator::iterator
; Function compile flags: /Ogty
;	COMDAT ??0iterator@?$vector@VCGuildCombat1to1@@V?$allocator@VCGuildCombat1to1@@@std@@@std@@QAE@PAVCGuildCombat1to1@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0iterator@?$vector@VCGuildCombat1to1@@V?$allocator@VCGuildCombat1to1@@@std@@@std@@QAE@PAVCGuildCombat1to1@@@Z PROC NEAR ; std::vector<CGuildCombat1to1,std::allocator<CGuildCombat1to1> >::iterator::iterator, COMDAT
; _this$ = ecx

; 215  : 			{	// construct with pointer _Ptr

  00000	8b c1		 mov	 eax, ecx
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Ptr$[esp-4]
  00006	89 08		 mov	 DWORD PTR [eax], ecx

; 216  : 			}

  00008	c2 04 00	 ret	 4
??0iterator@?$vector@VCGuildCombat1to1@@V?$allocator@VCGuildCombat1to1@@@std@@@std@@QAE@PAVCGuildCombat1to1@@@Z ENDP ; std::vector<CGuildCombat1to1,std::allocator<CGuildCombat1to1> >::iterator::iterator
_TEXT	ENDS
PUBLIC	??0iterator@?$vector@U__GC1TO1TENDER@CGuildCombat1to1Mng@@V?$allocator@U__GC1TO1TENDER@CGuildCombat1to1Mng@@@std@@@std@@QAE@PAU__GC1TO1TENDER@CGuildCombat1to1Mng@@@Z ; std::vector<CGuildCombat1to1Mng::__GC1TO1TENDER,std::allocator<CGuildCombat1to1Mng::__GC1TO1TENDER> >::iterator::iterator
; Function compile flags: /Ogty
;	COMDAT ??0iterator@?$vector@U__GC1TO1TENDER@CGuildCombat1to1Mng@@V?$allocator@U__GC1TO1TENDER@CGuildCombat1to1Mng@@@std@@@std@@QAE@PAU__GC1TO1TENDER@CGuildCombat1to1Mng@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0iterator@?$vector@U__GC1TO1TENDER@CGuildCombat1to1Mng@@V?$allocator@U__GC1TO1TENDER@CGuildCombat1to1Mng@@@std@@@std@@QAE@PAU__GC1TO1TENDER@CGuildCombat1to1Mng@@@Z PROC NEAR ; std::vector<CGuildCombat1to1Mng::__GC1TO1TENDER,std::allocator<CGuildCombat1to1Mng::__GC1TO1TENDER> >::iterator::iterator, COMDAT
; _this$ = ecx

; 215  : 			{	// construct with pointer _Ptr

  00000	8b c1		 mov	 eax, ecx
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Ptr$[esp-4]
  00006	89 08		 mov	 DWORD PTR [eax], ecx

; 216  : 			}

  00008	c2 04 00	 ret	 4
??0iterator@?$vector@U__GC1TO1TENDER@CGuildCombat1to1Mng@@V?$allocator@U__GC1TO1TENDER@CGuildCombat1to1Mng@@@std@@@std@@QAE@PAU__GC1TO1TENDER@CGuildCombat1to1Mng@@@Z ENDP ; std::vector<CGuildCombat1to1Mng::__GC1TO1TENDER,std::allocator<CGuildCombat1to1Mng::__GC1TO1TENDER> >::iterator::iterator
_TEXT	ENDS
PUBLIC	??0iterator@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE@PAPAU__JOINPLAYER@CGuildCombat@@@Z ; std::vector<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::iterator::iterator
; Function compile flags: /Ogty
;	COMDAT ??0iterator@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE@PAPAU__JOINPLAYER@CGuildCombat@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0iterator@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE@PAPAU__JOINPLAYER@CGuildCombat@@@Z PROC NEAR ; std::vector<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::iterator::iterator, COMDAT
; _this$ = ecx

; 215  : 			{	// construct with pointer _Ptr

  00000	8b c1		 mov	 eax, ecx
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Ptr$[esp-4]
  00006	89 08		 mov	 DWORD PTR [eax], ecx

; 216  : 			}

  00008	c2 04 00	 ret	 4
??0iterator@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE@PAPAU__JOINPLAYER@CGuildCombat@@@Z ENDP ; std::vector<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::iterator::iterator
_TEXT	ENDS
PUBLIC	??0iterator@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@QAE@PAU__GCGETPOINT@CGuildCombat@@@Z ; std::vector<CGuildCombat::__GCGETPOINT,std::allocator<CGuildCombat::__GCGETPOINT> >::iterator::iterator
; Function compile flags: /Ogty
;	COMDAT ??0iterator@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@QAE@PAU__GCGETPOINT@CGuildCombat@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0iterator@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@QAE@PAU__GCGETPOINT@CGuildCombat@@@Z PROC NEAR ; std::vector<CGuildCombat::__GCGETPOINT,std::allocator<CGuildCombat::__GCGETPOINT> >::iterator::iterator, COMDAT
; _this$ = ecx

; 215  : 			{	// construct with pointer _Ptr

  00000	8b c1		 mov	 eax, ecx
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Ptr$[esp-4]
  00006	89 08		 mov	 DWORD PTR [eax], ecx

; 216  : 			}

  00008	c2 04 00	 ret	 4
??0iterator@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@QAE@PAU__GCGETPOINT@CGuildCombat@@@Z ENDP ; std::vector<CGuildCombat::__GCGETPOINT,std::allocator<CGuildCombat::__GCGETPOINT> >::iterator::iterator
_TEXT	ENDS
PUBLIC	??0iterator@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@QAE@PAU__GCPLAYERPOINT@CGuildCombat@@@Z ; std::vector<CGuildCombat::__GCPLAYERPOINT,std::allocator<CGuildCombat::__GCPLAYERPOINT> >::iterator::iterator
; Function compile flags: /Ogty
;	COMDAT ??0iterator@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@QAE@PAU__GCPLAYERPOINT@CGuildCombat@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0iterator@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@QAE@PAU__GCPLAYERPOINT@CGuildCombat@@@Z PROC NEAR ; std::vector<CGuildCombat::__GCPLAYERPOINT,std::allocator<CGuildCombat::__GCPLAYERPOINT> >::iterator::iterator, COMDAT
; _this$ = ecx

; 215  : 			{	// construct with pointer _Ptr

  00000	8b c1		 mov	 eax, ecx
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Ptr$[esp-4]
  00006	89 08		 mov	 DWORD PTR [eax], ecx

; 216  : 			}

  00008	c2 04 00	 ret	 4
??0iterator@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@QAE@PAU__GCPLAYERPOINT@CGuildCombat@@@Z ENDP ; std::vector<CGuildCombat::__GCPLAYERPOINT,std::allocator<CGuildCombat::__GCPLAYERPOINT> >::iterator::iterator
_TEXT	ENDS
PUBLIC	??0iterator@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QAE@PAPAU__GuildCombatMember@CGuildCombat@@@Z ; std::vector<CGuildCombat::__GuildCombatMember *,std::allocator<CGuildCombat::__GuildCombatMember *> >::iterator::iterator
; Function compile flags: /Ogty
;	COMDAT ??0iterator@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QAE@PAPAU__GuildCombatMember@CGuildCombat@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0iterator@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QAE@PAPAU__GuildCombatMember@CGuildCombat@@@Z PROC NEAR ; std::vector<CGuildCombat::__GuildCombatMember *,std::allocator<CGuildCombat::__GuildCombatMember *> >::iterator::iterator, COMDAT
; _this$ = ecx

; 215  : 			{	// construct with pointer _Ptr

  00000	8b c1		 mov	 eax, ecx
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Ptr$[esp-4]
  00006	89 08		 mov	 DWORD PTR [eax], ecx

; 216  : 			}

  00008	c2 04 00	 ret	 4
??0iterator@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QAE@PAPAU__GuildCombatMember@CGuildCombat@@@Z ENDP ; std::vector<CGuildCombat::__GuildCombatMember *,std::allocator<CGuildCombat::__GuildCombatMember *> >::iterator::iterator
_TEXT	ENDS
PUBLIC	??0iterator@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QAE@PAU__REQUESTGUILD@CGuildCombat@@@Z ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::iterator::iterator
; Function compile flags: /Ogty
;	COMDAT ??0iterator@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QAE@PAU__REQUESTGUILD@CGuildCombat@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0iterator@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QAE@PAU__REQUESTGUILD@CGuildCombat@@@Z PROC NEAR ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::iterator::iterator, COMDAT
; _this$ = ecx

; 215  : 			{	// construct with pointer _Ptr

  00000	8b c1		 mov	 eax, ecx
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Ptr$[esp-4]
  00006	89 08		 mov	 DWORD PTR [eax], ecx

; 216  : 			}

  00008	c2 04 00	 ret	 4
??0iterator@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QAE@PAU__REQUESTGUILD@CGuildCombat@@@Z ENDP ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::iterator::iterator
_TEXT	ENDS
PUBLIC	??0iterator@?$vector@U__SECRETROOM_TENDER@@V?$allocator@U__SECRETROOM_TENDER@@@std@@@std@@QAE@PAU__SECRETROOM_TENDER@@@Z ; std::vector<__SECRETROOM_TENDER,std::allocator<__SECRETROOM_TENDER> >::iterator::iterator
; Function compile flags: /Ogty
;	COMDAT ??0iterator@?$vector@U__SECRETROOM_TENDER@@V?$allocator@U__SECRETROOM_TENDER@@@std@@@std@@QAE@PAU__SECRETROOM_TENDER@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0iterator@?$vector@U__SECRETROOM_TENDER@@V?$allocator@U__SECRETROOM_TENDER@@@std@@@std@@QAE@PAU__SECRETROOM_TENDER@@@Z PROC NEAR ; std::vector<__SECRETROOM_TENDER,std::allocator<__SECRETROOM_TENDER> >::iterator::iterator, COMDAT
; _this$ = ecx

; 215  : 			{	// construct with pointer _Ptr

  00000	8b c1		 mov	 eax, ecx
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Ptr$[esp-4]
  00006	89 08		 mov	 DWORD PTR [eax], ecx

; 216  : 			}

  00008	c2 04 00	 ret	 4
??0iterator@?$vector@U__SECRETROOM_TENDER@@V?$allocator@U__SECRETROOM_TENDER@@@std@@@std@@QAE@PAU__SECRETROOM_TENDER@@@Z ENDP ; std::vector<__SECRETROOM_TENDER,std::allocator<__SECRETROOM_TENDER> >::iterator::iterator
_TEXT	ENDS
PUBLIC	??0iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::iterator::iterator
; Function compile flags: /Ogty
;	COMDAT ??0iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z PROC NEAR ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::iterator::iterator, COMDAT
; _this$ = ecx

; 215  : 			{	// construct with pointer _Ptr

  00000	8b c1		 mov	 eax, ecx
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Ptr$[esp-4]
  00006	89 08		 mov	 DWORD PTR [eax], ecx

; 216  : 			}

  00008	c2 04 00	 ret	 4
??0iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::iterator::iterator
_TEXT	ENDS
PUBLIC	??Giterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEHABVconst_iterator@12@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::iterator::operator-
; Function compile flags: /Ogty
;	COMDAT ??Giterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEHABVconst_iterator@12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??Giterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEHABVconst_iterator@12@@Z PROC NEAR ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::iterator::operator-, COMDAT
; _this$ = ecx

; 279  : 			return ((const_iterator)*this - _Right);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Right$[esp-4]
  00006	2b 01		 sub	 eax, DWORD PTR [ecx]
  00008	8b c8		 mov	 ecx, eax
  0000a	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  0000f	f7 e9		 imul	 ecx
  00011	03 d1		 add	 edx, ecx
  00013	c1 fa 04	 sar	 edx, 4
  00016	8b c2		 mov	 eax, edx
  00018	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0001b	03 c2		 add	 eax, edx

; 280  : 			}

  0001d	c2 04 00	 ret	 4
??Giterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEHABVconst_iterator@12@@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::iterator::operator-
_TEXT	ENDS
PUBLIC	??0iterator@?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE@PAU__JOINPLAYER@CGuildCombat@@@Z ; std::vector<CGuildCombat::__JOINPLAYER,std::allocator<CGuildCombat::__JOINPLAYER> >::iterator::iterator
; Function compile flags: /Ogty
;	COMDAT ??0iterator@?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE@PAU__JOINPLAYER@CGuildCombat@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0iterator@?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE@PAU__JOINPLAYER@CGuildCombat@@@Z PROC NEAR ; std::vector<CGuildCombat::__JOINPLAYER,std::allocator<CGuildCombat::__JOINPLAYER> >::iterator::iterator, COMDAT
; _this$ = ecx

; 215  : 			{	// construct with pointer _Ptr

  00000	8b c1		 mov	 eax, ecx
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Ptr$[esp-4]
  00006	89 08		 mov	 DWORD PTR [eax], ecx

; 216  : 			}

  00008	c2 04 00	 ret	 4
??0iterator@?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE@PAU__JOINPLAYER@CGuildCombat@@@Z ENDP ; std::vector<CGuildCombat::__JOINPLAYER,std::allocator<CGuildCombat::__JOINPLAYER> >::iterator::iterator
_TEXT	ENDS
PUBLIC	??0iterator@?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@QAE@PAU__ITEMINFO@@@Z ; std::vector<__ITEMINFO,std::allocator<__ITEMINFO> >::iterator::iterator
; Function compile flags: /Ogty
;	COMDAT ??0iterator@?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@QAE@PAU__ITEMINFO@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0iterator@?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@QAE@PAU__ITEMINFO@@@Z PROC NEAR ; std::vector<__ITEMINFO,std::allocator<__ITEMINFO> >::iterator::iterator, COMDAT
; _this$ = ecx

; 215  : 			{	// construct with pointer _Ptr

  00000	8b c1		 mov	 eax, ecx
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Ptr$[esp-4]
  00006	89 08		 mov	 DWORD PTR [eax], ecx

; 216  : 			}

  00008	c2 04 00	 ret	 4
??0iterator@?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@QAE@PAU__ITEMINFO@@@Z ENDP ; std::vector<__ITEMINFO,std::allocator<__ITEMINFO> >::iterator::iterator
_TEXT	ENDS
PUBLIC	?SetPosChanged@CObj@@QAEXH@Z			; CObj::SetPosChanged
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\obj.h
;	COMDAT ?SetPosChanged@CObj@@QAEXH@Z
_TEXT	SEGMENT
_bUpdate$ = 8						; size = 4
?SetPosChanged@CObj@@QAEXH@Z PROC NEAR			; CObj::SetPosChanged, COMDAT
; _this$ = ecx

; 183  : 	void			SetPosChanged( BOOL bUpdate) { SetFlag( bUpdate, OBJ_FLAG_POSCHANGED ); }

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _bUpdate$[esp-4]
  00004	85 c0		 test	 eax, eax
  00006	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00009	74 09		 je	 SHORT $L301884
  0000b	83 c8 10	 or	 eax, 16			; 00000010H
  0000e	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00011	c2 04 00	 ret	 4
$L301884:
  00014	83 e0 ef	 and	 eax, -17		; ffffffefH
  00017	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  0001a	c2 04 00	 ret	 4
?SetPosChanged@CObj@@QAEXH@Z ENDP			; CObj::SetPosChanged
_TEXT	ENDS
PUBLIC	??Giterator@?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@QBEHABVconst_iterator@12@@Z ; std::vector<__ITEMINFO,std::allocator<__ITEMINFO> >::iterator::operator-
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ??Giterator@?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@QBEHABVconst_iterator@12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??Giterator@?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@QBEHABVconst_iterator@12@@Z PROC NEAR ; std::vector<__ITEMINFO,std::allocator<__ITEMINFO> >::iterator::operator-, COMDAT
; _this$ = ecx

; 279  : 			return ((const_iterator)*this - _Right);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Right$[esp-4]
  00006	2b 01		 sub	 eax, DWORD PTR [ecx]
  00008	8b c8		 mov	 ecx, eax
  0000a	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0000f	f7 e9		 imul	 ecx
  00011	d1 fa		 sar	 edx, 1
  00013	8b c2		 mov	 eax, edx
  00015	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00018	03 c2		 add	 eax, edx

; 280  : 			}

  0001a	c2 04 00	 ret	 4
??Giterator@?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@QBEHABVconst_iterator@12@@Z ENDP ; std::vector<__ITEMINFO,std::allocator<__ITEMINFO> >::iterator::operator-
_TEXT	ENDS
PUBLIC	??0?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z ; std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ??0?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 1
??0?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z PROC NEAR ; std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >, COMDAT
; _this$ = ecx

; 54   : 		{	// construct traits from _Parg and allocator from _Al

  00000	8b c1		 mov	 eax, ecx

; 55   : 		}

  00002	c2 08 00	 ret	 8
??0?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z ENDP ; std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node>::allocate
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@I@Z PROC NEAR ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node>::allocate, COMDAT
; _this$ = ecx

; 137  : 		return (_Allocate(_Count, (pointer)0));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Count$[esp-4]
  00004	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00007	c1 e0 03	 shl	 eax, 3
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00010	83 c4 04	 add	 esp, 4

; 138  : 		}

  00013	c2 04 00	 ret	 4
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node>::allocate
_TEXT	ENDS
PUBLIC	?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@ABQAU342@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node *>::construct
; Function compile flags: /Ogty
;	COMDAT ?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@ABQAU342@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@ABQAU342@@Z PROC NEAR ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node *>::construct, COMDAT
; _this$ = ecx

; 147  : 		_Construct(_Ptr, _Val);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Ptr$[esp-4]
  00004	85 c0		 test	 eax, eax
  00006	74 08		 je	 SHORT $L301923
  00008	8b 4c 24 08	 mov	 ecx, DWORD PTR __Val$[esp-4]
  0000c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000e	89 10		 mov	 DWORD PTR [eax], edx
$L301923:

; 148  : 		}

  00010	c2 08 00	 ret	 8
?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@ABQAU342@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node *>::construct
_TEXT	ENDS
PUBLIC	?max_size@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEIXZ ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::max_size
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\list
;	COMDAT ?max_size@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEIXZ PROC NEAR ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::max_size, COMDAT
; _this$ = ecx

; 436  : 		return (this->_Alval.max_size());

  00000	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 437  : 		}

  00005	c3		 ret	 0
?max_size@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEIXZ ENDP ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::max_size
_TEXT	ENDS
PUBLIC	??0?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAE@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@1@@Z ; std::_List_nod<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_List_nod<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >
; Function compile flags: /Ogty
;	COMDAT ??0?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAE@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAE@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@1@@Z PROC NEAR ; std::_List_nod<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_List_nod<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >, COMDAT
; _this$ = ecx

; 44   : 		{	// construct allocator from _Al

  00000	8b c1		 mov	 eax, ecx

; 45   : 		}

  00002	c2 04 00	 ret	 4
??0?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAE@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@1@@Z ENDP ; std::_List_nod<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_List_nod<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >
_TEXT	ENDS
PUBLIC	?max_size@?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@QBEIXZ ; std::list<CUser *,std::allocator<CUser *> >::max_size
; Function compile flags: /Ogty
;	COMDAT ?max_size@?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@QBEIXZ PROC NEAR ; std::list<CUser *,std::allocator<CUser *> >::max_size, COMDAT
; _this$ = ecx

; 436  : 		return (this->_Alval.max_size());

  00000	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 437  : 		}

  00005	c3		 ret	 0
?max_size@?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@QBEIXZ ENDP ; std::list<CUser *,std::allocator<CUser *> >::max_size
_TEXT	ENDS
PUBLIC	??0?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@IAE@V?$allocator@PAVCUser@@@1@@Z ; std::_List_nod<CUser *,std::allocator<CUser *> >::_List_nod<CUser *,std::allocator<CUser *> >
; Function compile flags: /Ogty
;	COMDAT ??0?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@IAE@V?$allocator@PAVCUser@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@IAE@V?$allocator@PAVCUser@@@1@@Z PROC NEAR ; std::_List_nod<CUser *,std::allocator<CUser *> >::_List_nod<CUser *,std::allocator<CUser *> >, COMDAT
; _this$ = ecx

; 44   : 		{	// construct allocator from _Al

  00000	8b c1		 mov	 eax, ecx

; 45   : 		}

  00002	c2 04 00	 ret	 4
??0?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@IAE@V?$allocator@PAVCUser@@@1@@Z ENDP ; std::_List_nod<CUser *,std::allocator<CUser *> >::_List_nod<CUser *,std::allocator<CUser *> >
_TEXT	ENDS
PUBLIC	??_C@_0BI@BEIFNGEL@GetItemProp?5range_error?$AA@ ; `string'
PUBLIC	?GetItemProp@CProject@@QAEPAUItemProp@@H@Z	; CProject::GetItemProp
;	COMDAT ??_C@_0BI@BEIFNGEL@GetItemProp?5range_error?$AA@
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\data.h
CONST	SEGMENT
??_C@_0BI@BEIFNGEL@GetItemProp?5range_error?$AA@ DB 'GetItemProp range_er'
	DB	'ror', 00H					; `string'
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\project.h
CONST	ENDS
;	COMDAT ?GetItemProp@CProject@@QAEPAUItemProp@@H@Z
_TEXT	SEGMENT
_nIndex$ = 8						; size = 4
?GetItemProp@CProject@@QAEPAUItemProp@@H@Z PROC NEAR	; CProject::GetItemProp, COMDAT
; _this$ = ecx

; 1364 : 	VERIFY_RANGE_ASSERT( nIndex, 0, m_aPropItem.GetSize(), "GetItemProp range_error", NULL );

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _nIndex$[esp-4]
  00004	85 c0		 test	 eax, eax
  00006	7c 1a		 jl	 SHORT $L197914
  00008	8b 91 5c 02 00
	00		 mov	 edx, DWORD PTR [ecx+604]
  0000e	3b c2		 cmp	 eax, edx
  00010	7d 10		 jge	 SHORT $L197914

; 1365 : 	return m_aPropItem.GetAt( nIndex ); 

  00012	3b c2		 cmp	 eax, edx
  00014	73 28		 jae	 SHORT $L301985
  00016	8b 89 4c 02 00
	00		 mov	 ecx, DWORD PTR [ecx+588]
  0001c	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]

; 1366 : }

  0001f	c2 04 00	 ret	 4
$L197914:

; 1364 : 	VERIFY_RANGE_ASSERT( nIndex, 0, m_aPropItem.GetSize(), "GetItemProp range_error", NULL );

  00022	8b 91 5c 02 00
	00		 mov	 edx, DWORD PTR [ecx+604]
  00028	50		 push	 eax
  00029	52		 push	 edx
  0002a	6a 00		 push	 0
  0002c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BI@BEIFNGEL@GetItemProp?5range_error?$AA@
  00031	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@HMFGHCP@?$CFs?5min?3?$CFd?0?5max?3?$CFd?0?5index?3?$CFd?$AA@
  00036	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  0003b	83 c4 14	 add	 esp, 20			; 00000014H
$L301985:
  0003e	33 c0		 xor	 eax, eax

; 1366 : }

  00040	c2 04 00	 ret	 4
?GetItemProp@CProject@@QAEPAUItemProp@@H@Z ENDP		; CProject::GetItemProp
_TEXT	ENDS
PUBLIC	??_C@_0BE@OHDBLHOM@GetText?5range_error?$AA@	; `string'
PUBLIC	??_C@_05KKCIMGE@error?$AA@			; `string'
PUBLIC	?GetText@CProject@@QAEPBDK@Z			; CProject::GetText
;	COMDAT ??_C@_0BE@OHDBLHOM@GetText?5range_error?$AA@
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\data.h
CONST	SEGMENT
??_C@_0BE@OHDBLHOM@GetText?5range_error?$AA@ DB 'GetText range_error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05KKCIMGE@error?$AA@
CONST	SEGMENT
??_C@_05KKCIMGE@error?$AA@ DB 'error', 00H		; `string'
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\project.h
CONST	ENDS
;	COMDAT ?GetText@CProject@@QAEPBDK@Z
_TEXT	SEGMENT
_dwIndex$ = 8						; size = 4
?GetText@CProject@@QAEPBDK@Z PROC NEAR			; CProject::GetText, COMDAT
; _this$ = ecx

; 1402 : 	VERIFY_RANGE( (int)( dwIndex ), 0, m_colorText.GetSize(), "GetText range_error", "error" );

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _dwIndex$[esp-4]
  00004	85 c0		 test	 eax, eax
  00006	7c 41		 jl	 SHORT $L197970
  00008	8b 91 c8 02 00
	00		 mov	 edx, DWORD PTR [ecx+712]
  0000e	3b c2		 cmp	 eax, edx
  00010	7d 37		 jge	 SHORT $L197970

; 1403 : 	if( m_colorText.GetAt( dwIndex ) == NULL )

  00012	3b c2		 cmp	 eax, edx
  00014	73 0c		 jae	 SHORT $L302013
  00016	8b 91 b8 02 00
	00		 mov	 edx, DWORD PTR [ecx+696]
  0001c	83 3c 82 00	 cmp	 DWORD PTR [edx+eax*4], 0
  00020	75 08		 jne	 SHORT $L197974
$L302013:

; 1404 : 		return "";

  00022	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@

; 1406 : }

  00027	c2 04 00	 ret	 4
$L197974:

; 1405 : 	return m_colorText.GetAt( dwIndex )->lpszData; 

  0002a	3b 81 c8 02 00
	00		 cmp	 eax, DWORD PTR [ecx+712]
  00030	72 08		 jb	 SHORT $L302009
  00032	33 c0		 xor	 eax, eax
  00034	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 1406 : }

  00037	c2 04 00	 ret	 4

; 1405 : 	return m_colorText.GetAt( dwIndex )->lpszData; 

$L302009:
  0003a	8b 89 b8 02 00
	00		 mov	 ecx, DWORD PTR [ecx+696]
  00040	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  00043	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 1406 : }

  00046	c2 04 00	 ret	 4
$L197970:

; 1402 : 	VERIFY_RANGE( (int)( dwIndex ), 0, m_colorText.GetSize(), "GetText range_error", "error" );

  00049	8b 91 c8 02 00
	00		 mov	 edx, DWORD PTR [ecx+712]
  0004f	50		 push	 eax
  00050	52		 push	 edx
  00051	6a 00		 push	 0
  00053	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BE@OHDBLHOM@GetText?5range_error?$AA@
  00058	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@HMFGHCP@?$CFs?5min?3?$CFd?0?5max?3?$CFd?0?5index?3?$CFd?$AA@
  0005d	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  00062	83 c4 14	 add	 esp, 20			; 00000014H
  00065	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:??_C@_05KKCIMGE@error?$AA@

; 1406 : }

  0006a	c2 04 00	 ret	 4
?GetText@CProject@@QAEPBDK@Z ENDP			; CProject::GetText
_TEXT	ENDS
PUBLIC	??0?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@K@1@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@1@@Z ; std::_Tree_nod<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Tree_nod<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ??0?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@K@1@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 1
??0?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@K@1@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@1@@Z PROC NEAR ; std::_Tree_nod<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Tree_nod<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >, COMDAT
; _this$ = ecx

; 54   : 		{	// construct traits from _Parg and allocator from _Al

  00000	8b c1		 mov	 eax, ecx

; 55   : 		}

  00002	c2 08 00	 ret	 8
??0?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@K@1@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@1@@Z ENDP ; std::_Tree_nod<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Tree_nod<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >
_TEXT	ENDS
PUBLIC	?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@ABQAU342@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Node *>::construct
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@ABQAU342@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@ABQAU342@@Z PROC NEAR ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Node *>::construct, COMDAT
; _this$ = ecx

; 147  : 		_Construct(_Ptr, _Val);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Ptr$[esp-4]
  00004	85 c0		 test	 eax, eax
  00006	74 08		 je	 SHORT $L302036
  00008	8b 4c 24 08	 mov	 ecx, DWORD PTR __Val$[esp-4]
  0000c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000e	89 10		 mov	 DWORD PTR [eax], edx
$L302036:

; 148  : 		}

  00010	c2 08 00	 ret	 8
?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@ABQAU342@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Node *>::construct
_TEXT	ENDS
PUBLIC	??0?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@K@1@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@1@@Z ; std::_Tree_nod<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::_Tree_nod<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ??0?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@K@1@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 1
??0?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@K@1@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@1@@Z PROC NEAR ; std::_Tree_nod<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::_Tree_nod<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >, COMDAT
; _this$ = ecx

; 54   : 		{	// construct traits from _Parg and allocator from _Al

  00000	8b c1		 mov	 eax, ecx

; 55   : 		}

  00002	c2 08 00	 ret	 8
??0?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@K@1@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@1@@Z ENDP ; std::_Tree_nod<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::_Tree_nod<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >
_TEXT	ENDS
PUBLIC	?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@ABQAU342@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::_Node *>::construct
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@ABQAU342@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@ABQAU342@@Z PROC NEAR ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::_Node *>::construct, COMDAT
; _this$ = ecx

; 147  : 		_Construct(_Ptr, _Val);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Ptr$[esp-4]
  00004	85 c0		 test	 eax, eax
  00006	74 08		 je	 SHORT $L302062
  00008	8b 4c 24 08	 mov	 ecx, DWORD PTR __Val$[esp-4]
  0000c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000e	89 10		 mov	 DWORD PTR [eax], edx
$L302062:

; 148  : 		}

  00010	c2 08 00	 ret	 8
?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@ABQAU342@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::_Node *>::construct
_TEXT	ENDS
PUBLIC	?Serialize@?$CItemContainer@VCItemElem@@@@QAEXAAVCAr@@@Z ; CItemContainer<CItemElem>::Serialize
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\item.h
;	COMDAT ?Serialize@?$CItemContainer@VCItemElem@@@@QAEXAAVCAr@@@Z
_TEXT	SEGMENT
_chSize$ = -525						; size = 1
tv342 = -524						; size = 4
_uOffset$291767 = -520					; size = 4
_nBufSize$291774 = -516					; size = 4
_adwObjIndex$ = -512					; size = 512
_ar$ = 8						; size = 4
?Serialize@?$CItemContainer@VCItemElem@@@@QAEXAAVCAr@@@Z PROC NEAR ; CItemContainer<CItemElem>::Serialize, COMDAT
; _this$ = ecx

; 899  : {

  00000	81 ec 10 02 00
	00		 sub	 esp, 528		; 00000210H
  00006	53		 push	 ebx
  00007	55		 push	 ebp
  00008	56		 push	 esi

; 900  : 	DWORD	adwObjIndex[128];
; 901  : 
; 902  : 	unsigned char chSize	= 0;
; 903  : 
; 904  : 	if( ar.IsStoring() )

  00009	8b b4 24 20 02
	00 00		 mov	 esi, DWORD PTR _ar$[esp+536]
  00010	33 c0		 xor	 eax, eax
  00012	8a 06		 mov	 al, BYTE PTR [esi]
  00014	57		 push	 edi
  00015	8b f9		 mov	 edi, ecx
  00017	c6 44 24 13 00	 mov	 BYTE PTR _chSize$[esp+544], 0
  0001c	f7 d0		 not	 eax
  0001e	a8 01		 test	 al, 1
  00020	0f 84 d5 00 00
	00		 je	 $L291765

; 905  : 	{
; 906  : 		
; 907  : 		ar.Write( m_apIndex, sizeof(DWORD) * m_dwItemMax );

  00026	8b 4f 0c	 mov	 ecx, DWORD PTR [edi+12]
  00029	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  0002c	c1 e1 02	 shl	 ecx, 2
  0002f	51		 push	 ecx
  00030	52		 push	 edx
  00031	8b ce		 mov	 ecx, esi
  00033	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write

; 908  : 		
; 909  : 		u_long uOffset	= ar.GetOffset();

  00038	8b 6e 08	 mov	 ebp, DWORD PTR [esi+8]
  0003b	2b 6e 10	 sub	 ebp, DWORD PTR [esi+16]

; 910  : 		ar << chSize;

  0003e	6a 01		 push	 1
  00040	8b ce		 mov	 ecx, esi
  00042	89 6c 24 1c	 mov	 DWORD PTR _uOffset$291767[esp+548], ebp
  00046	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0004b	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0004e	c6 00 00	 mov	 BYTE PTR [eax], 0
  00051	ff 46 08	 inc	 DWORD PTR [esi+8]

; 911  : 
; 912  : 		for( u_char ch = 0; ch < m_dwItemMax; ch++ )	// 0-504

  00054	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  00057	32 db		 xor	 bl, bl
  00059	85 c0		 test	 eax, eax
  0005b	76 6b		 jbe	 SHORT $L291771
  0005d	c7 44 24 14 00
	00 00 00	 mov	 DWORD PTR tv342[esp+544], 0
  00065	eb 09 8d a4 24
	00 00 00 00 8b
	ff		 npad	 11
$L302104:

; 913  : 		{
; 914  : 			if( m_apItem[ch].IsEmpty() == FALSE )

  00070	8b 6c 24 14	 mov	 ebp, DWORD PTR tv342[esp+544]
  00074	8b 4f 10	 mov	 ecx, DWORD PTR [edi+16]
  00077	69 ed b8 00 00
	00		 imul	 ebp, 184		; 000000b8H
  0007d	8b 44 29 0c	 mov	 eax, DWORD PTR [ecx+ebp+12]
  00081	85 c0		 test	 eax, eax
  00083	74 22		 je	 SHORT $L291772

; 915  : 			{
; 916  : 				ar << ch;

  00085	6a 01		 push	 1
  00087	8b ce		 mov	 ecx, esi
  00089	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0008e	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00091	88 1a		 mov	 BYTE PTR [edx], bl
  00093	ff 46 08	 inc	 DWORD PTR [esi+8]

; 917  : 				m_apItem[ch].Serialize( ar );

  00096	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  00099	8b 14 28	 mov	 edx, DWORD PTR [eax+ebp]
  0009c	8d 0c 28	 lea	 ecx, DWORD PTR [eax+ebp]
  0009f	56		 push	 esi
  000a0	ff 52 08	 call	 DWORD PTR [edx+8]

; 918  : 				chSize++;

  000a3	fe 44 24 13	 inc	 BYTE PTR _chSize$[esp+544]
$L291772:

; 919  : 			}
; 920  : 			adwObjIndex[ch]		= m_apItem[ch].m_dwObjIndex;

  000a7	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  000aa	8b 4c 28 08	 mov	 ecx, DWORD PTR [eax+ebp+8]
  000ae	8b 54 24 14	 mov	 edx, DWORD PTR tv342[esp+544]
  000b2	fe c3		 inc	 bl
  000b4	0f b6 c3	 movzx	 eax, bl
  000b7	89 4c 94 20	 mov	 DWORD PTR _adwObjIndex$[esp+edx*4+544], ecx
  000bb	3b 47 0c	 cmp	 eax, DWORD PTR [edi+12]
  000be	89 44 24 14	 mov	 DWORD PTR tv342[esp+544], eax
  000c2	72 ac		 jb	 SHORT $L302104

; 911  : 
; 912  : 		for( u_char ch = 0; ch < m_dwItemMax; ch++ )	// 0-504

  000c4	8b 6c 24 18	 mov	 ebp, DWORD PTR _uOffset$291767[esp+544]
$L291771:

; 921  : 		}
; 922  : 
; 923  : 		ar.Write( adwObjIndex, sizeof(DWORD) * m_dwItemMax );

  000c8	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  000cb	c1 e0 02	 shl	 eax, 2
  000ce	50		 push	 eax
  000cf	8d 4c 24 24	 lea	 ecx, DWORD PTR _adwObjIndex$[esp+548]
  000d3	51		 push	 ecx
  000d4	8b ce		 mov	 ecx, esi
  000d6	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write

; 924  : 
; 925  : 		int nBufSize;
; 926  : 		LPBYTE lpBuf	= ar.GetBuffer( &nBufSize );

  000db	8d 54 24 1c	 lea	 edx, DWORD PTR _nBufSize$291774[esp+544]
  000df	52		 push	 edx
  000e0	8b ce		 mov	 ecx, esi
  000e2	e8 00 00 00 00	 call	 ?GetBuffer@CAr@@QAEPAEPAH@Z ; CAr::GetBuffer

; 927  : 		*( lpBuf + uOffset )	= chSize;

  000e7	8a 4c 24 13	 mov	 cl, BYTE PTR _chSize$[esp+544]
  000eb	5f		 pop	 edi
  000ec	5e		 pop	 esi
  000ed	88 0c 28	 mov	 BYTE PTR [eax+ebp], cl
  000f0	5d		 pop	 ebp
  000f1	5b		 pop	 ebx

; 949  : 		}
; 950  : 	}
; 951  : }

  000f2	81 c4 10 02 00
	00		 add	 esp, 528		; 00000210H
  000f8	c2 04 00	 ret	 4
$L291765:

; 928  : 	}
; 929  : 	else
; 930  : 	{
; 931  : 		ar.Read( m_apIndex, sizeof(DWORD) * m_dwItemMax );

  000fb	8b 57 0c	 mov	 edx, DWORD PTR [edi+12]
  000fe	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00101	c1 e2 02	 shl	 edx, 2
  00104	52		 push	 edx
  00105	50		 push	 eax
  00106	8b ce		 mov	 ecx, esi
  00108	e8 00 00 00 00	 call	 ?Read@CAr@@QAEXPAXI@Z	; CAr::Read

; 932  : 		// Clear
; 933  : 		for( u_long i = 0; i < m_dwItemMax; i++ )

  0010d	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  00110	33 db		 xor	 ebx, ebx
  00112	85 c0		 test	 eax, eax
  00114	76 1b		 jbe	 SHORT $L291781

; 928  : 	}
; 929  : 	else
; 930  : 	{
; 931  : 		ar.Read( m_apIndex, sizeof(DWORD) * m_dwItemMax );

  00116	33 ed		 xor	 ebp, ebp
$L291779:

; 934  : 			m_apItem[i].Empty();

  00118	8b 4f 10	 mov	 ecx, DWORD PTR [edi+16]
  0011b	8b 14 29	 mov	 edx, DWORD PTR [ecx+ebp]
  0011e	03 cd		 add	 ecx, ebp
  00120	ff 52 0c	 call	 DWORD PTR [edx+12]
  00123	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  00126	43		 inc	 ebx
  00127	81 c5 b8 00 00
	00		 add	 ebp, 184		; 000000b8H
  0012d	3b d8		 cmp	 ebx, eax
  0012f	72 e7		 jb	 SHORT $L291779
$L291781:

; 935  : 
; 936  : 		ar >> chSize;

  00131	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00134	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  00137	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
  0013a	3b ca		 cmp	 ecx, edx
  0013c	77 07		 ja	 SHORT $L302088
  0013e	8a 00		 mov	 al, BYTE PTR [eax]
  00140	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  00143	eb 05		 jmp	 SHORT $L302089
$L302088:
  00145	32 c0		 xor	 al, al
  00147	89 56 08	 mov	 DWORD PTR [esi+8], edx
$L302089:

; 946  : 		for( i = 0; i < m_dwItemMax; i++ )

  0014a	0f b6 c0	 movzx	 eax, al
  0014d	85 c0		 test	 eax, eax
  0014f	76 33		 jbe	 SHORT $L291785

; 937  : 
; 938  : 		unsigned char ch;
; 939  : 		for( i = 0; i < chSize; i++ )

  00151	8b d8		 mov	 ebx, eax
$L291783:

; 940  : 		{
; 941  : 			ar >> ch;

  00153	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00156	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  00159	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
  0015c	3b ca		 cmp	 ecx, edx
  0015e	77 07		 ja	 SHORT $L302093
  00160	8a 00		 mov	 al, BYTE PTR [eax]
  00162	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  00165	eb 05		 jmp	 SHORT $L302094
$L302093:
  00167	32 c0		 xor	 al, al
  00169	89 56 08	 mov	 DWORD PTR [esi+8], edx
$L302094:

; 942  : 			m_apItem[ch].Serialize( ar );

  0016c	8b 4f 10	 mov	 ecx, DWORD PTR [edi+16]
  0016f	0f b6 c0	 movzx	 eax, al
  00172	69 c0 b8 00 00
	00		 imul	 eax, 184		; 000000b8H
  00178	8b 14 01	 mov	 edx, DWORD PTR [ecx+eax]
  0017b	03 c8		 add	 ecx, eax
  0017d	56		 push	 esi
  0017e	ff 52 08	 call	 DWORD PTR [edx+8]
  00181	4b		 dec	 ebx
  00182	75 cf		 jne	 SHORT $L291783
$L291785:

; 943  : 		}
; 944  : 
; 945  : 		ar.Read( adwObjIndex, sizeof(DWORD) * m_dwItemMax );

  00184	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  00187	c1 e0 02	 shl	 eax, 2
  0018a	50		 push	 eax
  0018b	8d 4c 24 24	 lea	 ecx, DWORD PTR _adwObjIndex$[esp+548]
  0018f	51		 push	 ecx
  00190	8b ce		 mov	 ecx, esi
  00192	e8 00 00 00 00	 call	 ?Read@CAr@@QAEXPAXI@Z	; CAr::Read

; 946  : 		for( i = 0; i < m_dwItemMax; i++ )

  00197	8b 4f 0c	 mov	 ecx, DWORD PTR [edi+12]
  0019a	33 c0		 xor	 eax, eax
  0019c	85 c9		 test	 ecx, ecx
  0019e	76 1b		 jbe	 SHORT $L291789

; 943  : 		}
; 944  : 
; 945  : 		ar.Read( adwObjIndex, sizeof(DWORD) * m_dwItemMax );

  001a0	33 c9		 xor	 ecx, ecx
$L291787:

; 947  : 		{
; 948  : 			m_apItem[i].m_dwObjIndex	= adwObjIndex[i];

  001a2	8b 57 10	 mov	 edx, DWORD PTR [edi+16]
  001a5	8b 74 84 20	 mov	 esi, DWORD PTR _adwObjIndex$[esp+eax*4+544]
  001a9	89 74 11 08	 mov	 DWORD PTR [ecx+edx+8], esi
  001ad	8b 57 0c	 mov	 edx, DWORD PTR [edi+12]
  001b0	40		 inc	 eax
  001b1	81 c1 b8 00 00
	00		 add	 ecx, 184		; 000000b8H
  001b7	3b c2		 cmp	 eax, edx
  001b9	72 e7		 jb	 SHORT $L291787
$L291789:
  001bb	5f		 pop	 edi
  001bc	5e		 pop	 esi
  001bd	5d		 pop	 ebp
  001be	5b		 pop	 ebx

; 949  : 		}
; 950  : 	}
; 951  : }

  001bf	81 c4 10 02 00
	00		 add	 esp, 528		; 00000210H
  001c5	c2 04 00	 ret	 4
?Serialize@?$CItemContainer@VCItemElem@@@@QAEXAAVCAr@@@Z ENDP ; CItemContainer<CItemElem>::Serialize
_TEXT	ENDS
PUBLIC	??$make_pair@KPAVCUser@@@std@@YA?AU?$pair@KPAVCUser@@@0@KPAVCUser@@@Z ; std::make_pair<unsigned long,CUser *>
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\utility
;	COMDAT ??$make_pair@KPAVCUser@@@std@@YA?AU?$pair@KPAVCUser@@@0@KPAVCUser@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Val1$ = 12						; size = 4
__Val2$ = 16						; size = 4
??$make_pair@KPAVCUser@@@std@@YA?AU?$pair@KPAVCUser@@@0@KPAVCUser@@@Z PROC NEAR ; std::make_pair<unsigned long,CUser *>, COMDAT

; 108  : 	return (pair<_Ty1, _Ty2>(_Val1, _Val2));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  00004	8b 4c 24 08	 mov	 ecx, DWORD PTR __Val1$[esp-4]
  00008	8b 54 24 0c	 mov	 edx, DWORD PTR __Val2$[esp-4]
  0000c	89 08		 mov	 DWORD PTR [eax], ecx
  0000e	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 109  : 	}

  00011	c3		 ret	 0
??$make_pair@KPAVCUser@@@std@@YA?AU?$pair@KPAVCUser@@@0@KPAVCUser@@@Z ENDP ; std::make_pair<unsigned long,CUser *>
_TEXT	ENDS
PUBLIC	??$copy@PAKPAK@std@@YAPAKPAK00@Z		; std::copy<unsigned long *,unsigned long *>
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xutility
;	COMDAT ??$copy@PAKPAK@std@@YAPAKPAK00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$copy@PAKPAK@std@@YAPAKPAK00@Z PROC NEAR		; std::copy<unsigned long *,unsigned long *>, COMDAT

; 1040 : 	return (_Copy_opt(_First, _Last, _Dest, _Ptr_cat(_First, _Dest)));

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR __First$[esp-4]
  00004	8b 44 24 08	 mov	 eax, DWORD PTR __Last$[esp-4]
  00008	2b c1		 sub	 eax, ecx
  0000a	56		 push	 esi
  0000b	c1 f8 02	 sar	 eax, 2
  0000e	8d 34 85 00 00
	00 00		 lea	 esi, DWORD PTR [eax*4]
  00015	8b 44 24 10	 mov	 eax, DWORD PTR __Dest$[esp]
  00019	56		 push	 esi
  0001a	51		 push	 ecx
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 _memmove
  00021	83 c4 0c	 add	 esp, 12			; 0000000cH
  00024	03 c6		 add	 eax, esi
  00026	5e		 pop	 esi

; 1041 : 	}

  00027	c3		 ret	 0
??$copy@PAKPAK@std@@YAPAKPAK00@Z ENDP			; std::copy<unsigned long *,unsigned long *>
_TEXT	ENDS
PUBLIC	??$copy_backward@PAKPAK@std@@YAPAKPAK00@Z	; std::copy_backward<unsigned long *,unsigned long *>
; Function compile flags: /Ogty
;	COMDAT ??$copy_backward@PAKPAK@std@@YAPAKPAK00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$copy_backward@PAKPAK@std@@YAPAKPAK00@Z PROC NEAR	; std::copy_backward<unsigned long *,unsigned long *>, COMDAT

; 1068 : 	return (_Copy_backward_opt(_First, _Last, _Dest,
; 1069 : 		_Ptr_cat(_First, _Dest)));

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR __First$[esp-4]
  00004	8b 44 24 08	 mov	 eax, DWORD PTR __Last$[esp-4]
  00008	2b c1		 sub	 eax, ecx
  0000a	c1 f8 02	 sar	 eax, 2
  0000d	c1 e0 02	 shl	 eax, 2
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	8b 4c 24 14	 mov	 ecx, DWORD PTR __Dest$[esp+4]
  00016	2b c8		 sub	 ecx, eax
  00018	51		 push	 ecx
  00019	e8 00 00 00 00	 call	 _memmove
  0001e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1070 : 	}

  00021	c3		 ret	 0
??$copy_backward@PAKPAK@std@@YAPAKPAK00@Z ENDP		; std::copy_backward<unsigned long *,unsigned long *>
_TEXT	ENDS
PUBLIC	?GetPropA@CItemElem@@QAEPAUItemProp@@XZ		; CItemElem::GetPropA
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\item.h
;	COMDAT ?GetPropA@CItemElem@@QAEPAUItemProp@@XZ
_TEXT	SEGMENT
?GetPropA@CItemElem@@QAEPAUItemProp@@XZ PROC NEAR	; CItemElem::GetPropA, COMDAT
; _this$ = ecx

; 229  : 	ItemProp*	GetProp()	{	return prj.GetItemProp( m_dwItemId );	}

  00000	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  00003	85 c0		 test	 eax, eax
  00005	8b 0d 5c 02 00
	00		 mov	 ecx, DWORD PTR ?prj@@3VCProject@@A+604
  0000b	7c 10		 jl	 SHORT $L302178
  0000d	3b c1		 cmp	 eax, ecx
  0000f	7d 0c		 jge	 SHORT $L302178
  00011	73 20		 jae	 SHORT $L302181
  00013	8b 0d 4c 02 00
	00		 mov	 ecx, DWORD PTR ?prj@@3VCProject@@A+588
  00019	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  0001c	c3		 ret	 0
$L302178:
  0001d	50		 push	 eax
  0001e	51		 push	 ecx
  0001f	6a 00		 push	 0
  00021	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BI@BEIFNGEL@GetItemProp?5range_error?$AA@
  00026	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@HMFGHCP@?$CFs?5min?3?$CFd?0?5max?3?$CFd?0?5index?3?$CFd?$AA@
  0002b	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  00030	83 c4 14	 add	 esp, 20			; 00000014H
$L302181:
  00033	33 c0		 xor	 eax, eax
  00035	c3		 ret	 0
?GetPropA@CItemElem@@QAEPAUItemProp@@XZ ENDP		; CItemElem::GetPropA
_TEXT	ENDS
PUBLIC	??$copy_backward@PAU__ITEMINFO@@PAU1@@std@@YAPAU__ITEMINFO@@PAU1@00@Z ; std::copy_backward<__ITEMINFO *,__ITEMINFO *>
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xutility
;	COMDAT ??$copy_backward@PAU__ITEMINFO@@PAU1@@std@@YAPAU__ITEMINFO@@PAU1@00@Z
_TEXT	SEGMENT
__Cat$302189 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$copy_backward@PAU__ITEMINFO@@PAU1@@std@@YAPAU__ITEMINFO@@PAU1@00@Z PROC NEAR ; std::copy_backward<__ITEMINFO *,__ITEMINFO *>, COMDAT

; 1067 : 	{	// copy [_First, _Last) backwards to [..., _Dest)

  00000	51		 push	 ecx

; 1068 : 	return (_Copy_backward_opt(_First, _Last, _Dest,
; 1069 : 		_Ptr_cat(_First, _Dest)));

  00001	8b 04 24	 mov	 eax, DWORD PTR __Cat$302189[esp+4]
  00004	8b 4c 24 10	 mov	 ecx, DWORD PTR __Dest$[esp]
  00008	8b 54 24 0c	 mov	 edx, DWORD PTR __Last$[esp]
  0000c	50		 push	 eax
  0000d	8b 44 24 0c	 mov	 eax, DWORD PTR __First$[esp+4]
  00011	51		 push	 ecx
  00012	52		 push	 edx
  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 ??$_Copy_backward_opt@PAU__ITEMINFO@@PAU1@@std@@YAPAU__ITEMINFO@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Copy_backward_opt<__ITEMINFO *,__ITEMINFO *>

; 1070 : 	}

  00019	83 c4 14	 add	 esp, 20			; 00000014H
  0001c	c3		 ret	 0
??$copy_backward@PAU__ITEMINFO@@PAU1@@std@@YAPAU__ITEMINFO@@PAU1@00@Z ENDP ; std::copy_backward<__ITEMINFO *,__ITEMINFO *>
_TEXT	ENDS
PUBLIC	?GetPropA@CItem@@QAEPAUItemProp@@XZ		; CItem::GetPropA
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\item.h
;	COMDAT ?GetPropA@CItem@@QAEPAUItemProp@@XZ
_TEXT	SEGMENT
?GetPropA@CItem@@QAEPAUItemProp@@XZ PROC NEAR		; CItem::GetPropA, COMDAT
; _this$ = ecx

; 991  : 	ItemProp* GetProp() { return prj.GetItemProp( GetIndex() ); }

  00000	8b 81 74 01 00
	00		 mov	 eax, DWORD PTR [ecx+372]
  00006	85 c0		 test	 eax, eax
  00008	8b 0d 5c 02 00
	00		 mov	 ecx, DWORD PTR ?prj@@3VCProject@@A+604
  0000e	7c 10		 jl	 SHORT $L302237
  00010	3b c1		 cmp	 eax, ecx
  00012	7d 0c		 jge	 SHORT $L302237
  00014	73 20		 jae	 SHORT $L302239
  00016	8b 0d 4c 02 00
	00		 mov	 ecx, DWORD PTR ?prj@@3VCProject@@A+588
  0001c	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  0001f	c3		 ret	 0
$L302237:
  00020	50		 push	 eax
  00021	51		 push	 ecx
  00022	6a 00		 push	 0
  00024	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BI@BEIFNGEL@GetItemProp?5range_error?$AA@
  00029	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@HMFGHCP@?$CFs?5min?3?$CFd?0?5max?3?$CFd?0?5index?3?$CFd?$AA@
  0002e	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  00033	83 c4 14	 add	 esp, 20			; 00000014H
$L302239:
  00036	33 c0		 xor	 eax, eax
  00038	c3		 ret	 0
?GetPropA@CItem@@QAEPAUItemProp@@XZ ENDP		; CItem::GetPropA
_TEXT	ENDS
PUBLIC	??6CAr@@QAEAAV0@H@Z				; CAr::operator<<
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_network\misc\include\ar.h
;	COMDAT ??6CAr@@QAEAAV0@H@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
??6CAr@@QAEAAV0@H@Z PROC NEAR				; CAr::operator<<, COMDAT
; _this$ = ecx

; 99   : 	{ return CAr::operator<<((LONG)i); }

  00000	56		 push	 esi
  00001	6a 04		 push	 4
  00003	8b f1		 mov	 esi, ecx
  00005	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0000a	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0000d	8b 4c 24 08	 mov	 ecx, DWORD PTR _i$[esp]
  00011	89 08		 mov	 DWORD PTR [eax], ecx
  00013	83 46 08 04	 add	 DWORD PTR [esi+8], 4
  00017	8b c6		 mov	 eax, esi
  00019	5e		 pop	 esi
  0001a	c2 04 00	 ret	 4
??6CAr@@QAEAAV0@H@Z ENDP				; CAr::operator<<
_TEXT	ENDS
PUBLIC	??6CAr@@QAEAAV0@I@Z				; CAr::operator<<
; Function compile flags: /Ogty
;	COMDAT ??6CAr@@QAEAAV0@I@Z
_TEXT	SEGMENT
_u$ = 8							; size = 4
??6CAr@@QAEAAV0@I@Z PROC NEAR				; CAr::operator<<, COMDAT
; _this$ = ecx

; 101  : 	{ return CAr::operator<<((LONG)u); }

  00000	56		 push	 esi
  00001	6a 04		 push	 4
  00003	8b f1		 mov	 esi, ecx
  00005	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0000a	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0000d	8b 4c 24 08	 mov	 ecx, DWORD PTR _u$[esp]
  00011	89 08		 mov	 DWORD PTR [eax], ecx
  00013	83 46 08 04	 add	 DWORD PTR [esi+8], 4
  00017	8b c6		 mov	 eax, esi
  00019	5e		 pop	 esi
  0001a	c2 04 00	 ret	 4
??6CAr@@QAEAAV0@I@Z ENDP				; CAr::operator<<
_TEXT	ENDS
PUBLIC	??6CAr@@QAEAAV0@F@Z				; CAr::operator<<
; Function compile flags: /Ogty
;	COMDAT ??6CAr@@QAEAAV0@F@Z
_TEXT	SEGMENT
_w$ = 8							; size = 2
??6CAr@@QAEAAV0@F@Z PROC NEAR				; CAr::operator<<, COMDAT
; _this$ = ecx

; 103  : 	{ return CAr::operator<<((WORD)w); }

  00000	56		 push	 esi
  00001	6a 02		 push	 2
  00003	8b f1		 mov	 esi, ecx
  00005	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0000a	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0000d	66 8b 4c 24 08	 mov	 cx, WORD PTR _w$[esp]
  00012	66 89 08	 mov	 WORD PTR [eax], cx
  00015	83 46 08 02	 add	 DWORD PTR [esi+8], 2
  00019	8b c6		 mov	 eax, esi
  0001b	5e		 pop	 esi
  0001c	c2 04 00	 ret	 4
??6CAr@@QAEAAV0@F@Z ENDP				; CAr::operator<<
_TEXT	ENDS
PUBLIC	??6CAr@@QAEAAV0@D@Z				; CAr::operator<<
; Function compile flags: /Ogty
;	COMDAT ??6CAr@@QAEAAV0@D@Z
_TEXT	SEGMENT
_ch$ = 8						; size = 1
??6CAr@@QAEAAV0@D@Z PROC NEAR				; CAr::operator<<, COMDAT
; _this$ = ecx

; 105  : 	{ return CAr::operator<<((BYTE)ch); }

  00000	56		 push	 esi
  00001	6a 01		 push	 1
  00003	8b f1		 mov	 esi, ecx
  00005	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0000a	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0000d	8a 4c 24 08	 mov	 cl, BYTE PTR _ch$[esp]
  00011	88 08		 mov	 BYTE PTR [eax], cl
  00013	ff 46 08	 inc	 DWORD PTR [esi+8]
  00016	8b c6		 mov	 eax, esi
  00018	5e		 pop	 esi
  00019	c2 04 00	 ret	 4
??6CAr@@QAEAAV0@D@Z ENDP				; CAr::operator<<
_TEXT	ENDS
PUBLIC	??5CAr@@QAEAAV0@AAH@Z				; CAr::operator>>
; Function compile flags: /Ogty
;	COMDAT ??5CAr@@QAEAAV0@AAH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
??5CAr@@QAEAAV0@AAH@Z PROC NEAR				; CAr::operator>>, COMDAT
; _this$ = ecx

; 126  : 	{ return CAr::operator>>((LONG&)i); }

  00000	8b c1		 mov	 eax, ecx
  00002	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00005	56		 push	 esi
  00006	8b 70 0c	 mov	 esi, DWORD PTR [eax+12]
  00009	8d 51 04	 lea	 edx, DWORD PTR [ecx+4]
  0000c	3b d6		 cmp	 edx, esi
  0000e	5e		 pop	 esi
  0000f	77 0f		 ja	 SHORT $L302270
  00011	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00013	8b 54 24 04	 mov	 edx, DWORD PTR _i$[esp-4]
  00017	89 0a		 mov	 DWORD PTR [edx], ecx
  00019	83 40 08 04	 add	 DWORD PTR [eax+8], 4
  0001d	c2 04 00	 ret	 4
$L302270:
  00020	8b 4c 24 04	 mov	 ecx, DWORD PTR _i$[esp-4]
  00024	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  0002a	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  0002d	89 50 08	 mov	 DWORD PTR [eax+8], edx
  00030	c2 04 00	 ret	 4
??5CAr@@QAEAAV0@AAH@Z ENDP				; CAr::operator>>
_TEXT	ENDS
PUBLIC	??$_Uninitialized_copy@PAKPAKV?$allocator@K@std@@@std@@YAPAKPAK00AAV?$allocator@K@0@@Z ; std::_Uninitialized_copy<unsigned long *,unsigned long *,std::allocator<unsigned long> >
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\memory
;	COMDAT ??$_Uninitialized_copy@PAKPAKV?$allocator@K@std@@@std@@YAPAKPAK00AAV?$allocator@K@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_copy@PAKPAKV?$allocator@K@std@@@std@@YAPAKPAK00AAV?$allocator@K@0@@Z PROC NEAR ; std::_Uninitialized_copy<unsigned long *,unsigned long *,std::allocator<unsigned long> >, COMDAT

; 127  : 	return (_Uninit_copy(_First, _Last, _Dest, _Al,
; 128  : 		_Ptr_cat(_First, _Dest)));

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR __First$[esp-4]
  00004	8b 44 24 08	 mov	 eax, DWORD PTR __Last$[esp-4]
  00008	2b c1		 sub	 eax, ecx
  0000a	56		 push	 esi
  0000b	c1 f8 02	 sar	 eax, 2
  0000e	8d 34 85 00 00
	00 00		 lea	 esi, DWORD PTR [eax*4]
  00015	8b 44 24 10	 mov	 eax, DWORD PTR __Dest$[esp]
  00019	56		 push	 esi
  0001a	51		 push	 ecx
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 _memmove
  00021	83 c4 0c	 add	 esp, 12			; 0000000cH
  00024	03 c6		 add	 eax, esi
  00026	5e		 pop	 esi

; 129  : 	}

  00027	c3		 ret	 0
??$_Uninitialized_copy@PAKPAKV?$allocator@K@std@@@std@@YAPAKPAK00AAV?$allocator@K@0@@Z ENDP ; std::_Uninitialized_copy<unsigned long *,unsigned long *,std::allocator<unsigned long> >
_TEXT	ENDS
PUBLIC	??$_Uninit_fill_n@KIK@std@@YAXPAKIABKAAV?$allocator@K@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<unsigned long,unsigned int,unsigned long>
; Function compile flags: /Ogty
;	COMDAT ??$_Uninit_fill_n@KIK@std@@YAXPAKIABKAAV?$allocator@K@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
??$_Uninit_fill_n@KIK@std@@YAXPAKIABKAAV?$allocator@K@0@U_Scalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Uninit_fill_n<unsigned long,unsigned int,unsigned long>, COMDAT

; 237  : 	fill_n(_First, _Count, _Val);

  00000	8b 4c 24 08	 mov	 ecx, DWORD PTR __Count$[esp-4]
  00004	85 c9		 test	 ecx, ecx
  00006	8b 44 24 04	 mov	 eax, DWORD PTR __First$[esp-4]
  0000a	76 10		 jbe	 SHORT $L302292
  0000c	8b 54 24 0c	 mov	 edx, DWORD PTR __Val$[esp-4]
  00010	56		 push	 esi
$L302290:
  00011	8b 32		 mov	 esi, DWORD PTR [edx]
  00013	89 30		 mov	 DWORD PTR [eax], esi
  00015	83 c0 04	 add	 eax, 4
  00018	49		 dec	 ecx
  00019	75 f6		 jne	 SHORT $L302290
  0001b	5e		 pop	 esi
$L302292:

; 238  : 	}

  0001c	c3		 ret	 0
??$_Uninit_fill_n@KIK@std@@YAXPAKIABKAAV?$allocator@K@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<unsigned long,unsigned int,unsigned long>
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@QAEXPAU__REQUESTGUILD@CGuildCombat@@@Z ; std::allocator<CGuildCombat::__REQUESTGUILD>::destroy
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ?destroy@?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@QAEXPAU__REQUESTGUILD@CGuildCombat@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@QAEXPAU__REQUESTGUILD@CGuildCombat@@@Z PROC NEAR ; std::allocator<CGuildCombat::__REQUESTGUILD>::destroy, COMDAT
; _this$ = ecx

; 152  : 		_Destroy(_Ptr);
; 153  : 		}

  00000	c2 04 00	 ret	 4
?destroy@?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@QAEXPAU__REQUESTGUILD@CGuildCombat@@@Z ENDP ; std::allocator<CGuildCombat::__REQUESTGUILD>::destroy
_TEXT	ENDS
PUBLIC	?construct@?$allocator@U__ITEMINFO@@@std@@QAEXPAU__ITEMINFO@@ABU3@@Z ; std::allocator<__ITEMINFO>::construct
; Function compile flags: /Ogty
;	COMDAT ?construct@?$allocator@U__ITEMINFO@@@std@@QAEXPAU__ITEMINFO@@ABU3@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@U__ITEMINFO@@@std@@QAEXPAU__ITEMINFO@@ABU3@@Z PROC NEAR ; std::allocator<__ITEMINFO>::construct, COMDAT
; _this$ = ecx

; 147  : 		_Construct(_Ptr, _Val);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Ptr$[esp-4]
  00004	85 c0		 test	 eax, eax
  00006	74 14		 je	 SHORT $L302315
  00008	8b 4c 24 08	 mov	 ecx, DWORD PTR __Val$[esp-4]
  0000c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000e	89 10		 mov	 DWORD PTR [eax], edx
  00010	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00013	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00016	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  00019	89 48 08	 mov	 DWORD PTR [eax+8], ecx
$L302315:

; 148  : 		}

  0001c	c2 08 00	 ret	 8
?construct@?$allocator@U__ITEMINFO@@@std@@QAEXPAU__ITEMINFO@@ABU3@@Z ENDP ; std::allocator<__ITEMINFO>::construct
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@U__ITEMINFO@@@std@@QAEXPAU__ITEMINFO@@@Z ; std::allocator<__ITEMINFO>::destroy
; Function compile flags: /Ogty
;	COMDAT ?destroy@?$allocator@U__ITEMINFO@@@std@@QAEXPAU__ITEMINFO@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@U__ITEMINFO@@@std@@QAEXPAU__ITEMINFO@@@Z PROC NEAR ; std::allocator<__ITEMINFO>::destroy, COMDAT
; _this$ = ecx

; 152  : 		_Destroy(_Ptr);
; 153  : 		}

  00000	c2 04 00	 ret	 4
?destroy@?$allocator@U__ITEMINFO@@@std@@QAEXPAU__ITEMINFO@@@Z ENDP ; std::allocator<__ITEMINFO>::destroy
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAU__ITEMINFO@@PAU1@V?$allocator@U__ITEMINFO@@@std@@@std@@YAPAU__ITEMINFO@@PAU1@00AAV?$allocator@U__ITEMINFO@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<__ITEMINFO *,__ITEMINFO *,std::allocator<__ITEMINFO> >
EXTRN	__CxxThrowException@8:NEAR
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\memory
;	COMDAT ??$_Uninit_copy@PAU__ITEMINFO@@PAU1@V?$allocator@U__ITEMINFO@@@std@@@std@@YAPAU__ITEMINFO@@PAU1@00AAV?$allocator@U__ITEMINFO@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
??$_Uninit_copy@PAU__ITEMINFO@@PAU1@V?$allocator@U__ITEMINFO@@@std@@@std@@YAPAU__ITEMINFO@@PAU1@00AAV?$allocator@U__ITEMINFO@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Uninit_copy<__ITEMINFO *,__ITEMINFO *,std::allocator<__ITEMINFO> >, COMDAT

; 78   : 	_FwdIt _Next = _Dest;
; 79   : 
; 80   : 	_TRY_BEGIN
; 81   : 	for (; _First != _Last; ++_Dest, ++_First)

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR __First$[esp-4]
  00004	8b 54 24 08	 mov	 edx, DWORD PTR __Last$[esp-4]
  00008	3b ca		 cmp	 ecx, edx
  0000a	8b 44 24 0c	 mov	 eax, DWORD PTR __Dest$[esp-4]
  0000e	74 28		 je	 SHORT $L293632
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi
$L293630:

; 82   : 		_Al.construct(_Dest, *_First);

  00013	85 c0		 test	 eax, eax
  00015	74 14		 je	 SHORT $L293631
  00017	8b f1		 mov	 esi, ecx
  00019	8b 1e		 mov	 ebx, DWORD PTR [esi]
  0001b	8b f8		 mov	 edi, eax
  0001d	89 1f		 mov	 DWORD PTR [edi], ebx
  0001f	8b 5e 04	 mov	 ebx, DWORD PTR [esi+4]
  00022	89 5f 04	 mov	 DWORD PTR [edi+4], ebx
  00025	8b 76 08	 mov	 esi, DWORD PTR [esi+8]
  00028	89 77 08	 mov	 DWORD PTR [edi+8], esi
$L293631:
  0002b	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0002e	83 c0 0c	 add	 eax, 12			; 0000000cH
  00031	3b ca		 cmp	 ecx, edx
  00033	75 de		 jne	 SHORT $L293630
  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
$L293632:

; 83   : 	_CATCH_ALL
; 84   : 	for (; _Next != _Dest; ++_Next)
; 85   : 		_Al.destroy(_Next);
; 86   : 	_RERAISE;
; 87   : 	_CATCH_END
; 88   : 	return (_Dest);
; 89   : 	}

  00038	c3		 ret	 0
??$_Uninit_copy@PAU__ITEMINFO@@PAU1@V?$allocator@U__ITEMINFO@@@std@@@std@@YAPAU__ITEMINFO@@PAU1@00AAV?$allocator@U__ITEMINFO@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<__ITEMINFO *,__ITEMINFO *,std::allocator<__ITEMINFO> >
_TEXT	ENDS
PUBLIC	?GetLength@?$CSimpleStringT@D$0A@@ATL@@QBEHXZ	; ATL::CSimpleStringT<char,0>::GetLength
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlsimpstr.h
;	COMDAT ?GetLength@?$CSimpleStringT@D$0A@@ATL@@QBEHXZ
_TEXT	SEGMENT
?GetLength@?$CSimpleStringT@D$0A@@ATL@@QBEHXZ PROC NEAR	; ATL::CSimpleStringT<char,0>::GetLength, COMDAT
; _this$ = ecx

; 501  : 		return( GetData()->nDataLength );

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 40 f4	 mov	 eax, DWORD PTR [eax-12]

; 502  : 	}

  00005	c3		 ret	 0
?GetLength@?$CSimpleStringT@D$0A@@ATL@@QBEHXZ ENDP	; ATL::CSimpleStringT<char,0>::GetLength
_TEXT	ENDS
PUBLIC	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str, COMDAT
; _this$ = ecx

; 1094 : 		return (_Myptr());

  00000	83 79 18 10	 cmp	 DWORD PTR [ecx+24], 16	; 00000010H
  00004	72 04		 jb	 SHORT $L302376
  00006	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 1095 : 		}

  00009	c3		 ret	 0

; 1094 : 		return (_Myptr());

$L302376:
  0000a	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]

; 1095 : 		}

  0000d	c3		 ret	 0
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
_TEXT	ENDS
PUBLIC	??9const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::const_iterator::operator!=
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::const_iterator::operator!=, COMDAT
; _this$ = ecx

; 246  : 			return (!(*this == _Right));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 54 24 04	 mov	 edx, DWORD PTR __Right$[esp-4]
  00006	56		 push	 esi
  00007	8b 32		 mov	 esi, DWORD PTR [edx]
  00009	33 c9		 xor	 ecx, ecx
  0000b	3b c6		 cmp	 eax, esi
  0000d	0f 95 c1	 setne	 cl
  00010	8a c1		 mov	 al, cl
  00012	5e		 pop	 esi

; 247  : 			}

  00013	c2 04 00	 ret	 4
??9const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::const_iterator::operator!=
_TEXT	ENDS
PUBLIC	??0?$CSimpleStringT@D$0A@@ATL@@QAE@PAUIAtlStringMgr@1@@Z ; ATL::CSimpleStringT<char,0>::CSimpleStringT<char,0>
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlsimpstr.h
;	COMDAT ??0?$CSimpleStringT@D$0A@@ATL@@QAE@PAUIAtlStringMgr@1@@Z
_TEXT	SEGMENT
_pStringMgr$ = 8					; size = 4
??0?$CSimpleStringT@D$0A@@ATL@@QAE@PAUIAtlStringMgr@1@@Z PROC NEAR ; ATL::CSimpleStringT<char,0>::CSimpleStringT<char,0>, COMDAT
; _this$ = ecx

; 210  : 	explicit CSimpleStringT( IAtlStringMgr* pStringMgr ) throw()

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 211  : 	{
; 212  : 		ATLASSERT( pStringMgr != NULL );
; 213  : 		CStringData* pData = pStringMgr->GetNilString();

  00003	8b 4c 24 08	 mov	 ecx, DWORD PTR _pStringMgr$[esp]
  00007	8b 01		 mov	 eax, DWORD PTR [ecx]
  00009	ff 50 0c	 call	 DWORD PTR [eax+12]

; 214  : 		Attach( pData );

  0000c	83 c0 10	 add	 eax, 16			; 00000010H
  0000f	89 06		 mov	 DWORD PTR [esi], eax

; 215  : 	}

  00011	8b c6		 mov	 eax, esi
  00013	5e		 pop	 esi
  00014	c2 04 00	 ret	 4
??0?$CSimpleStringT@D$0A@@ATL@@QAE@PAUIAtlStringMgr@1@@Z ENDP ; ATL::CSimpleStringT<char,0>::CSimpleStringT<char,0>
_TEXT	ENDS
PUBLIC	??1?$CSimpleStringT@D$0A@@ATL@@QAE@XZ		; ATL::CSimpleStringT<char,0>::~CSimpleStringT<char,0>
; Function compile flags: /Ogty
;	COMDAT ??1?$CSimpleStringT@D$0A@@ATL@@QAE@XZ
_TEXT	SEGMENT
??1?$CSimpleStringT@D$0A@@ATL@@QAE@XZ PROC NEAR		; ATL::CSimpleStringT<char,0>::~CSimpleStringT<char,0>, COMDAT
; _this$ = ecx

; 263  : 		CStringData* pData = GetData();

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 e8 10	 sub	 eax, 16			; 00000010H

; 264  : 		pData->Release();

  00005	8d 48 0c	 lea	 ecx, DWORD PTR [eax+12]
  00008	83 ca ff	 or	 edx, -1
  0000b	f0 0f c1 11	 lock	  xadd	 DWORD PTR [ecx], edx
  0000f	4a		 dec	 edx
  00010	85 d2		 test	 edx, edx
  00012	7f 08		 jg	 SHORT $L302405
  00014	8b 08		 mov	 ecx, DWORD PTR [eax]
  00016	8b 11		 mov	 edx, DWORD PTR [ecx]
  00018	50		 push	 eax
  00019	ff 52 04	 call	 DWORD PTR [edx+4]
$L302405:

; 265  : 	}

  0001c	c3		 ret	 0
??1?$CSimpleStringT@D$0A@@ATL@@QAE@XZ ENDP		; ATL::CSimpleStringT<char,0>::~CSimpleStringT<char,0>
_TEXT	ENDS
PUBLIC	?ReleaseBufferSetLength@?$CSimpleStringT@D$0A@@ATL@@QAEXH@Z ; ATL::CSimpleStringT<char,0>::ReleaseBufferSetLength
; Function compile flags: /Ogty
;	COMDAT ?ReleaseBufferSetLength@?$CSimpleStringT@D$0A@@ATL@@QAEXH@Z
_TEXT	SEGMENT
_nNewLength$ = 8					; size = 4
?ReleaseBufferSetLength@?$CSimpleStringT@D$0A@@ATL@@QAEXH@Z PROC NEAR ; ATL::CSimpleStringT<char,0>::ReleaseBufferSetLength, COMDAT
; _this$ = ecx

; 547  : 		ATLASSERT( nNewLength >= 0 );
; 548  : 		SetLength( nNewLength );

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _nNewLength$[esp-4]
  00004	85 c0		 test	 eax, eax
  00006	7c 13		 jl	 SHORT $L302423
  00008	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000a	3b 42 f8	 cmp	 eax, DWORD PTR [edx-8]
  0000d	7f 0c		 jg	 SHORT $L302423
  0000f	89 42 f4	 mov	 DWORD PTR [edx-12], eax
  00012	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00014	c6 04 08 00	 mov	 BYTE PTR [eax+ecx], 0

; 549  : 	}

  00018	c2 04 00	 ret	 4
$L302423:
  0001b	68 57 00 07 80	 push	 -2147024809		; 80070057H
  00020	e8 00 00 00 00	 call	 ?AtlThrow@ATL@@YGXJ@Z	; ATL::AtlThrow
$L302426:
$L302425:
  00025	cc		 int	 3
?ReleaseBufferSetLength@?$CSimpleStringT@D$0A@@ATL@@QAEXH@Z ENDP ; ATL::CSimpleStringT<char,0>::ReleaseBufferSetLength
_TEXT	ENDS
PUBLIC	??0?$_String_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z ; std::_String_val<char,std::allocator<char> >::_String_val<char,std::allocator<char> >
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ??0?$_String_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_String_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z PROC NEAR ; std::_String_val<char,std::allocator<char> >::_String_val<char,std::allocator<char> >, COMDAT
; _this$ = ecx

; 34   : 		{	// construct allocator from _Al

  00000	8b c1		 mov	 eax, ecx

; 35   : 		}

  00002	c2 04 00	 ret	 4
??0?$_String_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z ENDP ; std::_String_val<char,std::allocator<char> >::_String_val<char,std::allocator<char> >
_TEXT	ENDS
PUBLIC	?_Key@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@KAABKPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Key
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ?_Key@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@KAABKPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Key@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@KAABKPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Key, COMDAT

; 142  : 		return (_Mybase::_Kfn(_Myval(_Pnode)));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]
  00004	83 c0 0c	 add	 eax, 12			; 0000000cH

; 143  : 		}

  00007	c3		 ret	 0
?_Key@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@KAABKPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Key
_TEXT	ENDS
PUBLIC	??Diterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QBEAAU?$pair@$$CBKPAVCUser@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::iterator::operator*
; Function compile flags: /Ogty
;	COMDAT ??Diterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QBEAAU?$pair@$$CBKPAVCUser@@@2@XZ
_TEXT	SEGMENT
??Diterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QBEAAU?$pair@$$CBKPAVCUser@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::iterator::operator*, COMDAT
; _this$ = ecx

; 317  : 			return ((reference)**(const_iterator *)this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 0c	 add	 eax, 12			; 0000000cH

; 318  : 			}

  00005	c3		 ret	 0
??Diterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QBEAAU?$pair@$$CBKPAVCUser@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::iterator::operator*
_TEXT	ENDS
PUBLIC	?_Root@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::_Root
; Function compile flags: /Ogty
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Root@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::_Root, COMDAT
; _this$ = ecx

; 1059 : 		return (_Parent(_Myhead));

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	83 c0 04	 add	 eax, 4

; 1060 : 		}

  00006	c3		 ret	 0
?_Root@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::_Root
_TEXT	ENDS
PUBLIC	??0iterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::iterator::iterator
; Function compile flags: /Ogty
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
??0iterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::iterator::iterator, COMDAT
; _this$ = ecx

; 312  : 			{	// construct with node pointer _Pnode

  00000	8b c1		 mov	 eax, ecx
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Pnode$[esp-4]
  00006	89 08		 mov	 DWORD PTR [eax], ecx

; 313  : 			}

  00008	c2 04 00	 ret	 4
??0iterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::iterator::iterator
_TEXT	ENDS
PUBLIC	??Diterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QBEAAU?$pair@$$CBKPAVCCtrl@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::iterator::operator*
; Function compile flags: /Ogty
;	COMDAT ??Diterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QBEAAU?$pair@$$CBKPAVCCtrl@@@2@XZ
_TEXT	SEGMENT
??Diterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QBEAAU?$pair@$$CBKPAVCCtrl@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::iterator::operator*, COMDAT
; _this$ = ecx

; 317  : 			return ((reference)**(const_iterator *)this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 0c	 add	 eax, 12			; 0000000cH

; 318  : 			}

  00005	c3		 ret	 0
??Diterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QBEAAU?$pair@$$CBKPAVCCtrl@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::iterator::operator*
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@KV?$allocator@K@std@@@std@@IAE@V?$allocator@K@1@@Z ; std::_Vector_val<unsigned long,std::allocator<unsigned long> >::_Vector_val<unsigned long,std::allocator<unsigned long> >
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ??0?$_Vector_val@KV?$allocator@K@std@@@std@@IAE@V?$allocator@K@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@KV?$allocator@K@std@@@std@@IAE@V?$allocator@K@1@@Z PROC NEAR ; std::_Vector_val<unsigned long,std::allocator<unsigned long> >::_Vector_val<unsigned long,std::allocator<unsigned long> >, COMDAT
; _this$ = ecx

; 21   : 		{	// construct allocator from _Al

  00000	8b c1		 mov	 eax, ecx

; 22   : 		}

  00002	c2 04 00	 ret	 4
??0?$_Vector_val@KV?$allocator@K@std@@@std@@IAE@V?$allocator@K@1@@Z ENDP ; std::_Vector_val<unsigned long,std::allocator<unsigned long> >::_Vector_val<unsigned long,std::allocator<unsigned long> >
_TEXT	ENDS
PUBLIC	?_Key@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@KAABKPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::_Key
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ?_Key@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@KAABKPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Key@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@KAABKPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::_Key, COMDAT

; 142  : 		return (_Mybase::_Kfn(_Myval(_Pnode)));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]
  00004	83 c0 0c	 add	 eax, 12			; 0000000cH

; 143  : 		}

  00007	c3		 ret	 0
?_Key@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@KAABKPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::_Key
_TEXT	ENDS
PUBLIC	??0iterator@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::iterator::iterator
; Function compile flags: /Ogty
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
??0iterator@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::iterator::iterator, COMDAT
; _this$ = ecx

; 312  : 			{	// construct with node pointer _Pnode

  00000	8b c1		 mov	 eax, ecx
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Pnode$[esp-4]
  00006	89 08		 mov	 DWORD PTR [eax], ecx

; 313  : 			}

  00008	c2 04 00	 ret	 4
??0iterator@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::iterator::iterator
_TEXT	ENDS
PUBLIC	??Diterator@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QBEAAU?$pair@$$CBKPAVCMover@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::iterator::operator*
; Function compile flags: /Ogty
;	COMDAT ??Diterator@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QBEAAU?$pair@$$CBKPAVCMover@@@2@XZ
_TEXT	SEGMENT
??Diterator@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QBEAAU?$pair@$$CBKPAVCMover@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::iterator::operator*, COMDAT
; _this$ = ecx

; 317  : 			return ((reference)**(const_iterator *)this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 0c	 add	 eax, 12			; 0000000cH

; 318  : 			}

  00005	c3		 ret	 0
??Diterator@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QBEAAU?$pair@$$CBKPAVCMover@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::iterator::operator*
_TEXT	ENDS
PUBLIC	?Empty@?$CSimpleStringT@D$0A@@ATL@@QAEXXZ	; ATL::CSimpleStringT<char,0>::Empty
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlsimpstr.h
;	COMDAT ?Empty@?$CSimpleStringT@D$0A@@ATL@@QAEXXZ
_TEXT	SEGMENT
?Empty@?$CSimpleStringT@D$0A@@ATL@@QAEXXZ PROC NEAR	; ATL::CSimpleStringT<char,0>::Empty, COMDAT
; _this$ = ecx

; 421  : 	{

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 422  : 		CStringData* pOldData = GetData();

  00003	8b 0e		 mov	 ecx, DWORD PTR [esi]

; 423  : 		IAtlStringMgr* pStringMgr = pOldData->pStringMgr;
; 424  : 		if( pOldData->nDataLength == 0 )

  00005	8b 51 f4	 mov	 edx, DWORD PTR [ecx-12]
  00008	85 d2		 test	 edx, edx
  0000a	8d 41 f0	 lea	 eax, DWORD PTR [ecx-16]
  0000d	57		 push	 edi
  0000e	8b 38		 mov	 edi, DWORD PTR [eax]
  00010	74 4c		 je	 SHORT $L302541
  00012	53		 push	 ebx

; 425  : 		{
; 426  : 			return;
; 427  : 		}
; 428  : 
; 429  : 		if( pOldData->IsLocked() )

  00013	8b 58 0c	 mov	 ebx, DWORD PTR [eax+12]
  00016	8d 50 0c	 lea	 edx, DWORD PTR [eax+12]
  00019	85 db		 test	 ebx, ebx
  0001b	5b		 pop	 ebx
  0001c	7d 20		 jge	 SHORT $L221323

; 430  : 		{
; 431  : 			// Don't reallocate a locked buffer that's shrinking
; 432  : 			SetLength( 0 );

  0001e	8b 41 f8	 mov	 eax, DWORD PTR [ecx-8]
  00021	85 c0		 test	 eax, eax
  00023	7d 0a		 jge	 SHORT $L302530
  00025	68 57 00 07 80	 push	 -2147024809		; 80070057H
  0002a	e8 00 00 00 00	 call	 ?AtlThrow@ATL@@YGXJ@Z	; ATL::AtlThrow
$L302546:
$L302530:
  0002f	c7 41 f4 00 00
	00 00		 mov	 DWORD PTR [ecx-12], 0
  00036	8b 06		 mov	 eax, DWORD PTR [esi]
  00038	5f		 pop	 edi
  00039	c6 00 00	 mov	 BYTE PTR [eax], 0
  0003c	5e		 pop	 esi

; 439  : 		}
; 440  : 	}

  0003d	c3		 ret	 0
$L221323:

; 433  : 		}
; 434  : 		else
; 435  : 		{
; 436  : 			pOldData->Release();

  0003e	83 c9 ff	 or	 ecx, -1
  00041	f0 0f c1 0a	 lock	  xadd	 DWORD PTR [edx], ecx
  00045	49		 dec	 ecx
  00046	85 c9		 test	 ecx, ecx
  00048	7f 08		 jg	 SHORT $L302536
  0004a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0004c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0004e	50		 push	 eax
  0004f	ff 52 04	 call	 DWORD PTR [edx+4]
$L302536:

; 437  : 			CStringData* pNewData = pStringMgr->GetNilString();

  00052	8b 07		 mov	 eax, DWORD PTR [edi]
  00054	8b cf		 mov	 ecx, edi
  00056	ff 50 0c	 call	 DWORD PTR [eax+12]

; 438  : 			Attach( pNewData );

  00059	83 c0 10	 add	 eax, 16			; 00000010H
  0005c	89 06		 mov	 DWORD PTR [esi], eax
$L302541:
  0005e	5f		 pop	 edi
  0005f	5e		 pop	 esi

; 439  : 		}
; 440  : 	}

  00060	c3		 ret	 0
$L302545:
?Empty@?$CSimpleStringT@D$0A@@ATL@@QAEXXZ ENDP		; ATL::CSimpleStringT<char,0>::Empty
_TEXT	ENDS
PUBLIC	?PrepareWrite2@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z ; ATL::CSimpleStringT<char,0>::PrepareWrite2
; Function compile flags: /Ogty
;	COMDAT ?PrepareWrite2@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z
_TEXT	SEGMENT
_nLength$ = 8						; size = 4
?PrepareWrite2@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z PROC NEAR ; ATL::CSimpleStringT<char,0>::PrepareWrite2, COMDAT
; _this$ = ecx

; 747  : 		CStringData* pOldData = GetData();

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 748  : 		if( pOldData->nDataLength > nLength )

  00002	8b 54 24 04	 mov	 edx, DWORD PTR _nLength$[esp-4]
  00006	83 e8 10	 sub	 eax, 16			; 00000010H
  00009	56		 push	 esi
  0000a	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  0000d	3b f2		 cmp	 esi, edx
  0000f	7e 02		 jle	 SHORT $L221345

; 749  : 		{
; 750  : 			nLength = pOldData->nDataLength;

  00011	8b d6		 mov	 edx, esi
$L221345:

; 751  : 		}
; 752  : 		if( pOldData->IsShared() )

  00013	83 78 0c 01	 cmp	 DWORD PTR [eax+12], 1
  00017	5e		 pop	 esi
  00018	7e 09		 jle	 SHORT $L221346

; 753  : 		{
; 754  : 			Fork( nLength );

  0001a	89 54 24 04	 mov	 DWORD PTR _nLength$[esp-4], edx
  0001e	e9 00 00 00 00	 jmp	 ?Fork@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z ; ATL::CSimpleStringT<char,0>::Fork
$L221346:

; 755  : 		}
; 756  : 		else if( pOldData->nAllocLength < nLength )

  00023	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00026	3b c2		 cmp	 eax, edx
  00028	7d 1f		 jge	 SHORT $L221348

; 757  : 		{
; 758  : 			// Grow exponentially, until we hit 1K.
; 759  : 			int nNewLength = pOldData->nAllocLength;
; 760  : 			if( nNewLength > 1024 )

  0002a	3d 00 04 00 00	 cmp	 eax, 1024		; 00000400H
  0002f	7e 07		 jle	 SHORT $L221350

; 761  : 			{
; 762  : 				nNewLength += 1024;

  00031	05 00 04 00 00	 add	 eax, 1024		; 00000400H

; 763  : 			}
; 764  : 			else

  00036	eb 02		 jmp	 SHORT $L221351
$L221350:

; 765  : 			{
; 766  : 				nNewLength *= 2;

  00038	03 c0		 add	 eax, eax
$L221351:

; 767  : 			}
; 768  : 			if( nNewLength < nLength )

  0003a	3b c2		 cmp	 eax, edx
  0003c	7d 02		 jge	 SHORT $L221352

; 769  : 			{
; 770  : 				nNewLength = nLength;

  0003e	8b c2		 mov	 eax, edx
$L221352:

; 771  : 			}
; 772  : 			Reallocate( nNewLength );

  00040	89 44 24 04	 mov	 DWORD PTR _nLength$[esp-4], eax
  00044	e9 00 00 00 00	 jmp	 ?Reallocate@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z ; ATL::CSimpleStringT<char,0>::Reallocate
$L221348:

; 773  : 		}
; 774  : 	}

  00049	c2 04 00	 ret	 4
?PrepareWrite2@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z ENDP	; ATL::CSimpleStringT<char,0>::PrepareWrite2
_TEXT	ENDS
PUBLIC	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos, COMDAT
; _this$ = ecx

; 1475 : 		_Traits::assign(_Myptr()[_Mysize = _Newsize], _Elem());

  00000	83 79 18 10	 cmp	 DWORD PTR [ecx+24], 16	; 00000010H
  00004	8b 44 24 04	 mov	 eax, DWORD PTR __Newsize$[esp-4]
  00008	89 41 14	 mov	 DWORD PTR [ecx+20], eax
  0000b	72 0a		 jb	 SHORT $L302565
  0000d	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00010	c6 04 01 00	 mov	 BYTE PTR [ecx+eax], 0

; 1476 : 		}

  00014	c2 04 00	 ret	 4

; 1475 : 		_Traits::assign(_Myptr()[_Mysize = _Newsize], _Elem());

$L302565:
  00017	c6 44 01 04 00	 mov	 BYTE PTR [ecx+eax+4], 0

; 1476 : 		}

  0001c	c2 04 00	 ret	 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
_TEXT	ENDS
PUBLIC	?_Lbound@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@ABK@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Lbound
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ?_Lbound@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@ABK@Z
_TEXT	SEGMENT
__Keyval$ = 8						; size = 4
?_Lbound@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@ABK@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Lbound, COMDAT
; _this$ = ecx

; 988  : 		_Nodeptr _Pnode = _Root();

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]

; 989  : 		_Nodeptr _Wherenode = _Myhead;	// end() if search fails
; 990  : 
; 991  : 		while (!_Isnil(_Pnode))

  00006	8a 51 15	 mov	 dl, BYTE PTR [ecx+21]
  00009	84 d2		 test	 dl, dl
  0000b	75 1d		 jne	 SHORT $L221597
  0000d	8b 54 24 04	 mov	 edx, DWORD PTR __Keyval$[esp-4]
  00011	8b 12		 mov	 edx, DWORD PTR [edx]
  00013	53		 push	 ebx
$L221596:

; 992  : 			if (this->comp(_Key(_Pnode), _Keyval))

  00014	39 51 0c	 cmp	 DWORD PTR [ecx+12], edx
  00017	73 05		 jae	 SHORT $L221598

; 993  : 				_Pnode = _Right(_Pnode);	// descend right subtree

  00019	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]

; 994  : 			else

  0001c	eb 04		 jmp	 SHORT $L221599
$L221598:

; 995  : 				{	// _Pnode not less than _Keyval, remember it
; 996  : 				_Wherenode = _Pnode;

  0001e	8b c1		 mov	 eax, ecx

; 997  : 				_Pnode = _Left(_Pnode);	// descend left subtree

  00020	8b 09		 mov	 ecx, DWORD PTR [ecx]
$L221599:
  00022	8a 59 15	 mov	 bl, BYTE PTR [ecx+21]
  00025	84 db		 test	 bl, bl
  00027	74 eb		 je	 SHORT $L221596
  00029	5b		 pop	 ebx
$L221597:

; 998  : 				}
; 999  : 
; 1000 : 		return (_Wherenode);	// return best remembered candidate
; 1001 : 		}

  0002a	c2 04 00	 ret	 4
?_Lbound@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@ABK@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Lbound
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@K@std@@QAEPAKI@Z		; std::allocator<unsigned long>::allocate
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ?allocate@?$allocator@K@std@@QAEPAKI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@K@std@@QAEPAKI@Z PROC NEAR	; std::allocator<unsigned long>::allocate, COMDAT
; _this$ = ecx

; 137  : 		return (_Allocate(_Count, (pointer)0));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Count$[esp-4]
  00004	8d 0c 85 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*4]
  0000b	51		 push	 ecx
  0000c	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00011	83 c4 04	 add	 esp, 4

; 138  : 		}

  00014	c2 04 00	 ret	 4
?allocate@?$allocator@K@std@@QAEPAKI@Z ENDP		; std::allocator<unsigned long>::allocate
_TEXT	ENDS
PUBLIC	??0iterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::iterator::iterator
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0iterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAE@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::iterator::iterator, COMDAT
; _this$ = ecx

; 304  : 		iterator()

  00000	8b c1		 mov	 eax, ecx
  00002	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 305  : 			{	// construct with null node pointer
; 306  : 			}

  00008	c3		 ret	 0
??0iterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::iterator::iterator
_TEXT	ENDS
PUBLIC	??0iterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::iterator::iterator
; Function compile flags: /Ogty
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
??0iterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::iterator::iterator, COMDAT
; _this$ = ecx

; 312  : 			{	// construct with node pointer _Pnode

  00000	8b c1		 mov	 eax, ecx
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Pnode$[esp-4]
  00006	89 08		 mov	 DWORD PTR [eax], ecx

; 313  : 			}

  00008	c2 04 00	 ret	 4
??0iterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::iterator::iterator
_TEXT	ENDS
PUBLIC	?_Lrotate@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::_Lrotate
; Function compile flags: /Ogty
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Wherenode$ = 8					; size = 4
?_Lrotate@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::_Lrotate, COMDAT
; _this$ = ecx

; 1015 : 		_Nodeptr _Pnode = _Right(_Wherenode);

  00000	8b 54 24 04	 mov	 edx, DWORD PTR __Wherenode$[esp-4]
  00004	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00007	53		 push	 ebx
  00008	56		 push	 esi

; 1016 : 		_Right(_Wherenode) = _Left(_Pnode);

  00009	8b 30		 mov	 esi, DWORD PTR [eax]
  0000b	89 72 08	 mov	 DWORD PTR [edx+8], esi

; 1017 : 
; 1018 : 		if (!_Isnil(_Left(_Pnode)))

  0000e	8b 30		 mov	 esi, DWORD PTR [eax]
  00010	8a 5e 15	 mov	 bl, BYTE PTR [esi+21]
  00013	84 db		 test	 bl, bl
  00015	75 03		 jne	 SHORT $L221711

; 1019 : 			_Parent(_Left(_Pnode)) = _Wherenode;

  00017	89 56 04	 mov	 DWORD PTR [esi+4], edx
$L221711:

; 1020 : 		_Parent(_Pnode) = _Parent(_Wherenode);

  0001a	8b 72 04	 mov	 esi, DWORD PTR [edx+4]
  0001d	89 70 04	 mov	 DWORD PTR [eax+4], esi

; 1021 : 
; 1022 : 		if (_Wherenode == _Root())

  00020	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00023	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  00026	75 0d		 jne	 SHORT $L221712

; 1023 : 			_Root() = _Pnode;

  00028	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  0002b	5e		 pop	 esi

; 1028 : 
; 1029 : 		_Left(_Pnode) = _Wherenode;

  0002c	89 10		 mov	 DWORD PTR [eax], edx

; 1030 : 		_Parent(_Wherenode) = _Pnode;

  0002e	89 42 04	 mov	 DWORD PTR [edx+4], eax
  00031	5b		 pop	 ebx

; 1031 : 		}

  00032	c2 04 00	 ret	 4
$L221712:

; 1024 : 		else if (_Wherenode == _Left(_Parent(_Wherenode)))

  00035	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00038	3b 11		 cmp	 edx, DWORD PTR [ecx]
  0003a	75 0c		 jne	 SHORT $L221714

; 1025 : 			_Left(_Parent(_Wherenode)) = _Pnode;

  0003c	89 01		 mov	 DWORD PTR [ecx], eax
  0003e	5e		 pop	 esi

; 1028 : 
; 1029 : 		_Left(_Pnode) = _Wherenode;

  0003f	89 10		 mov	 DWORD PTR [eax], edx

; 1030 : 		_Parent(_Wherenode) = _Pnode;

  00041	89 42 04	 mov	 DWORD PTR [edx+4], eax
  00044	5b		 pop	 ebx

; 1031 : 		}

  00045	c2 04 00	 ret	 4
$L221714:

; 1026 : 		else
; 1027 : 			_Right(_Parent(_Wherenode)) = _Pnode;

  00048	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  0004b	5e		 pop	 esi

; 1028 : 
; 1029 : 		_Left(_Pnode) = _Wherenode;

  0004c	89 10		 mov	 DWORD PTR [eax], edx

; 1030 : 		_Parent(_Wherenode) = _Pnode;

  0004e	89 42 04	 mov	 DWORD PTR [edx+4], eax
  00051	5b		 pop	 ebx

; 1031 : 		}

  00052	c2 04 00	 ret	 4
?_Lrotate@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::_Lrotate
_TEXT	ENDS
PUBLIC	?_Rrotate@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::_Rrotate
; Function compile flags: /Ogty
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Wherenode$ = 8					; size = 4
?_Rrotate@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::_Rrotate, COMDAT
; _this$ = ecx

; 1069 : 		_Nodeptr _Pnode = _Left(_Wherenode);

  00000	8b 54 24 04	 mov	 edx, DWORD PTR __Wherenode$[esp-4]
  00004	8b 02		 mov	 eax, DWORD PTR [edx]
  00006	53		 push	 ebx
  00007	56		 push	 esi

; 1070 : 		_Left(_Wherenode) = _Right(_Pnode);

  00008	8b 70 08	 mov	 esi, DWORD PTR [eax+8]
  0000b	89 32		 mov	 DWORD PTR [edx], esi

; 1071 : 
; 1072 : 		if (!_Isnil(_Right(_Pnode)))

  0000d	8b 70 08	 mov	 esi, DWORD PTR [eax+8]
  00010	8a 5e 15	 mov	 bl, BYTE PTR [esi+21]
  00013	84 db		 test	 bl, bl
  00015	75 03		 jne	 SHORT $L221721

; 1073 : 			_Parent(_Right(_Pnode)) = _Wherenode;

  00017	89 56 04	 mov	 DWORD PTR [esi+4], edx
$L221721:

; 1074 : 		_Parent(_Pnode) = _Parent(_Wherenode);

  0001a	8b 72 04	 mov	 esi, DWORD PTR [edx+4]
  0001d	89 70 04	 mov	 DWORD PTR [eax+4], esi

; 1075 : 
; 1076 : 		if (_Wherenode == _Root())

  00020	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00023	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  00026	75 0e		 jne	 SHORT $L221722

; 1077 : 			_Root() = _Pnode;

  00028	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  0002b	5e		 pop	 esi

; 1082 : 
; 1083 : 		_Right(_Pnode) = _Wherenode;

  0002c	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 1084 : 		_Parent(_Wherenode) = _Pnode;

  0002f	89 42 04	 mov	 DWORD PTR [edx+4], eax
  00032	5b		 pop	 ebx

; 1085 : 		}

  00033	c2 04 00	 ret	 4
$L221722:

; 1078 : 		else if (_Wherenode == _Right(_Parent(_Wherenode)))

  00036	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00039	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  0003c	75 0e		 jne	 SHORT $L221724

; 1079 : 			_Right(_Parent(_Wherenode)) = _Pnode;

  0003e	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  00041	5e		 pop	 esi

; 1082 : 
; 1083 : 		_Right(_Pnode) = _Wherenode;

  00042	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 1084 : 		_Parent(_Wherenode) = _Pnode;

  00045	89 42 04	 mov	 DWORD PTR [edx+4], eax
  00048	5b		 pop	 ebx

; 1085 : 		}

  00049	c2 04 00	 ret	 4
$L221724:

; 1080 : 		else
; 1081 : 			_Left(_Parent(_Wherenode)) = _Pnode;

  0004c	89 01		 mov	 DWORD PTR [ecx], eax
  0004e	5e		 pop	 esi

; 1082 : 
; 1083 : 		_Right(_Pnode) = _Wherenode;

  0004f	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 1084 : 		_Parent(_Wherenode) = _Pnode;

  00052	89 42 04	 mov	 DWORD PTR [edx+4], eax
  00055	5b		 pop	 ebx

; 1085 : 		}

  00056	c2 04 00	 ret	 4
?_Rrotate@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::_Rrotate
_TEXT	ENDS
PUBLIC	?max_size@?$vector@KV?$allocator@K@std@@@std@@QBEIXZ ; std::vector<unsigned long,std::allocator<unsigned long> >::max_size
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ?max_size@?$vector@KV?$allocator@K@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@KV?$allocator@K@std@@@std@@QBEIXZ PROC NEAR ; std::vector<unsigned long,std::allocator<unsigned long> >::max_size, COMDAT
; _this$ = ecx

; 521  : 		return (this->_Alval.max_size());

  00000	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 522  : 		}

  00005	c3		 ret	 0
?max_size@?$vector@KV?$allocator@K@std@@@std@@QBEIXZ ENDP ; std::vector<unsigned long,std::allocator<unsigned long> >::max_size
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@KV?$allocator@K@std@@@std@@IAEXPAK0@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::_Destroy
; Function compile flags: /Ogty
;	COMDAT ?_Destroy@?$vector@KV?$allocator@K@std@@@std@@IAEXPAK0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@KV?$allocator@K@std@@@std@@IAEXPAK0@Z PROC NEAR ; std::vector<unsigned long,std::allocator<unsigned long> >::_Destroy, COMDAT
; _this$ = ecx

; 787  : 		_Destroy_range(_First, _Last, this->_Alval);
; 788  : 		}

  00000	c2 08 00	 ret	 8
?_Destroy@?$vector@KV?$allocator@K@std@@@std@@IAEXPAK0@Z ENDP ; std::vector<unsigned long,std::allocator<unsigned long> >::_Destroy
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node *>::destroy
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z PROC NEAR ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node *>::destroy, COMDAT
; _this$ = ecx

; 152  : 		_Destroy(_Ptr);
; 153  : 		}

  00000	c2 04 00	 ret	 4
?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node *>::destroy
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@EV?$allocator@E@std@@@std@@IAEXPAE0@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Destroy
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ?_Destroy@?$vector@EV?$allocator@E@std@@@std@@IAEXPAE0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@EV?$allocator@E@std@@@std@@IAEXPAE0@Z PROC NEAR ; std::vector<unsigned char,std::allocator<unsigned char> >::_Destroy, COMDAT
; _this$ = ecx

; 787  : 		_Destroy_range(_First, _Last, this->_Alval);
; 788  : 		}

  00000	c2 08 00	 ret	 8
?_Destroy@?$vector@EV?$allocator@E@std@@@std@@IAEXPAE0@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Destroy
_TEXT	ENDS
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 1114 : 		size_type _Num = _Mybase::_Alval.max_size();
; 1115 : 		return (_Num <= 1 ? 1 : _Num - 1);

  00000	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 1116 : 		}

  00005	c3		 ret	 0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
PUBLIC	?max_size@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::max_size
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ?max_size@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QBEIXZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::max_size, COMDAT
; _this$ = ecx

; 453  : 		return (this->_Alval.max_size());

  00000	b8 ff ff ff 1f	 mov	 eax, 536870911		; 1fffffffH

; 454  : 		}

  00005	c3		 ret	 0
?max_size@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::max_size
_TEXT	ENDS
PUBLIC	?_Lrotate@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Lrotate
; Function compile flags: /Ogty
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Wherenode$ = 8					; size = 4
?_Lrotate@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Lrotate, COMDAT
; _this$ = ecx

; 1015 : 		_Nodeptr _Pnode = _Right(_Wherenode);

  00000	8b 54 24 04	 mov	 edx, DWORD PTR __Wherenode$[esp-4]
  00004	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00007	53		 push	 ebx
  00008	56		 push	 esi

; 1016 : 		_Right(_Wherenode) = _Left(_Pnode);

  00009	8b 30		 mov	 esi, DWORD PTR [eax]
  0000b	89 72 08	 mov	 DWORD PTR [edx+8], esi

; 1017 : 
; 1018 : 		if (!_Isnil(_Left(_Pnode)))

  0000e	8b 30		 mov	 esi, DWORD PTR [eax]
  00010	8a 5e 15	 mov	 bl, BYTE PTR [esi+21]
  00013	84 db		 test	 bl, bl
  00015	75 03		 jne	 SHORT $L222814

; 1019 : 			_Parent(_Left(_Pnode)) = _Wherenode;

  00017	89 56 04	 mov	 DWORD PTR [esi+4], edx
$L222814:

; 1020 : 		_Parent(_Pnode) = _Parent(_Wherenode);

  0001a	8b 72 04	 mov	 esi, DWORD PTR [edx+4]
  0001d	89 70 04	 mov	 DWORD PTR [eax+4], esi

; 1021 : 
; 1022 : 		if (_Wherenode == _Root())

  00020	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00023	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  00026	75 0d		 jne	 SHORT $L222815

; 1023 : 			_Root() = _Pnode;

  00028	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  0002b	5e		 pop	 esi

; 1028 : 
; 1029 : 		_Left(_Pnode) = _Wherenode;

  0002c	89 10		 mov	 DWORD PTR [eax], edx

; 1030 : 		_Parent(_Wherenode) = _Pnode;

  0002e	89 42 04	 mov	 DWORD PTR [edx+4], eax
  00031	5b		 pop	 ebx

; 1031 : 		}

  00032	c2 04 00	 ret	 4
$L222815:

; 1024 : 		else if (_Wherenode == _Left(_Parent(_Wherenode)))

  00035	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00038	3b 11		 cmp	 edx, DWORD PTR [ecx]
  0003a	75 0c		 jne	 SHORT $L222817

; 1025 : 			_Left(_Parent(_Wherenode)) = _Pnode;

  0003c	89 01		 mov	 DWORD PTR [ecx], eax
  0003e	5e		 pop	 esi

; 1028 : 
; 1029 : 		_Left(_Pnode) = _Wherenode;

  0003f	89 10		 mov	 DWORD PTR [eax], edx

; 1030 : 		_Parent(_Wherenode) = _Pnode;

  00041	89 42 04	 mov	 DWORD PTR [edx+4], eax
  00044	5b		 pop	 ebx

; 1031 : 		}

  00045	c2 04 00	 ret	 4
$L222817:

; 1026 : 		else
; 1027 : 			_Right(_Parent(_Wherenode)) = _Pnode;

  00048	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  0004b	5e		 pop	 esi

; 1028 : 
; 1029 : 		_Left(_Pnode) = _Wherenode;

  0004c	89 10		 mov	 DWORD PTR [eax], edx

; 1030 : 		_Parent(_Wherenode) = _Pnode;

  0004e	89 42 04	 mov	 DWORD PTR [edx+4], eax
  00051	5b		 pop	 ebx

; 1031 : 		}

  00052	c2 04 00	 ret	 4
?_Lrotate@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Lrotate
_TEXT	ENDS
PUBLIC	?_Ubound@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@ABK@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Ubound
; Function compile flags: /Ogty
;	COMDAT ?_Ubound@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@ABK@Z
_TEXT	SEGMENT
__Keyval$ = 8						; size = 4
?_Ubound@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@ABK@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Ubound, COMDAT
; _this$ = ecx

; 1089 : 		_Nodeptr _Pnode = _Root();

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]

; 1090 : 		_Nodeptr _Wherenode = _Myhead;	// end() if search fails
; 1091 : 
; 1092 : 		while (!_Isnil(_Pnode))

  00006	8a 51 15	 mov	 dl, BYTE PTR [ecx+21]
  00009	84 d2		 test	 dl, dl
  0000b	75 1d		 jne	 SHORT $L222845
  0000d	8b 54 24 04	 mov	 edx, DWORD PTR __Keyval$[esp-4]
  00011	8b 12		 mov	 edx, DWORD PTR [edx]
  00013	53		 push	 ebx
$L222844:

; 1093 : 			if (this->comp(_Keyval, _Key(_Pnode)))

  00014	3b 51 0c	 cmp	 edx, DWORD PTR [ecx+12]
  00017	73 06		 jae	 SHORT $L222846

; 1094 : 				{	// _Pnode greater than _Keyval, remember it
; 1095 : 				_Wherenode = _Pnode;

  00019	8b c1		 mov	 eax, ecx

; 1096 : 				_Pnode = _Left(_Pnode);	// descend left subtree

  0001b	8b 09		 mov	 ecx, DWORD PTR [ecx]

; 1097 : 				}
; 1098 : 			else

  0001d	eb 03		 jmp	 SHORT $L222847
$L222846:

; 1099 : 				_Pnode = _Right(_Pnode);	// descend right subtree

  0001f	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
$L222847:

; 1090 : 		_Nodeptr _Wherenode = _Myhead;	// end() if search fails
; 1091 : 
; 1092 : 		while (!_Isnil(_Pnode))

  00022	8a 59 15	 mov	 bl, BYTE PTR [ecx+21]
  00025	84 db		 test	 bl, bl
  00027	74 eb		 je	 SHORT $L222844
  00029	5b		 pop	 ebx
$L222845:

; 1100 : 
; 1101 : 		return (_Wherenode);	// return best remembered candidate
; 1102 : 		}

  0002a	c2 04 00	 ret	 4
?_Ubound@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@ABK@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Ubound
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Node>::destroy
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Node>::destroy, COMDAT
; _this$ = ecx

; 152  : 		_Destroy(_Ptr);
; 153  : 		}

  00000	c2 04 00	 ret	 4
?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Node>::destroy
_TEXT	ENDS
PUBLIC	??Econst_iterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::const_iterator::operator++
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??Econst_iterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::const_iterator::operator++, COMDAT
; _this$ = ecx

; 214  : 			{	// preincrement

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 215  : 			_Inc();

  00003	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::const_iterator::_Inc

; 216  : 			return (*this);

  00008	8b c6		 mov	 eax, esi
  0000a	5e		 pop	 esi

; 217  : 			}

  0000b	c3		 ret	 0
??Econst_iterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::const_iterator::operator++
_TEXT	ENDS
PUBLIC	??Fconst_iterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::const_iterator::operator--
; Function compile flags: /Ogty
;	COMDAT ??Fconst_iterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??Fconst_iterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::const_iterator::operator--, COMDAT
; _this$ = ecx

; 227  : 			{	// predecrement

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 228  : 			_Dec();

  00003	e8 00 00 00 00	 call	 ?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::const_iterator::_Dec

; 229  : 			return (*this);

  00008	8b c6		 mov	 eax, esi
  0000a	5e		 pop	 esi

; 230  : 			}

  0000b	c3		 ret	 0
??Fconst_iterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::const_iterator::operator--
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::_Node>::allocate
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@I@Z PROC NEAR ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::_Node>::allocate, COMDAT
; _this$ = ecx

; 137  : 		return (_Allocate(_Count, (pointer)0));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Count$[esp-4]
  00004	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00007	c1 e0 03	 shl	 eax, 3
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00010	83 c4 04	 add	 esp, 4

; 138  : 		}

  00013	c2 04 00	 ret	 4
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::_Node>::allocate
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::_Node>::destroy
; Function compile flags: /Ogty
;	COMDAT ?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::_Node>::destroy, COMDAT
; _this$ = ecx

; 152  : 		_Destroy(_Ptr);
; 153  : 		}

  00000	c2 04 00	 ret	 4
?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::_Node>::destroy
_TEXT	ENDS
PUBLIC	?_Root@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::_Root
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Root@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::_Root, COMDAT
; _this$ = ecx

; 1064 : 		return (_Parent(_Myhead));

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	83 c0 04	 add	 eax, 4

; 1065 : 		}

  00006	c3		 ret	 0
?_Root@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::_Root
_TEXT	ENDS
PUBLIC	??0iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::iterator::iterator
; Function compile flags: /Ogty
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
??0iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::iterator::iterator, COMDAT
; _this$ = ecx

; 312  : 			{	// construct with node pointer _Pnode

  00000	8b c1		 mov	 eax, ecx
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Pnode$[esp-4]
  00006	89 08		 mov	 DWORD PTR [eax], ecx

; 313  : 			}

  00008	c2 04 00	 ret	 4
??0iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::iterator::iterator
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@D@std@@QAEPADI@Z		; std::allocator<char>::allocate
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@D@std@@QAEPADI@Z PROC NEAR	; std::allocator<char>::allocate, COMDAT
; _this$ = ecx

; 137  : 		return (_Allocate(_Count, (pointer)0));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Count$[esp-4]
  00004	50		 push	 eax
  00005	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0000a	83 c4 04	 add	 esp, 4

; 138  : 		}

  0000d	c2 04 00	 ret	 4
?allocate@?$allocator@D@std@@QAEPADI@Z ENDP		; std::allocator<char>::allocate
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Node>::allocate
; Function compile flags: /Ogty
;	COMDAT ?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@I@Z PROC NEAR ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Node>::allocate, COMDAT
; _this$ = ecx

; 137  : 		return (_Allocate(_Count, (pointer)0));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Count$[esp-4]
  00004	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00007	c1 e0 03	 shl	 eax, 3
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00010	83 c4 04	 add	 esp, 4

; 138  : 		}

  00013	c2 04 00	 ret	 4
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Node>::allocate
_TEXT	ENDS
PUBLIC	??Econst_iterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::const_iterator::operator++
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??Econst_iterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::const_iterator::operator++, COMDAT
; _this$ = ecx

; 214  : 			{	// preincrement

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 215  : 			_Inc();

  00003	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::const_iterator::_Inc

; 216  : 			return (*this);

  00008	8b c6		 mov	 eax, esi
  0000a	5e		 pop	 esi

; 217  : 			}

  0000b	c3		 ret	 0
??Econst_iterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::const_iterator::operator++
_TEXT	ENDS
PUBLIC	?_Lrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Lrotate
; Function compile flags: /Ogty
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Wherenode$ = 8					; size = 4
?_Lrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Lrotate, COMDAT
; _this$ = ecx

; 1015 : 		_Nodeptr _Pnode = _Right(_Wherenode);

  00000	8b 54 24 04	 mov	 edx, DWORD PTR __Wherenode$[esp-4]
  00004	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00007	53		 push	 ebx
  00008	56		 push	 esi

; 1016 : 		_Right(_Wherenode) = _Left(_Pnode);

  00009	8b 30		 mov	 esi, DWORD PTR [eax]
  0000b	89 72 08	 mov	 DWORD PTR [edx+8], esi

; 1017 : 
; 1018 : 		if (!_Isnil(_Left(_Pnode)))

  0000e	8b 30		 mov	 esi, DWORD PTR [eax]
  00010	8a 5e 15	 mov	 bl, BYTE PTR [esi+21]
  00013	84 db		 test	 bl, bl
  00015	75 03		 jne	 SHORT $L223650

; 1019 : 			_Parent(_Left(_Pnode)) = _Wherenode;

  00017	89 56 04	 mov	 DWORD PTR [esi+4], edx
$L223650:

; 1020 : 		_Parent(_Pnode) = _Parent(_Wherenode);

  0001a	8b 72 04	 mov	 esi, DWORD PTR [edx+4]
  0001d	89 70 04	 mov	 DWORD PTR [eax+4], esi

; 1021 : 
; 1022 : 		if (_Wherenode == _Root())

  00020	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00023	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  00026	75 0d		 jne	 SHORT $L223651

; 1023 : 			_Root() = _Pnode;

  00028	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  0002b	5e		 pop	 esi

; 1028 : 
; 1029 : 		_Left(_Pnode) = _Wherenode;

  0002c	89 10		 mov	 DWORD PTR [eax], edx

; 1030 : 		_Parent(_Wherenode) = _Pnode;

  0002e	89 42 04	 mov	 DWORD PTR [edx+4], eax
  00031	5b		 pop	 ebx

; 1031 : 		}

  00032	c2 04 00	 ret	 4
$L223651:

; 1024 : 		else if (_Wherenode == _Left(_Parent(_Wherenode)))

  00035	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00038	3b 11		 cmp	 edx, DWORD PTR [ecx]
  0003a	75 0c		 jne	 SHORT $L223653

; 1025 : 			_Left(_Parent(_Wherenode)) = _Pnode;

  0003c	89 01		 mov	 DWORD PTR [ecx], eax
  0003e	5e		 pop	 esi

; 1028 : 
; 1029 : 		_Left(_Pnode) = _Wherenode;

  0003f	89 10		 mov	 DWORD PTR [eax], edx

; 1030 : 		_Parent(_Wherenode) = _Pnode;

  00041	89 42 04	 mov	 DWORD PTR [edx+4], eax
  00044	5b		 pop	 ebx

; 1031 : 		}

  00045	c2 04 00	 ret	 4
$L223653:

; 1026 : 		else
; 1027 : 			_Right(_Parent(_Wherenode)) = _Pnode;

  00048	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  0004b	5e		 pop	 esi

; 1028 : 
; 1029 : 		_Left(_Pnode) = _Wherenode;

  0004c	89 10		 mov	 DWORD PTR [eax], edx

; 1030 : 		_Parent(_Wherenode) = _Pnode;

  0004e	89 42 04	 mov	 DWORD PTR [edx+4], eax
  00051	5b		 pop	 ebx

; 1031 : 		}

  00052	c2 04 00	 ret	 4
?_Lrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Lrotate
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node>::destroy
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z PROC NEAR ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node>::destroy, COMDAT
; _this$ = ecx

; 152  : 		_Destroy(_Ptr);
; 153  : 		}

  00000	c2 04 00	 ret	 4
?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node>::destroy
_TEXT	ENDS
PUBLIC	??Econst_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::const_iterator::operator++
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??Econst_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::const_iterator::operator++, COMDAT
; _this$ = ecx

; 214  : 			{	// preincrement

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 215  : 			_Inc();

  00003	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::const_iterator::_Inc

; 216  : 			return (*this);

  00008	8b c6		 mov	 eax, esi
  0000a	5e		 pop	 esi

; 217  : 			}

  0000b	c3		 ret	 0
??Econst_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::const_iterator::operator++
_TEXT	ENDS
PUBLIC	?Serialize@__MINIGAME_PACKET@@UAEXAAVCAr@@@Z	; __MINIGAME_PACKET::Serialize
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\minigamebase.h
;	COMDAT ?Serialize@__MINIGAME_PACKET@@UAEXAAVCAr@@@Z
_TEXT	SEGMENT
_ar$ = 8						; size = 4
?Serialize@__MINIGAME_PACKET@@UAEXAAVCAr@@@Z PROC NEAR	; __MINIGAME_PACKET::Serialize, COMDAT
; _this$ = ecx

; 16   : 	{

  00000	53		 push	 ebx
  00001	55		 push	 ebp
  00002	56		 push	 esi

; 17   : 		if( ar.IsStoring() )

  00003	8b 74 24 10	 mov	 esi, DWORD PTR _ar$[esp+8]
  00007	33 c0		 xor	 eax, eax
  00009	8a 06		 mov	 al, BYTE PTR [esi]
  0000b	57		 push	 edi
  0000c	8b f9		 mov	 edi, ecx
  0000e	f7 d0		 not	 eax
  00010	a8 01		 test	 al, 1
  00012	74 66		 je	 SHORT $L243594

; 18   : 			ar << wNowGame << nState << nParam1 << nParam2;

  00014	66 8b 5f 04	 mov	 bx, WORD PTR [edi+4]
  00018	6a 02		 push	 2
  0001a	8b ce		 mov	 ecx, esi
  0001c	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00021	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00024	66 89 19	 mov	 WORD PTR [ecx], bx
  00027	8b 5e 08	 mov	 ebx, DWORD PTR [esi+8]
  0002a	83 c3 02	 add	 ebx, 2
  0002d	bd 04 00 00 00	 mov	 ebp, 4
  00032	89 5e 08	 mov	 DWORD PTR [esi+8], ebx
  00035	8b 5f 08	 mov	 ebx, DWORD PTR [edi+8]
  00038	55		 push	 ebp
  00039	8b ce		 mov	 ecx, esi
  0003b	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00040	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00043	89 1a		 mov	 DWORD PTR [edx], ebx
  00045	01 6e 08	 add	 DWORD PTR [esi+8], ebp
  00048	8b 5f 0c	 mov	 ebx, DWORD PTR [edi+12]
  0004b	55		 push	 ebp
  0004c	8b ce		 mov	 ecx, esi
  0004e	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00053	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00056	89 18		 mov	 DWORD PTR [eax], ebx
  00058	01 6e 08	 add	 DWORD PTR [esi+8], ebp
  0005b	8b 7f 10	 mov	 edi, DWORD PTR [edi+16]
  0005e	55		 push	 ebp
  0005f	8b ce		 mov	 ecx, esi
  00061	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00066	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00069	89 39		 mov	 DWORD PTR [ecx], edi
  0006b	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0006e	03 c5		 add	 eax, ebp
  00070	5f		 pop	 edi
  00071	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00074	5e		 pop	 esi
  00075	5d		 pop	 ebp
  00076	5b		 pop	 ebx

; 21   : 	}

  00077	c2 04 00	 ret	 4
$L243594:

; 19   : 		else
; 20   : 			ar >> wNowGame >> nState >> nParam1 >> nParam2;

  0007a	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0007d	8b 5e 0c	 mov	 ebx, DWORD PTR [esi+12]
  00080	8d 50 02	 lea	 edx, DWORD PTR [eax+2]
  00083	33 c9		 xor	 ecx, ecx
  00085	3b d3		 cmp	 edx, ebx
  00087	77 0d		 ja	 SHORT $L303101
  00089	66 8b 00	 mov	 ax, WORD PTR [eax]
  0008c	66 89 47 04	 mov	 WORD PTR [edi+4], ax
  00090	83 46 08 02	 add	 DWORD PTR [esi+8], 2
  00094	eb 0a		 jmp	 SHORT $L303102
$L303101:
  00096	66 89 4f 04	 mov	 WORD PTR [edi+4], cx
  0009a	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  0009d	89 56 08	 mov	 DWORD PTR [esi+8], edx
$L303102:
  000a0	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000a3	8b 5e 0c	 mov	 ebx, DWORD PTR [esi+12]
  000a6	8d 50 04	 lea	 edx, DWORD PTR [eax+4]
  000a9	3b d3		 cmp	 edx, ebx
  000ab	bd 04 00 00 00	 mov	 ebp, 4
  000b0	77 0a		 ja	 SHORT $L303114
  000b2	8b 00		 mov	 eax, DWORD PTR [eax]
  000b4	89 47 08	 mov	 DWORD PTR [edi+8], eax
  000b7	01 6e 08	 add	 DWORD PTR [esi+8], ebp
  000ba	eb 09		 jmp	 SHORT $L303115
$L303114:
  000bc	89 4f 08	 mov	 DWORD PTR [edi+8], ecx
  000bf	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  000c2	89 56 08	 mov	 DWORD PTR [esi+8], edx
$L303115:
  000c5	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000c8	8b 5e 0c	 mov	 ebx, DWORD PTR [esi+12]
  000cb	8d 50 04	 lea	 edx, DWORD PTR [eax+4]
  000ce	3b d3		 cmp	 edx, ebx
  000d0	77 0a		 ja	 SHORT $L303127
  000d2	8b 00		 mov	 eax, DWORD PTR [eax]
  000d4	89 47 0c	 mov	 DWORD PTR [edi+12], eax
  000d7	01 6e 08	 add	 DWORD PTR [esi+8], ebp
  000da	eb 09		 jmp	 SHORT $L303128
$L303127:
  000dc	89 4f 0c	 mov	 DWORD PTR [edi+12], ecx
  000df	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  000e2	89 56 08	 mov	 DWORD PTR [esi+8], edx
$L303128:
  000e5	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000e8	8b 5e 0c	 mov	 ebx, DWORD PTR [esi+12]
  000eb	8d 50 04	 lea	 edx, DWORD PTR [eax+4]
  000ee	3b d3		 cmp	 edx, ebx
  000f0	77 14		 ja	 SHORT $L303140
  000f2	8b 00		 mov	 eax, DWORD PTR [eax]
  000f4	89 47 10	 mov	 DWORD PTR [edi+16], eax
  000f7	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000fa	03 c5		 add	 eax, ebp
  000fc	5f		 pop	 edi
  000fd	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00100	5e		 pop	 esi
  00101	5d		 pop	 ebp
  00102	5b		 pop	 ebx

; 21   : 	}

  00103	c2 04 00	 ret	 4

; 19   : 		else
; 20   : 			ar >> wNowGame >> nState >> nParam1 >> nParam2;

$L303140:
  00106	89 4f 10	 mov	 DWORD PTR [edi+16], ecx
  00109	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  0010c	5f		 pop	 edi
  0010d	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  00110	5e		 pop	 esi
  00111	5d		 pop	 ebp
  00112	5b		 pop	 ebx

; 21   : 	}

  00113	c2 04 00	 ret	 4
?Serialize@__MINIGAME_PACKET@@UAEXAAVCAr@@@Z ENDP	; __MINIGAME_PACKET::Serialize
_TEXT	ENDS
PUBLIC	?Serialize@HOUSINGINFO@@QAEXAAVCAr@@@Z		; HOUSINGINFO::Serialize
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\housing.h
;	COMDAT ?Serialize@HOUSINGINFO@@QAEXAAVCAr@@@Z
_TEXT	SEGMENT
$T303173 = -12						; size = 12
$T303177 = 8						; size = 4
_ar$ = 8						; size = 4
?Serialize@HOUSINGINFO@@QAEXAAVCAr@@@Z PROC NEAR	; HOUSINGINFO::Serialize, COMDAT
; _this$ = ecx

; 37   : 	{

  00000	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00003	53		 push	 ebx
  00004	55		 push	 ebp
  00005	56		 push	 esi

; 38   : 		if( ar.IsStoring() )

  00006	8b 74 24 1c	 mov	 esi, DWORD PTR _ar$[esp+20]
  0000a	33 c0		 xor	 eax, eax
  0000c	8a 06		 mov	 al, BYTE PTR [esi]
  0000e	57		 push	 edi
  0000f	8b f9		 mov	 edi, ecx

; 39   : 			ar << dwItemId << static_cast<time_t>(tKeepTime - time_null()) << bSetup << vPos << fAngle;

  00011	bd 04 00 00 00	 mov	 ebp, 4
  00016	f7 d0		 not	 eax
  00018	a8 01		 test	 al, 1
  0001a	0f 84 8f 00 00
	00		 je	 $L245055
  00020	8b 1f		 mov	 ebx, DWORD PTR [edi]
  00022	55		 push	 ebp
  00023	8b ce		 mov	 ecx, esi
  00025	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0002a	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0002d	89 19		 mov	 DWORD PTR [ecx], ebx
  0002f	01 6e 08	 add	 DWORD PTR [esi+8], ebp
  00032	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?g_tCurrent@@3JA ; g_tCurrent
  00038	8b 5f 04	 mov	 ebx, DWORD PTR [edi+4]
  0003b	2b d9		 sub	 ebx, ecx
  0003d	55		 push	 ebp
  0003e	8b ce		 mov	 ecx, esi
  00040	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00045	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00048	89 1a		 mov	 DWORD PTR [edx], ebx
  0004a	01 6e 08	 add	 DWORD PTR [esi+8], ebp
  0004d	8b 5f 08	 mov	 ebx, DWORD PTR [edi+8]
  00050	55		 push	 ebp
  00051	8b ce		 mov	 ecx, esi
  00053	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00058	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0005b	89 18		 mov	 DWORD PTR [eax], ebx
  0005d	01 6e 08	 add	 DWORD PTR [esi+8], ebp
  00060	8d 4f 0c	 lea	 ecx, DWORD PTR [edi+12]
  00063	8b 11		 mov	 edx, DWORD PTR [ecx]
  00065	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00068	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  0006b	89 54 24 10	 mov	 DWORD PTR $T303173[esp+28], edx
  0006f	6a 0c		 push	 12			; 0000000cH
  00071	8d 54 24 14	 lea	 edx, DWORD PTR $T303173[esp+32]
  00075	89 4c 24 1c	 mov	 DWORD PTR $T303173[esp+40], ecx
  00079	52		 push	 edx
  0007a	8b ce		 mov	 ecx, esi
  0007c	89 44 24 1c	 mov	 DWORD PTR $T303173[esp+40], eax
  00080	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
  00085	8b 47 18	 mov	 eax, DWORD PTR [edi+24]
  00088	55		 push	 ebp
  00089	8b ce		 mov	 ecx, esi
  0008b	89 44 24 24	 mov	 DWORD PTR $T303177[esp+28], eax
  0008f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00094	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00097	8b 54 24 20	 mov	 edx, DWORD PTR $T303177[esp+24]
  0009b	89 11		 mov	 DWORD PTR [ecx], edx
  0009d	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000a0	03 c5		 add	 eax, ebp
  000a2	5f		 pop	 edi

; 44   : 			ar >> bSetup >> vPos >> fAngle;

  000a3	89 46 08	 mov	 DWORD PTR [esi+8], eax
  000a6	5e		 pop	 esi
  000a7	5d		 pop	 ebp
  000a8	5b		 pop	 ebx

; 45   : 		}
; 46   : 	}

  000a9	83 c4 0c	 add	 esp, 12			; 0000000cH
  000ac	c2 04 00	 ret	 4
$L245055:

; 40   : 		else
; 41   : 		{
; 42   : 			ar >> dwItemId >> tKeepTime;

  000af	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000b2	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  000b5	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
  000b8	33 db		 xor	 ebx, ebx
  000ba	3b ca		 cmp	 ecx, edx
  000bc	77 0b		 ja	 SHORT $L303181
  000be	8b 10		 mov	 edx, DWORD PTR [eax]
  000c0	89 17		 mov	 DWORD PTR [edi], edx
  000c2	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000c5	03 c5		 add	 eax, ebp
  000c7	eb 05		 jmp	 SHORT $L303215
$L303181:
  000c9	89 1f		 mov	 DWORD PTR [edi], ebx
  000cb	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
$L303215:
  000ce	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  000d1	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
  000d4	3b ca		 cmp	 ecx, edx
  000d6	89 46 08	 mov	 DWORD PTR [esi+8], eax
  000d9	77 0c		 ja	 SHORT $L303186
  000db	8b 10		 mov	 edx, DWORD PTR [eax]
  000dd	89 57 04	 mov	 DWORD PTR [edi+4], edx
  000e0	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000e3	03 c5		 add	 eax, ebp
  000e5	eb 06		 jmp	 SHORT $L303216
$L303186:
  000e7	89 5f 04	 mov	 DWORD PTR [edi+4], ebx
  000ea	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
$L303216:
  000ed	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 43   : 			tKeepTime += time_null();

  000f0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?g_tCurrent@@3JA ; g_tCurrent
  000f6	01 4f 04	 add	 DWORD PTR [edi+4], ecx

; 44   : 			ar >> bSetup >> vPos >> fAngle;

  000f9	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000fc	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  000ff	8d 50 04	 lea	 edx, DWORD PTR [eax+4]
  00102	3b d1		 cmp	 edx, ecx
  00104	77 0a		 ja	 SHORT $L303201
  00106	8b 00		 mov	 eax, DWORD PTR [eax]
  00108	89 47 08	 mov	 DWORD PTR [edi+8], eax
  0010b	01 6e 08	 add	 DWORD PTR [esi+8], ebp
  0010e	eb 09		 jmp	 SHORT $L303202
$L303201:
  00110	89 5f 08	 mov	 DWORD PTR [edi+8], ebx
  00113	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  00116	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
$L303202:
  00119	6a 0c		 push	 12			; 0000000cH
  0011b	8d 57 0c	 lea	 edx, DWORD PTR [edi+12]
  0011e	52		 push	 edx
  0011f	8b ce		 mov	 ecx, esi
  00121	e8 00 00 00 00	 call	 ?Read@CAr@@QAEXPAXI@Z	; CAr::Read
  00126	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00129	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  0012c	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
  0012f	3b ca		 cmp	 ecx, edx
  00131	77 17		 ja	 SHORT $L303211
  00133	8b 10		 mov	 edx, DWORD PTR [eax]
  00135	89 57 18	 mov	 DWORD PTR [edi+24], edx
  00138	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0013b	03 c5		 add	 eax, ebp
  0013d	5f		 pop	 edi
  0013e	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00141	5e		 pop	 esi
  00142	5d		 pop	 ebp
  00143	5b		 pop	 ebx

; 45   : 		}
; 46   : 	}

  00144	83 c4 0c	 add	 esp, 12			; 0000000cH
  00147	c2 04 00	 ret	 4

; 44   : 			ar >> bSetup >> vPos >> fAngle;

$L303211:
  0014a	89 5f 18	 mov	 DWORD PTR [edi+24], ebx
  0014d	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00150	5f		 pop	 edi
  00151	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00154	5e		 pop	 esi
  00155	5d		 pop	 ebp
  00156	5b		 pop	 ebx

; 45   : 		}
; 46   : 	}

  00157	83 c4 0c	 add	 esp, 12			; 0000000cH
  0015a	c2 04 00	 ret	 4
?Serialize@HOUSINGINFO@@QAEXAAVCAr@@@Z ENDP		; HOUSINGINFO::Serialize
_TEXT	ENDS
PUBLIC	?AddText@CUser@@QAEXPBD@Z			; CUser::AddText
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
;	COMDAT ?AddText@CUser@@QAEXPBD@Z
_TEXT	SEGMENT
_lpsz$ = 8						; size = 4
?AddText@CUser@@QAEXPBD@Z PROC NEAR			; CUser::AddText, COMDAT
; _this$ = ecx

; 681  : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	75 61		 jne	 SHORT $L278064

; 682  : 
; 683  : 	m_Snapshot.cb++;

  00006	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  0000d	56		 push	 esi

; 684  : 	m_Snapshot.ar << NULL_ID;

  0000e	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  00014	6a 04		 push	 4
  00016	8b ce		 mov	 ecx, esi
  00018	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0001d	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00020	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [eax], -1
  00026	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00029	83 c0 04	 add	 eax, 4

; 685  : 	m_Snapshot.ar << SNAPSHOTTYPE_TEXT;

  0002c	6a 02		 push	 2
  0002e	8b ce		 mov	 ecx, esi
  00030	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00033	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00038	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003b	66 c7 01 a0 00	 mov	 WORD PTR [ecx], 160	; 000000a0H
  00040	83 46 08 02	 add	 DWORD PTR [esi+8], 2

; 686  : #ifdef __S_SERVER_UNIFY
; 687  : 	m_Snapshot.ar << TEXT_GENERAL;

  00044	6a 01		 push	 1
  00046	8b ce		 mov	 ecx, esi
  00048	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0004d	8b 56 08	 mov	 edx, DWORD PTR [esi+8]

; 688  : #endif // __S_SERVER_UNIFY
; 689  : 	m_Snapshot.ar.WriteString( lpsz );

  00050	8b 44 24 08	 mov	 eax, DWORD PTR _lpsz$[esp]
  00054	c6 02 01	 mov	 BYTE PTR [edx], 1
  00057	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0005a	42		 inc	 edx
  0005b	50		 push	 eax
  0005c	8b ce		 mov	 ecx, esi
  0005e	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00061	e8 00 00 00 00	 call	 ?WriteString@CAr@@QAEXPBD@Z ; CAr::WriteString
  00066	5e		 pop	 esi
$L278064:

; 690  : }

  00067	c2 04 00	 ret	 4
?AddText@CUser@@QAEXPBD@Z ENDP				; CUser::AddText
_TEXT	ENDS
PUBLIC	?AddDiagText@CUser@@QAEXPBD@Z			; CUser::AddDiagText
; Function compile flags: /Ogty
;	COMDAT ?AddDiagText@CUser@@QAEXPBD@Z
_TEXT	SEGMENT
_lpsz$ = 8						; size = 4
?AddDiagText@CUser@@QAEXPBD@Z PROC NEAR			; CUser::AddDiagText, COMDAT
; _this$ = ecx

; 695  : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	75 61		 jne	 SHORT $L278070

; 696  : 	
; 697  : 	m_Snapshot.cb++;

  00006	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  0000d	56		 push	 esi

; 698  : 	m_Snapshot.ar << NULL_ID;

  0000e	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  00014	6a 04		 push	 4
  00016	8b ce		 mov	 ecx, esi
  00018	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0001d	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00020	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [eax], -1
  00026	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00029	83 c0 04	 add	 eax, 4

; 699  : #ifdef __S_SERVER_UNIFY
; 700  : 	m_Snapshot.ar << SNAPSHOTTYPE_TEXT;

  0002c	6a 02		 push	 2
  0002e	8b ce		 mov	 ecx, esi
  00030	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00033	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00038	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003b	66 c7 01 a0 00	 mov	 WORD PTR [ecx], 160	; 000000a0H
  00040	83 46 08 02	 add	 DWORD PTR [esi+8], 2

; 701  : 	m_Snapshot.ar << TEXT_DIAG;

  00044	6a 01		 push	 1
  00046	8b ce		 mov	 ecx, esi
  00048	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0004d	8b 56 08	 mov	 edx, DWORD PTR [esi+8]

; 702  : #else // __S_SERVER_UNIFY
; 703  : 	m_Snapshot.ar << SNAPSHOTTYPE_DIAG_TEXT;
; 704  : #endif // __S_SERVER_UNIFY
; 705  : 	m_Snapshot.ar.WriteString( lpsz );

  00050	8b 44 24 08	 mov	 eax, DWORD PTR _lpsz$[esp]
  00054	c6 02 02	 mov	 BYTE PTR [edx], 2
  00057	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0005a	42		 inc	 edx
  0005b	50		 push	 eax
  0005c	8b ce		 mov	 ecx, esi
  0005e	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00061	e8 00 00 00 00	 call	 ?WriteString@CAr@@QAEXPBD@Z ; CAr::WriteString
  00066	5e		 pop	 esi
$L278070:

; 706  : }

  00067	c2 04 00	 ret	 4
?AddDiagText@CUser@@QAEXPBD@Z ENDP			; CUser::AddDiagText
_TEXT	ENDS
PUBLIC	?AddAllAction@CUser@@QAEXH@Z			; CUser::AddAllAction
; Function compile flags: /Ogty
;	COMDAT ?AddAllAction@CUser@@QAEXH@Z
_TEXT	SEGMENT
_bCharacter$ = 8					; size = 4
?AddAllAction@CUser@@QAEXH@Z PROC NEAR			; CUser::AddAllAction, COMDAT
; _this$ = ecx

; 710  : {

  00000	57		 push	 edi
  00001	8b f9		 mov	 edi, ecx

; 711  : 	if( IsDelete() )	return;

  00003	f6 47 04 01	 test	 BYTE PTR [edi+4], 1
  00007	75 76		 jne	 SHORT $L303300

; 712  : 	m_Snapshot.cb++;

  00009	66 ff 87 0c 57
	00 00		 inc	 WORD PTR [edi+22284]
  00010	53		 push	 ebx

; 713  : 	m_Snapshot.ar << GetId();

  00011	8b 9f bc 01 00
	00		 mov	 ebx, DWORD PTR [edi+444]
  00017	56		 push	 esi
  00018	8d b7 f8 16 00
	00		 lea	 esi, DWORD PTR [edi+5880]
  0001e	6a 04		 push	 4
  00020	8b ce		 mov	 ecx, esi
  00022	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00027	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0002a	89 18		 mov	 DWORD PTR [eax], ebx
  0002c	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0002f	83 c2 04	 add	 edx, 4

; 714  : 	m_Snapshot.ar << SNAPSHOTTYPE_ALLACTION;

  00032	6a 02		 push	 2
  00034	8b ce		 mov	 ecx, esi
  00036	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00039	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003e	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00041	66 c7 01 b7 00	 mov	 WORD PTR [ecx], 183	; 000000b7H
  00046	83 46 08 02	 add	 DWORD PTR [esi+8], 2

; 715  : 	m_Snapshot.ar << m_bAllAction;

  0004a	8b bf f8 95 00
	00		 mov	 edi, DWORD PTR [edi+38392]
  00050	6a 04		 push	 4
  00052	8b ce		 mov	 ecx, esi
  00054	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00059	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0005c	89 3a		 mov	 DWORD PTR [edx], edi
  0005e	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00061	83 c2 04	 add	 edx, 4

; 716  : 	m_Snapshot.ar << bCharacter;

  00064	6a 04		 push	 4
  00066	8b ce		 mov	 ecx, esi
  00068	89 56 08	 mov	 DWORD PTR [esi+8], edx
  0006b	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00070	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00073	8b 4c 24 10	 mov	 ecx, DWORD PTR _bCharacter$[esp+8]
  00077	89 08		 mov	 DWORD PTR [eax], ecx
  00079	83 46 08 04	 add	 DWORD PTR [esi+8], 4
  0007d	5e		 pop	 esi
  0007e	5b		 pop	 ebx
$L303300:
  0007f	5f		 pop	 edi

; 717  : }

  00080	c2 04 00	 ret	 4
?AddAllAction@CUser@@QAEXH@Z ENDP			; CUser::AddAllAction
_TEXT	ENDS
PUBLIC	?AddReplace@CUser@@QAEXKAAUD3DXVECTOR3@@@Z	; CUser::AddReplace
; Function compile flags: /Ogty
;	COMDAT ?AddReplace@CUser@@QAEXKAAUD3DXVECTOR3@@@Z
_TEXT	SEGMENT
$T303329 = -12						; size = 12
_dwWorldID$ = 8						; size = 4
_vPos$ = 12						; size = 4
?AddReplace@CUser@@QAEXKAAUD3DXVECTOR3@@@Z PROC NEAR	; CUser::AddReplace, COMDAT
; _this$ = ecx

; 723  : 	if( IsDelete() )	return;

  00000	8a 41 04	 mov	 al, BYTE PTR [ecx+4]
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	a8 01		 test	 al, 1
  00008	75 7b		 jne	 SHORT $L303328

; 724  : 	
; 725  : 	m_Snapshot.cb++;

  0000a	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  00011	56		 push	 esi

; 726  : 	m_Snapshot.ar << NULL_ID;

  00012	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  00018	6a 04		 push	 4
  0001a	8b ce		 mov	 ecx, esi
  0001c	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00021	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00024	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [eax], -1
  0002a	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0002d	83 c0 04	 add	 eax, 4

; 727  : 	m_Snapshot.ar << SNAPSHOTTYPE_REPLACE;

  00030	6a 02		 push	 2
  00032	8b ce		 mov	 ecx, esi
  00034	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00037	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003c	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003f	66 c7 01 f2 00	 mov	 WORD PTR [ecx], 242	; 000000f2H
  00044	83 46 08 02	 add	 DWORD PTR [esi+8], 2

; 728  : 	m_Snapshot.ar << dwWorldID;

  00048	6a 04		 push	 4
  0004a	8b ce		 mov	 ecx, esi
  0004c	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00051	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00054	8b 44 24 14	 mov	 eax, DWORD PTR _dwWorldID$[esp+12]

; 729  : 	m_Snapshot.ar << vPos;

  00058	8b 4c 24 18	 mov	 ecx, DWORD PTR _vPos$[esp+12]
  0005c	89 02		 mov	 DWORD PTR [edx], eax
  0005e	83 46 08 04	 add	 DWORD PTR [esi+8], 4
  00062	8b 11		 mov	 edx, DWORD PTR [ecx]
  00064	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00067	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  0006a	89 54 24 04	 mov	 DWORD PTR $T303329[esp+16], edx
  0006e	6a 0c		 push	 12			; 0000000cH
  00070	8d 54 24 08	 lea	 edx, DWORD PTR $T303329[esp+20]
  00074	89 4c 24 10	 mov	 DWORD PTR $T303329[esp+28], ecx
  00078	52		 push	 edx
  00079	8b ce		 mov	 ecx, esi
  0007b	89 44 24 10	 mov	 DWORD PTR $T303329[esp+28], eax
  0007f	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
  00084	5e		 pop	 esi
$L303328:

; 730  : }

  00085	83 c4 0c	 add	 esp, 12			; 0000000cH
  00088	c2 08 00	 ret	 8
?AddReplace@CUser@@QAEXKAAUD3DXVECTOR3@@@Z ENDP		; CUser::AddReplace
_TEXT	ENDS
PUBLIC	?AddTrade@CUser@@QAEXPAV1@K@Z			; CUser::AddTrade
; Function compile flags: /Ogty
;	COMDAT ?AddTrade@CUser@@QAEXPAV1@K@Z
_TEXT	SEGMENT
_pTrader$ = 8						; size = 4
_uidPlayer$ = 12					; size = 4
?AddTrade@CUser@@QAEXPAV1@K@Z PROC NEAR			; CUser::AddTrade, COMDAT
; _this$ = ecx

; 758  : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	75 74		 jne	 SHORT $L278112

; 759  : 
; 760  : 	m_Snapshot.cb++;

  00006	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  0000d	53		 push	 ebx
  0000e	56		 push	 esi
  0000f	57		 push	 edi

; 761  : 	m_Snapshot.ar << GETID( pTrader );

  00010	8b 7c 24 10	 mov	 edi, DWORD PTR _pTrader$[esp+8]
  00014	85 ff		 test	 edi, edi
  00016	74 08		 je	 SHORT $L303334
  00018	8b 9f bc 01 00
	00		 mov	 ebx, DWORD PTR [edi+444]
  0001e	eb 03		 jmp	 SHORT $L303335
$L303334:
  00020	83 cb ff	 or	 ebx, -1
$L303335:
  00023	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  00029	6a 04		 push	 4
  0002b	8b ce		 mov	 ecx, esi
  0002d	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00032	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00035	89 18		 mov	 DWORD PTR [eax], ebx
  00037	83 46 08 04	 add	 DWORD PTR [esi+8], 4

; 762  : 	m_Snapshot.ar << SNAPSHOTTYPE_TRADE;

  0003b	6a 02		 push	 2
  0003d	8b ce		 mov	 ecx, esi
  0003f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00044	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00047	66 c7 01 07 00	 mov	 WORD PTR [ecx], 7
  0004c	8b 5e 08	 mov	 ebx, DWORD PTR [esi+8]
  0004f	83 c3 02	 add	 ebx, 2

; 763  : 	m_Snapshot.ar << uidPlayer;

  00052	6a 04		 push	 4
  00054	8b ce		 mov	 ecx, esi
  00056	89 5e 08	 mov	 DWORD PTR [esi+8], ebx
  00059	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0005e	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00061	8b 44 24 14	 mov	 eax, DWORD PTR _uidPlayer$[esp+8]
  00065	89 02		 mov	 DWORD PTR [edx], eax
  00067	83 46 08 04	 add	 DWORD PTR [esi+8], 4

; 764  : 
; 765  : 	pTrader->m_Inventory.Serialize( m_Snapshot.ar );

  0006b	56		 push	 esi
  0006c	8d 8f 90 0b 00
	00		 lea	 ecx, DWORD PTR [edi+2960]
  00072	e8 00 00 00 00	 call	 ?Serialize@?$CItemContainer@VCItemElem@@@@QAEXAAVCAr@@@Z ; CItemContainer<CItemElem>::Serialize
  00077	5f		 pop	 edi
  00078	5e		 pop	 esi
  00079	5b		 pop	 ebx
$L278112:

; 766  : }

  0007a	c2 08 00	 ret	 8
?AddTrade@CUser@@QAEXPAV1@K@Z ENDP			; CUser::AddTrade
_TEXT	ENDS
PUBLIC	?AddTradePut@CUser@@QAEXKEEEF@Z			; CUser::AddTradePut
; Function compile flags: /Ogty
;	COMDAT ?AddTradePut@CUser@@QAEXKEEEF@Z
_TEXT	SEGMENT
_objid$ = 8						; size = 4
_i$ = 12						; size = 1
_nItemType$ = 16					; size = 1
_nId$ = 20						; size = 1
_nItemNum$ = 24						; size = 2
?AddTradePut@CUser@@QAEXKEEEF@Z PROC NEAR		; CUser::AddTradePut, COMDAT
; _this$ = ecx

; 810  : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	0f 85 9e 00 00
	00		 jne	 $L303387

; 811  : 
; 812  : 	m_Snapshot.cb++;

  0000a	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  00011	56		 push	 esi

; 813  : 	m_Snapshot.ar << objid;

  00012	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  00018	6a 04		 push	 4
  0001a	8b ce		 mov	 ecx, esi
  0001c	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00021	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00024	8b 4c 24 08	 mov	 ecx, DWORD PTR _objid$[esp]
  00028	89 08		 mov	 DWORD PTR [eax], ecx
  0002a	83 46 08 04	 add	 DWORD PTR [esi+8], 4

; 814  : 	m_Snapshot.ar << SNAPSHOTTYPE_TRADEPUT;

  0002e	6a 02		 push	 2
  00030	8b ce		 mov	 ecx, esi
  00032	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00037	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0003a	66 c7 02 08 00	 mov	 WORD PTR [edx], 8
  0003f	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00042	83 c2 02	 add	 edx, 2

; 815  : 	m_Snapshot.ar << i << nItemType << nId << nItemNum;

  00045	6a 01		 push	 1
  00047	8b ce		 mov	 ecx, esi
  00049	89 56 08	 mov	 DWORD PTR [esi+8], edx
  0004c	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00051	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00054	8a 4c 24 0c	 mov	 cl, BYTE PTR _i$[esp]
  00058	88 08		 mov	 BYTE PTR [eax], cl
  0005a	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0005d	40		 inc	 eax
  0005e	6a 01		 push	 1
  00060	8b ce		 mov	 ecx, esi
  00062	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00065	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0006a	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0006d	8a 44 24 10	 mov	 al, BYTE PTR _nItemType$[esp]
  00071	88 02		 mov	 BYTE PTR [edx], al
  00073	ff 46 08	 inc	 DWORD PTR [esi+8]
  00076	6a 01		 push	 1
  00078	8b ce		 mov	 ecx, esi
  0007a	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0007f	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00082	8a 54 24 14	 mov	 dl, BYTE PTR _nId$[esp]
  00086	88 11		 mov	 BYTE PTR [ecx], dl
  00088	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0008b	42		 inc	 edx
  0008c	6a 02		 push	 2
  0008e	8b ce		 mov	 ecx, esi
  00090	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00093	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00098	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0009b	66 8b 4c 24 18	 mov	 cx, WORD PTR _nItemNum$[esp]
  000a0	66 89 08	 mov	 WORD PTR [eax], cx
  000a3	83 46 08 02	 add	 DWORD PTR [esi+8], 2
  000a7	5e		 pop	 esi
$L303387:

; 816  : }

  000a8	c2 14 00	 ret	 20			; 00000014H
?AddTradePut@CUser@@QAEXKEEEF@Z ENDP			; CUser::AddTradePut
_TEXT	ENDS
PUBLIC	?AddTradeCancel@CUser@@QAEXKKH@Z		; CUser::AddTradeCancel
; Function compile flags: /Ogty
;	COMDAT ?AddTradeCancel@CUser@@QAEXKKH@Z
_TEXT	SEGMENT
_objid$ = 8						; size = 4
_uidPlayer$ = 12					; size = 4
_nMode$ = 16						; size = 4
?AddTradeCancel@CUser@@QAEXKKH@Z PROC NEAR		; CUser::AddTradeCancel, COMDAT
; _this$ = ecx

; 859  : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	75 70		 jne	 SHORT $L303413

; 860  : 
; 861  : 	m_Snapshot.cb++;

  00006	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  0000d	56		 push	 esi

; 862  : 	m_Snapshot.ar << objid;

  0000e	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  00014	6a 04		 push	 4
  00016	8b ce		 mov	 ecx, esi
  00018	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0001d	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00020	8b 4c 24 08	 mov	 ecx, DWORD PTR _objid$[esp]
  00024	89 08		 mov	 DWORD PTR [eax], ecx
  00026	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00029	83 c0 04	 add	 eax, 4

; 863  : 	m_Snapshot.ar << SNAPSHOTTYPE_TRADECANCEL;

  0002c	6a 02		 push	 2
  0002e	8b ce		 mov	 ecx, esi
  00030	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00033	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00038	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0003b	66 c7 02 0b 00	 mov	 WORD PTR [edx], 11	; 0000000bH
  00040	83 46 08 02	 add	 DWORD PTR [esi+8], 2

; 864  : 	m_Snapshot.ar << uidPlayer;

  00044	6a 04		 push	 4
  00046	8b ce		 mov	 ecx, esi
  00048	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0004d	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00050	8b 4c 24 0c	 mov	 ecx, DWORD PTR _uidPlayer$[esp]
  00054	89 08		 mov	 DWORD PTR [eax], ecx
  00056	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00059	83 c2 04	 add	 edx, 4

; 865  : 	m_Snapshot.ar << nMode;

  0005c	6a 04		 push	 4
  0005e	8b ce		 mov	 ecx, esi
  00060	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00063	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00068	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0006b	8b 44 24 10	 mov	 eax, DWORD PTR _nMode$[esp]
  0006f	89 02		 mov	 DWORD PTR [edx], eax
  00071	83 46 08 04	 add	 DWORD PTR [esi+8], 4
  00075	5e		 pop	 esi
$L303413:

; 866  : }

  00076	c2 0c 00	 ret	 12			; 0000000cH
?AddTradeCancel@CUser@@QAEXKKH@Z ENDP			; CUser::AddTradeCancel
_TEXT	ENDS
PUBLIC	?AddOpenShopWnd@CUser@@QAEXPAVCMover@@@Z	; CUser::AddOpenShopWnd
; Function compile flags: /Ogty
;	COMDAT ?AddOpenShopWnd@CUser@@QAEXPAVCMover@@@Z
_TEXT	SEGMENT
_pVendor$ = 8						; size = 4
?AddOpenShopWnd@CUser@@QAEXPAVCMover@@@Z PROC NEAR	; CUser::AddOpenShopWnd, COMDAT
; _this$ = ecx

; 872  : 	int i;
; 873  : 	m_Snapshot.cb++;

  00000	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  00007	53		 push	 ebx
  00008	56		 push	 esi
  00009	57		 push	 edi

; 874  : 	m_Snapshot.ar << pVendor->GetId();

  0000a	8b 7c 24 10	 mov	 edi, DWORD PTR _pVendor$[esp+8]
  0000e	8b 9f bc 01 00
	00		 mov	 ebx, DWORD PTR [edi+444]
  00014	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  0001a	6a 04		 push	 4
  0001c	8b ce		 mov	 ecx, esi
  0001e	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00023	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00026	89 18		 mov	 DWORD PTR [eax], ebx
  00028	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0002b	83 c2 04	 add	 edx, 4

; 875  : 	m_Snapshot.ar << SNAPSHOTTYPE_OPENSHOPWND;

  0002e	6a 02		 push	 2
  00030	8b ce		 mov	 ecx, esi
  00032	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00035	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003a	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003d	66 c7 01 14 00	 mov	 WORD PTR [ecx], 20	; 00000014H
  00042	83 46 08 02	 add	 DWORD PTR [esi+8], 2
  00046	81 c7 80 0b 00
	00		 add	 edi, 2944		; 00000b80H
  0004c	bb 04 00 00 00	 mov	 ebx, 4
$L278185:

; 876  : 	for( i = 0; i < MAX_VENDOR_INVENTORY_TAB; i++ )
; 877  : 		pVendor->m_ShopInventory[i]->Serialize( m_Snapshot.ar );

  00051	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00053	56		 push	 esi
  00054	e8 00 00 00 00	 call	 ?Serialize@?$CItemContainer@VCItemElem@@@@QAEXAAVCAr@@@Z ; CItemContainer<CItemElem>::Serialize
  00059	83 c7 04	 add	 edi, 4
  0005c	4b		 dec	 ebx
  0005d	75 f2		 jne	 SHORT $L278185
  0005f	5f		 pop	 edi
  00060	5e		 pop	 esi
  00061	5b		 pop	 ebx

; 878  : }

  00062	c2 04 00	 ret	 4
?AddOpenShopWnd@CUser@@QAEXPAVCMover@@@Z ENDP		; CUser::AddOpenShopWnd
_TEXT	ENDS
PUBLIC	?AddRegisterPVendorItem@CUser@@QAEXEEEFH@Z	; CUser::AddRegisterPVendorItem
; Function compile flags: /Ogty
;	COMDAT ?AddRegisterPVendorItem@CUser@@QAEXEEEFH@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 1
_nType$ = 12						; size = 1
_nId$ = 16						; size = 1
_nNum$ = 20						; size = 2
_nCost$ = 24						; size = 4
?AddRegisterPVendorItem@CUser@@QAEXEEEFH@Z PROC NEAR	; CUser::AddRegisterPVendorItem, COMDAT
; _this$ = ecx

; 891  : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	0f 85 be 00 00
	00		 jne	 $L303475

; 892  : 	m_Snapshot.cb++;

  0000a	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  00011	56		 push	 esi
  00012	57		 push	 edi

; 893  : 	m_Snapshot.ar << GetId();

  00013	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  00019	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  0001f	6a 04		 push	 4
  00021	8b ce		 mov	 ecx, esi
  00023	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00028	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0002b	89 38		 mov	 DWORD PTR [eax], edi
  0002d	83 46 08 04	 add	 DWORD PTR [esi+8], 4

; 894  : 	m_Snapshot.ar << SNAPSHOTTYPE_REGISTER_PVENDOR_ITEM;

  00031	bf 02 00 00 00	 mov	 edi, 2
  00036	57		 push	 edi
  00037	8b ce		 mov	 ecx, esi
  00039	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003e	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00041	66 c7 01 44 00	 mov	 WORD PTR [ecx], 68	; 00000044H
  00046	01 7e 08	 add	 DWORD PTR [esi+8], edi

; 895  : 	m_Snapshot.ar << iIndex << nType << nId << nNum << nCost;

  00049	6a 01		 push	 1
  0004b	8b ce		 mov	 ecx, esi
  0004d	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00052	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00055	8a 44 24 0c	 mov	 al, BYTE PTR _iIndex$[esp+4]
  00059	88 02		 mov	 BYTE PTR [edx], al
  0005b	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0005e	42		 inc	 edx
  0005f	6a 01		 push	 1
  00061	8b ce		 mov	 ecx, esi
  00063	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00066	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0006b	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0006e	8a 54 24 10	 mov	 dl, BYTE PTR _nType$[esp+4]
  00072	88 11		 mov	 BYTE PTR [ecx], dl
  00074	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00077	40		 inc	 eax
  00078	6a 01		 push	 1
  0007a	8b ce		 mov	 ecx, esi
  0007c	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0007f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00084	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00087	8a 4c 24 14	 mov	 cl, BYTE PTR _nId$[esp+4]
  0008b	88 08		 mov	 BYTE PTR [eax], cl
  0008d	ff 46 08	 inc	 DWORD PTR [esi+8]
  00090	57		 push	 edi
  00091	8b ce		 mov	 ecx, esi
  00093	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00098	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0009b	66 8b 44 24 18	 mov	 ax, WORD PTR _nNum$[esp+4]
  000a0	66 89 02	 mov	 WORD PTR [edx], ax
  000a3	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  000a6	03 d7		 add	 edx, edi
  000a8	6a 04		 push	 4
  000aa	8b ce		 mov	 ecx, esi
  000ac	89 56 08	 mov	 DWORD PTR [esi+8], edx
  000af	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000b4	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  000b7	8b 54 24 1c	 mov	 edx, DWORD PTR _nCost$[esp+4]
  000bb	89 11		 mov	 DWORD PTR [ecx], edx
  000bd	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000c0	83 c0 04	 add	 eax, 4
  000c3	5f		 pop	 edi
  000c4	89 46 08	 mov	 DWORD PTR [esi+8], eax
  000c7	5e		 pop	 esi
$L303475:

; 896  : }

  000c8	c2 14 00	 ret	 20			; 00000014H
?AddRegisterPVendorItem@CUser@@QAEXEEEFH@Z ENDP		; CUser::AddRegisterPVendorItem
_TEXT	ENDS
PUBLIC	?AddPVendorItem@CUser@@QAEXPAV1@H@Z		; CUser::AddPVendorItem
EXTRN	?GetItem@CVTInfo@@QAEPAVCItemBase@@E@Z:NEAR	; CVTInfo::GetItem
; Function compile flags: /Ogty
;	COMDAT ?AddPVendorItem@CUser@@QAEXPAV1@H@Z
_TEXT	SEGMENT
tv260 = -12						; size = 4
_uOffset$ = -8						; size = 4
_nBlockSize$ = -4					; size = 4
_nVendorItem$ = 8					; size = 1
_pUser$ = 8						; size = 4
_bState$ = 12						; size = 4
?AddPVendorItem@CUser@@QAEXPAV1@H@Z PROC NEAR		; CUser::AddPVendorItem, COMDAT
; _this$ = ecx

; 909  : 	if( IsDelete() )	return;

  00000	8a 41 04	 mov	 al, BYTE PTR [ecx+4]
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	a8 01		 test	 al, 1
  00008	0f 85 22 01 00
	00		 jne	 $L278215

; 910  : 
; 911  : 	m_Snapshot.cb++;

  0000e	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  00015	53		 push	 ebx
  00016	55		 push	 ebp
  00017	56		 push	 esi
  00018	57		 push	 edi

; 912  : 	m_Snapshot.ar << pUser->GetId();

  00019	8b 7c 24 20	 mov	 edi, DWORD PTR _pUser$[esp+24]
  0001d	8b 9f bc 01 00
	00		 mov	 ebx, DWORD PTR [edi+444]
  00023	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  00029	6a 04		 push	 4
  0002b	8b ce		 mov	 ecx, esi
  0002d	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00032	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00035	89 18		 mov	 DWORD PTR [eax], ebx
  00037	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0003a	83 c0 04	 add	 eax, 4

; 913  : 	m_Snapshot.ar << SNAPSHOTTYPE_PVENDOR_ITEM;

  0003d	6a 02		 push	 2
  0003f	8b ce		 mov	 ecx, esi
  00041	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00044	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00049	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0004c	66 c7 01 45 00	 mov	 WORD PTR [ecx], 69	; 00000045H
  00051	8b 5e 08	 mov	 ebx, DWORD PTR [esi+8]
  00054	83 c3 02	 add	 ebx, 2
  00057	89 5e 08	 mov	 DWORD PTR [esi+8], ebx

; 914  : 
; 915  : 	u_long uOffset	= m_Snapshot.ar.GetOffset();

  0005a	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  0005d	8b eb		 mov	 ebp, ebx
  0005f	2b ea		 sub	 ebp, edx

; 916  : 	BYTE nVendorItem	= 0;
; 917  : 
; 918  : 	m_Snapshot.ar << (BYTE)0;	// nVendorItem

  00061	6a 01		 push	 1
  00063	8b ce		 mov	 ecx, esi
  00065	89 6c 24 18	 mov	 DWORD PTR _uOffset$[esp+32], ebp
  00069	c6 44 24 24 00	 mov	 BYTE PTR _nVendorItem$[esp+28], 0
  0006e	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00073	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00076	c6 02 00	 mov	 BYTE PTR [edx], 0
  00079	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0007c	40		 inc	 eax

; 919  : 	for( int i = 0; i < MAX_VENDITEM; i++ )

  0007d	33 db		 xor	 ebx, ebx

; 920  : 	{
; 921  : 		CItemElem* pItemElem = (CItemElem *)pUser->m_vtInfo.GetItem( i );
; 922  : 		if( pItemElem  == NULL )

  0007f	81 c7 7c 0d 00
	00		 add	 edi, 3452		; 00000d7cH
  00085	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00088	89 7c 24 10	 mov	 DWORD PTR tv260[esp+28], edi
  0008c	8d 64 24 00	 npad	 4
$L303540:
  00090	8b 4c 24 10	 mov	 ecx, DWORD PTR tv260[esp+28]
  00094	53		 push	 ebx
  00095	e8 00 00 00 00	 call	 ?GetItem@CVTInfo@@QAEPAVCItemBase@@E@Z ; CVTInfo::GetItem
  0009a	8b f8		 mov	 edi, eax
  0009c	85 ff		 test	 edi, edi
  0009e	74 5d		 je	 SHORT $L278223

; 923  : 			continue;
; 924  : 
; 925  : 		m_Snapshot.ar << (BYTE)i;

  000a0	6a 01		 push	 1
  000a2	8b ce		 mov	 ecx, esi
  000a4	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000a9	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000ac	88 18		 mov	 BYTE PTR [eax], bl
  000ae	ff 46 08	 inc	 DWORD PTR [esi+8]

; 926  : 		pItemElem->Serialize( m_Snapshot.ar );

  000b1	8b 17		 mov	 edx, DWORD PTR [edi]
  000b3	56		 push	 esi
  000b4	8b cf		 mov	 ecx, edi
  000b6	ff 52 08	 call	 DWORD PTR [edx+8]

; 927  : 		m_Snapshot.ar << pItemElem->GetExtra();

  000b9	8b 6f 10	 mov	 ebp, DWORD PTR [edi+16]
  000bc	6a 04		 push	 4
  000be	8b ce		 mov	 ecx, esi
  000c0	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000c5	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000c8	89 28		 mov	 DWORD PTR [eax], ebp
  000ca	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000cd	bd 04 00 00 00	 mov	 ebp, 4
  000d2	03 c5		 add	 eax, ebp
  000d4	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 928  : 		m_Snapshot.ar << pItemElem->m_nCost;

  000d7	8b 7f 34	 mov	 edi, DWORD PTR [edi+52]
  000da	55		 push	 ebp
  000db	8b ce		 mov	 ecx, esi
  000dd	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000e2	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]

; 929  : 		nVendorItem++;

  000e5	8a 44 24 20	 mov	 al, BYTE PTR _nVendorItem$[esp+24]
  000e9	89 39		 mov	 DWORD PTR [ecx], edi
  000eb	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  000ee	03 cd		 add	 ecx, ebp
  000f0	8b 6c 24 14	 mov	 ebp, DWORD PTR _uOffset$[esp+28]
  000f4	fe c0		 inc	 al
  000f6	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  000f9	88 44 24 20	 mov	 BYTE PTR _nVendorItem$[esp+24], al
$L278223:
  000fd	43		 inc	 ebx
  000fe	83 fb 1e	 cmp	 ebx, 30			; 0000001eH
  00101	7c 8d		 jl	 SHORT $L303540

; 930  : 	}
; 931  : 	m_Snapshot.ar << bState;

  00103	6a 04		 push	 4
  00105	8b ce		 mov	 ecx, esi
  00107	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0010c	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0010f	8b 44 24 24	 mov	 eax, DWORD PTR _bState$[esp+24]
  00113	89 02		 mov	 DWORD PTR [edx], eax
  00115	83 46 08 04	 add	 DWORD PTR [esi+8], 4

; 932  : 
; 933  : 	GETBLOCK( m_Snapshot.ar, lpBlock, nBlockSize );

  00119	8d 4c 24 18	 lea	 ecx, DWORD PTR _nBlockSize$[esp+28]
  0011d	51		 push	 ecx
  0011e	8b ce		 mov	 ecx, esi
  00120	e8 00 00 00 00	 call	 ?GetBuffer@CAr@@QAEPAEPAH@Z ; CAr::GetBuffer

; 934  : 	*(UNALIGNED BYTE*)( lpBlock + uOffset )	= nVendorItem;

  00125	8a 54 24 20	 mov	 dl, BYTE PTR _nVendorItem$[esp+24]
  00129	5f		 pop	 edi
  0012a	5e		 pop	 esi
  0012b	88 14 28	 mov	 BYTE PTR [eax+ebp], dl
  0012e	5d		 pop	 ebp
  0012f	5b		 pop	 ebx
$L278215:

; 935  : }

  00130	83 c4 0c	 add	 esp, 12			; 0000000cH
  00133	c2 08 00	 ret	 8
?AddPVendorItem@CUser@@QAEXPAV1@H@Z ENDP		; CUser::AddPVendorItem
_TEXT	ENDS
PUBLIC	?AddBankWindow@CUser@@QAEXHKK@Z			; CUser::AddBankWindow
; Function compile flags: /Ogty
;	COMDAT ?AddBankWindow@CUser@@QAEXHKK@Z
_TEXT	SEGMENT
_nMode$ = 8						; size = 4
_dwId$ = 12						; size = 4
_dwItemId$ = 16						; size = 4
?AddBankWindow@CUser@@QAEXHKK@Z PROC NEAR		; CUser::AddBankWindow, COMDAT
; _this$ = ecx

; 1031 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	0f 85 98 00 00
	00		 jne	 $L303574

; 1032 : 	
; 1033 : 	m_Snapshot.cb++;

  0000a	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  00011	53		 push	 ebx
  00012	56		 push	 esi
  00013	57		 push	 edi

; 1034 : 	m_Snapshot.ar << GetId();

  00014	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  0001a	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  00020	bb 04 00 00 00	 mov	 ebx, 4
  00025	53		 push	 ebx
  00026	8b ce		 mov	 ecx, esi
  00028	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0002d	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00030	89 38		 mov	 DWORD PTR [eax], edi
  00032	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00035	03 c3		 add	 eax, ebx

; 1035 : 	m_Snapshot.ar << SNAPSHOTTYPE_BANKWINDOW;

  00037	6a 02		 push	 2
  00039	8b ce		 mov	 ecx, esi
  0003b	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0003e	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00043	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00046	66 c7 01 56 00	 mov	 WORD PTR [ecx], 86	; 00000056H
  0004b	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0004e	83 c2 02	 add	 edx, 2

; 1036 : 	m_Snapshot.ar << nMode;

  00051	53		 push	 ebx
  00052	8b ce		 mov	 ecx, esi
  00054	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00057	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0005c	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0005f	8b 44 24 10	 mov	 eax, DWORD PTR _nMode$[esp+8]
  00063	89 02		 mov	 DWORD PTR [edx], eax
  00065	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00068	03 c3		 add	 eax, ebx

; 1037 : 	m_Snapshot.ar << dwId << dwItemId;

  0006a	53		 push	 ebx
  0006b	8b ce		 mov	 ecx, esi
  0006d	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00070	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00075	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00078	8b 54 24 14	 mov	 edx, DWORD PTR _dwId$[esp+8]
  0007c	89 11		 mov	 DWORD PTR [ecx], edx
  0007e	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00081	03 d3		 add	 edx, ebx
  00083	53		 push	 ebx
  00084	8b ce		 mov	 ecx, esi
  00086	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00089	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0008e	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00091	8b 4c 24 18	 mov	 ecx, DWORD PTR _dwItemId$[esp+8]
  00095	89 08		 mov	 DWORD PTR [eax], ecx
  00097	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0009a	03 c3		 add	 eax, ebx
  0009c	5f		 pop	 edi
  0009d	89 46 08	 mov	 DWORD PTR [esi+8], eax
  000a0	5e		 pop	 esi
  000a1	5b		 pop	 ebx
$L303574:

; 1038 : 
; 1039 : }

  000a2	c2 0c 00	 ret	 12			; 0000000cH
?AddBankWindow@CUser@@QAEXHKK@Z ENDP			; CUser::AddBankWindow
_TEXT	ENDS
PUBLIC	?AddGuildBankWindow@CUser@@QAEXH@Z		; CUser::AddGuildBankWindow
; Function compile flags: /Ogty
;	COMDAT ?AddGuildBankWindow@CUser@@QAEXH@Z
_TEXT	SEGMENT
_nMode$ = 8						; size = 4
?AddGuildBankWindow@CUser@@QAEXH@Z PROC NEAR		; CUser::AddGuildBankWindow, COMDAT
; _this$ = ecx

; 1042 : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1043 : 	if( IsDelete() )	return;

  00003	f6 46 04 01	 test	 BYTE PTR [esi+4], 1
  00007	0f 85 88 00 00
	00		 jne	 $L278311
  0000d	57		 push	 edi

; 1044 : 	
; 1045 : 
; 1046 : 	CGuild* pGuild = GetGuild();

  0000e	e8 00 00 00 00	 call	 ?GetGuild@CMover@@QAEPAVCGuild@@XZ ; CMover::GetGuild
  00013	8b f8		 mov	 edi, eax

; 1047 : 	if (pGuild)

  00015	85 ff		 test	 edi, edi
  00017	74 7b		 je	 SHORT $L303607

; 1048 : 	{
; 1049 : 		m_Snapshot.cb++;

  00019	66 ff 86 0c 57
	00 00		 inc	 WORD PTR [esi+22284]
  00020	53		 push	 ebx

; 1050 : 		m_Snapshot.ar << GetId();

  00021	8b 9e bc 01 00
	00		 mov	 ebx, DWORD PTR [esi+444]
  00027	81 c6 f8 16 00
	00		 add	 esi, 5880		; 000016f8H
  0002d	6a 04		 push	 4
  0002f	8b ce		 mov	 ecx, esi
  00031	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00036	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00039	89 18		 mov	 DWORD PTR [eax], ebx
  0003b	8b 5e 08	 mov	 ebx, DWORD PTR [esi+8]
  0003e	83 c3 04	 add	 ebx, 4

; 1051 : 		m_Snapshot.ar << SNAPSHOTTYPE_GUILD_BANK_WND;

  00041	6a 02		 push	 2
  00043	8b ce		 mov	 ecx, esi
  00045	89 5e 08	 mov	 DWORD PTR [esi+8], ebx
  00048	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0004d	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00050	66 c7 01 fa 00	 mov	 WORD PTR [ecx], 250	; 000000faH
  00055	83 46 08 02	 add	 DWORD PTR [esi+8], 2

; 1052 : 		m_Snapshot.ar << nMode;

  00059	6a 04		 push	 4
  0005b	8b ce		 mov	 ecx, esi
  0005d	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00062	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00065	8b 44 24 10	 mov	 eax, DWORD PTR _nMode$[esp+8]
  00069	89 02		 mov	 DWORD PTR [edx], eax
  0006b	83 46 08 04	 add	 DWORD PTR [esi+8], 4

; 1053 : 		
; 1054 : 		m_Snapshot.ar << pGuild->m_nGoldGuild;

  0006f	8b 9f 1c 01 00
	00		 mov	 ebx, DWORD PTR [edi+284]
  00075	6a 04		 push	 4
  00077	8b ce		 mov	 ecx, esi
  00079	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0007e	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00081	89 19		 mov	 DWORD PTR [ecx], ebx
  00083	83 46 08 04	 add	 DWORD PTR [esi+8], 4

; 1055 : 		pGuild->m_GuildBank.Serialize(m_Snapshot.ar);

  00087	56		 push	 esi
  00088	8d 8f 08 01 00
	00		 lea	 ecx, DWORD PTR [edi+264]
  0008e	e8 00 00 00 00	 call	 ?Serialize@?$CItemContainer@VCItemElem@@@@QAEXAAVCAr@@@Z ; CItemContainer<CItemElem>::Serialize
  00093	5b		 pop	 ebx
$L303607:
  00094	5f		 pop	 edi
$L278311:
  00095	5e		 pop	 esi

; 1056 : 	}
; 1057 : }

  00096	c2 04 00	 ret	 4
?AddGuildBankWindow@CUser@@QAEXH@Z ENDP			; CUser::AddGuildBankWindow
_TEXT	ENDS
PUBLIC	?AddChangeBankPass@CUser@@QAEXHKK@Z		; CUser::AddChangeBankPass
; Function compile flags: /Ogty
;	COMDAT ?AddChangeBankPass@CUser@@QAEXHKK@Z
_TEXT	SEGMENT
_nMode$ = 8						; size = 4
_dwId$ = 12						; size = 4
_dwItemId$ = 16						; size = 4
?AddChangeBankPass@CUser@@QAEXHKK@Z PROC NEAR		; CUser::AddChangeBankPass, COMDAT
; _this$ = ecx

; 1061 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	0f 85 98 00 00
	00		 jne	 $L303641

; 1062 : 	
; 1063 : 	m_Snapshot.cb++;

  0000a	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  00011	53		 push	 ebx
  00012	56		 push	 esi
  00013	57		 push	 edi

; 1064 : 	m_Snapshot.ar << GetId();

  00014	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  0001a	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  00020	bb 04 00 00 00	 mov	 ebx, 4
  00025	53		 push	 ebx
  00026	8b ce		 mov	 ecx, esi
  00028	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0002d	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00030	89 38		 mov	 DWORD PTR [eax], edi
  00032	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00035	03 c3		 add	 eax, ebx

; 1065 : 	m_Snapshot.ar << SNAPSHOTTYPE_CHANGEBANKPASS;

  00037	6a 02		 push	 2
  00039	8b ce		 mov	 ecx, esi
  0003b	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0003e	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00043	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00046	66 c7 01 57 00	 mov	 WORD PTR [ecx], 87	; 00000057H
  0004b	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0004e	83 c2 02	 add	 edx, 2

; 1066 : 	m_Snapshot.ar << nMode;

  00051	53		 push	 ebx
  00052	8b ce		 mov	 ecx, esi
  00054	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00057	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0005c	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0005f	8b 44 24 10	 mov	 eax, DWORD PTR _nMode$[esp+8]
  00063	89 02		 mov	 DWORD PTR [edx], eax
  00065	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00068	03 c3		 add	 eax, ebx

; 1067 : 	m_Snapshot.ar << dwId << dwItemId;

  0006a	53		 push	 ebx
  0006b	8b ce		 mov	 ecx, esi
  0006d	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00070	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00075	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00078	8b 54 24 14	 mov	 edx, DWORD PTR _dwId$[esp+8]
  0007c	89 11		 mov	 DWORD PTR [ecx], edx
  0007e	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00081	03 d3		 add	 edx, ebx
  00083	53		 push	 ebx
  00084	8b ce		 mov	 ecx, esi
  00086	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00089	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0008e	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00091	8b 4c 24 18	 mov	 ecx, DWORD PTR _dwItemId$[esp+8]
  00095	89 08		 mov	 DWORD PTR [eax], ecx
  00097	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0009a	03 c3		 add	 eax, ebx
  0009c	5f		 pop	 edi
  0009d	89 46 08	 mov	 DWORD PTR [esi+8], eax
  000a0	5e		 pop	 esi
  000a1	5b		 pop	 ebx
$L303641:

; 1068 : }

  000a2	c2 0c 00	 ret	 12			; 0000000cH
?AddChangeBankPass@CUser@@QAEXHKK@Z ENDP		; CUser::AddChangeBankPass
_TEXT	ENDS
PUBLIC	?AddconfirmBankPass@CUser@@QAEXHKK@Z		; CUser::AddconfirmBankPass
; Function compile flags: /Ogty
;	COMDAT ?AddconfirmBankPass@CUser@@QAEXHKK@Z
_TEXT	SEGMENT
_nMode$ = 8						; size = 4
_dwId$ = 12						; size = 4
_dwItemId$ = 16						; size = 4
?AddconfirmBankPass@CUser@@QAEXHKK@Z PROC NEAR		; CUser::AddconfirmBankPass, COMDAT
; _this$ = ecx

; 1072 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	0f 85 98 00 00
	00		 jne	 $L303675

; 1073 : 	
; 1074 : 	m_Snapshot.cb++;

  0000a	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  00011	53		 push	 ebx
  00012	56		 push	 esi
  00013	57		 push	 edi

; 1075 : 	m_Snapshot.ar << GetId();

  00014	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  0001a	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  00020	bb 04 00 00 00	 mov	 ebx, 4
  00025	53		 push	 ebx
  00026	8b ce		 mov	 ecx, esi
  00028	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0002d	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00030	89 38		 mov	 DWORD PTR [eax], edi
  00032	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00035	03 c3		 add	 eax, ebx

; 1076 : 	m_Snapshot.ar << SNAPSHOTTYPE_CONFIRMBANKPASS;

  00037	6a 02		 push	 2
  00039	8b ce		 mov	 ecx, esi
  0003b	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0003e	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00043	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00046	66 c7 01 58 00	 mov	 WORD PTR [ecx], 88	; 00000058H
  0004b	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0004e	83 c2 02	 add	 edx, 2

; 1077 : 	m_Snapshot.ar << nMode;

  00051	53		 push	 ebx
  00052	8b ce		 mov	 ecx, esi
  00054	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00057	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0005c	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0005f	8b 44 24 10	 mov	 eax, DWORD PTR _nMode$[esp+8]
  00063	89 02		 mov	 DWORD PTR [edx], eax
  00065	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00068	03 c3		 add	 eax, ebx

; 1078 : 	m_Snapshot.ar << dwId << dwItemId;

  0006a	53		 push	 ebx
  0006b	8b ce		 mov	 ecx, esi
  0006d	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00070	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00075	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00078	8b 54 24 14	 mov	 edx, DWORD PTR _dwId$[esp+8]
  0007c	89 11		 mov	 DWORD PTR [ecx], edx
  0007e	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00081	03 d3		 add	 edx, ebx
  00083	53		 push	 ebx
  00084	8b ce		 mov	 ecx, esi
  00086	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00089	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0008e	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00091	8b 4c 24 18	 mov	 ecx, DWORD PTR _dwItemId$[esp+8]
  00095	89 08		 mov	 DWORD PTR [eax], ecx
  00097	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0009a	03 c3		 add	 eax, ebx
  0009c	5f		 pop	 edi
  0009d	89 46 08	 mov	 DWORD PTR [esi+8], eax
  000a0	5e		 pop	 esi
  000a1	5b		 pop	 ebx
$L303675:

; 1079 : }

  000a2	c2 0c 00	 ret	 12			; 0000000cH
?AddconfirmBankPass@CUser@@QAEXHKK@Z ENDP		; CUser::AddconfirmBankPass
_TEXT	ENDS
PUBLIC	?AddUpdateItemEx@CUser@@QAEXED_J@Z		; CUser::AddUpdateItemEx
; Function compile flags: /Ogty
;	COMDAT ?AddUpdateItemEx@CUser@@QAEXED_J@Z
_TEXT	SEGMENT
$T303709 = -8						; size = 8
_id$ = 8						; size = 1
_cParam$ = 12						; size = 1
_iValue$ = 16						; size = 8
?AddUpdateItemEx@CUser@@QAEXED_J@Z PROC NEAR		; CUser::AddUpdateItemEx, COMDAT
; _this$ = ecx

; 1084 : 	if( IsDelete() )	return;

  00000	8a 41 04	 mov	 al, BYTE PTR [ecx+4]
  00003	83 ec 08	 sub	 esp, 8
  00006	a8 01		 test	 al, 1
  00008	0f 85 98 00 00
	00		 jne	 $L303708

; 1085 : 	
; 1086 : 	m_Snapshot.cb++;

  0000e	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  00015	56		 push	 esi
  00016	57		 push	 edi

; 1087 : 	m_Snapshot.ar << GetId();

  00017	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  0001d	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  00023	6a 04		 push	 4
  00025	8b ce		 mov	 ecx, esi
  00027	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0002c	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0002f	89 38		 mov	 DWORD PTR [eax], edi
  00031	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00034	83 c0 04	 add	 eax, 4

; 1088 : 	m_Snapshot.ar << SNAPSHOTTYPE_UPDATE_ITEM_EX;

  00037	6a 02		 push	 2
  00039	8b ce		 mov	 ecx, esi
  0003b	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0003e	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00043	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00046	66 c7 01 40 01	 mov	 WORD PTR [ecx], 320	; 00000140H
  0004b	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0004e	83 c2 02	 add	 edx, 2

; 1089 : 	m_Snapshot.ar << id << cParam << iValue;

  00051	6a 01		 push	 1
  00053	8b ce		 mov	 ecx, esi
  00055	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00058	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0005d	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00060	8a 44 24 14	 mov	 al, BYTE PTR _id$[esp+12]
  00064	88 02		 mov	 BYTE PTR [edx], al
  00066	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00069	40		 inc	 eax
  0006a	6a 01		 push	 1
  0006c	8b ce		 mov	 ecx, esi
  0006e	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00071	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00076	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00079	8a 54 24 18	 mov	 dl, BYTE PTR _cParam$[esp+12]
  0007d	8b 44 24 1c	 mov	 eax, DWORD PTR _iValue$[esp+12]
  00081	88 11		 mov	 BYTE PTR [ecx], dl
  00083	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00086	8b 4c 24 20	 mov	 ecx, DWORD PTR _iValue$[esp+16]
  0008a	42		 inc	 edx
  0008b	89 56 08	 mov	 DWORD PTR [esi+8], edx
  0008e	6a 08		 push	 8
  00090	8d 54 24 0c	 lea	 edx, DWORD PTR $T303709[esp+20]
  00094	89 4c 24 10	 mov	 DWORD PTR $T303709[esp+24], ecx
  00098	52		 push	 edx
  00099	8b ce		 mov	 ecx, esi
  0009b	89 44 24 10	 mov	 DWORD PTR $T303709[esp+24], eax
  0009f	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
  000a4	5f		 pop	 edi
  000a5	5e		 pop	 esi
$L303708:

; 1090 : }

  000a6	83 c4 08	 add	 esp, 8
  000a9	c2 10 00	 ret	 16			; 00000010H
?AddUpdateItemEx@CUser@@QAEXED_J@Z ENDP			; CUser::AddUpdateItemEx
_TEXT	ENDS
PUBLIC	?AddUpdateItem@CUser@@QAEXDEDKK@Z		; CUser::AddUpdateItem
; Function compile flags: /Ogty
;	COMDAT ?AddUpdateItem@CUser@@QAEXDEDKK@Z
_TEXT	SEGMENT
_cType$ = 8						; size = 1
_nId$ = 12						; size = 1
_cParam$ = 16						; size = 1
_dwValue$ = 20						; size = 4
_dwTime$ = 24						; size = 4
?AddUpdateItem@CUser@@QAEXDEDKK@Z PROC NEAR		; CUser::AddUpdateItem, COMDAT
; _this$ = ecx

; 1099 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	0f 85 c9 00 00
	00		 jne	 $L303752

; 1100 : 	
; 1101 : 	m_Snapshot.cb++;

  0000a	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  00011	56		 push	 esi
  00012	57		 push	 edi

; 1102 : 	m_Snapshot.ar << GetId();

  00013	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  00019	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  0001f	6a 04		 push	 4
  00021	8b ce		 mov	 ecx, esi
  00023	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00028	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0002b	89 38		 mov	 DWORD PTR [eax], edi
  0002d	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00030	83 c0 04	 add	 eax, 4

; 1103 : 	m_Snapshot.ar << SNAPSHOTTYPE_UPDATE_ITEM;

  00033	6a 02		 push	 2
  00035	8b ce		 mov	 ecx, esi
  00037	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0003a	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003f	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00042	66 c7 01 18 00	 mov	 WORD PTR [ecx], 24	; 00000018H
  00047	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0004a	83 c2 02	 add	 edx, 2

; 1104 : 	m_Snapshot.ar << cType << nId << cParam << dwValue;

  0004d	6a 01		 push	 1
  0004f	8b ce		 mov	 ecx, esi
  00051	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00054	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00059	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0005c	8a 44 24 0c	 mov	 al, BYTE PTR _cType$[esp+4]
  00060	88 02		 mov	 BYTE PTR [edx], al
  00062	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00065	40		 inc	 eax
  00066	6a 01		 push	 1
  00068	8b ce		 mov	 ecx, esi
  0006a	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0006d	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00072	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00075	8a 54 24 10	 mov	 dl, BYTE PTR _nId$[esp+4]
  00079	88 11		 mov	 BYTE PTR [ecx], dl
  0007b	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0007e	42		 inc	 edx
  0007f	6a 01		 push	 1
  00081	8b ce		 mov	 ecx, esi
  00083	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00086	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0008b	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0008e	8a 4c 24 14	 mov	 cl, BYTE PTR _cParam$[esp+4]
  00092	88 08		 mov	 BYTE PTR [eax], cl
  00094	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00097	40		 inc	 eax
  00098	6a 04		 push	 4
  0009a	8b ce		 mov	 ecx, esi
  0009c	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0009f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000a4	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  000a7	8b 44 24 18	 mov	 eax, DWORD PTR _dwValue$[esp+4]
  000ab	89 02		 mov	 DWORD PTR [edx], eax
  000ad	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  000b0	83 c2 04	 add	 edx, 4

; 1105 : #if __VER >= 15 // __PETVIS
; 1106 : 	m_Snapshot.ar << dwTime;

  000b3	6a 04		 push	 4
  000b5	8b ce		 mov	 ecx, esi
  000b7	89 56 08	 mov	 DWORD PTR [esi+8], edx
  000ba	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000bf	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  000c2	8b 54 24 1c	 mov	 edx, DWORD PTR _dwTime$[esp+4]
  000c6	89 11		 mov	 DWORD PTR [ecx], edx
  000c8	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000cb	83 c0 04	 add	 eax, 4
  000ce	5f		 pop	 edi
  000cf	89 46 08	 mov	 DWORD PTR [esi+8], eax
  000d2	5e		 pop	 esi
$L303752:

; 1107 : #endif // __PETVIS
; 1108 : }

  000d3	c2 14 00	 ret	 20			; 00000014H
?AddUpdateItem@CUser@@QAEXDEDKK@Z ENDP			; CUser::AddUpdateItem
_TEXT	ENDS
PUBLIC	?AddUpdateBankItem@CUser@@QAEXEEDK@Z		; CUser::AddUpdateBankItem
; Function compile flags: /Ogty
;	COMDAT ?AddUpdateBankItem@CUser@@QAEXEEDK@Z
_TEXT	SEGMENT
_nSlot$ = 8						; size = 1
_nId$ = 12						; size = 1
_cParam$ = 16						; size = 1
_dwValue$ = 20						; size = 4
?AddUpdateBankItem@CUser@@QAEXEEDK@Z PROC NEAR		; CUser::AddUpdateBankItem, COMDAT
; _this$ = ecx

; 1112 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	0f 85 ae 00 00
	00		 jne	 $L303789

; 1113 : 	
; 1114 : 	m_Snapshot.cb++;

  0000a	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  00011	56		 push	 esi
  00012	57		 push	 edi

; 1115 : 	m_Snapshot.ar << GetId();

  00013	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  00019	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  0001f	6a 04		 push	 4
  00021	8b ce		 mov	 ecx, esi
  00023	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00028	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0002b	89 38		 mov	 DWORD PTR [eax], edi
  0002d	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00030	83 c2 04	 add	 edx, 4

; 1116 : 	m_Snapshot.ar << SNAPSHOTTYPE_UPDATE_BANKITEM;

  00033	6a 02		 push	 2
  00035	8b ce		 mov	 ecx, esi
  00037	89 56 08	 mov	 DWORD PTR [esi+8], edx
  0003a	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003f	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00042	66 c7 01 54 00	 mov	 WORD PTR [ecx], 84	; 00000054H
  00047	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0004a	83 c0 02	 add	 eax, 2

; 1117 : 	m_Snapshot.ar << nSlot << nId << cParam << dwValue;

  0004d	6a 01		 push	 1
  0004f	8b ce		 mov	 ecx, esi
  00051	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00054	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00059	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0005c	8a 44 24 0c	 mov	 al, BYTE PTR _nSlot$[esp+4]
  00060	88 02		 mov	 BYTE PTR [edx], al
  00062	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00065	42		 inc	 edx
  00066	6a 01		 push	 1
  00068	8b ce		 mov	 ecx, esi
  0006a	89 56 08	 mov	 DWORD PTR [esi+8], edx
  0006d	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00072	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00075	8a 54 24 10	 mov	 dl, BYTE PTR _nId$[esp+4]
  00079	88 11		 mov	 BYTE PTR [ecx], dl
  0007b	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0007e	40		 inc	 eax
  0007f	6a 01		 push	 1
  00081	8b ce		 mov	 ecx, esi
  00083	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00086	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0008b	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0008e	8a 4c 24 14	 mov	 cl, BYTE PTR _cParam$[esp+4]
  00092	88 08		 mov	 BYTE PTR [eax], cl
  00094	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00097	42		 inc	 edx
  00098	6a 04		 push	 4
  0009a	8b ce		 mov	 ecx, esi
  0009c	89 56 08	 mov	 DWORD PTR [esi+8], edx
  0009f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000a4	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  000a7	8b 44 24 18	 mov	 eax, DWORD PTR _dwValue$[esp+4]
  000ab	89 02		 mov	 DWORD PTR [edx], eax
  000ad	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000b0	83 c0 04	 add	 eax, 4
  000b3	5f		 pop	 edi
  000b4	89 46 08	 mov	 DWORD PTR [esi+8], eax
  000b7	5e		 pop	 esi
$L303789:

; 1118 : }

  000b8	c2 10 00	 ret	 16			; 00000010H
?AddUpdateBankItem@CUser@@QAEXEEDK@Z ENDP		; CUser::AddUpdateBankItem
_TEXT	ENDS
PUBLIC	?AddSetExperience@CUser@@QAEX_JGHH0G@Z		; CUser::AddSetExperience
; Function compile flags: /Ogty
;	COMDAT ?AddSetExperience@CUser@@QAEX_JGHH0G@Z
_TEXT	SEGMENT
$T303812 = -8						; size = 8
$T303837 = 8						; size = 8
_nExp1$ = 8						; size = 8
_wLevel$ = 16						; size = 2
_nSkillPoint$ = 20					; size = 4
_nSkillLevel$ = 24					; size = 4
_nDeathExp$ = 28					; size = 8
_wDeathLevel$ = 36					; size = 2
?AddSetExperience@CUser@@QAEX_JGHH0G@Z PROC NEAR	; CUser::AddSetExperience, COMDAT
; _this$ = ecx

; 1122 : 	if( IsDelete() )	return;

  00000	8a 41 04	 mov	 al, BYTE PTR [ecx+4]
  00003	83 ec 08	 sub	 esp, 8
  00006	a8 01		 test	 al, 1
  00008	0f 85 e9 00 00
	00		 jne	 $L303840

; 1123 : 
; 1124 : 	m_Snapshot.cb++;

  0000e	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  00015	56		 push	 esi
  00016	57		 push	 edi

; 1125 : 	m_Snapshot.ar << GetId();

  00017	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  0001d	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  00023	6a 04		 push	 4
  00025	8b ce		 mov	 ecx, esi
  00027	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0002c	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0002f	89 38		 mov	 DWORD PTR [eax], edi
  00031	83 46 08 04	 add	 DWORD PTR [esi+8], 4

; 1126 : 	m_Snapshot.ar << SNAPSHOTTYPE_SETEXPERIENCE;

  00035	bf 02 00 00 00	 mov	 edi, 2
  0003a	57		 push	 edi
  0003b	8b ce		 mov	 ecx, esi
  0003d	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00042	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]

; 1127 : 	m_Snapshot.ar << nExp1 << wLevel;

  00045	8b 54 24 14	 mov	 edx, DWORD PTR _nExp1$[esp+12]
  00049	8b 44 24 18	 mov	 eax, DWORD PTR _nExp1$[esp+16]
  0004d	66 c7 01 12 00	 mov	 WORD PTR [ecx], 18	; 00000012H
  00052	01 7e 08	 add	 DWORD PTR [esi+8], edi
  00055	6a 08		 push	 8
  00057	8d 4c 24 0c	 lea	 ecx, DWORD PTR $T303812[esp+20]
  0005b	51		 push	 ecx
  0005c	8b ce		 mov	 ecx, esi
  0005e	89 54 24 10	 mov	 DWORD PTR $T303812[esp+24], edx
  00062	89 44 24 14	 mov	 DWORD PTR $T303812[esp+28], eax
  00066	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
  0006b	57		 push	 edi
  0006c	8b ce		 mov	 ecx, esi
  0006e	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00073	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00076	66 8b 44 24 1c	 mov	 ax, WORD PTR _wLevel$[esp+12]
  0007b	66 89 02	 mov	 WORD PTR [edx], ax
  0007e	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00081	03 d7		 add	 edx, edi

; 1128 : 	m_Snapshot.ar  << nSkillLevel << nSkillPoint;

  00083	6a 04		 push	 4
  00085	8b ce		 mov	 ecx, esi
  00087	89 56 08	 mov	 DWORD PTR [esi+8], edx
  0008a	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0008f	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00092	8b 54 24 24	 mov	 edx, DWORD PTR _nSkillLevel$[esp+12]
  00096	89 11		 mov	 DWORD PTR [ecx], edx
  00098	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0009b	83 c0 04	 add	 eax, 4
  0009e	6a 04		 push	 4
  000a0	8b ce		 mov	 ecx, esi
  000a2	89 46 08	 mov	 DWORD PTR [esi+8], eax
  000a5	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000aa	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000ad	8b 4c 24 20	 mov	 ecx, DWORD PTR _nSkillPoint$[esp+12]

; 1129 : 	m_Snapshot.ar << nDeathExp << wDeathLevel;

  000b1	8b 54 24 28	 mov	 edx, DWORD PTR _nDeathExp$[esp+12]
  000b5	89 08		 mov	 DWORD PTR [eax], ecx
  000b7	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  000ba	8b 44 24 2c	 mov	 eax, DWORD PTR _nDeathExp$[esp+16]
  000be	83 c1 04	 add	 ecx, 4
  000c1	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  000c4	6a 08		 push	 8
  000c6	8d 4c 24 18	 lea	 ecx, DWORD PTR $T303837[esp+16]
  000ca	51		 push	 ecx
  000cb	8b ce		 mov	 ecx, esi
  000cd	89 54 24 1c	 mov	 DWORD PTR $T303837[esp+20], edx
  000d1	89 44 24 20	 mov	 DWORD PTR $T303837[esp+24], eax
  000d5	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
  000da	57		 push	 edi
  000db	8b ce		 mov	 ecx, esi
  000dd	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000e2	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  000e5	66 8b 44 24 30	 mov	 ax, WORD PTR _wDeathLevel$[esp+12]
  000ea	66 89 02	 mov	 WORD PTR [edx], ax
  000ed	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000f0	03 c7		 add	 eax, edi
  000f2	5f		 pop	 edi
  000f3	89 46 08	 mov	 DWORD PTR [esi+8], eax
  000f6	5e		 pop	 esi
$L303840:

; 1130 : }

  000f7	83 c4 08	 add	 esp, 8
  000fa	c2 20 00	 ret	 32			; 00000020H
?AddSetExperience@CUser@@QAEX_JGHH0G@Z ENDP		; CUser::AddSetExperience
_TEXT	ENDS
PUBLIC	?AddSetStatLevel@CUser@@QAEXDJJ@Z		; CUser::AddSetStatLevel
; Function compile flags: /Ogty
;	COMDAT ?AddSetStatLevel@CUser@@QAEXDJJ@Z
_TEXT	SEGMENT
_chID$ = 8						; size = 1
_nValue$ = 12						; size = 4
_nRemainGP$ = 16					; size = 4
?AddSetStatLevel@CUser@@QAEXDJJ@Z PROC NEAR		; CUser::AddSetStatLevel, COMDAT
; _this$ = ecx

; 1154 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	0f 85 97 00 00
	00		 jne	 $L303873

; 1155 : 
; 1156 : 	m_Snapshot.cb++;

  0000a	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  00011	56		 push	 esi
  00012	57		 push	 edi

; 1157 : 	m_Snapshot.ar << GetId();

  00013	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  00019	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  0001f	6a 04		 push	 4
  00021	8b ce		 mov	 ecx, esi
  00023	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00028	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0002b	89 38		 mov	 DWORD PTR [eax], edi
  0002d	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00030	83 c0 04	 add	 eax, 4

; 1158 : 	m_Snapshot.ar << SNAPSHOTTYPE_SET_STAT_LEVEL;

  00033	6a 02		 push	 2
  00035	8b ce		 mov	 ecx, esi
  00037	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0003a	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003f	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00042	66 c7 01 a4 00	 mov	 WORD PTR [ecx], 164	; 000000a4H
  00047	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0004a	83 c2 02	 add	 edx, 2

; 1159 : 	m_Snapshot.ar << chID << nValue << nRemainGP;

  0004d	6a 01		 push	 1
  0004f	8b ce		 mov	 ecx, esi
  00051	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00054	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00059	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0005c	8a 44 24 0c	 mov	 al, BYTE PTR _chID$[esp+4]
  00060	88 02		 mov	 BYTE PTR [edx], al
  00062	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00065	40		 inc	 eax
  00066	6a 04		 push	 4
  00068	8b ce		 mov	 ecx, esi
  0006a	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0006d	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00072	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00075	8b 54 24 10	 mov	 edx, DWORD PTR _nValue$[esp+4]
  00079	89 11		 mov	 DWORD PTR [ecx], edx
  0007b	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0007e	83 c2 04	 add	 edx, 4
  00081	6a 04		 push	 4
  00083	8b ce		 mov	 ecx, esi
  00085	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00088	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0008d	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00090	8b 4c 24 14	 mov	 ecx, DWORD PTR _nRemainGP$[esp+4]
  00094	89 08		 mov	 DWORD PTR [eax], ecx
  00096	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00099	83 c0 04	 add	 eax, 4
  0009c	5f		 pop	 edi
  0009d	89 46 08	 mov	 DWORD PTR [esi+8], eax
  000a0	5e		 pop	 esi
$L303873:

; 1160 : }

  000a1	c2 0c 00	 ret	 12			; 0000000cH
?AddSetStatLevel@CUser@@QAEXDJJ@Z ENDP			; CUser::AddSetStatLevel
_TEXT	ENDS
PUBLIC	?AddSetChangeJob@CUser@@QAEXH@Z			; CUser::AddSetChangeJob
; Function compile flags: /Ogty
;	COMDAT ?AddSetChangeJob@CUser@@QAEXH@Z
_TEXT	SEGMENT
_dwJobLv$ = -160					; size = 160
_nJob$ = 8						; size = 4
?AddSetChangeJob@CUser@@QAEXH@Z PROC NEAR		; CUser::AddSetChangeJob, COMDAT
; _this$ = ecx

; 1163 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	81 ec a4 00 00
	00		 sub	 esp, 164		; 000000a4H
  0000c	53		 push	 ebx
  0000d	56		 push	 esi
  0000e	8b d9		 mov	 ebx, ecx
  00010	57		 push	 edi

; 1164 : 	DWORD dwJobLv[MAX_JOB] = {0, };

  00011	33 c0		 xor	 eax, eax
  00013	b9 27 00 00 00	 mov	 ecx, 39			; 00000027H
  00018	8d 7c 24 14	 lea	 edi, DWORD PTR _dwJobLv$[esp+180]
  0001c	c7 44 24 10 00
	00 00 00	 mov	 DWORD PTR _dwJobLv$[esp+176], 0
  00024	f3 ab		 rep stosd

; 1165 : 
; 1166 : 	if( IsDelete() )	return;

  00026	f6 43 04 01	 test	 BYTE PTR [ebx+4], 1
  0002a	0f 85 84 00 00
	00		 jne	 $L278394

; 1167 : 	m_Snapshot.cb++;

  00030	66 ff 83 0c 57
	00 00		 inc	 WORD PTR [ebx+22284]

; 1168 : 	m_Snapshot.ar << GetId();

  00037	8b bb bc 01 00
	00		 mov	 edi, DWORD PTR [ebx+444]
  0003d	8d b3 f8 16 00
	00		 lea	 esi, DWORD PTR [ebx+5880]
  00043	6a 04		 push	 4
  00045	8b ce		 mov	 ecx, esi
  00047	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0004c	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0004f	89 38		 mov	 DWORD PTR [eax], edi
  00051	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00054	bf 04 00 00 00	 mov	 edi, 4
  00059	03 cf		 add	 ecx, edi
  0005b	89 4e 08	 mov	 DWORD PTR [esi+8], ecx

; 1169 : 	m_Snapshot.ar << SNAPSHOTTYPE_SET_JOB_SKILL;

  0005e	6a 02		 push	 2
  00060	8b ce		 mov	 ecx, esi
  00062	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00067	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0006a	66 c7 01 a7 00	 mov	 WORD PTR [ecx], 167	; 000000a7H
  0006f	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00072	83 c2 02	 add	 edx, 2

; 1170 : 	m_Snapshot.ar << nJob;

  00075	57		 push	 edi
  00076	8b ce		 mov	 ecx, esi
  00078	89 56 08	 mov	 DWORD PTR [esi+8], edx
  0007b	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00080	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00083	8b 45 08	 mov	 eax, DWORD PTR _nJob$[ebp]
  00086	89 02		 mov	 DWORD PTR [edx], eax
  00088	8b 46 08	 mov	 eax, DWORD PTR [esi+8]

; 1171 : #ifdef __3RD_LEGEND16
; 1172 : 	m_Snapshot.ar.Write( (void*)&m_aJobSkill[0], sizeof(SKILL) *  ( MAX_JOB_SKILL + MAX_EXPERT_SKILL + MAX_PRO_SKILL + MAX_MASTER_SKILL + MAX_HERO_SKILL + MAX_LEGEND_HERO_SKILL ) );

  0008b	68 98 01 00 00	 push	 408			; 00000198H
  00090	03 c7		 add	 eax, edi
  00092	81 c3 6c 03 00
	00		 add	 ebx, 876		; 0000036cH
  00098	53		 push	 ebx
  00099	8b ce		 mov	 ecx, esi
  0009b	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0009e	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write

; 1173 : #else // __3RD_LEGEND16
; 1174 : #if __VER >= 10 // __LEGEND	//	10 	Neuz, World, Trans
; 1175 : 	m_Snapshot.ar.Write( (void*)&m_aJobSkill[0], sizeof(SKILL) *  ( MAX_JOB_SKILL + MAX_EXPERT_SKILL + MAX_PRO_SKILL + MAX_MASTER_SKILL + MAX_HERO_SKILL ) );
; 1176 : #else //__LEGEND	//	10 	Neuz, World, Trans
; 1177 : 	m_Snapshot.ar.Write( (void*)&m_aJobSkill[0], sizeof(SKILL) *  ( MAX_JOB_SKILL + MAX_EXPERT_SKILL + MAX_PRO_SKILL ) );
; 1178 : #endif	//__LEGEND	//	10 	Neuz, World, Trans
; 1179 : #endif // __3RD_LEGEND16
; 1180 : 	m_Snapshot.ar.Write( (void*)dwJobLv, sizeof(DWORD) * MAX_JOB );

  000a3	68 a0 00 00 00	 push	 160			; 000000a0H
  000a8	8d 4c 24 14	 lea	 ecx, DWORD PTR _dwJobLv$[esp+180]
  000ac	51		 push	 ecx
  000ad	8b ce		 mov	 ecx, esi
  000af	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
$L278394:

; 1181 : }

  000b4	5f		 pop	 edi
  000b5	5e		 pop	 esi
  000b6	5b		 pop	 ebx
  000b7	8b e5		 mov	 esp, ebp
  000b9	5d		 pop	 ebp
  000ba	c2 04 00	 ret	 4
?AddSetChangeJob@CUser@@QAEXH@Z ENDP			; CUser::AddSetChangeJob
_TEXT	ENDS
PUBLIC	?AddReturnSay@CUser@@QAEXHPBD@Z			; CUser::AddReturnSay
; Function compile flags: /Ogty
;	COMDAT ?AddReturnSay@CUser@@QAEXHPBD@Z
_TEXT	SEGMENT
_ReturnFlag$ = 8					; size = 4
_lpszPlayer$ = 12					; size = 4
?AddReturnSay@CUser@@QAEXHPBD@Z PROC NEAR		; CUser::AddReturnSay, COMDAT
; _this$ = ecx

; 1185 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	75 65		 jne	 SHORT $L278406

; 1186 : 	
; 1187 : 	m_Snapshot.cb++;

  00006	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  0000d	56		 push	 esi
  0000e	57		 push	 edi

; 1188 : 	m_Snapshot.ar << GetId();

  0000f	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  00015	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  0001b	6a 04		 push	 4
  0001d	8b ce		 mov	 ecx, esi
  0001f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00024	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00027	89 38		 mov	 DWORD PTR [eax], edi
  00029	83 46 08 04	 add	 DWORD PTR [esi+8], 4

; 1189 : 	m_Snapshot.ar << SNAPSHOTTYPE_RETURNSAY;

  0002d	6a 02		 push	 2
  0002f	8b ce		 mov	 ecx, esi
  00031	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00036	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00039	66 c7 01 a9 00	 mov	 WORD PTR [ecx], 169	; 000000a9H
  0003e	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  00041	83 c7 02	 add	 edi, 2

; 1190 : 	m_Snapshot.ar << ReturnFlag;

  00044	6a 04		 push	 4
  00046	8b ce		 mov	 ecx, esi
  00048	89 7e 08	 mov	 DWORD PTR [esi+8], edi
  0004b	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00050	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00053	8b 44 24 0c	 mov	 eax, DWORD PTR _ReturnFlag$[esp+4]
  00057	89 02		 mov	 DWORD PTR [edx], eax
  00059	83 46 08 04	 add	 DWORD PTR [esi+8], 4

; 1191 : 	m_Snapshot.ar.WriteString( lpszPlayer );

  0005d	8b 4c 24 10	 mov	 ecx, DWORD PTR _lpszPlayer$[esp+4]
  00061	51		 push	 ecx
  00062	8b ce		 mov	 ecx, esi
  00064	e8 00 00 00 00	 call	 ?WriteString@CAr@@QAEXPBD@Z ; CAr::WriteString
  00069	5f		 pop	 edi
  0006a	5e		 pop	 esi
$L278406:

; 1192 : 	
; 1193 : }

  0006b	c2 08 00	 ret	 8
?AddReturnSay@CUser@@QAEXHPBD@Z ENDP			; CUser::AddReturnSay
_TEXT	ENDS
PUBLIC	?AddSetPartyMemberParam@CUser@@QAEXKEH@Z	; CUser::AddSetPartyMemberParam
; Function compile flags: /Ogty
;	COMDAT ?AddSetPartyMemberParam@CUser@@QAEXKEH@Z
_TEXT	SEGMENT
_idPlayer$ = 8						; size = 4
_nParam$ = 12						; size = 1
_nVal$ = 16						; size = 4
?AddSetPartyMemberParam@CUser@@QAEXKEH@Z PROC NEAR	; CUser::AddSetPartyMemberParam, COMDAT
; _this$ = ecx

; 1245 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	0f 85 97 00 00
	00		 jne	 $L303957

; 1246 : 	
; 1247 : 	m_Snapshot.cb++;

  0000a	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  00011	56		 push	 esi
  00012	57		 push	 edi

; 1248 : 	m_Snapshot.ar << GetId();

  00013	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  00019	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  0001f	6a 04		 push	 4
  00021	8b ce		 mov	 ecx, esi
  00023	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00028	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0002b	89 38		 mov	 DWORD PTR [eax], edi
  0002d	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00030	83 c0 04	 add	 eax, 4

; 1249 : 	m_Snapshot.ar << SNAPSHOTTYPE_SET_PARTY_MEMBER_PARAM;

  00033	6a 02		 push	 2
  00035	8b ce		 mov	 ecx, esi
  00037	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0003a	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003f	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00042	66 c7 01 91 00	 mov	 WORD PTR [ecx], 145	; 00000091H
  00047	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0004a	83 c2 02	 add	 edx, 2

; 1250 : 	m_Snapshot.ar << idPlayer << nParam << nVal;

  0004d	6a 04		 push	 4
  0004f	8b ce		 mov	 ecx, esi
  00051	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00054	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00059	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0005c	8b 44 24 0c	 mov	 eax, DWORD PTR _idPlayer$[esp+4]
  00060	89 02		 mov	 DWORD PTR [edx], eax
  00062	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00065	83 c0 04	 add	 eax, 4
  00068	6a 01		 push	 1
  0006a	8b ce		 mov	 ecx, esi
  0006c	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0006f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00074	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00077	8a 54 24 10	 mov	 dl, BYTE PTR _nParam$[esp+4]
  0007b	88 11		 mov	 BYTE PTR [ecx], dl
  0007d	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00080	42		 inc	 edx
  00081	6a 04		 push	 4
  00083	8b ce		 mov	 ecx, esi
  00085	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00088	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0008d	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00090	8b 4c 24 14	 mov	 ecx, DWORD PTR _nVal$[esp+4]
  00094	89 08		 mov	 DWORD PTR [eax], ecx
  00096	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00099	83 c0 04	 add	 eax, 4
  0009c	5f		 pop	 edi
  0009d	89 46 08	 mov	 DWORD PTR [esi+8], eax
  000a0	5e		 pop	 esi
$L303957:

; 1251 : 	
; 1252 : }

  000a1	c2 0c 00	 ret	 12			; 0000000cH
?AddSetPartyMemberParam@CUser@@QAEXKEH@Z ENDP		; CUser::AddSetPartyMemberParam
_TEXT	ENDS
PUBLIC	?AddPartyMember@CUser@@QAEXPAVCParty@@KPBD1@Z	; CUser::AddPartyMember
EXTRN	?Serialize@CParty@@QAEXAAVCAr@@@Z:NEAR		; CParty::Serialize
; Function compile flags: /Ogty
;	COMDAT ?AddPartyMember@CUser@@QAEXPAVCParty@@KPBD1@Z
_TEXT	SEGMENT
_pParty$ = 8						; size = 4
_idPlayer$ = 12						; size = 4
_pszLeader$ = 16					; size = 4
_pszMember$ = 20					; size = 4
?AddPartyMember@CUser@@QAEXPAVCParty@@KPBD1@Z PROC NEAR	; CUser::AddPartyMember, COMDAT
; _this$ = ecx

; 1260 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	0f 85 c3 00 00
	00		 jne	 $L303997

; 1261 : 	
; 1262 : 	m_Snapshot.cb++;

  0000a	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  00011	53		 push	 ebx
  00012	56		 push	 esi
  00013	57		 push	 edi

; 1263 : 	m_Snapshot.ar << GetId();

  00014	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  0001a	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  00020	bb 04 00 00 00	 mov	 ebx, 4
  00025	53		 push	 ebx
  00026	8b ce		 mov	 ecx, esi
  00028	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0002d	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00030	89 38		 mov	 DWORD PTR [eax], edi
  00032	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00035	03 d3		 add	 edx, ebx

; 1264 : 	m_Snapshot.ar << SNAPSHOTTYPE_PARTYMEMBER;

  00037	6a 02		 push	 2
  00039	8b ce		 mov	 ecx, esi
  0003b	89 56 08	 mov	 DWORD PTR [esi+8], edx
  0003e	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00043	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00046	66 c7 01 82 00	 mov	 WORD PTR [ecx], 130	; 00000082H
  0004b	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0004e	83 c0 02	 add	 eax, 2

; 1265 : 	m_Snapshot.ar << idPlayer;

  00051	53		 push	 ebx
  00052	8b ce		 mov	 ecx, esi
  00054	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00057	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0005c	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0005f	8b 44 24 14	 mov	 eax, DWORD PTR _idPlayer$[esp+8]

; 1266 : #if __VER >= 11 // __SYS_PLAYER_DATA
; 1267 : 	m_Snapshot.ar.WriteString( pszLeader );

  00063	8b 4c 24 18	 mov	 ecx, DWORD PTR _pszLeader$[esp+8]
  00067	89 02		 mov	 DWORD PTR [edx], eax
  00069	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  0006c	51		 push	 ecx
  0006d	03 fb		 add	 edi, ebx
  0006f	8b ce		 mov	 ecx, esi
  00071	89 7e 08	 mov	 DWORD PTR [esi+8], edi
  00074	e8 00 00 00 00	 call	 ?WriteString@CAr@@QAEXPBD@Z ; CAr::WriteString

; 1268 : 	m_Snapshot.ar.WriteString( pszMember );

  00079	8b 54 24 1c	 mov	 edx, DWORD PTR _pszMember$[esp+8]
  0007d	52		 push	 edx
  0007e	8b ce		 mov	 ecx, esi
  00080	e8 00 00 00 00	 call	 ?WriteString@CAr@@QAEXPBD@Z ; CAr::WriteString

; 1269 : #endif	// __SYS_PLAYER_DATA
; 1270 : 	if( pParty )

  00085	8b 7c 24 10	 mov	 edi, DWORD PTR _pParty$[esp+8]
  00089	85 ff		 test	 edi, edi

; 1271 : 	{
; 1272 : 		m_Snapshot.ar << pParty->m_nSizeofMember;

  0008b	8b ce		 mov	 ecx, esi
  0008d	74 24		 je	 SHORT $L278453
  0008f	55		 push	 ebp
  00090	8b af cc 01 00
	00		 mov	 ebp, DWORD PTR [edi+460]
  00096	53		 push	 ebx
  00097	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0009c	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0009f	89 28		 mov	 DWORD PTR [eax], ebp
  000a1	01 5e 08	 add	 DWORD PTR [esi+8], ebx

; 1273 : 		pParty->Serialize( m_Snapshot.ar );

  000a4	56		 push	 esi
  000a5	8b cf		 mov	 ecx, edi
  000a7	e8 00 00 00 00	 call	 ?Serialize@CParty@@QAEXAAVCAr@@@Z ; CParty::Serialize
  000ac	5d		 pop	 ebp
  000ad	5f		 pop	 edi
  000ae	5e		 pop	 esi
  000af	5b		 pop	 ebx

; 1278 : 	}
; 1279 : 	
; 1280 : }

  000b0	c2 10 00	 ret	 16			; 00000010H
$L278453:

; 1274 : 	}
; 1275 : 	else
; 1276 : 	{
; 1277 : 		m_Snapshot.ar << (int)0;

  000b3	53		 push	 ebx
  000b4	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000b9	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  000bc	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  000c2	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000c5	03 c3		 add	 eax, ebx
  000c7	5f		 pop	 edi
  000c8	89 46 08	 mov	 DWORD PTR [esi+8], eax
  000cb	5e		 pop	 esi
  000cc	5b		 pop	 ebx
$L303997:

; 1278 : 	}
; 1279 : 	
; 1280 : }

  000cd	c2 10 00	 ret	 16			; 00000010H
?AddPartyMember@CUser@@QAEXPAVCParty@@KPBD1@Z ENDP	; CUser::AddPartyMember
_TEXT	ENDS
PUBLIC	?AddPartyExpLevel@CUser@@QAEXHHH@Z		; CUser::AddPartyExpLevel
; Function compile flags: /Ogty
;	COMDAT ?AddPartyExpLevel@CUser@@QAEXHHH@Z
_TEXT	SEGMENT
_Exp$ = 8						; size = 4
_Level$ = 12						; size = 4
_nPoint$ = 16						; size = 4
?AddPartyExpLevel@CUser@@QAEXHHH@Z PROC NEAR		; CUser::AddPartyExpLevel, COMDAT
; _this$ = ecx

; 1284 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	0f 85 98 00 00
	00		 jne	 $L304045

; 1285 : 	
; 1286 : 	m_Snapshot.cb++;

  0000a	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  00011	53		 push	 ebx
  00012	56		 push	 esi
  00013	57		 push	 edi

; 1287 : 	m_Snapshot.ar << GetId();

  00014	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  0001a	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  00020	bb 04 00 00 00	 mov	 ebx, 4
  00025	53		 push	 ebx
  00026	8b ce		 mov	 ecx, esi
  00028	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0002d	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00030	89 38		 mov	 DWORD PTR [eax], edi
  00032	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00035	03 c3		 add	 eax, ebx

; 1288 : 	m_Snapshot.ar << SNAPSHOTTYPE_PARTYEXP;

  00037	6a 02		 push	 2
  00039	8b ce		 mov	 ecx, esi
  0003b	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0003e	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00043	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00046	66 c7 01 85 00	 mov	 WORD PTR [ecx], 133	; 00000085H
  0004b	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0004e	83 c2 02	 add	 edx, 2

; 1289 : 	m_Snapshot.ar << Exp;

  00051	53		 push	 ebx
  00052	8b ce		 mov	 ecx, esi
  00054	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00057	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0005c	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0005f	8b 44 24 10	 mov	 eax, DWORD PTR _Exp$[esp+8]
  00063	89 02		 mov	 DWORD PTR [edx], eax
  00065	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00068	03 c3		 add	 eax, ebx

; 1290 : 	m_Snapshot.ar << Level;

  0006a	53		 push	 ebx
  0006b	8b ce		 mov	 ecx, esi
  0006d	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00070	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00075	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00078	8b 54 24 14	 mov	 edx, DWORD PTR _Level$[esp+8]
  0007c	89 11		 mov	 DWORD PTR [ecx], edx
  0007e	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00081	03 d3		 add	 edx, ebx

; 1291 : 	m_Snapshot.ar << nPoint;

  00083	53		 push	 ebx
  00084	8b ce		 mov	 ecx, esi
  00086	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00089	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0008e	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00091	8b 4c 24 18	 mov	 ecx, DWORD PTR _nPoint$[esp+8]
  00095	89 08		 mov	 DWORD PTR [eax], ecx
  00097	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0009a	03 c3		 add	 eax, ebx
  0009c	5f		 pop	 edi
  0009d	89 46 08	 mov	 DWORD PTR [esi+8], eax
  000a0	5e		 pop	 esi
  000a1	5b		 pop	 ebx
$L304045:

; 1292 : 	
; 1293 : }

  000a2	c2 0c 00	 ret	 12			; 0000000cH
?AddPartyExpLevel@CUser@@QAEXHHH@Z ENDP			; CUser::AddPartyExpLevel
_TEXT	ENDS
PUBLIC	?AddSetPartyMode@CUser@@QAEXHHJK@Z		; CUser::AddSetPartyMode
; Function compile flags: /Ogty
;	COMDAT ?AddSetPartyMode@CUser@@QAEXHHJK@Z
_TEXT	SEGMENT
_nMode$ = 8						; size = 4
_bOnOff$ = 12						; size = 4
_nPoint$ = 16						; size = 4
_dwSkillTime$ = 20					; size = 4
?AddSetPartyMode@CUser@@QAEXHHJK@Z PROC NEAR		; CUser::AddSetPartyMode, COMDAT
; _this$ = ecx

; 1300 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	0f 85 b1 00 00
	00		 jne	 $L304091

; 1301 : 	
; 1302 : 	m_Snapshot.cb++;

  0000a	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  00011	53		 push	 ebx

; 1303 : 	m_Snapshot.ar << GetId();

  00012	8b 99 bc 01 00
	00		 mov	 ebx, DWORD PTR [ecx+444]
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  00020	bf 04 00 00 00	 mov	 edi, 4
  00025	57		 push	 edi
  00026	8b ce		 mov	 ecx, esi
  00028	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0002d	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00030	89 18		 mov	 DWORD PTR [eax], ebx
  00032	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00035	03 d7		 add	 edx, edi

; 1304 : 	m_Snapshot.ar << SNAPSHOTTYPE_SETPARTYMODE;

  00037	6a 02		 push	 2
  00039	8b ce		 mov	 ecx, esi
  0003b	89 56 08	 mov	 DWORD PTR [esi+8], edx
  0003e	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00043	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00046	66 c7 01 8d 00	 mov	 WORD PTR [ecx], 141	; 0000008dH
  0004b	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0004e	83 c0 02	 add	 eax, 2

; 1305 : 	m_Snapshot.ar << nMode;

  00051	57		 push	 edi
  00052	8b ce		 mov	 ecx, esi
  00054	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00057	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0005c	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0005f	8b 44 24 10	 mov	 eax, DWORD PTR _nMode$[esp+8]
  00063	89 02		 mov	 DWORD PTR [edx], eax
  00065	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00068	03 d7		 add	 edx, edi

; 1306 : #if __VER >= 12 // __JHMA_VER12_1	//12 
; 1307 : 	m_Snapshot.ar << dwSkillTime;

  0006a	57		 push	 edi
  0006b	8b ce		 mov	 ecx, esi
  0006d	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00070	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00075	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00078	8b 54 24 1c	 mov	 edx, DWORD PTR _dwSkillTime$[esp+8]
  0007c	89 11		 mov	 DWORD PTR [ecx], edx
  0007e	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00081	03 c7		 add	 eax, edi

; 1308 : #endif // //12 
; 1309 : 	m_Snapshot.ar << bOnOff;

  00083	57		 push	 edi
  00084	8b ce		 mov	 ecx, esi
  00086	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00089	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0008e	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00091	8b 44 24 14	 mov	 eax, DWORD PTR _bOnOff$[esp+8]
  00095	89 01		 mov	 DWORD PTR [ecx], eax
  00097	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0009a	03 d7		 add	 edx, edi

; 1310 : 	if( bOnOff == TRUE )

  0009c	83 f8 01	 cmp	 eax, 1
  0009f	89 56 08	 mov	 DWORD PTR [esi+8], edx
  000a2	75 14		 jne	 SHORT $L304094

; 1311 : 	{
; 1312 : 		m_Snapshot.ar << nPoint;

  000a4	57		 push	 edi
  000a5	8b ce		 mov	 ecx, esi
  000a7	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000ac	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  000af	8b 44 24 18	 mov	 eax, DWORD PTR _nPoint$[esp+8]
  000b3	89 02		 mov	 DWORD PTR [edx], eax
  000b5	01 7e 08	 add	 DWORD PTR [esi+8], edi
$L304094:
  000b8	5f		 pop	 edi
  000b9	5e		 pop	 esi
  000ba	5b		 pop	 ebx
$L304091:

; 1313 : 	}
; 1314 : 	
; 1315 : }

  000bb	c2 10 00	 ret	 16			; 00000010H
?AddSetPartyMode@CUser@@QAEXHHJK@Z ENDP			; CUser::AddSetPartyMode
_TEXT	ENDS
PUBLIC	?AddPartyChangeItemMode@CUser@@QAEXH@Z		; CUser::AddPartyChangeItemMode
; Function compile flags: /Ogty
;	COMDAT ?AddPartyChangeItemMode@CUser@@QAEXH@Z
_TEXT	SEGMENT
_nItemMode$ = 8						; size = 4
?AddPartyChangeItemMode@CUser@@QAEXH@Z PROC NEAR	; CUser::AddPartyChangeItemMode, COMDAT
; _this$ = ecx

; 1319 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	75 63		 jne	 SHORT $L304118

; 1320 : 	
; 1321 : 	m_Snapshot.cb++;

  00006	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  0000d	56		 push	 esi
  0000e	57		 push	 edi

; 1322 : 	m_Snapshot.ar << GetId();

  0000f	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  00015	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  0001b	6a 04		 push	 4
  0001d	8b ce		 mov	 ecx, esi
  0001f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00024	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00027	89 38		 mov	 DWORD PTR [eax], edi
  00029	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0002c	83 c0 04	 add	 eax, 4

; 1323 : 	m_Snapshot.ar << SNAPSHOTTYPE_PARTYCHANGEITEMMODE;

  0002f	6a 02		 push	 2
  00031	8b ce		 mov	 ecx, esi
  00033	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00036	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003b	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003e	66 c7 01 8f 00	 mov	 WORD PTR [ecx], 143	; 0000008fH
  00043	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00046	83 c2 02	 add	 edx, 2

; 1324 : 	m_Snapshot.ar << nItemMode;

  00049	6a 04		 push	 4
  0004b	8b ce		 mov	 ecx, esi
  0004d	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00050	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00055	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00058	8b 44 24 0c	 mov	 eax, DWORD PTR _nItemMode$[esp+4]
  0005c	89 02		 mov	 DWORD PTR [edx], eax
  0005e	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00061	83 c0 04	 add	 eax, 4
  00064	5f		 pop	 edi
  00065	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00068	5e		 pop	 esi
$L304118:

; 1325 : 	
; 1326 : }

  00069	c2 04 00	 ret	 4
?AddPartyChangeItemMode@CUser@@QAEXH@Z ENDP		; CUser::AddPartyChangeItemMode
_TEXT	ENDS
PUBLIC	?AddPartyChangeExpMode@CUser@@QAEXH@Z		; CUser::AddPartyChangeExpMode
; Function compile flags: /Ogty
;	COMDAT ?AddPartyChangeExpMode@CUser@@QAEXH@Z
_TEXT	SEGMENT
_nExpMode$ = 8						; size = 4
?AddPartyChangeExpMode@CUser@@QAEXH@Z PROC NEAR		; CUser::AddPartyChangeExpMode, COMDAT
; _this$ = ecx

; 1330 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	75 63		 jne	 SHORT $L304148

; 1331 : 	
; 1332 : 	m_Snapshot.cb++;

  00006	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  0000d	56		 push	 esi
  0000e	57		 push	 edi

; 1333 : 	m_Snapshot.ar << GetId();

  0000f	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  00015	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  0001b	6a 04		 push	 4
  0001d	8b ce		 mov	 ecx, esi
  0001f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00024	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00027	89 38		 mov	 DWORD PTR [eax], edi
  00029	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0002c	83 c0 04	 add	 eax, 4

; 1334 : 	m_Snapshot.ar << SNAPSHOTTYPE_PARTYCHANGEEXPMODE;

  0002f	6a 02		 push	 2
  00031	8b ce		 mov	 ecx, esi
  00033	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00036	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003b	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003e	66 c7 01 90 00	 mov	 WORD PTR [ecx], 144	; 00000090H
  00043	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00046	83 c2 02	 add	 edx, 2

; 1335 : 	m_Snapshot.ar << nExpMode;

  00049	6a 04		 push	 4
  0004b	8b ce		 mov	 ecx, esi
  0004d	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00050	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00055	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00058	8b 44 24 0c	 mov	 eax, DWORD PTR _nExpMode$[esp+4]
  0005c	89 02		 mov	 DWORD PTR [edx], eax
  0005e	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00061	83 c0 04	 add	 eax, 4
  00064	5f		 pop	 edi
  00065	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00068	5e		 pop	 esi
$L304148:

; 1336 : 	
; 1337 : }

  00069	c2 04 00	 ret	 4
?AddPartyChangeExpMode@CUser@@QAEXH@Z ENDP		; CUser::AddPartyChangeExpMode
_TEXT	ENDS
PUBLIC	?AddPartyRequest@CUser@@QAEXPAV1@0H@Z		; CUser::AddPartyRequest
; Function compile flags: /Ogty
;	COMDAT ?AddPartyRequest@CUser@@QAEXPAV1@0H@Z
_TEXT	SEGMENT
$T304191 = 8						; size = 1
$T304171 = 8						; size = 1
_pLeader$ = 8						; size = 4
$T304200 = 12						; size = 4
$T304195 = 12						; size = 4
_pMember$ = 12						; size = 4
_bTroup$ = 16						; size = 4
?AddPartyRequest@CUser@@QAEXPAV1@0H@Z PROC NEAR		; CUser::AddPartyRequest, COMDAT
; _this$ = ecx

; 1364 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	0f 85 54 01 00
	00		 jne	 $L304215

; 1365 : 	
; 1366 : 	m_Snapshot.cb++;

  0000a	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  00011	53		 push	 ebx
  00012	55		 push	 ebp
  00013	56		 push	 esi
  00014	57		 push	 edi

; 1367 : 	m_Snapshot.ar << GetId();

  00015	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  0001b	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  00021	bb 04 00 00 00	 mov	 ebx, 4
  00026	53		 push	 ebx
  00027	8b ce		 mov	 ecx, esi
  00029	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0002e	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00031	89 38		 mov	 DWORD PTR [eax], edi
  00033	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  00036	03 fb		 add	 edi, ebx

; 1368 : 	m_Snapshot.ar << SNAPSHOTTYPE_PARTYREQEST;

  00038	6a 02		 push	 2
  0003a	8b ce		 mov	 ecx, esi
  0003c	89 7e 08	 mov	 DWORD PTR [esi+8], edi
  0003f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00044	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]

; 1369 : 	m_Snapshot.ar << pLeader->m_idPlayer << pLeader->m_nLevel << pLeader->m_nJob << pLeader->GetSex();

  00047	8b 7c 24 14	 mov	 edi, DWORD PTR _pLeader$[esp+12]
  0004b	66 c7 01 83 00	 mov	 WORD PTR [ecx], 131	; 00000083H
  00050	83 46 08 02	 add	 DWORD PTR [esi+8], 2
  00054	8a 97 20 06 00
	00		 mov	 dl, BYTE PTR [edi+1568]
  0005a	8b af 38 02 00
	00		 mov	 ebp, DWORD PTR [edi+568]
  00060	53		 push	 ebx
  00061	8b ce		 mov	 ecx, esi
  00063	88 54 24 18	 mov	 BYTE PTR $T304171[esp+16], dl
  00067	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0006c	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0006f	89 28		 mov	 DWORD PTR [eax], ebp
  00071	01 5e 08	 add	 DWORD PTR [esi+8], ebx
  00074	8b af e0 05 00
	00		 mov	 ebp, DWORD PTR [edi+1504]
  0007a	53		 push	 ebx
  0007b	8b ce		 mov	 ecx, esi
  0007d	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00082	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00085	89 29		 mov	 DWORD PTR [ecx], ebp
  00087	01 5e 08	 add	 DWORD PTR [esi+8], ebx
  0008a	8b af 44 06 00
	00		 mov	 ebp, DWORD PTR [edi+1604]
  00090	53		 push	 ebx
  00091	8b ce		 mov	 ecx, esi
  00093	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00098	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0009b	89 2a		 mov	 DWORD PTR [edx], ebp
  0009d	8b 6e 08	 mov	 ebp, DWORD PTR [esi+8]
  000a0	03 eb		 add	 ebp, ebx
  000a2	6a 01		 push	 1
  000a4	8b ce		 mov	 ecx, esi
  000a6	89 6e 08	 mov	 DWORD PTR [esi+8], ebp
  000a9	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000ae	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000b1	8a 4c 24 14	 mov	 cl, BYTE PTR $T304171[esp+12]

; 1370 : 	m_Snapshot.ar << pMember->m_idPlayer << pMember->m_nLevel << pMember->m_nJob << pMember->GetSex();

  000b5	8b 6c 24 18	 mov	 ebp, DWORD PTR _pMember$[esp+12]
  000b9	88 08		 mov	 BYTE PTR [eax], cl
  000bb	ff 46 08	 inc	 DWORD PTR [esi+8]
  000be	8a 95 20 06 00
	00		 mov	 dl, BYTE PTR [ebp+1568]
  000c4	8b 85 38 02 00
	00		 mov	 eax, DWORD PTR [ebp+568]
  000ca	53		 push	 ebx
  000cb	8b ce		 mov	 ecx, esi
  000cd	88 54 24 18	 mov	 BYTE PTR $T304191[esp+16], dl
  000d1	89 44 24 1c	 mov	 DWORD PTR $T304195[esp+16], eax
  000d5	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000da	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  000dd	8b 54 24 18	 mov	 edx, DWORD PTR $T304195[esp+12]
  000e1	89 11		 mov	 DWORD PTR [ecx], edx
  000e3	01 5e 08	 add	 DWORD PTR [esi+8], ebx
  000e6	8b 85 e0 05 00
	00		 mov	 eax, DWORD PTR [ebp+1504]
  000ec	89 44 24 18	 mov	 DWORD PTR $T304200[esp+12], eax
  000f0	53		 push	 ebx
  000f1	8b ce		 mov	 ecx, esi
  000f3	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000f8	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  000fb	8b 54 24 18	 mov	 edx, DWORD PTR $T304200[esp+12]
  000ff	89 11		 mov	 DWORD PTR [ecx], edx
  00101	01 5e 08	 add	 DWORD PTR [esi+8], ebx
  00104	8b ad 44 06 00
	00		 mov	 ebp, DWORD PTR [ebp+1604]
  0010a	53		 push	 ebx
  0010b	8b ce		 mov	 ecx, esi
  0010d	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00112	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00115	89 28		 mov	 DWORD PTR [eax], ebp
  00117	01 5e 08	 add	 DWORD PTR [esi+8], ebx
  0011a	6a 01		 push	 1
  0011c	8b ce		 mov	 ecx, esi
  0011e	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00123	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00126	8a 54 24 14	 mov	 dl, BYTE PTR $T304191[esp+12]
  0012a	88 11		 mov	 BYTE PTR [ecx], dl
  0012c	8b 6e 08	 mov	 ebp, DWORD PTR [esi+8]

; 1371 : 	m_Snapshot.ar.WriteString( pLeader->m_szName );

  0012f	81 c7 90 16 00
	00		 add	 edi, 5776		; 00001690H
  00135	45		 inc	 ebp
  00136	57		 push	 edi
  00137	8b ce		 mov	 ecx, esi
  00139	89 6e 08	 mov	 DWORD PTR [esi+8], ebp
  0013c	e8 00 00 00 00	 call	 ?WriteString@CAr@@QAEXPBD@Z ; CAr::WriteString

; 1372 : 	m_Snapshot.ar << bTroup;

  00141	53		 push	 ebx
  00142	8b ce		 mov	 ecx, esi
  00144	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00149	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0014c	8b 4c 24 1c	 mov	 ecx, DWORD PTR _bTroup$[esp+12]
  00150	89 08		 mov	 DWORD PTR [eax], ecx
  00152	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00155	03 c3		 add	 eax, ebx
  00157	5f		 pop	 edi
  00158	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0015b	5e		 pop	 esi
  0015c	5d		 pop	 ebp
  0015d	5b		 pop	 ebx
$L304215:

; 1373 : 	
; 1374 : }

  0015e	c2 0c 00	 ret	 12			; 0000000cH
?AddPartyRequest@CUser@@QAEXPAV1@0H@Z ENDP		; CUser::AddPartyRequest
_TEXT	ENDS
PUBLIC	?AddPartyRequestCancel@CUser@@QAEXKKH@Z		; CUser::AddPartyRequestCancel
; Function compile flags: /Ogty
;	COMDAT ?AddPartyRequestCancel@CUser@@QAEXKKH@Z
_TEXT	SEGMENT
_uLeaderid$ = 8						; size = 4
_uMemberid$ = 12					; size = 4
_nMode$ = 16						; size = 4
?AddPartyRequestCancel@CUser@@QAEXKKH@Z PROC NEAR	; CUser::AddPartyRequestCancel, COMDAT
; _this$ = ecx

; 1378 : 	// nMode
; 1379 : 	// 0 :  
; 1380 : 	// 1 :    
; 1381 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	0f 85 98 00 00
	00		 jne	 $L304249

; 1382 : 	
; 1383 : 	m_Snapshot.cb++;

  0000a	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  00011	53		 push	 ebx
  00012	56		 push	 esi
  00013	57		 push	 edi

; 1384 : 	m_Snapshot.ar << GetId();

  00014	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  0001a	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  00020	bb 04 00 00 00	 mov	 ebx, 4
  00025	53		 push	 ebx
  00026	8b ce		 mov	 ecx, esi
  00028	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0002d	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00030	89 38		 mov	 DWORD PTR [eax], edi
  00032	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00035	03 c3		 add	 eax, ebx

; 1385 : 	m_Snapshot.ar << SNAPSHOTTYPE_PARTYREQESTCANCEL;

  00037	6a 02		 push	 2
  00039	8b ce		 mov	 ecx, esi
  0003b	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0003e	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00043	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00046	66 c7 01 84 00	 mov	 WORD PTR [ecx], 132	; 00000084H
  0004b	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0004e	83 c2 02	 add	 edx, 2

; 1386 : 	m_Snapshot.ar << uLeaderid << uMemberid;

  00051	53		 push	 ebx
  00052	8b ce		 mov	 ecx, esi
  00054	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00057	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0005c	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0005f	8b 44 24 10	 mov	 eax, DWORD PTR _uLeaderid$[esp+8]
  00063	89 02		 mov	 DWORD PTR [edx], eax
  00065	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00068	03 c3		 add	 eax, ebx
  0006a	53		 push	 ebx
  0006b	8b ce		 mov	 ecx, esi
  0006d	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00070	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00075	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00078	8b 54 24 14	 mov	 edx, DWORD PTR _uMemberid$[esp+8]
  0007c	89 11		 mov	 DWORD PTR [ecx], edx
  0007e	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00081	03 d3		 add	 edx, ebx

; 1387 : 	m_Snapshot.ar << nMode;

  00083	53		 push	 ebx
  00084	8b ce		 mov	 ecx, esi
  00086	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00089	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0008e	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00091	8b 4c 24 18	 mov	 ecx, DWORD PTR _nMode$[esp+8]
  00095	89 08		 mov	 DWORD PTR [eax], ecx
  00097	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0009a	03 c3		 add	 eax, ebx
  0009c	5f		 pop	 edi
  0009d	89 46 08	 mov	 DWORD PTR [esi+8], eax
  000a0	5e		 pop	 esi
  000a1	5b		 pop	 ebx
$L304249:

; 1388 : 	
; 1389 : }

  000a2	c2 0c 00	 ret	 12			; 0000000cH
?AddPartyRequestCancel@CUser@@QAEXKKH@Z ENDP		; CUser::AddPartyRequestCancel
_TEXT	ENDS
PUBLIC	?AddCancelQuest@CUser@@QAEXK@Z			; CUser::AddCancelQuest
; Function compile flags: /Ogty
;	COMDAT ?AddCancelQuest@CUser@@QAEXK@Z
_TEXT	SEGMENT
_dwQuestCancelID$ = 8					; size = 4
?AddCancelQuest@CUser@@QAEXK@Z PROC NEAR		; CUser::AddCancelQuest, COMDAT
; _this$ = ecx

; 1453 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	75 7e		 jne	 SHORT $L304280

; 1454 : 	
; 1455 : 	m_Snapshot.cb++;

  00006	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  0000d	56		 push	 esi
  0000e	57		 push	 edi

; 1456 : 	m_Snapshot.ar << GetId();

  0000f	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  00015	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  0001b	6a 04		 push	 4
  0001d	8b ce		 mov	 ecx, esi
  0001f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00024	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00027	89 38		 mov	 DWORD PTR [eax], edi
  00029	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0002c	83 c2 04	 add	 edx, 4

; 1457 : 	m_Snapshot.ar << SNAPSHOTTYPE_REMOVEQUEST;

  0002f	6a 02		 push	 2
  00031	8b ce		 mov	 ecx, esi
  00033	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00036	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003b	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003e	66 c7 01 3a 00	 mov	 WORD PTR [ecx], 58	; 0000003aH
  00043	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00046	83 c0 02	 add	 eax, 2

; 1458 : 	m_Snapshot.ar << (int)-1 << dwQuestCancelID;

  00049	6a 04		 push	 4
  0004b	8b ce		 mov	 ecx, esi
  0004d	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00050	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00055	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00058	c7 02 ff ff ff
	ff		 mov	 DWORD PTR [edx], -1
  0005e	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00061	83 c2 04	 add	 edx, 4
  00064	6a 04		 push	 4
  00066	8b ce		 mov	 ecx, esi
  00068	89 56 08	 mov	 DWORD PTR [esi+8], edx
  0006b	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00070	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00073	8b 4c 24 0c	 mov	 ecx, DWORD PTR _dwQuestCancelID$[esp+4]
  00077	89 08		 mov	 DWORD PTR [eax], ecx
  00079	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0007c	83 c0 04	 add	 eax, 4
  0007f	5f		 pop	 edi
  00080	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00083	5e		 pop	 esi
$L304280:

; 1459 : 	
; 1460 : }

  00084	c2 04 00	 ret	 4
?AddCancelQuest@CUser@@QAEXK@Z ENDP			; CUser::AddCancelQuest
_TEXT	ENDS
PUBLIC	?AddRemoveQuest@CUser@@QAEXK@Z			; CUser::AddRemoveQuest
; Function compile flags: /Ogty
;	COMDAT ?AddRemoveQuest@CUser@@QAEXK@Z
_TEXT	SEGMENT
_dwQuestCancelID$ = 8					; size = 4
?AddRemoveQuest@CUser@@QAEXK@Z PROC NEAR		; CUser::AddRemoveQuest, COMDAT
; _this$ = ecx

; 1464 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	75 7e		 jne	 SHORT $L304310

; 1465 : 	
; 1466 : 	m_Snapshot.cb++;

  00006	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  0000d	56		 push	 esi
  0000e	57		 push	 edi

; 1467 : 	m_Snapshot.ar << GetId();

  0000f	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  00015	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  0001b	6a 04		 push	 4
  0001d	8b ce		 mov	 ecx, esi
  0001f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00024	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00027	89 38		 mov	 DWORD PTR [eax], edi
  00029	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0002c	83 c2 04	 add	 edx, 4

; 1468 : 	m_Snapshot.ar << SNAPSHOTTYPE_REMOVEQUEST;

  0002f	6a 02		 push	 2
  00031	8b ce		 mov	 ecx, esi
  00033	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00036	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003b	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003e	66 c7 01 3a 00	 mov	 WORD PTR [ecx], 58	; 0000003aH
  00043	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00046	83 c0 02	 add	 eax, 2

; 1469 : 	m_Snapshot.ar << (int)0 << dwQuestCancelID;

  00049	6a 04		 push	 4
  0004b	8b ce		 mov	 ecx, esi
  0004d	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00050	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00055	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00058	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0
  0005e	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00061	83 c2 04	 add	 edx, 4
  00064	6a 04		 push	 4
  00066	8b ce		 mov	 ecx, esi
  00068	89 56 08	 mov	 DWORD PTR [esi+8], edx
  0006b	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00070	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00073	8b 4c 24 0c	 mov	 ecx, DWORD PTR _dwQuestCancelID$[esp+4]
  00077	89 08		 mov	 DWORD PTR [eax], ecx
  00079	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0007c	83 c0 04	 add	 eax, 4
  0007f	5f		 pop	 edi
  00080	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00083	5e		 pop	 esi
$L304310:

; 1470 : 	
; 1471 : }

  00084	c2 04 00	 ret	 4
?AddRemoveQuest@CUser@@QAEXK@Z ENDP			; CUser::AddRemoveQuest
_TEXT	ENDS
PUBLIC	?AddRemoveAllQuest@CUser@@QAEXXZ		; CUser::AddRemoveAllQuest
; Function compile flags: /Ogty
;	COMDAT ?AddRemoveAllQuest@CUser@@QAEXXZ
_TEXT	SEGMENT
?AddRemoveAllQuest@CUser@@QAEXXZ PROC NEAR		; CUser::AddRemoveAllQuest, COMDAT
; _this$ = ecx

; 1475 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	75 7e		 jne	 SHORT $L304340

; 1476 : 	
; 1477 : 	m_Snapshot.cb++;

  00006	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  0000d	56		 push	 esi
  0000e	57		 push	 edi

; 1478 : 	m_Snapshot.ar << GetId();

  0000f	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  00015	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  0001b	6a 04		 push	 4
  0001d	8b ce		 mov	 ecx, esi
  0001f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00024	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00027	89 38		 mov	 DWORD PTR [eax], edi
  00029	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0002c	83 c2 04	 add	 edx, 4

; 1479 : 	m_Snapshot.ar << SNAPSHOTTYPE_REMOVEQUEST;

  0002f	6a 02		 push	 2
  00031	8b ce		 mov	 ecx, esi
  00033	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00036	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003b	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003e	66 c7 01 3a 00	 mov	 WORD PTR [ecx], 58	; 0000003aH
  00043	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00046	83 c0 02	 add	 eax, 2

; 1480 : 	m_Snapshot.ar << (int)1 << (DWORD)0;

  00049	6a 04		 push	 4
  0004b	8b ce		 mov	 ecx, esi
  0004d	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00050	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00055	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00058	c7 02 01 00 00
	00		 mov	 DWORD PTR [edx], 1
  0005e	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00061	83 c2 04	 add	 edx, 4
  00064	6a 04		 push	 4
  00066	8b ce		 mov	 ecx, esi
  00068	89 56 08	 mov	 DWORD PTR [esi+8], edx
  0006b	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00070	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00073	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00079	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0007c	83 c0 04	 add	 eax, 4
  0007f	5f		 pop	 edi
  00080	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00083	5e		 pop	 esi
$L304340:

; 1481 : 	
; 1482 : }

  00084	c3		 ret	 0
?AddRemoveAllQuest@CUser@@QAEXXZ ENDP			; CUser::AddRemoveAllQuest
_TEXT	ENDS
PUBLIC	?AddRemoveCompleteQuest@CUser@@QAEXXZ		; CUser::AddRemoveCompleteQuest
; Function compile flags: /Ogty
;	COMDAT ?AddRemoveCompleteQuest@CUser@@QAEXXZ
_TEXT	SEGMENT
?AddRemoveCompleteQuest@CUser@@QAEXXZ PROC NEAR		; CUser::AddRemoveCompleteQuest, COMDAT
; _this$ = ecx

; 1485 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	75 7e		 jne	 SHORT $L304370

; 1486 : 	
; 1487 : 	m_Snapshot.cb++;

  00006	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  0000d	56		 push	 esi
  0000e	57		 push	 edi

; 1488 : 	m_Snapshot.ar << GetId();

  0000f	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  00015	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  0001b	6a 04		 push	 4
  0001d	8b ce		 mov	 ecx, esi
  0001f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00024	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00027	89 38		 mov	 DWORD PTR [eax], edi
  00029	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0002c	83 c2 04	 add	 edx, 4

; 1489 : 	m_Snapshot.ar << SNAPSHOTTYPE_REMOVEQUEST;

  0002f	6a 02		 push	 2
  00031	8b ce		 mov	 ecx, esi
  00033	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00036	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003b	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003e	66 c7 01 3a 00	 mov	 WORD PTR [ecx], 58	; 0000003aH
  00043	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00046	83 c0 02	 add	 eax, 2

; 1490 : 	m_Snapshot.ar << (int)2 << (DWORD)0;

  00049	6a 04		 push	 4
  0004b	8b ce		 mov	 ecx, esi
  0004d	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00050	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00055	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00058	c7 02 02 00 00
	00		 mov	 DWORD PTR [edx], 2
  0005e	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00061	83 c2 04	 add	 edx, 4
  00064	6a 04		 push	 4
  00066	8b ce		 mov	 ecx, esi
  00068	89 56 08	 mov	 DWORD PTR [esi+8], edx
  0006b	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00070	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00073	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00079	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0007c	83 c0 04	 add	 eax, 4
  0007f	5f		 pop	 edi
  00080	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00083	5e		 pop	 esi
$L304370:

; 1491 : 	
; 1492 : }

  00084	c3		 ret	 0
?AddRemoveCompleteQuest@CUser@@QAEXXZ ENDP		; CUser::AddRemoveCompleteQuest
_TEXT	ENDS
PUBLIC	?AddEnvironmentSetting@CUser@@QAEXXZ		; CUser::AddEnvironmentSetting
EXTRN	?GetInstance@CEnvironment@@SAPAV1@XZ:NEAR	; CEnvironment::GetInstance
EXTRN	?GetSeason@CEnvironment@@QAEHXZ:NEAR		; CEnvironment::GetSeason
; Function compile flags: /Ogty
;	COMDAT ?AddEnvironmentSetting@CUser@@QAEXXZ
_TEXT	SEGMENT
?AddEnvironmentSetting@CUser@@QAEXXZ PROC NEAR		; CUser::AddEnvironmentSetting, COMDAT
; _this$ = ecx

; 1563 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	75 68		 jne	 SHORT $L304396

; 1564 : 
; 1565 : 	m_Snapshot.cb++;

  00006	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  0000d	56		 push	 esi
  0000e	57		 push	 edi

; 1566 : 	m_Snapshot.ar << GetId();

  0000f	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  00015	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  0001b	6a 04		 push	 4
  0001d	8b ce		 mov	 ecx, esi
  0001f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00024	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00027	89 38		 mov	 DWORD PTR [eax], edi
  00029	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0002c	83 c0 04	 add	 eax, 4

; 1567 : 	m_Snapshot.ar << SNAPSHOTTYPE_ENVIRONMENTALL;

  0002f	6a 02		 push	 2
  00031	8b ce		 mov	 ecx, esi
  00033	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00036	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003b	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003e	66 c7 01 63 00	 mov	 WORD PTR [ecx], 99	; 00000063H
  00043	83 46 08 02	 add	 DWORD PTR [esi+8], 2

; 1568 : 	m_Snapshot.ar << CEnvironment::GetInstance()->GetSeason();

  00047	e8 00 00 00 00	 call	 ?GetInstance@CEnvironment@@SAPAV1@XZ ; CEnvironment::GetInstance
  0004c	8b c8		 mov	 ecx, eax
  0004e	e8 00 00 00 00	 call	 ?GetSeason@CEnvironment@@QAEHXZ ; CEnvironment::GetSeason
  00053	6a 04		 push	 4
  00055	8b ce		 mov	 ecx, esi
  00057	8b f8		 mov	 edi, eax
  00059	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0005e	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00061	89 3a		 mov	 DWORD PTR [edx], edi
  00063	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00066	83 c0 04	 add	 eax, 4
  00069	5f		 pop	 edi
  0006a	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0006d	5e		 pop	 esi
$L304396:

; 1569 : }

  0006e	c3		 ret	 0
?AddEnvironmentSetting@CUser@@QAEXXZ ENDP		; CUser::AddEnvironmentSetting
_TEXT	ENDS
PUBLIC	?AddDuelStart@CUser@@QAEXKH@Z			; CUser::AddDuelStart
; Function compile flags: /Ogty
;	COMDAT ?AddDuelStart@CUser@@QAEXKH@Z
_TEXT	SEGMENT
_uidTarget$ = 8						; size = 4
_bStart$ = 12						; size = 4
?AddDuelStart@CUser@@QAEXKH@Z PROC NEAR			; CUser::AddDuelStart, COMDAT
; _this$ = ecx

; 1662 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	75 7e		 jne	 SHORT $L304428

; 1663 : 	
; 1664 : 	m_Snapshot.cb++;

  00006	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  0000d	56		 push	 esi
  0000e	57		 push	 edi

; 1665 : 	m_Snapshot.ar << GetId();

  0000f	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  00015	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  0001b	6a 04		 push	 4
  0001d	8b ce		 mov	 ecx, esi
  0001f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00024	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00027	89 38		 mov	 DWORD PTR [eax], edi
  00029	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0002c	83 c2 04	 add	 edx, 4

; 1666 : 	m_Snapshot.ar << SNAPSHOTTYPE_DUELSTART;

  0002f	6a 02		 push	 2
  00031	8b ce		 mov	 ecx, esi
  00033	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00036	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003b	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003e	66 c7 01 31 00	 mov	 WORD PTR [ecx], 49	; 00000031H
  00043	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00046	83 c0 02	 add	 eax, 2

; 1667 : 	m_Snapshot.ar << uidTarget;

  00049	6a 04		 push	 4
  0004b	8b ce		 mov	 ecx, esi
  0004d	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00050	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00055	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00058	8b 44 24 0c	 mov	 eax, DWORD PTR _uidTarget$[esp+4]
  0005c	89 02		 mov	 DWORD PTR [edx], eax
  0005e	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00061	83 c2 04	 add	 edx, 4

; 1668 : 	m_Snapshot.ar << bStart;

  00064	6a 04		 push	 4
  00066	8b ce		 mov	 ecx, esi
  00068	89 56 08	 mov	 DWORD PTR [esi+8], edx
  0006b	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00070	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00073	8b 54 24 10	 mov	 edx, DWORD PTR _bStart$[esp+4]
  00077	89 11		 mov	 DWORD PTR [ecx], edx
  00079	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0007c	83 c0 04	 add	 eax, 4
  0007f	5f		 pop	 edi
  00080	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00083	5e		 pop	 esi
$L304428:

; 1669 : 	
; 1670 : }

  00084	c2 08 00	 ret	 8
?AddDuelStart@CUser@@QAEXKH@Z ENDP			; CUser::AddDuelStart
_TEXT	ENDS
PUBLIC	?AddDuelCount@CUser@@QAEXH@Z			; CUser::AddDuelCount
; Function compile flags: /Ogty
;	COMDAT ?AddDuelCount@CUser@@QAEXH@Z
_TEXT	SEGMENT
_nCount$ = 8						; size = 4
?AddDuelCount@CUser@@QAEXH@Z PROC NEAR			; CUser::AddDuelCount, COMDAT
; _this$ = ecx

; 1674 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	75 63		 jne	 SHORT $L304455

; 1675 : 	
; 1676 : 	m_Snapshot.cb++;

  00006	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  0000d	56		 push	 esi
  0000e	57		 push	 edi

; 1677 : 	m_Snapshot.ar << GetId();

  0000f	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  00015	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  0001b	6a 04		 push	 4
  0001d	8b ce		 mov	 ecx, esi
  0001f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00024	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00027	89 38		 mov	 DWORD PTR [eax], edi
  00029	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0002c	83 c0 04	 add	 eax, 4

; 1678 : 	m_Snapshot.ar << SNAPSHOTTYPE_DUELCOUNT;

  0002f	6a 02		 push	 2
  00031	8b ce		 mov	 ecx, esi
  00033	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00036	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003b	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003e	66 c7 01 67 00	 mov	 WORD PTR [ecx], 103	; 00000067H
  00043	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00046	83 c2 02	 add	 edx, 2

; 1679 : 	m_Snapshot.ar << nCount;

  00049	6a 04		 push	 4
  0004b	8b ce		 mov	 ecx, esi
  0004d	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00050	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00055	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00058	8b 44 24 0c	 mov	 eax, DWORD PTR _nCount$[esp+4]
  0005c	89 02		 mov	 DWORD PTR [edx], eax
  0005e	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00061	83 c0 04	 add	 eax, 4
  00064	5f		 pop	 edi
  00065	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00068	5e		 pop	 esi
$L304455:

; 1680 : 	
; 1681 : }

  00069	c2 04 00	 ret	 4
?AddDuelCount@CUser@@QAEXH@Z ENDP			; CUser::AddDuelCount
_TEXT	ENDS
PUBLIC	?AddDuelPartyStart@CUser@@QAEXPBDHPAKKH@Z	; CUser::AddDuelPartyStart
; Function compile flags: /Ogty
;	COMDAT ?AddDuelPartyStart@CUser@@QAEXPBDHPAKKH@Z
_TEXT	SEGMENT
_szPartyName$ = 8					; size = 4
_nMax$ = 12						; size = 4
_pMembers$ = 16						; size = 4
_idParty$ = 20						; size = 4
_bFlag$ = 24						; size = 4
?AddDuelPartyStart@CUser@@QAEXPBDHPAKKH@Z PROC NEAR	; CUser::AddDuelPartyStart, COMDAT
; _this$ = ecx

; 1718 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	0f 85 cf 00 00
	00		 jne	 $L304500

; 1719 : 	
; 1720 : 	m_Snapshot.cb++;

  0000a	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  00011	53		 push	 ebx
  00012	55		 push	 ebp
  00013	56		 push	 esi
  00014	57		 push	 edi

; 1721 : 	m_Snapshot.ar << GetId();

  00015	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  0001b	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  00021	bd 04 00 00 00	 mov	 ebp, 4
  00026	55		 push	 ebp
  00027	8b ce		 mov	 ecx, esi
  00029	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0002e	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00031	89 38		 mov	 DWORD PTR [eax], edi
  00033	8b 5e 08	 mov	 ebx, DWORD PTR [esi+8]
  00036	03 dd		 add	 ebx, ebp

; 1722 : 	m_Snapshot.ar << SNAPSHOTTYPE_DUELPARTYSTART;

  00038	6a 02		 push	 2
  0003a	8b ce		 mov	 ecx, esi
  0003c	89 5e 08	 mov	 DWORD PTR [esi+8], ebx
  0003f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00044	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00047	66 c7 01 35 00	 mov	 WORD PTR [ecx], 53	; 00000035H
  0004c	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0004f	83 c2 02	 add	 edx, 2

; 1723 : 	m_Snapshot.ar << nMax;

  00052	55		 push	 ebp
  00053	8b ce		 mov	 ecx, esi
  00055	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00058	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0005d	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00060	8b 5c 24 18	 mov	 ebx, DWORD PTR _nMax$[esp+12]
  00064	89 1a		 mov	 DWORD PTR [edx], ebx
  00066	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00069	03 c5		 add	 eax, ebp

; 1724 : 	m_Snapshot.ar << idParty;

  0006b	55		 push	 ebp
  0006c	8b ce		 mov	 ecx, esi
  0006e	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00071	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00076	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00079	8b 4c 24 20	 mov	 ecx, DWORD PTR _idParty$[esp+12]
  0007d	89 08		 mov	 DWORD PTR [eax], ecx
  0007f	01 6e 08	 add	 DWORD PTR [esi+8], ebp

; 1725 : 	m_Snapshot.ar.WriteString( szPartyName );

  00082	8b 54 24 14	 mov	 edx, DWORD PTR _szPartyName$[esp+12]
  00086	52		 push	 edx
  00087	8b ce		 mov	 ecx, esi
  00089	e8 00 00 00 00	 call	 ?WriteString@CAr@@QAEXPBD@Z ; CAr::WriteString

; 1726 : 	for( int  i = 0; i < nMax; i ++ )

  0008e	33 ff		 xor	 edi, edi
  00090	85 db		 test	 ebx, ebx
  00092	7e 28		 jle	 SHORT $L278683
$L278681:

; 1727 : 		m_Snapshot.ar << pMembers[i];

  00094	8b 44 24 1c	 mov	 eax, DWORD PTR _pMembers$[esp+12]
  00098	8b 2c b8	 mov	 ebp, DWORD PTR [eax+edi*4]
  0009b	6a 04		 push	 4
  0009d	8b ce		 mov	 ecx, esi
  0009f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000a4	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  000a7	89 29		 mov	 DWORD PTR [ecx], ebp
  000a9	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  000ac	83 c2 04	 add	 edx, 4
  000af	47		 inc	 edi
  000b0	3b fb		 cmp	 edi, ebx
  000b2	89 56 08	 mov	 DWORD PTR [esi+8], edx
  000b5	7c dd		 jl	 SHORT $L278681

; 1726 : 	for( int  i = 0; i < nMax; i ++ )

  000b7	bd 04 00 00 00	 mov	 ebp, 4
$L278683:

; 1728 : 	m_Snapshot.ar << bFlag;

  000bc	55		 push	 ebp
  000bd	8b ce		 mov	 ecx, esi
  000bf	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000c4	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  000c7	8b 44 24 24	 mov	 eax, DWORD PTR _bFlag$[esp+12]
  000cb	89 02		 mov	 DWORD PTR [edx], eax
  000cd	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000d0	03 c5		 add	 eax, ebp
  000d2	5f		 pop	 edi
  000d3	89 46 08	 mov	 DWORD PTR [esi+8], eax
  000d6	5e		 pop	 esi
  000d7	5d		 pop	 ebp
  000d8	5b		 pop	 ebx
$L304500:

; 1729 : 	
; 1730 : }

  000d9	c2 14 00	 ret	 20			; 00000014H
?AddDuelPartyStart@CUser@@QAEXPBDHPAKKH@Z ENDP		; CUser::AddDuelPartyStart
_TEXT	ENDS
PUBLIC	?AddDuelPartyCancel@CUser@@QAEXPAVCParty@@@Z	; CUser::AddDuelPartyCancel
; Function compile flags: /Ogty
;	COMDAT ?AddDuelPartyCancel@CUser@@QAEXPAVCParty@@@Z
_TEXT	SEGMENT
_pDuelOther$ = 8					; size = 4
?AddDuelPartyCancel@CUser@@QAEXPAVCParty@@@Z PROC NEAR	; CUser::AddDuelPartyCancel, COMDAT
; _this$ = ecx

; 1745 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	0f 85 9a 00 00
	00		 jne	 $L304546

; 1746 : 	
; 1747 : 	m_Snapshot.cb++;

  0000a	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  00011	55		 push	 ebp
  00012	56		 push	 esi
  00013	57		 push	 edi

; 1748 : 	m_Snapshot.ar << GetId();

  00014	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  0001a	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  00020	bd 04 00 00 00	 mov	 ebp, 4
  00025	55		 push	 ebp
  00026	8b ce		 mov	 ecx, esi
  00028	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0002d	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00030	89 38		 mov	 DWORD PTR [eax], edi
  00032	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  00035	03 fd		 add	 edi, ebp

; 1749 : 	m_Snapshot.ar << SNAPSHOTTYPE_DUELPARTYCANCEL;

  00037	6a 02		 push	 2
  00039	8b ce		 mov	 ecx, esi
  0003b	89 7e 08	 mov	 DWORD PTR [esi+8], edi
  0003e	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00043	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]

; 1750 : 
; 1751 : 	if( pDuelOther )

  00046	8b 7c 24 10	 mov	 edi, DWORD PTR _pDuelOther$[esp+8]
  0004a	66 c7 01 37 00	 mov	 WORD PTR [ecx], 55	; 00000037H
  0004f	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00052	83 c1 02	 add	 ecx, 2
  00055	85 ff		 test	 edi, edi
  00057	89 4e 08	 mov	 DWORD PTR [esi+8], ecx

; 1752 : 	{
; 1753 : 		int		i, nSize = pDuelOther->GetSizeofMember();	//  
; 1754 : 		m_Snapshot.ar << nSize;

  0005a	8b ce		 mov	 ecx, esi
  0005c	74 49		 je	 SHORT $L278696
  0005e	53		 push	 ebx
  0005f	8b 9f cc 01 00
	00		 mov	 ebx, DWORD PTR [edi+460]
  00065	55		 push	 ebp
  00066	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0006b	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0006e	89 1a		 mov	 DWORD PTR [edx], ebx
  00070	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00073	03 cd		 add	 ecx, ebp

; 1755 : 		for( i = 0; i < nSize; i ++ )	

  00075	85 db		 test	 ebx, ebx
  00077	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  0007a	7e 24		 jle	 SHORT $L304553
  0007c	83 c7 28	 add	 edi, 40			; 00000028H
  0007f	8b eb		 mov	 ebp, ebx
$L278699:

; 1756 : 		{
; 1757 : 			m_Snapshot.ar << pDuelOther->m_aMember[i].m_uPlayerId;		//   .

  00081	8b 1f		 mov	 ebx, DWORD PTR [edi]
  00083	6a 04		 push	 4
  00085	8b ce		 mov	 ecx, esi
  00087	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0008c	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0008f	89 18		 mov	 DWORD PTR [eax], ebx
  00091	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00094	83 c2 04	 add	 edx, 4
  00097	83 c7 1c	 add	 edi, 28			; 0000001cH
  0009a	4d		 dec	 ebp
  0009b	89 56 08	 mov	 DWORD PTR [esi+8], edx
  0009e	75 e1		 jne	 SHORT $L278699
$L304553:
  000a0	5b		 pop	 ebx
  000a1	5f		 pop	 edi
  000a2	5e		 pop	 esi
  000a3	5d		 pop	 ebp

; 1758 : 		}
; 1759 : 	}
; 1760 : 	else
; 1761 : 	{
; 1762 : 		m_Snapshot.ar << 0;

$L304546:

; 1763 : 	}
; 1764 : 	
; 1765 : }

  000a4	c2 04 00	 ret	 4
$L278696:

; 1758 : 		}
; 1759 : 	}
; 1760 : 	else
; 1761 : 	{
; 1762 : 		m_Snapshot.ar << 0;

  000a7	55		 push	 ebp
  000a8	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000ad	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  000b0	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  000b6	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000b9	03 c5		 add	 eax, ebp
  000bb	5f		 pop	 edi
  000bc	89 46 08	 mov	 DWORD PTR [esi+8], eax
  000bf	5e		 pop	 esi
  000c0	5d		 pop	 ebp

; 1763 : 	}
; 1764 : 	
; 1765 : }

  000c1	c2 04 00	 ret	 4
?AddDuelPartyCancel@CUser@@QAEXPAVCParty@@@Z ENDP	; CUser::AddDuelPartyCancel
_TEXT	ENDS
PUBLIC	?AddDuelPartyResult@CUser@@QAEXPAVCParty@@H@Z	; CUser::AddDuelPartyResult
; Function compile flags: /Ogty
;	COMDAT ?AddDuelPartyResult@CUser@@QAEXPAVCParty@@H@Z
_TEXT	SEGMENT
_pDuelOther$ = 8					; size = 4
_bWin$ = 12						; size = 4
?AddDuelPartyResult@CUser@@QAEXPAVCParty@@H@Z PROC NEAR	; CUser::AddDuelPartyResult, COMDAT
; _this$ = ecx

; 1769 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	0f 85 aa 00 00
	00		 jne	 $L278714

; 1770 : 
; 1771 : 	
; 1772 : 	m_Snapshot.cb++;

  0000a	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  00011	53		 push	 ebx
  00012	55		 push	 ebp
  00013	56		 push	 esi
  00014	57		 push	 edi

; 1773 : 	m_Snapshot.ar << GetId();

  00015	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  0001b	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  00021	bd 04 00 00 00	 mov	 ebp, 4
  00026	55		 push	 ebp
  00027	8b ce		 mov	 ecx, esi
  00029	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0002e	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00031	89 38		 mov	 DWORD PTR [eax], edi
  00033	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00036	03 d5		 add	 edx, ebp

; 1774 : 	m_Snapshot.ar << SNAPSHOTTYPE_DUELPARTYRESULT;

  00038	6a 02		 push	 2
  0003a	8b ce		 mov	 ecx, esi
  0003c	89 56 08	 mov	 DWORD PTR [esi+8], edx
  0003f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00044	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00047	66 c7 01 38 00	 mov	 WORD PTR [ecx], 56	; 00000038H
  0004c	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0004f	83 c0 02	 add	 eax, 2

; 1775 : 	m_Snapshot.ar << bWin;

  00052	55		 push	 ebp
  00053	8b ce		 mov	 ecx, esi
  00055	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00058	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0005d	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00060	8b 44 24 18	 mov	 eax, DWORD PTR _bWin$[esp+12]
  00064	89 02		 mov	 DWORD PTR [edx], eax
  00066	01 6e 08	 add	 DWORD PTR [esi+8], ebp

; 1776 : 
; 1777 : 	int		i, nSize = pDuelOther->GetSizeofMember();	//  

  00069	8b 7c 24 14	 mov	 edi, DWORD PTR _pDuelOther$[esp+12]
  0006d	8b 9f cc 01 00
	00		 mov	 ebx, DWORD PTR [edi+460]

; 1778 : 	m_Snapshot.ar << nSize;

  00073	55		 push	 ebp
  00074	8b ce		 mov	 ecx, esi
  00076	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0007b	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0007e	89 19		 mov	 DWORD PTR [ecx], ebx
  00080	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00083	03 cd		 add	 ecx, ebp

; 1779 : 	for( i = 0; i < nSize; i ++ )	

  00085	85 db		 test	 ebx, ebx
  00087	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  0008a	7e 24		 jle	 SHORT $L304600
  0008c	83 c7 28	 add	 edi, 40			; 00000028H
  0008f	8b eb		 mov	 ebp, ebx
$L278712:

; 1780 : 	{
; 1781 : 		m_Snapshot.ar << pDuelOther->m_aMember[i].m_uPlayerId;		//   .

  00091	8b 1f		 mov	 ebx, DWORD PTR [edi]
  00093	6a 04		 push	 4
  00095	8b ce		 mov	 ecx, esi
  00097	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0009c	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0009f	89 1a		 mov	 DWORD PTR [edx], ebx
  000a1	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  000a4	83 c2 04	 add	 edx, 4
  000a7	83 c7 1c	 add	 edi, 28			; 0000001cH
  000aa	4d		 dec	 ebp
  000ab	89 56 08	 mov	 DWORD PTR [esi+8], edx
  000ae	75 e1		 jne	 SHORT $L278712
$L304600:
  000b0	5f		 pop	 edi
  000b1	5e		 pop	 esi
  000b2	5d		 pop	 ebp
  000b3	5b		 pop	 ebx
$L278714:

; 1782 : 	}
; 1783 : 	
; 1784 : 	
; 1785 : }

  000b4	c2 08 00	 ret	 8
?AddDuelPartyResult@CUser@@QAEXPAVCParty@@H@Z ENDP	; CUser::AddDuelPartyResult
_TEXT	ENDS
PUBLIC	?AddQueryPlayerData@CUser@@QAEXKPAU_PlayerData@@@Z ; CUser::AddQueryPlayerData
; Function compile flags: /Ogty
;	COMDAT ?AddQueryPlayerData@CUser@@QAEXKPAU_PlayerData@@@Z
_TEXT	SEGMENT
_idPlayer$ = 8						; size = 4
_pPlayerData$ = 12					; size = 4
?AddQueryPlayerData@CUser@@QAEXKPAU_PlayerData@@@Z PROC NEAR ; CUser::AddQueryPlayerData, COMDAT
; _this$ = ecx

; 1790 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	75 76		 jne	 SHORT $L278719

; 1791 : 	m_Snapshot.cb++;

  00006	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  0000d	56		 push	 esi
  0000e	57		 push	 edi

; 1792 : 	m_Snapshot.ar << NULL_ID;

  0000f	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  00015	bf 04 00 00 00	 mov	 edi, 4
  0001a	57		 push	 edi
  0001b	8b ce		 mov	 ecx, esi
  0001d	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00022	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00025	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [eax], -1
  0002b	01 7e 08	 add	 DWORD PTR [esi+8], edi

; 1793 : 	m_Snapshot.ar << SNAPSHOTTYPE_QUERY_PLAYER_DATA;

  0002e	6a 02		 push	 2
  00030	8b ce		 mov	 ecx, esi
  00032	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00037	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003a	66 c7 01 41 01	 mov	 WORD PTR [ecx], 321	; 00000141H
  0003f	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00042	83 c2 02	 add	 edx, 2

; 1794 : 	m_Snapshot.ar << idPlayer;

  00045	57		 push	 edi
  00046	8b ce		 mov	 ecx, esi
  00048	89 56 08	 mov	 DWORD PTR [esi+8], edx
  0004b	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00050	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00053	8b 44 24 0c	 mov	 eax, DWORD PTR _idPlayer$[esp+4]
  00057	89 02		 mov	 DWORD PTR [edx], eax
  00059	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0005c	03 c7		 add	 eax, edi

; 1795 : 	m_Snapshot.ar.WriteString( pPlayerData->szPlayer );

  0005e	8b 7c 24 10	 mov	 edi, DWORD PTR _pPlayerData$[esp+4]
  00062	8d 4f 0c	 lea	 ecx, DWORD PTR [edi+12]
  00065	51		 push	 ecx
  00066	8b ce		 mov	 ecx, esi
  00068	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0006b	e8 00 00 00 00	 call	 ?WriteString@CAr@@QAEXPBD@Z ; CAr::WriteString

; 1796 : 	m_Snapshot.ar.Write( &pPlayerData->data, sizeof(sPlayerData) );

  00070	6a 0c		 push	 12			; 0000000cH
  00072	57		 push	 edi
  00073	8b ce		 mov	 ecx, esi
  00075	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
  0007a	5f		 pop	 edi
  0007b	5e		 pop	 esi
$L278719:

; 1797 : }

  0007c	c2 08 00	 ret	 8
?AddQueryPlayerData@CUser@@QAEXKPAU_PlayerData@@@Z ENDP	; CUser::AddQueryPlayerData
_TEXT	ENDS
PUBLIC	?AddGuildInvite@CUser@@QAEXKK@Z			; CUser::AddGuildInvite
; Function compile flags: /Ogty
;	COMDAT ?AddGuildInvite@CUser@@QAEXKK@Z
_TEXT	SEGMENT
_idGuild$ = 8						; size = 4
_idMaster$ = 12						; size = 4
?AddGuildInvite@CUser@@QAEXKK@Z PROC NEAR		; CUser::AddGuildInvite, COMDAT
; _this$ = ecx

; 1899 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	75 70		 jne	 SHORT $L304654

; 1900 : 	
; 1901 : 	m_Snapshot.cb++;

  00006	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  0000d	56		 push	 esi

; 1902 : 	m_Snapshot.ar << NULL_ID;

  0000e	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  00014	6a 04		 push	 4
  00016	8b ce		 mov	 ecx, esi
  00018	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0001d	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00020	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [eax], -1
  00026	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00029	83 c0 04	 add	 eax, 4

; 1903 : 	m_Snapshot.ar << SNAPSHOTTYPE_GUILD_INVITE;

  0002c	6a 02		 push	 2
  0002e	8b ce		 mov	 ecx, esi
  00030	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00033	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00038	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003b	66 c7 01 9a 00	 mov	 WORD PTR [ecx], 154	; 0000009aH
  00040	83 46 08 02	 add	 DWORD PTR [esi+8], 2

; 1904 : 	m_Snapshot.ar << idGuild;

  00044	6a 04		 push	 4
  00046	8b ce		 mov	 ecx, esi
  00048	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0004d	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00050	8b 44 24 08	 mov	 eax, DWORD PTR _idGuild$[esp]
  00054	89 02		 mov	 DWORD PTR [edx], eax
  00056	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00059	83 c2 04	 add	 edx, 4

; 1905 : 	m_Snapshot.ar << idMaster;

  0005c	6a 04		 push	 4
  0005e	8b ce		 mov	 ecx, esi
  00060	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00063	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00068	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0006b	8b 54 24 0c	 mov	 edx, DWORD PTR _idMaster$[esp]
  0006f	89 11		 mov	 DWORD PTR [ecx], edx
  00071	83 46 08 04	 add	 DWORD PTR [esi+8], 4
  00075	5e		 pop	 esi
$L304654:

; 1906 : 	
; 1907 : }

  00076	c2 08 00	 ret	 8
?AddGuildInvite@CUser@@QAEXKK@Z ENDP			; CUser::AddGuildInvite
_TEXT	ENDS
PUBLIC	?AddAllGuilds@CUser@@QAEXXZ			; CUser::AddAllGuilds
EXTRN	?g_GuildMng@@3VCGuildMng@@A:BYTE		; g_GuildMng
EXTRN	?Serialize@CGuildMng@@QAEXAAVCAr@@H@Z:NEAR	; CGuildMng::Serialize
; Function compile flags: /Ogty
;	COMDAT ?AddAllGuilds@CUser@@QAEXXZ
_TEXT	SEGMENT
?AddAllGuilds@CUser@@QAEXXZ PROC NEAR			; CUser::AddAllGuilds, COMDAT
; _this$ = ecx

; 1911 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	75 4c		 jne	 SHORT $L278887

; 1912 : 	
; 1913 : 	m_Snapshot.cb++;

  00006	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  0000d	56		 push	 esi

; 1914 : 	m_Snapshot.ar << NULL_ID;

  0000e	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  00014	6a 04		 push	 4
  00016	8b ce		 mov	 ecx, esi
  00018	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0001d	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00020	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [eax], -1
  00026	83 46 08 04	 add	 DWORD PTR [esi+8], 4

; 1915 : 	m_Snapshot.ar << SNAPSHOTTYPE_ALL_GUILDS;

  0002a	6a 02		 push	 2
  0002c	8b ce		 mov	 ecx, esi
  0002e	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00033	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00036	66 c7 01 9f 00	 mov	 WORD PTR [ecx], 159	; 0000009fH
  0003b	8b 56 08	 mov	 edx, DWORD PTR [esi+8]

; 1916 : 	g_GuildMng.Serialize( m_Snapshot.ar, TRUE );

  0003e	6a 01		 push	 1
  00040	83 c2 02	 add	 edx, 2
  00043	56		 push	 esi
  00044	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_GuildMng@@3VCGuildMng@@A
  00049	89 56 08	 mov	 DWORD PTR [esi+8], edx
  0004c	e8 00 00 00 00	 call	 ?Serialize@CGuildMng@@QAEXAAVCAr@@H@Z ; CGuildMng::Serialize
  00051	5e		 pop	 esi
$L278887:

; 1917 : 	
; 1918 : }

  00052	c3		 ret	 0
?AddAllGuilds@CUser@@QAEXXZ ENDP			; CUser::AddAllGuilds
_TEXT	ENDS
PUBLIC	?AddMyGuild@CUser@@QAEXXZ			; CUser::AddMyGuild
EXTRN	?Serialize@CGuild@@QAEXAAVCAr@@H@Z:NEAR		; CGuild::Serialize
; Function compile flags: /Ogty
;	COMDAT ?AddMyGuild@CUser@@QAEXXZ
_TEXT	SEGMENT
?AddMyGuild@CUser@@QAEXXZ PROC NEAR			; CUser::AddMyGuild, COMDAT
; _this$ = ecx

; 1921 : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1922 : 	if( IsDelete() )	return;

  00003	f6 46 04 01	 test	 BYTE PTR [esi+4], 1
  00007	75 70		 jne	 SHORT $L278893
  00009	57		 push	 edi

; 1923 : 
; 1924 : 	CGuild* pGuild	= GetGuild();

  0000a	e8 00 00 00 00	 call	 ?GetGuild@CMover@@QAEPAVCGuild@@XZ ; CMover::GetGuild
  0000f	8b f8		 mov	 edi, eax

; 1925 : 	if( !pGuild )

  00011	85 ff		 test	 edi, edi
  00013	74 63		 je	 SHORT $L304701

; 1926 : 		return;
; 1927 : 	
; 1928 : 	m_Snapshot.cb++;

  00015	66 ff 86 0c 57
	00 00		 inc	 WORD PTR [esi+22284]
  0001c	53		 push	 ebx

; 1929 : 	m_Snapshot.ar << NULL_ID;

  0001d	81 c6 f8 16 00
	00		 add	 esi, 5880		; 000016f8H
  00023	6a 04		 push	 4
  00025	8b ce		 mov	 ecx, esi
  00027	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0002c	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0002f	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [eax], -1
  00035	8b 5e 08	 mov	 ebx, DWORD PTR [esi+8]
  00038	83 c3 04	 add	 ebx, 4

; 1930 : 	m_Snapshot.ar << SNAPSHOTTYPE_GUILD;

  0003b	6a 02		 push	 2
  0003d	8b ce		 mov	 ecx, esi
  0003f	89 5e 08	 mov	 DWORD PTR [esi+8], ebx
  00042	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00047	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0004a	66 c7 01 9e 00	 mov	 WORD PTR [ecx], 158	; 0000009eH
  0004f	83 46 08 02	 add	 DWORD PTR [esi+8], 2

; 1931 : 	m_Snapshot.ar << pGuild->m_idGuild;

  00053	8b 5f 04	 mov	 ebx, DWORD PTR [edi+4]
  00056	6a 04		 push	 4
  00058	8b ce		 mov	 ecx, esi
  0005a	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0005f	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00062	89 1a		 mov	 DWORD PTR [edx], ebx
  00064	8b 56 08	 mov	 edx, DWORD PTR [esi+8]

; 1932 : 	pGuild->Serialize( m_Snapshot.ar, FALSE );

  00067	6a 00		 push	 0
  00069	83 c2 04	 add	 edx, 4
  0006c	56		 push	 esi
  0006d	8b cf		 mov	 ecx, edi
  0006f	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00072	e8 00 00 00 00	 call	 ?Serialize@CGuild@@QAEXAAVCAr@@H@Z ; CGuild::Serialize
  00077	5b		 pop	 ebx
$L304701:
  00078	5f		 pop	 edi
$L278893:
  00079	5e		 pop	 esi

; 1933 : }

  0007a	c3		 ret	 0
?AddMyGuild@CUser@@QAEXXZ ENDP				; CUser::AddMyGuild
_TEXT	ENDS
PUBLIC	?AddMyGuildWar@CUser@@QAEXXZ			; CUser::AddMyGuildWar
EXTRN	?GetWar@CMover@@QAEPAVCGuildWar@@XZ:NEAR	; CMover::GetWar
EXTRN	?Serialize@CGuildWar@@QAEXAAVCAr@@@Z:NEAR	; CGuildWar::Serialize
; Function compile flags: /Ogty
;	COMDAT ?AddMyGuildWar@CUser@@QAEXXZ
_TEXT	SEGMENT
?AddMyGuildWar@CUser@@QAEXXZ PROC NEAR			; CUser::AddMyGuildWar, COMDAT
; _this$ = ecx

; 1936 : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1937 : 	if( IsDelete() )	return;

  00003	f6 46 04 01	 test	 BYTE PTR [esi+4], 1
  00007	75 63		 jne	 SHORT $L278901
  00009	57		 push	 edi

; 1938 : 
; 1939 : 	CGuildWar* pWar	= GetWar();

  0000a	e8 00 00 00 00	 call	 ?GetWar@CMover@@QAEPAVCGuildWar@@XZ ; CMover::GetWar
  0000f	8b f8		 mov	 edi, eax

; 1940 : 	if( !pWar )

  00011	85 ff		 test	 edi, edi
  00013	74 56		 je	 SHORT $L304727

; 1941 : 		return;
; 1942 : 
; 1943 : 	
; 1944 : 	m_Snapshot.cb++;

  00015	66 ff 86 0c 57
	00 00		 inc	 WORD PTR [esi+22284]
  0001c	53		 push	 ebx

; 1945 : 	m_Snapshot.ar << NULL_ID;

  0001d	81 c6 f8 16 00
	00		 add	 esi, 5880		; 000016f8H
  00023	6a 04		 push	 4
  00025	8b ce		 mov	 ecx, esi
  00027	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0002c	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0002f	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [eax], -1
  00035	83 46 08 04	 add	 DWORD PTR [esi+8], 4

; 1946 : 	m_Snapshot.ar << SNAPSHOTTYPE_WAR;

  00039	6a 02		 push	 2
  0003b	8b ce		 mov	 ecx, esi
  0003d	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00042	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00045	66 c7 01 da 00	 mov	 WORD PTR [ecx], 218	; 000000daH
  0004a	83 46 08 02	 add	 DWORD PTR [esi+8], 2

; 1947 : 	m_Snapshot.ar << pWar->m_idWar;

  0004e	8b 1f		 mov	 ebx, DWORD PTR [edi]
  00050	6a 04		 push	 4
  00052	8b ce		 mov	 ecx, esi
  00054	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00059	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0005c	89 1a		 mov	 DWORD PTR [edx], ebx
  0005e	83 46 08 04	 add	 DWORD PTR [esi+8], 4

; 1948 : 	pWar->Serialize( m_Snapshot.ar );

  00062	56		 push	 esi
  00063	8b cf		 mov	 ecx, edi
  00065	e8 00 00 00 00	 call	 ?Serialize@CGuildWar@@QAEXAAVCAr@@@Z ; CGuildWar::Serialize
  0006a	5b		 pop	 ebx
$L304727:
  0006b	5f		 pop	 edi
$L278901:
  0006c	5e		 pop	 esi

; 1949 : 	
; 1950 : }

  0006d	c3		 ret	 0
?AddMyGuildWar@CUser@@QAEXXZ ENDP			; CUser::AddMyGuildWar
_TEXT	ENDS
PUBLIC	?AddContribution@CUser@@QAEXAAUCONTRIBUTION_CHANGED_INFO@@@Z ; CUser::AddContribution
EXTRN	??6@YAAAVCAr@@AAV0@AAUCONTRIBUTION_CHANGED_INFO@@@Z:NEAR ; operator<<
; Function compile flags: /Ogty
;	COMDAT ?AddContribution@CUser@@QAEXAAUCONTRIBUTION_CHANGED_INFO@@@Z
_TEXT	SEGMENT
_info$ = 8						; size = 4
?AddContribution@CUser@@QAEXAAUCONTRIBUTION_CHANGED_INFO@@@Z PROC NEAR ; CUser::AddContribution, COMDAT
; _this$ = ecx

; 1954 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	75 52		 jne	 SHORT $L278909

; 1955 : 
; 1956 : 	
; 1957 : 	m_Snapshot.cb++;

  00006	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  0000d	56		 push	 esi

; 1958 : 	m_Snapshot.ar << NULL_ID;

  0000e	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  00014	6a 04		 push	 4
  00016	8b ce		 mov	 ecx, esi
  00018	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0001d	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00020	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [eax], -1
  00026	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00029	83 c0 04	 add	 eax, 4

; 1959 : 	m_Snapshot.ar << SNAPSHOTTYPE_GUILD_CONTRIBUTION;

  0002c	6a 02		 push	 2
  0002e	8b ce		 mov	 ecx, esi
  00030	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00033	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00038	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]

; 1960 : 	m_Snapshot.ar << info;

  0003b	8b 54 24 08	 mov	 edx, DWORD PTR _info$[esp]
  0003f	66 c7 01 fc 00	 mov	 WORD PTR [ecx], 252	; 000000fcH
  00044	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00047	52		 push	 edx
  00048	83 c1 02	 add	 ecx, 2
  0004b	56		 push	 esi
  0004c	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  0004f	e8 00 00 00 00	 call	 ??6@YAAAVCAr@@AAV0@AAUCONTRIBUTION_CHANGED_INFO@@@Z ; operator<<
  00054	83 c4 08	 add	 esp, 8
  00057	5e		 pop	 esi
$L278909:

; 1961 : 	
; 1962 : }

  00058	c2 04 00	 ret	 4
?AddContribution@CUser@@QAEXAAUCONTRIBUTION_CHANGED_INFO@@@Z ENDP ; CUser::AddContribution
_TEXT	ENDS
PUBLIC	?AddInsertedVote@CUser@@QAEXAAUVOTE_INSERTED_INFO@@@Z ; CUser::AddInsertedVote
EXTRN	??6@YAAAVCAr@@AAV0@AAUVOTE_INSERTED_INFO@@@Z:NEAR ; operator<<
; Function compile flags: /Ogty
;	COMDAT ?AddInsertedVote@CUser@@QAEXAAUVOTE_INSERTED_INFO@@@Z
_TEXT	SEGMENT
_info$ = 8						; size = 4
?AddInsertedVote@CUser@@QAEXAAUVOTE_INSERTED_INFO@@@Z PROC NEAR ; CUser::AddInsertedVote, COMDAT
; _this$ = ecx

; 1966 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	75 52		 jne	 SHORT $L278915

; 1967 : 
; 1968 : 	
; 1969 : 	m_Snapshot.cb++;

  00006	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  0000d	56		 push	 esi

; 1970 : 	m_Snapshot.ar << NULL_ID;

  0000e	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  00014	6a 04		 push	 4
  00016	8b ce		 mov	 ecx, esi
  00018	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0001d	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00020	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [eax], -1
  00026	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00029	83 c0 04	 add	 eax, 4

; 1971 : 	m_Snapshot.ar << SNAPSHOTTYPE_GUILD_ADDVOTE;

  0002c	6a 02		 push	 2
  0002e	8b ce		 mov	 ecx, esi
  00030	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00033	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00038	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]

; 1972 : 	m_Snapshot.ar << info;

  0003b	8b 54 24 08	 mov	 edx, DWORD PTR _info$[esp]
  0003f	66 c7 01 d8 00	 mov	 WORD PTR [ecx], 216	; 000000d8H
  00044	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00047	52		 push	 edx
  00048	83 c1 02	 add	 ecx, 2
  0004b	56		 push	 esi
  0004c	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  0004f	e8 00 00 00 00	 call	 ??6@YAAAVCAr@@AAV0@AAUVOTE_INSERTED_INFO@@@Z ; operator<<
  00054	83 c4 08	 add	 esp, 8
  00057	5e		 pop	 esi
$L278915:

; 1973 : 	
; 1974 : }

  00058	c2 04 00	 ret	 4
?AddInsertedVote@CUser@@QAEXAAUVOTE_INSERTED_INFO@@@Z ENDP ; CUser::AddInsertedVote
_TEXT	ENDS
PUBLIC	?AddModifyVote@CUser@@QAEXKEE@Z			; CUser::AddModifyVote
; Function compile flags: /Ogty
;	COMDAT ?AddModifyVote@CUser@@QAEXKEE@Z
_TEXT	SEGMENT
_idVote$ = 8						; size = 4
_cbOperation$ = 12					; size = 1
_cbExtra$ = 16						; size = 1
?AddModifyVote@CUser@@QAEXKEE@Z PROC NEAR		; CUser::AddModifyVote, COMDAT
; _this$ = ecx

; 1978 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	0f 85 88 00 00
	00		 jne	 $L304797

; 1979 : 
; 1980 : 	
; 1981 : 	m_Snapshot.cb++;

  0000a	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  00011	56		 push	 esi

; 1982 : 	m_Snapshot.ar << NULL_ID;

  00012	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  00018	6a 04		 push	 4
  0001a	8b ce		 mov	 ecx, esi
  0001c	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00021	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00024	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [eax], -1
  0002a	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0002d	83 c2 04	 add	 edx, 4

; 1983 : 	m_Snapshot.ar << SNAPSHOTTYPE_GUILD_MODIFYVOTE;

  00030	6a 02		 push	 2
  00032	8b ce		 mov	 ecx, esi
  00034	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00037	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003c	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003f	66 c7 01 d9 00	 mov	 WORD PTR [ecx], 217	; 000000d9H
  00044	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00047	83 c0 02	 add	 eax, 2

; 1984 : 	m_Snapshot.ar << idVote;

  0004a	6a 04		 push	 4
  0004c	8b ce		 mov	 ecx, esi
  0004e	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00051	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00056	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00059	8b 44 24 08	 mov	 eax, DWORD PTR _idVote$[esp]
  0005d	89 02		 mov	 DWORD PTR [edx], eax
  0005f	83 46 08 04	 add	 DWORD PTR [esi+8], 4

; 1985 : 	m_Snapshot.ar << cbOperation;

  00063	6a 01		 push	 1
  00065	8b ce		 mov	 ecx, esi
  00067	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0006c	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0006f	8a 54 24 0c	 mov	 dl, BYTE PTR _cbOperation$[esp]
  00073	88 11		 mov	 BYTE PTR [ecx], dl
  00075	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00078	42		 inc	 edx

; 1986 : 	m_Snapshot.ar << cbExtra;

  00079	6a 01		 push	 1
  0007b	8b ce		 mov	 ecx, esi
  0007d	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00080	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00085	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00088	8a 4c 24 10	 mov	 cl, BYTE PTR _cbExtra$[esp]
  0008c	88 08		 mov	 BYTE PTR [eax], cl
  0008e	ff 46 08	 inc	 DWORD PTR [esi+8]
  00091	5e		 pop	 esi
$L304797:

; 1987 : 	
; 1988 : }

  00092	c2 0c 00	 ret	 12			; 0000000cH
?AddModifyVote@CUser@@QAEXKEE@Z ENDP			; CUser::AddModifyVote
_TEXT	ENDS
PUBLIC	?AddSetNotice@CUser@@QAEXKPBD@Z			; CUser::AddSetNotice
; Function compile flags: /Ogty
;	COMDAT ?AddSetNotice@CUser@@QAEXKPBD@Z
_TEXT	SEGMENT
_idGuild$ = 8						; size = 4
_szNotice$ = 12						; size = 4
?AddSetNotice@CUser@@QAEXKPBD@Z PROC NEAR		; CUser::AddSetNotice, COMDAT
; _this$ = ecx

; 1992 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	75 66		 jne	 SHORT $L278930

; 1993 : 
; 1994 : 	
; 1995 : 	m_Snapshot.cb++;

  00006	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  0000d	56		 push	 esi

; 1996 : 	m_Snapshot.ar << NULL_ID;

  0000e	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  00014	6a 04		 push	 4
  00016	8b ce		 mov	 ecx, esi
  00018	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0001d	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00020	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [eax], -1
  00026	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00029	83 c2 04	 add	 edx, 4

; 1997 : 	m_Snapshot.ar << SNAPSHOTTYPE_GUILD_NOTICE;

  0002c	6a 02		 push	 2
  0002e	8b ce		 mov	 ecx, esi
  00030	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00033	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00038	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003b	66 c7 01 fd 00	 mov	 WORD PTR [ecx], 253	; 000000fdH
  00040	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00043	83 c0 02	 add	 eax, 2

; 1998 : 	m_Snapshot.ar << idGuild;

  00046	6a 04		 push	 4
  00048	8b ce		 mov	 ecx, esi
  0004a	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0004d	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00052	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00055	8b 44 24 08	 mov	 eax, DWORD PTR _idGuild$[esp]
  00059	89 02		 mov	 DWORD PTR [edx], eax
  0005b	83 46 08 04	 add	 DWORD PTR [esi+8], 4

; 1999 : 	m_Snapshot.ar.WriteString( szNotice );

  0005f	8b 4c 24 0c	 mov	 ecx, DWORD PTR _szNotice$[esp]
  00063	51		 push	 ecx
  00064	8b ce		 mov	 ecx, esi
  00066	e8 00 00 00 00	 call	 ?WriteString@CAr@@QAEXPBD@Z ; CAr::WriteString
  0006b	5e		 pop	 esi
$L278930:

; 2000 : 	
; 2001 : }

  0006c	c2 08 00	 ret	 8
?AddSetNotice@CUser@@QAEXKPBD@Z ENDP			; CUser::AddSetNotice
_TEXT	ENDS
PUBLIC	?AddSetGuildAuthority@CUser@@QAEXQAK@Z		; CUser::AddSetGuildAuthority
; Function compile flags: /Ogty
;	COMDAT ?AddSetGuildAuthority@CUser@@QAEXQAK@Z
_TEXT	SEGMENT
_dwAuthority$ = 8					; size = 4
?AddSetGuildAuthority@CUser@@QAEXQAK@Z PROC NEAR	; CUser::AddSetGuildAuthority, COMDAT
; _this$ = ecx

; 2005 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	75 48		 jne	 SHORT $L278936

; 2006 : 	
; 2007 : 	
; 2008 : 	m_Snapshot.cb++;

  00006	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  0000d	56		 push	 esi

; 2009 : 	m_Snapshot.ar << NULL_ID;

  0000e	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  00014	6a 04		 push	 4
  00016	8b ce		 mov	 ecx, esi
  00018	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0001d	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00020	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [eax], -1
  00026	83 46 08 04	 add	 DWORD PTR [esi+8], 4

; 2010 : 	m_Snapshot.ar << SNAPSHOTTYPE_GUILD_AUTHORITY;

  0002a	6a 02		 push	 2
  0002c	8b ce		 mov	 ecx, esi
  0002e	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00033	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00036	66 c7 01 fe 00	 mov	 WORD PTR [ecx], 254	; 000000feH
  0003b	83 46 08 02	 add	 DWORD PTR [esi+8], 2

; 2011 : 	m_Snapshot.ar.Write( dwAuthority, sizeof(DWORD) * MAX_GM_LEVEL );

  0003f	8b 54 24 08	 mov	 edx, DWORD PTR _dwAuthority$[esp]
  00043	6a 14		 push	 20			; 00000014H
  00045	52		 push	 edx
  00046	8b ce		 mov	 ecx, esi
  00048	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
  0004d	5e		 pop	 esi
$L278936:

; 2012 : 	
; 2013 : }

  0004e	c2 04 00	 ret	 4
?AddSetGuildAuthority@CUser@@QAEXQAK@Z ENDP		; CUser::AddSetGuildAuthority
_TEXT	ENDS
PUBLIC	?AddSetGuildPenya@CUser@@QAEXKK@Z		; CUser::AddSetGuildPenya
; Function compile flags: /Ogty
;	COMDAT ?AddSetGuildPenya@CUser@@QAEXKK@Z
_TEXT	SEGMENT
_dwType$ = 8						; size = 4
_dwPenya$ = 12						; size = 4
?AddSetGuildPenya@CUser@@QAEXKK@Z PROC NEAR		; CUser::AddSetGuildPenya, COMDAT
; _this$ = ecx

; 2017 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	75 70		 jne	 SHORT $L304869

; 2018 : 	
; 2019 : 	
; 2020 : 	m_Snapshot.cb++;

  00006	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  0000d	56		 push	 esi

; 2021 : 	m_Snapshot.ar << NULL_ID;

  0000e	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  00014	6a 04		 push	 4
  00016	8b ce		 mov	 ecx, esi
  00018	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0001d	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00020	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [eax], -1
  00026	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00029	83 c0 04	 add	 eax, 4

; 2022 : 	m_Snapshot.ar << SNAPSHOTTYPE_GUILD_PENYA;

  0002c	6a 02		 push	 2
  0002e	8b ce		 mov	 ecx, esi
  00030	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00033	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00038	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003b	66 c7 01 ff 00	 mov	 WORD PTR [ecx], 255	; 000000ffH
  00040	83 46 08 02	 add	 DWORD PTR [esi+8], 2

; 2023 : 	m_Snapshot.ar << dwType << dwPenya;	

  00044	6a 04		 push	 4
  00046	8b ce		 mov	 ecx, esi
  00048	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0004d	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00050	8b 44 24 08	 mov	 eax, DWORD PTR _dwType$[esp]
  00054	89 02		 mov	 DWORD PTR [edx], eax
  00056	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00059	83 c2 04	 add	 edx, 4
  0005c	6a 04		 push	 4
  0005e	8b ce		 mov	 ecx, esi
  00060	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00063	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00068	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0006b	8b 54 24 0c	 mov	 edx, DWORD PTR _dwPenya$[esp]
  0006f	89 11		 mov	 DWORD PTR [ecx], edx
  00071	83 46 08 04	 add	 DWORD PTR [esi+8], 4
  00075	5e		 pop	 esi
$L304869:

; 2024 : 	
; 2025 : }

  00076	c2 08 00	 ret	 8
?AddSetGuildPenya@CUser@@QAEXKK@Z ENDP			; CUser::AddSetGuildPenya
_TEXT	ENDS
PUBLIC	?AddGuildRealPenya@CUser@@QAEXHH@Z		; CUser::AddGuildRealPenya
; Function compile flags: /Ogty
;	COMDAT ?AddGuildRealPenya@CUser@@QAEXHH@Z
_TEXT	SEGMENT
_nGoldGuild$ = 8					; size = 4
_nType$ = 12						; size = 4
?AddGuildRealPenya@CUser@@QAEXHH@Z PROC NEAR		; CUser::AddGuildRealPenya, COMDAT
; _this$ = ecx

; 2029 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	75 70		 jne	 SHORT $L304904

; 2030 : 	
; 2031 : 	
; 2032 : 	m_Snapshot.cb++;

  00006	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  0000d	56		 push	 esi

; 2033 : 	m_Snapshot.ar << NULL_ID;

  0000e	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  00014	6a 04		 push	 4
  00016	8b ce		 mov	 ecx, esi
  00018	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0001d	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00020	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [eax], -1
  00026	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00029	83 c0 04	 add	 eax, 4

; 2034 : 	m_Snapshot.ar << SNAPSHOTTYPE_GUILD_REAL_PENYA;

  0002c	6a 02		 push	 2
  0002e	8b ce		 mov	 ecx, esi
  00030	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00033	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00038	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003b	66 c7 01 d5 00	 mov	 WORD PTR [ecx], 213	; 000000d5H
  00040	83 46 08 02	 add	 DWORD PTR [esi+8], 2

; 2035 : 	m_Snapshot.ar << nGoldGuild;	

  00044	6a 04		 push	 4
  00046	8b ce		 mov	 ecx, esi
  00048	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0004d	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00050	8b 44 24 08	 mov	 eax, DWORD PTR _nGoldGuild$[esp]
  00054	89 02		 mov	 DWORD PTR [edx], eax
  00056	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00059	83 c2 04	 add	 edx, 4

; 2036 : 	m_Snapshot.ar << nType;	

  0005c	6a 04		 push	 4
  0005e	8b ce		 mov	 ecx, esi
  00060	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00063	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00068	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0006b	8b 54 24 0c	 mov	 edx, DWORD PTR _nType$[esp]
  0006f	89 11		 mov	 DWORD PTR [ecx], edx
  00071	83 46 08 04	 add	 DWORD PTR [esi+8], 4
  00075	5e		 pop	 esi
$L304904:

; 2037 : 	
; 2038 : }

  00076	c2 08 00	 ret	 8
?AddGuildRealPenya@CUser@@QAEXHH@Z ENDP			; CUser::AddGuildRealPenya
_TEXT	ENDS
PUBLIC	?SendGuildRank@CUser@@QAEXXZ			; CUser::SendGuildRank
EXTRN	?Instance@CGuildRank@@SAPAV1@XZ:NEAR		; CGuildRank::Instance
; Function compile flags: /Ogty
;	COMDAT ?SendGuildRank@CUser@@QAEXXZ
_TEXT	SEGMENT
?SendGuildRank@CUser@@QAEXXZ PROC NEAR			; CUser::SendGuildRank, COMDAT
; _this$ = ecx

; 2042 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	75 51		 jne	 SHORT $L278956

; 2043 : 	
; 2044 : 	
; 2045 : 	m_Snapshot.cb++;

  00006	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  0000d	56		 push	 esi

; 2046 : 	m_Snapshot.ar << NULL_ID;

  0000e	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  00014	6a 04		 push	 4
  00016	8b ce		 mov	 ecx, esi
  00018	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0001d	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00020	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [eax], -1
  00026	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00029	83 c0 04	 add	 eax, 4

; 2047 : 	m_Snapshot.ar << SNAPSHOTTYPE_REQUEST_GUILDRANK;

  0002c	6a 02		 push	 2
  0002e	8b ce		 mov	 ecx, esi
  00030	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00033	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00038	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003b	66 c7 01 db 00	 mov	 WORD PTR [ecx], 219	; 000000dbH
  00040	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00043	83 c1 02	 add	 ecx, 2

; 2048 : 	CGuildRank::Instance()->Serialize( m_Snapshot.ar );

  00046	56		 push	 esi
  00047	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  0004a	e8 00 00 00 00	 call	 ?Instance@CGuildRank@@SAPAV1@XZ ; CGuildRank::Instance
  0004f	8b c8		 mov	 ecx, eax
  00051	e8 00 00 00 00	 call	 ?Serialize@CGuildRank@@QAEXAAVCAr@@@Z ; CGuildRank::Serialize
  00056	5e		 pop	 esi
$L278956:

; 2049 : 	
; 2050 : }

  00057	c3		 ret	 0
?SendGuildRank@CUser@@QAEXXZ ENDP			; CUser::SendGuildRank
_TEXT	ENDS
PUBLIC	??_C@_0BL@MCMODJOL@SMMODE?5OVERFLOW?5nType?5?3?5?$CFd?$AA@ ; `string'
PUBLIC	?AddSMMode@CUser@@QAEXHK@Z			; CUser::AddSMMode
EXTRN	?g_AddSMMode@@3U_ADDSMMODE@@A:BYTE		; g_AddSMMode
;	COMDAT ??_C@_0BL@MCMODJOL@SMMODE?5OVERFLOW?5nType?5?3?5?$CFd?$AA@
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_network\misc\include\ar.h
CONST	SEGMENT
??_C@_0BL@MCMODJOL@SMMODE?5OVERFLOW?5nType?5?3?5?$CFd?$AA@ DB 'SMMODE OVE'
	DB	'RFLOW nType : %d', 00H			; `string'
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
CONST	ENDS
;	COMDAT ?AddSMMode@CUser@@QAEXHK@Z
_TEXT	SEGMENT
_tSMtime$279089 = -8					; size = 8
_nType$ = 8						; size = 4
_dwTime$ = 12						; size = 4
?AddSMMode@CUser@@QAEXHK@Z PROC NEAR			; CUser::AddSMMode, COMDAT
; _this$ = ecx

; 2088 : {

  00000	83 ec 08	 sub	 esp, 8
  00003	57		 push	 edi
  00004	8b f9		 mov	 edi, ecx

; 2089 : 	if( IsDelete() )	return;

  00006	f6 47 04 01	 test	 BYTE PTR [edi+4], 1
  0000a	0f 85 c1 00 00
	00		 jne	 $L279096

; 2090 : 	
; 2091 : 	m_Snapshot.cb++;

  00010	66 ff 87 0c 57
	00 00		 inc	 WORD PTR [edi+22284]
  00017	53		 push	 ebx
  00018	56		 push	 esi

; 2092 : 	m_Snapshot.ar << NULL_ID;

  00019	8d b7 f8 16 00
	00		 lea	 esi, DWORD PTR [edi+5880]
  0001f	6a 04		 push	 4
  00021	8b ce		 mov	 ecx, esi
  00023	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00028	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0002b	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [eax], -1
  00031	8b 5e 08	 mov	 ebx, DWORD PTR [esi+8]
  00034	83 c3 04	 add	 ebx, 4

; 2093 : 	m_Snapshot.ar << SNAPSHOTTYPE_SM_MODE;

  00037	6a 02		 push	 2
  00039	8b ce		 mov	 ecx, esi
  0003b	89 5e 08	 mov	 DWORD PTR [esi+8], ebx
  0003e	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00043	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]

; 2094 : 
; 2095 : 	DWORD BufSMTime = 0;
; 2096 : 	if( dwTime != 0 )

  00046	8b 44 24 1c	 mov	 eax, DWORD PTR _dwTime$[esp+16]
  0004a	8b 5c 24 18	 mov	 ebx, DWORD PTR _nType$[esp+16]
  0004e	66 c7 01 3f 00	 mov	 WORD PTR [ecx], 63	; 0000003fH
  00053	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00056	83 c1 02	 add	 ecx, 2
  00059	85 c0		 test	 eax, eax
  0005b	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  0005e	74 28		 je	 SHORT $L279087

; 2097 : 	{
; 2098 : 		if( g_AddSMMode.bSMModetime[nType] )

  00060	8b 04 9d 00 00
	00 00		 mov	 eax, DWORD PTR ?g_AddSMMode@@3U_ADDSMMODE@@A[ebx*4]
  00067	85 c0		 test	 eax, eax

; 2099 : 		{
; 2100 : 			CTime tSMtime( m_dwSMTime[nType] );

  00069	8b bc 9f 04 03
	00 00		 mov	 edi, DWORD PTR [edi+ebx*4+772]
  00070	74 18		 je	 SHORT $L279095

; 2101 : 			CTimeSpan ct = tSMtime - CTime::GetCurrentTime();

  00072	6a 00		 push	 0
  00074	c7 44 24 14 00
	00 00 00	 mov	 DWORD PTR _tSMtime$279089[esp+28], 0
  0007c	e8 00 00 00 00	 call	 __time64
  00081	83 c4 04	 add	 esp, 4
  00084	2b f8		 sub	 edi, eax

; 2102 : 			BufSMTime = (DWORD)( ct.GetTotalSeconds() );
; 2103 : 		}
; 2104 : 		else

  00086	eb 02		 jmp	 SHORT $L279095
$L279087:

; 2105 : 		{
; 2106 : 			BufSMTime = m_dwSMTime[nType];
; 2107 : 		}
; 2108 : 	}
; 2109 : 	else
; 2110 : 	{
; 2111 : 		BufSMTime = 0;

  00088	33 ff		 xor	 edi, edi
$L279095:

; 2112 : 	}
; 2113 : 
; 2114 : 	m_Snapshot.ar << nType;

  0008a	6a 04		 push	 4
  0008c	8b ce		 mov	 ecx, esi
  0008e	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00093	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00096	89 1a		 mov	 DWORD PTR [edx], ebx
  00098	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0009b	83 c0 04	 add	 eax, 4

; 2115 : 	m_Snapshot.ar << BufSMTime;

  0009e	6a 04		 push	 4
  000a0	8b ce		 mov	 ecx, esi
  000a2	89 46 08	 mov	 DWORD PTR [esi+8], eax
  000a5	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000aa	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000ad	89 38		 mov	 DWORD PTR [eax], edi
  000af	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  000b2	83 c1 04	 add	 ecx, 4

; 2116 : 	
; 2117 : 	if( nType < 0 || SM_MAX <= nType )

  000b5	85 db		 test	 ebx, ebx
  000b7	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  000ba	7c 05		 jl	 SHORT $L279097
  000bc	83 fb 1a	 cmp	 ebx, 26			; 0000001aH
  000bf	7c 0e		 jl	 SHORT $L304987
$L279097:

; 2118 : 	{
; 2119 : 		WriteLog( "SMMODE OVERFLOW nType : %d", nType );

  000c1	53		 push	 ebx
  000c2	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BL@MCMODJOL@SMMODE?5OVERFLOW?5nType?5?3?5?$CFd?$AA@
  000c7	e8 00 00 00 00	 call	 ?WriteLog@@YAXPBDZZ	; WriteLog
  000cc	83 c4 08	 add	 esp, 8
$L304987:
  000cf	5e		 pop	 esi
  000d0	5b		 pop	 ebx
$L279096:
  000d1	5f		 pop	 edi

; 2120 : 	}
; 2121 : 	
; 2122 : }

  000d2	83 c4 08	 add	 esp, 8
  000d5	c2 08 00	 ret	 8
?AddSMMode@CUser@@QAEXHK@Z ENDP				; CUser::AddSMMode
_TEXT	ENDS
PUBLIC	?AddSMModeAll@CUser@@QAEXXZ			; CUser::AddSMModeAll
; Function compile flags: /Ogty
;	COMDAT ?AddSMModeAll@CUser@@QAEXXZ
_TEXT	SEGMENT
_nReal$ = -20						; size = 2
_uOffset$ = -16						; size = 4
_nBlockSize$ = -12					; size = 4
_tSMtime$279114 = -8					; size = 8
?AddSMModeAll@CUser@@QAEXXZ PROC NEAR			; CUser::AddSMModeAll, COMDAT
; _this$ = ecx

; 2125 : {

  00000	83 ec 14	 sub	 esp, 20			; 00000014H
  00003	57		 push	 edi
  00004	8b f9		 mov	 edi, ecx

; 2126 : 	if( IsDelete() )	return;

  00006	f6 47 04 01	 test	 BYTE PTR [edi+4], 1
  0000a	0f 85 f3 00 00
	00		 jne	 $L279101

; 2127 : 	
; 2128 : 	m_Snapshot.cb++;

  00010	66 ff 87 0c 57
	00 00		 inc	 WORD PTR [edi+22284]
  00017	53		 push	 ebx
  00018	55		 push	 ebp
  00019	56		 push	 esi

; 2129 : 	m_Snapshot.ar << NULL_ID;

  0001a	8d b7 f8 16 00
	00		 lea	 esi, DWORD PTR [edi+5880]
  00020	6a 04		 push	 4
  00022	8b ce		 mov	 ecx, esi
  00024	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00029	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0002c	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [eax], -1
  00032	83 46 08 04	 add	 DWORD PTR [esi+8], 4

; 2130 : 	m_Snapshot.ar << SNAPSHOTTYPE_SM_MODE_ALL;

  00036	bb 02 00 00 00	 mov	 ebx, 2
  0003b	53		 push	 ebx
  0003c	8b ce		 mov	 ecx, esi
  0003e	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00043	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00046	66 c7 01 3e 00	 mov	 WORD PTR [ecx], 62	; 0000003eH
  0004b	8b 6e 08	 mov	 ebp, DWORD PTR [esi+8]
  0004e	03 eb		 add	 ebp, ebx
  00050	89 6e 08	 mov	 DWORD PTR [esi+8], ebp

; 2131 : 
; 2132 : 	u_long uOffset	= m_Snapshot.ar.GetOffset();

  00053	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  00056	8b c5		 mov	 eax, ebp
  00058	2b c2		 sub	 eax, edx

; 2133 : 	m_Snapshot.ar << (short)0;

  0005a	53		 push	 ebx
  0005b	8b ce		 mov	 ecx, esi
  0005d	89 44 24 18	 mov	 DWORD PTR _uOffset$[esp+40], eax
  00061	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00066	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00069	66 c7 02 00 00	 mov	 WORD PTR [edx], 0
  0006e	01 5e 08	 add	 DWORD PTR [esi+8], ebx

; 2134 : 	short nReal = 0;

  00071	c7 44 24 10 00
	00 00 00	 mov	 DWORD PTR _nReal$[esp+36], 0

; 2135 : 
; 2136 : 	for( int i = 0 ; i < SM_MAX ; ++i )

  00079	33 db		 xor	 ebx, ebx
  0007b	8d af 04 03 00
	00		 lea	 ebp, DWORD PTR [edi+772]
$L305063:

; 2137 : 	{
; 2138 : 		DWORD BufSMTime = 0;
; 2139 : 		if( 0 < m_dwSMTime[i] )

  00081	8b 7d 00	 mov	 edi, DWORD PTR [ebp]
  00084	85 ff		 test	 edi, edi
  00086	76 56		 jbe	 SHORT $L279109

; 2140 : 		{
; 2141 : 			if( g_AddSMMode.bSMModetime[i] )

  00088	8b 04 9d 00 00
	00 00		 mov	 eax, DWORD PTR ?g_AddSMMode@@3U_ADDSMMODE@@A[ebx*4]
  0008f	85 c0		 test	 eax, eax
  00091	74 14		 je	 SHORT $L279119

; 2142 : 			{
; 2143 : 				CTime tSMtime( m_dwSMTime[i] );
; 2144 : 				CTimeSpan ct = tSMtime - CTime::GetCurrentTime();

  00093	6a 00		 push	 0
  00095	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR _tSMtime$279114[esp+44], 0
  0009d	e8 00 00 00 00	 call	 __time64
  000a2	83 c4 04	 add	 esp, 4
  000a5	2b f8		 sub	 edi, eax
$L279119:

; 2145 : 				BufSMTime = (DWORD)( ct.GetTotalSeconds() );
; 2146 : 			}
; 2147 : 			else
; 2148 : 			{
; 2149 : 				BufSMTime = m_dwSMTime[i];
; 2150 : 			}
; 2151 : 			m_Snapshot.ar << i;

  000a7	6a 04		 push	 4
  000a9	8b ce		 mov	 ecx, esi
  000ab	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000b0	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000b3	89 18		 mov	 DWORD PTR [eax], ebx
  000b5	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000b8	83 c0 04	 add	 eax, 4

; 2152 : 			m_Snapshot.ar << BufSMTime;

  000bb	6a 04		 push	 4
  000bd	8b ce		 mov	 ecx, esi
  000bf	89 46 08	 mov	 DWORD PTR [esi+8], eax
  000c2	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000c7	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]

; 2153 : 			++nReal;

  000ca	8b 44 24 10	 mov	 eax, DWORD PTR _nReal$[esp+36]
  000ce	89 39		 mov	 DWORD PTR [ecx], edi
  000d0	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  000d3	83 c1 04	 add	 ecx, 4
  000d6	40		 inc	 eax
  000d7	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  000da	89 44 24 10	 mov	 DWORD PTR _nReal$[esp+36], eax
$L279109:
  000de	43		 inc	 ebx
  000df	83 c5 04	 add	 ebp, 4
  000e2	83 fb 1a	 cmp	 ebx, 26			; 0000001aH
  000e5	7c 9a		 jl	 SHORT $L305063

; 2154 : 		}
; 2155 : 	}
; 2156 : 	
; 2157 : 	GETBLOCK( m_Snapshot.ar, lpBlock, nBlockSize );

  000e7	8d 54 24 18	 lea	 edx, DWORD PTR _nBlockSize$[esp+36]
  000eb	52		 push	 edx
  000ec	8b ce		 mov	 ecx, esi
  000ee	e8 00 00 00 00	 call	 ?GetBuffer@CAr@@QAEPAEPAH@Z ; CAr::GetBuffer

; 2158 : 	*(UNALIGNED short*)( lpBlock + uOffset ) = nReal;

  000f3	66 8b 4c 24 10	 mov	 cx, WORD PTR _nReal$[esp+36]
  000f8	8b 54 24 14	 mov	 edx, DWORD PTR _uOffset$[esp+36]
  000fc	5e		 pop	 esi
  000fd	5d		 pop	 ebp
  000fe	66 89 0c 10	 mov	 WORD PTR [eax+edx], cx
  00102	5b		 pop	 ebx
$L279101:
  00103	5f		 pop	 edi

; 2159 : 
; 2160 : 	
; 2161 : }

  00104	83 c4 14	 add	 esp, 20			; 00000014H
  00107	c3		 ret	 0
?AddSMModeAll@CUser@@QAEXXZ ENDP			; CUser::AddSMModeAll
_TEXT	ENDS
PUBLIC	?AddResistSMMode@CUser@@QAEXEEE@Z		; CUser::AddResistSMMode
; Function compile flags: /Ogty
;	COMDAT ?AddResistSMMode@CUser@@QAEXEEE@Z
_TEXT	SEGMENT
_nAttackResistLeft$ = 8					; size = 1
_nAttackResistRight$ = 12				; size = 1
_nDefenceResist$ = 16					; size = 1
?AddResistSMMode@CUser@@QAEXEEE@Z PROC NEAR		; CUser::AddResistSMMode, COMDAT
; _this$ = ecx

; 2165 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	0f 85 87 00 00
	00		 jne	 $L305093

; 2166 : 	
; 2167 : 	m_Snapshot.cb++;

  0000a	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  00011	56		 push	 esi

; 2168 : 	m_Snapshot.ar << NULL_ID;

  00012	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  00018	6a 04		 push	 4
  0001a	8b ce		 mov	 ecx, esi
  0001c	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00021	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00024	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [eax], -1
  0002a	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0002d	83 c2 04	 add	 edx, 4

; 2169 : 	m_Snapshot.ar << SNAPSHOTTYPE_RESISTSMMODE;

  00030	6a 02		 push	 2
  00032	8b ce		 mov	 ecx, esi
  00034	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00037	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003c	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003f	66 c7 01 5d 00	 mov	 WORD PTR [ecx], 93	; 0000005dH
  00044	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00047	83 c0 02	 add	 eax, 2

; 2170 : 	m_Snapshot.ar << nAttackResistLeft;

  0004a	6a 01		 push	 1
  0004c	8b ce		 mov	 ecx, esi
  0004e	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00051	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00056	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00059	8a 44 24 08	 mov	 al, BYTE PTR _nAttackResistLeft$[esp]
  0005d	88 02		 mov	 BYTE PTR [edx], al
  0005f	ff 46 08	 inc	 DWORD PTR [esi+8]

; 2171 : 	m_Snapshot.ar << nAttackResistRight;

  00062	6a 01		 push	 1
  00064	8b ce		 mov	 ecx, esi
  00066	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0006b	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0006e	8a 54 24 0c	 mov	 dl, BYTE PTR _nAttackResistRight$[esp]
  00072	88 11		 mov	 BYTE PTR [ecx], dl
  00074	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00077	42		 inc	 edx

; 2172 : 	m_Snapshot.ar << nDefenceResist;

  00078	6a 01		 push	 1
  0007a	8b ce		 mov	 ecx, esi
  0007c	89 56 08	 mov	 DWORD PTR [esi+8], edx
  0007f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00084	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00087	8a 4c 24 10	 mov	 cl, BYTE PTR _nDefenceResist$[esp]
  0008b	88 08		 mov	 BYTE PTR [eax], cl
  0008d	ff 46 08	 inc	 DWORD PTR [esi+8]
  00090	5e		 pop	 esi
$L305093:

; 2173 : 	
; 2174 : }

  00091	c2 0c 00	 ret	 12			; 0000000cH
?AddResistSMMode@CUser@@QAEXEEE@Z ENDP			; CUser::AddResistSMMode
_TEXT	ENDS
PUBLIC	?AddCommercialElem@CUser@@QAEXKH@Z		; CUser::AddCommercialElem
; Function compile flags: /Ogty
;	COMDAT ?AddCommercialElem@CUser@@QAEXKH@Z
_TEXT	SEGMENT
_dwItemId$ = 8						; size = 4
_nResistSMItemId$ = 12					; size = 4
?AddCommercialElem@CUser@@QAEXKH@Z PROC NEAR		; CUser::AddCommercialElem, COMDAT
; _this$ = ecx

; 2178 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	75 70		 jne	 SHORT $L305124

; 2179 : 	
; 2180 : 	m_Snapshot.cb++;

  00006	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  0000d	56		 push	 esi

; 2181 : 	m_Snapshot.ar << NULL_ID;

  0000e	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  00014	6a 04		 push	 4
  00016	8b ce		 mov	 ecx, esi
  00018	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0001d	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00020	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [eax], -1
  00026	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00029	83 c0 04	 add	 eax, 4

; 2182 : 	m_Snapshot.ar << SNAPSHOTTYPE_COMMERCIALELEM;

  0002c	6a 02		 push	 2
  0002e	8b ce		 mov	 ecx, esi
  00030	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00033	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00038	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003b	66 c7 01 5e 00	 mov	 WORD PTR [ecx], 94	; 0000005eH
  00040	83 46 08 02	 add	 DWORD PTR [esi+8], 2

; 2183 : 	m_Snapshot.ar << dwItemId;

  00044	6a 04		 push	 4
  00046	8b ce		 mov	 ecx, esi
  00048	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0004d	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00050	8b 44 24 08	 mov	 eax, DWORD PTR _dwItemId$[esp]
  00054	89 02		 mov	 DWORD PTR [edx], eax
  00056	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00059	83 c2 04	 add	 edx, 4

; 2184 : 	m_Snapshot.ar << nResistSMItemId;

  0005c	6a 04		 push	 4
  0005e	8b ce		 mov	 ecx, esi
  00060	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00063	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00068	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0006b	8b 54 24 0c	 mov	 edx, DWORD PTR _nResistSMItemId$[esp]
  0006f	89 11		 mov	 DWORD PTR [ecx], edx
  00071	83 46 08 04	 add	 DWORD PTR [esi+8], 4
  00075	5e		 pop	 esi
$L305124:

; 2185 : 	
; 2186 : }

  00076	c2 08 00	 ret	 8
?AddCommercialElem@CUser@@QAEXKH@Z ENDP			; CUser::AddCommercialElem
_TEXT	ENDS
PUBLIC	?AddFlyffEvent@CUser@@QAEXXZ			; CUser::AddFlyffEvent
EXTRN	?Serialize@CFlyffEvent@@QAEXAAVCAr@@@Z:NEAR	; CFlyffEvent::Serialize
EXTRN	?g_eLocal@@3VCFlyffEvent@@A:BYTE		; g_eLocal
; Function compile flags: /Ogty
;	COMDAT ?AddFlyffEvent@CUser@@QAEXXZ
_TEXT	SEGMENT
?AddFlyffEvent@CUser@@QAEXXZ PROC NEAR			; CUser::AddFlyffEvent, COMDAT
; _this$ = ecx

; 2190 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	75 4a		 jne	 SHORT $L279141

; 2191 : 	
; 2192 : 	m_Snapshot.cb++;

  00006	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  0000d	56		 push	 esi

; 2193 : 	m_Snapshot.ar << NULL_ID;

  0000e	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  00014	6a 04		 push	 4
  00016	8b ce		 mov	 ecx, esi
  00018	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0001d	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00020	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [eax], -1
  00026	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00029	83 c0 04	 add	 eax, 4

; 2194 : 	m_Snapshot.ar << SNAPSHOTTYPE_FLYFF_EVENT;

  0002c	6a 02		 push	 2
  0002e	8b ce		 mov	 ecx, esi
  00030	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00033	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00038	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003b	66 c7 01 b2 00	 mov	 WORD PTR [ecx], 178	; 000000b2H
  00040	83 46 08 02	 add	 DWORD PTR [esi+8], 2

; 2195 : 	g_eLocal.Serialize( m_Snapshot.ar );

  00044	56		 push	 esi
  00045	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_eLocal@@3VCFlyffEvent@@A
  0004a	e8 00 00 00 00	 call	 ?Serialize@CFlyffEvent@@QAEXAAVCAr@@@Z ; CFlyffEvent::Serialize
  0004f	5e		 pop	 esi
$L279141:

; 2196 : 	
; 2197 : }

  00050	c3		 ret	 0
?AddFlyffEvent@CUser@@QAEXXZ ENDP			; CUser::AddFlyffEvent
_TEXT	ENDS
PUBLIC	?AddDefinedText@CUser@@QAAXHPBDZZ		; CUser::AddDefinedText
EXTRN	__vsnprintf:NEAR
; Function compile flags: /Ogty
;	COMDAT ?AddDefinedText@CUser@@QAAXHPBDZZ
_TEXT	SEGMENT
_szBuffer$ = -1028					; size = 1024
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
_this$ = 8						; size = 4
_dwText$ = 12						; size = 4
_lpszFormat$ = 16					; size = 4
?AddDefinedText@CUser@@QAAXHPBDZZ PROC NEAR		; CUser::AddDefinedText, COMDAT

; 2239 : {

  00000	81 ec 04 04 00
	00		 sub	 esp, 1028		; 00000404H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c4		 xor	 eax, esp
  0000d	56		 push	 esi

; 2240 : 	if( IsDelete() )	return;

  0000e	8b b4 24 0c 04
	00 00		 mov	 esi, DWORD PTR _this$[esp+1028]
  00015	89 84 24 04 04
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+1032], eax
  0001c	f6 46 04 01	 test	 BYTE PTR [esi+4], 1
  00020	0f 85 8c 00 00
	00		 jne	 $L279177

; 2241 : 
; 2242 : 	TCHAR szBuffer[1024];
; 2243 : 
; 2244 : 	va_list args;
; 2245 : 	va_start( args, lpszFormat );
; 2246 : 	int nBuf = _vsntprintf( szBuffer, sizeof(szBuffer)-1, lpszFormat, args );

  00026	8b 8c 24 14 04
	00 00		 mov	 ecx, DWORD PTR _lpszFormat$[esp+1028]
  0002d	8d 84 24 18 04
	00 00		 lea	 eax, DWORD PTR _lpszFormat$[esp+1032]
  00034	50		 push	 eax
  00035	51		 push	 ecx
  00036	8d 54 24 0c	 lea	 edx, DWORD PTR _szBuffer$[esp+1040]
  0003a	68 ff 03 00 00	 push	 1023			; 000003ffH
  0003f	52		 push	 edx
  00040	e8 00 00 00 00	 call	 __vsnprintf
  00045	83 c4 10	 add	 esp, 16			; 00000010H

; 2247 : 	va_end( args );
; 2248 : 
; 2249 : 	if( nBuf < 0 )

  00048	85 c0		 test	 eax, eax
  0004a	7c 66		 jl	 SHORT $L279177

; 2250 : 		return;
; 2251 : 
; 2252 : 	
; 2253 : 	m_Snapshot.cb++;

  0004c	66 ff 86 0c 57
	00 00		 inc	 WORD PTR [esi+22284]
  00053	57		 push	 edi

; 2254 : 	m_Snapshot.ar << GetId();

  00054	8b be bc 01 00
	00		 mov	 edi, DWORD PTR [esi+444]
  0005a	81 c6 f8 16 00
	00		 add	 esi, 5880		; 000016f8H
  00060	6a 04		 push	 4
  00062	8b ce		 mov	 ecx, esi
  00064	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00069	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0006c	89 38		 mov	 DWORD PTR [eax], edi
  0006e	83 46 08 04	 add	 DWORD PTR [esi+8], 4

; 2255 : 	m_Snapshot.ar << SNAPSHOTTYPE_DEFINEDTEXT;

  00072	6a 02		 push	 2
  00074	8b ce		 mov	 ecx, esi
  00076	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0007b	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0007e	66 c7 01 95 00	 mov	 WORD PTR [ecx], 149	; 00000095H
  00083	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  00086	83 c7 02	 add	 edi, 2

; 2256 : 	m_Snapshot.ar << dwText;

  00089	6a 04		 push	 4
  0008b	8b ce		 mov	 ecx, esi
  0008d	89 7e 08	 mov	 DWORD PTR [esi+8], edi
  00090	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00095	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00098	8b 84 24 14 04
	00 00		 mov	 eax, DWORD PTR _dwText$[esp+1032]
  0009f	89 02		 mov	 DWORD PTR [edx], eax
  000a1	83 46 08 04	 add	 DWORD PTR [esi+8], 4

; 2257 : 	m_Snapshot.ar.WriteString( szBuffer );

  000a5	8d 4c 24 08	 lea	 ecx, DWORD PTR _szBuffer$[esp+1036]
  000a9	51		 push	 ecx
  000aa	8b ce		 mov	 ecx, esi
  000ac	e8 00 00 00 00	 call	 ?WriteString@CAr@@QAEXPBD@Z ; CAr::WriteString
  000b1	5f		 pop	 edi
$L279177:

; 2258 : 	
; 2259 : }

  000b2	8b 8c 24 04 04
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+1032]
  000b9	5e		 pop	 esi
  000ba	33 cc		 xor	 ecx, esp
  000bc	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000c1	81 c4 04 04 00
	00		 add	 esp, 1028		; 00000404H
  000c7	c3		 ret	 0
?AddDefinedText@CUser@@QAAXHPBDZZ ENDP			; CUser::AddDefinedText
_TEXT	ENDS
PUBLIC	?AddChatText@CUser@@QAAXHPBDZZ			; CUser::AddChatText
; Function compile flags: /Ogty
;	COMDAT ?AddChatText@CUser@@QAAXHPBDZZ
_TEXT	SEGMENT
_szBuffer$ = -1028					; size = 1024
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
_this$ = 8						; size = 4
_dwText$ = 12						; size = 4
_lpszFormat$ = 16					; size = 4
?AddChatText@CUser@@QAAXHPBDZZ PROC NEAR		; CUser::AddChatText, COMDAT

; 2262 : {

  00000	81 ec 04 04 00
	00		 sub	 esp, 1028		; 00000404H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c4		 xor	 eax, esp
  0000d	56		 push	 esi

; 2263 : 	if( IsDelete() )	return;

  0000e	8b b4 24 0c 04
	00 00		 mov	 esi, DWORD PTR _this$[esp+1028]
  00015	89 84 24 04 04
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+1032], eax
  0001c	f6 46 04 01	 test	 BYTE PTR [esi+4], 1
  00020	0f 85 8c 00 00
	00		 jne	 $L279194

; 2264 : 	
; 2265 : 	TCHAR szBuffer[1024];
; 2266 : 	
; 2267 : 	va_list args;
; 2268 : 	va_start( args, lpszFormat );
; 2269 : 	int nBuf = _vsntprintf( szBuffer, sizeof(szBuffer)-1, lpszFormat, args );

  00026	8b 8c 24 14 04
	00 00		 mov	 ecx, DWORD PTR _lpszFormat$[esp+1028]
  0002d	8d 84 24 18 04
	00 00		 lea	 eax, DWORD PTR _lpszFormat$[esp+1032]
  00034	50		 push	 eax
  00035	51		 push	 ecx
  00036	8d 54 24 0c	 lea	 edx, DWORD PTR _szBuffer$[esp+1040]
  0003a	68 ff 03 00 00	 push	 1023			; 000003ffH
  0003f	52		 push	 edx
  00040	e8 00 00 00 00	 call	 __vsnprintf
  00045	83 c4 10	 add	 esp, 16			; 00000010H

; 2270 : 	va_end( args );
; 2271 : 	
; 2272 : 	if( nBuf < 0 )

  00048	85 c0		 test	 eax, eax
  0004a	7c 66		 jl	 SHORT $L279194

; 2273 : 		return;
; 2274 : 	
; 2275 : 	
; 2276 : 	m_Snapshot.cb++;

  0004c	66 ff 86 0c 57
	00 00		 inc	 WORD PTR [esi+22284]
  00053	57		 push	 edi

; 2277 : 	m_Snapshot.ar << GetId();

  00054	8b be bc 01 00
	00		 mov	 edi, DWORD PTR [esi+444]
  0005a	81 c6 f8 16 00
	00		 add	 esi, 5880		; 000016f8H
  00060	6a 04		 push	 4
  00062	8b ce		 mov	 ecx, esi
  00064	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00069	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0006c	89 38		 mov	 DWORD PTR [eax], edi
  0006e	83 46 08 04	 add	 DWORD PTR [esi+8], 4

; 2278 : 	m_Snapshot.ar << SNAPSHOTTYPE_CHATTEXT;

  00072	6a 02		 push	 2
  00074	8b ce		 mov	 ecx, esi
  00076	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0007b	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0007e	66 c7 01 bc 00	 mov	 WORD PTR [ecx], 188	; 000000bcH
  00083	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  00086	83 c7 02	 add	 edi, 2

; 2279 : 	m_Snapshot.ar << dwText;

  00089	6a 04		 push	 4
  0008b	8b ce		 mov	 ecx, esi
  0008d	89 7e 08	 mov	 DWORD PTR [esi+8], edi
  00090	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00095	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00098	8b 84 24 14 04
	00 00		 mov	 eax, DWORD PTR _dwText$[esp+1032]
  0009f	89 02		 mov	 DWORD PTR [edx], eax
  000a1	83 46 08 04	 add	 DWORD PTR [esi+8], 4

; 2280 : 	m_Snapshot.ar.WriteString( szBuffer );

  000a5	8d 4c 24 08	 lea	 ecx, DWORD PTR _szBuffer$[esp+1036]
  000a9	51		 push	 ecx
  000aa	8b ce		 mov	 ecx, esi
  000ac	e8 00 00 00 00	 call	 ?WriteString@CAr@@QAEXPBD@Z ; CAr::WriteString
  000b1	5f		 pop	 edi
$L279194:

; 2281 : 	
; 2282 : }

  000b2	8b 8c 24 04 04
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+1032]
  000b9	5e		 pop	 esi
  000ba	33 cc		 xor	 ecx, esp
  000bc	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000c1	81 c4 04 04 00
	00		 add	 esp, 1028		; 00000404H
  000c7	c3		 ret	 0
?AddChatText@CUser@@QAAXHPBDZZ ENDP			; CUser::AddChatText
_TEXT	ENDS
PUBLIC	?AddDefinedText@CUser@@QAEXH@Z			; CUser::AddDefinedText
; Function compile flags: /Ogty
;	COMDAT ?AddDefinedText@CUser@@QAEXH@Z
_TEXT	SEGMENT
_dwText$ = 8						; size = 4
?AddDefinedText@CUser@@QAEXH@Z PROC NEAR		; CUser::AddDefinedText, COMDAT
; _this$ = ecx

; 2286 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	75 63		 jne	 SHORT $L305232

; 2287 : 	
; 2288 : 	
; 2289 : 	m_Snapshot.cb++;

  00006	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  0000d	56		 push	 esi
  0000e	57		 push	 edi

; 2290 : 	m_Snapshot.ar << GetId();

  0000f	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  00015	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  0001b	6a 04		 push	 4
  0001d	8b ce		 mov	 ecx, esi
  0001f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00024	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00027	89 38		 mov	 DWORD PTR [eax], edi
  00029	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0002c	83 c0 04	 add	 eax, 4

; 2291 : 	m_Snapshot.ar << SNAPSHOTTYPE_DEFINEDTEXT1;

  0002f	6a 02		 push	 2
  00031	8b ce		 mov	 ecx, esi
  00033	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00036	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003b	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003e	66 c7 01 94 00	 mov	 WORD PTR [ecx], 148	; 00000094H
  00043	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00046	83 c2 02	 add	 edx, 2

; 2292 : 	m_Snapshot.ar << dwText;

  00049	6a 04		 push	 4
  0004b	8b ce		 mov	 ecx, esi
  0004d	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00050	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00055	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00058	8b 44 24 0c	 mov	 eax, DWORD PTR _dwText$[esp+4]
  0005c	89 02		 mov	 DWORD PTR [edx], eax
  0005e	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00061	83 c0 04	 add	 eax, 4
  00064	5f		 pop	 edi
  00065	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00068	5e		 pop	 esi
$L305232:

; 2293 : 	
; 2294 : }

  00069	c2 04 00	 ret	 4
?AddDefinedText@CUser@@QAEXH@Z ENDP			; CUser::AddDefinedText
_TEXT	ENDS
PUBLIC	?AddDefinedCaption@CUser@@QAAXHHPBDZZ		; CUser::AddDefinedCaption
; Function compile flags: /Ogty
;	COMDAT ?AddDefinedCaption@CUser@@QAAXHHPBDZZ
_TEXT	SEGMENT
_szBuffer$ = -1028					; size = 1024
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
_this$ = 8						; size = 4
_bSmall$ = 12						; size = 4
_dwText$ = 16						; size = 4
_lpszFormat$ = 20					; size = 4
?AddDefinedCaption@CUser@@QAAXHHPBDZZ PROC NEAR		; CUser::AddDefinedCaption, COMDAT

; 2312 : {

  00000	81 ec 04 04 00
	00		 sub	 esp, 1028		; 00000404H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c4		 xor	 eax, esp
  0000d	56		 push	 esi

; 2313 : 	if( IsDelete() )	return;

  0000e	8b b4 24 0c 04
	00 00		 mov	 esi, DWORD PTR _this$[esp+1028]
  00015	89 84 24 04 04
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+1032], eax
  0001c	f6 46 04 01	 test	 BYTE PTR [esi+4], 1
  00020	0f 85 b8 00 00
	00		 jne	 $L279227

; 2314 : 	
; 2315 : 	TCHAR szBuffer[1024];
; 2316 : 	
; 2317 : 	va_list args;
; 2318 : 	va_start( args, lpszFormat );
; 2319 : 	int nBuf = _vsntprintf( szBuffer, sizeof(szBuffer)-1, lpszFormat, args );

  00026	8b 8c 24 18 04
	00 00		 mov	 ecx, DWORD PTR _lpszFormat$[esp+1028]
  0002d	8d 84 24 1c 04
	00 00		 lea	 eax, DWORD PTR _lpszFormat$[esp+1032]
  00034	50		 push	 eax
  00035	51		 push	 ecx
  00036	8d 54 24 0c	 lea	 edx, DWORD PTR _szBuffer$[esp+1040]
  0003a	68 ff 03 00 00	 push	 1023			; 000003ffH
  0003f	52		 push	 edx
  00040	e8 00 00 00 00	 call	 __vsnprintf
  00045	83 c4 10	 add	 esp, 16			; 00000010H

; 2320 : 	va_end( args );
; 2321 : 	
; 2322 : 	if( nBuf < 0 )

  00048	85 c0		 test	 eax, eax
  0004a	0f 8c 8e 00 00
	00		 jl	 $L279227

; 2323 : 		return;
; 2324 : 	
; 2325 : 	
; 2326 : 	m_Snapshot.cb++;

  00050	66 ff 86 0c 57
	00 00		 inc	 WORD PTR [esi+22284]
  00057	57		 push	 edi

; 2327 : 	m_Snapshot.ar << GetId();

  00058	8b be bc 01 00
	00		 mov	 edi, DWORD PTR [esi+444]
  0005e	81 c6 f8 16 00
	00		 add	 esi, 5880		; 000016f8H
  00064	6a 04		 push	 4
  00066	8b ce		 mov	 ecx, esi
  00068	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0006d	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00070	89 38		 mov	 DWORD PTR [eax], edi
  00072	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00075	83 c0 04	 add	 eax, 4

; 2328 : 	m_Snapshot.ar << SNAPSHOTTYPE_DEFINEDCAPTION;

  00078	6a 02		 push	 2
  0007a	8b ce		 mov	 ecx, esi
  0007c	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0007f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00084	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00087	66 c7 01 b9 00	 mov	 WORD PTR [ecx], 185	; 000000b9H
  0008c	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0008f	83 c2 02	 add	 edx, 2

; 2329 : 	m_Snapshot.ar << bSmall;

  00092	6a 04		 push	 4
  00094	8b ce		 mov	 ecx, esi
  00096	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00099	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0009e	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  000a1	8b 84 24 14 04
	00 00		 mov	 eax, DWORD PTR _bSmall$[esp+1032]
  000a8	89 02		 mov	 DWORD PTR [edx], eax
  000aa	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000ad	83 c0 04	 add	 eax, 4

; 2330 : 	m_Snapshot.ar << dwText;

  000b0	6a 04		 push	 4
  000b2	8b ce		 mov	 ecx, esi
  000b4	89 46 08	 mov	 DWORD PTR [esi+8], eax
  000b7	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000bc	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  000bf	8b 94 24 18 04
	00 00		 mov	 edx, DWORD PTR _dwText$[esp+1032]
  000c6	89 11		 mov	 DWORD PTR [ecx], edx
  000c8	8b 56 08	 mov	 edx, DWORD PTR [esi+8]

; 2331 : 	m_Snapshot.ar.WriteString( szBuffer );

  000cb	8d 44 24 08	 lea	 eax, DWORD PTR _szBuffer$[esp+1036]
  000cf	83 c2 04	 add	 edx, 4
  000d2	50		 push	 eax
  000d3	8b ce		 mov	 ecx, esi
  000d5	89 56 08	 mov	 DWORD PTR [esi+8], edx
  000d8	e8 00 00 00 00	 call	 ?WriteString@CAr@@QAEXPBD@Z ; CAr::WriteString
  000dd	5f		 pop	 edi
$L279227:

; 2332 : 	
; 2333 : }

  000de	8b 8c 24 04 04
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+1032]
  000e5	5e		 pop	 esi
  000e6	33 cc		 xor	 ecx, esp
  000e8	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000ed	81 c4 04 04 00
	00		 add	 esp, 1028		; 00000404H
  000f3	c3		 ret	 0
?AddDefinedCaption@CUser@@QAAXHHPBDZZ ENDP		; CUser::AddDefinedCaption
_TEXT	ENDS
PUBLIC	?AddSetGuildQuest@CUser@@QAEXHH@Z		; CUser::AddSetGuildQuest
; Function compile flags: /Ogty
;	COMDAT ?AddSetGuildQuest@CUser@@QAEXHH@Z
_TEXT	SEGMENT
_nQuestId$ = 8						; size = 4
_nState$ = 12						; size = 4
?AddSetGuildQuest@CUser@@QAEXHH@Z PROC NEAR		; CUser::AddSetGuildQuest, COMDAT
; _this$ = ecx

; 2337 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	75 7e		 jne	 SHORT $L305306

; 2338 : 	
; 2339 : 	m_Snapshot.cb++;

  00006	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  0000d	56		 push	 esi
  0000e	57		 push	 edi

; 2340 : 	m_Snapshot.ar << GetId();

  0000f	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  00015	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  0001b	6a 04		 push	 4
  0001d	8b ce		 mov	 ecx, esi
  0001f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00024	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00027	89 38		 mov	 DWORD PTR [eax], edi
  00029	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0002c	83 c2 04	 add	 edx, 4

; 2341 : 	m_Snapshot.ar << SNAPSHOTTYPE_SETGUILDQUEST;

  0002f	6a 02		 push	 2
  00031	8b ce		 mov	 ecx, esi
  00033	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00036	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003b	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003e	66 c7 01 b5 00	 mov	 WORD PTR [ecx], 181	; 000000b5H
  00043	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00046	83 c0 02	 add	 eax, 2

; 2342 : 	m_Snapshot.ar << nQuestId << nState;

  00049	6a 04		 push	 4
  0004b	8b ce		 mov	 ecx, esi
  0004d	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00050	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00055	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00058	8b 44 24 0c	 mov	 eax, DWORD PTR _nQuestId$[esp+4]
  0005c	89 02		 mov	 DWORD PTR [edx], eax
  0005e	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00061	83 c2 04	 add	 edx, 4
  00064	6a 04		 push	 4
  00066	8b ce		 mov	 ecx, esi
  00068	89 56 08	 mov	 DWORD PTR [esi+8], edx
  0006b	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00070	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00073	8b 54 24 10	 mov	 edx, DWORD PTR _nState$[esp+4]
  00077	89 11		 mov	 DWORD PTR [ecx], edx
  00079	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0007c	83 c0 04	 add	 eax, 4
  0007f	5f		 pop	 edi
  00080	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00083	5e		 pop	 esi
$L305306:

; 2343 : 	
; 2344 : }

  00084	c2 08 00	 ret	 8
?AddSetGuildQuest@CUser@@QAEXHH@Z ENDP			; CUser::AddSetGuildQuest
_TEXT	ENDS
PUBLIC	?AddRemoveGuildQuest@CUser@@QAEXH@Z		; CUser::AddRemoveGuildQuest
; Function compile flags: /Ogty
;	COMDAT ?AddRemoveGuildQuest@CUser@@QAEXH@Z
_TEXT	SEGMENT
_nQuestId$ = 8						; size = 4
?AddRemoveGuildQuest@CUser@@QAEXH@Z PROC NEAR		; CUser::AddRemoveGuildQuest, COMDAT
; _this$ = ecx

; 2348 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	75 63		 jne	 SHORT $L305332

; 2349 : 	
; 2350 : 	m_Snapshot.cb++;

  00006	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  0000d	56		 push	 esi
  0000e	57		 push	 edi

; 2351 : 	m_Snapshot.ar << GetId();

  0000f	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  00015	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  0001b	6a 04		 push	 4
  0001d	8b ce		 mov	 ecx, esi
  0001f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00024	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00027	89 38		 mov	 DWORD PTR [eax], edi
  00029	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0002c	83 c0 04	 add	 eax, 4

; 2352 : 	m_Snapshot.ar << SNAPSHOTTYPE_REMOVEGUILDQUEST;

  0002f	6a 02		 push	 2
  00031	8b ce		 mov	 ecx, esi
  00033	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00036	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003b	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003e	66 c7 01 b6 00	 mov	 WORD PTR [ecx], 182	; 000000b6H
  00043	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00046	83 c2 02	 add	 edx, 2

; 2353 : 	m_Snapshot.ar << nQuestId;

  00049	6a 04		 push	 4
  0004b	8b ce		 mov	 ecx, esi
  0004d	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00050	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00055	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00058	8b 44 24 0c	 mov	 eax, DWORD PTR _nQuestId$[esp+4]
  0005c	89 02		 mov	 DWORD PTR [edx], eax
  0005e	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00061	83 c0 04	 add	 eax, 4
  00064	5f		 pop	 edi
  00065	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00068	5e		 pop	 esi
$L305332:

; 2354 : 	
; 2355 : }

  00069	c2 04 00	 ret	 4
?AddRemoveGuildQuest@CUser@@QAEXH@Z ENDP		; CUser::AddRemoveGuildQuest
_TEXT	ENDS
PUBLIC	?AddSetFuel@CUser@@QAEXHK@Z			; CUser::AddSetFuel
; Function compile flags: /Ogty
;	COMDAT ?AddSetFuel@CUser@@QAEXHK@Z
_TEXT	SEGMENT
_nFuel$ = 8						; size = 4
_tmAccFuel$ = 12					; size = 4
?AddSetFuel@CUser@@QAEXHK@Z PROC NEAR			; CUser::AddSetFuel, COMDAT
; _this$ = ecx

; 2439 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	75 7e		 jne	 SHORT $L305363

; 2440 : 	
; 2441 : 	
; 2442 : 	m_Snapshot.cb++;

  00006	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  0000d	56		 push	 esi
  0000e	57		 push	 edi

; 2443 : 	m_Snapshot.ar << GetId();

  0000f	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  00015	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  0001b	6a 04		 push	 4
  0001d	8b ce		 mov	 ecx, esi
  0001f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00024	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00027	89 38		 mov	 DWORD PTR [eax], edi
  00029	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0002c	83 c2 04	 add	 edx, 4

; 2444 : 	m_Snapshot.ar << SNAPSHOTTYPE_SETFUEL;

  0002f	6a 02		 push	 2
  00031	8b ce		 mov	 ecx, esi
  00033	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00036	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003b	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003e	66 c7 01 4b 00	 mov	 WORD PTR [ecx], 75	; 0000004bH
  00043	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00046	83 c0 02	 add	 eax, 2

; 2445 : 	m_Snapshot.ar << nFuel << tmAccFuel;

  00049	6a 04		 push	 4
  0004b	8b ce		 mov	 ecx, esi
  0004d	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00050	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00055	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00058	8b 44 24 0c	 mov	 eax, DWORD PTR _nFuel$[esp+4]
  0005c	89 02		 mov	 DWORD PTR [edx], eax
  0005e	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00061	83 c2 04	 add	 edx, 4
  00064	6a 04		 push	 4
  00066	8b ce		 mov	 ecx, esi
  00068	89 56 08	 mov	 DWORD PTR [esi+8], edx
  0006b	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00070	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00073	8b 54 24 10	 mov	 edx, DWORD PTR _tmAccFuel$[esp+4]
  00077	89 11		 mov	 DWORD PTR [ecx], edx
  00079	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0007c	83 c0 04	 add	 eax, 4
  0007f	5f		 pop	 edi
  00080	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00083	5e		 pop	 esi
$L305363:

; 2446 : 	
; 2447 : }

  00084	c2 08 00	 ret	 8
?AddSetFuel@CUser@@QAEXHK@Z ENDP			; CUser::AddSetFuel
_TEXT	ENDS
PUBLIC	?AddTag@CUser@@QAEXFPBUTAG_ENTRY@@@Z		; CUser::AddTag
EXTRN	?GetInstance@CPlayerDataCenter@@SAPAV1@XZ:NEAR	; CPlayerDataCenter::GetInstance
EXTRN	?GetPlayerString@CPlayerDataCenter@@QAEPBDK@Z:NEAR ; CPlayerDataCenter::GetPlayerString
; Function compile flags: /Ogty
;	COMDAT ?AddTag@CUser@@QAEXFPBUTAG_ENTRY@@@Z
_TEXT	SEGMENT
_uOffset$ = -8						; size = 4
_nBlockSize$ = -4					; size = 4
tv70 = 8						; size = 4
_nTagCount$ = 8						; size = 2
_tags$ = 12						; size = 4
?AddTag@CUser@@QAEXFPBUTAG_ENTRY@@@Z PROC NEAR		; CUser::AddTag, COMDAT
; _this$ = ecx

; 2489 : 	if( IsDelete() )	return;

  00000	8a 41 04	 mov	 al, BYTE PTR [ecx+4]
  00003	83 ec 08	 sub	 esp, 8
  00006	a8 01		 test	 al, 1
  00008	0f 85 eb 00 00
	00		 jne	 $L279335

; 2490 : 	
; 2491 : 	m_Snapshot.cb++;

  0000e	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  00015	53		 push	 ebx
  00016	55		 push	 ebp
  00017	56		 push	 esi
  00018	57		 push	 edi

; 2492 : 	m_Snapshot.ar << GetId();

  00019	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  0001f	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  00025	6a 04		 push	 4
  00027	8b ce		 mov	 ecx, esi
  00029	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0002e	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00031	89 38		 mov	 DWORD PTR [eax], edi
  00033	83 46 08 04	 add	 DWORD PTR [esi+8], 4

; 2493 : 	m_Snapshot.ar << SNAPSHOTTYPE_TAG;

  00037	bf 02 00 00 00	 mov	 edi, 2
  0003c	57		 push	 edi
  0003d	8b ce		 mov	 ecx, esi
  0003f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00044	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00047	66 c7 01 f7 00	 mov	 WORD PTR [ecx], 247	; 000000f7H
  0004c	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0004f	03 cf		 add	 ecx, edi
  00051	89 4e 08	 mov	 DWORD PTR [esi+8], ecx

; 2494 : 
; 2495 : 	u_long uOffset	= m_Snapshot.ar.GetOffset();

  00054	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00057	8b d9		 mov	 ebx, ecx
  00059	2b d8		 sub	 ebx, eax

; 2496 : 	m_Snapshot.ar << (short)0;

  0005b	57		 push	 edi
  0005c	8b ce		 mov	 ecx, esi
  0005e	89 5c 24 14	 mov	 DWORD PTR _uOffset$[esp+28], ebx
  00062	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00067	8b 56 08	 mov	 edx, DWORD PTR [esi+8]

; 2497 : 	
; 2498 : 	short nReal = 0;
; 2499 : 	for( short i=0; i<nTagCount; ++i )

  0006a	66 8b 44 24 1c	 mov	 ax, WORD PTR _nTagCount$[esp+20]
  0006f	66 c7 02 00 00	 mov	 WORD PTR [edx], 0
  00074	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00077	03 d7		 add	 edx, edi
  00079	33 ed		 xor	 ebp, ebp
  0007b	66 85 c0	 test	 ax, ax
  0007e	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00081	7e 62		 jle	 SHORT $L279344
  00083	8b 7c 24 20	 mov	 edi, DWORD PTR _tags$[esp+20]
  00087	0f b7 c0	 movzx	 eax, ax
  0008a	83 c7 08	 add	 edi, 8
  0008d	89 44 24 1c	 mov	 DWORD PTR tv70[esp+20], eax
$L279342:

; 2500 : 	{
; 2501 : #if __VER >= 11 // __SYS_PLAYER_DATA
; 2502 : 		LPCTSTR lpszName = CPlayerDataCenter::GetInstance()->GetPlayerString( tags[i].idFrom );

  00091	8b 4f f8	 mov	 ecx, DWORD PTR [edi-8]
  00094	51		 push	 ecx
  00095	e8 00 00 00 00	 call	 ?GetInstance@CPlayerDataCenter@@SAPAV1@XZ ; CPlayerDataCenter::GetInstance
  0009a	8b c8		 mov	 ecx, eax
  0009c	e8 00 00 00 00	 call	 ?GetPlayerString@CPlayerDataCenter@@QAEPBDK@Z ; CPlayerDataCenter::GetPlayerString

; 2503 : #else	// __SYS_PLAYER_DATA
; 2504 : 		LPCTSTR lpszName = prj.GetPlayerString( tags[i].idFrom );
; 2505 : #endif	// __SYS_PLAYER_DATA
; 2506 : 		if( lpszName )

  000a1	85 c0		 test	 eax, eax
  000a3	74 2f		 je	 SHORT $L279343

; 2507 : 		{
; 2508 : 			TRACE("TAG:%s %d %s\n", lpszName, tags[i].dwDate, tags[i].szString);
; 2509 : 
; 2510 : 			m_Snapshot.ar.WriteString( lpszName );				//  

  000a5	50		 push	 eax
  000a6	8b ce		 mov	 ecx, esi
  000a8	e8 00 00 00 00	 call	 ?WriteString@CAr@@QAEXPBD@Z ; CAr::WriteString

; 2511 : 			m_Snapshot.ar << tags[i].dwDate;					//  

  000ad	8b 5f fc	 mov	 ebx, DWORD PTR [edi-4]
  000b0	6a 04		 push	 4
  000b2	8b ce		 mov	 ecx, esi
  000b4	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000b9	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  000bc	89 1a		 mov	 DWORD PTR [edx], ebx
  000be	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  000c1	83 c2 04	 add	 edx, 4

; 2512 : 			m_Snapshot.ar.WriteString( tags[i].szString );		//   

  000c4	57		 push	 edi
  000c5	8b ce		 mov	 ecx, esi
  000c7	89 56 08	 mov	 DWORD PTR [esi+8], edx
  000ca	e8 00 00 00 00	 call	 ?WriteString@CAr@@QAEXPBD@Z ; CAr::WriteString

; 2513 : 
; 2514 : 			nReal++;

  000cf	8b 5c 24 10	 mov	 ebx, DWORD PTR _uOffset$[esp+24]
  000d3	45		 inc	 ebp
$L279343:
  000d4	8b 44 24 1c	 mov	 eax, DWORD PTR tv70[esp+20]
  000d8	81 c7 08 01 00
	00		 add	 edi, 264		; 00000108H
  000de	48		 dec	 eax
  000df	89 44 24 1c	 mov	 DWORD PTR tv70[esp+20], eax
  000e3	75 ac		 jne	 SHORT $L279342
$L279344:

; 2515 : 		}
; 2516 : 	}
; 2517 : 	GETBLOCK( m_Snapshot.ar, lpBlock, nBlockSize );

  000e5	8d 44 24 14	 lea	 eax, DWORD PTR _nBlockSize$[esp+24]
  000e9	50		 push	 eax
  000ea	8b ce		 mov	 ecx, esi
  000ec	e8 00 00 00 00	 call	 ?GetBuffer@CAr@@QAEPAEPAH@Z ; CAr::GetBuffer
  000f1	5f		 pop	 edi
  000f2	5e		 pop	 esi

; 2518 : 	*(UNALIGNED short*)( lpBlock + uOffset ) = nReal;

  000f3	66 89 2c 18	 mov	 WORD PTR [eax+ebx], bp
  000f7	5d		 pop	 ebp
  000f8	5b		 pop	 ebx
$L279335:

; 2519 : 
; 2520 : 	
; 2521 : }

  000f9	83 c4 08	 add	 esp, 8
  000fc	c2 08 00	 ret	 8
?AddTag@CUser@@QAEXFPBUTAG_ENTRY@@@Z ENDP		; CUser::AddTag
_TEXT	ENDS
PUBLIC	?AddPlayMusic@CUser@@QAEXK@Z			; CUser::AddPlayMusic
; Function compile flags: /Ogty
;	COMDAT ?AddPlayMusic@CUser@@QAEXK@Z
_TEXT	SEGMENT
_idMusic$ = 8						; size = 4
?AddPlayMusic@CUser@@QAEXK@Z PROC NEAR			; CUser::AddPlayMusic, COMDAT
; _this$ = ecx

; 2539 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	75 55		 jne	 SHORT $L305425

; 2540 : 	
; 2541 : 	m_Snapshot.cb++;

  00006	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  0000d	56		 push	 esi

; 2542 : 	m_Snapshot.ar << NULL_ID;

  0000e	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  00014	6a 04		 push	 4
  00016	8b ce		 mov	 ecx, esi
  00018	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0001d	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00020	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [eax], -1
  00026	83 46 08 04	 add	 DWORD PTR [esi+8], 4

; 2543 : 	m_Snapshot.ar << SNAPSHOTTYPE_PLAYMUSIC;

  0002a	6a 02		 push	 2
  0002c	8b ce		 mov	 ecx, esi
  0002e	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00033	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00036	66 c7 01 d1 00	 mov	 WORD PTR [ecx], 209	; 000000d1H
  0003b	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0003e	83 c2 02	 add	 edx, 2

; 2544 : 	m_Snapshot.ar << idMusic;

  00041	6a 04		 push	 4
  00043	8b ce		 mov	 ecx, esi
  00045	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00048	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0004d	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00050	8b 44 24 08	 mov	 eax, DWORD PTR _idMusic$[esp]
  00054	89 02		 mov	 DWORD PTR [edx], eax
  00056	83 46 08 04	 add	 DWORD PTR [esi+8], 4
  0005a	5e		 pop	 esi
$L305425:

; 2545 : 	
; 2546 : }

  0005b	c2 04 00	 ret	 4
?AddPlayMusic@CUser@@QAEXK@Z ENDP			; CUser::AddPlayMusic
_TEXT	ENDS
PUBLIC	?AddPlaySound@CUser@@QAEXK@Z			; CUser::AddPlaySound
; Function compile flags: /Ogty
;	COMDAT ?AddPlaySound@CUser@@QAEXK@Z
_TEXT	SEGMENT
_idSound$ = 8						; size = 4
?AddPlaySound@CUser@@QAEXK@Z PROC NEAR			; CUser::AddPlaySound, COMDAT
; _this$ = ecx

; 2550 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	75 6b		 jne	 SHORT $L305453

; 2551 : 	
; 2552 : 	m_Snapshot.cb++;

  00006	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  0000d	56		 push	 esi

; 2553 : 	m_Snapshot.ar << NULL_ID;

  0000e	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  00014	6a 04		 push	 4
  00016	8b ce		 mov	 ecx, esi
  00018	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0001d	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00020	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [eax], -1
  00026	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00029	83 c0 04	 add	 eax, 4

; 2554 : 	m_Snapshot.ar << SNAPSHOTTYPE_PLAYSOUND;

  0002c	6a 02		 push	 2
  0002e	8b ce		 mov	 ecx, esi
  00030	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00033	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00038	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003b	66 c7 01 d2 00	 mov	 WORD PTR [ecx], 210	; 000000d2H
  00040	83 46 08 02	 add	 DWORD PTR [esi+8], 2

; 2555 : 	m_Snapshot.ar << (BYTE)0;

  00044	6a 01		 push	 1
  00046	8b ce		 mov	 ecx, esi
  00048	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0004d	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00050	c6 02 00	 mov	 BYTE PTR [edx], 0
  00053	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00056	42		 inc	 edx

; 2556 : 	m_Snapshot.ar << idSound;

  00057	6a 04		 push	 4
  00059	8b ce		 mov	 ecx, esi
  0005b	89 56 08	 mov	 DWORD PTR [esi+8], edx
  0005e	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00063	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00066	8b 4c 24 08	 mov	 ecx, DWORD PTR _idSound$[esp]
  0006a	89 08		 mov	 DWORD PTR [eax], ecx
  0006c	83 46 08 04	 add	 DWORD PTR [esi+8], 4
  00070	5e		 pop	 esi
$L305453:

; 2557 : 	
; 2558 : }

  00071	c2 04 00	 ret	 4
?AddPlaySound@CUser@@QAEXK@Z ENDP			; CUser::AddPlaySound
_TEXT	ENDS
PUBLIC	?AddPlaySound2@CUser@@QAEXPBD@Z			; CUser::AddPlaySound2
; Function compile flags: /Ogty
;	COMDAT ?AddPlaySound2@CUser@@QAEXPBD@Z
_TEXT	SEGMENT
_szSound$ = 8						; size = 4
?AddPlaySound2@CUser@@QAEXPBD@Z PROC NEAR		; CUser::AddPlaySound2, COMDAT
; _this$ = ecx

; 2562 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	75 61		 jne	 SHORT $L279375

; 2563 : 	
; 2564 : 	m_Snapshot.cb++;

  00006	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  0000d	56		 push	 esi

; 2565 : 	m_Snapshot.ar << NULL_ID;

  0000e	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  00014	6a 04		 push	 4
  00016	8b ce		 mov	 ecx, esi
  00018	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0001d	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00020	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [eax], -1
  00026	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00029	83 c0 04	 add	 eax, 4

; 2566 : 	m_Snapshot.ar << SNAPSHOTTYPE_PLAYSOUND;

  0002c	6a 02		 push	 2
  0002e	8b ce		 mov	 ecx, esi
  00030	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00033	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00038	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003b	66 c7 01 d2 00	 mov	 WORD PTR [ecx], 210	; 000000d2H
  00040	83 46 08 02	 add	 DWORD PTR [esi+8], 2

; 2567 : 	m_Snapshot.ar << (BYTE)1;

  00044	6a 01		 push	 1
  00046	8b ce		 mov	 ecx, esi
  00048	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0004d	8b 56 08	 mov	 edx, DWORD PTR [esi+8]

; 2568 : 	m_Snapshot.ar.WriteString( szSound );

  00050	8b 44 24 08	 mov	 eax, DWORD PTR _szSound$[esp]
  00054	c6 02 01	 mov	 BYTE PTR [edx], 1
  00057	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0005a	42		 inc	 edx
  0005b	50		 push	 eax
  0005c	8b ce		 mov	 ecx, esi
  0005e	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00061	e8 00 00 00 00	 call	 ?WriteString@CAr@@QAEXPBD@Z ; CAr::WriteString
  00066	5e		 pop	 esi
$L279375:

; 2569 : 	
; 2570 : }

  00067	c2 04 00	 ret	 4
?AddPlaySound2@CUser@@QAEXPBD@Z ENDP			; CUser::AddPlaySound2
_TEXT	ENDS
PUBLIC	?AddMoverFocus@CUser@@QAEXPAVCMover@@@Z		; CUser::AddMoverFocus
; Function compile flags: /Ogty
;	COMDAT ?AddMoverFocus@CUser@@QAEXPAVCMover@@@Z
_TEXT	SEGMENT
$T305524 = -8						; size = 8
_pMover$ = 8						; size = 4
?AddMoverFocus@CUser@@QAEXPAVCMover@@@Z PROC NEAR	; CUser::AddMoverFocus, COMDAT
; _this$ = ecx

; 2574 : 	if( IsDelete() )	return;

  00000	8a 41 04	 mov	 al, BYTE PTR [ecx+4]
  00003	83 ec 08	 sub	 esp, 8
  00006	a8 01		 test	 al, 1
  00008	0f 85 99 00 00
	00		 jne	 $L305523

; 2575 : 	
; 2576 : 	m_Snapshot.cb++;

  0000e	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	57		 push	 edi

; 2577 : 	m_Snapshot.ar << NULL_ID;

  00018	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  0001e	6a 04		 push	 4
  00020	8b ce		 mov	 ecx, esi
  00022	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00027	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0002a	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [eax], -1
  00030	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00033	83 c0 04	 add	 eax, 4

; 2578 : 	m_Snapshot.ar << SNAPSHOTTYPE_MOVERFOCUS;

  00036	6a 02		 push	 2
  00038	8b ce		 mov	 ecx, esi
  0003a	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0003d	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00042	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00045	66 c7 01 3b 00	 mov	 WORD PTR [ecx], 59	; 0000003bH
  0004a	83 46 08 02	 add	 DWORD PTR [esi+8], 2

; 2579 : 	m_Snapshot.ar << pMover->m_idPlayer;

  0004e	8b 7c 24 18	 mov	 edi, DWORD PTR _pMover$[esp+16]
  00052	8b 9f 38 02 00
	00		 mov	 ebx, DWORD PTR [edi+568]
  00058	6a 04		 push	 4
  0005a	8b ce		 mov	 ecx, esi
  0005c	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00061	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00064	89 1a		 mov	 DWORD PTR [edx], ebx
  00066	83 46 08 04	 add	 DWORD PTR [esi+8], 4

; 2580 : 	m_Snapshot.ar << pMover->GetGold();

  0006a	8b 9f 84 16 00
	00		 mov	 ebx, DWORD PTR [edi+5764]
  00070	6a 04		 push	 4
  00072	8b ce		 mov	 ecx, esi
  00074	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00079	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0007c	89 18		 mov	 DWORD PTR [eax], ebx
  0007e	83 46 08 04	 add	 DWORD PTR [esi+8], 4

; 2581 : 	m_Snapshot.ar << pMover->GetExp1();

  00082	8b 8f e8 05 00
	00		 mov	 ecx, DWORD PTR [edi+1512]
  00088	8b 97 ec 05 00
	00		 mov	 edx, DWORD PTR [edi+1516]
  0008e	6a 08		 push	 8
  00090	8d 44 24 10	 lea	 eax, DWORD PTR $T305524[esp+24]
  00094	89 4c 24 10	 mov	 DWORD PTR $T305524[esp+24], ecx
  00098	50		 push	 eax
  00099	8b ce		 mov	 ecx, esi
  0009b	89 54 24 18	 mov	 DWORD PTR $T305524[esp+32], edx
  0009f	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
  000a4	5f		 pop	 edi
  000a5	5e		 pop	 esi
  000a6	5b		 pop	 ebx
$L305523:

; 2582 : 	
; 2583 : }

  000a7	83 c4 08	 add	 esp, 8
  000aa	c2 04 00	 ret	 4
?AddMoverFocus@CUser@@QAEXPAVCMover@@@Z ENDP		; CUser::AddMoverFocus
_TEXT	ENDS
PUBLIC	?AddPartyMapInfo@CUser@@QAEXHUD3DXVECTOR3@@@Z	; CUser::AddPartyMapInfo
; Function compile flags: /Ogty
;	COMDAT ?AddPartyMapInfo@CUser@@QAEXHUD3DXVECTOR3@@@Z
_TEXT	SEGMENT
$T305558 = -12						; size = 12
_nIndex$ = 8						; size = 4
_vPos$ = 12						; size = 12
?AddPartyMapInfo@CUser@@QAEXHUD3DXVECTOR3@@@Z PROC NEAR	; CUser::AddPartyMapInfo, COMDAT
; _this$ = ecx

; 2587 : 	if( IsDelete() )	return;

  00000	8a 41 04	 mov	 al, BYTE PTR [ecx+4]
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	a8 01		 test	 al, 1
  00008	0f 85 80 00 00
	00		 jne	 $L305557

; 2588 : 	
; 2589 : 	m_Snapshot.cb++;

  0000e	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  00015	56		 push	 esi

; 2590 : 	m_Snapshot.ar << NULL_ID;

  00016	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  0001c	6a 04		 push	 4
  0001e	8b ce		 mov	 ecx, esi
  00020	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00025	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00028	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [eax], -1
  0002e	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00031	83 c0 04	 add	 eax, 4

; 2591 : 	m_Snapshot.ar << SNAPSHOTTYPE_PARTYMAPINFO;

  00034	6a 02		 push	 2
  00036	8b ce		 mov	 ecx, esi
  00038	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0003b	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00040	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00043	66 c7 01 3c 00	 mov	 WORD PTR [ecx], 60	; 0000003cH
  00048	83 46 08 02	 add	 DWORD PTR [esi+8], 2

; 2592 : 	m_Snapshot.ar << nIndex;

  0004c	6a 04		 push	 4
  0004e	8b ce		 mov	 ecx, esi
  00050	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00055	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00058	8b 44 24 14	 mov	 eax, DWORD PTR _nIndex$[esp+12]

; 2593 : 	m_Snapshot.ar << vPos;

  0005c	8b 4c 24 18	 mov	 ecx, DWORD PTR _vPos$[esp+12]
  00060	89 02		 mov	 DWORD PTR [edx], eax
  00062	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00065	8b 44 24 20	 mov	 eax, DWORD PTR _vPos$[esp+20]
  00069	83 c2 04	 add	 edx, 4
  0006c	89 4c 24 04	 mov	 DWORD PTR $T305558[esp+16], ecx
  00070	6a 0c		 push	 12			; 0000000cH
  00072	8d 4c 24 08	 lea	 ecx, DWORD PTR $T305558[esp+20]
  00076	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00079	8b 54 24 20	 mov	 edx, DWORD PTR _vPos$[esp+20]
  0007d	51		 push	 ecx
  0007e	8b ce		 mov	 ecx, esi
  00080	89 54 24 10	 mov	 DWORD PTR $T305558[esp+28], edx
  00084	89 44 24 14	 mov	 DWORD PTR $T305558[esp+32], eax
  00088	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
  0008d	5e		 pop	 esi
$L305557:

; 2594 : 	
; 2595 : }

  0008e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00091	c2 10 00	 ret	 16			; 00000010H
?AddPartyMapInfo@CUser@@QAEXHUD3DXVECTOR3@@@Z ENDP	; CUser::AddPartyMapInfo
_TEXT	ENDS
PUBLIC	?AddSetDuel@CUser@@QAEXPAVCMover@@@Z		; CUser::AddSetDuel
; Function compile flags: /Ogty
;	COMDAT ?AddSetDuel@CUser@@QAEXPAVCMover@@@Z
_TEXT	SEGMENT
_pMover$ = 8						; size = 4
?AddSetDuel@CUser@@QAEXPAVCMover@@@Z PROC NEAR		; CUser::AddSetDuel, COMDAT
; _this$ = ecx

; 2611 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	0f 85 c1 00 00
	00		 jne	 $L305610

; 2612 : 	
; 2613 : 	m_Snapshot.cb++;

  0000a	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  00011	53		 push	 ebx
  00012	55		 push	 ebp
  00013	56		 push	 esi
  00014	57		 push	 edi

; 2614 : 	m_Snapshot.ar << GetId();

  00015	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  0001b	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  00021	bb 04 00 00 00	 mov	 ebx, 4
  00026	53		 push	 ebx
  00027	8b ce		 mov	 ecx, esi
  00029	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0002e	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00031	89 38		 mov	 DWORD PTR [eax], edi
  00033	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00036	03 c3		 add	 eax, ebx

; 2615 : 	m_Snapshot.ar << SNAPSHOTTYPE_SETDUEL;

  00038	6a 02		 push	 2
  0003a	8b ce		 mov	 ecx, esi
  0003c	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0003f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00044	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00047	66 c7 01 66 00	 mov	 WORD PTR [ecx], 102	; 00000066H
  0004c	83 46 08 02	 add	 DWORD PTR [esi+8], 2

; 2616 : 	m_Snapshot.ar << pMover->GetId() << pMover->m_nDuel << pMover->m_nDuelState << pMover->m_idDuelOther << pMover->m_idDuelParty;

  00050	8b 7c 24 14	 mov	 edi, DWORD PTR _pMover$[esp+12]
  00054	8b af bc 01 00
	00		 mov	 ebp, DWORD PTR [edi+444]
  0005a	53		 push	 ebx
  0005b	8b ce		 mov	 ecx, esi
  0005d	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00062	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00065	89 2a		 mov	 DWORD PTR [edx], ebp
  00067	01 5e 08	 add	 DWORD PTR [esi+8], ebx
  0006a	8b af 44 07 00
	00		 mov	 ebp, DWORD PTR [edi+1860]
  00070	53		 push	 ebx
  00071	8b ce		 mov	 ecx, esi
  00073	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00078	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0007b	89 28		 mov	 DWORD PTR [eax], ebp
  0007d	01 5e 08	 add	 DWORD PTR [esi+8], ebx
  00080	8b af 40 07 00
	00		 mov	 ebp, DWORD PTR [edi+1856]
  00086	53		 push	 ebx
  00087	8b ce		 mov	 ecx, esi
  00089	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0008e	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00091	89 29		 mov	 DWORD PTR [ecx], ebp
  00093	01 5e 08	 add	 DWORD PTR [esi+8], ebx
  00096	8b af 48 07 00
	00		 mov	 ebp, DWORD PTR [edi+1864]
  0009c	53		 push	 ebx
  0009d	8b ce		 mov	 ecx, esi
  0009f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000a4	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  000a7	89 2a		 mov	 DWORD PTR [edx], ebp
  000a9	01 5e 08	 add	 DWORD PTR [esi+8], ebx
  000ac	8b bf 4c 07 00
	00		 mov	 edi, DWORD PTR [edi+1868]
  000b2	53		 push	 ebx
  000b3	8b ce		 mov	 ecx, esi
  000b5	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000ba	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000bd	89 38		 mov	 DWORD PTR [eax], edi
  000bf	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000c2	03 c3		 add	 eax, ebx
  000c4	5f		 pop	 edi
  000c5	89 46 08	 mov	 DWORD PTR [esi+8], eax
  000c8	5e		 pop	 esi
  000c9	5d		 pop	 ebp
  000ca	5b		 pop	 ebx
$L305610:

; 2617 : 	
; 2618 : }

  000cb	c2 04 00	 ret	 4
?AddSetDuel@CUser@@QAEXPAVCMover@@@Z ENDP		; CUser::AddSetDuel
_TEXT	ENDS
PUBLIC	?AddPKValue@CUser@@QAEXXZ			; CUser::AddPKValue
; Function compile flags: /Ogty
;	COMDAT ?AddPKValue@CUser@@QAEXXZ
_TEXT	SEGMENT
?AddPKValue@CUser@@QAEXXZ PROC NEAR			; CUser::AddPKValue, COMDAT
; _this$ = ecx

; 2622 : {

  00000	57		 push	 edi
  00001	8b f9		 mov	 edi, ecx

; 2623 : 	if( IsDelete() )	return;

  00003	f6 47 04 01	 test	 BYTE PTR [edi+4], 1
  00007	75 72		 jne	 SHORT $L305645

; 2624 : 
; 2625 : 	m_Snapshot.cb++;

  00009	66 ff 87 0c 57
	00 00		 inc	 WORD PTR [edi+22284]
  00010	53		 push	 ebx

; 2626 : 	m_Snapshot.ar << GetId();

  00011	8b 9f bc 01 00
	00		 mov	 ebx, DWORD PTR [edi+444]
  00017	56		 push	 esi
  00018	8d b7 f8 16 00
	00		 lea	 esi, DWORD PTR [edi+5880]
  0001e	6a 04		 push	 4
  00020	8b ce		 mov	 ecx, esi
  00022	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00027	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0002a	89 18		 mov	 DWORD PTR [eax], ebx
  0002c	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0002f	83 c2 04	 add	 edx, 4

; 2627 : 	m_Snapshot.ar << SNAPSHOTTYPE_PK_RELATION;

  00032	6a 02		 push	 2
  00034	8b ce		 mov	 ecx, esi
  00036	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00039	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003e	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00041	66 c7 01 65 00	 mov	 WORD PTR [ecx], 101	; 00000065H
  00046	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00049	83 c0 02	 add	 eax, 2

; 2628 : 	m_Snapshot.ar << PK_PKVALUE;

  0004c	6a 01		 push	 1
  0004e	8b ce		 mov	 ecx, esi
  00050	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00053	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00058	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0005b	c6 02 02	 mov	 BYTE PTR [edx], 2
  0005e	ff 46 08	 inc	 DWORD PTR [esi+8]

; 2629 : 	m_Snapshot.ar << GetPKValue();

  00061	8b bf 5c 07 00
	00		 mov	 edi, DWORD PTR [edi+1884]
  00067	6a 04		 push	 4
  00069	8b ce		 mov	 ecx, esi
  0006b	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00070	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00073	89 38		 mov	 DWORD PTR [eax], edi
  00075	83 46 08 04	 add	 DWORD PTR [esi+8], 4
  00079	5e		 pop	 esi
  0007a	5b		 pop	 ebx
$L305645:
  0007b	5f		 pop	 edi

; 2630 : }

  0007c	c3		 ret	 0
?AddPKValue@CUser@@QAEXXZ ENDP				; CUser::AddPKValue
_TEXT	ENDS
PUBLIC	?AddSnoop@CUser@@QAEXPBD@Z			; CUser::AddSnoop
; Function compile flags: /Ogty
;	COMDAT ?AddSnoop@CUser@@QAEXPBD@Z
_TEXT	SEGMENT
_lpString$ = 8						; size = 4
?AddSnoop@CUser@@QAEXPBD@Z PROC NEAR			; CUser::AddSnoop, COMDAT
; _this$ = ecx

; 2652 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	75 4b		 jne	 SHORT $L279418

; 2653 : 	
; 2654 : 	m_Snapshot.cb++;

  00006	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  0000d	56		 push	 esi

; 2655 : 	m_Snapshot.ar << NULL_ID;

  0000e	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  00014	6a 04		 push	 4
  00016	8b ce		 mov	 ecx, esi
  00018	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0001d	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00020	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [eax], -1
  00026	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00029	83 c0 04	 add	 eax, 4

; 2656 : 	m_Snapshot.ar << SNAPSHOTTYPE_SNOOP;

  0002c	6a 02		 push	 2
  0002e	8b ce		 mov	 ecx, esi
  00030	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00033	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00038	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]

; 2657 : 	m_Snapshot.ar.WriteString( lpString );

  0003b	8b 54 24 08	 mov	 edx, DWORD PTR _lpString$[esp]
  0003f	66 c7 01 93 00	 mov	 WORD PTR [ecx], 147	; 00000093H
  00044	83 46 08 02	 add	 DWORD PTR [esi+8], 2
  00048	52		 push	 edx
  00049	8b ce		 mov	 ecx, esi
  0004b	e8 00 00 00 00	 call	 ?WriteString@CAr@@QAEXPBD@Z ; CAr::WriteString
  00050	5e		 pop	 esi
$L279418:

; 2658 : 	
; 2659 : }

  00051	c2 04 00	 ret	 4
?AddSnoop@CUser@@QAEXPBD@Z ENDP				; CUser::AddSnoop
_TEXT	ENDS
PUBLIC	?AddSetCheerParam@CUser@@QAEXHKH@Z		; CUser::AddSetCheerParam
; Function compile flags: /Ogty
;	COMDAT ?AddSetCheerParam@CUser@@QAEXHKH@Z
_TEXT	SEGMENT
_nCheerPoint$ = 8					; size = 4
_dwRest$ = 12						; size = 4
_bAdd$ = 16						; size = 4
?AddSetCheerParam@CUser@@QAEXHKH@Z PROC NEAR		; CUser::AddSetCheerParam, COMDAT
; _this$ = ecx

; 2663 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	0f 85 98 00 00
	00		 jne	 $L305707

; 2664 : 	
; 2665 : 	m_Snapshot.cb++;

  0000a	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  00011	53		 push	 ebx
  00012	56		 push	 esi
  00013	57		 push	 edi

; 2666 : 	m_Snapshot.ar << GETID( this );

  00014	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  0001a	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  00020	bb 04 00 00 00	 mov	 ebx, 4
  00025	53		 push	 ebx
  00026	8b ce		 mov	 ecx, esi
  00028	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0002d	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00030	89 38		 mov	 DWORD PTR [eax], edi
  00032	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00035	03 c3		 add	 eax, ebx

; 2667 : 	m_Snapshot.ar << SNAPSHOTTYPE_SETCHEERPARAM;

  00037	6a 02		 push	 2
  00039	8b ce		 mov	 ecx, esi
  0003b	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0003e	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00043	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00046	66 c7 01 b4 00	 mov	 WORD PTR [ecx], 180	; 000000b4H
  0004b	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0004e	83 c2 02	 add	 edx, 2

; 2668 : 	m_Snapshot.ar << nCheerPoint << dwRest;

  00051	53		 push	 ebx
  00052	8b ce		 mov	 ecx, esi
  00054	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00057	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0005c	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0005f	8b 44 24 10	 mov	 eax, DWORD PTR _nCheerPoint$[esp+8]
  00063	89 02		 mov	 DWORD PTR [edx], eax
  00065	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00068	03 c3		 add	 eax, ebx
  0006a	53		 push	 ebx
  0006b	8b ce		 mov	 ecx, esi
  0006d	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00070	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00075	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00078	8b 54 24 14	 mov	 edx, DWORD PTR _dwRest$[esp+8]
  0007c	89 11		 mov	 DWORD PTR [ecx], edx
  0007e	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00081	03 d3		 add	 edx, ebx

; 2669 : 	m_Snapshot.ar << bAdd; // chipi_080412

  00083	53		 push	 ebx
  00084	8b ce		 mov	 ecx, esi
  00086	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00089	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0008e	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00091	8b 4c 24 18	 mov	 ecx, DWORD PTR _bAdd$[esp+8]
  00095	89 08		 mov	 DWORD PTR [eax], ecx
  00097	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0009a	03 c3		 add	 eax, ebx
  0009c	5f		 pop	 edi
  0009d	89 46 08	 mov	 DWORD PTR [esi+8], eax
  000a0	5e		 pop	 esi
  000a1	5b		 pop	 ebx
$L305707:

; 2670 : 	
; 2671 : }

  000a2	c2 0c 00	 ret	 12			; 0000000cH
?AddSetCheerParam@CUser@@QAEXHKH@Z ENDP			; CUser::AddSetCheerParam
_TEXT	ENDS
PUBLIC	?AddQueryEquip@CUser@@QAEXPAV1@@Z		; CUser::AddQueryEquip
EXTRN	?GetEquipItem@CMover@@QAEPAVCItemElem@@H@Z:NEAR	; CMover::GetEquipItem
; Function compile flags: /Ogty
;	COMDAT ?AddQueryEquip@CUser@@QAEXPAV1@@Z
_TEXT	SEGMENT
_cbEquip$ = -20						; size = 4
_uOffset$ = -16						; size = 4
_nBlockSize$ = -12					; size = 4
$T305759 = -8						; size = 8
_pUser$ = 8						; size = 4
?AddQueryEquip@CUser@@QAEXPAV1@@Z PROC NEAR		; CUser::AddQueryEquip, COMDAT
; _this$ = ecx

; 2674 : {

  00000	83 ec 14	 sub	 esp, 20			; 00000014H
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 2675 : 	if( IsDelete() )	return;

  00006	f6 46 04 01	 test	 BYTE PTR [esi+4], 1
  0000a	0f 85 31 01 00
	00		 jne	 $L279432

; 2676 : 	
; 2677 : 	m_Snapshot.cb++;

  00010	66 ff 86 0c 57
	00 00		 inc	 WORD PTR [esi+22284]
  00017	53		 push	 ebx
  00018	55		 push	 ebp
  00019	57		 push	 edi

; 2678 : 	m_Snapshot.ar << GETID( pUser );

  0001a	8b 7c 24 28	 mov	 edi, DWORD PTR _pUser$[esp+32]
  0001e	85 ff		 test	 edi, edi
  00020	74 08		 je	 SHORT $L305712
  00022	8b 9f bc 01 00
	00		 mov	 ebx, DWORD PTR [edi+444]
  00028	eb 03		 jmp	 SHORT $L305713
$L305712:
  0002a	83 cb ff	 or	 ebx, -1
$L305713:
  0002d	81 c6 f8 16 00
	00		 add	 esi, 5880		; 000016f8H
  00033	bd 04 00 00 00	 mov	 ebp, 4
  00038	55		 push	 ebp
  00039	8b ce		 mov	 ecx, esi
  0003b	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00040	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00043	89 18		 mov	 DWORD PTR [eax], ebx
  00045	01 6e 08	 add	 DWORD PTR [esi+8], ebp

; 2679 : 	m_Snapshot.ar << SNAPSHOTTYPE_QUERYEQUIP;

  00048	6a 02		 push	 2
  0004a	8b ce		 mov	 ecx, esi
  0004c	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00051	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00054	66 c7 01 ac 00	 mov	 WORD PTR [ecx], 172	; 000000acH
  00059	8b 5e 08	 mov	 ebx, DWORD PTR [esi+8]
  0005c	83 c3 02	 add	 ebx, 2
  0005f	89 5e 08	 mov	 DWORD PTR [esi+8], ebx

; 2680 : 
; 2681 : 	u_long uOffset	= m_Snapshot.ar.GetOffset();

  00062	2b 5e 10	 sub	 ebx, DWORD PTR [esi+16]

; 2682 : 	int cbEquip		= 0;
; 2683 : 	
; 2684 : 	m_Snapshot.ar << cbEquip;

  00065	55		 push	 ebp
  00066	8b ce		 mov	 ecx, esi
  00068	89 5c 24 18	 mov	 DWORD PTR _uOffset$[esp+40], ebx
  0006c	c7 44 24 14 00
	00 00 00	 mov	 DWORD PTR _cbEquip$[esp+40], 0
  00074	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00079	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0007c	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0
  00082	01 6e 08	 add	 DWORD PTR [esi+8], ebp

; 2685 : 	
; 2686 : 	for( int i = 0; i < MAX_HUMAN_PARTS; i++ )

  00085	33 ed		 xor	 ebp, ebp
  00087	eb 07		 jmp	 SHORT $L279438
$L305781:
  00089	8b 7c 24 28	 mov	 edi, DWORD PTR _pUser$[esp+32]
  0008d	8d 49 00	 npad	 3
$L279438:

; 2687 : 	{
; 2688 : 		CItemElem* pItemElem	= pUser->GetEquipItem( i );

  00090	55		 push	 ebp
  00091	8b cf		 mov	 ecx, edi
  00093	e8 00 00 00 00	 call	 ?GetEquipItem@CMover@@QAEPAVCItemElem@@H@Z ; CMover::GetEquipItem
  00098	8b f8		 mov	 edi, eax

; 2689 : 		if( pItemElem )

  0009a	85 ff		 test	 edi, edi
  0009c	0f 84 7f 00 00
	00		 je	 $L279439

; 2690 : 		{
; 2691 : 			m_Snapshot.ar << i;

  000a2	6a 04		 push	 4
  000a4	8b ce		 mov	 ecx, esi
  000a6	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000ab	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000ae	89 28		 mov	 DWORD PTR [eax], ebp
  000b0	83 46 08 04	 add	 DWORD PTR [esi+8], 4

; 2692 : 			m_Snapshot.ar << pItemElem->GetRandomOptItemId();

  000b4	8b 8f 98 00 00
	00		 mov	 ecx, DWORD PTR [edi+152]
  000ba	8b 97 9c 00 00
	00		 mov	 edx, DWORD PTR [edi+156]
  000c0	6a 08		 push	 8
  000c2	8d 44 24 20	 lea	 eax, DWORD PTR $T305759[esp+40]
  000c6	89 4c 24 20	 mov	 DWORD PTR $T305759[esp+40], ecx
  000ca	50		 push	 eax
  000cb	8b ce		 mov	 ecx, esi
  000cd	89 54 24 28	 mov	 DWORD PTR $T305759[esp+48], edx
  000d1	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write

; 2693 : //			m_Snapshot.ar.Write( &pItemElem->m_piercingInfo, sizeof(PIERCINGINFO) );
; 2694 : 			pItemElem->SerializePiercing( m_Snapshot.ar );

  000d6	8b 57 3c	 mov	 edx, DWORD PTR [edi+60]
  000d9	8d 4f 3c	 lea	 ecx, DWORD PTR [edi+60]
  000dc	56		 push	 esi
  000dd	ff 52 04	 call	 DWORD PTR [edx+4]

; 2695 : 			m_Snapshot.ar << pItemElem->m_bItemResist;

  000e0	8a 9f 88 00 00
	00		 mov	 bl, BYTE PTR [edi+136]
  000e6	6a 01		 push	 1
  000e8	8b ce		 mov	 ecx, esi
  000ea	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000ef	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000f2	88 18		 mov	 BYTE PTR [eax], bl
  000f4	ff 46 08	 inc	 DWORD PTR [esi+8]

; 2696 : 			m_Snapshot.ar << pItemElem->m_nResistAbilityOption;

  000f7	8b bf 8c 00 00
	00		 mov	 edi, DWORD PTR [edi+140]
  000fd	6a 04		 push	 4
  000ff	8b ce		 mov	 ecx, esi
  00101	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00106	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]

; 2697 : 			cbEquip++;

  00109	8b 44 24 10	 mov	 eax, DWORD PTR _cbEquip$[esp+36]
  0010d	8b 5c 24 14	 mov	 ebx, DWORD PTR _uOffset$[esp+36]
  00111	89 39		 mov	 DWORD PTR [ecx], edi
  00113	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00116	83 c1 04	 add	 ecx, 4
  00119	40		 inc	 eax
  0011a	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  0011d	89 44 24 10	 mov	 DWORD PTR _cbEquip$[esp+36], eax
$L279439:
  00121	45		 inc	 ebp
  00122	83 fd 1f	 cmp	 ebp, 31			; 0000001fH
  00125	0f 8c 5e ff ff
	ff		 jl	 $L305781

; 2698 : 		}
; 2699 : 	}
; 2700 : 
; 2701 : 	GETBLOCK( m_Snapshot.ar, lpBlock, nBlockSize );

  0012b	8d 54 24 18	 lea	 edx, DWORD PTR _nBlockSize$[esp+36]
  0012f	52		 push	 edx
  00130	8b ce		 mov	 ecx, esi
  00132	e8 00 00 00 00	 call	 ?GetBuffer@CAr@@QAEPAEPAH@Z ; CAr::GetBuffer

; 2702 : 	*(UNALIGNED int*)( lpBlock + uOffset )	= cbEquip;

  00137	8b 4c 24 10	 mov	 ecx, DWORD PTR _cbEquip$[esp+36]
  0013b	5f		 pop	 edi
  0013c	5d		 pop	 ebp
  0013d	89 0c 18	 mov	 DWORD PTR [eax+ebx], ecx
  00140	5b		 pop	 ebx
$L279432:
  00141	5e		 pop	 esi

; 2703 : 
; 2704 : 	
; 2705 : }

  00142	83 c4 14	 add	 esp, 20			; 00000014H
  00145	c2 04 00	 ret	 4
?AddQueryEquip@CUser@@QAEXPAV1@@Z ENDP			; CUser::AddQueryEquip
_TEXT	ENDS
PUBLIC	?DoUsePackItem@CUser@@QAEXPAVCItemElem@@PAU_PACKITEMELEM@@@Z ; CUser::DoUsePackItem
PUBLIC	??_C@_04OEDFLLKD@?$CC?$CFs?$CC?$AA@		; `string'
PUBLIC	??_C@_04EDDHFNCG@PACK?$AA@			; `string'
PUBLIC	??_C@_01DDCIFGEA@E?$AA@				; `string'
EXTRN	?PutCreateItemLog@CDPSrvr@@QAEXPAVCUser@@PAVCItemElem@@PBD2@Z:NEAR ; CDPSrvr::PutCreateItemLog
EXTRN	?CreateItem@CMover@@QAEHPAVCItemBase@@PAEPAFE@Z:NEAR ; CMover::CreateItem
EXTRN	??0CItemElem@@QAE@XZ:NEAR			; CItemElem::CItemElem
EXTRN	??1CItemElem@@UAE@XZ:NEAR			; CItemElem::~CItemElem
EXTRN	?IsBinds@CItemElem@@QAEHXZ:NEAR			; CItemElem::IsBinds
EXTRN	?OnAfterUseItem@CMover@@QAEXPBUItemProp@@@Z:NEAR ; CMover::OnAfterUseItem
EXTRN	__except_list:DWORD
EXTRN	___CxxFrameHandler:NEAR
;	COMDAT xdata$x
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\data.h
xdata$x	SEGMENT
$T306053 DD	0ffffffffH
	DD	FLAT:$L305788
$T306040 DD	019930520H
	DD	01H
	DD	FLAT:$T306053
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_C@_04OEDFLLKD@?$CC?$CFs?$CC?$AA@
CONST	SEGMENT
??_C@_04OEDFLLKD@?$CC?$CFs?$CC?$AA@ DB '"%s"', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04EDDHFNCG@PACK?$AA@
CONST	SEGMENT
??_C@_04EDDHFNCG@PACK?$AA@ DB 'PACK', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01DDCIFGEA@E?$AA@
CONST	SEGMENT
??_C@_01DDCIFGEA@E?$AA@ DB 'E', 00H			; `string'
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
CONST	ENDS
;	COMDAT ?DoUsePackItem@CUser@@QAEXPAVCItemElem@@PAU_PACKITEMELEM@@@Z
_TEXT	SEGMENT
$T306037 = -212						; size = 4
_time$279491 = -208					; size = 8
_t$ = -208						; size = 4
_itemElem$279501 = -200					; size = 184
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_pItemElem$ = 8						; size = 4
_pPackItemElem$ = 12					; size = 4
?DoUsePackItem@CUser@@QAEXPAVCItemElem@@PAU_PACKITEMELEM@@@Z PROC NEAR ; CUser::DoUsePackItem, COMDAT
; _this$ = ecx

; 2763 : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?DoUsePackItem@CUser@@QAEXPAVCItemElem@@PAU_PACKITEMELEM@@@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	81 ec c8 00 00
	00		 sub	 esp, 200		; 000000c8H
  0001b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00020	33 c4		 xor	 eax, esp
  00022	53		 push	 ebx
  00023	55		 push	 ebp
  00024	8b ac 24 e4 00
	00 00		 mov	 ebp, DWORD PTR _pPackItemElem$[esp+216]
  0002b	56		 push	 esi
  0002c	89 84 24 d0 00
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+224], eax

; 2764 : 	time_t t	= 0;
; 2765 : 	if( pPackItemElem->nSpan )	// minutes

  00033	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  00036	85 c0		 test	 eax, eax
  00038	57		 push	 edi
  00039	8b bc 24 e8 00
	00 00		 mov	 edi, DWORD PTR _pItemElem$[esp+224]
  00040	8b d9		 mov	 ebx, ecx
  00042	89 7c 24 10	 mov	 DWORD PTR $T306037[esp+228], edi
  00046	c7 44 24 14 00
	00 00 00	 mov	 DWORD PTR _t$[esp+228], 0
  0004e	74 2a		 je	 SHORT $L279490

; 2766 : 	{
; 2767 : 		CTime time	= CTime::GetCurrentTime() + CTimeSpan( 0, 0, pPackItemElem->nSpan, 0 );

  00050	6a 00		 push	 0
  00052	99		 cdq
  00053	6a 3c		 push	 60			; 0000003cH
  00055	52		 push	 edx
  00056	50		 push	 eax
  00057	e8 00 00 00 00	 call	 __allmul
  0005c	6a 00		 push	 0
  0005e	8b f0		 mov	 esi, eax
  00060	8b fa		 mov	 edi, edx
  00062	e8 00 00 00 00	 call	 __time64
  00067	83 c4 04	 add	 esp, 4
  0006a	03 f0		 add	 esi, eax
  0006c	13 fa		 adc	 edi, edx
  0006e	89 7c 24 18	 mov	 DWORD PTR _time$279491[esp+232], edi

; 2768 : 		t	= (time_t)( time.GetTime() );

  00072	8b 7c 24 10	 mov	 edi, DWORD PTR $T306037[esp+228]
  00076	89 74 24 14	 mov	 DWORD PTR _t$[esp+228], esi
$L279490:

; 2769 : 	}
; 2770 : 
; 2771 : 	if( m_Inventory.GetEmptyCount() >= pPackItemElem->nSize )

  0007a	8b 8b 9c 0b 00
	00		 mov	 ecx, DWORD PTR [ebx+2972]
  00080	33 d2		 xor	 edx, edx
  00082	85 c9		 test	 ecx, ecx
  00084	76 24		 jbe	 SHORT $L305828
  00086	8b 83 a0 0b 00
	00		 mov	 eax, DWORD PTR [ebx+2976]
  0008c	83 c0 08	 add	 eax, 8
  0008f	90		 npad	 1
$L306046:
  00090	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  00093	85 f6		 test	 esi, esi
  00095	75 0b		 jne	 SHORT $L305827
  00097	8b 30		 mov	 esi, DWORD PTR [eax]
  00099	3b b3 98 0b 00
	00		 cmp	 esi, DWORD PTR [ebx+2968]
  0009f	73 01		 jae	 SHORT $L305827
  000a1	42		 inc	 edx
$L305827:
  000a2	05 b8 00 00 00	 add	 eax, 184		; 000000b8H
  000a7	49		 dec	 ecx
  000a8	75 e6		 jne	 SHORT $L306046
$L305828:
  000aa	8b 45 04	 mov	 eax, DWORD PTR [ebp+4]
  000ad	3b d0		 cmp	 edx, eax
  000af	0f 8c 9c 01 00
	00		 jl	 $L279496

; 2772 : 	{
; 2773 : 		for( int i = 0; i < pPackItemElem->nSize; i++ )

  000b5	33 f6		 xor	 esi, esi
  000b7	85 c0		 test	 eax, eax
  000b9	0f 8e 38 01 00
	00		 jle	 $L279500
  000bf	8d 7d 4c	 lea	 edi, DWORD PTR [ebp+76]
$L279498:

; 2774 : 		{
; 2775 : 			CItemElem itemElem;

  000c2	8d 4c 24 1c	 lea	 ecx, DWORD PTR _itemElem$279501[esp+228]
  000c6	e8 00 00 00 00	 call	 ??0CItemElem@@QAE@XZ	; CItemElem::CItemElem

; 2776 : 			itemElem.m_dwItemId	= pPackItemElem->adwItem[i];

  000cb	8b 47 c0	 mov	 eax, DWORD PTR [edi-64]

; 2777 : 			itemElem.SetAbilityOption( pPackItemElem->anAbilityOption[i] );
; 2778 : 			itemElem.m_nItemNum	= pPackItemElem->anNum[i];
; 2779 : 			itemElem.m_bCharged		= itemElem.GetProp()->bCharged;

  000ce	85 c0		 test	 eax, eax
  000d0	8b 0f		 mov	 ecx, DWORD PTR [edi]
  000d2	66 8b 57 40	 mov	 dx, WORD PTR [edi+64]
  000d6	89 8c 24 8c 00
	00 00		 mov	 DWORD PTR _itemElem$279501[esp+340], ecx
  000dd	8b 0d 5c 02 00
	00		 mov	 ecx, DWORD PTR ?prj@@3VCProject@@A+604
  000e3	c7 84 24 e0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+236], 0
  000ee	89 44 24 28	 mov	 DWORD PTR _itemElem$279501[esp+240], eax
  000f2	66 89 94 24 9c
	00 00 00	 mov	 WORD PTR _itemElem$279501[esp+356], dx
  000fa	7c 11		 jl	 SHORT $L305888
  000fc	3b c1		 cmp	 eax, ecx
  000fe	7d 0d		 jge	 SHORT $L305888
  00100	73 21		 jae	 SHORT $L306050
  00102	8b 0d 4c 02 00
	00		 mov	 ecx, DWORD PTR ?prj@@3VCProject@@A+588
  00108	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  0010b	eb 18		 jmp	 SHORT $L305883
$L305888:
  0010d	50		 push	 eax
  0010e	51		 push	 ecx
  0010f	6a 00		 push	 0
  00111	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BI@BEIFNGEL@GetItemProp?5range_error?$AA@
  00116	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@HMFGHCP@?$CFs?5min?3?$CFd?0?5max?3?$CFd?0?5index?3?$CFd?$AA@
  0011b	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  00120	83 c4 14	 add	 esp, 20			; 00000014H
$L306050:
  00123	33 c0		 xor	 eax, eax
$L305883:
  00125	8b 90 ec 00 00
	00		 mov	 edx, DWORD PTR [eax+236]

; 2780 : 			itemElem.m_dwKeepTime	= (DWORD)t;

  0012b	8b 44 24 14	 mov	 eax, DWORD PTR _t$[esp+228]

; 2781 : 
; 2782 : //			if( pItemElem->IsFlag( CItemElem::binds ) )
; 2783 : 			if( pItemElem->IsBinds() )

  0012f	8b 4c 24 10	 mov	 ecx, DWORD PTR $T306037[esp+228]
  00133	89 94 24 c8 00
	00 00		 mov	 DWORD PTR _itemElem$279501[esp+400], edx
  0013a	89 84 24 cc 00
	00 00		 mov	 DWORD PTR _itemElem$279501[esp+404], eax
  00141	e8 00 00 00 00	 call	 ?IsBinds@CItemElem@@QAEHXZ ; CItemElem::IsBinds
  00146	85 c0		 test	 eax, eax
  00148	74 08		 je	 SHORT $L305905

; 2784 : 				itemElem.SetFlag( CItemElem::binds );

  0014a	80 8c 24 9e 00
	00 00 02	 or	 BYTE PTR _itemElem$279501[esp+358], 2
$L305905:

; 2785 : 
; 2786 : 			if( CreateItem( &itemElem ) )

  00152	6a 00		 push	 0
  00154	6a 00		 push	 0
  00156	6a 00		 push	 0
  00158	8d 4c 24 28	 lea	 ecx, DWORD PTR _itemElem$279501[esp+240]
  0015c	51		 push	 ecx
  0015d	8b cb		 mov	 ecx, ebx
  0015f	e8 00 00 00 00	 call	 ?CreateItem@CMover@@QAEHPAVCItemBase@@PAEPAFE@Z ; CMover::CreateItem
  00164	85 c0		 test	 eax, eax
  00166	74 68		 je	 SHORT $L279504

; 2787 : 			{
; 2788 : 				AddDefinedText( TID_GAME_REAPITEM, "\"%s\"", itemElem.GetProp()->szName );

  00168	8b 44 24 28	 mov	 eax, DWORD PTR _itemElem$279501[esp+240]
  0016c	85 c0		 test	 eax, eax
  0016e	8b 0d 5c 02 00
	00		 mov	 ecx, DWORD PTR ?prj@@3VCProject@@A+604
  00174	7c 11		 jl	 SHORT $L305956
  00176	3b c1		 cmp	 eax, ecx
  00178	7d 0d		 jge	 SHORT $L305956
  0017a	73 21		 jae	 SHORT $L306051
  0017c	8b 15 4c 02 00
	00		 mov	 edx, DWORD PTR ?prj@@3VCProject@@A+588
  00182	8b 04 82	 mov	 eax, DWORD PTR [edx+eax*4]
  00185	eb 18		 jmp	 SHORT $L305951
$L305956:
  00187	50		 push	 eax
  00188	51		 push	 ecx
  00189	6a 00		 push	 0
  0018b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BI@BEIFNGEL@GetItemProp?5range_error?$AA@
  00190	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@HMFGHCP@?$CFs?5min?3?$CFd?0?5max?3?$CFd?0?5index?3?$CFd?$AA@
  00195	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  0019a	83 c4 14	 add	 esp, 20			; 00000014H
$L306051:
  0019d	33 c0		 xor	 eax, eax
$L305951:
  0019f	83 c0 04	 add	 eax, 4
  001a2	50		 push	 eax
  001a3	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_04OEDFLLKD@?$CC?$CFs?$CC?$AA@
  001a8	68 74 02 00 00	 push	 628			; 00000274H
  001ad	53		 push	 ebx
  001ae	e8 00 00 00 00	 call	 ?AddDefinedText@CUser@@QAAXHPBDZZ ; CUser::AddDefinedText
  001b3	83 c4 10	 add	 esp, 16			; 00000010H

; 2789 : 				g_DPSrvr.PutCreateItemLog( this, &itemElem , "E", "PACK" );

  001b6	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_04EDDHFNCG@PACK?$AA@
  001bb	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_01DDCIFGEA@E?$AA@
  001c0	8d 44 24 24	 lea	 eax, DWORD PTR _itemElem$279501[esp+236]
  001c4	50		 push	 eax
  001c5	53		 push	 ebx
  001c6	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_DPSrvr@@3VCDPSrvr@@A
  001cb	e8 00 00 00 00	 call	 ?PutCreateItemLog@CDPSrvr@@QAEXPAVCUser@@PAVCItemElem@@PBD2@Z ; CDPSrvr::PutCreateItemLog
$L279504:

; 2790 : //				ItemProp* pItemProp		= itemElem.GetProp();
; 2791 : //				if( pItemProp->dwSfxObj3 != -1 )
; 2792 : //					g_UserMng.AddCreateSfxObj( this, pItemProp->dwSfxObj3, GetPos().x, GetPos().y, GetPos().z );
; 2793 : 			}
; 2794 : 			else
; 2795 : 			{
; 2796 : 				// critical err
; 2797 : 			}
; 2798 : 		}

  001d0	8d 4c 24 1c	 lea	 ecx, DWORD PTR _itemElem$279501[esp+228]
  001d4	c7 84 24 e0 00
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+236], -1
  001df	e8 00 00 00 00	 call	 ??1CItemElem@@UAE@XZ	; CItemElem::~CItemElem
  001e4	8b 45 04	 mov	 eax, DWORD PTR [ebp+4]
  001e7	46		 inc	 esi
  001e8	83 c7 04	 add	 edi, 4
  001eb	3b f0		 cmp	 esi, eax
  001ed	0f 8c cf fe ff
	ff		 jl	 $L279498

; 2772 : 	{
; 2773 : 		for( int i = 0; i < pPackItemElem->nSize; i++ )

  001f3	8b 7c 24 10	 mov	 edi, DWORD PTR $T306037[esp+228]
$L279500:

; 2799 : 		OnAfterUseItem( pItemElem->GetProp() );

  001f7	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  001fa	85 c0		 test	 eax, eax
  001fc	8b 0d 5c 02 00
	00		 mov	 ecx, DWORD PTR ?prj@@3VCProject@@A+604
  00202	7c 11		 jl	 SHORT $L306022
  00204	3b c1		 cmp	 eax, ecx
  00206	7d 0d		 jge	 SHORT $L306022
  00208	73 21		 jae	 SHORT $L306052
  0020a	8b 0d 4c 02 00
	00		 mov	 ecx, DWORD PTR ?prj@@3VCProject@@A+588
  00210	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  00213	eb 18		 jmp	 SHORT $L306017
$L306022:
  00215	50		 push	 eax
  00216	51		 push	 ecx
  00217	6a 00		 push	 0
  00219	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BI@BEIFNGEL@GetItemProp?5range_error?$AA@
  0021e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@HMFGHCP@?$CFs?5min?3?$CFd?0?5max?3?$CFd?0?5index?3?$CFd?$AA@
  00223	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  00228	83 c4 14	 add	 esp, 20			; 00000014H
$L306052:
  0022b	33 c0		 xor	 eax, eax
$L306017:
  0022d	50		 push	 eax
  0022e	8b cb		 mov	 ecx, ebx
  00230	e8 00 00 00 00	 call	 ?OnAfterUseItem@CMover@@QAEXPBUItemProp@@@Z ; CMover::OnAfterUseItem

; 2800 : 		UpdateItem( (BYTE)( pItemElem->m_dwObjId ), UI_NUM, pItemElem->m_nItemNum - 1 );

  00235	0f bf 97 80 00
	00 00		 movsx	 edx, WORD PTR [edi+128]
  0023c	33 c0		 xor	 eax, eax
  0023e	8a 47 04	 mov	 al, BYTE PTR [edi+4]
  00241	6a 00		 push	 0
  00243	4a		 dec	 edx
  00244	52		 push	 edx
  00245	6a 00		 push	 0
  00247	8b cb		 mov	 ecx, ebx
  00249	50		 push	 eax
  0024a	e8 00 00 00 00	 call	 ?UpdateItem@CMover@@QAEXEDKK@Z ; CMover::UpdateItem

; 2801 : 	}
; 2802 : 	else

  0024f	eb 0c		 jmp	 SHORT $L279510
$L279496:

; 2803 : 	{
; 2804 : 		AddDefinedText( TID_GAME_LACKSPACE );			

  00251	68 72 02 00 00	 push	 626			; 00000272H
  00256	8b cb		 mov	 ecx, ebx
  00258	e8 00 00 00 00	 call	 ?AddDefinedText@CUser@@QAEXH@Z ; CUser::AddDefinedText
$L279510:

; 2805 : 	}
; 2806 : }

  0025d	8b 8c 24 d8 00
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+228]
  00264	5f		 pop	 edi
  00265	5e		 pop	 esi
  00266	5d		 pop	 ebp
  00267	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0026e	8b 8c 24 c8 00
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+216]
  00275	5b		 pop	 ebx
  00276	33 cc		 xor	 ecx, esp
  00278	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0027d	81 c4 d4 00 00
	00		 add	 esp, 212		; 000000d4H
  00283	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L305788:
  00000	8d 8d 38 ff ff
	ff		 lea	 ecx, DWORD PTR _itemElem$279501[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CItemElem@@UAE@XZ	; CItemElem::~CItemElem
__ehhandler$?DoUsePackItem@CUser@@QAEXPAVCItemElem@@PAU_PACKITEMELEM@@@Z:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T306040
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?DoUsePackItem@CUser@@QAEXPAVCItemElem@@PAU_PACKITEMELEM@@@Z ENDP ; CUser::DoUsePackItem
PUBLIC	?DoUseGiftbox@CUser@@QAEHPAVCItemElem@@K@Z	; CUser::DoUseGiftbox
PUBLIC	??_C@_07EEDNNGKF@GIFTBOX?$AA@			; `string'
EXTRN	?GetInstance@CGiftboxMan@@SAPAV1@XZ:NEAR	; CGiftboxMan::GetInstance
EXTRN	?Open@CGiftboxMan@@QAEHKPAU_GIFTBOXRESULT@@@Z:NEAR ; CGiftboxMan::Open
EXTRN	?OnLogItem@CDPSrvr@@QAEXAAU_LogItemInfo@@PAVCItemElem@@H@Z:NEAR ; CDPSrvr::OnLogItem
;	COMDAT xdata$x
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\mover.h
xdata$x	SEGMENT
$T306137 DD	0ffffffffH
	DD	FLAT:$L306064
$T306128 DD	019930520H
	DD	01H
	DD	FLAT:$T306137
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_C@_07EEDNNGKF@GIFTBOX?$AA@
CONST	SEGMENT
??_C@_07EEDNNGKF@GIFTBOX?$AA@ DB 'GIFTBOX', 00H		; `string'
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
CONST	ENDS
;	COMDAT ?DoUseGiftbox@CUser@@QAEHPAVCItemElem@@K@Z
_TEXT	SEGMENT
_result$ = -428						; size = 20
_time$279525 = -408					; size = 8
$T306062 = -408						; size = 8
_itemElem$279521 = -400					; size = 184
_aLogItem$279531 = -216					; size = 200
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_pItemElem$ = 8						; size = 4
_dwItemId$ = 12						; size = 4
?DoUseGiftbox@CUser@@QAEHPAVCItemElem@@K@Z PROC NEAR	; CUser::DoUseGiftbox, COMDAT
; _this$ = ecx

; 2809 : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?DoUseGiftbox@CUser@@QAEHPAVCItemElem@@K@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	81 ec a0 01 00
	00		 sub	 esp, 416		; 000001a0H
  0001b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00020	33 c4		 xor	 eax, esp
  00022	53		 push	 ebx
  00023	56		 push	 esi
  00024	89 84 24 a4 01
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+436], eax
  0002b	57		 push	 edi
  0002c	8b bc 24 bc 01
	00 00		 mov	 edi, DWORD PTR _pItemElem$[esp+436]

; 2810 : //	DWORD dwItem;
; 2811 : //	int nNum;
; 2812 : //	BYTE nFlag;
; 2813 : 	GIFTBOXRESULT	result;

  00033	33 db		 xor	 ebx, ebx

; 2814 : 	/*
; 2815 : #ifdef __GIFTBOX0213
; 2816 : 	if( CGiftboxMan::GetInstance()->Open( dwItemId, &dwItem, &nNum, m_idPlayer, pItemElem ) )
; 2817 : #else	// __GIFTBOX0213
; 2818 : 	*/
; 2819 : 	if( CGiftboxMan::GetInstance()->Open( dwItemId, &result ) )

  00035	8d 44 24 0c	 lea	 eax, DWORD PTR _result$[esp+440]
  00039	8b f1		 mov	 esi, ecx
  0003b	8b 8c 24 c0 01
	00 00		 mov	 ecx, DWORD PTR _dwItemId$[esp+436]
  00042	50		 push	 eax
  00043	51		 push	 ecx
  00044	89 5c 24 14	 mov	 DWORD PTR _result$[esp+448], ebx
  00048	89 5c 24 18	 mov	 DWORD PTR _result$[esp+452], ebx
  0004c	88 5c 24 1c	 mov	 BYTE PTR _result$[esp+456], bl
  00050	89 5c 24 20	 mov	 DWORD PTR _result$[esp+460], ebx
  00054	89 5c 24 24	 mov	 DWORD PTR _result$[esp+464], ebx
  00058	e8 00 00 00 00	 call	 ?GetInstance@CGiftboxMan@@SAPAV1@XZ ; CGiftboxMan::GetInstance
  0005d	8b c8		 mov	 ecx, eax
  0005f	e8 00 00 00 00	 call	 ?Open@CGiftboxMan@@QAEHKPAU_GIFTBOXRESULT@@@Z ; CGiftboxMan::Open
  00064	85 c0		 test	 eax, eax
  00066	0f 84 e9 01 00
	00		 je	 $L279517

; 2820 : //#endif	// __GIFTBOX0213
; 2821 : 	{
; 2822 : 		if( m_Inventory.GetEmptyCount() < 1 )

  0006c	8b 8e 9c 0b 00
	00		 mov	 ecx, DWORD PTR [esi+2972]
  00072	33 d2		 xor	 edx, edx
  00074	3b cb		 cmp	 ecx, ebx
  00076	55		 push	 ebp
  00077	76 26		 jbe	 SHORT $L306132
  00079	8b 86 a0 0b 00
	00		 mov	 eax, DWORD PTR [esi+2976]
  0007f	83 c0 08	 add	 eax, 8
$L306075:
  00082	39 58 04	 cmp	 DWORD PTR [eax+4], ebx
  00085	75 0b		 jne	 SHORT $L306076
  00087	8b 28		 mov	 ebp, DWORD PTR [eax]
  00089	3b ae 98 0b 00
	00		 cmp	 ebp, DWORD PTR [esi+2968]
  0008f	73 01		 jae	 SHORT $L306076
  00091	42		 inc	 edx
$L306076:
  00092	05 b8 00 00 00	 add	 eax, 184		; 000000b8H
  00097	49		 dec	 ecx
  00098	75 e8		 jne	 SHORT $L306075
  0009a	83 fa 01	 cmp	 edx, 1
  0009d	7d 3a		 jge	 SHORT $L279518
$L306132:

; 2823 : 		{
; 2824 : 			AddDefinedText( TID_GAME_LACKSPACE );

  0009f	68 72 02 00 00	 push	 626			; 00000272H
  000a4	8b ce		 mov	 ecx, esi
  000a6	e8 00 00 00 00	 call	 ?AddDefinedText@CUser@@QAEXH@Z ; CUser::AddDefinedText
$L306136:

; 2861 : 		}
; 2862 : 		
; 2863 : 		return TRUE;

  000ab	b8 01 00 00 00	 mov	 eax, 1
  000b0	5d		 pop	 ebp
$L279515:

; 2867 : }

  000b1	8b 8c 24 ac 01
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+440]
  000b8	5f		 pop	 edi
  000b9	5e		 pop	 esi
  000ba	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  000c1	8b 8c 24 a0 01
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+432]
  000c8	5b		 pop	 ebx
  000c9	33 cc		 xor	 ecx, esp
  000cb	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000d0	81 c4 ac 01 00
	00		 add	 esp, 428		; 000001acH
  000d6	c2 08 00	 ret	 8
$L279518:

; 2825 : 			return TRUE;
; 2826 : 		}
; 2827 : 		if( pItemElem )

  000d9	3b fb		 cmp	 edi, ebx
  000db	74 27		 je	 SHORT $L279519

; 2828 : 		{
; 2829 : 			OnAfterUseItem( pItemElem->GetProp() );

  000dd	8b cf		 mov	 ecx, edi
  000df	e8 00 00 00 00	 call	 ?GetPropA@CItemElem@@QAEPAUItemProp@@XZ ; CItemElem::GetPropA
  000e4	50		 push	 eax
  000e5	8b ce		 mov	 ecx, esi
  000e7	e8 00 00 00 00	 call	 ?OnAfterUseItem@CMover@@QAEXPBUItemProp@@@Z ; CMover::OnAfterUseItem

; 2830 : 			UpdateItem( (BYTE)( pItemElem->m_dwObjId ), UI_NUM, pItemElem->m_nItemNum - 1 );

  000ec	0f bf 97 80 00
	00 00		 movsx	 edx, WORD PTR [edi+128]
  000f3	33 c0		 xor	 eax, eax
  000f5	8a 47 04	 mov	 al, BYTE PTR [edi+4]
  000f8	53		 push	 ebx
  000f9	4a		 dec	 edx
  000fa	52		 push	 edx
  000fb	53		 push	 ebx
  000fc	8b ce		 mov	 ecx, esi
  000fe	50		 push	 eax
  000ff	e8 00 00 00 00	 call	 ?UpdateItem@CMover@@QAEXEDKK@Z ; CMover::UpdateItem
$L279519:

; 2831 : 		}
; 2832 : 
; 2833 : 		CItemElem itemElem;

  00104	8d 4c 24 2c	 lea	 ecx, DWORD PTR _itemElem$279521[esp+444]
  00108	e8 00 00 00 00	 call	 ??0CItemElem@@QAE@XZ	; CItemElem::CItemElem

; 2834 : 		itemElem.m_dwItemId	= result.dwItem;
; 2835 : 		itemElem.m_nItemNum	= result.nNum;
; 2836 : 		if( result.nFlag != 4 )	// ignore property

  0010d	8a 44 24 18	 mov	 al, BYTE PTR _result$[esp+452]
  00111	3c 04		 cmp	 al, 4
  00113	8b 4c 24 10	 mov	 ecx, DWORD PTR _result$[esp+444]
  00117	66 8b 54 24 14	 mov	 dx, WORD PTR _result$[esp+448]
  0011c	89 9c 24 b8 01
	00 00		 mov	 DWORD PTR __$EHRec$[esp+452], ebx
  00123	89 4c 24 38	 mov	 DWORD PTR _itemElem$279521[esp+456], ecx
  00127	66 89 94 24 ac
	00 00 00	 mov	 WORD PTR _itemElem$279521[esp+572], dx
  0012f	74 1d		 je	 SHORT $L279522

; 2837 : 		{
; 2838 : 			itemElem.m_byFlag	= result.nFlag;
; 2839 : 			itemElem.m_bCharged		= itemElem.GetProp()->bCharged;

  00131	8d 4c 24 2c	 lea	 ecx, DWORD PTR _itemElem$279521[esp+444]
  00135	88 84 24 ae 00
	00 00		 mov	 BYTE PTR _itemElem$279521[esp+574], al
  0013c	e8 00 00 00 00	 call	 ?GetPropA@CItemElem@@QAEPAUItemProp@@XZ ; CItemElem::GetPropA
  00141	8b 80 ec 00 00
	00		 mov	 eax, DWORD PTR [eax+236]
  00147	89 84 24 d8 00
	00 00		 mov	 DWORD PTR _itemElem$279521[esp+616], eax
$L279522:

; 2840 : 		}
; 2841 : 
; 2842 : 		time_t t	= 0;
; 2843 : 		if( result.nSpan )	// minutes

  0014e	8b 44 24 1c	 mov	 eax, DWORD PTR _result$[esp+456]
  00152	33 c9		 xor	 ecx, ecx
  00154	3b c3		 cmp	 eax, ebx
  00156	74 2b		 je	 SHORT $L279524

; 2844 : 		{
; 2845 : 			CTime time	= CTime::GetCurrentTime() + CTimeSpan( 0, 0, result.nSpan, 0 );

  00158	53		 push	 ebx
  00159	e8 00 00 00 00	 call	 __time64
  0015e	8b 4c 24 20	 mov	 ecx, DWORD PTR _result$[esp+460]
  00162	83 c4 04	 add	 esp, 4
  00165	53		 push	 ebx
  00166	51		 push	 ecx
  00167	53		 push	 ebx
  00168	53		 push	 ebx
  00169	8d 4c 24 34	 lea	 ecx, DWORD PTR $T306062[esp+460]
  0016d	8b f8		 mov	 edi, eax
  0016f	8b ea		 mov	 ebp, edx
  00171	e8 00 00 00 00	 call	 ??0CTimeSpan@ATL@@QAE@JHHH@Z ; ATL::CTimeSpan::CTimeSpan
  00176	8b 08		 mov	 ecx, DWORD PTR [eax]
  00178	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0017b	03 cf		 add	 ecx, edi
  0017d	13 c5		 adc	 eax, ebp
  0017f	89 44 24 28	 mov	 DWORD PTR _time$279525[esp+448], eax
$L279524:

; 2846 : 			t	= (time_t)( time.GetTime() );
; 2847 : 		}
; 2848 : 		itemElem.m_dwKeepTime	= t;
; 2849 : 		itemElem.SetAbilityOption( result.nAbilityOption );

  00183	8b 54 24 20	 mov	 edx, DWORD PTR _result$[esp+460]

; 2850 : 
; 2851 : 		if( CreateItem( &itemElem ) )

  00187	53		 push	 ebx
  00188	53		 push	 ebx
  00189	53		 push	 ebx
  0018a	8d 44 24 38	 lea	 eax, DWORD PTR _itemElem$279521[esp+456]
  0018e	89 8c 24 e8 00
	00 00		 mov	 DWORD PTR _itemElem$279521[esp+632], ecx
  00195	50		 push	 eax
  00196	8b ce		 mov	 ecx, esi
  00198	89 94 24 ac 00
	00 00		 mov	 DWORD PTR _itemElem$279521[esp+572], edx
  0019f	e8 00 00 00 00	 call	 ?CreateItem@CMover@@QAEHPAVCItemBase@@PAEPAFE@Z ; CMover::CreateItem
  001a4	85 c0		 test	 eax, eax
  001a6	0f 84 90 00 00
	00		 je	 $L279530

; 2852 : 		{
; 2853 : 			AddDefinedText( TID_GAME_REAPITEM, "\"%s\"", itemElem.GetProp()->szName );						

  001ac	8d 4c 24 2c	 lea	 ecx, DWORD PTR _itemElem$279521[esp+444]
  001b0	e8 00 00 00 00	 call	 ?GetPropA@CItemElem@@QAEPAUItemProp@@XZ ; CItemElem::GetPropA
  001b5	83 c0 04	 add	 eax, 4
  001b8	50		 push	 eax
  001b9	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_04OEDFLLKD@?$CC?$CFs?$CC?$AA@
  001be	68 74 02 00 00	 push	 628			; 00000274H
  001c3	56		 push	 esi
  001c4	e8 00 00 00 00	 call	 ?AddDefinedText@CUser@@QAAXHPBDZZ ; CUser::AddDefinedText
  001c9	83 c4 10	 add	 esp, 16			; 00000010H

; 2854 : 			LogItemInfo aLogItem;

  001cc	8d 8c 24 e4 00
	00 00		 lea	 ecx, DWORD PTR _aLogItem$279531[esp+444]
  001d3	e8 00 00 00 00	 call	 ??0_LogItemInfo@@QAE@XZ	; _LogItemInfo::_LogItemInfo

; 2855 : 			aLogItem.Action = "E";
; 2856 : 			aLogItem.SendName = GetName();

  001d8	53		 push	 ebx
  001d9	8b ce		 mov	 ecx, esi
  001db	c7 84 24 e8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR _aLogItem$279531[esp+448], OFFSET FLAT:??_C@_01DDCIFGEA@E?$AA@
  001e6	e8 00 00 00 00	 call	 ?GetName@CMover@@QAEPBDH@Z ; CMover::GetName

; 2857 : 			aLogItem.RecvName = "GIFTBOX";
; 2858 : 			aLogItem.WorldId = GetWorld()->GetID();
; 2859 : 			aLogItem.Gold = aLogItem.Gold2 = GetGold();
; 2860 : 			g_DPSrvr.OnLogItem( aLogItem, &itemElem, result.nNum );

  001eb	8b 54 24 14	 mov	 edx, DWORD PTR _result$[esp+448]
  001ef	89 84 24 e8 00
	00 00		 mov	 DWORD PTR _aLogItem$279531[esp+448], eax
  001f6	8b 86 6c 01 00
	00		 mov	 eax, DWORD PTR [esi+364]
  001fc	8b b6 84 16 00
	00		 mov	 esi, DWORD PTR [esi+5764]
  00202	c7 84 24 ec 00
	00 00 00 00 00
	00		 mov	 DWORD PTR _aLogItem$279531[esp+452], OFFSET FLAT:??_C@_07EEDNNGKF@GIFTBOX?$AA@
  0020d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0020f	52		 push	 edx
  00210	89 8c 24 f4 00
	00 00		 mov	 DWORD PTR _aLogItem$279531[esp+460], ecx
  00217	8d 44 24 30	 lea	 eax, DWORD PTR _itemElem$279521[esp+448]
  0021b	50		 push	 eax
  0021c	8d 8c 24 ec 00
	00 00		 lea	 ecx, DWORD PTR _aLogItem$279531[esp+452]
  00223	51		 push	 ecx
  00224	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_DPSrvr@@3VCDPSrvr@@A
  00229	89 b4 24 04 01
	00 00		 mov	 DWORD PTR _aLogItem$279531[esp+476], esi
  00230	89 b4 24 00 01
	00 00		 mov	 DWORD PTR _aLogItem$279531[esp+472], esi
  00237	e8 00 00 00 00	 call	 ?OnLogItem@CDPSrvr@@QAEXAAU_LogItemInfo@@PAVCItemElem@@H@Z ; CDPSrvr::OnLogItem
$L279530:

; 2861 : 		}
; 2862 : 		
; 2863 : 		return TRUE;

  0023c	8d 4c 24 2c	 lea	 ecx, DWORD PTR _itemElem$279521[esp+444]
  00240	c7 84 24 b8 01
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+452], -1
  0024b	e8 00 00 00 00	 call	 ??1CItemElem@@UAE@XZ	; CItemElem::~CItemElem
  00250	e9 56 fe ff ff	 jmp	 $L306136
$L279517:

; 2864 : 	}
; 2865 : 
; 2866 : 	return FALSE;

  00255	33 c0		 xor	 eax, eax
  00257	e9 55 fe ff ff	 jmp	 $L279515
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L306064:
  00000	8d 8d 70 fe ff
	ff		 lea	 ecx, DWORD PTR _itemElem$279521[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CItemElem@@UAE@XZ	; CItemElem::~CItemElem
__ehhandler$?DoUseGiftbox@CUser@@QAEHPAVCItemElem@@K@Z:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T306128
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?DoUseGiftbox@CUser@@QAEHPAVCItemElem@@K@Z ENDP		; CUser::DoUseGiftbox
PUBLIC	??_C@_0P@LOCHAH@GIFTBOX?1?10?1?1?$CFs?$AA@	; `string'
PUBLIC	?DoUseEveFBOX@CUser@@QAEXPAVCItemElem@@@Z	; CUser::DoUseEveFBOX
EXTRN	?xRandom@@YAKKK@Z:NEAR				; xRandom
;	COMDAT xdata$x
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\mover.h
xdata$x	SEGMENT
$T306229 DD	0ffffffffH
	DD	FLAT:$L306144
$T306225 DD	019930520H
	DD	01H
	DD	FLAT:$T306229
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_C@_0P@LOCHAH@GIFTBOX?1?10?1?1?$CFs?$AA@
CONST	SEGMENT
??_C@_0P@LOCHAH@GIFTBOX?1?10?1?1?$CFs?$AA@ DB 'GIFTBOX//0//%s', 00H ; `string'
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
CONST	ENDS
;	COMDAT ?DoUseEveFBOX@CUser@@QAEXPAVCItemElem@@@Z
_TEXT	SEGMENT
_aLogItem$279568 = -400					; size = 200
_itemElem$ = -200					; size = 184
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_pItemElem$ = 8						; size = 4
?DoUseEveFBOX@CUser@@QAEXPAVCItemElem@@@Z PROC NEAR	; CUser::DoUseEveFBOX, COMDAT
; _this$ = ecx

; 2871 : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?DoUseEveFBOX@CUser@@QAEXPAVCItemElem@@@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	81 ec 84 01 00
	00		 sub	 esp, 388		; 00000184H
  0001b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00020	33 c4		 xor	 eax, esp
  00022	56		 push	 esi
  00023	8b b4 24 98 01
	00 00		 mov	 esi, DWORD PTR _pItemElem$[esp+400]

; 2872 : 	DWORD dwIdx;
; 2873 : 	if( pItemElem )

  0002a	85 f6		 test	 esi, esi
  0002c	57		 push	 edi
  0002d	89 84 24 88 01
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+408], eax
  00034	8b f9		 mov	 edi, ecx
  00036	74 58		 je	 SHORT $L279539

; 2874 : 	{
; 2875 : 		OnAfterUseItem( pItemElem->GetProp() );

  00038	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  0003b	85 c0		 test	 eax, eax
  0003d	8b 0d 5c 02 00
	00		 mov	 ecx, DWORD PTR ?prj@@3VCProject@@A+604
  00043	7c 11		 jl	 SHORT $L306207
  00045	3b c1		 cmp	 eax, ecx
  00047	7d 0d		 jge	 SHORT $L306207
  00049	73 21		 jae	 SHORT $L306228
  0004b	8b 0d 4c 02 00
	00		 mov	 ecx, DWORD PTR ?prj@@3VCProject@@A+588
  00051	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  00054	eb 18		 jmp	 SHORT $L306202
$L306207:
  00056	50		 push	 eax
  00057	51		 push	 ecx
  00058	6a 00		 push	 0
  0005a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BI@BEIFNGEL@GetItemProp?5range_error?$AA@
  0005f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@HMFGHCP@?$CFs?5min?3?$CFd?0?5max?3?$CFd?0?5index?3?$CFd?$AA@
  00064	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  00069	83 c4 14	 add	 esp, 20			; 00000014H
$L306228:
  0006c	33 c0		 xor	 eax, eax
$L306202:
  0006e	50		 push	 eax
  0006f	8b cf		 mov	 ecx, edi
  00071	e8 00 00 00 00	 call	 ?OnAfterUseItem@CMover@@QAEXPBUItemProp@@@Z ; CMover::OnAfterUseItem

; 2876 : 		UpdateItem( (BYTE)( pItemElem->m_dwObjId ), UI_NUM, pItemElem->m_nItemNum - 1 );

  00076	0f bf 96 80 00
	00 00		 movsx	 edx, WORD PTR [esi+128]
  0007d	33 c0		 xor	 eax, eax
  0007f	8a 46 04	 mov	 al, BYTE PTR [esi+4]
  00082	6a 00		 push	 0
  00084	4a		 dec	 edx
  00085	52		 push	 edx
  00086	6a 00		 push	 0
  00088	8b cf		 mov	 ecx, edi
  0008a	50		 push	 eax
  0008b	e8 00 00 00 00	 call	 ?UpdateItem@CMover@@QAEXEDKK@Z ; CMover::UpdateItem
$L279539:

; 2877 : 	}
; 2878 : 
; 2879 : 	int nRand	= xRandom( 1, 1000 );

  00090	68 e8 03 00 00	 push	 1000			; 000003e8H
  00095	6a 01		 push	 1
  00097	e8 00 00 00 00	 call	 ?xRandom@@YAKKK@Z	; xRandom
  0009c	83 c4 08	 add	 esp, 8

; 2880 : 	if( nRand > 470 )   // 53%

  0009f	3d d6 01 00 00	 cmp	 eax, 470		; 000001d6H
  000a4	7e 0a		 jle	 SHORT $L279542

; 2881 : 		dwIdx    = II_GEN_FOO_INS_CHOCOLATE;

  000a6	be f2 0a 00 00	 mov	 esi, 2802		; 00000af2H

; 2882 : 	else if( nRand > 130 )         // 34%

  000ab	e9 94 00 00 00	 jmp	 $L279564
$L279542:
  000b0	3d 82 00 00 00	 cmp	 eax, 130		; 00000082H
  000b5	7e 0a		 jle	 SHORT $L279544

; 2883 : 		dwIdx    = II_CHR_MAG_TRI_HEARTBOMB;

  000b7	be ee 27 00 00	 mov	 esi, 10222		; 000027eeH

; 2884 : 	else if( nRand > 108 )         // 2.2%

  000bc	e9 83 00 00 00	 jmp	 $L279564
$L279544:
  000c1	83 f8 6c	 cmp	 eax, 108		; 0000006cH
  000c4	7e 07		 jle	 SHORT $L279546

; 2885 : 		dwIdx    = II_ARM_S_CLO_SHO_WARMSLEEPER;

  000c6	be 35 11 00 00	 mov	 esi, 4405		; 00001135H

; 2886 : 	else if( nRand > 86 )         // 2.2%

  000cb	eb 77		 jmp	 SHORT $L279564
$L279546:
  000cd	83 f8 56	 cmp	 eax, 86			; 00000056H
  000d0	7e 07		 jle	 SHORT $L279548

; 2887 : 		dwIdx    = II_ARM_S_CLO_HAT_MUSHROOM;

  000d2	be 34 11 00 00	 mov	 esi, 4404		; 00001134H

; 2888 : 	else if( nRand > 71 )         // 1.5%

  000d7	eb 6b		 jmp	 SHORT $L279564
$L279548:
  000d9	83 f8 47	 cmp	 eax, 71			; 00000047H
  000dc	7e 07		 jle	 SHORT $L279550

; 2889 : 		dwIdx    = II_ARM_S_CLO_HAT_STATHAT;

  000de	be 31 11 00 00	 mov	 esi, 4401		; 00001131H

; 2890 : 	else if( nRand > 66 )   // 0.5%

  000e3	eb 5f		 jmp	 SHORT $L279564
$L279550:
  000e5	83 f8 42	 cmp	 eax, 66			; 00000042H
  000e8	7e 07		 jle	 SHORT $L279552

; 2891 : 		dwIdx    = II_WEA_SWO_HARTBONG;

  000ea	be b0 18 00 00	 mov	 esi, 6320		; 000018b0H

; 2892 : 	else if( nRand > 56 )         // 1%

  000ef	eb 53		 jmp	 SHORT $L279564
$L279552:
  000f1	83 f8 38	 cmp	 eax, 56			; 00000038H
  000f4	7e 07		 jle	 SHORT $L279554

; 2893 : 		dwIdx    = II_ARM_M_CLO_KOREAN01SUIT;

  000f6	be 67 28 00 00	 mov	 esi, 10343		; 00002867H

; 2894 : 	else if( nRand > 41 )          // 1.5%

  000fb	eb 47		 jmp	 SHORT $L279564
$L279554:
  000fd	83 f8 29	 cmp	 eax, 41			; 00000029H
  00100	7e 07		 jle	 SHORT $L279556

; 2895 : 		dwIdx    = II_ARM_M_CLO_KOREAN01SHOES;

  00102	be 68 28 00 00	 mov	 esi, 10344		; 00002868H

; 2896 : 	else if( nRand > 31 )          // 1%

  00107	eb 3b		 jmp	 SHORT $L279564
$L279556:
  00109	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0010c	7e 07		 jle	 SHORT $L279558

; 2897 : 		dwIdx    = II_ARM_F_CLO_KOREAN01SUIT;

  0010e	be 6a 28 00 00	 mov	 esi, 10346		; 0000286aH

; 2898 : 	else if( nRand > 16 )          // 1.5%

  00113	eb 2f		 jmp	 SHORT $L279564
$L279558:
  00115	83 f8 10	 cmp	 eax, 16			; 00000010H
  00118	7e 07		 jle	 SHORT $L279560

; 2899 : 		dwIdx    = II_ARM_F_CLO_KOREAN01SHOES;

  0011a	be 6b 28 00 00	 mov	 esi, 10347		; 0000286bH

; 2900 : 	else if( nRand > 6 )          // 1%

  0011f	eb 23		 jmp	 SHORT $L279564
$L279560:
  00121	83 f8 06	 cmp	 eax, 6
  00124	7e 07		 jle	 SHORT $L279562

; 2901 : 		dwIdx    = II_SYS_SYS_EVE_WINGS;

  00126	be af 18 00 00	 mov	 esi, 6319		; 000018afH

; 2902 : 	else if( nRand > 5 )          // 0.1%

  0012b	eb 17		 jmp	 SHORT $L279564
$L279562:
  0012d	33 c9		 xor	 ecx, ecx
  0012f	83 f8 05	 cmp	 eax, 5
  00132	0f 9e c1	 setle	 cl
  00135	49		 dec	 ecx
  00136	81 e1 4a f0 ff
	ff		 and	 ecx, -4022		; fffff04aH
  0013c	81 c1 69 28 00
	00		 add	 ecx, 10345		; 00002869H
  00142	8b f1		 mov	 esi, ecx
$L279564:

; 2903 : 		dwIdx    = II_WEA_KNU_ISHOFIST;
; 2904 : 	else	// 0.5%
; 2905 : 		dwIdx    = II_ARM_F_CLO_KOREAN01HAT;
; 2906 : 
; 2907 : 	CItemElem itemElem;

  00144	8d 8c 24 d0 00
	00 00		 lea	 ecx, DWORD PTR _itemElem$[esp+408]
  0014b	e8 00 00 00 00	 call	 ??0CItemElem@@QAE@XZ	; CItemElem::CItemElem

; 2908 : 	itemElem.m_dwItemId	= dwIdx;
; 2909 : 	itemElem.m_nItemNum	= 1;
; 2910 : 	if( CreateItem( &itemElem ) )

  00150	6a 00		 push	 0
  00152	6a 00		 push	 0
  00154	6a 00		 push	 0
  00156	8d 94 24 dc 00
	00 00		 lea	 edx, DWORD PTR _itemElem$[esp+420]
  0015d	52		 push	 edx
  0015e	8b cf		 mov	 ecx, edi
  00160	c7 84 24 a4 01
	00 00 00 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+432], 0
  0016b	89 b4 24 ec 00
	00 00		 mov	 DWORD PTR _itemElem$[esp+436], esi
  00172	66 c7 84 24 60
	01 00 00 01 00	 mov	 WORD PTR _itemElem$[esp+552], 1
  0017c	e8 00 00 00 00	 call	 ?CreateItem@CMover@@QAEHPAVCItemBase@@PAEPAFE@Z ; CMover::CreateItem
  00181	85 c0		 test	 eax, eax
  00183	74 5b		 je	 SHORT $L279567

; 2911 : 	{
; 2912 : 		LogItemInfo aLogItem;

  00185	8d 4c 24 08	 lea	 ecx, DWORD PTR _aLogItem$279568[esp+408]
  00189	e8 00 00 00 00	 call	 ??0_LogItemInfo@@QAE@XZ	; _LogItemInfo::_LogItemInfo

; 2913 : 		aLogItem.Action = "E";
; 2914 : 		aLogItem.SendName = GetName();

  0018e	6a 00		 push	 0
  00190	8b cf		 mov	 ecx, edi
  00192	c7 44 24 0c 00
	00 00 00	 mov	 DWORD PTR _aLogItem$279568[esp+412], OFFSET FLAT:??_C@_01DDCIFGEA@E?$AA@
  0019a	e8 00 00 00 00	 call	 ?GetName@CMover@@QAEPBDH@Z ; CMover::GetName
  0019f	89 44 24 0c	 mov	 DWORD PTR _aLogItem$279568[esp+412], eax

; 2915 : 		aLogItem.RecvName = "GIFTBOX";
; 2916 : 		aLogItem.WorldId = GetWorld()->GetID();

  001a3	8b 87 6c 01 00
	00		 mov	 eax, DWORD PTR [edi+364]

; 2917 : 		aLogItem.Gold = aLogItem.Gold2 = GetGold();

  001a9	8b bf 84 16 00
	00		 mov	 edi, DWORD PTR [edi+5764]

; 2918 : 		g_DPSrvr.OnLogItem( aLogItem, &itemElem, 1 );

  001af	6a 01		 push	 1
  001b1	8d 8c 24 d4 00
	00 00		 lea	 ecx, DWORD PTR _itemElem$[esp+412]
  001b8	51		 push	 ecx
  001b9	c7 44 24 18 00
	00 00 00	 mov	 DWORD PTR _aLogItem$279568[esp+424], OFFSET FLAT:??_C@_07EEDNNGKF@GIFTBOX?$AA@
  001c1	8b 00		 mov	 eax, DWORD PTR [eax]
  001c3	8d 54 24 10	 lea	 edx, DWORD PTR _aLogItem$279568[esp+416]
  001c7	52		 push	 edx
  001c8	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_DPSrvr@@3VCDPSrvr@@A
  001cd	89 44 24 20	 mov	 DWORD PTR _aLogItem$279568[esp+432], eax
  001d1	89 7c 24 28	 mov	 DWORD PTR _aLogItem$279568[esp+440], edi
  001d5	89 7c 24 24	 mov	 DWORD PTR _aLogItem$279568[esp+436], edi
  001d9	e8 00 00 00 00	 call	 ?OnLogItem@CDPSrvr@@QAEXAAU_LogItemInfo@@PAVCItemElem@@H@Z ; CDPSrvr::OnLogItem

; 2919 : 	}
; 2920 : 	else

  001de	eb 17		 jmp	 SHORT $L279569
$L279567:

; 2921 : 	{
; 2922 : 		WriteError( "GIFTBOX//0//%s", GetName() );

  001e0	6a 00		 push	 0
  001e2	8b cf		 mov	 ecx, edi
  001e4	e8 00 00 00 00	 call	 ?GetName@CMover@@QAEPBDH@Z ; CMover::GetName
  001e9	50		 push	 eax
  001ea	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0P@LOCHAH@GIFTBOX?1?10?1?1?$CFs?$AA@
  001ef	e8 00 00 00 00	 call	 ?WriteError@@YAXPBDZZ	; WriteError
  001f4	83 c4 08	 add	 esp, 8
$L279569:

; 2923 : 	}
; 2924 : }

  001f7	8d 8c 24 d0 00
	00 00		 lea	 ecx, DWORD PTR _itemElem$[esp+408]
  001fe	c7 84 24 94 01
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+416], -1
  00209	e8 00 00 00 00	 call	 ??1CItemElem@@UAE@XZ	; CItemElem::~CItemElem
  0020e	8b 8c 24 8c 01
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+408]
  00215	5f		 pop	 edi
  00216	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0021d	8b 8c 24 84 01
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+404]
  00224	5e		 pop	 esi
  00225	33 cc		 xor	 ecx, esp
  00227	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0022c	81 c4 90 01 00
	00		 add	 esp, 400		; 00000190H
  00232	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L306144:
  00000	8d 8d 38 ff ff
	ff		 lea	 ecx, DWORD PTR _itemElem$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CItemElem@@UAE@XZ	; CItemElem::~CItemElem
__ehhandler$?DoUseEveFBOX@CUser@@QAEXPAVCItemElem@@@Z:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T306225
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?DoUseEveFBOX@CUser@@QAEXPAVCItemElem@@@Z ENDP		; CUser::DoUseEveFBOX
PUBLIC	??_C@_0BB@JEJCJGDO@ITEMCONTAINER?1?11?$AA@	; `string'
PUBLIC	?IsUsableState@CUser@@QAEHK@Z			; CUser::IsUsableState
EXTRN	?VendorIsVendor@CVTInfo@@QAEHXZ:NEAR		; CVTInfo::VendorIsVendor
;	COMDAT ??_C@_0BB@JEJCJGDO@ITEMCONTAINER?1?11?$AA@
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\mover.h
CONST	SEGMENT
??_C@_0BB@JEJCJGDO@ITEMCONTAINER?1?11?$AA@ DB 'ITEMCONTAINER//1', 00H ; `string'
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
CONST	ENDS
;	COMDAT ?IsUsableState@CUser@@QAEHK@Z
_TEXT	SEGMENT
_dwId$ = 8						; size = 4
?IsUsableState@CUser@@QAEHK@Z PROC NEAR			; CUser::IsUsableState, COMDAT
; _this$ = ecx

; 2928 : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 2929 : 	if( m_Inventory.m_apItem == NULL )

  00003	8b 86 a0 0b 00
	00		 mov	 eax, DWORD PTR [esi+2976]
  00009	85 c0		 test	 eax, eax
  0000b	75 13		 jne	 SHORT $L279575

; 2930 : 	{
; 2931 : 		WriteError( "ITEMCONTAINER//1" );

  0000d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BB@JEJCJGDO@ITEMCONTAINER?1?11?$AA@
  00012	e8 00 00 00 00	 call	 ?WriteError@@YAXPBDZZ	; WriteError
  00017	83 c4 04	 add	 esp, 4
$L306248:

; 2932 : 		return FALSE;

  0001a	33 c0		 xor	 eax, eax
  0001c	5e		 pop	 esi

; 2952 : 		return FALSE;
; 2953 : #endif // __S_SERVER_UNIFY
; 2954 : 
; 2955 : 	return TRUE;
; 2956 : }

  0001d	c2 04 00	 ret	 4
$L279575:

; 2933 : 	}
; 2934 : 
; 2935 : 	if( m_Inventory.IsEquip( dwId ) == FALSE )

  00020	8b 8e a0 0b 00
	00		 mov	 ecx, DWORD PTR [esi+2976]
  00026	85 c9		 test	 ecx, ecx
  00028	75 0f		 jne	 SHORT $L306238
  0002a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0N@GELFDHNG@CONTAINER?1?10?$AA@
  0002f	e8 00 00 00 00	 call	 ?WriteError@@YAXPBDZZ	; WriteError
  00034	83 c4 04	 add	 esp, 4
  00037	eb 1e		 jmp	 SHORT $L306247
$L306238:
  00039	8b 44 24 08	 mov	 eax, DWORD PTR _dwId$[esp]
  0003d	3b 86 9c 0b 00
	00		 cmp	 eax, DWORD PTR [esi+2972]
  00043	73 12		 jae	 SHORT $L306247
  00045	69 c0 b8 00 00
	00		 imul	 eax, 184		; 000000b8H
  0004b	8b 44 08 08	 mov	 eax, DWORD PTR [eax+ecx+8]
  0004f	3b 86 98 0b 00
	00		 cmp	 eax, DWORD PTR [esi+2968]
  00055	73 31		 jae	 SHORT $L279579
$L306247:

; 2936 : 	{
; 2937 : 		//       .
; 2938 : 		//            . 
; 2939 : 		if( m_vtInfo.GetOtherID() != NULL_ID )

  00057	83 be f8 0d 00
	00 ff		 cmp	 DWORD PTR [esi+3576], -1
  0005e	74 19		 je	 SHORT $L279578

; 2940 : 		{
; 2941 : 			AddDefinedText( TID_GAME_TRADELIMITUSING, "" );

  00060	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  00065	68 7d 02 00 00	 push	 637			; 0000027dH
  0006a	56		 push	 esi
  0006b	e8 00 00 00 00	 call	 ?AddDefinedText@CUser@@QAAXHPBDZZ ; CUser::AddDefinedText
  00070	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2942 : 			return FALSE;

  00073	33 c0		 xor	 eax, eax
  00075	5e		 pop	 esi

; 2952 : 		return FALSE;
; 2953 : #endif // __S_SERVER_UNIFY
; 2954 : 
; 2955 : 	return TRUE;
; 2956 : }

  00076	c2 04 00	 ret	 4
$L279578:

; 2943 : 		}
; 2944 : 		if( m_vtInfo.VendorIsVendor() )

  00079	8d 8e 7c 0d 00
	00		 lea	 ecx, DWORD PTR [esi+3452]
  0007f	e8 00 00 00 00	 call	 ?VendorIsVendor@CVTInfo@@QAEHXZ ; CVTInfo::VendorIsVendor
  00084	85 c0		 test	 eax, eax

; 2945 : 		{
; 2946 : 			return FALSE;

  00086	75 92		 jne	 SHORT $L306248
$L279579:

; 2947 : 		}
; 2948 : 	}
; 2949 : 
; 2950 : #ifdef __S_SERVER_UNIFY
; 2951 : 	if( m_bAllAction == FALSE )

  00088	8b 8e f8 95 00
	00		 mov	 ecx, DWORD PTR [esi+38392]
  0008e	33 c0		 xor	 eax, eax
  00090	85 c9		 test	 ecx, ecx
  00092	0f 95 c0	 setne	 al
  00095	5e		 pop	 esi

; 2952 : 		return FALSE;
; 2953 : #endif // __S_SERVER_UNIFY
; 2954 : 
; 2955 : 	return TRUE;
; 2956 : }

  00096	c2 04 00	 ret	 4
?IsUsableState@CUser@@QAEHK@Z ENDP			; CUser::IsUsableState
_TEXT	ENDS
PUBLIC	?OnDoUseItem@CUser@@QAEXKKH@Z			; CUser::OnDoUseItem
EXTRN	?TransFormVisPet@CItemUpgrade@@QAEXPAVCUser@@K@Z:NEAR ; CItemUpgrade::TransFormVisPet
EXTRN	?GetInstance@CPackItem@@SAPAV1@XZ:NEAR		; CPackItem::GetInstance
EXTRN	?Open@CPackItem@@QAEPAU_PACKITEMELEM@@K@Z:NEAR	; CPackItem::Open
EXTRN	?IsUsableItem@@YAHPAVCItemBase@@@Z:NEAR		; IsUsableItem
EXTRN	?DoUseItem@CMover@@QAEHKKH@Z:NEAR		; CMover::DoUseItem
EXTRN	?GetInstance@CItemUpgrade@@SAPAV1@XZ:NEAR	; CItemUpgrade::GetInstance
EXTRN	?PetVisSize@CItemUpgrade@@QAEXPAVCUser@@K@Z:NEAR ; CItemUpgrade::PetVisSize
EXTRN	?SetPetVisItem@CItemUpgrade@@QAEXPAVCUser@@K@Z:NEAR ; CItemUpgrade::SetPetVisItem
; Function compile flags: /Ogty
;	COMDAT ?OnDoUseItem@CUser@@QAEXKKH@Z
_TEXT	SEGMENT
_dwData$ = 8						; size = 4
_objid$ = 12						; size = 4
_nPart$ = 16						; size = 4
?OnDoUseItem@CUser@@QAEXKKH@Z PROC NEAR			; CUser::OnDoUseItem, COMDAT
; _this$ = ecx

; 2959 : {

  00000	55		 push	 ebp

; 2960 : 	DWORD dwItemId;
; 2961 : 	DWORD dwId = HIWORD( dwData );

  00001	8b 6c 24 08	 mov	 ebp, DWORD PTR _dwData$[esp]
  00005	56		 push	 esi
  00006	57		 push	 edi
  00007	8b f5		 mov	 esi, ebp
  00009	c1 ee 10	 shr	 esi, 16			; 00000010H

; 2962 : 
; 2963 : 	if( IsUsableState( dwId ) == FALSE )

  0000c	56		 push	 esi
  0000d	8b f9		 mov	 edi, ecx
  0000f	e8 00 00 00 00	 call	 ?IsUsableState@CUser@@QAEHK@Z ; CUser::IsUsableState
  00014	85 c0		 test	 eax, eax
  00016	0f 84 51 01 00
	00		 je	 $L279610

; 2964 : 		return;
; 2965 : 
; 2966 : #ifdef __QUIZ
; 2967 : 	if( GetWorld() && GetWorld()->GetID() == WI_WORLD_QUIZ )

  0001c	8b 87 6c 01 00
	00		 mov	 eax, DWORD PTR [edi+364]
  00022	85 c0		 test	 eax, eax
  00024	74 0c		 je	 SHORT $L279592
  00026	81 38 d3 00 00
	00		 cmp	 DWORD PTR [eax], 211	; 000000d3H
  0002c	0f 84 3b 01 00
	00		 je	 $L279610
$L279592:

; 2968 : 		return;
; 2969 : #endif // __QUIZ
; 2970 : 
; 2971 : 	CItemElem* pItemElem = m_Inventory.GetAtId( dwId );

  00032	3b b7 9c 0b 00
	00		 cmp	 esi, DWORD PTR [edi+2972]
  00038	53		 push	 ebx
  00039	72 04		 jb	 SHORT $L306278
  0003b	33 f6		 xor	 esi, esi
  0003d	eb 19		 jmp	 SHORT $L306280
$L306278:
  0003f	8b 9f a0 0b 00
	00		 mov	 ebx, DWORD PTR [edi+2976]
  00045	69 f6 b8 00 00
	00		 imul	 esi, 184		; 000000b8H
  0004b	03 f3		 add	 esi, ebx
  0004d	8b c6		 mov	 eax, esi
  0004f	8b 70 0c	 mov	 esi, DWORD PTR [eax+12]
  00052	f7 de		 neg	 esi
  00054	1b f6		 sbb	 esi, esi
  00056	23 f0		 and	 esi, eax
$L306280:

; 2972 : 	if( IsUsableItem( pItemElem ) )

  00058	56		 push	 esi
  00059	e8 00 00 00 00	 call	 ?IsUsableItem@@YAHPAVCItemBase@@@Z ; IsUsableItem
  0005e	83 c4 04	 add	 esp, 4
  00061	85 c0		 test	 eax, eax
  00063	0f 84 d0 00 00
	00		 je	 $L279594

; 2973 : 	{
; 2974 : 		//  
; 2975 : 		ItemProp* pItemProp	= pItemElem->GetProp();

  00069	8b ce		 mov	 ecx, esi
  0006b	e8 00 00 00 00	 call	 ?GetPropA@CItemElem@@QAEPAUItemProp@@XZ ; CItemElem::GetPropA

; 2976 : 		if( pItemProp && pItemProp->dwParts == NULL_ID && pItemElem->IsFlag( CItemElem::expired ) )

  00070	85 c0		 test	 eax, eax
  00072	0f 84 9d 00 00
	00		 je	 $L279604
  00078	83 b8 a8 00 00
	00 ff		 cmp	 DWORD PTR [eax+168], -1
  0007f	75 33		 jne	 SHORT $L279596
  00081	f6 86 82 00 00
	00 01		 test	 BYTE PTR [esi+130], 1
  00088	74 2a		 je	 SHORT $L279596

; 2977 : 		{
; 2978 : #if __VER >= 9	// __PET_0410
; 2979 : 			if(pItemProp->dwItemKind3 == IK3_EGG)

  0008a	83 78 78 78	 cmp	 DWORD PTR [eax+120], 120 ; 00000078H

; 2980 : 				AddDefinedText( TID_GAME_PET_DEAD );

  0008e	8b cf		 mov	 ecx, edi
  00090	75 11		 jne	 SHORT $L279597
  00092	68 e1 0c 00 00	 push	 3297			; 00000ce1H
  00097	e8 00 00 00 00	 call	 ?AddDefinedText@CUser@@QAEXH@Z ; CUser::AddDefinedText
  0009c	5b		 pop	 ebx
  0009d	5f		 pop	 edi
  0009e	5e		 pop	 esi
  0009f	5d		 pop	 ebp

; 3033 : 		break;
; 3034 : 	}
; 3035 : }

  000a0	c2 0c 00	 ret	 12			; 0000000cH
$L279597:

; 2981 : 			else
; 2982 : 				AddDefinedText( TID_GAME_ITEM_EXPIRED );

  000a3	68 56 0b 00 00	 push	 2902			; 00000b56H
  000a8	e8 00 00 00 00	 call	 ?AddDefinedText@CUser@@QAEXH@Z ; CUser::AddDefinedText
  000ad	5b		 pop	 ebx
  000ae	5f		 pop	 edi
  000af	5e		 pop	 esi
  000b0	5d		 pop	 ebp

; 3033 : 		break;
; 3034 : 	}
; 3035 : }

  000b1	c2 0c 00	 ret	 12			; 0000000cH
$L279596:

; 2983 : #else
; 2984 : 			AddDefinedText( TID_GAME_ITEM_EXPIRED );
; 2985 : #endif //__PET_0410
; 2986 : 			return;
; 2987 : 		}
; 2988 : #if __VER >= 15 // __PETVIS
; 2989 : 		if( pItemProp )
; 2990 : 		{
; 2991 : 			if( pItemProp->dwItemKind3 == IK3_VIS )

  000b4	81 78 78 8a 00
	00 00		 cmp	 DWORD PTR [eax+120], 138 ; 0000008aH
  000bb	75 18		 jne	 SHORT $L279600

; 2992 : 			{
; 2993 : 				CItemUpgrade::GetInstance()->SetPetVisItem( this, pItemElem->m_dwObjId );

  000bd	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000c0	50		 push	 eax
  000c1	57		 push	 edi
  000c2	e8 00 00 00 00	 call	 ?GetInstance@CItemUpgrade@@SAPAV1@XZ ; CItemUpgrade::GetInstance
  000c7	8b c8		 mov	 ecx, eax
  000c9	e8 00 00 00 00	 call	 ?SetPetVisItem@CItemUpgrade@@QAEXPAVCUser@@K@Z ; CItemUpgrade::SetPetVisItem
  000ce	5b		 pop	 ebx
  000cf	5f		 pop	 edi
  000d0	5e		 pop	 esi
  000d1	5d		 pop	 ebp

; 3033 : 		break;
; 3034 : 	}
; 3035 : }

  000d2	c2 0c 00	 ret	 12			; 0000000cH
$L279600:

; 2994 : 				return;
; 2995 : 			}
; 2996 : 			else if( pItemProp->dwID == II_SYS_SYS_VIS_KEY01 )

  000d5	8b 00		 mov	 eax, DWORD PTR [eax]
  000d7	3d e7 68 00 00	 cmp	 eax, 26855		; 000068e7H
  000dc	75 18		 jne	 SHORT $L279602

; 2997 : 			{
; 2998 : 				CItemUpgrade::GetInstance()->PetVisSize( this, pItemElem->m_dwObjId );

  000de	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  000e1	51		 push	 ecx
  000e2	57		 push	 edi
  000e3	e8 00 00 00 00	 call	 ?GetInstance@CItemUpgrade@@SAPAV1@XZ ; CItemUpgrade::GetInstance
  000e8	8b c8		 mov	 ecx, eax
  000ea	e8 00 00 00 00	 call	 ?PetVisSize@CItemUpgrade@@QAEXPAVCUser@@K@Z ; CItemUpgrade::PetVisSize
  000ef	5b		 pop	 ebx
  000f0	5f		 pop	 edi
  000f1	5e		 pop	 esi
  000f2	5d		 pop	 ebp

; 3033 : 		break;
; 3034 : 	}
; 3035 : }

  000f3	c2 0c 00	 ret	 12			; 0000000cH
$L279602:

; 2999 : 				return;
; 3000 : 			}
; 3001 : 			else if( pItemProp->dwID == II_SYS_SYS_SCR_PET_MAGIC )

  000f6	3d 1e 69 00 00	 cmp	 eax, 26910		; 0000691eH
  000fb	75 18		 jne	 SHORT $L279604

; 3002 : 			{
; 3003 : 				CItemUpgrade::GetInstance()->TransFormVisPet( this, pItemElem->m_dwObjId );

  000fd	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00100	52		 push	 edx
  00101	57		 push	 edi
  00102	e8 00 00 00 00	 call	 ?GetInstance@CItemUpgrade@@SAPAV1@XZ ; CItemUpgrade::GetInstance
  00107	8b c8		 mov	 ecx, eax
  00109	e8 00 00 00 00	 call	 ?TransFormVisPet@CItemUpgrade@@QAEXPAVCUser@@K@Z ; CItemUpgrade::TransFormVisPet
  0010e	5b		 pop	 ebx
  0010f	5f		 pop	 edi
  00110	5e		 pop	 esi
  00111	5d		 pop	 ebp

; 3033 : 		break;
; 3034 : 	}
; 3035 : }

  00112	c2 0c 00	 ret	 12			; 0000000cH
$L279604:

; 3004 : 				return;
; 3005 : 			}
; 3006 : 		}			
; 3007 : #endif // __PETVIS
; 3008 : 
; 3009 : 		dwItemId = pItemElem->m_dwItemId;

  00115	8b 5e 0c	 mov	 ebx, DWORD PTR [esi+12]

; 3010 : 	
; 3011 : 		PPACKITEMELEM pPackItemElem	= CPackItem::GetInstance()->Open( dwItemId );

  00118	53		 push	 ebx
  00119	e8 00 00 00 00	 call	 ?GetInstance@CPackItem@@SAPAV1@XZ ; CPackItem::GetInstance
  0011e	8b c8		 mov	 ecx, eax
  00120	e8 00 00 00 00	 call	 ?Open@CPackItem@@QAEPAU_PACKITEMELEM@@K@Z ; CPackItem::Open

; 3012 : 		if( pPackItemElem )

  00125	85 c0		 test	 eax, eax
  00127	74 14		 je	 SHORT $L279607

; 3013 : 		{
; 3014 : 			DoUsePackItem( pItemElem, pPackItemElem );

  00129	50		 push	 eax
  0012a	56		 push	 esi
  0012b	8b cf		 mov	 ecx, edi
  0012d	e8 00 00 00 00	 call	 ?DoUsePackItem@CUser@@QAEXPAVCItemElem@@PAU_PACKITEMELEM@@@Z ; CUser::DoUsePackItem
  00132	5b		 pop	 ebx
  00133	5f		 pop	 edi
  00134	5e		 pop	 esi
  00135	5d		 pop	 ebp

; 3033 : 		break;
; 3034 : 	}
; 3035 : }

  00136	c2 0c 00	 ret	 12			; 0000000cH
$L279594:

; 3015 : 			return;
; 3016 : 		}
; 3017 : 	}
; 3018 : 	else
; 3019 : 	{
; 3020 : 		pItemElem = NULL;

  00139	33 f6		 xor	 esi, esi

; 3021 : 		dwItemId = 0;

  0013b	33 db		 xor	 ebx, ebx
$L279607:

; 3022 : 	}
; 3023 : 
; 3024 : 	DoUseItem( dwData, objid, nPart );

  0013d	8b 44 24 1c	 mov	 eax, DWORD PTR _nPart$[esp+12]
  00141	8b 4c 24 18	 mov	 ecx, DWORD PTR _objid$[esp+12]
  00145	50		 push	 eax
  00146	51		 push	 ecx
  00147	55		 push	 ebp
  00148	8b cf		 mov	 ecx, edi
  0014a	e8 00 00 00 00	 call	 ?DoUseItem@CMover@@QAEHKKH@Z ; CMover::DoUseItem

; 3025 : 
; 3026 : 	if( DoUseGiftbox( pItemElem, dwItemId ) )

  0014f	53		 push	 ebx
  00150	56		 push	 esi
  00151	8b cf		 mov	 ecx, edi
  00153	e8 00 00 00 00	 call	 ?DoUseGiftbox@CUser@@QAEHPAVCItemElem@@K@Z ; CUser::DoUseGiftbox
  00158	85 c0		 test	 eax, eax
  0015a	75 10		 jne	 SHORT $L306285

; 3027 : 		return;
; 3028 : 
; 3029 : 	switch( dwItemId )

  0015c	81 fb ae 18 00
	00		 cmp	 ebx, 6318		; 000018aeH
  00162	75 08		 jne	 SHORT $L306285

; 3030 : 	{
; 3031 : 	case II_SYS_SYS_EVE_FBOX:
; 3032 : 		DoUseEveFBOX( pItemElem );

  00164	56		 push	 esi
  00165	8b cf		 mov	 ecx, edi
  00167	e8 00 00 00 00	 call	 ?DoUseEveFBOX@CUser@@QAEXPAVCItemElem@@@Z ; CUser::DoUseEveFBOX
$L306285:
  0016c	5b		 pop	 ebx
$L279610:
  0016d	5f		 pop	 edi
  0016e	5e		 pop	 esi
  0016f	5d		 pop	 ebp

; 3033 : 		break;
; 3034 : 	}
; 3035 : }

  00170	c2 0c 00	 ret	 12			; 0000000cH
?OnDoUseItem@CUser@@QAEXKKH@Z ENDP			; CUser::OnDoUseItem
_TEXT	ENDS
PUBLIC	?AddPetFoodMill@CUser@@QAEXHH@Z			; CUser::AddPetFoodMill
; Function compile flags: /Ogty
;	COMDAT ?AddPetFoodMill@CUser@@QAEXHH@Z
_TEXT	SEGMENT
_nResult$ = 8						; size = 4
_nCount$ = 12						; size = 4
?AddPetFoodMill@CUser@@QAEXHH@Z PROC NEAR		; CUser::AddPetFoodMill, COMDAT
; _this$ = ecx

; 3071 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	75 7e		 jne	 SHORT $L306323

; 3072 : 	
; 3073 : 	m_Snapshot.cb++;

  00006	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  0000d	56		 push	 esi
  0000e	57		 push	 edi

; 3074 : 	m_Snapshot.ar << GETID( this );

  0000f	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  00015	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  0001b	6a 04		 push	 4
  0001d	8b ce		 mov	 ecx, esi
  0001f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00024	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00027	89 38		 mov	 DWORD PTR [eax], edi
  00029	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0002c	83 c2 04	 add	 edx, 4

; 3075 : 	m_Snapshot.ar << SNAPSHOTTYPE_PET_MILL;

  0002f	6a 02		 push	 2
  00031	8b ce		 mov	 ecx, esi
  00033	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00036	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003b	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003e	66 c7 01 17 01	 mov	 WORD PTR [ecx], 279	; 00000117H
  00043	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00046	83 c0 02	 add	 eax, 2

; 3076 : 	m_Snapshot.ar << nResult;

  00049	6a 04		 push	 4
  0004b	8b ce		 mov	 ecx, esi
  0004d	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00050	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00055	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00058	8b 44 24 0c	 mov	 eax, DWORD PTR _nResult$[esp+4]
  0005c	89 02		 mov	 DWORD PTR [edx], eax
  0005e	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00061	83 c2 04	 add	 edx, 4

; 3077 : 	m_Snapshot.ar << nCount;

  00064	6a 04		 push	 4
  00066	8b ce		 mov	 ecx, esi
  00068	89 56 08	 mov	 DWORD PTR [esi+8], edx
  0006b	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00070	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00073	8b 54 24 10	 mov	 edx, DWORD PTR _nCount$[esp+4]
  00077	89 11		 mov	 DWORD PTR [ecx], edx
  00079	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0007c	83 c0 04	 add	 eax, 4
  0007f	5f		 pop	 edi
  00080	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00083	5e		 pop	 esi
$L306323:

; 3078 : }

  00084	c2 08 00	 ret	 8
?AddPetFoodMill@CUser@@QAEXHH@Z ENDP			; CUser::AddPetFoodMill
_TEXT	ENDS
PUBLIC	??_C@_01PAPGNFGE@c?$AA@				; `string'
PUBLIC	??_C@_0L@EMDEHLJF@CreateItem?$AA@		; `string'
PUBLIC	?ProcessCollecting@CUser@@UAEXXZ		; CUser::ProcessCollecting
EXTRN	?IsDisguise@CMover@@QAEHXZ:NEAR			; CMover::IsDisguise
EXTRN	?GetCool@CCollectingProperty@@QAEHH@Z:NEAR	; CCollectingProperty::GetCool
EXTRN	?GetItem@CCollectingProperty@@QAEKXZ:NEAR	; CCollectingProperty::GetItem
EXTRN	?SetSerialNumber@CItemBase@@QAEXXZ:NEAR		; CItemBase::SetSerialNumber
;	COMDAT xdata$x
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\mover.h
xdata$x	SEGMENT
$T306367 DD	0ffffffffH
	DD	FLAT:$L306329
$T306361 DD	019930520H
	DD	01H
	DD	FLAT:$T306367
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_C@_01PAPGNFGE@c?$AA@
CONST	SEGMENT
??_C@_01PAPGNFGE@c?$AA@ DB 'c', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@EMDEHLJF@CreateItem?$AA@
CONST	SEGMENT
??_C@_0L@EMDEHLJF@CreateItem?$AA@ DB 'CreateItem', 00H	; `string'
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
CONST	ENDS
;	COMDAT ?ProcessCollecting@CUser@@UAEXXZ
_TEXT	SEGMENT
_itemElem$279663 = -400					; size = 184
_log$279665 = -216					; size = 200
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
?ProcessCollecting@CUser@@UAEXXZ PROC NEAR		; CUser::ProcessCollecting, COMDAT
; _this$ = ecx

; 3083 : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?ProcessCollecting@CUser@@UAEXXZ
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	81 ec 84 01 00
	00		 sub	 esp, 388		; 00000184H
  0001b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00020	33 c4		 xor	 eax, esp
  00022	56		 push	 esi
  00023	57		 push	 edi
  00024	89 84 24 88 01
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+408], eax
  0002b	8b f1		 mov	 esi, ecx

; 3084 : 	CItemElem* pCol		= GetCollector();

  0002d	e8 00 00 00 00	 call	 ?GetCollector@CMover@@QAEPAVCItemElem@@XZ ; CMover::GetCollector
  00032	8b f8		 mov	 edi, eax

; 3085 : 	if( pCol == NULL )	

  00034	85 ff		 test	 edi, edi
  00036	75 27		 jne	 SHORT $L279648

; 3086 : 	{
; 3087 : 		// 1.  
; 3088 : 		if( m_pActMover->GetActionState() == OBJSTA_COLLECT )

  00038	8b 86 3c 02 00
	00		 mov	 eax, DWORD PTR [esi+572]
  0003e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
$L306366:
  00041	81 e1 00 00 00
	f0		 and	 ecx, -268435456		; f0000000H
  00047	81 f9 00 00 00
	10		 cmp	 ecx, 268435456		; 10000000H
  0004d	0f 85 a8 01 00
	00		 jne	 $L279660
$L306365:

; 3089 : 			StopCollecting();

  00053	8b 16		 mov	 edx, DWORD PTR [esi]
  00055	8b ce		 mov	 ecx, esi
  00057	ff 52 4c	 call	 DWORD PTR [edx+76]

; 3090 : 	}
; 3091 : 	else if( IsDisguise() )	

  0005a	e9 9c 01 00 00	 jmp	 $L279660
$L279648:
  0005f	8b ce		 mov	 ecx, esi
  00061	e8 00 00 00 00	 call	 ?IsDisguise@CMover@@QAEHXZ ; CMover::IsDisguise
  00066	85 c0		 test	 eax, eax

; 3092 : 	{
; 3093 : 		if( m_pActMover->GetActionState() == OBJSTA_COLLECT )

  00068	8b 86 3c 02 00
	00		 mov	 eax, DWORD PTR [esi+572]
  0006e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]

; 3094 : 			StopCollecting();
; 3095 : 	}
; 3096 : 	else if( m_pActMover->GetActionState() == OBJSTA_COLLECT )

  00071	75 ce		 jne	 SHORT $L306366
  00073	81 e1 00 00 00
	f0		 and	 ecx, -268435456		; f0000000H
  00079	81 f9 00 00 00
	10		 cmp	 ecx, 268435456		; 10000000H
  0007f	0f 85 76 01 00
	00		 jne	 $L279660

; 3097 : 	{
; 3098 : 		// 3.  
; 3099 : 		// 3.1.  
; 3100 : 		if( !HasBuff( BUFF_ITEM2, II_GEN_TOO_COL_SILVERBATTERY )
; 3101 : 			&& !HasBuff( BUFF_ITEM2, II_GEN_TOO_COL_GOLDBATTERY ) 
; 3102 : 			&& !HasBuff( BUFF_ITEM2, II_GEN_TOO_COL_BATTERY001 ) )

  00085	68 56 67 00 00	 push	 26454			; 00006756H
  0008a	6a 03		 push	 3
  0008c	8b ce		 mov	 ecx, esi
  0008e	e8 00 00 00 00	 call	 ?HasBuff@CMover@@QAEHGG@Z ; CMover::HasBuff
  00093	85 c0		 test	 eax, eax
  00095	75 50		 jne	 SHORT $L279658
  00097	68 57 67 00 00	 push	 26455			; 00006757H
  0009c	6a 03		 push	 3
  0009e	8b ce		 mov	 ecx, esi
  000a0	e8 00 00 00 00	 call	 ?HasBuff@CMover@@QAEHGG@Z ; CMover::HasBuff
  000a5	85 c0		 test	 eax, eax
  000a7	75 3e		 jne	 SHORT $L279658
  000a9	68 c0 67 00 00	 push	 26560			; 000067c0H
  000ae	6a 03		 push	 3
  000b0	8b ce		 mov	 ecx, esi
  000b2	e8 00 00 00 00	 call	 ?HasBuff@CMover@@QAEHGG@Z ; CMover::HasBuff
  000b7	85 c0		 test	 eax, eax
  000b9	75 2c		 jne	 SHORT $L279658

; 3103 : 		{
; 3104 : 			if( --pCol->m_nHitPoint < 0 )

  000bb	ff 4f 7c	 dec	 DWORD PTR [edi+124]
  000be	79 07		 jns	 SHORT $L279656

; 3105 : 				pCol->m_nHitPoint	= 0;

  000c0	c7 47 7c 00 00
	00 00		 mov	 DWORD PTR [edi+124], 0
$L279656:

; 3106 : 
; 3107 : 			UpdateItem( (BYTE)( pCol->m_dwObjId ), UI_HP, pCol->m_nHitPoint );

  000c7	8b 57 7c	 mov	 edx, DWORD PTR [edi+124]
  000ca	33 c0		 xor	 eax, eax
  000cc	8a 47 04	 mov	 al, BYTE PTR [edi+4]
  000cf	6a 00		 push	 0
  000d1	52		 push	 edx
  000d2	6a 01		 push	 1
  000d4	8b ce		 mov	 ecx, esi
  000d6	50		 push	 eax
  000d7	e8 00 00 00 00	 call	 ?UpdateItem@CMover@@QAEXEDKK@Z ; CMover::UpdateItem

; 3108 : 
; 3109 : 			if( pCol->m_nHitPoint == 0 )

  000dc	8b 47 7c	 mov	 eax, DWORD PTR [edi+124]
  000df	85 c0		 test	 eax, eax

; 3110 : 			{
; 3111 : 				StopCollecting();
; 3112 : 				return;

  000e1	0f 84 6c ff ff
	ff		 je	 $L306365
$L279658:
  000e7	53		 push	 ebx

; 3113 : 			}
; 3114 : 		}
; 3115 : 
; 3116 : 		// 3.2. 
; 3117 : 		CCollectingProperty* pProperty	= CCollectingProperty::GetInstance();

  000e8	e8 00 00 00 00	 call	 ?GetInstance@CCollectingProperty@@SAPAV1@XZ ; CCollectingProperty::GetInstance
  000ed	8b d8		 mov	 ebx, eax

; 3118 : 		if( ++m_nCollecting >= pProperty->GetCool( pCol->GetAbilityOption() ) )

  000ef	ff 86 38 96 00
	00		 inc	 DWORD PTR [esi+38456]
  000f5	8b 7f 70	 mov	 edi, DWORD PTR [edi+112]
  000f8	57		 push	 edi
  000f9	8b cb		 mov	 ecx, ebx
  000fb	e8 00 00 00 00	 call	 ?GetCool@CCollectingProperty@@QAEHH@Z ; CCollectingProperty::GetCool
  00100	39 86 38 96 00
	00		 cmp	 DWORD PTR [esi+38456], eax
  00106	0f 8c ee 00 00
	00		 jl	 $L306364

; 3119 : 		{
; 3120 : 			m_nCollecting		= 0;
; 3121 : 
; 3122 : 			DWORD dwItemId	= pProperty->GetItem();

  0010c	8b cb		 mov	 ecx, ebx
  0010e	c7 86 38 96 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+38456], 0
  00118	e8 00 00 00 00	 call	 ?GetItem@CCollectingProperty@@QAEKXZ ; CCollectingProperty::GetItem
  0011d	8b f8		 mov	 edi, eax

; 3123 : 			if( dwItemId == 0 )	

  0011f	85 ff		 test	 edi, edi
  00121	0f 84 d3 00 00
	00		 je	 $L306364

; 3124 : 				return;
; 3125 : 			CItemElem itemElem;

  00127	8d 4c 24 0c	 lea	 ecx, DWORD PTR _itemElem$279663[esp+412]
  0012b	e8 00 00 00 00	 call	 ??0CItemElem@@QAE@XZ	; CItemElem::CItemElem

; 3126 : 			itemElem.m_dwItemId	= dwItemId;
; 3127 : 			itemElem.m_nItemNum		= 1;
; 3128 : 			itemElem.SetSerialNumber();

  00130	8d 4c 24 0c	 lea	 ecx, DWORD PTR _itemElem$279663[esp+412]
  00134	c7 84 24 98 01
	00 00 00 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+420], 0
  0013f	89 7c 24 18	 mov	 DWORD PTR _itemElem$279663[esp+424], edi
  00143	66 c7 84 24 8c
	00 00 00 01 00	 mov	 WORD PTR _itemElem$279663[esp+540], 1
  0014d	e8 00 00 00 00	 call	 ?SetSerialNumber@CItemBase@@QAEXXZ ; CItemBase::SetSerialNumber

; 3129 : 			if( CreateItem( &itemElem ) == TRUE )

  00152	6a 00		 push	 0
  00154	6a 00		 push	 0
  00156	6a 00		 push	 0
  00158	8d 44 24 18	 lea	 eax, DWORD PTR _itemElem$279663[esp+424]
  0015c	50		 push	 eax
  0015d	8b ce		 mov	 ecx, esi
  0015f	e8 00 00 00 00	 call	 ?CreateItem@CMover@@QAEHPAVCItemBase@@PAEPAFE@Z ; CMover::CreateItem
  00164	83 f8 01	 cmp	 eax, 1
  00167	75 7d		 jne	 SHORT $L279664

; 3130 : 			{
; 3131 : //				ItemProp* pItemProp		= itemElem.GetProp();
; 3132 : //				if( pItemProp )
; 3133 : //					AddDefinedText( TID_GAME_REAPITEM, "\"%s\"", pItemProp->szName );
; 3134 : 				AddRestartCollecting( dwItemId );

  00169	57		 push	 edi
  0016a	8b ce		 mov	 ecx, esi
  0016c	e8 00 00 00 00	 call	 ?AddRestartCollecting@CUser@@QAEXK@Z ; CUser::AddRestartCollecting

; 3135 : 				// log
; 3136 : 				LogItemInfo	log;

  00171	8d 8c 24 c4 00
	00 00		 lea	 ecx, DWORD PTR _log$279665[esp+412]
  00178	e8 00 00 00 00	 call	 ??0_LogItemInfo@@QAE@XZ	; _LogItemInfo::_LogItemInfo

; 3137 : 				log.Action	= "c";
; 3138 : 				log.SendName	= GetName();

  0017d	6a 00		 push	 0
  0017f	8b ce		 mov	 ecx, esi
  00181	c7 84 24 c8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR _log$279665[esp+416], OFFSET FLAT:??_C@_01PAPGNFGE@c?$AA@
  0018c	e8 00 00 00 00	 call	 ?GetName@CMover@@QAEPBDH@Z ; CMover::GetName

; 3139 : 				log.RecvName	= "CreateItem";
; 3140 : 				log.WorldId		= GetWorld()->GetID();
; 3141 : 				log.Gold	= GetGold();
; 3142 : 				log.Gold2	= GetGold();
; 3143 : 				g_DPSrvr.OnLogItem( log, &itemElem, itemElem.m_nItemNum );

  00191	0f bf 94 24 8c
	00 00 00	 movsx	 edx, WORD PTR _itemElem$279663[esp+540]
  00199	89 84 24 c8 00
	00 00		 mov	 DWORD PTR _log$279665[esp+416], eax
  001a0	8b 86 6c 01 00
	00		 mov	 eax, DWORD PTR [esi+364]
  001a6	8b b6 84 16 00
	00		 mov	 esi, DWORD PTR [esi+5764]
  001ac	c7 84 24 cc 00
	00 00 00 00 00
	00		 mov	 DWORD PTR _log$279665[esp+420], OFFSET FLAT:??_C@_0L@EMDEHLJF@CreateItem?$AA@
  001b7	8b 08		 mov	 ecx, DWORD PTR [eax]
  001b9	52		 push	 edx
  001ba	89 8c 24 d4 00
	00 00		 mov	 DWORD PTR _log$279665[esp+428], ecx
  001c1	8d 44 24 10	 lea	 eax, DWORD PTR _itemElem$279663[esp+416]
  001c5	50		 push	 eax
  001c6	8d 8c 24 cc 00
	00 00		 lea	 ecx, DWORD PTR _log$279665[esp+420]
  001cd	51		 push	 ecx
  001ce	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_DPSrvr@@3VCDPSrvr@@A
  001d3	89 b4 24 e0 00
	00 00		 mov	 DWORD PTR _log$279665[esp+440], esi
  001da	89 b4 24 e4 00
	00 00		 mov	 DWORD PTR _log$279665[esp+444], esi
  001e1	e8 00 00 00 00	 call	 ?OnLogItem@CDPSrvr@@QAEXAAU_LogItemInfo@@PAVCItemElem@@H@Z ; CDPSrvr::OnLogItem
$L279664:

; 3144 : 			}
; 3145 : 		}

  001e6	8d 4c 24 0c	 lea	 ecx, DWORD PTR _itemElem$279663[esp+412]
  001ea	c7 84 24 98 01
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+420], -1
  001f5	e8 00 00 00 00	 call	 ??1CItemElem@@UAE@XZ	; CItemElem::~CItemElem
$L306364:
  001fa	5b		 pop	 ebx
$L279660:

; 3146 : 		//
; 3147 : 	}
; 3148 : 	else
; 3149 : 	{
; 3150 : 		// 2.   
; 3151 : 	}
; 3152 : }

  001fb	8b 8c 24 8c 01
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+408]
  00202	5f		 pop	 edi
  00203	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0020a	8b 8c 24 84 01
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+404]
  00211	5e		 pop	 esi
  00212	33 cc		 xor	 ecx, esp
  00214	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00219	81 c4 90 01 00
	00		 add	 esp, 400		; 00000190H
  0021f	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L306329:
  00000	8d 8d 70 fe ff
	ff		 lea	 ecx, DWORD PTR _itemElem$279663[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CItemElem@@UAE@XZ	; CItemElem::~CItemElem
__ehhandler$?ProcessCollecting@CUser@@UAEXXZ:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T306361
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?ProcessCollecting@CUser@@UAEXXZ ENDP			; CUser::ProcessCollecting
PUBLIC	?DoUseItemTicket@CUser@@QAEXPAVCItemElem@@@Z	; CUser::DoUseItemTicket
PUBLIC	??_C@_01KGKMHCOC@e?$AA@				; `string'
PUBLIC	??_C@_0BA@CLPMAOJC@DoUseItemTicket?$AA@		; `string'
EXTRN	?Replace@CMover@@QAEHKKAAUD3DXVECTOR3@@W4REPLACE_TYPE@@H@Z:NEAR ; CMover::Replace
EXTRN	?GetInstance@CRainbowRaceMng@@SAPAV1@XZ:NEAR	; CRainbowRaceMng::GetInstance
EXTRN	?DoApplySkill@CCtrl@@QAEHPAV1@PAUItemProp@@PAUAddSkillProp@@_NHHH@Z:NEAR ; CCtrl::DoApplySkill
EXTRN	?RemoveBuff@CMover@@QAEXGG@Z:NEAR		; CMover::RemoveBuff
EXTRN	?HasBuffByIk3@CMover@@QAEHK@Z:NEAR		; CMover::HasBuffByIk3
EXTRN	?IsEntry@CRainbowRaceMng@@QAEHK@Z:NEAR		; CRainbowRaceMng::IsEntry
EXTRN	?g_GuildCombat1to1Mng@@3VCGuildCombat1to1Mng@@A:BYTE ; g_GuildCombat1to1Mng
EXTRN	_atoi:NEAR
EXTRN	?g_uIdofMulti@@3KA:DWORD			; g_uIdofMulti
EXTRN	?IsPossibleUser@CGuildCombat1to1Mng@@QAEHPAVCUser@@@Z:NEAR ; CGuildCombat1to1Mng::IsPossibleUser
EXTRN	?GetInstance@CTicketProperty@@SAPAV1@XZ:NEAR	; CTicketProperty::GetInstance
EXTRN	?GetTicketProp@CTicketProperty@@QAEPAU_TicketProp@@K@Z:NEAR ; CTicketProperty::GetTicketProp
;	COMDAT ??_C@_01KGKMHCOC@e?$AA@
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\ticket.h
CONST	SEGMENT
??_C@_01KGKMHCOC@e?$AA@ DB 'e', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@CLPMAOJC@DoUseItemTicket?$AA@
CONST	SEGMENT
??_C@_0BA@CLPMAOJC@DoUseItemTicket?$AA@ DB 'DoUseItemTicket', 00H ; `string'
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
CONST	ENDS
;	COMDAT ?DoUseItemTicket@CUser@@QAEXPAVCItemElem@@@Z
_TEXT	SEGMENT
$T306418 = -220						; size = 4
$T306374 = -216						; size = 12
_log$279737 = -204					; size = 200
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
_pItemElem$ = 8						; size = 4
?DoUseItemTicket@CUser@@QAEXPAVCItemElem@@@Z PROC NEAR	; CUser::DoUseItemTicket, COMDAT
; _this$ = ecx

; 3403 : {

  00000	81 ec dc 00 00
	00		 sub	 esp, 220		; 000000dcH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c4		 xor	 eax, esp
  0000d	56		 push	 esi
  0000e	57		 push	 edi
  0000f	8b bc 24 e8 00
	00 00		 mov	 edi, DWORD PTR _pItemElem$[esp+224]
  00016	8b f1		 mov	 esi, ecx

; 3404 : 	if( g_GuildCombat1to1Mng.IsPossibleUser( this ) )

  00018	56		 push	 esi
  00019	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_GuildCombat1to1Mng@@3VCGuildCombat1to1Mng@@A
  0001e	89 84 24 e4 00
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+232], eax
  00025	e8 00 00 00 00	 call	 ?IsPossibleUser@CGuildCombat1to1Mng@@QAEHPAVCUser@@@Z ; CGuildCombat1to1Mng::IsPossibleUser
  0002a	85 c0		 test	 eax, eax
  0002c	0f 85 1b 02 00
	00		 jne	 $L279745

; 3405 : 		return;
; 3406 : 
; 3407 : 	ItemProp* pItemProp		= pItemElem->GetProp();

  00032	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  00035	85 c0		 test	 eax, eax
  00037	8b 0d 5c 02 00
	00		 mov	 ecx, DWORD PTR ?prj@@3VCProject@@A+604
  0003d	7c 1d		 jl	 SHORT $L306438
  0003f	3b c1		 cmp	 eax, ecx
  00041	7d 19		 jge	 SHORT $L306438
  00043	72 08		 jb	 SHORT $L306431
  00045	33 c0		 xor	 eax, eax
  00047	89 44 24 08	 mov	 DWORD PTR $T306418[esp+228], eax
  0004b	eb 2d		 jmp	 SHORT $L306433
$L306431:
  0004d	8b 0d 4c 02 00
	00		 mov	 ecx, DWORD PTR ?prj@@3VCProject@@A+588
  00053	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  00056	89 44 24 08	 mov	 DWORD PTR $T306418[esp+228], eax
  0005a	eb 1e		 jmp	 SHORT $L306433
$L306438:
  0005c	50		 push	 eax
  0005d	51		 push	 ecx
  0005e	6a 00		 push	 0
  00060	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BI@BEIFNGEL@GetItemProp?5range_error?$AA@
  00065	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@HMFGHCP@?$CFs?5min?3?$CFd?0?5max?3?$CFd?0?5index?3?$CFd?$AA@
  0006a	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  0006f	83 c4 14	 add	 esp, 20			; 00000014H
  00072	c7 44 24 08 00
	00 00 00	 mov	 DWORD PTR $T306418[esp+228], 0
$L306433:

; 3408 : 	if( HasBuffByIk3( pItemProp->dwItemKind3 ) )

  0007a	8b 54 24 08	 mov	 edx, DWORD PTR $T306418[esp+228]
  0007e	8b 42 78	 mov	 eax, DWORD PTR [edx+120]
  00081	50		 push	 eax
  00082	8b ce		 mov	 ecx, esi
  00084	e8 00 00 00 00	 call	 ?HasBuffByIk3@CMover@@QAEHK@Z ; CMover::HasBuffByIk3
  00089	85 c0		 test	 eax, eax
  0008b	0f 84 82 00 00
	00		 je	 $L279724

; 3409 : 	{
; 3410 : 		if( !HasBuff( BUFF_ITEM, (WORD)( pItemElem->m_dwItemId ) ) )

  00091	33 c9		 xor	 ecx, ecx
  00093	66 8b 4f 0c	 mov	 cx, WORD PTR [edi+12]
  00097	51		 push	 ecx
  00098	6a 00		 push	 0
  0009a	8b ce		 mov	 ecx, esi
  0009c	e8 00 00 00 00	 call	 ?HasBuff@CMover@@QAEHGG@Z ; CMover::HasBuff
  000a1	85 c0		 test	 eax, eax

; 3411 : 		{
; 3412 : 			AddDefinedText( TID_GAME_MUST_STOP_OTHER_TICKET );

  000a3	8b ce		 mov	 ecx, esi
  000a5	75 0f		 jne	 SHORT $L279726
  000a7	68 1e 0e 00 00	 push	 3614			; 00000e1eH
  000ac	e8 00 00 00 00	 call	 ?AddDefinedText@CUser@@QAEXH@Z ; CUser::AddDefinedText

; 3413 : 			return;

  000b1	e9 97 01 00 00	 jmp	 $L279745
$L279726:

; 3414 : 		}
; 3415 : 		if( pItemElem->m_dwKeepTime == 0 )

  000b6	8b 87 b0 00 00
	00		 mov	 eax, DWORD PTR [edi+176]
  000bc	85 c0		 test	 eax, eax
  000be	75 0f		 jne	 SHORT $L279727

; 3416 : 		{
; 3417 : 			AddDefinedText( TID_GAME_LIMITED_USE );

  000c0	68 30 08 00 00	 push	 2096			; 00000830H
  000c5	e8 00 00 00 00	 call	 ?AddDefinedText@CUser@@QAEXH@Z ; CUser::AddDefinedText

; 3418 : 			return;

  000ca	e9 7e 01 00 00	 jmp	 $L279745
$L279727:

; 3419 : 		}
; 3420 : 		RemoveBuff( BUFF_ITEM, (WORD)( pItemElem->m_dwItemId ) );

  000cf	33 d2		 xor	 edx, edx
  000d1	66 8b 57 0c	 mov	 dx, WORD PTR [edi+12]
  000d5	52		 push	 edx
  000d6	6a 00		 push	 0
  000d8	e8 00 00 00 00	 call	 ?RemoveBuff@CMover@@QAEXGG@Z ; CMover::RemoveBuff

; 3421 : 		REPLACE( g_uIdofMulti, WI_WORLD_MADRIGAL, D3DXVECTOR3( 6971.984F, 100.0F, 3336.884F ), REPLACE_FORCE, nDefaultLayer );

  000dd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?g_uIdofMulti@@3KA ; g_uIdofMulti
  000e3	6a 00		 push	 0
  000e5	6a 01		 push	 1
  000e7	8d 44 24 14	 lea	 eax, DWORD PTR $T306374[esp+236]
  000eb	50		 push	 eax
  000ec	6a 01		 push	 1
  000ee	51		 push	 ecx
  000ef	8b ce		 mov	 ecx, esi
  000f1	c7 44 24 20 df
	df d9 45	 mov	 DWORD PTR $T306374[esp+248], 1171906527 ; 45d9dfdfH
  000f9	c7 44 24 24 00
	00 c8 42	 mov	 DWORD PTR $T306374[esp+252], 1120403456 ; 42c80000H
  00101	c7 44 24 28 25
	8e 50 45	 mov	 DWORD PTR $T306374[esp+256], 1162907173 ; 45508e25H
  00109	e8 00 00 00 00	 call	 ?Replace@CMover@@QAEHKKAAUD3DXVECTOR3@@W4REPLACE_TYPE@@H@Z ; CMover::Replace

; 3422 : 	}
; 3423 : 	else

  0010e	e9 3a 01 00 00	 jmp	 $L279745
$L279724:

; 3424 : 	{
; 3425 : #if __VER >= 13 // __RAINBOW_RACE
; 3426 : 		if( CRainbowRaceMng::GetInstance()->IsEntry( m_idPlayer ) )

  00113	8b 96 38 02 00
	00		 mov	 edx, DWORD PTR [esi+568]
  00119	52		 push	 edx
  0011a	e8 00 00 00 00	 call	 ?GetInstance@CRainbowRaceMng@@SAPAV1@XZ ; CRainbowRaceMng::GetInstance
  0011f	8b c8		 mov	 ecx, eax
  00121	e8 00 00 00 00	 call	 ?IsEntry@CRainbowRaceMng@@QAEHK@Z ; CRainbowRaceMng::IsEntry
  00126	85 c0		 test	 eax, eax
  00128	74 11		 je	 SHORT $L279731

; 3427 : 		{
; 3428 : 			AddDefinedText( TID_GAME_RAINBOWRACE_NOTELEPORT );

  0012a	68 c1 0f 00 00	 push	 4033			; 00000fc1H
  0012f	8b ce		 mov	 ecx, esi
  00131	e8 00 00 00 00	 call	 ?AddDefinedText@CUser@@QAEXH@Z ; CUser::AddDefinedText

; 3429 : 			return;

  00136	e9 12 01 00 00	 jmp	 $L279745
$L279731:

; 3430 : 		}
; 3431 : #endif // __RAINBOW_RACE
; 3432 : 		if( pItemElem->m_dwKeepTime == 0 )

  0013b	8b 87 b0 00 00
	00		 mov	 eax, DWORD PTR [edi+176]
  00141	85 c0		 test	 eax, eax
  00143	0f 85 91 00 00
	00		 jne	 $L279735

; 3433 : 		{
; 3434 : 			CItemElem* pTicket	= FindActiveTicket( pItemElem->m_dwItemId );

  00149	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  0014c	50		 push	 eax
  0014d	8b ce		 mov	 ecx, esi
  0014f	e8 00 00 00 00	 call	 ?FindActiveTicket@CUser@@AAEPAVCItemElem@@K@Z ; CUser::FindActiveTicket

; 3435 : 			if( pTicket )

  00154	85 c0		 test	 eax, eax
  00156	74 11		 je	 SHORT $L279734

; 3436 : 			{
; 3437 : 				AddDefinedText( TID_GAME_LIMITED_USE );

  00158	68 30 08 00 00	 push	 2096			; 00000830H
  0015d	8b ce		 mov	 ecx, esi
  0015f	e8 00 00 00 00	 call	 ?AddDefinedText@CUser@@QAEXH@Z ; CUser::AddDefinedText

; 3438 : 				return;

  00164	e9 e4 00 00 00	 jmp	 $L279745
$L279734:

; 3439 : 			}
; 3440 : 			else
; 3441 : 			{
; 3442 : 				UpdateItem( (BYTE)( pItemElem->m_dwObjId ), UI_KEEPTIME, pItemElem->GetProp()->dwAbilityMin );

  00169	6a 00		 push	 0
  0016b	8b cf		 mov	 ecx, edi
  0016d	e8 00 00 00 00	 call	 ?GetPropA@CItemElem@@QAEPAUItemProp@@XZ ; CItemElem::GetPropA
  00172	8b 88 e4 00 00
	00		 mov	 ecx, DWORD PTR [eax+228]
  00178	33 d2		 xor	 edx, edx
  0017a	8a 57 04	 mov	 dl, BYTE PTR [edi+4]
  0017d	51		 push	 ecx
  0017e	6a 0b		 push	 11			; 0000000bH
  00180	8b ce		 mov	 ecx, esi
  00182	52		 push	 edx
  00183	e8 00 00 00 00	 call	 ?UpdateItem@CMover@@QAEXEDKK@Z ; CMover::UpdateItem

; 3443 : 				// log
; 3444 : 				LogItemInfo	log;

  00188	8d 4c 24 18	 lea	 ecx, DWORD PTR _log$279737[esp+228]
  0018c	e8 00 00 00 00	 call	 ??0_LogItemInfo@@QAE@XZ	; _LogItemInfo::_LogItemInfo

; 3445 : 				log.Action	= "e";
; 3446 : 				log.SendName	= GetName();

  00191	6a 00		 push	 0
  00193	8b ce		 mov	 ecx, esi
  00195	c7 44 24 1c 00
	00 00 00	 mov	 DWORD PTR _log$279737[esp+232], OFFSET FLAT:??_C@_01KGKMHCOC@e?$AA@
  0019d	e8 00 00 00 00	 call	 ?GetName@CMover@@QAEPBDH@Z ; CMover::GetName
  001a2	89 44 24 1c	 mov	 DWORD PTR _log$279737[esp+232], eax

; 3447 : 				log.RecvName	= "DoUseItemTicket";
; 3448 : 				log.WorldId		= GetWorld()->GetID();

  001a6	8b 86 6c 01 00
	00		 mov	 eax, DWORD PTR [esi+364]

; 3449 : 				log.Gold	= GetGold();
; 3450 : 				log.Gold2	= GetGold();
; 3451 : 				g_DPSrvr.OnLogItem( log, pItemElem, 1 );

  001ac	6a 01		 push	 1
  001ae	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR _log$279737[esp+240], OFFSET FLAT:??_C@_0BA@CLPMAOJC@DoUseItemTicket?$AA@
  001b6	8b 08		 mov	 ecx, DWORD PTR [eax]
  001b8	8b 86 84 16 00
	00		 mov	 eax, DWORD PTR [esi+5764]
  001be	57		 push	 edi
  001bf	8d 54 24 20	 lea	 edx, DWORD PTR _log$279737[esp+236]
  001c3	89 4c 24 2c	 mov	 DWORD PTR _log$279737[esp+248], ecx
  001c7	52		 push	 edx
  001c8	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_DPSrvr@@3VCDPSrvr@@A
  001cd	89 44 24 34	 mov	 DWORD PTR _log$279737[esp+256], eax
  001d1	89 44 24 38	 mov	 DWORD PTR _log$279737[esp+260], eax
  001d5	e8 00 00 00 00	 call	 ?OnLogItem@CDPSrvr@@QAEXAAU_LogItemInfo@@PAVCItemElem@@H@Z ; CDPSrvr::OnLogItem
$L279735:

; 3452 : 			}
; 3453 : 		}
; 3454 : 		CTicketProperty* pProperty	= CTicketProperty::GetInstance();

  001da	e8 00 00 00 00	 call	 ?GetInstance@CTicketProperty@@SAPAV1@XZ ; CTicketProperty::GetInstance

; 3455 : 		TicketProp* pTicketProp		= pProperty->GetTicketProp( pItemElem->m_dwItemId );

  001df	8b 4f 0c	 mov	 ecx, DWORD PTR [edi+12]
  001e2	51		 push	 ecx
  001e3	8b c8		 mov	 ecx, eax
  001e5	e8 00 00 00 00	 call	 ?GetTicketProp@CTicketProperty@@QAEPAU_TicketProp@@K@Z ; CTicketProperty::GetTicketProp
  001ea	8b f8		 mov	 edi, eax

; 3456 : 		if( pTicketProp )

  001ec	85 ff		 test	 edi, edi
  001ee	74 5d		 je	 SHORT $L279745
  001f0	53		 push	 ebx

; 3457 : 		{
; 3458 : #ifdef __AZRIA_1023
; 3459 : 			int nLayer	= ::atoi( GetInput() );

  001f1	8d 96 44 96 00
	00		 lea	 edx, DWORD PTR [esi+38468]
  001f7	55		 push	 ebp
  001f8	52		 push	 edx
  001f9	e8 00 00 00 00	 call	 _atoi

; 3460 : 			int nExpand	= CTicketProperty::GetInstance()->GetExpanedLayer( pTicketProp->dwWorldId );

  001fe	8b 2f		 mov	 ebp, DWORD PTR [edi]
  00200	83 c4 04	 add	 esp, 4
  00203	8b d8		 mov	 ebx, eax
  00205	e8 00 00 00 00	 call	 ?GetInstance@CTicketProperty@@SAPAV1@XZ ; CTicketProperty::GetInstance
  0020a	55		 push	 ebp
  0020b	8d 48 1c	 lea	 ecx, DWORD PTR [eax+28]
  0020e	e8 00 00 00 00	 call	 ?GetExpanedLayer@CLayerProperty@@QAEHK@Z ; CLayerProperty::GetExpanedLayer

; 3461 : 			if( nLayer <= 0 && nLayer >= -nExpand )

  00213	85 db		 test	 ebx, ebx
  00215	7f 34		 jg	 SHORT $L306476
  00217	f7 d8		 neg	 eax
  00219	3b d8		 cmp	 ebx, eax
  0021b	7c 2e		 jl	 SHORT $L306476

; 3462 : 			{
; 3463 : 				DoApplySkill( (CCtrl*)this, pItemProp, NULL );

  0021d	8b 44 24 10	 mov	 eax, DWORD PTR $T306418[esp+236]
  00221	6a 00		 push	 0
  00223	6a 00		 push	 0
  00225	6a 00		 push	 0
  00227	6a 00		 push	 0
  00229	6a 00		 push	 0
  0022b	50		 push	 eax
  0022c	56		 push	 esi
  0022d	8b ce		 mov	 ecx, esi
  0022f	e8 00 00 00 00	 call	 ?DoApplySkill@CCtrl@@QAEHPAV1@PAUItemProp@@PAUAddSkillProp@@_NHHH@Z ; CCtrl::DoApplySkill

; 3464 : 				REPLACE( g_uIdofMulti, pTicketProp->dwWorldId, pTicketProp->vPos, REPLACE_NORMAL, nLayer );

  00234	8b 17		 mov	 edx, DWORD PTR [edi]
  00236	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_uIdofMulti@@3KA ; g_uIdofMulti
  0023b	53		 push	 ebx
  0023c	6a 00		 push	 0
  0023e	8d 4f 04	 lea	 ecx, DWORD PTR [edi+4]
  00241	51		 push	 ecx
  00242	52		 push	 edx
  00243	50		 push	 eax
  00244	8b ce		 mov	 ecx, esi
  00246	e8 00 00 00 00	 call	 ?Replace@CMover@@QAEHKKAAUD3DXVECTOR3@@W4REPLACE_TYPE@@H@Z ; CMover::Replace
$L306476:
  0024b	5d		 pop	 ebp
  0024c	5b		 pop	 ebx
$L279745:

; 3465 : 			}
; 3466 : #else	// __AZRIA_1023
; 3467 : 			DoApplySkill( (CCtrl*)this, pItemProp, NULL );
; 3468 : 			REPLACE( g_uIdofMulti, pTicketProp->dwWorldId, pTicketProp->vPos, REPLACE_NORMAL, nTempLayer );
; 3469 : #endif	// __AZRIA_1023
; 3470 : 		}
; 3471 : 	}
; 3472 : }

  0024d	8b 8c 24 e0 00
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+228]
  00254	5f		 pop	 edi
  00255	5e		 pop	 esi
  00256	33 cc		 xor	 ecx, esp
  00258	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0025d	81 c4 dc 00 00
	00		 add	 esp, 220		; 000000dcH
  00263	c2 04 00	 ret	 4
?DoUseItemTicket@CUser@@QAEXPAVCItemElem@@@Z ENDP	; CUser::DoUseItemTicket
_TEXT	ENDS
PUBLIC	?AddGC1to1TenderOpenWnd@CUser@@QAEXH@Z		; CUser::AddGC1to1TenderOpenWnd
; Function compile flags: /Ogty
;	COMDAT ?AddGC1to1TenderOpenWnd@CUser@@QAEXH@Z
_TEXT	SEGMENT
_nPenya$ = 8						; size = 4
?AddGC1to1TenderOpenWnd@CUser@@QAEXH@Z PROC NEAR	; CUser::AddGC1to1TenderOpenWnd, COMDAT
; _this$ = ecx

; 3478 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	75 79		 jne	 SHORT $L306513

; 3479 : 	m_Snapshot.cb++;

  00006	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  0000d	56		 push	 esi
  0000e	57		 push	 edi

; 3480 : 	m_Snapshot.ar << NULL_ID;

  0000f	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  00015	6a 04		 push	 4
  00017	8b ce		 mov	 ecx, esi
  00019	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0001e	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00021	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [eax], -1
  00027	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0002a	83 c2 04	 add	 edx, 4

; 3481 : 	m_Snapshot.ar << SNAPSHOTTYPE_GC1TO1_TENDEROPENWND;

  0002d	6a 02		 push	 2
  0002f	8b ce		 mov	 ecx, esi
  00031	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00034	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00039	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003c	66 c7 01 26 01	 mov	 WORD PTR [ecx], 294	; 00000126H
  00041	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00044	83 c0 02	 add	 eax, 2

; 3482 : 	m_Snapshot.ar << nPenya;

  00047	6a 04		 push	 4
  00049	8b ce		 mov	 ecx, esi
  0004b	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0004e	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00053	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00056	8b 44 24 0c	 mov	 eax, DWORD PTR _nPenya$[esp+4]
  0005a	89 02		 mov	 DWORD PTR [edx], eax
  0005c	83 46 08 04	 add	 DWORD PTR [esi+8], 4

; 3483 : 	m_Snapshot.ar << g_GuildCombat1to1Mng.m_nJoinPenya;

  00060	8b 3d 08 00 00
	00		 mov	 edi, DWORD PTR ?g_GuildCombat1to1Mng@@3VCGuildCombat1to1Mng@@A+8
  00066	6a 04		 push	 4
  00068	8b ce		 mov	 ecx, esi
  0006a	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0006f	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00072	89 39		 mov	 DWORD PTR [ecx], edi
  00074	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00077	83 c0 04	 add	 eax, 4
  0007a	5f		 pop	 edi
  0007b	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0007e	5e		 pop	 esi
$L306513:

; 3484 : }

  0007f	c2 04 00	 ret	 4
?AddGC1to1TenderOpenWnd@CUser@@QAEXH@Z ENDP		; CUser::AddGC1to1TenderOpenWnd
_TEXT	ENDS
PUBLIC	?AddGC1to1WarResult@CUser@@QAEXHKHH@Z		; CUser::AddGC1to1WarResult
; Function compile flags: /Ogty
;	COMDAT ?AddGC1to1WarResult@CUser@@QAEXHKHH@Z
_TEXT	SEGMENT
_m_nState$ = 8						; size = 4
_uIdPlayer$ = 12					; size = 4
_nWinCount0$ = 16					; size = 4
_nWinCount1$ = 20					; size = 4
?AddGC1to1WarResult@CUser@@QAEXHKHH@Z PROC NEAR		; CUser::AddGC1to1WarResult, COMDAT
; _this$ = ecx

; 3541 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	0f 85 a3 00 00
	00		 jne	 $L306563

; 3542 : 	m_Snapshot.cb++;

  0000a	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  00011	56		 push	 esi
  00012	57		 push	 edi

; 3543 : 	m_Snapshot.ar << NULL_ID;

  00013	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  00019	bf 04 00 00 00	 mov	 edi, 4
  0001e	57		 push	 edi
  0001f	8b ce		 mov	 ecx, esi
  00021	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00026	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00029	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [eax], -1
  0002f	01 7e 08	 add	 DWORD PTR [esi+8], edi

; 3544 : 	m_Snapshot.ar << SNAPSHOTTYPE_GC1TO1_WARRESULT;

  00032	6a 02		 push	 2
  00034	8b ce		 mov	 ecx, esi
  00036	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003b	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003e	66 c7 01 29 01	 mov	 WORD PTR [ecx], 297	; 00000129H
  00043	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00046	83 c2 02	 add	 edx, 2

; 3545 : 	m_Snapshot.ar << m_nState << uIdPlayer << nWinCount0 << nWinCount1;

  00049	57		 push	 edi
  0004a	8b ce		 mov	 ecx, esi
  0004c	89 56 08	 mov	 DWORD PTR [esi+8], edx
  0004f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00054	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00057	8b 44 24 0c	 mov	 eax, DWORD PTR _m_nState$[esp+4]
  0005b	89 02		 mov	 DWORD PTR [edx], eax
  0005d	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00060	03 c7		 add	 eax, edi
  00062	57		 push	 edi
  00063	8b ce		 mov	 ecx, esi
  00065	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00068	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0006d	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00070	8b 54 24 10	 mov	 edx, DWORD PTR _uIdPlayer$[esp+4]
  00074	89 11		 mov	 DWORD PTR [ecx], edx
  00076	01 7e 08	 add	 DWORD PTR [esi+8], edi
  00079	57		 push	 edi
  0007a	8b ce		 mov	 ecx, esi
  0007c	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00081	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00084	8b 4c 24 14	 mov	 ecx, DWORD PTR _nWinCount0$[esp+4]
  00088	89 08		 mov	 DWORD PTR [eax], ecx
  0008a	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0008d	03 d7		 add	 edx, edi
  0008f	57		 push	 edi
  00090	8b ce		 mov	 ecx, esi
  00092	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00095	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0009a	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0009d	8b 44 24 18	 mov	 eax, DWORD PTR _nWinCount1$[esp+4]
  000a1	89 02		 mov	 DWORD PTR [edx], eax
  000a3	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000a6	03 c7		 add	 eax, edi
  000a8	5f		 pop	 edi
  000a9	89 46 08	 mov	 DWORD PTR [esi+8], eax
  000ac	5e		 pop	 esi
$L306563:

; 3546 : }

  000ad	c2 10 00	 ret	 16			; 00000010H
?AddGC1to1WarResult@CUser@@QAEXHKHH@Z ENDP		; CUser::AddGC1to1WarResult
_TEXT	ENDS
PUBLIC	?AddPocketAttribute@CUser@@QAEXHHH@Z		; CUser::AddPocketAttribute
; Function compile flags: /Ogty
;	COMDAT ?AddPocketAttribute@CUser@@QAEXHHH@Z
_TEXT	SEGMENT
_nAttribute$ = 8					; size = 4
_nPocket$ = 12						; size = 4
_nData$ = 16						; size = 4
?AddPocketAttribute@CUser@@QAEXHHH@Z PROC NEAR		; CUser::AddPocketAttribute, COMDAT
; _this$ = ecx

; 3594 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	0f 85 8f 00 00
	00		 jne	 $L306608

; 3595 : 	m_Snapshot.cb++;

  0000a	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  00011	56		 push	 esi
  00012	57		 push	 edi

; 3596 : 	m_Snapshot.ar << NULL_ID;

  00013	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  00019	bf 04 00 00 00	 mov	 edi, 4
  0001e	57		 push	 edi
  0001f	8b ce		 mov	 ecx, esi
  00021	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00026	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00029	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [eax], -1
  0002f	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00032	03 d7		 add	 edx, edi

; 3597 : 	m_Snapshot.ar << SNAPSHOTTYPE_POCKET_ATTRIBUTE;

  00034	6a 02		 push	 2
  00036	8b ce		 mov	 ecx, esi
  00038	89 56 08	 mov	 DWORD PTR [esi+8], edx
  0003b	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00040	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00043	66 c7 01 00 02	 mov	 WORD PTR [ecx], 512	; 00000200H
  00048	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0004b	83 c0 02	 add	 eax, 2

; 3598 : 	m_Snapshot.ar << nAttribute << nPocket << nData;

  0004e	57		 push	 edi
  0004f	8b ce		 mov	 ecx, esi
  00051	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00054	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00059	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0005c	8b 44 24 0c	 mov	 eax, DWORD PTR _nAttribute$[esp+4]
  00060	89 02		 mov	 DWORD PTR [edx], eax
  00062	01 7e 08	 add	 DWORD PTR [esi+8], edi
  00065	57		 push	 edi
  00066	8b ce		 mov	 ecx, esi
  00068	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0006d	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00070	8b 54 24 10	 mov	 edx, DWORD PTR _nPocket$[esp+4]
  00074	89 11		 mov	 DWORD PTR [ecx], edx
  00076	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00079	03 d7		 add	 edx, edi
  0007b	57		 push	 edi
  0007c	8b ce		 mov	 ecx, esi
  0007e	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00081	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00086	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00089	8b 4c 24 14	 mov	 ecx, DWORD PTR _nData$[esp+4]
  0008d	89 08		 mov	 DWORD PTR [eax], ecx
  0008f	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00092	03 c7		 add	 eax, edi
  00094	5f		 pop	 edi
  00095	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00098	5e		 pop	 esi
$L306608:

; 3599 : }

  00099	c2 0c 00	 ret	 12			; 0000000cH
?AddPocketAttribute@CUser@@QAEXHHH@Z ENDP		; CUser::AddPocketAttribute
_TEXT	ENDS
PUBLIC	??_C@_0BI@IDEPNPML@p?$CD?5?3?5?$CFd?0?5b?5?3?5?$CFd?0?5t?5?3?5?$CFd?$AA@ ; `string'
PUBLIC	??_C@_0CC@KGHJJCFM@nItem?5?3?5?$CFd?0?5szName?3?5?$CFs?0?5nNum?5?3?5?$CF@ ; `string'
PUBLIC	?AddPocketView@CUser@@QAEXXZ			; CUser::AddPocketView
EXTRN	?GetAvailable@CPocketController@@QAEJH@Z:NEAR	; CPocketController::GetAvailable
;	COMDAT ??_C@_0BI@IDEPNPML@p?$CD?5?3?5?$CFd?0?5b?5?3?5?$CFd?0?5t?5?3?5?$CFd?$AA@
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_network\misc\include\ar.h
CONST	SEGMENT
??_C@_0BI@IDEPNPML@p?$CD?5?3?5?$CFd?0?5b?5?3?5?$CFd?0?5t?5?3?5?$CFd?$AA@ DB 'p'
	DB	'# : %d, b : %d, t : %d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@KGHJJCFM@nItem?5?3?5?$CFd?0?5szName?3?5?$CFs?0?5nNum?5?3?5?$CF@
CONST	SEGMENT
??_C@_0CC@KGHJJCFM@nItem?5?3?5?$CFd?0?5szName?3?5?$CFs?0?5nNum?5?3?5?$CF@ DB 'n'
	DB	'Item : %d, szName: %s, nNum : %d', 00H	; `string'
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
CONST	ENDS
;	COMDAT ?AddPocketView@CUser@@QAEXXZ
_TEXT	SEGMENT
_i$279830 = -236					; size = 4
tv529 = -232						; size = 4
tv500 = -228						; size = 4
_j$279838 = -224					; size = 4
_pPocket$279836 = -220					; size = 4
_sPocket$279834 = -216					; size = 100
_sItem$279844 = -112					; size = 100
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
?AddPocketView@CUser@@QAEXXZ PROC NEAR			; CUser::AddPocketView, COMDAT
; _this$ = ecx

; 3602 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	81 ec ec 00 00
	00		 sub	 esp, 236		; 000000ecH
  0000c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00011	53		 push	 ebx
  00012	33 c5		 xor	 eax, ebp
  00014	56		 push	 esi
  00015	89 84 24 f0 00
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+244], eax
  0001c	57		 push	 edi
  0001d	8b d9		 mov	 ebx, ecx

; 3603 : 	for( int i = 0; i < MAX_POCKET; i++ )

  0001f	c7 44 24 0c 00
	00 00 00	 mov	 DWORD PTR _i$279830[esp+248], 0

; 3604 : 	{
; 3605 : 		char sPocket[100]	= { 0,};
; 3606 : 		sprintf( sPocket, "p# : %d, b : %d, t : %d", i, m_Pocket.IsAvailable( i ), m_Pocket.GetAvailable( i ) );

  00027	c7 44 24 10 08
	00 00 00	 mov	 DWORD PTR tv529[esp+248], 8
  0002f	90		 npad	 1
$L279831:
  00030	33 c0		 xor	 eax, eax
  00032	c6 44 24 20 00	 mov	 BYTE PTR _sPocket$279834[esp+248], 0
  00037	b9 18 00 00 00	 mov	 ecx, 24			; 00000018H
  0003c	8d 7c 24 21	 lea	 edi, DWORD PTR _sPocket$279834[esp+249]
  00040	f3 ab		 rep stosd
  00042	66 ab		 stosw
  00044	aa		 stosb
  00045	8b 44 24 10	 mov	 eax, DWORD PTR tv529[esp+248]
  00049	8b 84 18 f4 0b
	00 00		 mov	 eax, DWORD PTR [eax+ebx+3060]
  00050	85 c0		 test	 eax, eax
  00052	8d 8b f4 0b 00
	00		 lea	 ecx, DWORD PTR [ebx+3060]
  00058	74 0e		 je	 SHORT $L306623
  0005a	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  0005d	85 d2		 test	 edx, edx
  0005f	75 07		 jne	 SHORT $L306623
  00061	be 01 00 00 00	 mov	 esi, 1
  00066	eb 02		 jmp	 SHORT $L306624
$L306623:
  00068	33 f6		 xor	 esi, esi
$L306624:
  0006a	8b 54 24 0c	 mov	 edx, DWORD PTR _i$279830[esp+248]
  0006e	52		 push	 edx
  0006f	e8 00 00 00 00	 call	 ?GetAvailable@CPocketController@@QAEJH@Z ; CPocketController::GetAvailable
  00074	50		 push	 eax
  00075	8b 44 24 10	 mov	 eax, DWORD PTR _i$279830[esp+252]
  00079	56		 push	 esi
  0007a	50		 push	 eax
  0007b	8d 4c 24 2c	 lea	 ecx, DWORD PTR _sPocket$279834[esp+260]
  0007f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BI@IDEPNPML@p?$CD?5?3?5?$CFd?0?5b?5?3?5?$CFd?0?5t?5?3?5?$CFd?$AA@
  00084	51		 push	 ecx
  00085	e8 00 00 00 00	 call	 _sprintf

; 3607 : 		AddText( sPocket );

  0008a	8a 43 04	 mov	 al, BYTE PTR [ebx+4]
  0008d	83 c4 14	 add	 esp, 20			; 00000014H
  00090	a8 01		 test	 al, 1
  00092	75 5f		 jne	 SHORT $L306662
  00094	66 ff 83 0c 57
	00 00		 inc	 WORD PTR [ebx+22284]
  0009b	8d b3 f8 16 00
	00		 lea	 esi, DWORD PTR [ebx+5880]
  000a1	6a 04		 push	 4
  000a3	8b ce		 mov	 ecx, esi
  000a5	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000aa	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  000ad	c7 02 ff ff ff
	ff		 mov	 DWORD PTR [edx], -1
  000b3	83 46 08 04	 add	 DWORD PTR [esi+8], 4
  000b7	6a 02		 push	 2
  000b9	8b ce		 mov	 ecx, esi
  000bb	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000c0	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000c3	66 c7 00 a0 00	 mov	 WORD PTR [eax], 160	; 000000a0H
  000c8	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  000cb	83 c7 02	 add	 edi, 2
  000ce	6a 01		 push	 1
  000d0	8b ce		 mov	 ecx, esi
  000d2	89 7e 08	 mov	 DWORD PTR [esi+8], edi
  000d5	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000da	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  000dd	c6 01 01	 mov	 BYTE PTR [ecx], 1
  000e0	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  000e3	41		 inc	 ecx
  000e4	8d 54 24 20	 lea	 edx, DWORD PTR _sPocket$279834[esp+248]
  000e8	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  000eb	52		 push	 edx
  000ec	8b ce		 mov	 ecx, esi
  000ee	e8 00 00 00 00	 call	 ?WriteString@CAr@@QAEXPBD@Z ; CAr::WriteString
$L306662:

; 3608 : 		CPocket* pPocket	= m_Pocket.GetPocket( i );

  000f3	8b 44 24 0c	 mov	 eax, DWORD PTR _i$279830[esp+248]
  000f7	50		 push	 eax
  000f8	8d 8b f4 0b 00
	00		 lea	 ecx, DWORD PTR [ebx+3060]
  000fe	e8 00 00 00 00	 call	 ?GetPocket@CPocketController@@QAEPAVCPocket@@H@Z ; CPocketController::GetPocket

; 3609 : 		if( pPocket )

  00103	33 d2		 xor	 edx, edx
  00105	3b c2		 cmp	 eax, edx
  00107	89 44 24 1c	 mov	 DWORD PTR _pPocket$279836[esp+248], eax
  0010b	0f 84 37 01 00
	00		 je	 $L279832

; 3610 : 		{
; 3611 : 			for( int j = 0; j < pPocket->GetMax(); j++ )

  00111	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00114	3b d1		 cmp	 edx, ecx
  00116	89 54 24 18	 mov	 DWORD PTR _j$279838[esp+248], edx
  0011a	0f 8d 28 01 00
	00		 jge	 $L279832
  00120	89 54 24 14	 mov	 DWORD PTR tv500[esp+248], edx
$L306795:

; 3612 : 			{
; 3613 : 				CItemElem* pItem	= pPocket->GetAtId( j );

  00124	0f 83 fc 00 00
	00		 jae	 $L279840
  0012a	8b 54 24 14	 mov	 edx, DWORD PTR tv500[esp+248]
  0012e	8b 70 10	 mov	 esi, DWORD PTR [eax+16]
  00131	03 f2		 add	 esi, edx
  00133	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  00136	85 d2		 test	 edx, edx
  00138	0f 84 e8 00 00
	00		 je	 $L279840

; 3614 : 				if( pItem )
; 3615 : 				{
; 3616 : 					char sItem[100]	= { 0,};

  0013e	33 c0		 xor	 eax, eax

; 3617 : 					sprintf( sItem, "nItem : %d, szName: %s, nNum : %d", j, pItem->GetProp()->szName, pItem->m_nItemNum );

  00140	85 d2		 test	 edx, edx
  00142	c6 84 24 88 00
	00 00 00	 mov	 BYTE PTR _sItem$279844[esp+248], 0
  0014a	b9 18 00 00 00	 mov	 ecx, 24			; 00000018H
  0014f	8d bc 24 89 00
	00 00		 lea	 edi, DWORD PTR _sItem$279844[esp+249]
  00156	f3 ab		 rep stosd
  00158	66 ab		 stosw
  0015a	aa		 stosb
  0015b	a1 5c 02 00 00	 mov	 eax, DWORD PTR ?prj@@3VCProject@@A+604
  00160	7c 19		 jl	 SHORT $L306735
  00162	3b d0		 cmp	 edx, eax
  00164	7d 15		 jge	 SHORT $L306735
  00166	72 06		 jb	 SHORT $L306747
  00168	33 d2		 xor	 edx, edx
  0016a	8b c2		 mov	 eax, edx
  0016c	eb 25		 jmp	 SHORT $L306730
$L306747:
  0016e	8b 0d 4c 02 00
	00		 mov	 ecx, DWORD PTR ?prj@@3VCProject@@A+588
  00174	8b 14 91	 mov	 edx, DWORD PTR [ecx+edx*4]
  00177	8b c2		 mov	 eax, edx
  00179	eb 18		 jmp	 SHORT $L306730
$L306735:
  0017b	52		 push	 edx
  0017c	50		 push	 eax
  0017d	6a 00		 push	 0
  0017f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BI@BEIFNGEL@GetItemProp?5range_error?$AA@
  00184	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@HMFGHCP@?$CFs?5min?3?$CFd?0?5max?3?$CFd?0?5index?3?$CFd?$AA@
  00189	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  0018e	83 c4 14	 add	 esp, 20			; 00000014H
  00191	33 c0		 xor	 eax, eax
$L306730:
  00193	0f bf 96 80 00
	00 00		 movsx	 edx, WORD PTR [esi+128]
  0019a	52		 push	 edx
  0019b	83 c0 04	 add	 eax, 4
  0019e	50		 push	 eax
  0019f	8b 44 24 20	 mov	 eax, DWORD PTR _j$279838[esp+256]
  001a3	50		 push	 eax
  001a4	8d 8c 24 94 00
	00 00		 lea	 ecx, DWORD PTR _sItem$279844[esp+260]
  001ab	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CC@KGHJJCFM@nItem?5?3?5?$CFd?0?5szName?3?5?$CFs?0?5nNum?5?3?5?$CF@
  001b0	51		 push	 ecx
  001b1	e8 00 00 00 00	 call	 _sprintf

; 3618 : 					AddText( sItem );

  001b6	8a 43 04	 mov	 al, BYTE PTR [ebx+4]
  001b9	83 c4 14	 add	 esp, 20			; 00000014H
  001bc	a8 01		 test	 al, 1
  001be	75 62		 jne	 SHORT $L306791
  001c0	66 ff 83 0c 57
	00 00		 inc	 WORD PTR [ebx+22284]
  001c7	8d b3 f8 16 00
	00		 lea	 esi, DWORD PTR [ebx+5880]
  001cd	6a 04		 push	 4
  001cf	8b ce		 mov	 ecx, esi
  001d1	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  001d6	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  001d9	c7 02 ff ff ff
	ff		 mov	 DWORD PTR [edx], -1
  001df	83 46 08 04	 add	 DWORD PTR [esi+8], 4
  001e3	6a 02		 push	 2
  001e5	8b ce		 mov	 ecx, esi
  001e7	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  001ec	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  001ef	66 c7 00 a0 00	 mov	 WORD PTR [eax], 160	; 000000a0H
  001f4	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  001f7	83 c7 02	 add	 edi, 2
  001fa	6a 01		 push	 1
  001fc	8b ce		 mov	 ecx, esi
  001fe	89 7e 08	 mov	 DWORD PTR [esi+8], edi
  00201	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00206	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00209	c6 01 01	 mov	 BYTE PTR [ecx], 1
  0020c	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0020f	41		 inc	 ecx
  00210	8d 94 24 88 00
	00 00		 lea	 edx, DWORD PTR _sItem$279844[esp+248]
  00217	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  0021a	52		 push	 edx
  0021b	8b ce		 mov	 ecx, esi
  0021d	e8 00 00 00 00	 call	 ?WriteString@CAr@@QAEXPBD@Z ; CAr::WriteString
$L306791:
  00222	8b 44 24 1c	 mov	 eax, DWORD PTR _pPocket$279836[esp+248]
$L279840:

; 3610 : 		{
; 3611 : 			for( int j = 0; j < pPocket->GetMax(); j++ )

  00226	8b 54 24 18	 mov	 edx, DWORD PTR _j$279838[esp+248]
  0022a	8b 7c 24 14	 mov	 edi, DWORD PTR tv500[esp+248]
  0022e	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00231	42		 inc	 edx
  00232	81 c7 b8 00 00
	00		 add	 edi, 184		; 000000b8H
  00238	3b d1		 cmp	 edx, ecx
  0023a	89 54 24 18	 mov	 DWORD PTR _j$279838[esp+248], edx
  0023e	89 7c 24 14	 mov	 DWORD PTR tv500[esp+248], edi
  00242	0f 8c dc fe ff
	ff		 jl	 $L306795
$L279832:

; 3603 : 	for( int i = 0; i < MAX_POCKET; i++ )

  00248	8b 44 24 10	 mov	 eax, DWORD PTR tv529[esp+248]
  0024c	8b 74 24 0c	 mov	 esi, DWORD PTR _i$279830[esp+248]
  00250	83 c0 04	 add	 eax, 4
  00253	46		 inc	 esi
  00254	83 f8 14	 cmp	 eax, 20			; 00000014H
  00257	89 74 24 0c	 mov	 DWORD PTR _i$279830[esp+248], esi
  0025b	89 44 24 10	 mov	 DWORD PTR tv529[esp+248], eax
  0025f	0f 8c cb fd ff
	ff		 jl	 $L279831

; 3619 : 				}
; 3620 : 			}
; 3621 : 		}
; 3622 : 	}
; 3623 : }

  00265	8b 8c 24 f4 00
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+248]
  0026c	5f		 pop	 edi
  0026d	5e		 pop	 esi
  0026e	33 cd		 xor	 ecx, ebp
  00270	5b		 pop	 ebx
  00271	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00276	8b e5		 mov	 esp, ebp
  00278	5d		 pop	 ebp
  00279	c3		 ret	 0
?AddPocketView@CUser@@QAEXXZ ENDP			; CUser::AddPocketView
_TEXT	ENDS
PUBLIC	?AddPocketAddItem@CUser@@QAEXHPAVCItemElem@@@Z	; CUser::AddPocketAddItem
; Function compile flags: /Ogty
;	COMDAT ?AddPocketAddItem@CUser@@QAEXHPAVCItemElem@@@Z
_TEXT	SEGMENT
_nPocket$ = 8						; size = 4
_pItem$ = 12						; size = 4
?AddPocketAddItem@CUser@@QAEXHPAVCItemElem@@@Z PROC NEAR ; CUser::AddPocketAddItem, COMDAT
; _this$ = ecx

; 3627 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	75 64		 jne	 SHORT $L279850

; 3628 : 	m_Snapshot.cb++;

  00006	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  0000d	56		 push	 esi

; 3629 : 	m_Snapshot.ar << NULL_ID;

  0000e	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  00014	6a 04		 push	 4
  00016	8b ce		 mov	 ecx, esi
  00018	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0001d	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00020	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [eax], -1
  00026	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00029	83 c2 04	 add	 edx, 4

; 3630 : 	m_Snapshot.ar << SNAPSHOTTYPE_POCKET_ADD_ITEM;

  0002c	6a 02		 push	 2
  0002e	8b ce		 mov	 ecx, esi
  00030	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00033	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00038	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003b	66 c7 01 01 02	 mov	 WORD PTR [ecx], 513	; 00000201H
  00040	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00043	83 c0 02	 add	 eax, 2

; 3631 : 	m_Snapshot.ar << nPocket;

  00046	6a 04		 push	 4
  00048	8b ce		 mov	 ecx, esi
  0004a	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0004d	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00052	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00055	8b 44 24 08	 mov	 eax, DWORD PTR _nPocket$[esp]
  00059	89 02		 mov	 DWORD PTR [edx], eax
  0005b	83 46 08 04	 add	 DWORD PTR [esi+8], 4

; 3632 : 	pItem->Serialize( m_Snapshot.ar );

  0005f	8b 4c 24 0c	 mov	 ecx, DWORD PTR _pItem$[esp]
  00063	8b 11		 mov	 edx, DWORD PTR [ecx]
  00065	56		 push	 esi
  00066	ff 52 08	 call	 DWORD PTR [edx+8]
  00069	5e		 pop	 esi
$L279850:

; 3633 : }

  0006a	c2 08 00	 ret	 8
?AddPocketAddItem@CUser@@QAEXHPAVCItemElem@@@Z ENDP	; CUser::AddPocketAddItem
_TEXT	ENDS
PUBLIC	?AddPocketRemoveItem@CUser@@QAEXHHF@Z		; CUser::AddPocketRemoveItem
; Function compile flags: /Ogty
;	COMDAT ?AddPocketRemoveItem@CUser@@QAEXHHF@Z
_TEXT	SEGMENT
_nPocket$ = 8						; size = 4
_nItem$ = 12						; size = 4
_nNum$ = 16						; size = 2
?AddPocketRemoveItem@CUser@@QAEXHHF@Z PROC NEAR		; CUser::AddPocketRemoveItem, COMDAT
; _this$ = ecx

; 3637 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	0f 85 8d 00 00
	00		 jne	 $L306865

; 3638 : 	m_Snapshot.cb++;

  0000a	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  00011	56		 push	 esi

; 3639 : 	m_Snapshot.ar << NULL_ID;

  00012	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  00018	6a 04		 push	 4
  0001a	8b ce		 mov	 ecx, esi
  0001c	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00021	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00024	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [eax], -1
  0002a	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0002d	83 c2 04	 add	 edx, 4

; 3640 : 	m_Snapshot.ar << SNAPSHOTTYPE_POCKET_REMOVE_ITEM;

  00030	6a 02		 push	 2
  00032	8b ce		 mov	 ecx, esi
  00034	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00037	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003c	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003f	66 c7 01 02 02	 mov	 WORD PTR [ecx], 514	; 00000202H
  00044	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00047	83 c0 02	 add	 eax, 2

; 3641 : 	m_Snapshot.ar << nPocket << nItem << nNum;

  0004a	6a 04		 push	 4
  0004c	8b ce		 mov	 ecx, esi
  0004e	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00051	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00056	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00059	8b 44 24 08	 mov	 eax, DWORD PTR _nPocket$[esp]
  0005d	89 02		 mov	 DWORD PTR [edx], eax
  0005f	83 46 08 04	 add	 DWORD PTR [esi+8], 4
  00063	6a 04		 push	 4
  00065	8b ce		 mov	 ecx, esi
  00067	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0006c	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0006f	8b 54 24 0c	 mov	 edx, DWORD PTR _nItem$[esp]
  00073	89 11		 mov	 DWORD PTR [ecx], edx
  00075	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00078	83 c2 04	 add	 edx, 4
  0007b	6a 02		 push	 2
  0007d	8b ce		 mov	 ecx, esi
  0007f	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00082	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00087	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0008a	66 8b 4c 24 10	 mov	 cx, WORD PTR _nNum$[esp]
  0008f	66 89 08	 mov	 WORD PTR [eax], cx
  00092	83 46 08 02	 add	 DWORD PTR [esi+8], 2
  00096	5e		 pop	 esi
$L306865:

; 3642 : }

  00097	c2 0c 00	 ret	 12			; 0000000cH
?AddPocketRemoveItem@CUser@@QAEXHHF@Z ENDP		; CUser::AddPocketRemoveItem
_TEXT	ENDS
PUBLIC	?AddQuePetResurrectionResult@CUser@@QAEXH@Z	; CUser::AddQuePetResurrectionResult
; Function compile flags: /Ogty
;	COMDAT ?AddQuePetResurrectionResult@CUser@@QAEXH@Z
_TEXT	SEGMENT
_bResult$ = 8						; size = 4
?AddQuePetResurrectionResult@CUser@@QAEXH@Z PROC NEAR	; CUser::AddQuePetResurrectionResult, COMDAT
; _this$ = ecx

; 3648 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	75 55		 jne	 SHORT $L306893

; 3649 : 	m_Snapshot.cb++;

  00006	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  0000d	56		 push	 esi

; 3650 : 	m_Snapshot.ar << NULL_ID;

  0000e	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  00014	6a 04		 push	 4
  00016	8b ce		 mov	 ecx, esi
  00018	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0001d	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00020	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [eax], -1
  00026	83 46 08 04	 add	 DWORD PTR [esi+8], 4

; 3651 : 	m_Snapshot.ar << SNAPSHOTTYPE_QUE_PETRESURRECTION_RESULT;

  0002a	6a 02		 push	 2
  0002c	8b ce		 mov	 ecx, esi
  0002e	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00033	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00036	66 c7 01 03 02	 mov	 WORD PTR [ecx], 515	; 00000203H
  0003b	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0003e	83 c2 02	 add	 edx, 2

; 3652 : 	m_Snapshot.ar << bResult;

  00041	6a 04		 push	 4
  00043	8b ce		 mov	 ecx, esi
  00045	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00048	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0004d	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00050	8b 44 24 08	 mov	 eax, DWORD PTR _bResult$[esp]
  00054	89 02		 mov	 DWORD PTR [edx], eax
  00056	83 46 08 04	 add	 DWORD PTR [esi+8], 4
  0005a	5e		 pop	 esi
$L306893:

; 3653 : }

  0005b	c2 04 00	 ret	 4
?AddQuePetResurrectionResult@CUser@@QAEXH@Z ENDP	; CUser::AddQuePetResurrectionResult
_TEXT	ENDS
PUBLIC	?ValidateItem@CUser@@QAEXXZ			; CUser::ValidateItem
PUBLIC	??_C@_0BE@JFOKAJOJ@ITEMPROP?1?10?1?1?$CFs?1?1?$CFd?$AA@ ; `string'
PUBLIC	??_C@_0BD@CHKPHCIE@ITEMNUM?1?10?1?1?$CFs?1?1?$CFd?$AA@ ; `string'
;	COMDAT ??_C@_0BD@CHKPHCIE@ITEMNUM?1?10?1?1?$CFs?1?1?$CFd?$AA@
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\item.h
CONST	SEGMENT
??_C@_0BD@CHKPHCIE@ITEMNUM?1?10?1?1?$CFs?1?1?$CFd?$AA@ DB 'ITEMNUM//0//%s'
	DB	'//%d', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@JFOKAJOJ@ITEMPROP?1?10?1?1?$CFs?1?1?$CFd?$AA@
CONST	SEGMENT
??_C@_0BE@JFOKAJOJ@ITEMPROP?1?10?1?1?$CFs?1?1?$CFd?$AA@ DB 'ITEMPROP//0//'
	DB	'%s//%d', 00H				; `string'
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
CONST	ENDS
;	COMDAT ?ValidateItem@CUser@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
_nSize$ = -4						; size = 4
?ValidateItem@CUser@@QAEXXZ PROC NEAR			; CUser::ValidateItem, COMDAT
; _this$ = ecx

; 3657 : {

  00000	83 ec 08	 sub	 esp, 8

; 3658 : 	int nSize	= m_Inventory.GetMax();

  00003	8b 81 9c 0b 00
	00		 mov	 eax, DWORD PTR [ecx+2972]
  00009	53		 push	 ebx

; 3659 : 	ItemProp* pItemProp;
; 3660 : 	for( int i = 0; i < nSize; i++ )

  0000a	33 db		 xor	 ebx, ebx
  0000c	85 c0		 test	 eax, eax
  0000e	89 4c 24 04	 mov	 DWORD PTR _this$[esp+12], ecx
  00012	89 44 24 08	 mov	 DWORD PTR _nSize$[esp+12], eax
  00016	0f 8e 29 01 00
	00		 jle	 $L279876
  0001c	55		 push	 ebp
  0001d	56		 push	 esi
  0001e	57		 push	 edi
  0001f	8d b9 90 0b 00
	00		 lea	 edi, DWORD PTR [ecx+2960]
  00025	33 ed		 xor	 ebp, ebp
$L307004:

; 3661 : 	{
; 3662 : 		CItemElem* pItemElem	= m_Inventory.GetAtId( i );

  00027	3b 5f 0c	 cmp	 ebx, DWORD PTR [edi+12]
  0002a	0f 83 ff 00 00
	00		 jae	 $L279875
  00030	8b 77 10	 mov	 esi, DWORD PTR [edi+16]
  00033	8b 44 2e 0c	 mov	 eax, DWORD PTR [esi+ebp+12]
  00037	03 f5		 add	 esi, ebp
  00039	85 c0		 test	 eax, eax
  0003b	0f 84 ee 00 00
	00		 je	 $L279875

; 3663 : 		if( pItemElem )
; 3664 : 		{
; 3665 : 			pItemElem->SetExtra( 0 );
; 3666 : 			if( pItemElem->GetSerialNumber() == 0 )

  00041	8b 46 38	 mov	 eax, DWORD PTR [esi+56]
  00044	85 c0		 test	 eax, eax
  00046	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  0004d	75 07		 jne	 SHORT $L279879

; 3667 : 				pItemElem->SetSerialNumber();

  0004f	8b ce		 mov	 ecx, esi
  00051	e8 00 00 00 00	 call	 ?SetSerialNumber@CItemBase@@QAEXXZ ; CItemBase::SetSerialNumber
$L279879:

; 3668 : 
; 3669 : 			pItemProp	= pItemElem->GetProp();

  00056	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00059	85 c0		 test	 eax, eax
  0005b	8b 0d 5c 02 00
	00		 mov	 ecx, DWORD PTR ?prj@@3VCProject@@A+604
  00061	7c 57		 jl	 SHORT $L306979
  00063	3b c1		 cmp	 eax, ecx
  00065	7d 53		 jge	 SHORT $L306979
  00067	72 46		 jb	 SHORT $L306991
  00069	33 c0		 xor	 eax, eax
$L306974:

; 3670 : 			if( !pItemProp || pItemProp->dwItemKind3 == IK3_VIRTUAL )

  0006b	85 c0		 test	 eax, eax
  0006d	74 61		 je	 SHORT $L279881
  0006f	83 78 78 0a	 cmp	 DWORD PTR [eax+120], 10	; 0000000aH
  00073	74 5b		 je	 SHORT $L279881

; 3674 : 				continue;
; 3675 : 			}
; 3676 : 			if( pItemElem->m_nItemNum <= 0 )

  00075	66 8b b6 80 00
	00 00		 mov	 si, WORD PTR [esi+128]
  0007c	66 85 f6	 test	 si, si
  0007f	0f 8f aa 00 00
	00		 jg	 $L279875

; 3677 : 			{
; 3678 : 				WriteError( "ITEMNUM//0//%s//%d", GetName(), pItemElem->m_nItemNum );

  00085	8b 4c 24 10	 mov	 ecx, DWORD PTR _this$[esp+24]
  00089	0f bf d6	 movsx	 edx, si
  0008c	52		 push	 edx
  0008d	6a 00		 push	 0
  0008f	e8 00 00 00 00	 call	 ?GetName@CMover@@QAEPBDH@Z ; CMover::GetName
  00094	50		 push	 eax
  00095	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BD@CHKPHCIE@ITEMNUM?1?10?1?1?$CFs?1?1?$CFd?$AA@
  0009a	e8 00 00 00 00	 call	 ?WriteError@@YAXPBDZZ	; WriteError
  0009f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3679 : 				m_Inventory.RemoveAtId( i );

  000a2	53		 push	 ebx
  000a3	8b cf		 mov	 ecx, edi
  000a5	e8 00 00 00 00	 call	 ?RemoveAtId@?$CItemContainer@VCItemElem@@@@QAEXK@Z ; CItemContainer<CItemElem>::RemoveAtId
  000aa	e9 80 00 00 00	 jmp	 $L279875

; 3668 : 
; 3669 : 			pItemProp	= pItemElem->GetProp();

$L306991:
  000af	8b 0d 4c 02 00
	00		 mov	 ecx, DWORD PTR ?prj@@3VCProject@@A+588
  000b5	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  000b8	eb b1		 jmp	 SHORT $L306974
$L306979:
  000ba	50		 push	 eax
  000bb	51		 push	 ecx
  000bc	6a 00		 push	 0
  000be	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BI@BEIFNGEL@GetItemProp?5range_error?$AA@
  000c3	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@HMFGHCP@?$CFs?5min?3?$CFd?0?5max?3?$CFd?0?5index?3?$CFd?$AA@
  000c8	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  000cd	83 c4 14	 add	 esp, 20			; 00000014H
$L279881:

; 3671 : 			{
; 3672 : 				WriteError( "ITEMPROP//0//%s//%d", GetName(), pItemElem->m_dwItemId );

  000d0	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  000d3	8b 4c 24 10	 mov	 ecx, DWORD PTR _this$[esp+24]
  000d7	50		 push	 eax
  000d8	6a 00		 push	 0
  000da	e8 00 00 00 00	 call	 ?GetName@CMover@@QAEPBDH@Z ; CMover::GetName
  000df	50		 push	 eax
  000e0	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BE@JFOKAJOJ@ITEMPROP?1?10?1?1?$CFs?1?1?$CFd?$AA@
  000e5	e8 00 00 00 00	 call	 ?WriteError@@YAXPBDZZ	; WriteError

; 3673 : 				m_Inventory.RemoveAtId( i );

  000ea	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  000ed	83 c4 0c	 add	 esp, 12			; 0000000cH
  000f0	3b d8		 cmp	 ebx, eax
  000f2	73 3b		 jae	 SHORT $L279875
  000f4	8b 4f 10	 mov	 ecx, DWORD PTR [edi+16]
  000f7	39 44 29 08	 cmp	 DWORD PTR [ecx+ebp+8], eax
  000fb	73 32		 jae	 SHORT $L279875
  000fd	8b d1		 mov	 edx, ecx
  000ff	8b 04 2a	 mov	 eax, DWORD PTR [edx+ebp]
  00102	8d 0c 2a	 lea	 ecx, DWORD PTR [edx+ebp]
  00105	ff 50 0c	 call	 DWORD PTR [eax+12]
  00108	8b 4f 10	 mov	 ecx, DWORD PTR [edi+16]
  0010b	8b 54 29 08	 mov	 edx, DWORD PTR [ecx+ebp+8]
  0010f	3b 57 08	 cmp	 edx, DWORD PTR [edi+8]
  00112	72 1b		 jb	 SHORT $L279875
  00114	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  00117	8b c1		 mov	 eax, ecx
  00119	8b 4c 28 08	 mov	 ecx, DWORD PTR [eax+ebp+8]
  0011d	c7 04 8a ff ff
	ff ff		 mov	 DWORD PTR [edx+ecx*4], -1
  00124	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  00127	c7 44 28 08 ff
	ff ff ff	 mov	 DWORD PTR [eax+ebp+8], -1
$L279875:
  0012f	8b 44 24 14	 mov	 eax, DWORD PTR _nSize$[esp+24]
  00133	43		 inc	 ebx
  00134	81 c5 b8 00 00
	00		 add	 ebp, 184		; 000000b8H
  0013a	3b d8		 cmp	 ebx, eax
  0013c	0f 8c e5 fe ff
	ff		 jl	 $L307004
  00142	5f		 pop	 edi
  00143	5e		 pop	 esi
  00144	5d		 pop	 ebp
$L279876:
  00145	5b		 pop	 ebx

; 3680 : 			}
; 3681 : 		}
; 3682 : 	}
; 3683 : }

  00146	83 c4 08	 add	 esp, 8
  00149	c3		 ret	 0
?ValidateItem@CUser@@QAEXXZ ENDP			; CUser::ValidateItem
_TEXT	ENDS
PUBLIC	?AddAddCoupleExperience@CUser@@QAEXH@Z		; CUser::AddAddCoupleExperience
; Function compile flags: /Ogty
;	COMDAT ?AddAddCoupleExperience@CUser@@QAEXH@Z
_TEXT	SEGMENT
_nExperience$ = 8					; size = 4
?AddAddCoupleExperience@CUser@@QAEXH@Z PROC NEAR	; CUser::AddAddCoupleExperience, COMDAT
; _this$ = ecx

; 3845 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	75 63		 jne	 SHORT $L307027

; 3846 : 	m_Snapshot.cb++;

  00006	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  0000d	56		 push	 esi
  0000e	57		 push	 edi

; 3847 : 	m_Snapshot.ar << GetId();

  0000f	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  00015	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  0001b	6a 04		 push	 4
  0001d	8b ce		 mov	 ecx, esi
  0001f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00024	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00027	89 38		 mov	 DWORD PTR [eax], edi
  00029	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0002c	83 c0 04	 add	 eax, 4

; 3848 : 	m_Snapshot.ar << SNAPSHOTTYPE_ADD_COUPLE_EXPERIENCE;

  0002f	6a 02		 push	 2
  00031	8b ce		 mov	 ecx, esi
  00033	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00036	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003b	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003e	66 c7 01 05 97	 mov	 WORD PTR [ecx], 38661	; 00009705H
  00043	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00046	83 c2 02	 add	 edx, 2

; 3849 : 	m_Snapshot.ar << nExperience;

  00049	6a 04		 push	 4
  0004b	8b ce		 mov	 ecx, esi
  0004d	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00050	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00055	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00058	8b 44 24 0c	 mov	 eax, DWORD PTR _nExperience$[esp+4]
  0005c	89 02		 mov	 DWORD PTR [edx], eax
  0005e	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00061	83 c0 04	 add	 eax, 4
  00064	5f		 pop	 edi
  00065	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00068	5e		 pop	 esi
$L307027:

; 3850 : }

  00069	c2 04 00	 ret	 4
?AddAddCoupleExperience@CUser@@QAEXH@Z ENDP		; CUser::AddAddCoupleExperience
_TEXT	ENDS
PUBLIC	?AddNewChatting@CUser@@QAEXPAVCChatting@@@Z	; CUser::AddNewChatting
PUBLIC	??_C@_0DJ@NAGLBLJJ@AddNewChatting?5?3?5MAX_ChattingMem@ ; `string'
;	COMDAT ??_C@_0DJ@NAGLBLJJ@AddNewChatting?5?3?5MAX_ChattingMem@
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\chatting.h
CONST	SEGMENT
??_C@_0DJ@NAGLBLJJ@AddNewChatting?5?3?5MAX_ChattingMem@ DB 'AddNewChattin'
	DB	'g : MAX_ChattingMember = %d, GetMember = %d', 00H ; `string'
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
CONST	ENDS
;	COMDAT ?AddNewChatting@CUser@@QAEXPAVCChatting@@@Z
_TEXT	SEGMENT
_i$283034 = 8						; size = 4
_pChatting$ = 8						; size = 4
?AddNewChatting@CUser@@QAEXPAVCChatting@@@Z PROC NEAR	; CUser::AddNewChatting, COMDAT
; _this$ = ecx

; 6379 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	0f 85 f6 00 00
	00		 jne	 $L283037

; 6380 : 	
; 6381 : 	m_Snapshot.cb++;

  0000a	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  00011	53		 push	 ebx
  00012	55		 push	 ebp
  00013	56		 push	 esi
  00014	57		 push	 edi

; 6382 : 	m_Snapshot.ar << GetId();

  00015	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  0001b	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  00021	bd 04 00 00 00	 mov	 ebp, 4
  00026	55		 push	 ebp
  00027	8b ce		 mov	 ecx, esi
  00029	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0002e	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00031	89 38		 mov	 DWORD PTR [eax], edi
  00033	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00036	03 d5		 add	 edx, ebp

; 6383 : 	m_Snapshot.ar << SNAPSHOTTYPE_CHATTING;

  00038	6a 02		 push	 2
  0003a	8b ce		 mov	 ecx, esi
  0003c	89 56 08	 mov	 DWORD PTR [esi+8], edx
  0003f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00044	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00047	66 c7 01 7b 00	 mov	 WORD PTR [ecx], 123	; 0000007bH
  0004c	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0004f	83 c0 02	 add	 eax, 2

; 6384 : 	m_Snapshot.ar << CHATTING_NEWCHATTING;

  00052	6a 01		 push	 1
  00054	8b ce		 mov	 ecx, esi
  00056	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00059	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0005e	8b 56 08	 mov	 edx, DWORD PTR [esi+8]

; 6385 : 	m_Snapshot.ar << pChatting->GetChattingMember();

  00061	8b 5c 24 14	 mov	 ebx, DWORD PTR _pChatting$[esp+12]
  00065	c6 02 01	 mov	 BYTE PTR [edx], 1
  00068	ff 46 08	 inc	 DWORD PTR [esi+8]
  0006b	8b 7b 28	 mov	 edi, DWORD PTR [ebx+40]
  0006e	55		 push	 ebp
  0006f	8b ce		 mov	 ecx, esi
  00071	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00076	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00079	89 38		 mov	 DWORD PTR [eax], edi
  0007b	01 6e 08	 add	 DWORD PTR [esi+8], ebp

; 6386 : 	for( int i = 0 ; i < pChatting->GetChattingMember() ; ++i )

  0007e	8b 43 28	 mov	 eax, DWORD PTR [ebx+40]
  00081	85 c0		 test	 eax, eax
  00083	c7 44 24 14 00
	00 00 00	 mov	 DWORD PTR _i$283034[esp+12], 0
  0008b	7e 6f		 jle	 SHORT $L307082

; 6380 : 	
; 6381 : 	m_Snapshot.cb++;

  0008d	8d 7b 2c	 lea	 edi, DWORD PTR [ebx+44]
$L283035:

; 6387 : 	{
; 6388 : 		m_Snapshot.ar << pChatting->m_idMember[i];

  00090	8b 2f		 mov	 ebp, DWORD PTR [edi]
  00092	6a 04		 push	 4
  00094	8b ce		 mov	 ecx, esi
  00096	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0009b	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0009e	89 29		 mov	 DWORD PTR [ecx], ebp
  000a0	83 46 08 04	 add	 DWORD PTR [esi+8], 4

; 6389 : #if __VER >= 11 // __SYS_PLAYER_DATA
; 6390 : 		if( NULL == CPlayerDataCenter::GetInstance()->GetPlayerString( pChatting->m_idMember[i] ) )

  000a4	8b 17		 mov	 edx, DWORD PTR [edi]
  000a6	52		 push	 edx
  000a7	e8 00 00 00 00	 call	 ?GetInstance@CPlayerDataCenter@@SAPAV1@XZ ; CPlayerDataCenter::GetInstance
  000ac	8b c8		 mov	 ecx, eax
  000ae	e8 00 00 00 00	 call	 ?GetPlayerString@CPlayerDataCenter@@QAEPBDK@Z ; CPlayerDataCenter::GetPlayerString
  000b3	85 c0		 test	 eax, eax
  000b5	75 1b		 jne	 SHORT $L283038

; 6391 : #else	// __SYS_PLAYER_DATA
; 6392 : 		if( NULL == prj.GetPlayerString( pChatting->m_idMember[i] ) )
; 6393 : #endif	// __SYS_PLAYER_DATA
; 6394 : 		{
; 6395 : 			Error( "AddNewChatting : MAX_ChattingMember = %d, GetMember = %d", pChatting->GetChattingMember(), pChatting->m_idMember[i] );

  000b7	8b 07		 mov	 eax, DWORD PTR [edi]
  000b9	8b 4b 28	 mov	 ecx, DWORD PTR [ebx+40]
  000bc	50		 push	 eax
  000bd	51		 push	 ecx
  000be	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@NAGLBLJJ@AddNewChatting?5?3?5MAX_ChattingMem@
  000c3	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  000c8	83 c4 0c	 add	 esp, 12			; 0000000cH

; 6396 : 			m_Snapshot.ar.WriteString( "" );

  000cb	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@

; 6397 : 		}
; 6398 : 		else

  000d0	eb 10		 jmp	 SHORT $L307086
$L283038:

; 6399 : 		{
; 6400 : #if __VER >= 11 // __SYS_PLAYER_DATA
; 6401 : 			m_Snapshot.ar.WriteString( CPlayerDataCenter::GetInstance()->GetPlayerString( pChatting->m_idMember[i] ) );

  000d2	8b 17		 mov	 edx, DWORD PTR [edi]
  000d4	52		 push	 edx
  000d5	e8 00 00 00 00	 call	 ?GetInstance@CPlayerDataCenter@@SAPAV1@XZ ; CPlayerDataCenter::GetInstance
  000da	8b c8		 mov	 ecx, eax
  000dc	e8 00 00 00 00	 call	 ?GetPlayerString@CPlayerDataCenter@@QAEPBDK@Z ; CPlayerDataCenter::GetPlayerString
  000e1	50		 push	 eax
$L307086:
  000e2	8b ce		 mov	 ecx, esi
  000e4	e8 00 00 00 00	 call	 ?WriteString@CAr@@QAEXPBD@Z ; CAr::WriteString
  000e9	8b 44 24 14	 mov	 eax, DWORD PTR _i$283034[esp+12]
  000ed	8b 4b 28	 mov	 ecx, DWORD PTR [ebx+40]
  000f0	40		 inc	 eax
  000f1	83 c7 04	 add	 edi, 4
  000f4	3b c1		 cmp	 eax, ecx
  000f6	89 44 24 14	 mov	 DWORD PTR _i$283034[esp+12], eax
  000fa	7c 94		 jl	 SHORT $L283035
$L307082:
  000fc	5f		 pop	 edi
  000fd	5e		 pop	 esi
  000fe	5d		 pop	 ebp
  000ff	5b		 pop	 ebx
$L283037:

; 6402 : #else	//__SYS_PLAYER_DATA
; 6403 : 			m_Snapshot.ar.WriteString( prj.GetPlayerString( pChatting->m_idMember[i] ) );
; 6404 : #endif	// __SYS_PLAYER_DATA
; 6405 : 		}
; 6406 : 	}
; 6407 : }

  00100	c2 04 00	 ret	 4
?AddNewChatting@CUser@@QAEXPAVCChatting@@@Z ENDP	; CUser::AddNewChatting
_TEXT	ENDS
PUBLIC	?AddAngelInfo@CUser@@QAEXH@Z			; CUser::AddAngelInfo
; Function compile flags: /Ogty
;	COMDAT ?AddAngelInfo@CUser@@QAEXH@Z
_TEXT	SEGMENT
$T307112 = -8						; size = 8
_bComplete$ = 8						; size = 4
?AddAngelInfo@CUser@@QAEXH@Z PROC NEAR			; CUser::AddAngelInfo, COMDAT
; _this$ = ecx

; 6425 : {

  00000	83 ec 08	 sub	 esp, 8
  00003	57		 push	 edi
  00004	8b f9		 mov	 edi, ecx

; 6426 : 	if( IsDelete() )	return;

  00006	f6 47 04 01	 test	 BYTE PTR [edi+4], 1
  0000a	0f 85 af 00 00
	00		 jne	 $L307123

; 6427 : 	
; 6428 : 	m_Snapshot.cb++;

  00010	66 ff 87 0c 57
	00 00		 inc	 WORD PTR [edi+22284]
  00017	53		 push	 ebx

; 6429 : 	m_Snapshot.ar << GetId();

  00018	8b 9f bc 01 00
	00		 mov	 ebx, DWORD PTR [edi+444]
  0001e	56		 push	 esi
  0001f	8d b7 f8 16 00
	00		 lea	 esi, DWORD PTR [edi+5880]
  00025	6a 04		 push	 4
  00027	8b ce		 mov	 ecx, esi
  00029	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0002e	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00031	89 18		 mov	 DWORD PTR [eax], ebx
  00033	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00036	83 c2 04	 add	 edx, 4

; 6430 : 	m_Snapshot.ar << SNAPSHOTTYPE_ANGEL;

  00039	6a 02		 push	 2
  0003b	8b ce		 mov	 ecx, esi
  0003d	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00040	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00045	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00048	66 c7 01 b1 00	 mov	 WORD PTR [ecx], 177	; 000000b1H
  0004d	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00050	83 c0 02	 add	 eax, 2

; 6431 : 	m_Snapshot.ar << ANGEL_INFO;

  00053	6a 01		 push	 1
  00055	8b ce		 mov	 ecx, esi
  00057	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0005a	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0005f	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00062	c6 02 01	 mov	 BYTE PTR [edx], 1
  00065	ff 46 08	 inc	 DWORD PTR [esi+8]

; 6432 : 	m_Snapshot.ar << m_nAngelExp;

  00068	8b 8f 6c 07 00
	00		 mov	 ecx, DWORD PTR [edi+1900]
  0006e	8b 87 68 07 00
	00		 mov	 eax, DWORD PTR [edi+1896]
  00074	6a 08		 push	 8
  00076	8d 54 24 10	 lea	 edx, DWORD PTR $T307112[esp+24]
  0007a	89 4c 24 14	 mov	 DWORD PTR $T307112[esp+28], ecx
  0007e	52		 push	 edx
  0007f	8b ce		 mov	 ecx, esi
  00081	89 44 24 14	 mov	 DWORD PTR $T307112[esp+28], eax
  00085	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write

; 6433 : 	m_Snapshot.ar << m_nAngelLevel;

  0008a	8b bf 70 07 00
	00		 mov	 edi, DWORD PTR [edi+1904]
  00090	6a 04		 push	 4
  00092	8b ce		 mov	 ecx, esi
  00094	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00099	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0009c	89 38		 mov	 DWORD PTR [eax], edi
  0009e	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  000a1	83 c2 04	 add	 edx, 4

; 6434 : 	m_Snapshot.ar << bComplete;

  000a4	6a 04		 push	 4
  000a6	8b ce		 mov	 ecx, esi
  000a8	89 56 08	 mov	 DWORD PTR [esi+8], edx
  000ab	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000b0	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  000b3	8b 54 24 18	 mov	 edx, DWORD PTR _bComplete$[esp+16]
  000b7	89 11		 mov	 DWORD PTR [ecx], edx
  000b9	83 46 08 04	 add	 DWORD PTR [esi+8], 4
  000bd	5e		 pop	 esi
  000be	5b		 pop	 ebx
$L307123:
  000bf	5f		 pop	 edi

; 6435 : }

  000c0	83 c4 08	 add	 esp, 8
  000c3	c2 04 00	 ret	 4
?AddAngelInfo@CUser@@QAEXH@Z ENDP			; CUser::AddAngelInfo
_TEXT	ENDS
PUBLIC	?AddChttingRoomState@CUser@@QAEXH@Z		; CUser::AddChttingRoomState
; Function compile flags: /Ogty
;	COMDAT ?AddChttingRoomState@CUser@@QAEXH@Z
_TEXT	SEGMENT
_bState$ = 8						; size = 4
?AddChttingRoomState@CUser@@QAEXH@Z PROC NEAR		; CUser::AddChttingRoomState, COMDAT
; _this$ = ecx

; 6476 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	75 79		 jne	 SHORT $L307154

; 6477 : 	
; 6478 : 	m_Snapshot.cb++;

  00006	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  0000d	56		 push	 esi
  0000e	57		 push	 edi

; 6479 : 	m_Snapshot.ar << GetId();

  0000f	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  00015	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  0001b	6a 04		 push	 4
  0001d	8b ce		 mov	 ecx, esi
  0001f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00024	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00027	89 38		 mov	 DWORD PTR [eax], edi
  00029	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0002c	83 c2 04	 add	 edx, 4

; 6480 : 	m_Snapshot.ar << SNAPSHOTTYPE_CHATTING;

  0002f	6a 02		 push	 2
  00031	8b ce		 mov	 ecx, esi
  00033	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00036	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003b	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003e	66 c7 01 7b 00	 mov	 WORD PTR [ecx], 123	; 0000007bH
  00043	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00046	83 c0 02	 add	 eax, 2

; 6481 : 	m_Snapshot.ar << CHATTING_CHATTINGROOMSTATE;

  00049	6a 01		 push	 1
  0004b	8b ce		 mov	 ecx, esi
  0004d	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00050	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00055	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00058	c6 02 05	 mov	 BYTE PTR [edx], 5
  0005b	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0005e	42		 inc	 edx

; 6482 : 	m_Snapshot.ar << bState;

  0005f	6a 04		 push	 4
  00061	8b ce		 mov	 ecx, esi
  00063	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00066	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0006b	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0006e	8b 4c 24 0c	 mov	 ecx, DWORD PTR _bState$[esp+4]
  00072	89 08		 mov	 DWORD PTR [eax], ecx
  00074	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00077	83 c0 04	 add	 eax, 4
  0007a	5f		 pop	 edi
  0007b	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0007e	5e		 pop	 esi
$L307154:

; 6483 : 	
; 6484 : }

  0007f	c2 04 00	 ret	 4
?AddChttingRoomState@CUser@@QAEXH@Z ENDP		; CUser::AddChttingRoomState
_TEXT	ENDS
PUBLIC	?AddMonsterProp@CUser@@QAEXXZ			; CUser::AddMonsterProp
; Function compile flags: /Ogty
;	COMDAT ?AddMonsterProp@CUser@@QAEXXZ
_TEXT	SEGMENT
$T307245 = -4						; size = 4
$T307235 = -4						; size = 4
$T307225 = -4						; size = 4
$T307215 = -4						; size = 4
$T307205 = -4						; size = 4
$T307195 = -4						; size = 4
?AddMonsterProp@CUser@@QAEXXZ PROC NEAR			; CUser::AddMonsterProp, COMDAT
; _this$ = ecx

; 6528 : {

  00000	51		 push	 ecx

; 6529 : 	if( IsDelete() )	return;

  00001	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00005	0f 85 71 01 00
	00		 jne	 $L283115

; 6530 : 	
; 6531 : 	m_Snapshot.cb++;

  0000b	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  00012	53		 push	 ebx
  00013	55		 push	 ebp
  00014	56		 push	 esi
  00015	57		 push	 edi

; 6532 : 	m_Snapshot.ar << GetId();

  00016	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  0001c	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  00022	bb 04 00 00 00	 mov	 ebx, 4
  00027	53		 push	 ebx
  00028	8b ce		 mov	 ecx, esi
  0002a	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0002f	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00032	89 38		 mov	 DWORD PTR [eax], edi
  00034	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00037	03 c3		 add	 eax, ebx

; 6533 : 	m_Snapshot.ar << SNAPSHOTTYPE_MONSTERPROP;

  00039	6a 02		 push	 2
  0003b	8b ce		 mov	 ecx, esi
  0003d	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00040	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00045	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00048	66 c7 01 4e 00	 mov	 WORD PTR [ecx], 78	; 0000004eH
  0004d	83 46 08 02	 add	 DWORD PTR [esi+8], 2

; 6534 : 
; 6535 : 	m_Snapshot.ar << prj.m_nMonsterPropSize;

  00051	8b 3d cc 86 11
	00		 mov	 edi, DWORD PTR ?prj@@3VCProject@@A+1148620
  00057	53		 push	 ebx
  00058	8b ce		 mov	 ecx, esi
  0005a	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0005f	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00062	89 3a		 mov	 DWORD PTR [edx], edi
  00064	01 5e 08	 add	 DWORD PTR [esi+8], ebx

; 6536 : 	for( int i = 0 ; i < prj.m_nMonsterPropSize ; ++i )

  00067	a1 cc 86 11 00	 mov	 eax, DWORD PTR ?prj@@3VCProject@@A+1148620
  0006c	33 ed		 xor	 ebp, ebp
  0006e	85 c0		 test	 eax, eax
  00070	0f 8e c7 00 00
	00		 jle	 $L283112

; 6530 : 	
; 6531 : 	m_Snapshot.cb++;

  00076	bf e4 46 0f 00	 mov	 edi, OFFSET FLAT:?prj@@3VCProject@@A+1001188
  0007b	eb 03 8d 49 00	 npad	 5
$L283110:

; 6537 : 	{
; 6538 : 		m_Snapshot.ar.WriteString( prj.m_aMonsterProp[ i ].szMonsterName );

  00080	8d 47 e0	 lea	 eax, DWORD PTR [edi-32]
  00083	50		 push	 eax
  00084	8b ce		 mov	 ecx, esi
  00086	e8 00 00 00 00	 call	 ?WriteString@CAr@@QAEXPBD@Z ; CAr::WriteString

; 6539 : 		m_Snapshot.ar << prj.m_aMonsterProp[ i ].nHitPoint;

  0008b	8b 0f		 mov	 ecx, DWORD PTR [edi]
  0008d	89 4c 24 10	 mov	 DWORD PTR $T307195[esp+20], ecx
  00091	53		 push	 ebx
  00092	8b ce		 mov	 ecx, esi
  00094	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00099	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0009c	8b 44 24 10	 mov	 eax, DWORD PTR $T307195[esp+20]
  000a0	89 02		 mov	 DWORD PTR [edx], eax
  000a2	01 5e 08	 add	 DWORD PTR [esi+8], ebx

; 6540 : 		m_Snapshot.ar << prj.m_aMonsterProp[ i ].nAttackPower;

  000a5	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  000a8	89 4c 24 10	 mov	 DWORD PTR $T307205[esp+20], ecx
  000ac	53		 push	 ebx
  000ad	8b ce		 mov	 ecx, esi
  000af	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000b4	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  000b7	8b 44 24 10	 mov	 eax, DWORD PTR $T307205[esp+20]
  000bb	89 02		 mov	 DWORD PTR [edx], eax
  000bd	01 5e 08	 add	 DWORD PTR [esi+8], ebx

; 6541 : 		m_Snapshot.ar << prj.m_aMonsterProp[ i ].nDefence;

  000c0	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  000c3	89 4c 24 10	 mov	 DWORD PTR $T307215[esp+20], ecx
  000c7	53		 push	 ebx
  000c8	8b ce		 mov	 ecx, esi
  000ca	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000cf	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  000d2	8b 44 24 10	 mov	 eax, DWORD PTR $T307215[esp+20]
  000d6	89 02		 mov	 DWORD PTR [edx], eax
  000d8	01 5e 08	 add	 DWORD PTR [esi+8], ebx

; 6542 : 		m_Snapshot.ar << prj.m_aMonsterProp[ i ].nExp;

  000db	8b 4f 0c	 mov	 ecx, DWORD PTR [edi+12]
  000de	89 4c 24 10	 mov	 DWORD PTR $T307225[esp+20], ecx
  000e2	53		 push	 ebx
  000e3	8b ce		 mov	 ecx, esi
  000e5	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000ea	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  000ed	8b 44 24 10	 mov	 eax, DWORD PTR $T307225[esp+20]
  000f1	89 02		 mov	 DWORD PTR [edx], eax
  000f3	01 5e 08	 add	 DWORD PTR [esi+8], ebx

; 6543 : 		m_Snapshot.ar << prj.m_aMonsterProp[ i ].nItemDrop;

  000f6	8b 4f 10	 mov	 ecx, DWORD PTR [edi+16]
  000f9	89 4c 24 10	 mov	 DWORD PTR $T307235[esp+20], ecx
  000fd	53		 push	 ebx
  000fe	8b ce		 mov	 ecx, esi
  00100	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00105	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00108	8b 44 24 10	 mov	 eax, DWORD PTR $T307235[esp+20]
  0010c	89 02		 mov	 DWORD PTR [edx], eax
  0010e	01 5e 08	 add	 DWORD PTR [esi+8], ebx

; 6544 : 		m_Snapshot.ar << prj.m_aMonsterProp[ i ].nPenya;

  00111	8b 4f 14	 mov	 ecx, DWORD PTR [edi+20]
  00114	89 4c 24 10	 mov	 DWORD PTR $T307245[esp+20], ecx
  00118	53		 push	 ebx
  00119	8b ce		 mov	 ecx, esi
  0011b	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00120	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00123	8b 44 24 10	 mov	 eax, DWORD PTR $T307245[esp+20]
  00127	89 02		 mov	 DWORD PTR [edx], eax
  00129	01 5e 08	 add	 DWORD PTR [esi+8], ebx
  0012c	a1 cc 86 11 00	 mov	 eax, DWORD PTR ?prj@@3VCProject@@A+1148620
  00131	45		 inc	 ebp
  00132	83 c7 38	 add	 edi, 56			; 00000038H
  00135	3b e8		 cmp	 ebp, eax
  00137	0f 8c 43 ff ff
	ff		 jl	 $L283110
$L283112:

; 6545 : 	}
; 6546 : 	
; 6547 : 	m_Snapshot.ar << prj.m_nRemoveMonsterPropSize;

  0013d	8b 3d c8 86 11
	00		 mov	 edi, DWORD PTR ?prj@@3VCProject@@A+1148616
  00143	53		 push	 ebx
  00144	8b ce		 mov	 ecx, esi
  00146	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0014b	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0014e	89 39		 mov	 DWORD PTR [ecx], edi
  00150	01 5e 08	 add	 DWORD PTR [esi+8], ebx

; 6548 : 	for( i = 0 ; i < prj.m_nRemoveMonsterPropSize ; ++i )

  00153	a1 c8 86 11 00	 mov	 eax, DWORD PTR ?prj@@3VCProject@@A+1148616
  00158	33 ff		 xor	 edi, edi
  0015a	85 c0		 test	 eax, eax
  0015c	7e 1a		 jle	 SHORT $L307261

; 6545 : 	}
; 6546 : 	
; 6547 : 	m_Snapshot.ar << prj.m_nRemoveMonsterPropSize;

  0015e	bb c4 06 11 00	 mov	 ebx, OFFSET FLAT:?prj@@3VCProject@@A+1115844
$L283113:

; 6549 : 	{
; 6550 : 		m_Snapshot.ar.WriteString( prj.m_aRemoveProp[i] );

  00163	53		 push	 ebx
  00164	8b ce		 mov	 ecx, esi
  00166	e8 00 00 00 00	 call	 ?WriteString@CAr@@QAEXPBD@Z ; CAr::WriteString
  0016b	a1 c8 86 11 00	 mov	 eax, DWORD PTR ?prj@@3VCProject@@A+1148616
  00170	47		 inc	 edi
  00171	83 c3 20	 add	 ebx, 32			; 00000020H
  00174	3b f8		 cmp	 edi, eax
  00176	7c eb		 jl	 SHORT $L283113
$L307261:
  00178	5f		 pop	 edi
  00179	5e		 pop	 esi
  0017a	5d		 pop	 ebp
  0017b	5b		 pop	 ebx
$L283115:

; 6551 : 	}
; 6552 : 
; 6553 : 	
; 6554 : }

  0017c	59		 pop	 ecx
  0017d	c3		 ret	 0
?AddMonsterProp@CUser@@QAEXXZ ENDP			; CUser::AddMonsterProp
_TEXT	ENDS
PUBLIC	?AddInitSkill@CUser@@QAEXXZ			; CUser::AddInitSkill
; Function compile flags: /Ogty
;	COMDAT ?AddInitSkill@CUser@@QAEXXZ
_TEXT	SEGMENT
?AddInitSkill@CUser@@QAEXXZ PROC NEAR			; CUser::AddInitSkill, COMDAT
; _this$ = ecx

; 6558 : {

  00000	57		 push	 edi
  00001	8b f9		 mov	 edi, ecx

; 6559 : 
; 6560 : 	if( IsDelete() )	return;

  00003	f6 47 04 01	 test	 BYTE PTR [edi+4], 1
  00007	75 5b		 jne	 SHORT $L307289

; 6561 : 	
; 6562 : 	m_Snapshot.cb++;

  00009	66 ff 87 0c 57
	00 00		 inc	 WORD PTR [edi+22284]
  00010	53		 push	 ebx

; 6563 : 	m_Snapshot.ar << GetId();

  00011	8b 9f bc 01 00
	00		 mov	 ebx, DWORD PTR [edi+444]
  00017	56		 push	 esi
  00018	8d b7 f8 16 00
	00		 lea	 esi, DWORD PTR [edi+5880]
  0001e	6a 04		 push	 4
  00020	8b ce		 mov	 ecx, esi
  00022	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00027	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0002a	89 18		 mov	 DWORD PTR [eax], ebx
  0002c	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0002f	83 c0 04	 add	 eax, 4

; 6564 : 	m_Snapshot.ar << SNAPSHOTTYPE_INITSKILLPOINT;

  00032	6a 02		 push	 2
  00034	8b ce		 mov	 ecx, esi
  00036	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00039	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003e	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00041	66 c7 01 7c 00	 mov	 WORD PTR [ecx], 124	; 0000007cH
  00046	83 46 08 02	 add	 DWORD PTR [esi+8], 2

; 6565 : 	m_Snapshot.ar << m_nSkillPoint;

  0004a	8b bf a4 11 00
	00		 mov	 edi, DWORD PTR [edi+4516]
  00050	6a 04		 push	 4
  00052	8b ce		 mov	 ecx, esi
  00054	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00059	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0005c	89 3a		 mov	 DWORD PTR [edx], edi
  0005e	83 46 08 04	 add	 DWORD PTR [esi+8], 4
  00062	5e		 pop	 esi
  00063	5b		 pop	 ebx
$L307289:
  00064	5f		 pop	 edi

; 6566 : }

  00065	c3		 ret	 0
?AddInitSkill@CUser@@QAEXXZ ENDP			; CUser::AddInitSkill
_TEXT	ENDS
PUBLIC	?AddDoUseSkillPoint@CUser@@QAEXQAUtagSkill@@H@Z	; CUser::AddDoUseSkillPoint
; Function compile flags: /Ogty
;	COMDAT ?AddDoUseSkillPoint@CUser@@QAEXQAUtagSkill@@H@Z
_TEXT	SEGMENT
_aJobSkill$ = 8						; size = 4
_nSkillPoint$ = 12					; size = 4
?AddDoUseSkillPoint@CUser@@QAEXQAUtagSkill@@H@Z PROC NEAR ; CUser::AddDoUseSkillPoint, COMDAT
; _this$ = ecx

; 6571 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	0f 85 9f 00 00
	00		 jne	 $L307326

; 6572 : 	
; 6573 : 	m_Snapshot.cb++;

  0000a	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  00011	53		 push	 ebx
  00012	55		 push	 ebp
  00013	56		 push	 esi
  00014	57		 push	 edi

; 6574 : 	m_Snapshot.ar << GetId();

  00015	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  0001b	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  00021	6a 04		 push	 4
  00023	8b ce		 mov	 ecx, esi
  00025	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0002a	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0002d	89 38		 mov	 DWORD PTR [eax], edi
  0002f	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00032	83 c2 04	 add	 edx, 4

; 6575 : 	m_Snapshot.ar << SNAPSHOTTYPE_DOUSESKILLPOINT;

  00035	6a 02		 push	 2
  00037	8b ce		 mov	 ecx, esi
  00039	89 56 08	 mov	 DWORD PTR [esi+8], edx
  0003c	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00041	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]

; 6576 : 
; 6577 : 	for( int i = 0; i < MAX_SKILL_JOB; i++ ) 
; 6578 : 	{
; 6579 : 		LPSKILL lpSkill;
; 6580 : 		lpSkill = &aJobSkill[ i ];
; 6581 : 		
; 6582 : 		m_Snapshot.ar << lpSkill->dwSkill << lpSkill->dwLevel;

  00044	8b 6c 24 14	 mov	 ebp, DWORD PTR _aJobSkill$[esp+12]
  00048	66 c7 01 7d 00	 mov	 WORD PTR [ecx], 125	; 0000007dH
  0004d	83 46 08 02	 add	 DWORD PTR [esi+8], 2
  00051	33 ff		 xor	 edi, edi
$L283129:
  00053	8b 5c fd 00	 mov	 ebx, DWORD PTR [ebp+edi*8]
  00057	6a 04		 push	 4
  00059	8b ce		 mov	 ecx, esi
  0005b	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00060	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00063	89 1a		 mov	 DWORD PTR [edx], ebx
  00065	83 46 08 04	 add	 DWORD PTR [esi+8], 4
  00069	8b 5c fd 04	 mov	 ebx, DWORD PTR [ebp+edi*8+4]
  0006d	6a 04		 push	 4
  0006f	8b ce		 mov	 ecx, esi
  00071	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00076	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00079	89 18		 mov	 DWORD PTR [eax], ebx
  0007b	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0007e	83 c2 04	 add	 edx, 4
  00081	47		 inc	 edi
  00082	83 ff 33	 cmp	 edi, 51			; 00000033H
  00085	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00088	7c c9		 jl	 SHORT $L283129

; 6583 : 	}
; 6584 : 	m_Snapshot.ar << nSkillPoint;

  0008a	6a 04		 push	 4
  0008c	8b ce		 mov	 ecx, esi
  0008e	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00093	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00096	8b 54 24 18	 mov	 edx, DWORD PTR _nSkillPoint$[esp+12]
  0009a	89 11		 mov	 DWORD PTR [ecx], edx
  0009c	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0009f	5f		 pop	 edi
  000a0	83 c0 04	 add	 eax, 4
  000a3	89 46 08	 mov	 DWORD PTR [esi+8], eax
  000a6	5e		 pop	 esi
  000a7	5d		 pop	 ebp
  000a8	5b		 pop	 ebx
$L307326:

; 6585 : }

  000a9	c2 08 00	 ret	 8
?AddDoUseSkillPoint@CUser@@QAEXQAUtagSkill@@H@Z ENDP	; CUser::AddDoUseSkillPoint
_TEXT	ENDS
PUBLIC	?AddRemoveMail@CUser@@QAEXKH@Z			; CUser::AddRemoveMail
; Function compile flags: /Ogty
;	COMDAT ?AddRemoveMail@CUser@@QAEXKH@Z
_TEXT	SEGMENT
_nMail$ = 8						; size = 4
_nType$ = 12						; size = 4
?AddRemoveMail@CUser@@QAEXKH@Z PROC NEAR		; CUser::AddRemoveMail, COMDAT
; _this$ = ecx

; 6732 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	75 7e		 jne	 SHORT $L307359

; 6733 : 	
; 6734 : 	m_Snapshot.cb++;

  00006	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  0000d	56		 push	 esi
  0000e	57		 push	 edi

; 6735 : 	m_Snapshot.ar << GetId();

  0000f	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  00015	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  0001b	6a 04		 push	 4
  0001d	8b ce		 mov	 ecx, esi
  0001f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00024	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00027	89 38		 mov	 DWORD PTR [eax], edi
  00029	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0002c	83 c2 04	 add	 edx, 4

; 6736 : 	m_Snapshot.ar << SNAPSHOTTYPE_REMOVEMAIL;

  0002f	6a 02		 push	 2
  00031	8b ce		 mov	 ecx, esi
  00033	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00036	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003b	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003e	66 c7 01 e7 00	 mov	 WORD PTR [ecx], 231	; 000000e7H
  00043	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00046	83 c0 02	 add	 eax, 2

; 6737 : 	m_Snapshot.ar << nMail << nType;

  00049	6a 04		 push	 4
  0004b	8b ce		 mov	 ecx, esi
  0004d	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00050	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00055	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00058	8b 44 24 0c	 mov	 eax, DWORD PTR _nMail$[esp+4]
  0005c	89 02		 mov	 DWORD PTR [edx], eax
  0005e	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00061	83 c2 04	 add	 edx, 4
  00064	6a 04		 push	 4
  00066	8b ce		 mov	 ecx, esi
  00068	89 56 08	 mov	 DWORD PTR [esi+8], edx
  0006b	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00070	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00073	8b 54 24 10	 mov	 edx, DWORD PTR _nType$[esp+4]
  00077	89 11		 mov	 DWORD PTR [ecx], edx
  00079	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0007c	83 c0 04	 add	 eax, 4
  0007f	5f		 pop	 edi
  00080	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00083	5e		 pop	 esi
$L307359:

; 6738 : 	
; 6739 : }

  00084	c2 08 00	 ret	 8
?AddRemoveMail@CUser@@QAEXKH@Z ENDP			; CUser::AddRemoveMail
_TEXT	ENDS
PUBLIC	?SendCheckMailBoxReq@CUser@@QAEXH@Z		; CUser::SendCheckMailBoxReq
; Function compile flags: /Ogty
;	COMDAT ?SendCheckMailBoxReq@CUser@@QAEXH@Z
_TEXT	SEGMENT
_bCheckTransMailBox$ = 8				; size = 4
?SendCheckMailBoxReq@CUser@@QAEXH@Z PROC NEAR		; CUser::SendCheckMailBoxReq, COMDAT
; _this$ = ecx

; 6754 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	75 63		 jne	 SHORT $L307385

; 6755 : 
; 6756 : 	m_Snapshot.cb++;

  00006	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  0000d	56		 push	 esi
  0000e	57		 push	 edi

; 6757 : 	m_Snapshot.ar << GetId();

  0000f	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  00015	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  0001b	6a 04		 push	 4
  0001d	8b ce		 mov	 ecx, esi
  0001f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00024	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00027	89 38		 mov	 DWORD PTR [eax], edi
  00029	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0002c	83 c0 04	 add	 eax, 4

; 6758 : 	m_Snapshot.ar << SNAPSHOTTYPE_QUERYMAILBOX_REQ;

  0002f	6a 02		 push	 2
  00031	8b ce		 mov	 ecx, esi
  00033	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00036	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003b	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003e	66 c7 01 60 88	 mov	 WORD PTR [ecx], 34912	; 00008860H
  00043	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00046	83 c2 02	 add	 edx, 2

; 6759 : 	m_Snapshot.ar << bCheckTransMailBox;

  00049	6a 04		 push	 4
  0004b	8b ce		 mov	 ecx, esi
  0004d	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00050	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00055	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00058	8b 44 24 0c	 mov	 eax, DWORD PTR _bCheckTransMailBox$[esp+4]
  0005c	89 02		 mov	 DWORD PTR [edx], eax
  0005e	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00061	83 c0 04	 add	 eax, 4
  00064	5f		 pop	 edi
  00065	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00068	5e		 pop	 esi
$L307385:

; 6760 : }

  00069	c2 04 00	 ret	 4
?SendCheckMailBoxReq@CUser@@QAEXH@Z ENDP		; CUser::SendCheckMailBoxReq
_TEXT	ENDS
PUBLIC	?AddGCJoinWarWindow@CUser@@QAEXHH@Z		; CUser::AddGCJoinWarWindow
; Function compile flags: /Ogty
;	COMDAT ?AddGCJoinWarWindow@CUser@@QAEXHH@Z
_TEXT	SEGMENT
_nMap$ = 8						; size = 4
_nTelTime$ = 12						; size = 4
?AddGCJoinWarWindow@CUser@@QAEXHH@Z PROC NEAR		; CUser::AddGCJoinWarWindow, COMDAT
; _this$ = ecx

; 6872 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	0f 85 94 00 00
	00		 jne	 $L307425

; 6873 : 	
; 6874 : 	m_Snapshot.cb++;

  0000a	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  00011	56		 push	 esi
  00012	57		 push	 edi

; 6875 : 	m_Snapshot.ar << GetId();

  00013	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  00019	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  0001f	6a 04		 push	 4
  00021	8b ce		 mov	 ecx, esi
  00023	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00028	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0002b	89 38		 mov	 DWORD PTR [eax], edi
  0002d	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00030	83 c0 04	 add	 eax, 4

; 6876 : 	m_Snapshot.ar << SNAPSHOTTYPE_GUILDCOMBAT;

  00033	6a 02		 push	 2
  00035	8b ce		 mov	 ecx, esi
  00037	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0003a	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003f	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00042	66 c7 01 b8 00	 mov	 WORD PTR [ecx], 184	; 000000b8H
  00047	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0004a	83 c2 02	 add	 edx, 2

; 6877 : 	m_Snapshot.ar << GC_SELECTWARPOS;

  0004d	6a 01		 push	 1
  0004f	8b ce		 mov	 ecx, esi
  00051	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00054	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00059	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0005c	c6 02 06	 mov	 BYTE PTR [edx], 6
  0005f	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00062	40		 inc	 eax

; 6878 : 	m_Snapshot.ar << nMap;

  00063	6a 04		 push	 4
  00065	8b ce		 mov	 ecx, esi
  00067	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0006a	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0006f	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00072	8b 4c 24 0c	 mov	 ecx, DWORD PTR _nMap$[esp+4]
  00076	89 08		 mov	 DWORD PTR [eax], ecx
  00078	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0007b	83 c2 04	 add	 edx, 4

; 6879 : 	m_Snapshot.ar << nTelTime;

  0007e	6a 04		 push	 4
  00080	8b ce		 mov	 ecx, esi
  00082	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00085	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0008a	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0008d	8b 44 24 10	 mov	 eax, DWORD PTR _nTelTime$[esp+4]
  00091	89 02		 mov	 DWORD PTR [edx], eax
  00093	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00096	83 c0 04	 add	 eax, 4
  00099	5f		 pop	 edi
  0009a	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0009d	5e		 pop	 esi
$L307425:

; 6880 : 	
; 6881 : }

  0009e	c2 08 00	 ret	 8
?AddGCJoinWarWindow@CUser@@QAEXHH@Z ENDP		; CUser::AddGCJoinWarWindow
_TEXT	ENDS
PUBLIC	?AddGCWinGuild@CUser@@QAEXXZ			; CUser::AddGCWinGuild
; Function compile flags: /Ogty
;	COMDAT ?AddGCWinGuild@CUser@@QAEXXZ
_TEXT	SEGMENT
?AddGCWinGuild@CUser@@QAEXXZ PROC NEAR			; CUser::AddGCWinGuild, COMDAT
; _this$ = ecx

; 6884 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	0f 85 a1 00 00
	00		 jne	 $L307470

; 6885 : 	
; 6886 : 	m_Snapshot.cb++;

  0000a	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  00011	53		 push	 ebx
  00012	56		 push	 esi
  00013	57		 push	 edi

; 6887 : 	m_Snapshot.ar << GetId();

  00014	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  0001a	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  00020	bb 04 00 00 00	 mov	 ebx, 4
  00025	53		 push	 ebx
  00026	8b ce		 mov	 ecx, esi
  00028	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0002d	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00030	89 38		 mov	 DWORD PTR [eax], edi
  00032	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  00035	03 fb		 add	 edi, ebx

; 6888 : 	m_Snapshot.ar << SNAPSHOTTYPE_GUILDCOMBAT;

  00037	6a 02		 push	 2
  00039	8b ce		 mov	 ecx, esi
  0003b	89 7e 08	 mov	 DWORD PTR [esi+8], edi
  0003e	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00043	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00046	66 c7 01 b8 00	 mov	 WORD PTR [ecx], 184	; 000000b8H
  0004b	83 46 08 02	 add	 DWORD PTR [esi+8], 2

; 6889 : 	m_Snapshot.ar << GC_WINGUILD;

  0004f	6a 01		 push	 1
  00051	8b ce		 mov	 ecx, esi
  00053	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00058	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0005b	c6 02 00	 mov	 BYTE PTR [edx], 0
  0005e	ff 46 08	 inc	 DWORD PTR [esi+8]

; 6890 : 	m_Snapshot.ar << g_GuildCombatMng.m_nGuildCombatIndex << g_GuildCombatMng.m_uWinGuildId << g_GuildCombatMng.m_nWinGuildCount;

  00061	8b 3d 40 00 00
	00		 mov	 edi, DWORD PTR ?g_GuildCombatMng@@3VCGuildCombat@@A+64
  00067	53		 push	 ebx
  00068	8b ce		 mov	 ecx, esi
  0006a	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0006f	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00072	89 38		 mov	 DWORD PTR [eax], edi
  00074	01 5e 08	 add	 DWORD PTR [esi+8], ebx
  00077	8b 3d 44 00 00
	00		 mov	 edi, DWORD PTR ?g_GuildCombatMng@@3VCGuildCombat@@A+68
  0007d	53		 push	 ebx
  0007e	8b ce		 mov	 ecx, esi
  00080	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00085	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00088	89 39		 mov	 DWORD PTR [ecx], edi
  0008a	01 5e 08	 add	 DWORD PTR [esi+8], ebx
  0008d	8b 3d 48 00 00
	00		 mov	 edi, DWORD PTR ?g_GuildCombatMng@@3VCGuildCombat@@A+72
  00093	53		 push	 ebx
  00094	8b ce		 mov	 ecx, esi
  00096	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0009b	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0009e	89 3a		 mov	 DWORD PTR [edx], edi
  000a0	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000a3	03 c3		 add	 eax, ebx
  000a5	5f		 pop	 edi
  000a6	89 46 08	 mov	 DWORD PTR [esi+8], eax
  000a9	5e		 pop	 esi
  000aa	5b		 pop	 ebx
$L307470:

; 6891 : 	
; 6892 : }

  000ab	c3		 ret	 0
?AddGCWinGuild@CUser@@QAEXXZ ENDP			; CUser::AddGCWinGuild
_TEXT	ENDS
PUBLIC	?AddGCIsRequest@CUser@@QAEXH@Z			; CUser::AddGCIsRequest
; Function compile flags: /Ogty
;	COMDAT ?AddGCIsRequest@CUser@@QAEXH@Z
_TEXT	SEGMENT
_bRequest$ = 8						; size = 4
?AddGCIsRequest@CUser@@QAEXH@Z PROC NEAR		; CUser::AddGCIsRequest, COMDAT
; _this$ = ecx

; 6906 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	75 79		 jne	 SHORT $L307501

; 6907 : 	
; 6908 : 	m_Snapshot.cb++;

  00006	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  0000d	56		 push	 esi
  0000e	57		 push	 edi

; 6909 : 	m_Snapshot.ar << GetId();

  0000f	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  00015	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  0001b	6a 04		 push	 4
  0001d	8b ce		 mov	 ecx, esi
  0001f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00024	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00027	89 38		 mov	 DWORD PTR [eax], edi
  00029	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0002c	83 c2 04	 add	 edx, 4

; 6910 : 	m_Snapshot.ar << SNAPSHOTTYPE_GUILDCOMBAT;

  0002f	6a 02		 push	 2
  00031	8b ce		 mov	 ecx, esi
  00033	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00036	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003b	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003e	66 c7 01 b8 00	 mov	 WORD PTR [ecx], 184	; 000000b8H
  00043	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00046	83 c0 02	 add	 eax, 2

; 6911 : 	m_Snapshot.ar << GC_ISREQUEST;

  00049	6a 01		 push	 1
  0004b	8b ce		 mov	 ecx, esi
  0004d	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00050	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00055	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00058	c6 02 08	 mov	 BYTE PTR [edx], 8
  0005b	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0005e	42		 inc	 edx

; 6912 : 	m_Snapshot.ar << bRequest;

  0005f	6a 04		 push	 4
  00061	8b ce		 mov	 ecx, esi
  00063	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00066	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0006b	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0006e	8b 4c 24 0c	 mov	 ecx, DWORD PTR _bRequest$[esp+4]
  00072	89 08		 mov	 DWORD PTR [eax], ecx
  00074	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00077	83 c0 04	 add	 eax, 4
  0007a	5f		 pop	 edi
  0007b	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0007e	5e		 pop	 esi
$L307501:

; 6913 : 	
; 6914 : }

  0007f	c2 04 00	 ret	 4
?AddGCIsRequest@CUser@@QAEXH@Z ENDP			; CUser::AddGCIsRequest
_TEXT	ENDS
PUBLIC	?AddGCGetPenyaGuild@CUser@@QAEXH_J@Z		; CUser::AddGCGetPenyaGuild
; Function compile flags: /Ogty
;	COMDAT ?AddGCGetPenyaGuild@CUser@@QAEXH_J@Z
_TEXT	SEGMENT
$T307537 = -8						; size = 8
_nGetResult$ = 8					; size = 4
_nGetPenya$ = 12					; size = 8
?AddGCGetPenyaGuild@CUser@@QAEXH_J@Z PROC NEAR		; CUser::AddGCGetPenyaGuild, COMDAT
; _this$ = ecx

; 6917 : 	if( IsDelete() )	return;

  00000	8a 41 04	 mov	 al, BYTE PTR [ecx+4]
  00003	83 ec 08	 sub	 esp, 8
  00006	a8 01		 test	 al, 1
  00008	0f 85 97 00 00
	00		 jne	 $L307536

; 6918 : 	
; 6919 : 	m_Snapshot.cb++;

  0000e	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  00015	56		 push	 esi
  00016	57		 push	 edi

; 6920 : 	m_Snapshot.ar << GetId();

  00017	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  0001d	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  00023	6a 04		 push	 4
  00025	8b ce		 mov	 ecx, esi
  00027	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0002c	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0002f	89 38		 mov	 DWORD PTR [eax], edi
  00031	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00034	83 c0 04	 add	 eax, 4

; 6921 : 	m_Snapshot.ar << SNAPSHOTTYPE_GUILDCOMBAT;

  00037	6a 02		 push	 2
  00039	8b ce		 mov	 ecx, esi
  0003b	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0003e	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00043	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00046	66 c7 01 b8 00	 mov	 WORD PTR [ecx], 184	; 000000b8H
  0004b	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0004e	83 c2 02	 add	 edx, 2

; 6922 : 	m_Snapshot.ar << GC_GETPENYAGUILD;

  00051	6a 01		 push	 1
  00053	8b ce		 mov	 ecx, esi
  00055	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00058	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0005d	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00060	c6 02 40	 mov	 BYTE PTR [edx], 64	; 00000040H
  00063	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00066	40		 inc	 eax

; 6923 : 	m_Snapshot.ar << nGetResult;

  00067	6a 04		 push	 4
  00069	8b ce		 mov	 ecx, esi
  0006b	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0006e	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00073	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00076	8b 4c 24 14	 mov	 ecx, DWORD PTR _nGetResult$[esp+12]
  0007a	89 08		 mov	 DWORD PTR [eax], ecx
  0007c	8b 56 08	 mov	 edx, DWORD PTR [esi+8]

; 6924 : 	m_Snapshot.ar << nGetPenya;

  0007f	8b 44 24 1c	 mov	 eax, DWORD PTR _nGetPenya$[esp+16]
  00083	83 c2 04	 add	 edx, 4
  00086	6a 08		 push	 8
  00088	8d 4c 24 0c	 lea	 ecx, DWORD PTR $T307537[esp+20]
  0008c	89 56 08	 mov	 DWORD PTR [esi+8], edx
  0008f	8b 54 24 1c	 mov	 edx, DWORD PTR _nGetPenya$[esp+16]
  00093	51		 push	 ecx
  00094	8b ce		 mov	 ecx, esi
  00096	89 54 24 10	 mov	 DWORD PTR $T307537[esp+24], edx
  0009a	89 44 24 14	 mov	 DWORD PTR $T307537[esp+28], eax
  0009e	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
  000a3	5f		 pop	 edi
  000a4	5e		 pop	 esi
$L307536:

; 6925 : 	
; 6926 : }

  000a5	83 c4 08	 add	 esp, 8
  000a8	c2 0c 00	 ret	 12			; 0000000cH
?AddGCGetPenyaGuild@CUser@@QAEXH_J@Z ENDP		; CUser::AddGCGetPenyaGuild
_TEXT	ENDS
PUBLIC	?AddGCGetPenyaPlayer@CUser@@QAEXH_J@Z		; CUser::AddGCGetPenyaPlayer
; Function compile flags: /Ogty
;	COMDAT ?AddGCGetPenyaPlayer@CUser@@QAEXH_J@Z
_TEXT	SEGMENT
$T307573 = -8						; size = 8
_nGetResult$ = 8					; size = 4
_nGetPenya$ = 12					; size = 8
?AddGCGetPenyaPlayer@CUser@@QAEXH_J@Z PROC NEAR		; CUser::AddGCGetPenyaPlayer, COMDAT
; _this$ = ecx

; 6929 : 	if( IsDelete() )	return;

  00000	8a 41 04	 mov	 al, BYTE PTR [ecx+4]
  00003	83 ec 08	 sub	 esp, 8
  00006	a8 01		 test	 al, 1
  00008	0f 85 97 00 00
	00		 jne	 $L307572

; 6930 : 	
; 6931 : 	m_Snapshot.cb++;

  0000e	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  00015	56		 push	 esi
  00016	57		 push	 edi

; 6932 : 	m_Snapshot.ar << GetId();

  00017	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  0001d	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  00023	6a 04		 push	 4
  00025	8b ce		 mov	 ecx, esi
  00027	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0002c	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0002f	89 38		 mov	 DWORD PTR [eax], edi
  00031	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00034	83 c0 04	 add	 eax, 4

; 6933 : 	m_Snapshot.ar << SNAPSHOTTYPE_GUILDCOMBAT;

  00037	6a 02		 push	 2
  00039	8b ce		 mov	 ecx, esi
  0003b	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0003e	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00043	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00046	66 c7 01 b8 00	 mov	 WORD PTR [ecx], 184	; 000000b8H
  0004b	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0004e	83 c2 02	 add	 edx, 2

; 6934 : 	m_Snapshot.ar << GC_GETPENYAPLAYER;

  00051	6a 01		 push	 1
  00053	8b ce		 mov	 ecx, esi
  00055	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00058	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0005d	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00060	c6 02 41	 mov	 BYTE PTR [edx], 65	; 00000041H
  00063	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00066	40		 inc	 eax

; 6935 : 	m_Snapshot.ar << nGetResult;

  00067	6a 04		 push	 4
  00069	8b ce		 mov	 ecx, esi
  0006b	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0006e	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00073	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00076	8b 4c 24 14	 mov	 ecx, DWORD PTR _nGetResult$[esp+12]
  0007a	89 08		 mov	 DWORD PTR [eax], ecx
  0007c	8b 56 08	 mov	 edx, DWORD PTR [esi+8]

; 6936 : 	m_Snapshot.ar << nGetPenya;

  0007f	8b 44 24 1c	 mov	 eax, DWORD PTR _nGetPenya$[esp+16]
  00083	83 c2 04	 add	 edx, 4
  00086	6a 08		 push	 8
  00088	8d 4c 24 0c	 lea	 ecx, DWORD PTR $T307573[esp+20]
  0008c	89 56 08	 mov	 DWORD PTR [esi+8], edx
  0008f	8b 54 24 1c	 mov	 edx, DWORD PTR _nGetPenya$[esp+16]
  00093	51		 push	 ecx
  00094	8b ce		 mov	 ecx, esi
  00096	89 54 24 10	 mov	 DWORD PTR $T307573[esp+24], edx
  0009a	89 44 24 14	 mov	 DWORD PTR $T307573[esp+28], eax
  0009e	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
  000a3	5f		 pop	 edi
  000a4	5e		 pop	 esi
$L307572:

; 6937 : 	
; 6938 : }

  000a5	83 c4 08	 add	 esp, 8
  000a8	c2 0c 00	 ret	 12			; 0000000cH
?AddGCGetPenyaPlayer@CUser@@QAEXH_J@Z ENDP		; CUser::AddGCGetPenyaPlayer
_TEXT	ENDS
PUBLIC	?AddGuildCombatState@CUser@@QAEXXZ		; CUser::AddGuildCombatState
; Function compile flags: /Ogty
;	COMDAT ?AddGuildCombatState@CUser@@QAEXXZ
_TEXT	SEGMENT
?AddGuildCombatState@CUser@@QAEXXZ PROC NEAR		; CUser::AddGuildCombatState, COMDAT
; _this$ = ecx

; 7008 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	0f 85 8a 00 00
	00		 jne	 $L307614

; 7009 : 	
; 7010 : 	m_Snapshot.cb++;

  0000a	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  00011	56		 push	 esi
  00012	57		 push	 edi

; 7011 : 	m_Snapshot.ar << GetId();

  00013	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  00019	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  0001f	6a 04		 push	 4
  00021	8b ce		 mov	 ecx, esi
  00023	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00028	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0002b	89 38		 mov	 DWORD PTR [eax], edi
  0002d	83 46 08 04	 add	 DWORD PTR [esi+8], 4

; 7012 : 	m_Snapshot.ar << SNAPSHOTTYPE_GUILDCOMBAT;

  00031	6a 02		 push	 2
  00033	8b ce		 mov	 ecx, esi
  00035	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003a	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003d	66 c7 01 b8 00	 mov	 WORD PTR [ecx], 184	; 000000b8H
  00042	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  00045	83 c7 02	 add	 edi, 2

; 7013 : 	m_Snapshot.ar << GC_GCSTATE;

  00048	6a 01		 push	 1
  0004a	8b ce		 mov	 ecx, esi
  0004c	89 7e 08	 mov	 DWORD PTR [esi+8], edi
  0004f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00054	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00057	c6 02 30	 mov	 BYTE PTR [edx], 48	; 00000030H
  0005a	ff 46 08	 inc	 DWORD PTR [esi+8]

; 7014 : 	m_Snapshot.ar << g_GuildCombatMng.m_nState << g_GuildCombatMng.m_nGCState;

  0005d	8b 3d 40 11 00
	00		 mov	 edi, DWORD PTR ?g_GuildCombatMng@@3VCGuildCombat@@A+4416
  00063	6a 04		 push	 4
  00065	8b ce		 mov	 ecx, esi
  00067	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0006c	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0006f	89 38		 mov	 DWORD PTR [eax], edi
  00071	83 46 08 04	 add	 DWORD PTR [esi+8], 4
  00075	8b 3d 44 11 00
	00		 mov	 edi, DWORD PTR ?g_GuildCombatMng@@3VCGuildCombat@@A+4420
  0007b	6a 04		 push	 4
  0007d	8b ce		 mov	 ecx, esi
  0007f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00084	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00087	89 39		 mov	 DWORD PTR [ecx], edi
  00089	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0008c	83 c0 04	 add	 eax, 4
  0008f	5f		 pop	 edi
  00090	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00093	5e		 pop	 esi
$L307614:

; 7015 : 	
; 7016 : }

  00094	c3		 ret	 0
?AddGuildCombatState@CUser@@QAEXXZ ENDP			; CUser::AddGuildCombatState
_TEXT	ENDS
PUBLIC	?AddQuestTextTime@CUser@@QAEXHHK@Z		; CUser::AddQuestTextTime
; Function compile flags: /Ogty
;	COMDAT ?AddQuestTextTime@CUser@@QAEXHHK@Z
_TEXT	SEGMENT
_bFlag$ = 8						; size = 4
_nState$ = 12						; size = 4
_dwTime$ = 16						; size = 4
?AddQuestTextTime@CUser@@QAEXHHK@Z PROC NEAR		; CUser::AddQuestTextTime, COMDAT
; _this$ = ecx

; 7060 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	0f 85 98 00 00
	00		 jne	 $L307654

; 7061 : 	
; 7062 : 	m_Snapshot.cb++;

  0000a	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  00011	53		 push	 ebx
  00012	56		 push	 esi
  00013	57		 push	 edi

; 7063 : 	m_Snapshot.ar << GetId();

  00014	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  0001a	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  00020	bb 04 00 00 00	 mov	 ebx, 4
  00025	53		 push	 ebx
  00026	8b ce		 mov	 ecx, esi
  00028	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0002d	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00030	89 38		 mov	 DWORD PTR [eax], edi
  00032	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00035	03 c3		 add	 eax, ebx

; 7064 : 	m_Snapshot.ar << SNAPSHOTTYPE_QUEST_TEXT_TIME;

  00037	6a 02		 push	 2
  00039	8b ce		 mov	 ecx, esi
  0003b	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0003e	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00043	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00046	66 c7 01 ba 00	 mov	 WORD PTR [ecx], 186	; 000000baH
  0004b	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0004e	83 c2 02	 add	 edx, 2

; 7065 : 	m_Snapshot.ar << bFlag;

  00051	53		 push	 ebx
  00052	8b ce		 mov	 ecx, esi
  00054	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00057	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0005c	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0005f	8b 44 24 10	 mov	 eax, DWORD PTR _bFlag$[esp+8]
  00063	89 02		 mov	 DWORD PTR [edx], eax
  00065	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00068	03 c3		 add	 eax, ebx

; 7066 : 	m_Snapshot.ar << nState;

  0006a	53		 push	 ebx
  0006b	8b ce		 mov	 ecx, esi
  0006d	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00070	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00075	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00078	8b 54 24 14	 mov	 edx, DWORD PTR _nState$[esp+8]
  0007c	89 11		 mov	 DWORD PTR [ecx], edx
  0007e	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00081	03 d3		 add	 edx, ebx

; 7067 : 	m_Snapshot.ar << dwTime;

  00083	53		 push	 ebx
  00084	8b ce		 mov	 ecx, esi
  00086	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00089	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0008e	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00091	8b 4c 24 18	 mov	 ecx, DWORD PTR _dwTime$[esp+8]
  00095	89 08		 mov	 DWORD PTR [eax], ecx
  00097	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0009a	03 c3		 add	 eax, ebx
  0009c	5f		 pop	 edi
  0009d	89 46 08	 mov	 DWORD PTR [esi+8], eax
  000a0	5e		 pop	 esi
  000a1	5b		 pop	 ebx
$L307654:

; 7068 : 	
; 7069 : }

  000a2	c2 0c 00	 ret	 12			; 0000000cH
?AddQuestTextTime@CUser@@QAEXHHK@Z ENDP			; CUser::AddQuestTextTime
_TEXT	ENDS
PUBLIC	??_C@_01HIHLOKLC@1?$AA@				; `string'
PUBLIC	?DoSMItemEquip@CUser@@QAEXPAVCItemElem@@K@Z	; CUser::DoSMItemEquip
EXTRN	?SendLogSMItemUse@CDPDatabaseClient@@QAEXPBDPAVCUser@@PAVCItemElem@@PAUItemProp@@0@Z:NEAR ; CDPDatabaseClient::SendLogSMItemUse
EXTRN	?SetSMMode@CMover@@QAEHHK@Z:NEAR		; CMover::SetSMMode
;	COMDAT ??_C@_01HIHLOKLC@1?$AA@
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\data.h
CONST	SEGMENT
??_C@_01HIHLOKLC@1?$AA@ DB '1', 00H			; `string'
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
CONST	ENDS
;	COMDAT ?DoSMItemEquip@CUser@@QAEXPAVCItemElem@@K@Z
_TEXT	SEGMENT
_nResistAttackLeft$ = -12				; size = 1
_nResistDefense$ = -8					; size = 1
_nResistAttackRight$ = -4				; size = 1
_pItemElem$ = 8						; size = 4
_dwParts$ = 12						; size = 4
?DoSMItemEquip@CUser@@QAEXPAVCItemElem@@K@Z PROC NEAR	; CUser::DoSMItemEquip, COMDAT
; _this$ = ecx

; 7344 : {

  00000	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00003	53		 push	 ebx

; 7345 : 	BYTE nResistAttackLeft = (BYTE)0xff;
; 7346 : 	BYTE nResistAttackRight = (BYTE)0xff;
; 7347 : 	BYTE nResistDefense = (BYTE)0xff;
; 7348 : 	BYTE nResist = 0;
; 7349 : 	switch( pItemElem->m_nResistSMItemId )

  00004	8b 5c 24 14	 mov	 ebx, DWORD PTR _pItemElem$[esp+12]
  00008	56		 push	 esi
  00009	8b f1		 mov	 esi, ecx
  0000b	8b 8b 90 00 00
	00		 mov	 ecx, DWORD PTR [ebx+144]
  00011	57		 push	 edi
  00012	80 ca ff	 or	 dl, 255			; 000000ffH
  00015	8d b9 db d7 ff
	ff		 lea	 edi, DWORD PTR [ecx-10277]
  0001b	32 c0		 xor	 al, al
  0001d	83 ff 09	 cmp	 edi, 9
  00020	c6 44 24 0c ff	 mov	 BYTE PTR _nResistAttackLeft$[esp+24], 255 ; 000000ffH
  00025	88 54 24 14	 mov	 BYTE PTR _nResistAttackRight$[esp+24], dl
  00029	c6 44 24 10 ff	 mov	 BYTE PTR _nResistDefense$[esp+24], 255 ; 000000ffH
  0002e	77 19		 ja	 SHORT $L283807
  00030	ff 24 bd 00 00
	00 00		 jmp	 DWORD PTR $L307769[edi*4]
$L283815:

; 7350 : 	{
; 7351 : 	case II_CHR_SYS_SCR_FIREASTONE:
; 7352 : 		nResist = SAI79::FIRE;
; 7353 : 		break;
; 7354 : 	case II_CHR_SYS_SCR_WATEILSTONE:
; 7355 : 		nResist = SAI79::WATER;
; 7356 : 		break;
; 7357 : 	case II_CHR_SYS_SCR_WINDYOSTONE:
; 7358 : 		nResist = SAI79::WIND;
; 7359 : 		break;
; 7360 : 	case II_CHR_SYS_SCR_LIGHTINESTONE:
; 7361 : 		nResist = SAI79::ELECTRICITY;
; 7362 : 		break;
; 7363 : 	case II_CHR_SYS_SCR_EARTHYSTONE:
; 7364 : 		nResist = SAI79::EARTH;
; 7365 : 		break;
; 7366 : 	case II_CHR_SYS_SCR_DEFIREASTONE:
; 7367 : 		nResist = SAI79::FIRE;

  00037	b0 01		 mov	 al, 1

; 7368 : 		break;

  00039	eb 0e		 jmp	 SHORT $L283807
$L283816:

; 7369 : 	case II_CHR_SYS_SCR_DEWATEILSTONE:
; 7370 : 		nResist = SAI79::WATER;

  0003b	b0 02		 mov	 al, 2

; 7371 : 		break;

  0003d	eb 0a		 jmp	 SHORT $L283807
$L283817:

; 7372 : 	case II_CHR_SYS_SCR_DEWINDYOSTONE:
; 7373 : 		nResist = SAI79::WIND;

  0003f	b0 04		 mov	 al, 4

; 7374 : 		break;

  00041	eb 06		 jmp	 SHORT $L283807
$L283818:

; 7375 : 	case II_CHR_SYS_SCR_DELIGHTINESTONE:
; 7376 : 		nResist = SAI79::ELECTRICITY;

  00043	b0 03		 mov	 al, 3

; 7377 : 		break;

  00045	eb 02		 jmp	 SHORT $L283807
$L283819:

; 7378 : 	case II_CHR_SYS_SCR_DEEARTHYSTONE:
; 7379 : 		nResist = SAI79::EARTH;

  00047	b0 05		 mov	 al, 5
$L283807:

; 7380 : 		break;
; 7381 : 	}
; 7382 : 
; 7383 : 	if( dwParts == PARTS_LWEAPON )

  00049	8b 7c 24 20	 mov	 edi, DWORD PTR _dwParts$[esp+20]
  0004d	83 ff 09	 cmp	 edi, 9
  00050	75 06		 jne	 SHORT $L283820

; 7384 : 	{
; 7385 : 		nResistAttackLeft = nResist;

  00052	88 44 24 0c	 mov	 BYTE PTR _nResistAttackLeft$[esp+24], al

; 7386 : 	}
; 7387 : 	else if( dwParts == PARTS_RWEAPON )

  00056	eb 11		 jmp	 SHORT $L283823
$L283820:
  00058	83 ff 0a	 cmp	 edi, 10			; 0000000aH
  0005b	75 08		 jne	 SHORT $L283822

; 7388 : 	{
; 7389 : 		nResistAttackRight = nResist;

  0005d	8a d0		 mov	 dl, al
  0005f	88 54 24 14	 mov	 BYTE PTR _nResistAttackRight$[esp+24], dl

; 7390 : 	}
; 7391 : 	else

  00063	eb 04		 jmp	 SHORT $L283823
$L283822:

; 7392 : 	{
; 7393 : 		nResistDefense = nResist;

  00065	88 44 24 10	 mov	 BYTE PTR _nResistDefense$[esp+24], al
$L283823:

; 7394 : 	}
; 7395 : 
; 7396 : 	ItemProp* pItemProp = NULL;
; 7397 : 	pItemProp = prj.GetItemProp( pItemElem->m_nResistSMItemId );

  00069	85 c9		 test	 ecx, ecx
  0006b	a1 5c 02 00 00	 mov	 eax, DWORD PTR ?prj@@3VCProject@@A+604
  00070	0f 8c 80 00 00
	00		 jl	 $L307686
  00076	3b c8		 cmp	 ecx, eax
  00078	7d 7c		 jge	 SHORT $L307686
  0007a	0f 83 5a 01 00
	00		 jae	 $L283840
  00080	a1 4c 02 00 00	 mov	 eax, DWORD PTR ?prj@@3VCProject@@A+588
  00085	8b 3c 88	 mov	 edi, DWORD PTR [eax+ecx*4]

; 7398 : 	if( pItemProp )

  00088	85 ff		 test	 edi, edi
  0008a	0f 84 4a 01 00
	00		 je	 $L283840

; 7399 : 	{
; 7400 : 		if( nResistAttackLeft != (BYTE)0xff )

  00090	8a 44 24 0c	 mov	 al, BYTE PTR _nResistAttackLeft$[esp+24]
  00094	3c ff		 cmp	 al, 255			; 000000ffH
  00096	0f 84 98 00 00
	00		 je	 $L283827

; 7401 : 		{
; 7402 : 			m_nAttackResistLeft = nResistAttackLeft;
; 7403 : 			((CUser*)this)->AddResistSMMode( m_nAttackResistLeft, m_nAttackResistRight, m_nDefenseResist );

  0009c	33 c9		 xor	 ecx, ecx
  0009e	8a 8e 16 07 00
	00		 mov	 cl, BYTE PTR [esi+1814]
  000a4	33 d2		 xor	 edx, edx
  000a6	8a 96 15 07 00
	00		 mov	 dl, BYTE PTR [esi+1813]
  000ac	88 86 14 07 00
	00		 mov	 BYTE PTR [esi+1812], al
  000b2	8b 44 24 0c	 mov	 eax, DWORD PTR _nResistAttackLeft$[esp+24]
  000b6	51		 push	 ecx
  000b7	8b ce		 mov	 ecx, esi
  000b9	52		 push	 edx
  000ba	50		 push	 eax
  000bb	e8 00 00 00 00	 call	 ?AddResistSMMode@CUser@@QAEXEEE@Z ; CUser::AddResistSMMode

; 7404 : 			SetSMMode( SM_RESIST_ATTACK_LEFT, pItemProp->dwCircleTime );

  000c0	8b 8f ec 01 00
	00		 mov	 ecx, DWORD PTR [edi+492]
  000c6	51		 push	 ecx
  000c7	6a 10		 push	 16			; 00000010H
  000c9	8b ce		 mov	 ecx, esi
  000cb	e8 00 00 00 00	 call	 ?SetSMMode@CMover@@QAEHHK@Z ; CMover::SetSMMode

; 7405 : 			g_dpDBClient.SendLogSMItemUse( "1", (CUser*)this, pItemElem, pItemElem->GetProp() );

  000d0	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]
  000d3	85 c0		 test	 eax, eax
  000d5	8b 0d 5c 02 00
	00		 mov	 ecx, DWORD PTR ?prj@@3VCProject@@A+604
  000db	7c 38		 jl	 SHORT $L307751
  000dd	3b c1		 cmp	 eax, ecx
  000df	7d 34		 jge	 SHORT $L307751
  000e1	73 48		 jae	 SHORT $L307768
  000e3	8b 15 4c 02 00
	00		 mov	 edx, DWORD PTR ?prj@@3VCProject@@A+588
  000e9	8b 04 82	 mov	 eax, DWORD PTR [edx+eax*4]
  000ec	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@

; 7406 : 			g_dpDBClient.SendLogSMItemUse( "1", (CUser*)this, NULL, pItemProp );
; 7407 : 		}
; 7408 : 		else

  000f1	e9 ba 00 00 00	 jmp	 $L307766

; 7394 : 	}
; 7395 : 
; 7396 : 	ItemProp* pItemProp = NULL;
; 7397 : 	pItemProp = prj.GetItemProp( pItemElem->m_nResistSMItemId );

$L307686:
  000f6	51		 push	 ecx
  000f7	50		 push	 eax
  000f8	6a 00		 push	 0
  000fa	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BI@BEIFNGEL@GetItemProp?5range_error?$AA@
  000ff	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@HMFGHCP@?$CFs?5min?3?$CFd?0?5max?3?$CFd?0?5index?3?$CFd?$AA@
  00104	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  00109	83 c4 14	 add	 esp, 20			; 00000014H
  0010c	5f		 pop	 edi
  0010d	5e		 pop	 esi
  0010e	5b		 pop	 ebx

; 7425 : 		}
; 7426 : 	}
; 7427 : }

  0010f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00112	c2 08 00	 ret	 8

; 7405 : 			g_dpDBClient.SendLogSMItemUse( "1", (CUser*)this, pItemElem, pItemElem->GetProp() );

$L307751:
  00115	50		 push	 eax
  00116	51		 push	 ecx
  00117	6a 00		 push	 0
  00119	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BI@BEIFNGEL@GetItemProp?5range_error?$AA@
  0011e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@HMFGHCP@?$CFs?5min?3?$CFd?0?5max?3?$CFd?0?5index?3?$CFd?$AA@
  00123	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  00128	83 c4 14	 add	 esp, 20			; 00000014H
$L307768:
  0012b	33 c0		 xor	 eax, eax
  0012d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@

; 7406 : 			g_dpDBClient.SendLogSMItemUse( "1", (CUser*)this, NULL, pItemProp );
; 7407 : 		}
; 7408 : 		else

  00132	eb 7c		 jmp	 SHORT $L307766
$L283827:

; 7409 : 		if( nResistAttackRight != (BYTE)0xff )

  00134	80 fa ff	 cmp	 dl, 255			; 000000ffH
  00137	74 2f		 je	 SHORT $L283834

; 7410 : 		{
; 7411 : 			m_nAttackResistRight = nResistAttackRight;
; 7412 : 			((CUser*)this)->AddResistSMMode( m_nAttackResistLeft, m_nAttackResistRight, m_nDefenseResist );

  00139	8b 4c 24 14	 mov	 ecx, DWORD PTR _nResistAttackRight$[esp+24]
  0013d	33 c0		 xor	 eax, eax
  0013f	8a 86 16 07 00
	00		 mov	 al, BYTE PTR [esi+1814]
  00145	88 96 15 07 00
	00		 mov	 BYTE PTR [esi+1813], dl
  0014b	33 d2		 xor	 edx, edx
  0014d	8a 96 14 07 00
	00		 mov	 dl, BYTE PTR [esi+1812]
  00153	50		 push	 eax
  00154	51		 push	 ecx
  00155	8b ce		 mov	 ecx, esi
  00157	52		 push	 edx
  00158	e8 00 00 00 00	 call	 ?AddResistSMMode@CUser@@QAEXEEE@Z ; CUser::AddResistSMMode

; 7413 : 			SetSMMode( SM_RESIST_ATTACK_RIGHT, pItemProp->dwCircleTime );

  0015d	8b 87 ec 01 00
	00		 mov	 eax, DWORD PTR [edi+492]
  00163	50		 push	 eax
  00164	6a 11		 push	 17			; 00000011H

; 7414 : 			g_dpDBClient.SendLogSMItemUse( "1", (CUser*)this, pItemElem, pItemElem->GetProp() );
; 7415 : 			g_dpDBClient.SendLogSMItemUse( "1", (CUser*)this, NULL, pItemProp );
; 7416 : 		}
; 7417 : 		else

  00166	eb 35		 jmp	 SHORT $L307767
$L283834:

; 7418 : 		if( nResistDefense != (BYTE)0xff )

  00168	8a 44 24 10	 mov	 al, BYTE PTR _nResistDefense$[esp+24]
  0016c	3c ff		 cmp	 al, 255			; 000000ffH
  0016e	74 6a		 je	 SHORT $L283840

; 7419 : 		{
; 7420 : 			m_nDefenseResist = nResistDefense;
; 7421 : 			((CUser*)this)->AddResistSMMode( m_nAttackResistLeft, m_nAttackResistRight, m_nDefenseResist );

  00170	8b 4c 24 10	 mov	 ecx, DWORD PTR _nResistDefense$[esp+24]
  00174	33 d2		 xor	 edx, edx
  00176	8a 96 15 07 00
	00		 mov	 dl, BYTE PTR [esi+1813]
  0017c	88 86 16 07 00
	00		 mov	 BYTE PTR [esi+1814], al
  00182	33 c0		 xor	 eax, eax
  00184	8a 86 14 07 00
	00		 mov	 al, BYTE PTR [esi+1812]
  0018a	51		 push	 ecx
  0018b	8b ce		 mov	 ecx, esi
  0018d	52		 push	 edx
  0018e	50		 push	 eax
  0018f	e8 00 00 00 00	 call	 ?AddResistSMMode@CUser@@QAEXEEE@Z ; CUser::AddResistSMMode

; 7422 : 			SetSMMode( SM_RESIST_DEFENSE, pItemProp->dwCircleTime );

  00194	8b 8f ec 01 00
	00		 mov	 ecx, DWORD PTR [edi+492]
  0019a	51		 push	 ecx
  0019b	6a 12		 push	 18			; 00000012H
$L307767:
  0019d	8b ce		 mov	 ecx, esi
  0019f	e8 00 00 00 00	 call	 ?SetSMMode@CMover@@QAEHHK@Z ; CMover::SetSMMode

; 7423 : 			g_dpDBClient.SendLogSMItemUse( "1", (CUser*)this, pItemElem, pItemElem->GetProp() );

  001a4	8b cb		 mov	 ecx, ebx
  001a6	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  001ab	e8 00 00 00 00	 call	 ?GetPropA@CItemElem@@QAEPAUItemProp@@XZ ; CItemElem::GetPropA
$L307766:
  001b0	50		 push	 eax
  001b1	53		 push	 ebx
  001b2	56		 push	 esi
  001b3	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_dpDBClient@@3VCDPDatabaseClient@@A
  001b8	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_01HIHLOKLC@1?$AA@
  001bd	e8 00 00 00 00	 call	 ?SendLogSMItemUse@CDPDatabaseClient@@QAEXPBDPAVCUser@@PAVCItemElem@@PAUItemProp@@0@Z ; CDPDatabaseClient::SendLogSMItemUse

; 7424 : 			g_dpDBClient.SendLogSMItemUse( "1", (CUser*)this, NULL, pItemProp );

  001c2	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  001c7	57		 push	 edi
  001c8	6a 00		 push	 0
  001ca	56		 push	 esi
  001cb	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_dpDBClient@@3VCDPDatabaseClient@@A
  001d0	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_01HIHLOKLC@1?$AA@
  001d5	e8 00 00 00 00	 call	 ?SendLogSMItemUse@CDPDatabaseClient@@QAEXPBDPAVCUser@@PAVCItemElem@@PAUItemProp@@0@Z ; CDPDatabaseClient::SendLogSMItemUse
$L283840:
  001da	5f		 pop	 edi
  001db	5e		 pop	 esi
  001dc	5b		 pop	 ebx

; 7425 : 		}
; 7426 : 	}
; 7427 : }

  001dd	83 c4 0c	 add	 esp, 12			; 0000000cH
  001e0	c2 08 00	 ret	 8
  001e3	90		 npad	 1
$L307769:
  001e4	00 00 00 00	 DD	 $L283815
  001e8	00 00 00 00	 DD	 $L283816
  001ec	00 00 00 00	 DD	 $L283817
  001f0	00 00 00 00	 DD	 $L283818
  001f4	00 00 00 00	 DD	 $L283819
  001f8	00 00 00 00	 DD	 $L283815
  001fc	00 00 00 00	 DD	 $L283816
  00200	00 00 00 00	 DD	 $L283817
  00204	00 00 00 00	 DD	 $L283818
  00208	00 00 00 00	 DD	 $L283819
?DoSMItemEquip@CUser@@QAEXPAVCItemElem@@K@Z ENDP	; CUser::DoSMItemEquip
_TEXT	ENDS
PUBLIC	??_C@_01FDFGLJHB@2?$AA@				; `string'
PUBLIC	?DoSMItemUnEquip@CUser@@QAEXPAVCItemElem@@K@Z	; CUser::DoSMItemUnEquip
;	COMDAT ??_C@_01FDFGLJHB@2?$AA@
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\data.h
CONST	SEGMENT
??_C@_01FDFGLJHB@2?$AA@ DB '2', 00H			; `string'
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
CONST	ENDS
;	COMDAT ?DoSMItemUnEquip@CUser@@QAEXPAVCItemElem@@K@Z
_TEXT	SEGMENT
_pItemElem$ = 8						; size = 4
_dwParts$ = 12						; size = 4
?DoSMItemUnEquip@CUser@@QAEXPAVCItemElem@@K@Z PROC NEAR	; CUser::DoSMItemUnEquip, COMDAT
; _this$ = ecx

; 7430 : {

  00000	56		 push	 esi

; 7431 : 	if( pItemElem->m_nResistSMItemId == II_CHR_SYS_SCR_FIREASTONE || pItemElem->m_nResistSMItemId == II_CHR_SYS_SCR_WATEILSTONE ||
; 7432 : 		pItemElem->m_nResistSMItemId == II_CHR_SYS_SCR_WINDYOSTONE || pItemElem->m_nResistSMItemId == II_CHR_SYS_SCR_LIGHTINESTONE ||
; 7433 : 		pItemElem->m_nResistSMItemId == II_CHR_SYS_SCR_EARTHYSTONE
; 7434 : 		)

  00001	8b 74 24 08	 mov	 esi, DWORD PTR _pItemElem$[esp]
  00005	8b 86 90 00 00
	00		 mov	 eax, DWORD PTR [esi+144]
  0000b	3d 25 28 00 00	 cmp	 eax, 10277		; 00002825H
  00010	57		 push	 edi
  00011	8b f9		 mov	 edi, ecx
  00013	74 76		 je	 SHORT $L283850
  00015	3d 26 28 00 00	 cmp	 eax, 10278		; 00002826H
  0001a	74 6f		 je	 SHORT $L283850
  0001c	3d 27 28 00 00	 cmp	 eax, 10279		; 00002827H
  00021	74 68		 je	 SHORT $L283850
  00023	3d 28 28 00 00	 cmp	 eax, 10280		; 00002828H
  00028	74 61		 je	 SHORT $L283850
  0002a	3d 29 28 00 00	 cmp	 eax, 10281		; 00002829H
  0002f	74 5a		 je	 SHORT $L283850

; 7448 : 	}
; 7449 : 	else
; 7450 : 	if( pItemElem->m_nResistSMItemId == II_CHR_SYS_SCR_DEFIREASTONE || pItemElem->m_nResistSMItemId == II_CHR_SYS_SCR_DEWATEILSTONE ||
; 7451 : 		pItemElem->m_nResistSMItemId == II_CHR_SYS_SCR_DEWINDYOSTONE || pItemElem->m_nResistSMItemId == II_CHR_SYS_SCR_DELIGHTINESTONE ||
; 7452 : 		pItemElem->m_nResistSMItemId == II_CHR_SYS_SCR_DEEARTHYSTONE
; 7453 : 		)

  00031	3d 2a 28 00 00	 cmp	 eax, 10282		; 0000282aH
  00036	74 20		 je	 SHORT $L283859
  00038	3d 2b 28 00 00	 cmp	 eax, 10283		; 0000282bH
  0003d	74 19		 je	 SHORT $L283859
  0003f	3d 2c 28 00 00	 cmp	 eax, 10284		; 0000282cH
  00044	74 12		 je	 SHORT $L283859
  00046	3d 2d 28 00 00	 cmp	 eax, 10285		; 0000282dH
  0004b	74 0b		 je	 SHORT $L283859
  0004d	3d 2e 28 00 00	 cmp	 eax, 10286		; 0000282eH
  00052	0f 85 ff 00 00
	00		 jne	 $L283858
$L283859:

; 7454 : 	{
; 7455 : 		SetSMMode( SM_RESIST_DEFENSE, 1 );

  00058	6a 01		 push	 1
  0005a	6a 12		 push	 18			; 00000012H
  0005c	8b cf		 mov	 ecx, edi
  0005e	e8 00 00 00 00	 call	 ?SetSMMode@CMover@@QAEHHK@Z ; CMover::SetSMMode

; 7456 : 		pItemElem->m_nResistSMItemId = 0;
; 7457 : 		((CUser*)this)->AddCommercialElem( pItemElem->m_dwObjId, 0 );

  00063	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00066	6a 00		 push	 0
  00068	50		 push	 eax
  00069	8b cf		 mov	 ecx, edi
  0006b	c7 86 90 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+144], 0
  00075	e8 00 00 00 00	 call	 ?AddCommercialElem@CUser@@QAEXKH@Z ; CUser::AddCommercialElem

; 7458 : 		g_dpDBClient.SendLogSMItemUse( "2", (CUser*)this, pItemElem, pItemElem->GetProp() );

  0007a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  0007f	8b ce		 mov	 ecx, esi
  00081	e8 00 00 00 00	 call	 ?GetPropA@CItemElem@@QAEPAUItemProp@@XZ ; CItemElem::GetPropA
  00086	e9 ba 00 00 00	 jmp	 $L307903
$L283850:

; 7435 : 	{
; 7436 : 		if( dwParts == PARTS_LWEAPON )

  0008b	83 7c 24 10 09	 cmp	 DWORD PTR _dwParts$[esp+4], 9

; 7437 : 		{
; 7438 : 			SetSMMode( SM_RESIST_ATTACK_LEFT, 1 );

  00090	8b cf		 mov	 ecx, edi
  00092	6a 01		 push	 1
  00094	75 56		 jne	 SHORT $L283851
  00096	6a 10		 push	 16			; 00000010H
  00098	e8 00 00 00 00	 call	 ?SetSMMode@CMover@@QAEHHK@Z ; CMover::SetSMMode

; 7439 : 			g_dpDBClient.SendLogSMItemUse( "2", (CUser*)this, pItemElem, pItemElem->GetProp() );

  0009d	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  000a0	85 c0		 test	 eax, eax
  000a2	8b 0d 5c 02 00
	00		 mov	 ecx, DWORD PTR ?prj@@3VCProject@@A+604
  000a8	7c 11		 jl	 SHORT $L307823
  000aa	3b c1		 cmp	 eax, ecx
  000ac	7d 0d		 jge	 SHORT $L307823
  000ae	73 21		 jae	 SHORT $L307904
  000b0	8b 0d 4c 02 00
	00		 mov	 ecx, DWORD PTR ?prj@@3VCProject@@A+588
  000b6	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  000b9	eb 18		 jmp	 SHORT $L307818
$L307823:
  000bb	50		 push	 eax
  000bc	51		 push	 ecx
  000bd	6a 00		 push	 0
  000bf	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BI@BEIFNGEL@GetItemProp?5range_error?$AA@
  000c4	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@HMFGHCP@?$CFs?5min?3?$CFd?0?5max?3?$CFd?0?5index?3?$CFd?$AA@
  000c9	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  000ce	83 c4 14	 add	 esp, 20			; 00000014H
$L307904:
  000d1	33 c0		 xor	 eax, eax
$L307818:
  000d3	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  000d8	50		 push	 eax
  000d9	56		 push	 esi
  000da	57		 push	 edi
  000db	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_01FDFGLJHB@2?$AA@
  000e0	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_dpDBClient@@3VCDPDatabaseClient@@A
  000e5	e8 00 00 00 00	 call	 ?SendLogSMItemUse@CDPDatabaseClient@@QAEXPBDPAVCUser@@PAVCItemElem@@PAUItemProp@@0@Z ; CDPDatabaseClient::SendLogSMItemUse

; 7440 : 		}
; 7441 : 		else

  000ea	eb 07		 jmp	 SHORT $L283854
$L283851:

; 7442 : 		{
; 7443 : 			SetSMMode( SM_RESIST_ATTACK_RIGHT, 1 );

  000ec	6a 11		 push	 17			; 00000011H
  000ee	e8 00 00 00 00	 call	 ?SetSMMode@CMover@@QAEHHK@Z ; CMover::SetSMMode
$L283854:

; 7444 : 		}
; 7445 : 		pItemElem->m_nResistSMItemId = 0;
; 7446 : 		((CUser*)this)->AddCommercialElem( pItemElem->m_dwObjId, 0 );

  000f3	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  000f6	6a 00		 push	 0
  000f8	52		 push	 edx
  000f9	8b cf		 mov	 ecx, edi
  000fb	c7 86 90 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+144], 0
  00105	e8 00 00 00 00	 call	 ?AddCommercialElem@CUser@@QAEXKH@Z ; CUser::AddCommercialElem

; 7447 : 		g_dpDBClient.SendLogSMItemUse( "2", (CUser*)this, pItemElem, pItemElem->GetProp() );

  0010a	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  0010d	85 c0		 test	 eax, eax
  0010f	8b 0d 5c 02 00
	00		 mov	 ecx, DWORD PTR ?prj@@3VCProject@@A+604
  00115	7c 11		 jl	 SHORT $L307888
  00117	3b c1		 cmp	 eax, ecx
  00119	7d 0d		 jge	 SHORT $L307888
  0011b	73 21		 jae	 SHORT $L307905
  0011d	8b 0d 4c 02 00
	00		 mov	 ecx, DWORD PTR ?prj@@3VCProject@@A+588
  00123	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  00126	eb 18		 jmp	 SHORT $L307883
$L307888:
  00128	50		 push	 eax
  00129	51		 push	 ecx
  0012a	6a 00		 push	 0
  0012c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BI@BEIFNGEL@GetItemProp?5range_error?$AA@
  00131	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@HMFGHCP@?$CFs?5min?3?$CFd?0?5max?3?$CFd?0?5index?3?$CFd?$AA@
  00136	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  0013b	83 c4 14	 add	 esp, 20			; 00000014H
$L307905:
  0013e	33 c0		 xor	 eax, eax
$L307883:
  00140	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
$L307903:
  00145	50		 push	 eax
  00146	56		 push	 esi
  00147	57		 push	 edi
  00148	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_dpDBClient@@3VCDPDatabaseClient@@A
  0014d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_01FDFGLJHB@2?$AA@
  00152	e8 00 00 00 00	 call	 ?SendLogSMItemUse@CDPDatabaseClient@@QAEXPBDPAVCUser@@PAVCItemElem@@PAUItemProp@@0@Z ; CDPDatabaseClient::SendLogSMItemUse
$L283858:
  00157	5f		 pop	 edi
  00158	5e		 pop	 esi

; 7459 : 	}
; 7460 : }

  00159	c2 08 00	 ret	 8
?DoSMItemUnEquip@CUser@@QAEXPAVCItemElem@@K@Z ENDP	; CUser::DoSMItemUnEquip
_TEXT	ENDS
PUBLIC	?AddKawibawiboResult@CUser@@QAEXHHKHKH@Z	; CUser::AddKawibawiboResult
; Function compile flags: /Ogty
;	COMDAT ?AddKawibawiboResult@CUser@@QAEXHHKHKH@Z
_TEXT	SEGMENT
_nResult$ = 8						; size = 4
_nWinCount$ = 12					; size = 4
_dwItemId$ = 16						; size = 4
_nItemCount$ = 20					; size = 4
_dwNextItemId$ = 24					; size = 4
_nNextItemCount$ = 28					; size = 4
?AddKawibawiboResult@CUser@@QAEXHHKHKH@Z PROC NEAR	; CUser::AddKawibawiboResult, COMDAT
; _this$ = ecx

; 7665 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	0f 85 4e 01 00
	00		 jne	 $L307988

; 7666 : 	
; 7667 : 	m_Snapshot.cb++;

  0000a	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  00011	53		 push	 ebx

; 7668 : 	m_Snapshot.ar << GetId();

  00012	8b 99 bc 01 00
	00		 mov	 ebx, DWORD PTR [ecx+444]
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  00020	bf 04 00 00 00	 mov	 edi, 4
  00025	57		 push	 edi
  00026	8b ce		 mov	 ecx, esi
  00028	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0002d	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00030	89 18		 mov	 DWORD PTR [eax], ebx
  00032	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00035	03 d7		 add	 edx, edi

; 7669 : 	m_Snapshot.ar << SNAPSHOTTYPE_MINIGAME;

  00037	6a 02		 push	 2
  00039	8b ce		 mov	 ecx, esi
  0003b	89 56 08	 mov	 DWORD PTR [esi+8], edx
  0003e	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00043	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00046	66 c7 01 e8 00	 mov	 WORD PTR [ecx], 232	; 000000e8H
  0004b	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0004e	83 c0 02	 add	 eax, 2

; 7670 : 	m_Snapshot.ar << MINIGAME_KAWIBAWIBO_RESUTLT;

  00051	6a 01		 push	 1
  00053	8b ce		 mov	 ecx, esi
  00055	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00058	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0005d	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00060	c6 02 01	 mov	 BYTE PTR [edx], 1
  00063	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00066	42		 inc	 edx

; 7671 : 
; 7672 : 	m_Snapshot.ar << nResult;

  00067	57		 push	 edi
  00068	8b ce		 mov	 ecx, esi
  0006a	89 56 08	 mov	 DWORD PTR [esi+8], edx
  0006d	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00072	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00075	8b 5c 24 10	 mov	 ebx, DWORD PTR _nResult$[esp+8]
  00079	89 18		 mov	 DWORD PTR [eax], ebx
  0007b	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0007e	03 c7		 add	 eax, edi

; 7673 : 	m_Snapshot.ar << nWinCount;

  00080	57		 push	 edi
  00081	8b ce		 mov	 ecx, esi
  00083	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00086	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0008b	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0008e	8b 54 24 14	 mov	 edx, DWORD PTR _nWinCount$[esp+8]
  00092	89 11		 mov	 DWORD PTR [ecx], edx
  00094	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00097	03 cf		 add	 ecx, edi

; 7674 : 	if( nResult == CMiniGame::KAWIBAWIBO_WIN )

  00099	85 db		 test	 ebx, ebx
  0009b	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  0009e	0f 85 80 00 00
	00		 jne	 $L284791

; 7675 : 	{
; 7676 : 		m_Snapshot.ar << dwItemId << dwNextItemId;

  000a4	57		 push	 edi
  000a5	8b ce		 mov	 ecx, esi
  000a7	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000ac	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000af	8b 4c 24 18	 mov	 ecx, DWORD PTR _dwItemId$[esp+8]
  000b3	89 08		 mov	 DWORD PTR [eax], ecx
  000b5	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000b8	03 c7		 add	 eax, edi
  000ba	57		 push	 edi
  000bb	8b ce		 mov	 ecx, esi
  000bd	89 46 08	 mov	 DWORD PTR [esi+8], eax
  000c0	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000c5	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  000c8	8b 44 24 20	 mov	 eax, DWORD PTR _dwNextItemId$[esp+8]
  000cc	89 02		 mov	 DWORD PTR [edx], eax
  000ce	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  000d1	03 d7		 add	 edx, edi

; 7677 : 		m_Snapshot.ar << nItemCount << nNextItemCount;

  000d3	57		 push	 edi
  000d4	8b ce		 mov	 ecx, esi
  000d6	89 56 08	 mov	 DWORD PTR [esi+8], edx
  000d9	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000de	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  000e1	8b 54 24 1c	 mov	 edx, DWORD PTR _nItemCount$[esp+8]
  000e5	89 11		 mov	 DWORD PTR [ecx], edx
  000e7	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000ea	03 c7		 add	 eax, edi
  000ec	57		 push	 edi
  000ed	8b ce		 mov	 ecx, esi
  000ef	89 46 08	 mov	 DWORD PTR [esi+8], eax
  000f2	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000f7	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000fa	8b 4c 24 24	 mov	 ecx, DWORD PTR _nNextItemCount$[esp+8]
  000fe	89 08		 mov	 DWORD PTR [eax], ecx
  00100	01 7e 08	 add	 DWORD PTR [esi+8], edi

; 7678 : 		m_Snapshot.ar << prj.m_MiniGame.nKawiBawiBo_MaxWin;

  00103	8b 1d 40 91 11
	00		 mov	 ebx, DWORD PTR ?prj@@3VCProject@@A+1151296
  00109	57		 push	 edi
  0010a	8b ce		 mov	 ecx, esi
  0010c	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00111	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00114	89 1a		 mov	 DWORD PTR [edx], ebx

; 7683 : 		m_Snapshot.ar << nItemCount;

  00116	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00119	03 c7		 add	 eax, edi
  0011b	5f		 pop	 edi
  0011c	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0011f	5e		 pop	 esi
  00120	5b		 pop	 ebx

; 7684 : 	}
; 7685 : }

  00121	c2 18 00	 ret	 24			; 00000018H
$L284791:

; 7679 : 	}
; 7680 : 	else if( nResult == CMiniGame::KAWIBAWIBO_GETITEM )

  00124	3b df		 cmp	 ebx, edi
  00126	75 2d		 jne	 SHORT $L307993

; 7681 : 	{
; 7682 : 		m_Snapshot.ar << dwItemId;

  00128	57		 push	 edi
  00129	8b ce		 mov	 ecx, esi
  0012b	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00130	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00133	8b 4c 24 18	 mov	 ecx, DWORD PTR _dwItemId$[esp+8]
  00137	89 08		 mov	 DWORD PTR [eax], ecx
  00139	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0013c	03 d7		 add	 edx, edi

; 7683 : 		m_Snapshot.ar << nItemCount;

  0013e	57		 push	 edi
  0013f	8b ce		 mov	 ecx, esi
  00141	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00144	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00149	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0014c	8b 44 24 1c	 mov	 eax, DWORD PTR _nItemCount$[esp+8]
  00150	89 02		 mov	 DWORD PTR [edx], eax
  00152	01 7e 08	 add	 DWORD PTR [esi+8], edi
$L307993:
  00155	5f		 pop	 edi
  00156	5e		 pop	 esi
  00157	5b		 pop	 ebx
$L307988:

; 7684 : 	}
; 7685 : }

  00158	c2 18 00	 ret	 24			; 00000018H
?AddKawibawiboResult@CUser@@QAEXHHKHKH@Z ENDP		; CUser::AddKawibawiboResult
_TEXT	ENDS
PUBLIC	?AddReassembleResult@CUser@@QAEXKH@Z		; CUser::AddReassembleResult
; Function compile flags: /Ogty
;	COMDAT ?AddReassembleResult@CUser@@QAEXKH@Z
_TEXT	SEGMENT
_dwItemId$ = 8						; size = 4
_nItemCount$ = 12					; size = 4
?AddReassembleResult@CUser@@QAEXKH@Z PROC NEAR		; CUser::AddReassembleResult, COMDAT
; _this$ = ecx

; 7703 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	0f 85 94 00 00
	00		 jne	 $L308027

; 7704 : 	
; 7705 : 	m_Snapshot.cb++;

  0000a	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  00011	56		 push	 esi
  00012	57		 push	 edi

; 7706 : 	m_Snapshot.ar << GetId();

  00013	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  00019	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  0001f	6a 04		 push	 4
  00021	8b ce		 mov	 ecx, esi
  00023	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00028	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0002b	89 38		 mov	 DWORD PTR [eax], edi
  0002d	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00030	83 c0 04	 add	 eax, 4

; 7707 : 	m_Snapshot.ar << SNAPSHOTTYPE_MINIGAME;

  00033	6a 02		 push	 2
  00035	8b ce		 mov	 ecx, esi
  00037	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0003a	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003f	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00042	66 c7 01 e8 00	 mov	 WORD PTR [ecx], 232	; 000000e8H
  00047	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0004a	83 c2 02	 add	 edx, 2

; 7708 : 	m_Snapshot.ar << MINIGAME_REASSEMBLE_RESULT;

  0004d	6a 01		 push	 1
  0004f	8b ce		 mov	 ecx, esi
  00051	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00054	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00059	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0005c	c6 02 02	 mov	 BYTE PTR [edx], 2
  0005f	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00062	40		 inc	 eax

; 7709 : 	
; 7710 : 	m_Snapshot.ar << dwItemId;

  00063	6a 04		 push	 4
  00065	8b ce		 mov	 ecx, esi
  00067	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0006a	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0006f	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00072	8b 4c 24 0c	 mov	 ecx, DWORD PTR _dwItemId$[esp+4]
  00076	89 08		 mov	 DWORD PTR [eax], ecx
  00078	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0007b	83 c2 04	 add	 edx, 4

; 7711 : 	m_Snapshot.ar << nItemCount;

  0007e	6a 04		 push	 4
  00080	8b ce		 mov	 ecx, esi
  00082	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00085	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0008a	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0008d	8b 44 24 10	 mov	 eax, DWORD PTR _nItemCount$[esp+4]
  00091	89 02		 mov	 DWORD PTR [edx], eax
  00093	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00096	83 c0 04	 add	 eax, 4
  00099	5f		 pop	 edi
  0009a	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0009d	5e		 pop	 esi
$L308027:

; 7712 : }

  0009e	c2 08 00	 ret	 8
?AddReassembleResult@CUser@@QAEXKH@Z ENDP		; CUser::AddReassembleResult
_TEXT	ENDS
PUBLIC	?AddAlphabetResult@CUser@@QAEXHKH@Z		; CUser::AddAlphabetResult
; Function compile flags: /Ogty
;	COMDAT ?AddAlphabetResult@CUser@@QAEXHKH@Z
_TEXT	SEGMENT
_nResult$ = 8						; size = 4
_dwItemId$ = 12						; size = 4
_nItemCount$ = 16					; size = 4
?AddAlphabetResult@CUser@@QAEXHKH@Z PROC NEAR		; CUser::AddAlphabetResult, COMDAT
; _this$ = ecx

; 7731 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	0f 85 b7 00 00
	00		 jne	 $L308071

; 7732 : 	
; 7733 : 	m_Snapshot.cb++;

  0000a	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  00011	53		 push	 ebx
  00012	56		 push	 esi
  00013	57		 push	 edi

; 7734 : 	m_Snapshot.ar << GetId();

  00014	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  0001a	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  00020	bb 04 00 00 00	 mov	 ebx, 4
  00025	53		 push	 ebx
  00026	8b ce		 mov	 ecx, esi
  00028	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0002d	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00030	89 38		 mov	 DWORD PTR [eax], edi
  00032	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00035	03 c3		 add	 eax, ebx

; 7735 : 	m_Snapshot.ar << SNAPSHOTTYPE_MINIGAME;

  00037	6a 02		 push	 2
  00039	8b ce		 mov	 ecx, esi
  0003b	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0003e	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00043	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00046	66 c7 01 e8 00	 mov	 WORD PTR [ecx], 232	; 000000e8H
  0004b	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0004e	83 c2 02	 add	 edx, 2

; 7736 : 	m_Snapshot.ar << MINIGAME_ALPHABET_RESULT;

  00051	6a 01		 push	 1
  00053	8b ce		 mov	 ecx, esi
  00055	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00058	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0005d	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00060	c6 02 05	 mov	 BYTE PTR [edx], 5
  00063	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00066	40		 inc	 eax

; 7737 : 	
; 7738 : 	m_Snapshot.ar << nResult;

  00067	53		 push	 ebx
  00068	8b ce		 mov	 ecx, esi
  0006a	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0006d	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00072	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00075	8b 44 24 10	 mov	 eax, DWORD PTR _nResult$[esp+8]
  00079	89 01		 mov	 DWORD PTR [ecx], eax
  0007b	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0007e	03 d3		 add	 edx, ebx

; 7739 : 	if( nResult != CMiniGame::ALPHABET_FAILED && nResult != CMiniGame::ALPHABET_NOTENOUGH_MONEY )

  00080	3d e7 03 00 00	 cmp	 eax, 999		; 000003e7H
  00085	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00088	74 34		 je	 SHORT $L308076
  0008a	3d e6 03 00 00	 cmp	 eax, 998		; 000003e6H
  0008f	74 2d		 je	 SHORT $L308076

; 7740 : 	{
; 7741 : 		m_Snapshot.ar << dwItemId;

  00091	53		 push	 ebx
  00092	8b ce		 mov	 ecx, esi
  00094	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00099	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0009c	8b 44 24 14	 mov	 eax, DWORD PTR _dwItemId$[esp+8]
  000a0	89 02		 mov	 DWORD PTR [edx], eax
  000a2	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  000a5	03 d3		 add	 edx, ebx

; 7742 : 		m_Snapshot.ar << nItemCount;

  000a7	53		 push	 ebx
  000a8	8b ce		 mov	 ecx, esi
  000aa	89 56 08	 mov	 DWORD PTR [esi+8], edx
  000ad	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000b2	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  000b5	8b 54 24 18	 mov	 edx, DWORD PTR _nItemCount$[esp+8]
  000b9	89 11		 mov	 DWORD PTR [ecx], edx
  000bb	01 5e 08	 add	 DWORD PTR [esi+8], ebx
$L308076:
  000be	5f		 pop	 edi
  000bf	5e		 pop	 esi
  000c0	5b		 pop	 ebx
$L308071:

; 7743 : 	}
; 7744 : }

  000c1	c2 0c 00	 ret	 12			; 0000000cH
?AddAlphabetResult@CUser@@QAEXHKH@Z ENDP		; CUser::AddAlphabetResult
_TEXT	ENDS
PUBLIC	?AddFiveSystemOpenWnd@CUser@@QAEXHHH@Z		; CUser::AddFiveSystemOpenWnd
; Function compile flags: /Ogty
;	COMDAT ?AddFiveSystemOpenWnd@CUser@@QAEXHHH@Z
_TEXT	SEGMENT
_nBetMinPenya$ = 8					; size = 4
_nBetMaxPenya$ = 12					; size = 4
_nMultiple$ = 16					; size = 4
?AddFiveSystemOpenWnd@CUser@@QAEXHHH@Z PROC NEAR	; CUser::AddFiveSystemOpenWnd, COMDAT
; _this$ = ecx

; 7748 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	0f 85 ae 00 00
	00		 jne	 $L308122

; 7749 : 	
; 7750 : 	m_Snapshot.cb++;

  0000a	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  00011	53		 push	 ebx
  00012	56		 push	 esi
  00013	57		 push	 edi

; 7751 : 	m_Snapshot.ar << GetId();

  00014	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  0001a	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  00020	bb 04 00 00 00	 mov	 ebx, 4
  00025	53		 push	 ebx
  00026	8b ce		 mov	 ecx, esi
  00028	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0002d	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00030	89 38		 mov	 DWORD PTR [eax], edi
  00032	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00035	03 d3		 add	 edx, ebx

; 7752 : 	m_Snapshot.ar << SNAPSHOTTYPE_MINIGAME;

  00037	6a 02		 push	 2
  00039	8b ce		 mov	 ecx, esi
  0003b	89 56 08	 mov	 DWORD PTR [esi+8], edx
  0003e	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00043	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00046	66 c7 01 e8 00	 mov	 WORD PTR [ecx], 232	; 000000e8H
  0004b	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0004e	83 c0 02	 add	 eax, 2

; 7753 : 	m_Snapshot.ar << MINIGAME_FIVESYSTEM_OPENWND;

  00051	6a 01		 push	 1
  00053	8b ce		 mov	 ecx, esi
  00055	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00058	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0005d	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00060	c6 02 06	 mov	 BYTE PTR [edx], 6
  00063	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00066	42		 inc	 edx

; 7754 : 	
; 7755 : 	m_Snapshot.ar << nBetMinPenya;

  00067	53		 push	 ebx
  00068	8b ce		 mov	 ecx, esi
  0006a	89 56 08	 mov	 DWORD PTR [esi+8], edx
  0006d	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00072	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00075	8b 4c 24 10	 mov	 ecx, DWORD PTR _nBetMinPenya$[esp+8]
  00079	89 08		 mov	 DWORD PTR [eax], ecx
  0007b	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0007e	03 c3		 add	 eax, ebx

; 7756 : 	m_Snapshot.ar << nBetMaxPenya;

  00080	53		 push	 ebx
  00081	8b ce		 mov	 ecx, esi
  00083	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00086	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0008b	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0008e	8b 44 24 14	 mov	 eax, DWORD PTR _nBetMaxPenya$[esp+8]
  00092	89 02		 mov	 DWORD PTR [edx], eax
  00094	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00097	03 d3		 add	 edx, ebx

; 7757 : 	m_Snapshot.ar << nMultiple;

  00099	53		 push	 ebx
  0009a	8b ce		 mov	 ecx, esi
  0009c	89 56 08	 mov	 DWORD PTR [esi+8], edx
  0009f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000a4	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  000a7	8b 54 24 18	 mov	 edx, DWORD PTR _nMultiple$[esp+8]
  000ab	89 11		 mov	 DWORD PTR [ecx], edx
  000ad	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000b0	03 c3		 add	 eax, ebx
  000b2	5f		 pop	 edi
  000b3	89 46 08	 mov	 DWORD PTR [esi+8], eax
  000b6	5e		 pop	 esi
  000b7	5b		 pop	 ebx
$L308122:

; 7758 : }

  000b8	c2 0c 00	 ret	 12			; 0000000cH
?AddFiveSystemOpenWnd@CUser@@QAEXHHH@Z ENDP		; CUser::AddFiveSystemOpenWnd
_TEXT	ENDS
PUBLIC	?AddFiveSystemResult@CUser@@QAEXHHH@Z		; CUser::AddFiveSystemResult
; Function compile flags: /Ogty
;	COMDAT ?AddFiveSystemResult@CUser@@QAEXHHH@Z
_TEXT	SEGMENT
_nResult$ = 8						; size = 4
_nGetPenya$ = 12					; size = 4
_nBetNum$ = 16						; size = 4
?AddFiveSystemResult@CUser@@QAEXHHH@Z PROC NEAR		; CUser::AddFiveSystemResult, COMDAT
; _this$ = ecx

; 7762 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	0f 85 b6 00 00
	00		 jne	 $L308162

; 7763 : 	
; 7764 : 	m_Snapshot.cb++;

  0000a	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  00011	56		 push	 esi
  00012	57		 push	 edi

; 7765 : 	m_Snapshot.ar << GetId();

  00013	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  00019	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  0001f	6a 04		 push	 4
  00021	8b ce		 mov	 ecx, esi
  00023	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00028	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0002b	89 38		 mov	 DWORD PTR [eax], edi
  0002d	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  00030	83 c7 04	 add	 edi, 4

; 7766 : 	m_Snapshot.ar << SNAPSHOTTYPE_MINIGAME;

  00033	6a 02		 push	 2
  00035	8b ce		 mov	 ecx, esi
  00037	89 7e 08	 mov	 DWORD PTR [esi+8], edi
  0003a	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003f	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00042	66 c7 01 e8 00	 mov	 WORD PTR [ecx], 232	; 000000e8H
  00047	83 46 08 02	 add	 DWORD PTR [esi+8], 2

; 7767 : 	m_Snapshot.ar << MINIGAME_FIVESYSTEM_RESULT;

  0004b	6a 01		 push	 1
  0004d	8b ce		 mov	 ecx, esi
  0004f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00054	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00057	c6 02 07	 mov	 BYTE PTR [edx], 7
  0005a	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  0005d	47		 inc	 edi

; 7768 : 	
; 7769 : 	m_Snapshot.ar << nResult;

  0005e	6a 04		 push	 4
  00060	8b ce		 mov	 ecx, esi
  00062	89 7e 08	 mov	 DWORD PTR [esi+8], edi
  00065	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0006a	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0006d	8b 7c 24 0c	 mov	 edi, DWORD PTR _nResult$[esp+4]
  00071	89 38		 mov	 DWORD PTR [eax], edi
  00073	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00076	83 c1 04	 add	 ecx, 4

; 7770 : 	if( ( nResult != CMiniGame::FIVESYSTEM_NOTENOUGH ) &&
; 7771 : 		( nResult != CMiniGame::FIVESYSTEM_OVERMAX ) &&
; 7772 : 		( nResult != CMiniGame::FIVESYSTEM_FAILED ) )

  00079	81 ff e7 03 00
	00		 cmp	 edi, 999		; 000003e7H
  0007f	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  00082	74 1c		 je	 SHORT $L284847
  00084	81 ff e6 03 00
	00		 cmp	 edi, 998		; 000003e6H
  0008a	74 14		 je	 SHORT $L284847
  0008c	81 ff e5 03 00
	00		 cmp	 edi, 997		; 000003e5H
  00092	74 0c		 je	 SHORT $L284847

; 7773 : 		m_Snapshot.ar << nGetPenya;

  00094	8b 4c 24 10	 mov	 ecx, DWORD PTR _nGetPenya$[esp+4]
  00098	51		 push	 ecx
  00099	8b ce		 mov	 ecx, esi
  0009b	e8 00 00 00 00	 call	 ??6CAr@@QAEAAV0@H@Z	; CAr::operator<<
$L284847:

; 7774 : 	
; 7775 : 	if( nResult == CMiniGame::FIVESYSTEM_BETOK )

  000a0	81 ff e4 03 00
	00		 cmp	 edi, 996		; 000003e4H
  000a6	75 16		 jne	 SHORT $L308167

; 7776 : 		m_Snapshot.ar << nBetNum;

  000a8	6a 04		 push	 4
  000aa	8b ce		 mov	 ecx, esi
  000ac	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000b1	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  000b4	8b 44 24 14	 mov	 eax, DWORD PTR _nBetNum$[esp+4]
  000b8	89 02		 mov	 DWORD PTR [edx], eax
  000ba	83 46 08 04	 add	 DWORD PTR [esi+8], 4
$L308167:
  000be	5f		 pop	 edi
  000bf	5e		 pop	 esi
$L308162:

; 7777 : 	
; 7778 : }

  000c0	c2 0c 00	 ret	 12			; 0000000cH
?AddFiveSystemResult@CUser@@QAEXHHH@Z ENDP		; CUser::AddFiveSystemResult
_TEXT	ENDS
PUBLIC	?AddUltimateMakeItem@CUser@@QAEXH@Z		; CUser::AddUltimateMakeItem
; Function compile flags: /Ogty
;	COMDAT ?AddUltimateMakeItem@CUser@@QAEXH@Z
_TEXT	SEGMENT
_nResult$ = 8						; size = 4
?AddUltimateMakeItem@CUser@@QAEXH@Z PROC NEAR		; CUser::AddUltimateMakeItem, COMDAT
; _this$ = ecx

; 7784 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	75 79		 jne	 SHORT $L308194

; 7785 : 	
; 7786 : 	m_Snapshot.cb++;

  00006	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  0000d	56		 push	 esi
  0000e	57		 push	 edi

; 7787 : 	m_Snapshot.ar << GetId();

  0000f	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  00015	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  0001b	6a 04		 push	 4
  0001d	8b ce		 mov	 ecx, esi
  0001f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00024	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00027	89 38		 mov	 DWORD PTR [eax], edi
  00029	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0002c	83 c2 04	 add	 edx, 4

; 7788 : 	m_Snapshot.ar << SNAPSHOTTYPE_ULTIMATE;

  0002f	6a 02		 push	 2
  00031	8b ce		 mov	 ecx, esi
  00033	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00036	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003b	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003e	66 c7 01 00 01	 mov	 WORD PTR [ecx], 256	; 00000100H
  00043	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00046	83 c0 02	 add	 eax, 2

; 7789 : 	m_Snapshot.ar << ULTIMATE_MAKEITEM;

  00049	6a 01		 push	 1
  0004b	8b ce		 mov	 ecx, esi
  0004d	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00050	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00055	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00058	c6 02 01	 mov	 BYTE PTR [edx], 1
  0005b	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0005e	42		 inc	 edx

; 7790 : 	m_Snapshot.ar << nResult;

  0005f	6a 04		 push	 4
  00061	8b ce		 mov	 ecx, esi
  00063	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00066	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0006b	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0006e	8b 4c 24 0c	 mov	 ecx, DWORD PTR _nResult$[esp+4]
  00072	89 08		 mov	 DWORD PTR [eax], ecx
  00074	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00077	83 c0 04	 add	 eax, 4
  0007a	5f		 pop	 edi
  0007b	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0007e	5e		 pop	 esi
$L308194:

; 7791 : }

  0007f	c2 04 00	 ret	 4
?AddUltimateMakeItem@CUser@@QAEXH@Z ENDP		; CUser::AddUltimateMakeItem
_TEXT	ENDS
PUBLIC	?AddUltimateMakeGem@CUser@@QAEXHH@Z		; CUser::AddUltimateMakeGem
; Function compile flags: /Ogty
;	COMDAT ?AddUltimateMakeGem@CUser@@QAEXHH@Z
_TEXT	SEGMENT
_nResult$ = 8						; size = 4
_nNum$ = 12						; size = 4
?AddUltimateMakeGem@CUser@@QAEXHH@Z PROC NEAR		; CUser::AddUltimateMakeGem, COMDAT
; _this$ = ecx

; 7795 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	0f 85 94 00 00
	00		 jne	 $L308237

; 7796 : 	
; 7797 : 	m_Snapshot.cb++;

  0000a	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  00011	56		 push	 esi
  00012	57		 push	 edi

; 7798 : 	m_Snapshot.ar << GetId();

  00013	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  00019	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  0001f	6a 04		 push	 4
  00021	8b ce		 mov	 ecx, esi
  00023	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00028	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0002b	89 38		 mov	 DWORD PTR [eax], edi
  0002d	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00030	83 c0 04	 add	 eax, 4

; 7799 : 	m_Snapshot.ar << SNAPSHOTTYPE_ULTIMATE;

  00033	6a 02		 push	 2
  00035	8b ce		 mov	 ecx, esi
  00037	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0003a	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003f	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00042	66 c7 01 00 01	 mov	 WORD PTR [ecx], 256	; 00000100H
  00047	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0004a	83 c2 02	 add	 edx, 2

; 7800 : 	m_Snapshot.ar << ULTIMATE_MAKEGEM;

  0004d	6a 01		 push	 1
  0004f	8b ce		 mov	 ecx, esi
  00051	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00054	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00059	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0005c	c6 02 03	 mov	 BYTE PTR [edx], 3
  0005f	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00062	40		 inc	 eax

; 7801 : 	m_Snapshot.ar << nResult;

  00063	6a 04		 push	 4
  00065	8b ce		 mov	 ecx, esi
  00067	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0006a	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0006f	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00072	8b 4c 24 0c	 mov	 ecx, DWORD PTR _nResult$[esp+4]
  00076	89 08		 mov	 DWORD PTR [eax], ecx
  00078	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0007b	83 c2 04	 add	 edx, 4

; 7802 : 	m_Snapshot.ar << nNum;

  0007e	6a 04		 push	 4
  00080	8b ce		 mov	 ecx, esi
  00082	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00085	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0008a	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0008d	8b 44 24 10	 mov	 eax, DWORD PTR _nNum$[esp+4]
  00091	89 02		 mov	 DWORD PTR [edx], eax
  00093	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00096	83 c0 04	 add	 eax, 4
  00099	5f		 pop	 edi
  0009a	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0009d	5e		 pop	 esi
$L308237:

; 7803 : }

  0009e	c2 08 00	 ret	 8
?AddUltimateMakeGem@CUser@@QAEXHH@Z ENDP		; CUser::AddUltimateMakeGem
_TEXT	ENDS
PUBLIC	?AddUltimateWeapon@CUser@@QAEXEH@Z		; CUser::AddUltimateWeapon
; Function compile flags: /Ogty
;	COMDAT ?AddUltimateWeapon@CUser@@QAEXEH@Z
_TEXT	SEGMENT
_state$ = 8						; size = 1
_nResult$ = 12						; size = 4
?AddUltimateWeapon@CUser@@QAEXEH@Z PROC NEAR		; CUser::AddUltimateWeapon, COMDAT
; _this$ = ecx

; 7807 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	75 7c		 jne	 SHORT $L308268

; 7808 : 	
; 7809 : 	m_Snapshot.cb++;

  00006	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  0000d	56		 push	 esi
  0000e	57		 push	 edi

; 7810 : 	m_Snapshot.ar << GetId();

  0000f	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  00015	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  0001b	6a 04		 push	 4
  0001d	8b ce		 mov	 ecx, esi
  0001f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00024	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00027	89 38		 mov	 DWORD PTR [eax], edi
  00029	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0002c	83 c2 04	 add	 edx, 4

; 7811 : 	m_Snapshot.ar << SNAPSHOTTYPE_ULTIMATE;

  0002f	6a 02		 push	 2
  00031	8b ce		 mov	 ecx, esi
  00033	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00036	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003b	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003e	66 c7 01 00 01	 mov	 WORD PTR [ecx], 256	; 00000100H
  00043	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00046	83 c0 02	 add	 eax, 2

; 7812 : 	m_Snapshot.ar << state;

  00049	6a 01		 push	 1
  0004b	8b ce		 mov	 ecx, esi
  0004d	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00050	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00055	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00058	8a 44 24 0c	 mov	 al, BYTE PTR _state$[esp+4]
  0005c	88 02		 mov	 BYTE PTR [edx], al
  0005e	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00061	42		 inc	 edx

; 7813 : 	m_Snapshot.ar << nResult;

  00062	6a 04		 push	 4
  00064	8b ce		 mov	 ecx, esi
  00066	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00069	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0006e	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00071	8b 54 24 10	 mov	 edx, DWORD PTR _nResult$[esp+4]
  00075	89 11		 mov	 DWORD PTR [ecx], edx
  00077	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0007a	83 c0 04	 add	 eax, 4
  0007d	5f		 pop	 edi
  0007e	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00081	5e		 pop	 esi
$L308268:

; 7814 : }

  00082	c2 08 00	 ret	 8
?AddUltimateWeapon@CUser@@QAEXEH@Z ENDP			; CUser::AddUltimateWeapon
_TEXT	ENDS
PUBLIC	?AddExchangeResult@CUser@@QAEXEH@Z		; CUser::AddExchangeResult
; Function compile flags: /Ogty
;	COMDAT ?AddExchangeResult@CUser@@QAEXEH@Z
_TEXT	SEGMENT
_state$ = 8						; size = 1
_nResult$ = 12						; size = 4
?AddExchangeResult@CUser@@QAEXEH@Z PROC NEAR		; CUser::AddExchangeResult, COMDAT
; _this$ = ecx

; 7820 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	75 7c		 jne	 SHORT $L308299

; 7821 : 	
; 7822 : 	m_Snapshot.cb++;

  00006	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  0000d	56		 push	 esi
  0000e	57		 push	 edi

; 7823 : 	m_Snapshot.ar << GetId();

  0000f	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  00015	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  0001b	6a 04		 push	 4
  0001d	8b ce		 mov	 ecx, esi
  0001f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00024	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00027	89 38		 mov	 DWORD PTR [eax], edi
  00029	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0002c	83 c2 04	 add	 edx, 4

; 7824 : 	m_Snapshot.ar << SNAPSHOTTYPE_EXCHANGE;

  0002f	6a 02		 push	 2
  00031	8b ce		 mov	 ecx, esi
  00033	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00036	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003b	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003e	66 c7 01 01 01	 mov	 WORD PTR [ecx], 257	; 00000101H
  00043	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00046	83 c0 02	 add	 eax, 2

; 7825 : 	m_Snapshot.ar << state;

  00049	6a 01		 push	 1
  0004b	8b ce		 mov	 ecx, esi
  0004d	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00050	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00055	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00058	8a 44 24 0c	 mov	 al, BYTE PTR _state$[esp+4]
  0005c	88 02		 mov	 BYTE PTR [edx], al
  0005e	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00061	42		 inc	 edx

; 7826 : 	m_Snapshot.ar << nResult;

  00062	6a 04		 push	 4
  00064	8b ce		 mov	 ecx, esi
  00066	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00069	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0006e	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00071	8b 54 24 10	 mov	 edx, DWORD PTR _nResult$[esp+4]
  00075	89 11		 mov	 DWORD PTR [ecx], edx
  00077	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0007a	83 c0 04	 add	 eax, 4
  0007d	5f		 pop	 edi
  0007e	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00081	5e		 pop	 esi
$L308299:

; 7827 : }

  00082	c2 08 00	 ret	 8
?AddExchangeResult@CUser@@QAEXEH@Z ENDP			; CUser::AddExchangeResult
_TEXT	ENDS
PUBLIC	?AddRemoveAttribute@CUser@@QAEXH@Z		; CUser::AddRemoveAttribute
; Function compile flags: /Ogty
;	COMDAT ?AddRemoveAttribute@CUser@@QAEXH@Z
_TEXT	SEGMENT
_bSuccess$ = 8						; size = 4
?AddRemoveAttribute@CUser@@QAEXH@Z PROC NEAR		; CUser::AddRemoveAttribute, COMDAT
; _this$ = ecx

; 7833 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	75 63		 jne	 SHORT $L308326

; 7834 : 	
; 7835 : 	m_Snapshot.cb++;

  00006	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  0000d	56		 push	 esi
  0000e	57		 push	 edi

; 7836 : 	m_Snapshot.ar << GetId();

  0000f	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  00015	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  0001b	6a 04		 push	 4
  0001d	8b ce		 mov	 ecx, esi
  0001f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00024	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00027	89 38		 mov	 DWORD PTR [eax], edi
  00029	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0002c	83 c0 04	 add	 eax, 4

; 7837 : 	m_Snapshot.ar << SNAPSHOTTYPE_REMOVE_ATTRIBUTE;

  0002f	6a 02		 push	 2
  00031	8b ce		 mov	 ecx, esi
  00033	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00036	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003b	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003e	66 c7 01 22 01	 mov	 WORD PTR [ecx], 290	; 00000122H
  00043	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00046	83 c2 02	 add	 edx, 2

; 7838 : 	m_Snapshot.ar << bSuccess;

  00049	6a 04		 push	 4
  0004b	8b ce		 mov	 ecx, esi
  0004d	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00050	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00055	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00058	8b 44 24 0c	 mov	 eax, DWORD PTR _bSuccess$[esp+4]
  0005c	89 02		 mov	 DWORD PTR [edx], eax
  0005e	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00061	83 c0 04	 add	 eax, 4
  00064	5f		 pop	 edi
  00065	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00068	5e		 pop	 esi
$L308326:

; 7839 : }

  00069	c2 04 00	 ret	 4
?AddRemoveAttribute@CUser@@QAEXH@Z ENDP			; CUser::AddRemoveAttribute
_TEXT	ENDS
PUBLIC	?AddLegendSkillResult@CUser@@QAEXH@Z		; CUser::AddLegendSkillResult
; Function compile flags: /Ogty
;	COMDAT ?AddLegendSkillResult@CUser@@QAEXH@Z
_TEXT	SEGMENT
_nResult$ = 8						; size = 4
?AddLegendSkillResult@CUser@@QAEXH@Z PROC NEAR		; CUser::AddLegendSkillResult, COMDAT
; _this$ = ecx

; 7960 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	75 63		 jne	 SHORT $L308353

; 7961 : 	
; 7962 : 	m_Snapshot.cb++;

  00006	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  0000d	56		 push	 esi
  0000e	57		 push	 edi

; 7963 : 	m_Snapshot.ar << GetId();

  0000f	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  00015	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  0001b	6a 04		 push	 4
  0001d	8b ce		 mov	 ecx, esi
  0001f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00024	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00027	89 38		 mov	 DWORD PTR [eax], edi
  00029	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0002c	83 c0 04	 add	 eax, 4

; 7964 : 	m_Snapshot.ar << SNAPSHOTTYPE_LEGENDSKILLUP_RESULT;

  0002f	6a 02		 push	 2
  00031	8b ce		 mov	 ecx, esi
  00033	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00036	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003b	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003e	66 c7 01 20 01	 mov	 WORD PTR [ecx], 288	; 00000120H
  00043	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00046	83 c2 02	 add	 edx, 2

; 7965 : //	m_Snapshot.ar << LEGENDSKILL_RESULT;	
; 7966 : 	m_Snapshot.ar << nResult;	

  00049	6a 04		 push	 4
  0004b	8b ce		 mov	 ecx, esi
  0004d	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00050	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00055	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00058	8b 44 24 0c	 mov	 eax, DWORD PTR _nResult$[esp+4]
  0005c	89 02		 mov	 DWORD PTR [edx], eax
  0005e	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00061	83 c0 04	 add	 eax, 4
  00064	5f		 pop	 edi
  00065	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00068	5e		 pop	 esi
$L308353:

; 7967 : }

  00069	c2 04 00	 ret	 4
?AddLegendSkillResult@CUser@@QAEXH@Z ENDP		; CUser::AddLegendSkillResult
_TEXT	ENDS
PUBLIC	?AddGuildBankLogView@CUser@@QAEXEFPBU__GUILDBANKLOG_ENTRY@@@Z ; CUser::AddGuildBankLogView
; Function compile flags: /Ogty
;	COMDAT ?AddGuildBankLogView@CUser@@QAEXEFPBU__GUILDBANKLOG_ENTRY@@@Z
_TEXT	SEGMENT
_byListType$ = 8					; size = 1
tv91 = 12						; size = 4
_nLogCount$ = 12					; size = 2
_logs$ = 16						; size = 4
?AddGuildBankLogView@CUser@@QAEXEFPBU__GUILDBANKLOG_ENTRY@@@Z PROC NEAR ; CUser::AddGuildBankLogView, COMDAT
; _this$ = ecx

; 7990 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	0f 85 12 01 00
	00		 jne	 $L285106

; 7991 : 	
; 7992 : 	m_Snapshot.cb++;

  0000a	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  00011	53		 push	 ebx
  00012	56		 push	 esi
  00013	57		 push	 edi

; 7993 : 	m_Snapshot.ar << GetId();

  00014	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  0001a	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  00020	bb 04 00 00 00	 mov	 ebx, 4
  00025	53		 push	 ebx
  00026	8b ce		 mov	 ecx, esi
  00028	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0002d	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00030	89 38		 mov	 DWORD PTR [eax], edi
  00032	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00035	03 c3		 add	 eax, ebx

; 7994 : 	m_Snapshot.ar << SNAPSHOTTYPE_GUILDLOG_VIEW;

  00037	bf 02 00 00 00	 mov	 edi, 2
  0003c	57		 push	 edi
  0003d	8b ce		 mov	 ecx, esi
  0003f	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00042	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00047	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0004a	66 c7 01 42 01	 mov	 WORD PTR [ecx], 322	; 00000142H
  0004f	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00052	03 d7		 add	 edx, edi

; 7995 : 	m_Snapshot.ar << byListType;

  00054	6a 01		 push	 1
  00056	8b ce		 mov	 ecx, esi
  00058	89 56 08	 mov	 DWORD PTR [esi+8], edx
  0005b	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00060	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00063	8a 44 24 10	 mov	 al, BYTE PTR _byListType$[esp+8]
  00067	88 02		 mov	 BYTE PTR [edx], al
  00069	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0006c	40		 inc	 eax

; 7996 : 	m_Snapshot.ar << nLogCount;

  0006d	57		 push	 edi
  0006e	8b ce		 mov	 ecx, esi
  00070	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00073	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00078	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0007b	66 8b 44 24 14	 mov	 ax, WORD PTR _nLogCount$[esp+8]
  00080	66 89 01	 mov	 WORD PTR [ecx], ax
  00083	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00086	03 d7		 add	 edx, edi

; 7997 : 	
; 7998 : 	for( short i=0; i<nLogCount; ++i )

  00088	66 85 c0	 test	 ax, ax
  0008b	89 56 08	 mov	 DWORD PTR [esi+8], edx
  0008e	0f 8e 85 00 00
	00		 jle	 $L308408
  00094	8b 7c 24 18	 mov	 edi, DWORD PTR _logs$[esp+8]
  00098	0f b7 d0	 movzx	 edx, ax
  0009b	83 c7 30	 add	 edi, 48			; 00000030H
  0009e	89 54 24 14	 mov	 DWORD PTR tv91[esp+8], edx
  000a2	55		 push	 ebp
$L285104:

; 7999 : 	{
; 8000 : 		TRACE("GuildBankLogView:%s %d %d %d %d\n", logs[i].szPlayer, logs[i].nDate,logs[i].nItemID,logs[i].nItemAbilityOption,logs[i].nItemCount);
; 8001 : 		m_Snapshot.ar.WriteString( logs[i].szPlayer );				//  

  000a3	8d 47 d0	 lea	 eax, DWORD PTR [edi-48]
  000a6	50		 push	 eax
  000a7	8b ce		 mov	 ecx, esi
  000a9	e8 00 00 00 00	 call	 ?WriteString@CAr@@QAEXPBD@Z ; CAr::WriteString

; 8002 : 		m_Snapshot.ar << logs[i].nDate;					//  

  000ae	8b 6f fc	 mov	 ebp, DWORD PTR [edi-4]
  000b1	53		 push	 ebx
  000b2	8b ce		 mov	 ecx, esi
  000b4	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000b9	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  000bc	89 29		 mov	 DWORD PTR [ecx], ebp
  000be	01 5e 08	 add	 DWORD PTR [esi+8], ebx

; 8003 : 		m_Snapshot.ar << logs[i].nItemID;					//  nItemAbilityOption

  000c1	8b 2f		 mov	 ebp, DWORD PTR [edi]
  000c3	53		 push	 ebx
  000c4	8b ce		 mov	 ecx, esi
  000c6	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000cb	8b 56 08	 mov	 edx, DWORD PTR [esi+8]

; 8004 : 		if( byListType == GI_LOG_VIEW_ITEM_ADD || byListType == GI_LOG_VIEW_ITEM_REMOVE )

  000ce	8a 44 24 14	 mov	 al, BYTE PTR _byListType$[esp+12]
  000d2	89 2a		 mov	 DWORD PTR [edx], ebp
  000d4	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  000d7	03 d3		 add	 edx, ebx
  000d9	3c 01		 cmp	 al, 1
  000db	89 56 08	 mov	 DWORD PTR [esi+8], edx
  000de	74 04		 je	 SHORT $L285108
  000e0	3c 02		 cmp	 al, 2
  000e2	75 26		 jne	 SHORT $L285105
$L285108:

; 8005 : 		{
; 8006 : 			m_Snapshot.ar << logs[i].nItemAbilityOption;

  000e4	8b 6f 04	 mov	 ebp, DWORD PTR [edi+4]
  000e7	53		 push	 ebx
  000e8	8b ce		 mov	 ecx, esi
  000ea	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000ef	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000f2	89 28		 mov	 DWORD PTR [eax], ebp
  000f4	01 5e 08	 add	 DWORD PTR [esi+8], ebx

; 8007 : 			m_Snapshot.ar << logs[i].nItemCount;					//  

  000f7	8b 6f 08	 mov	 ebp, DWORD PTR [edi+8]
  000fa	53		 push	 ebx
  000fb	8b ce		 mov	 ecx, esi
  000fd	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00102	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00105	89 29		 mov	 DWORD PTR [ecx], ebp
  00107	01 5e 08	 add	 DWORD PTR [esi+8], ebx
$L285105:
  0010a	8b 44 24 18	 mov	 eax, DWORD PTR tv91[esp+12]
  0010e	83 c7 3c	 add	 edi, 60			; 0000003cH
  00111	48		 dec	 eax
  00112	89 44 24 18	 mov	 DWORD PTR tv91[esp+12], eax
  00116	75 8b		 jne	 SHORT $L285104
  00118	5d		 pop	 ebp
$L308408:
  00119	5f		 pop	 edi
  0011a	5e		 pop	 esi
  0011b	5b		 pop	 ebx
$L285106:

; 8008 : 		}
; 8009 : 	}
; 8010 : }

  0011c	c2 0c 00	 ret	 12			; 0000000cH
?AddGuildBankLogView@CUser@@QAEXEFPBU__GUILDBANKLOG_ENTRY@@@Z ENDP ; CUser::AddGuildBankLogView
_TEXT	ENDS
PUBLIC	?AddHonorListAck@CUser@@QAEXXZ			; CUser::AddHonorListAck
; Function compile flags: /Ogty
;	COMDAT ?AddHonorListAck@CUser@@QAEXXZ
_TEXT	SEGMENT
?AddHonorListAck@CUser@@QAEXXZ PROC NEAR		; CUser::AddHonorListAck, COMDAT
; _this$ = ecx

; 8015 : {

  00000	57		 push	 edi
  00001	8b f9		 mov	 edi, ecx

; 8016 : 	if( IsDelete() )	return;

  00003	f6 47 04 01	 test	 BYTE PTR [edi+4], 1
  00007	75 6f		 jne	 SHORT $L285117

; 8017 : 
; 8018 : 	m_Snapshot.cb++;

  00009	66 ff 87 0c 57
	00 00		 inc	 WORD PTR [edi+22284]
  00010	53		 push	 ebx

; 8019 : 	m_Snapshot.ar << GetId();

  00011	8b 9f bc 01 00
	00		 mov	 ebx, DWORD PTR [edi+444]
  00017	55		 push	 ebp
  00018	56		 push	 esi
  00019	8d b7 f8 16 00
	00		 lea	 esi, DWORD PTR [edi+5880]
  0001f	6a 04		 push	 4
  00021	8b ce		 mov	 ecx, esi
  00023	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00028	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0002b	89 18		 mov	 DWORD PTR [eax], ebx
  0002d	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00030	83 c2 04	 add	 edx, 4

; 8020 : 	m_Snapshot.ar << SNAPSHOTTYPE_HONOR_LIST_ACK;

  00033	6a 02		 push	 2
  00035	8b ce		 mov	 ecx, esi
  00037	89 56 08	 mov	 DWORD PTR [esi+8], edx
  0003a	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003f	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00042	66 c7 01 00 93	 mov	 WORD PTR [ecx], 37632	; 00009300H
  00047	83 46 08 02	 add	 DWORD PTR [esi+8], 2
  0004b	81 c7 0c 09 00
	00		 add	 edi, 2316		; 0000090cH
  00051	bd 96 00 00 00	 mov	 ebp, 150		; 00000096H
$L285115:

; 8021 : 	
; 8022 : 	for( int i=0; i<MAX_HONOR_TITLE; ++i )
; 8023 : 	{
; 8024 : 		m_Snapshot.ar << m_aHonorTitle[i];

  00056	8b 1f		 mov	 ebx, DWORD PTR [edi]
  00058	6a 04		 push	 4
  0005a	8b ce		 mov	 ecx, esi
  0005c	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00061	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00064	89 1a		 mov	 DWORD PTR [edx], ebx
  00066	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00069	83 c2 04	 add	 edx, 4
  0006c	83 c7 04	 add	 edi, 4
  0006f	4d		 dec	 ebp
  00070	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00073	75 e1		 jne	 SHORT $L285115
  00075	5e		 pop	 esi
  00076	5d		 pop	 ebp
  00077	5b		 pop	 ebx
$L285117:
  00078	5f		 pop	 edi

; 8025 : 	}
; 8026 : }

  00079	c3		 ret	 0
?AddHonorListAck@CUser@@QAEXXZ ENDP			; CUser::AddHonorListAck
_TEXT	ENDS
PUBLIC	?AddSealChar@CUser@@QAEXFPBU__SEALCHAR_ENTRY@@@Z ; CUser::AddSealChar
; Function compile flags: /Ogty
;	COMDAT ?AddSealChar@CUser@@QAEXFPBU__SEALCHAR_ENTRY@@@Z
_TEXT	SEGMENT
_nLogCount$ = 8						; size = 2
_seals$ = 12						; size = 4
?AddSealChar@CUser@@QAEXFPBU__SEALCHAR_ENTRY@@@Z PROC NEAR ; CUser::AddSealChar, COMDAT
; _this$ = ecx

; 8032 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	0f 85 b9 00 00
	00		 jne	 $L285128

; 8033 : 	
; 8034 : 	m_Snapshot.cb++;

  0000a	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  00011	55		 push	 ebp
  00012	56		 push	 esi
  00013	57		 push	 edi

; 8035 : 	m_Snapshot.ar << GetId();

  00014	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  0001a	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  00020	6a 04		 push	 4
  00022	8b ce		 mov	 ecx, esi
  00024	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00029	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0002c	89 38		 mov	 DWORD PTR [eax], edi
  0002e	83 46 08 04	 add	 DWORD PTR [esi+8], 4

; 8036 : 	m_Snapshot.ar << SNAPSHOTTYPE_SEALCHAR_REQ;

  00032	bf 02 00 00 00	 mov	 edi, 2
  00037	57		 push	 edi
  00038	8b ce		 mov	 ecx, esi
  0003a	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003f	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00042	66 c7 01 44 01	 mov	 WORD PTR [ecx], 324	; 00000144H
  00047	8b 6e 08	 mov	 ebp, DWORD PTR [esi+8]
  0004a	03 ef		 add	 ebp, edi

; 8037 : 	m_Snapshot.ar << nLogCount;

  0004c	57		 push	 edi
  0004d	8b ce		 mov	 ecx, esi
  0004f	89 6e 08	 mov	 DWORD PTR [esi+8], ebp
  00052	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00057	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0005a	66 8b 44 24 10	 mov	 ax, WORD PTR _nLogCount$[esp+8]
  0005f	66 89 02	 mov	 WORD PTR [edx], ax
  00062	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00065	03 d7		 add	 edx, edi

; 8038 : 	
; 8039 : 	for( short i=0; i<nLogCount; ++i )

  00067	66 85 c0	 test	 ax, ax
  0006a	89 56 08	 mov	 DWORD PTR [esi+8], edx
  0006d	7e 51		 jle	 SHORT $L308481
  0006f	8b 7c 24 14	 mov	 edi, DWORD PTR _seals$[esp+8]
  00073	83 c7 2c	 add	 edi, 44			; 0000002cH
  00076	0f b7 e8	 movzx	 ebp, ax
  00079	53		 push	 ebx
  0007a	8d 9b 00 00 00
	00		 npad	 6
$L285126:

; 8040 : 	{
; 8041 : 		TRACE("AddSealChar:%s %d %d \n", seals[i].szPlayer, seals[i].nPlayerSlot,seals[i].idPlayer);
; 8042 : 		m_Snapshot.ar << seals[i].nPlayerSlot;					// 

  00080	8b 5f 04	 mov	 ebx, DWORD PTR [edi+4]
  00083	6a 04		 push	 4
  00085	8b ce		 mov	 ecx, esi
  00087	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0008c	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0008f	89 18		 mov	 DWORD PTR [eax], ebx
  00091	83 46 08 04	 add	 DWORD PTR [esi+8], 4

; 8043 : 		m_Snapshot.ar << seals[i].idPlayer;					//  

  00095	8b 1f		 mov	 ebx, DWORD PTR [edi]
  00097	6a 04		 push	 4
  00099	8b ce		 mov	 ecx, esi
  0009b	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000a0	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  000a3	89 19		 mov	 DWORD PTR [ecx], ebx
  000a5	8b 46 08	 mov	 eax, DWORD PTR [esi+8]

; 8044 : 		m_Snapshot.ar.WriteString( seals[i].szPlayer );				//  

  000a8	8d 57 d4	 lea	 edx, DWORD PTR [edi-44]
  000ab	83 c0 04	 add	 eax, 4
  000ae	52		 push	 edx
  000af	8b ce		 mov	 ecx, esi
  000b1	89 46 08	 mov	 DWORD PTR [esi+8], eax
  000b4	e8 00 00 00 00	 call	 ?WriteString@CAr@@QAEXPBD@Z ; CAr::WriteString
  000b9	83 c7 34	 add	 edi, 52			; 00000034H
  000bc	4d		 dec	 ebp
  000bd	75 c1		 jne	 SHORT $L285126
  000bf	5b		 pop	 ebx
$L308481:
  000c0	5f		 pop	 edi
  000c1	5e		 pop	 esi
  000c2	5d		 pop	 ebp
$L285128:

; 8045 : 	}
; 8046 : }

  000c3	c2 08 00	 ret	 8
?AddSealChar@CUser@@QAEXFPBU__SEALCHAR_ENTRY@@@Z ENDP	; CUser::AddSealChar
_TEXT	ENDS
PUBLIC	?AddCoupon@CUser@@QAEXH@Z			; CUser::AddCoupon
; Function compile flags: /Ogty
;	COMDAT ?AddCoupon@CUser@@QAEXH@Z
_TEXT	SEGMENT
_nCoupon$ = 8						; size = 4
?AddCoupon@CUser@@QAEXH@Z PROC NEAR			; CUser::AddCoupon, COMDAT
; _this$ = ecx

; 8060 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	75 63		 jne	 SHORT $L308510

; 8061 : 	m_Snapshot.cb++;

  00006	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  0000d	56		 push	 esi
  0000e	57		 push	 edi

; 8062 : 	m_Snapshot.ar << GetId();

  0000f	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  00015	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  0001b	6a 04		 push	 4
  0001d	8b ce		 mov	 ecx, esi
  0001f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00024	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00027	89 38		 mov	 DWORD PTR [eax], edi
  00029	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0002c	83 c0 04	 add	 eax, 4

; 8063 : 	m_Snapshot.ar << SNAPSHOTTYPE_EVENT_COUPON;

  0002f	6a 02		 push	 2
  00031	8b ce		 mov	 ecx, esi
  00033	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00036	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003b	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003e	66 c7 01 46 01	 mov	 WORD PTR [ecx], 326	; 00000146H
  00043	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00046	83 c2 02	 add	 edx, 2

; 8064 : 	m_Snapshot.ar << nCoupon;

  00049	6a 04		 push	 4
  0004b	8b ce		 mov	 ecx, esi
  0004d	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00050	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00055	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00058	8b 44 24 0c	 mov	 eax, DWORD PTR _nCoupon$[esp+4]
  0005c	89 02		 mov	 DWORD PTR [edx], eax
  0005e	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00061	83 c0 04	 add	 eax, 4
  00064	5f		 pop	 edi
  00065	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00068	5e		 pop	 esi
$L308510:

; 8065 : }

  00069	c2 04 00	 ret	 4
?AddCoupon@CUser@@QAEXH@Z ENDP				; CUser::AddCoupon
_TEXT	ENDS
PUBLIC	?AddSecretRoomMngState@CUser@@QAEXHK@Z		; CUser::AddSecretRoomMngState
; Function compile flags: /Ogty
;	COMDAT ?AddSecretRoomMngState@CUser@@QAEXHK@Z
_TEXT	SEGMENT
_nState$ = 8						; size = 4
_dwRemainTime$ = 12					; size = 4
?AddSecretRoomMngState@CUser@@QAEXHK@Z PROC NEAR	; CUser::AddSecretRoomMngState, COMDAT
; _this$ = ecx

; 8071 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	75 7e		 jne	 SHORT $L308541

; 8072 : 	m_Snapshot.cb++;

  00006	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  0000d	56		 push	 esi
  0000e	57		 push	 edi

; 8073 : 	m_Snapshot.ar << GetId();

  0000f	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  00015	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  0001b	6a 04		 push	 4
  0001d	8b ce		 mov	 ecx, esi
  0001f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00024	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00027	89 38		 mov	 DWORD PTR [eax], edi
  00029	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0002c	83 c2 04	 add	 edx, 4

; 8074 : 	m_Snapshot.ar << SNAPSHOTTYPE_SECRETROOM_MNG_STATE;

  0002f	6a 02		 push	 2
  00031	8b ce		 mov	 ecx, esi
  00033	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00036	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003b	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003e	66 c7 01 00 03	 mov	 WORD PTR [ecx], 768	; 00000300H
  00043	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00046	83 c0 02	 add	 eax, 2

; 8075 : 	m_Snapshot.ar << nState;

  00049	6a 04		 push	 4
  0004b	8b ce		 mov	 ecx, esi
  0004d	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00050	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00055	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00058	8b 44 24 0c	 mov	 eax, DWORD PTR _nState$[esp+4]
  0005c	89 02		 mov	 DWORD PTR [edx], eax
  0005e	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00061	83 c2 04	 add	 edx, 4

; 8076 : 	m_Snapshot.ar << dwRemainTime;

  00064	6a 04		 push	 4
  00066	8b ce		 mov	 ecx, esi
  00068	89 56 08	 mov	 DWORD PTR [esi+8], edx
  0006b	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00070	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00073	8b 54 24 10	 mov	 edx, DWORD PTR _dwRemainTime$[esp+4]
  00077	89 11		 mov	 DWORD PTR [ecx], edx
  00079	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0007c	83 c0 04	 add	 eax, 4
  0007f	5f		 pop	 edi
  00080	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00083	5e		 pop	 esi
$L308541:

; 8077 : }

  00084	c2 08 00	 ret	 8
?AddSecretRoomMngState@CUser@@QAEXHK@Z ENDP		; CUser::AddSecretRoomMngState
_TEXT	ENDS
PUBLIC	?AddSecretRoomTenderOpenWnd@CUser@@QAEXH@Z	; CUser::AddSecretRoomTenderOpenWnd
EXTRN	?GetInstance@CSecretRoomMng@@SAPAV1@XZ:NEAR	; CSecretRoomMng::GetInstance
; Function compile flags: /Ogty
;	COMDAT ?AddSecretRoomTenderOpenWnd@CUser@@QAEXH@Z
_TEXT	SEGMENT
_nTenderPenya$ = 8					; size = 4
?AddSecretRoomTenderOpenWnd@CUser@@QAEXH@Z PROC NEAR	; CUser::AddSecretRoomTenderOpenWnd, COMDAT
; _this$ = ecx

; 8141 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	75 7d		 jne	 SHORT $L308578

; 8142 : 	m_Snapshot.cb++;

  00006	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  0000d	56		 push	 esi
  0000e	57		 push	 edi

; 8143 : 	m_Snapshot.ar << GetId();

  0000f	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  00015	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  0001b	6a 04		 push	 4
  0001d	8b ce		 mov	 ecx, esi
  0001f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00024	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00027	89 38		 mov	 DWORD PTR [eax], edi
  00029	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  0002c	83 c7 04	 add	 edi, 4

; 8144 : 	m_Snapshot.ar << SNAPSHOTTYPE_SECRETROOM_TENDEROPENWND;

  0002f	6a 02		 push	 2
  00031	8b ce		 mov	 ecx, esi
  00033	89 7e 08	 mov	 DWORD PTR [esi+8], edi
  00036	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003b	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003e	66 c7 01 02 03	 mov	 WORD PTR [ecx], 770	; 00000302H
  00043	83 46 08 02	 add	 DWORD PTR [esi+8], 2

; 8145 : 	m_Snapshot.ar << CSecretRoomMng::GetInstance()->m_nMinPenya;

  00047	e8 00 00 00 00	 call	 ?GetInstance@CSecretRoomMng@@SAPAV1@XZ ; CSecretRoomMng::GetInstance
  0004c	8b 78 18	 mov	 edi, DWORD PTR [eax+24]
  0004f	6a 04		 push	 4
  00051	8b ce		 mov	 ecx, esi
  00053	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00058	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0005b	89 3a		 mov	 DWORD PTR [edx], edi
  0005d	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00060	83 c2 04	 add	 edx, 4

; 8146 : 	m_Snapshot.ar << nTenderPenya;

  00063	6a 04		 push	 4
  00065	8b ce		 mov	 ecx, esi
  00067	89 56 08	 mov	 DWORD PTR [esi+8], edx
  0006a	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0006f	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00072	8b 4c 24 0c	 mov	 ecx, DWORD PTR _nTenderPenya$[esp+4]
  00076	89 08		 mov	 DWORD PTR [eax], ecx
  00078	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0007b	83 c0 04	 add	 eax, 4
  0007e	5f		 pop	 edi
  0007f	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00082	5e		 pop	 esi
$L308578:

; 8147 : }

  00083	c2 04 00	 ret	 4
?AddSecretRoomTenderOpenWnd@CUser@@QAEXH@Z ENDP		; CUser::AddSecretRoomTenderOpenWnd
_TEXT	ENDS
PUBLIC	?AddLord@CUser@@QAEXXZ				; CUser::AddLord
EXTRN	?Serialize@CLord@@QAEXAAVCAr@@@Z:NEAR		; CLord::Serialize
EXTRN	?Instance@CSLord@@SAPAV1@XZ:NEAR		; CSLord::Instance
; Function compile flags: /Ogty
;	COMDAT ?AddLord@CUser@@QAEXXZ
_TEXT	SEGMENT
?AddLord@CUser@@QAEXXZ PROC NEAR			; CUser::AddLord, COMDAT
; _this$ = ecx

; 8181 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	75 51		 jne	 SHORT $L285232

; 8182 : 	m_Snapshot.cb++;

  00006	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  0000d	56		 push	 esi

; 8183 : 	m_Snapshot.ar << NULL_ID;

  0000e	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  00014	6a 04		 push	 4
  00016	8b ce		 mov	 ecx, esi
  00018	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0001d	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00020	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [eax], -1
  00026	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00029	83 c0 04	 add	 eax, 4

; 8184 : 	m_Snapshot.ar << SNAPSHOTTYPE_LORD;

  0002c	6a 02		 push	 2
  0002e	8b ce		 mov	 ecx, esi
  00030	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00033	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00038	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003b	66 c7 01 06 8f	 mov	 WORD PTR [ecx], 36614	; 00008f06H
  00040	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00043	83 c1 02	 add	 ecx, 2

; 8185 : 	CSLord::Instance()->Serialize( m_Snapshot.ar );

  00046	56		 push	 esi
  00047	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  0004a	e8 00 00 00 00	 call	 ?Instance@CSLord@@SAPAV1@XZ ; CSLord::Instance
  0004f	8b c8		 mov	 ecx, eax
  00051	e8 00 00 00 00	 call	 ?Serialize@CLord@@QAEXAAVCAr@@@Z ; CLord::Serialize
  00056	5e		 pop	 esi
$L285232:

; 8186 : }

  00057	c3		 ret	 0
?AddLord@CUser@@QAEXXZ ENDP				; CUser::AddLord
_TEXT	ENDS
PUBLIC	?AddLordSkillTick@CUser@@QAEXPAVCLordSkill@@@Z	; CUser::AddLordSkillTick
EXTRN	?SerializeTick@CLordSkill@@QAEXAAVCAr@@@Z:NEAR	; CLordSkill::SerializeTick
; Function compile flags: /Ogty
;	COMDAT ?AddLordSkillTick@CUser@@QAEXPAVCLordSkill@@@Z
_TEXT	SEGMENT
_pSkills$ = 8						; size = 4
?AddLordSkillTick@CUser@@QAEXPAVCLordSkill@@@Z PROC NEAR ; CUser::AddLordSkillTick, COMDAT
; _this$ = ecx

; 8199 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	75 49		 jne	 SHORT $L285244

; 8200 : 	m_Snapshot.cb++;

  00006	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  0000d	56		 push	 esi

; 8201 : 	m_Snapshot.ar << NULL_ID;

  0000e	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  00014	6a 04		 push	 4
  00016	8b ce		 mov	 ecx, esi
  00018	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0001d	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00020	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [eax], -1
  00026	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00029	83 c0 04	 add	 eax, 4

; 8202 : 	m_Snapshot.ar << SNAPSHOTTYPE_LORD_SKILL_TICK;

  0002c	6a 02		 push	 2
  0002e	8b ce		 mov	 ecx, esi
  00030	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00033	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00038	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003b	66 c7 01 0a 8f	 mov	 WORD PTR [ecx], 36618	; 00008f0aH
  00040	83 46 08 02	 add	 DWORD PTR [esi+8], 2

; 8203 : 	pSkills->SerializeTick( m_Snapshot.ar );	

  00044	8b 4c 24 08	 mov	 ecx, DWORD PTR _pSkills$[esp]
  00048	56		 push	 esi
  00049	e8 00 00 00 00	 call	 ?SerializeTick@CLordSkill@@QAEXAAVCAr@@@Z ; CLordSkill::SerializeTick
  0004e	5e		 pop	 esi
$L285244:

; 8204 : }

  0004f	c2 04 00	 ret	 4
?AddLordSkillTick@CUser@@QAEXPAVCLordSkill@@@Z ENDP	; CUser::AddLordSkillTick
_TEXT	ENDS
PUBLIC	?AddSetTutorialState@CUser@@QAEXXZ		; CUser::AddSetTutorialState
; Function compile flags: /Ogty
;	COMDAT ?AddSetTutorialState@CUser@@QAEXXZ
_TEXT	SEGMENT
?AddSetTutorialState@CUser@@QAEXXZ PROC NEAR		; CUser::AddSetTutorialState, COMDAT
; _this$ = ecx

; 8235 : {

  00000	57		 push	 edi
  00001	8b f9		 mov	 edi, ecx

; 8236 : 	if( IsDelete() )	return;

  00003	f6 47 04 01	 test	 BYTE PTR [edi+4], 1
  00007	75 52		 jne	 SHORT $L308651

; 8237 : 	m_Snapshot.cb++;

  00009	66 ff 87 0c 57
	00 00		 inc	 WORD PTR [edi+22284]
  00010	56		 push	 esi

; 8238 : 	m_Snapshot.ar << NULL_ID;

  00011	8d b7 f8 16 00
	00		 lea	 esi, DWORD PTR [edi+5880]
  00017	6a 04		 push	 4
  00019	8b ce		 mov	 ecx, esi
  0001b	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00020	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00023	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [eax], -1
  00029	83 46 08 04	 add	 DWORD PTR [esi+8], 4

; 8239 : 	m_Snapshot.ar << SNAPSHOTTYPE_SET_TUTORIAL_STATE;

  0002d	6a 02		 push	 2
  0002f	8b ce		 mov	 ecx, esi
  00031	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00036	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00039	66 c7 01 0c 8f	 mov	 WORD PTR [ecx], 36620	; 00008f0cH
  0003e	83 46 08 02	 add	 DWORD PTR [esi+8], 2

; 8240 : 	m_Snapshot.ar << GetTutorialState();

  00042	8b bf f8 05 00
	00		 mov	 edi, DWORD PTR [edi+1528]
  00048	6a 04		 push	 4
  0004a	8b ce		 mov	 ecx, esi
  0004c	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00051	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00054	89 3a		 mov	 DWORD PTR [edx], edi
  00056	83 46 08 04	 add	 DWORD PTR [esi+8], 4
  0005a	5e		 pop	 esi
$L308651:
  0005b	5f		 pop	 edi

; 8241 : }

  0005c	c3		 ret	 0
?AddSetTutorialState@CUser@@QAEXXZ ENDP			; CUser::AddSetTutorialState
_TEXT	ENDS
PUBLIC	?AddTaxSetTaxRateOpenWnd@CUser@@QAEXE@Z		; CUser::AddTaxSetTaxRateOpenWnd
; Function compile flags: /Ogty
;	COMDAT ?AddTaxSetTaxRateOpenWnd@CUser@@QAEXE@Z
_TEXT	SEGMENT
_nCont$ = 8						; size = 1
?AddTaxSetTaxRateOpenWnd@CUser@@QAEXE@Z PROC NEAR	; CUser::AddTaxSetTaxRateOpenWnd, COMDAT
; _this$ = ecx

; 8367 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	0f 85 90 00 00
	00		 jne	 $L308692

; 8368 : 	m_Snapshot.cb++;

  0000a	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  00011	56		 push	 esi
  00012	57		 push	 edi

; 8369 : 	m_Snapshot.ar << GetId();

  00013	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  00019	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  0001f	6a 04		 push	 4
  00021	8b ce		 mov	 ecx, esi
  00023	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00028	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0002b	89 38		 mov	 DWORD PTR [eax], edi
  0002d	83 46 08 04	 add	 DWORD PTR [esi+8], 4

; 8370 : 	m_Snapshot.ar << SNAPSHOTTYPE_TAX_SETTAXRATE_OPENWND;

  00031	6a 02		 push	 2
  00033	8b ce		 mov	 ecx, esi
  00035	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003a	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003d	66 c7 01 01 04	 mov	 WORD PTR [ecx], 1025	; 00000401H
  00042	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  00045	83 c7 02	 add	 edi, 2

; 8371 : 	m_Snapshot.ar << nCont;

  00048	6a 01		 push	 1
  0004a	8b ce		 mov	 ecx, esi
  0004c	89 7e 08	 mov	 DWORD PTR [esi+8], edi
  0004f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00054	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00057	8a 44 24 0c	 mov	 al, BYTE PTR _nCont$[esp+4]
  0005b	88 02		 mov	 BYTE PTR [edx], al
  0005d	ff 46 08	 inc	 DWORD PTR [esi+8]

; 8372 : 	m_Snapshot.ar << CTax::GetInstance()->m_nMinTaxRate << CTax::GetInstance()->m_nMaxTaxRate;

  00060	e8 00 00 00 00	 call	 ?GetInstance@CTax@@SAPAV1@XZ ; CTax::GetInstance
  00065	8b 38		 mov	 edi, DWORD PTR [eax]
  00067	6a 04		 push	 4
  00069	8b ce		 mov	 ecx, esi
  0006b	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00070	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00073	89 39		 mov	 DWORD PTR [ecx], edi
  00075	83 46 08 04	 add	 DWORD PTR [esi+8], 4
  00079	e8 00 00 00 00	 call	 ?GetInstance@CTax@@SAPAV1@XZ ; CTax::GetInstance
  0007e	8b 78 04	 mov	 edi, DWORD PTR [eax+4]
  00081	6a 04		 push	 4
  00083	8b ce		 mov	 ecx, esi
  00085	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0008a	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0008d	89 3a		 mov	 DWORD PTR [edx], edi
  0008f	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00092	83 c0 04	 add	 eax, 4
  00095	5f		 pop	 edi
  00096	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00099	5e		 pop	 esi
$L308692:

; 8373 : }

  0009a	c2 04 00	 ret	 4
?AddTaxSetTaxRateOpenWnd@CUser@@QAEXE@Z ENDP		; CUser::AddTaxSetTaxRateOpenWnd
_TEXT	ENDS
PUBLIC	?AddRainbowRaceApplicationOpenWnd@CUser@@QAEXXZ	; CUser::AddRainbowRaceApplicationOpenWnd
; Function compile flags: /Ogty
;	COMDAT ?AddRainbowRaceApplicationOpenWnd@CUser@@QAEXXZ
_TEXT	SEGMENT
?AddRainbowRaceApplicationOpenWnd@CUser@@QAEXXZ PROC NEAR ; CUser::AddRainbowRaceApplicationOpenWnd, COMDAT
; _this$ = ecx

; 8404 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	75 62		 jne	 SHORT $L308729

; 8405 : 	m_Snapshot.cb++;

  00006	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  0000d	56		 push	 esi
  0000e	57		 push	 edi

; 8406 : 	m_Snapshot.ar << GetId();

  0000f	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  00015	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  0001b	6a 04		 push	 4
  0001d	8b ce		 mov	 ecx, esi
  0001f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00024	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00027	89 38		 mov	 DWORD PTR [eax], edi
  00029	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0002c	83 c0 04	 add	 eax, 4

; 8407 : 	m_Snapshot.ar << SNAPSHOTTYPE_RAINBOWRACE_APPLICATION_OPENWND;

  0002f	6a 02		 push	 2
  00031	8b ce		 mov	 ecx, esi
  00033	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00036	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003b	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003e	66 c7 01 01 90	 mov	 WORD PTR [ecx], 36865	; 00009001H
  00043	83 46 08 02	 add	 DWORD PTR [esi+8], 2

; 8408 : 	m_Snapshot.ar << CRainbowRaceMng::GetInstance()->GetApplicantNum();

  00047	e8 00 00 00 00	 call	 ?GetInstance@CRainbowRaceMng@@SAPAV1@XZ ; CRainbowRaceMng::GetInstance
  0004c	8b 78 18	 mov	 edi, DWORD PTR [eax+24]
  0004f	6a 04		 push	 4
  00051	8b ce		 mov	 ecx, esi
  00053	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00058	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0005b	89 3a		 mov	 DWORD PTR [edx], edi
  0005d	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00060	83 c0 04	 add	 eax, 4
  00063	5f		 pop	 edi
  00064	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00067	5e		 pop	 esi
$L308729:

; 8409 : }

  00068	c3		 ret	 0
?AddRainbowRaceApplicationOpenWnd@CUser@@QAEXXZ ENDP	; CUser::AddRainbowRaceApplicationOpenWnd
_TEXT	ENDS
PUBLIC	?AddMiniGameState@CUser@@QAEXU__MINIGAME_PACKET@@@Z ; CUser::AddMiniGameState
; Function compile flags: /Ogty
;	COMDAT ?AddMiniGameState@CUser@@QAEXU__MINIGAME_PACKET@@@Z
_TEXT	SEGMENT
_MiniGamePacket$ = 8					; size = 20
?AddMiniGameState@CUser@@QAEXU__MINIGAME_PACKET@@@Z PROC NEAR ; CUser::AddMiniGameState, COMDAT
; _this$ = ecx

; 8422 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	75 4d		 jne	 SHORT $L285435

; 8423 : 	m_Snapshot.cb++;

  00006	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  0000d	56		 push	 esi
  0000e	57		 push	 edi

; 8424 : 	m_Snapshot.ar << GetId();

  0000f	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  00015	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  0001b	6a 04		 push	 4
  0001d	8b ce		 mov	 ecx, esi
  0001f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00024	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00027	89 38		 mov	 DWORD PTR [eax], edi
  00029	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  0002c	83 c7 04	 add	 edi, 4

; 8425 : 	m_Snapshot.ar << SNAPSHOTTYPE_RAINBOWRACE_MINIGAMESTATE;

  0002f	6a 02		 push	 2
  00031	8b ce		 mov	 ecx, esi
  00033	89 7e 08	 mov	 DWORD PTR [esi+8], edi
  00036	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003b	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003e	66 c7 01 03 90	 mov	 WORD PTR [ecx], 36867	; 00009003H
  00043	83 46 08 02	 add	 DWORD PTR [esi+8], 2

; 8426 : 	MiniGamePacket.Serialize( m_Snapshot.ar );

  00047	56		 push	 esi
  00048	8d 4c 24 10	 lea	 ecx, DWORD PTR _MiniGamePacket$[esp+8]
  0004c	e8 00 00 00 00	 call	 ?Serialize@__MINIGAME_PACKET@@UAEXAAVCAr@@@Z ; __MINIGAME_PACKET::Serialize
  00051	5f		 pop	 edi
  00052	5e		 pop	 esi
$L285435:

; 8427 : }

  00053	c2 14 00	 ret	 20			; 00000014H
?AddMiniGameState@CUser@@QAEXU__MINIGAME_PACKET@@@Z ENDP ; CUser::AddMiniGameState
_TEXT	ENDS
PUBLIC	?AddHousingSetFurnitureList@CUser@@QAEXAAUHOUSINGINFO@@H@Z ; CUser::AddHousingSetFurnitureList
; Function compile flags: /Ogty
;	COMDAT ?AddHousingSetFurnitureList@CUser@@QAEXAAUHOUSINGINFO@@H@Z
_TEXT	SEGMENT
_housingInfo$ = 8					; size = 4
_bAdd$ = 12						; size = 4
?AddHousingSetFurnitureList@CUser@@QAEXAAUHOUSINGINFO@@H@Z PROC NEAR ; CUser::AddHousingSetFurnitureList, COMDAT
; _this$ = ecx

; 8451 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	75 68		 jne	 SHORT $L308774

; 8452 : 	m_Snapshot.cb++;

  00006	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  0000d	56		 push	 esi
  0000e	57		 push	 edi

; 8453 : 	m_Snapshot.ar << GetId();

  0000f	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  00015	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  0001b	6a 04		 push	 4
  0001d	8b ce		 mov	 ecx, esi
  0001f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00024	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00027	89 38		 mov	 DWORD PTR [eax], edi
  00029	83 46 08 04	 add	 DWORD PTR [esi+8], 4

; 8454 : 	m_Snapshot.ar << SNAPSHOTTYPE_HOUSING_FURNITURELIST;

  0002d	6a 02		 push	 2
  0002f	8b ce		 mov	 ecx, esi
  00031	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00036	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00039	66 c7 01 01 92	 mov	 WORD PTR [ecx], 37377	; 00009201H
  0003e	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]

; 8455 : 	housingInfo.Serialize( m_Snapshot.ar );

  00041	8b 4c 24 0c	 mov	 ecx, DWORD PTR _housingInfo$[esp+4]
  00045	83 c7 02	 add	 edi, 2
  00048	56		 push	 esi
  00049	89 7e 08	 mov	 DWORD PTR [esi+8], edi
  0004c	e8 00 00 00 00	 call	 ?Serialize@HOUSINGINFO@@QAEXAAVCAr@@@Z ; HOUSINGINFO::Serialize

; 8456 : 	m_Snapshot.ar << bAdd;

  00051	6a 04		 push	 4
  00053	8b ce		 mov	 ecx, esi
  00055	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0005a	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0005d	8b 44 24 10	 mov	 eax, DWORD PTR _bAdd$[esp+4]
  00061	89 02		 mov	 DWORD PTR [edx], eax
  00063	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00066	83 c0 04	 add	 eax, 4
  00069	5f		 pop	 edi
  0006a	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0006d	5e		 pop	 esi
$L308774:

; 8457 : }

  0006e	c2 08 00	 ret	 8
?AddHousingSetFurnitureList@CUser@@QAEXAAUHOUSINGINFO@@H@Z ENDP ; CUser::AddHousingSetFurnitureList
_TEXT	ENDS
PUBLIC	?AddHousingSetupFurniture@CUser@@QAEXPAUHOUSINGINFO@@@Z ; CUser::AddHousingSetupFurniture
; Function compile flags: /Ogty
;	COMDAT ?AddHousingSetupFurniture@CUser@@QAEXPAUHOUSINGINFO@@@Z
_TEXT	SEGMENT
_pHousingInfo$ = 8					; size = 4
?AddHousingSetupFurniture@CUser@@QAEXPAUHOUSINGINFO@@@Z PROC NEAR ; CUser::AddHousingSetupFurniture, COMDAT
; _this$ = ecx

; 8461 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	75 4d		 jne	 SHORT $L285462

; 8462 : 	m_Snapshot.cb++;

  00006	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  0000d	56		 push	 esi
  0000e	57		 push	 edi

; 8463 : 	m_Snapshot.ar << GetId();

  0000f	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  00015	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  0001b	6a 04		 push	 4
  0001d	8b ce		 mov	 ecx, esi
  0001f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00024	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00027	89 38		 mov	 DWORD PTR [eax], edi
  00029	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  0002c	83 c7 04	 add	 edi, 4

; 8464 : 	m_Snapshot.ar << SNAPSHOTTYPE_HOUSING_SETUPFURNITURE;

  0002f	6a 02		 push	 2
  00031	8b ce		 mov	 ecx, esi
  00033	89 7e 08	 mov	 DWORD PTR [esi+8], edi
  00036	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003b	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003e	66 c7 01 02 92	 mov	 WORD PTR [ecx], 37378	; 00009202H
  00043	83 46 08 02	 add	 DWORD PTR [esi+8], 2

; 8465 : 	pHousingInfo->Serialize( m_Snapshot.ar );

  00047	8b 4c 24 0c	 mov	 ecx, DWORD PTR _pHousingInfo$[esp+4]
  0004b	56		 push	 esi
  0004c	e8 00 00 00 00	 call	 ?Serialize@HOUSINGINFO@@QAEXAAVCAr@@@Z ; HOUSINGINFO::Serialize
  00051	5f		 pop	 edi
  00052	5e		 pop	 esi
$L285462:

; 8466 : }

  00053	c2 04 00	 ret	 4
?AddHousingSetupFurniture@CUser@@QAEXPAUHOUSINGINFO@@@Z ENDP ; CUser::AddHousingSetupFurniture
_TEXT	ENDS
PUBLIC	?AddHousingPaperingInfo@CUser@@QAEXKH@Z		; CUser::AddHousingPaperingInfo
; Function compile flags: /Ogty
;	COMDAT ?AddHousingPaperingInfo@CUser@@QAEXKH@Z
_TEXT	SEGMENT
_dwItemId$ = 8						; size = 4
_bSetup$ = 12						; size = 4
?AddHousingPaperingInfo@CUser@@QAEXKH@Z PROC NEAR	; CUser::AddHousingPaperingInfo, COMDAT
; _this$ = ecx

; 8470 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	75 7e		 jne	 SHORT $L308820

; 8471 : 	m_Snapshot.cb++;

  00006	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  0000d	56		 push	 esi
  0000e	57		 push	 edi

; 8472 : 	m_Snapshot.ar << GetId();

  0000f	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  00015	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  0001b	6a 04		 push	 4
  0001d	8b ce		 mov	 ecx, esi
  0001f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00024	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00027	89 38		 mov	 DWORD PTR [eax], edi
  00029	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0002c	83 c2 04	 add	 edx, 4

; 8473 : 	m_Snapshot.ar << SNAPSHOTTYPE_HOUSING_PAPERINGINFO;

  0002f	6a 02		 push	 2
  00031	8b ce		 mov	 ecx, esi
  00033	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00036	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003b	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003e	66 c7 01 03 92	 mov	 WORD PTR [ecx], 37379	; 00009203H
  00043	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00046	83 c0 02	 add	 eax, 2

; 8474 : 	m_Snapshot.ar << dwItemId;

  00049	6a 04		 push	 4
  0004b	8b ce		 mov	 ecx, esi
  0004d	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00050	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00055	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00058	8b 44 24 0c	 mov	 eax, DWORD PTR _dwItemId$[esp+4]
  0005c	89 02		 mov	 DWORD PTR [edx], eax
  0005e	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00061	83 c2 04	 add	 edx, 4

; 8475 : 	m_Snapshot.ar << bSetup;

  00064	6a 04		 push	 4
  00066	8b ce		 mov	 ecx, esi
  00068	89 56 08	 mov	 DWORD PTR [esi+8], edx
  0006b	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00070	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00073	8b 54 24 10	 mov	 edx, DWORD PTR _bSetup$[esp+4]
  00077	89 11		 mov	 DWORD PTR [ecx], edx
  00079	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0007c	83 c0 04	 add	 eax, 4
  0007f	5f		 pop	 edi
  00080	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00083	5e		 pop	 esi
$L308820:

; 8476 : }

  00084	c2 08 00	 ret	 8
?AddHousingPaperingInfo@CUser@@QAEXKH@Z ENDP		; CUser::AddHousingPaperingInfo
_TEXT	ENDS
PUBLIC	?AddHousingSetVisitAllow@CUser@@QAEXKH@Z	; CUser::AddHousingSetVisitAllow
; Function compile flags: /Ogty
;	COMDAT ?AddHousingSetVisitAllow@CUser@@QAEXKH@Z
_TEXT	SEGMENT
_dwTargetId$ = 8					; size = 4
_bAllow$ = 12						; size = 4
?AddHousingSetVisitAllow@CUser@@QAEXKH@Z PROC NEAR	; CUser::AddHousingSetVisitAllow, COMDAT
; _this$ = ecx

; 8493 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	75 7e		 jne	 SHORT $L308851

; 8494 : 	m_Snapshot.cb++;

  00006	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  0000d	56		 push	 esi
  0000e	57		 push	 edi

; 8495 : 	m_Snapshot.ar << GetId();

  0000f	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  00015	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  0001b	6a 04		 push	 4
  0001d	8b ce		 mov	 ecx, esi
  0001f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00024	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00027	89 38		 mov	 DWORD PTR [eax], edi
  00029	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0002c	83 c2 04	 add	 edx, 4

; 8496 : 	m_Snapshot.ar << SNAPSHOTTYPE_HOUSING_SETVISITALLOW;

  0002f	6a 02		 push	 2
  00031	8b ce		 mov	 ecx, esi
  00033	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00036	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003b	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003e	66 c7 01 04 92	 mov	 WORD PTR [ecx], 37380	; 00009204H
  00043	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00046	83 c0 02	 add	 eax, 2

; 8497 : 	m_Snapshot.ar << dwTargetId << bAllow;

  00049	6a 04		 push	 4
  0004b	8b ce		 mov	 ecx, esi
  0004d	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00050	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00055	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00058	8b 44 24 0c	 mov	 eax, DWORD PTR _dwTargetId$[esp+4]
  0005c	89 02		 mov	 DWORD PTR [edx], eax
  0005e	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00061	83 c2 04	 add	 edx, 4
  00064	6a 04		 push	 4
  00066	8b ce		 mov	 ecx, esi
  00068	89 56 08	 mov	 DWORD PTR [esi+8], edx
  0006b	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00070	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00073	8b 54 24 10	 mov	 edx, DWORD PTR _bAllow$[esp+4]
  00077	89 11		 mov	 DWORD PTR [ecx], edx
  00079	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0007c	83 c0 04	 add	 eax, 4
  0007f	5f		 pop	 edi
  00080	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00083	5e		 pop	 esi
$L308851:

; 8498 : }

  00084	c2 08 00	 ret	 8
?AddHousingSetVisitAllow@CUser@@QAEXKH@Z ENDP		; CUser::AddHousingSetVisitAllow
_TEXT	ENDS
PUBLIC	?AddQuizEventState@CUser@@QAEXHH@Z		; CUser::AddQuizEventState
; Function compile flags: /Ogty
;	COMDAT ?AddQuizEventState@CUser@@QAEXHH@Z
_TEXT	SEGMENT
_nType$ = 8						; size = 4
_nState$ = 12						; size = 4
?AddQuizEventState@CUser@@QAEXHH@Z PROC NEAR		; CUser::AddQuizEventState, COMDAT
; _this$ = ecx

; 8645 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	75 7e		 jne	 SHORT $L308886

; 8646 : 	
; 8647 : 	m_Snapshot.cb++;

  00006	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  0000d	56		 push	 esi
  0000e	57		 push	 edi

; 8648 : 	m_Snapshot.ar << GetId();

  0000f	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  00015	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  0001b	6a 04		 push	 4
  0001d	8b ce		 mov	 ecx, esi
  0001f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00024	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00027	89 38		 mov	 DWORD PTR [eax], edi
  00029	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0002c	83 c2 04	 add	 edx, 4

; 8649 : 	m_Snapshot.ar << SNAPSHOTTYPE_QUIZ_STATE;

  0002f	6a 02		 push	 2
  00031	8b ce		 mov	 ecx, esi
  00033	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00036	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003b	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003e	66 c7 01 20 99	 mov	 WORD PTR [ecx], 39200	; 00009920H
  00043	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00046	83 c0 02	 add	 eax, 2

; 8650 : 	m_Snapshot.ar << nType << nState;

  00049	6a 04		 push	 4
  0004b	8b ce		 mov	 ecx, esi
  0004d	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00050	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00055	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00058	8b 44 24 0c	 mov	 eax, DWORD PTR _nType$[esp+4]
  0005c	89 02		 mov	 DWORD PTR [edx], eax
  0005e	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00061	83 c2 04	 add	 edx, 4
  00064	6a 04		 push	 4
  00066	8b ce		 mov	 ecx, esi
  00068	89 56 08	 mov	 DWORD PTR [esi+8], edx
  0006b	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00070	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00073	8b 54 24 10	 mov	 edx, DWORD PTR _nState$[esp+4]
  00077	89 11		 mov	 DWORD PTR [ecx], edx
  00079	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0007c	83 c0 04	 add	 eax, 4
  0007f	5f		 pop	 edi
  00080	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00083	5e		 pop	 esi
$L308886:

; 8651 : }

  00084	c2 08 00	 ret	 8
?AddQuizEventState@CUser@@QAEXHH@Z ENDP			; CUser::AddQuizEventState
_TEXT	ENDS
PUBLIC	?AddQuizEventMessage@CUser@@QAEXPBDH@Z		; CUser::AddQuizEventMessage
; Function compile flags: /Ogty
;	COMDAT ?AddQuizEventMessage@CUser@@QAEXPBDH@Z
_TEXT	SEGMENT
tv65 = 8						; size = 4
_lpszMessage$ = 8					; size = 4
_nState$ = 12						; size = 4
?AddQuizEventMessage@CUser@@QAEXPBDH@Z PROC NEAR	; CUser::AddQuizEventMessage, COMDAT
; _this$ = ecx

; 8654 : {

  00000	55		 push	 ebp

; 8655 : 	if( strlen( lpszMessage ) == 0 ) return;

  00001	8b 6c 24 08	 mov	 ebp, DWORD PTR _lpszMessage$[esp]
  00005	8b c5		 mov	 eax, ebp
  00007	56		 push	 esi
  00008	8d 70 01	 lea	 esi, DWORD PTR [eax+1]
  0000b	eb 03 8d 49 00	 npad	 5
$L308917:
  00010	8a 10		 mov	 dl, BYTE PTR [eax]
  00012	40		 inc	 eax
  00013	84 d2		 test	 dl, dl
  00015	75 f9		 jne	 SHORT $L308917
  00017	2b c6		 sub	 eax, esi
  00019	89 44 24 0c	 mov	 DWORD PTR tv65[esp+4], eax
  0001d	74 65		 je	 SHORT $L308912

; 8656 : 	if( IsDelete() )	return;

  0001f	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00023	75 5f		 jne	 SHORT $L308912

; 8657 : 	
; 8658 : 	m_Snapshot.cb++;

  00025	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  0002c	57		 push	 edi

; 8659 : 	m_Snapshot.ar << GetId();

  0002d	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  00033	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  00039	6a 04		 push	 4
  0003b	8b ce		 mov	 ecx, esi
  0003d	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00042	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00045	89 38		 mov	 DWORD PTR [eax], edi
  00047	83 46 08 04	 add	 DWORD PTR [esi+8], 4

; 8660 : 	m_Snapshot.ar << SNAPSHOTTYPE_QUIZ_MESSAGE;

  0004b	6a 02		 push	 2
  0004d	8b ce		 mov	 ecx, esi
  0004f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00054	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00057	66 c7 01 21 99	 mov	 WORD PTR [ecx], 39201	; 00009921H
  0005c	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  0005f	83 c7 02	 add	 edi, 2

; 8661 : 	m_Snapshot.ar.WriteString( lpszMessage );

  00062	55		 push	 ebp
  00063	8b ce		 mov	 ecx, esi
  00065	89 7e 08	 mov	 DWORD PTR [esi+8], edi
  00068	e8 00 00 00 00	 call	 ?WriteString@CAr@@QAEXPBD@Z ; CAr::WriteString

; 8662 : 	m_Snapshot.ar << nState;

  0006d	6a 04		 push	 4
  0006f	8b ce		 mov	 ecx, esi
  00071	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00076	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00079	8b 44 24 14	 mov	 eax, DWORD PTR _nState$[esp+8]
  0007d	89 02		 mov	 DWORD PTR [edx], eax
  0007f	83 46 08 04	 add	 DWORD PTR [esi+8], 4
  00083	5f		 pop	 edi
$L308912:
  00084	5e		 pop	 esi
  00085	5d		 pop	 ebp

; 8663 : }

  00086	c2 08 00	 ret	 8
?AddQuizEventMessage@CUser@@QAEXPBDH@Z ENDP		; CUser::AddQuizEventMessage
_TEXT	ENDS
PUBLIC	?AddQuizQuestion@CUser@@QAEXHPBDH@Z		; CUser::AddQuizQuestion
; Function compile flags: /Ogty
;	COMDAT ?AddQuizQuestion@CUser@@QAEXHPBDH@Z
_TEXT	SEGMENT
_nType$ = 8						; size = 4
tv65 = 12						; size = 4
_lpszQuestion$ = 12					; size = 4
_nCount$ = 16						; size = 4
?AddQuizQuestion@CUser@@QAEXHPBDH@Z PROC NEAR		; CUser::AddQuizQuestion, COMDAT
; _this$ = ecx

; 8666 : {

  00000	55		 push	 ebp

; 8667 : 	if( strlen( lpszQuestion ) == 0 ) return;

  00001	8b 6c 24 0c	 mov	 ebp, DWORD PTR _lpszQuestion$[esp]
  00005	8b c5		 mov	 eax, ebp
  00007	56		 push	 esi
  00008	8d 70 01	 lea	 esi, DWORD PTR [eax+1]
  0000b	eb 03 8d 49 00	 npad	 5
$L308954:
  00010	8a 10		 mov	 dl, BYTE PTR [eax]
  00012	40		 inc	 eax
  00013	84 d2		 test	 dl, dl
  00015	75 f9		 jne	 SHORT $L308954
  00017	2b c6		 sub	 eax, esi
  00019	89 44 24 10	 mov	 DWORD PTR tv65[esp+4], eax
  0001d	0f 84 80 00 00
	00		 je	 $L308949

; 8668 : 	if( IsDelete() )	return;

  00023	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00027	75 7a		 jne	 SHORT $L308949

; 8669 : 	
; 8670 : 	m_Snapshot.cb++;

  00029	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  00030	57		 push	 edi

; 8671 : 	m_Snapshot.ar << GetId();

  00031	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  00037	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  0003d	6a 04		 push	 4
  0003f	8b ce		 mov	 ecx, esi
  00041	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00046	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00049	89 38		 mov	 DWORD PTR [eax], edi
  0004b	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  0004e	83 c7 04	 add	 edi, 4

; 8672 : 	m_Snapshot.ar << SNAPSHOTTYPE_QUIZ_QUESTION;

  00051	6a 02		 push	 2
  00053	8b ce		 mov	 ecx, esi
  00055	89 7e 08	 mov	 DWORD PTR [esi+8], edi
  00058	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0005d	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00060	66 c7 01 22 99	 mov	 WORD PTR [ecx], 39202	; 00009922H
  00065	83 46 08 02	 add	 DWORD PTR [esi+8], 2

; 8673 : 	m_Snapshot.ar << nType;

  00069	6a 04		 push	 4
  0006b	8b ce		 mov	 ecx, esi
  0006d	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00072	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00075	8b 44 24 10	 mov	 eax, DWORD PTR _nType$[esp+8]
  00079	89 02		 mov	 DWORD PTR [edx], eax
  0007b	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  0007e	83 c7 04	 add	 edi, 4

; 8674 : 	m_Snapshot.ar.WriteString( lpszQuestion );

  00081	55		 push	 ebp
  00082	8b ce		 mov	 ecx, esi
  00084	89 7e 08	 mov	 DWORD PTR [esi+8], edi
  00087	e8 00 00 00 00	 call	 ?WriteString@CAr@@QAEXPBD@Z ; CAr::WriteString

; 8675 : 	m_Snapshot.ar << nCount;

  0008c	6a 04		 push	 4
  0008e	8b ce		 mov	 ecx, esi
  00090	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00095	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00098	8b 54 24 18	 mov	 edx, DWORD PTR _nCount$[esp+8]
  0009c	89 11		 mov	 DWORD PTR [ecx], edx
  0009e	83 46 08 04	 add	 DWORD PTR [esi+8], 4
  000a2	5f		 pop	 edi
$L308949:
  000a3	5e		 pop	 esi
  000a4	5d		 pop	 ebp

; 8676 : }

  000a5	c2 0c 00	 ret	 12			; 0000000cH
?AddQuizQuestion@CUser@@QAEXHPBDH@Z ENDP		; CUser::AddQuizQuestion
_TEXT	ENDS
PUBLIC	?AddGuildHousePakcet@CUser@@QAEXHAAUGuildHouse_Furniture_Info@CGuildHouseBase@@H@Z ; CUser::AddGuildHousePakcet
EXTRN	?Serialize@GuildHouse_Furniture_Info@CGuildHouseBase@@QAEXAAVCAr@@@Z:NEAR ; CGuildHouseBase::GuildHouse_Furniture_Info::Serialize
; Function compile flags: /Ogty
;	COMDAT ?AddGuildHousePakcet@CUser@@QAEXHAAUGuildHouse_Furniture_Info@CGuildHouseBase@@H@Z
_TEXT	SEGMENT
_nPacketType$ = 8					; size = 4
_gfi$ = 12						; size = 4
_nIndex$ = 16						; size = 4
?AddGuildHousePakcet@CUser@@QAEXHAAUGuildHouse_Furniture_Info@CGuildHouseBase@@H@Z PROC NEAR ; CUser::AddGuildHousePakcet, COMDAT
; _this$ = ecx

; 8707 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	75 7e		 jne	 SHORT $L285631

; 8708 : 	
; 8709 : 	m_Snapshot.cb++;

  00006	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  0000d	56		 push	 esi
  0000e	57		 push	 edi

; 8710 : 	m_Snapshot.ar << GetId();

  0000f	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  00015	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  0001b	6a 04		 push	 4
  0001d	8b ce		 mov	 ecx, esi
  0001f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00024	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00027	89 38		 mov	 DWORD PTR [eax], edi
  00029	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  0002c	83 c7 04	 add	 edi, 4

; 8711 : 	m_Snapshot.ar << SNAPSHOTTYPE_GUILDHOUSE_PACKET;

  0002f	6a 02		 push	 2
  00031	8b ce		 mov	 ecx, esi
  00033	89 7e 08	 mov	 DWORD PTR [esi+8], edi
  00036	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003b	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003e	66 c7 01 10 88	 mov	 WORD PTR [ecx], 34832	; 00008810H
  00043	83 46 08 02	 add	 DWORD PTR [esi+8], 2

; 8712 : 	m_Snapshot.ar << nPacketType << nIndex;

  00047	6a 04		 push	 4
  00049	8b ce		 mov	 ecx, esi
  0004b	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00050	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00053	8b 44 24 0c	 mov	 eax, DWORD PTR _nPacketType$[esp+4]
  00057	89 02		 mov	 DWORD PTR [edx], eax
  00059	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  0005c	83 c7 04	 add	 edi, 4
  0005f	6a 04		 push	 4
  00061	8b ce		 mov	 ecx, esi
  00063	89 7e 08	 mov	 DWORD PTR [esi+8], edi
  00066	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0006b	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0006e	8b 54 24 14	 mov	 edx, DWORD PTR _nIndex$[esp+4]
  00072	89 11		 mov	 DWORD PTR [ecx], edx
  00074	83 46 08 04	 add	 DWORD PTR [esi+8], 4

; 8713 : 	gfi.Serialize( m_Snapshot.ar );

  00078	8b 4c 24 10	 mov	 ecx, DWORD PTR _gfi$[esp+4]
  0007c	56		 push	 esi
  0007d	e8 00 00 00 00	 call	 ?Serialize@GuildHouse_Furniture_Info@CGuildHouseBase@@QAEXAAVCAr@@@Z ; CGuildHouseBase::GuildHouse_Furniture_Info::Serialize
  00082	5f		 pop	 edi
  00083	5e		 pop	 esi
$L285631:

; 8714 : }

  00084	c2 0c 00	 ret	 12			; 0000000cH
?AddGuildHousePakcet@CUser@@QAEXHAAUGuildHouse_Furniture_Info@CGuildHouseBase@@H@Z ENDP ; CUser::AddGuildHousePakcet
_TEXT	ENDS
PUBLIC	?AddGuildHouseAllInfo@CUser@@QAEXPAVCGuildHouseBase@@@Z ; CUser::AddGuildHouseAllInfo
EXTRN	?GetState@CFlyffEvent@@QAEEH@Z:NEAR		; CFlyffEvent::GetState
EXTRN	?SerializeAllInfo@CGuildHouseBase@@QAEXAAVCAr@@@Z:NEAR ; CGuildHouseBase::SerializeAllInfo
; Function compile flags: /Ogty
;	COMDAT ?AddGuildHouseAllInfo@CUser@@QAEXPAVCGuildHouseBase@@@Z
_TEXT	SEGMENT
_pGuildHouse$ = 8					; size = 4
?AddGuildHouseAllInfo@CUser@@QAEXPAVCGuildHouseBase@@@Z PROC NEAR ; CUser::AddGuildHouseAllInfo, COMDAT
; _this$ = ecx

; 8718 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	0f 85 ac 00 00
	00		 jne	 $L309031

; 8719 : 	
; 8720 : 	m_Snapshot.cb++;

  0000a	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  00011	53		 push	 ebx
  00012	56		 push	 esi
  00013	57		 push	 edi

; 8721 : 	m_Snapshot.ar << GetId();

  00014	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  0001a	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  00020	bb 04 00 00 00	 mov	 ebx, 4
  00025	53		 push	 ebx
  00026	8b ce		 mov	 ecx, esi
  00028	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0002d	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00030	89 38		 mov	 DWORD PTR [eax], edi
  00032	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00035	03 d3		 add	 edx, ebx

; 8722 : 	m_Snapshot.ar << SNAPSHOTTYPE_GUILDHOUSE_ALLINFO;

  00037	6a 02		 push	 2
  00039	8b ce		 mov	 ecx, esi
  0003b	89 56 08	 mov	 DWORD PTR [esi+8], edx
  0003e	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00043	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00046	66 c7 01 12 88	 mov	 WORD PTR [ecx], 34834	; 00008812H
  0004b	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0004e	83 c0 02	 add	 eax, 2

; 8723 : 	m_Snapshot.ar << static_cast<BOOL>( g_eLocal.GetState( ENABLE_GUILD_INVENTORY ) );

  00051	6a 02		 push	 2
  00053	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_eLocal@@3VCFlyffEvent@@A
  00058	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0005b	e8 00 00 00 00	 call	 ?GetState@CFlyffEvent@@QAEEH@Z ; CFlyffEvent::GetState
  00060	53		 push	 ebx
  00061	8b ce		 mov	 ecx, esi
  00063	0f b6 f8	 movzx	 edi, al
  00066	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0006b	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0006e	89 3a		 mov	 DWORD PTR [edx], edi
  00070	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]

; 8724 : 	if( pGuildHouse )

  00073	8b 7c 24 10	 mov	 edi, DWORD PTR _pGuildHouse$[esp+8]
  00077	03 cb		 add	 ecx, ebx
  00079	89 4e 08	 mov	 DWORD PTR [esi+8], ecx

; 8725 : 	{
; 8726 : 		m_Snapshot.ar << TRUE;

  0007c	8b ce		 mov	 ecx, esi
  0007e	53		 push	 ebx
  0007f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00084	85 ff		 test	 edi, edi
  00086	74 1a		 je	 SHORT $L285641
  00088	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0008b	c7 00 01 00 00
	00		 mov	 DWORD PTR [eax], 1
  00091	01 5e 08	 add	 DWORD PTR [esi+8], ebx

; 8727 : 		pGuildHouse->SerializeAllInfo( m_Snapshot.ar );

  00094	56		 push	 esi
  00095	8b cf		 mov	 ecx, edi
  00097	e8 00 00 00 00	 call	 ?SerializeAllInfo@CGuildHouseBase@@QAEXAAVCAr@@@Z ; CGuildHouseBase::SerializeAllInfo
  0009c	5f		 pop	 edi
  0009d	5e		 pop	 esi
  0009e	5b		 pop	 ebx

; 8731 : }

  0009f	c2 04 00	 ret	 4
$L285641:

; 8728 : 	}
; 8729 : 	else
; 8730 : 		m_Snapshot.ar << FALSE;

  000a2	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  000a5	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  000ab	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000ae	03 c3		 add	 eax, ebx
  000b0	5f		 pop	 edi
  000b1	89 46 08	 mov	 DWORD PTR [esi+8], eax
  000b4	5e		 pop	 esi
  000b5	5b		 pop	 ebx
$L309031:

; 8731 : }

  000b6	c2 04 00	 ret	 4
?AddGuildHouseAllInfo@CUser@@QAEXPAVCGuildHouseBase@@@Z ENDP ; CUser::AddGuildHouseAllInfo
_TEXT	ENDS
PUBLIC	?AddRestPoint@CUser@@AAEXXZ			; CUser::AddRestPoint
; Function compile flags: /Ogty
;	COMDAT ?AddRestPoint@CUser@@AAEXXZ
_TEXT	SEGMENT
?AddRestPoint@CUser@@AAEXXZ PROC NEAR			; CUser::AddRestPoint, COMDAT
; _this$ = ecx

; 8774 : {

  00000	57		 push	 edi
  00001	8b f9		 mov	 edi, ecx

; 8775 : 	if( IsDelete() )	return;

  00003	f6 47 04 01	 test	 BYTE PTR [edi+4], 1
  00007	75 5b		 jne	 SHORT $L309061

; 8776 : 
; 8777 : 	m_Snapshot.cb++;

  00009	66 ff 87 0c 57
	00 00		 inc	 WORD PTR [edi+22284]
  00010	53		 push	 ebx

; 8778 : 	m_Snapshot.ar << GetId();

  00011	8b 9f bc 01 00
	00		 mov	 ebx, DWORD PTR [edi+444]
  00017	56		 push	 esi
  00018	8d b7 f8 16 00
	00		 lea	 esi, DWORD PTR [edi+5880]
  0001e	6a 04		 push	 4
  00020	8b ce		 mov	 ecx, esi
  00022	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00027	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0002a	89 18		 mov	 DWORD PTR [eax], ebx
  0002c	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0002f	83 c0 04	 add	 eax, 4

; 8779 : 	m_Snapshot.ar << SNAPSHOTTYPE_GUILDHOUSE_RESTPOINT;

  00032	6a 02		 push	 2
  00034	8b ce		 mov	 ecx, esi
  00036	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00039	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003e	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00041	66 c7 01 14 88	 mov	 WORD PTR [ecx], 34836	; 00008814H
  00046	83 46 08 02	 add	 DWORD PTR [esi+8], 2

; 8780 : 	m_Snapshot.ar << m_nRestPoint;

  0004a	8b bf a8 96 00
	00		 mov	 edi, DWORD PTR [edi+38568]
  00050	6a 04		 push	 4
  00052	8b ce		 mov	 ecx, esi
  00054	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00059	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0005c	89 3a		 mov	 DWORD PTR [edx], edi
  0005e	83 46 08 04	 add	 DWORD PTR [esi+8], 4
  00062	5e		 pop	 esi
  00063	5b		 pop	 ebx
$L309061:
  00064	5f		 pop	 edi

; 8781 : }

  00065	c3		 ret	 0
?AddRestPoint@CUser@@AAEXXZ ENDP			; CUser::AddRestPoint
_TEXT	ENDS
PUBLIC	?AddUpdateCampusPoint@CUser@@QAEXH@Z		; CUser::AddUpdateCampusPoint
; Function compile flags: /Ogty
;	COMDAT ?AddUpdateCampusPoint@CUser@@QAEXH@Z
_TEXT	SEGMENT
_nCampusPoint$ = 8					; size = 4
?AddUpdateCampusPoint@CUser@@QAEXH@Z PROC NEAR		; CUser::AddUpdateCampusPoint, COMDAT
; _this$ = ecx

; 8848 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	75 63		 jne	 SHORT $L309089

; 8849 : 
; 8850 : 	m_Snapshot.cb++;

  00006	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  0000d	56		 push	 esi
  0000e	57		 push	 edi

; 8851 : 	m_Snapshot.ar << GetId();

  0000f	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  00015	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  0001b	6a 04		 push	 4
  0001d	8b ce		 mov	 ecx, esi
  0001f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00024	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00027	89 38		 mov	 DWORD PTR [eax], edi
  00029	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0002c	83 c0 04	 add	 eax, 4

; 8852 : 	m_Snapshot.ar << SNAPSHOTTYPE_CAMPUS_UPDATE_POINT;

  0002f	6a 02		 push	 2
  00031	8b ce		 mov	 ecx, esi
  00033	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00036	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003b	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003e	66 c7 01 33 88	 mov	 WORD PTR [ecx], 34867	; 00008833H
  00043	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00046	83 c2 02	 add	 edx, 2

; 8853 : 	m_Snapshot.ar << nCampusPoint;

  00049	6a 04		 push	 4
  0004b	8b ce		 mov	 ecx, esi
  0004d	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00050	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00055	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00058	8b 44 24 0c	 mov	 eax, DWORD PTR _nCampusPoint$[esp+4]
  0005c	89 02		 mov	 DWORD PTR [edx], eax
  0005e	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00061	83 c0 04	 add	 eax, 4
  00064	5f		 pop	 edi
  00065	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00068	5e		 pop	 esi
$L309089:

; 8854 : }

  00069	c2 04 00	 ret	 4
?AddUpdateCampusPoint@CUser@@QAEXH@Z ENDP		; CUser::AddUpdateCampusPoint
_TEXT	ENDS
PUBLIC	?ActiveCampusBuff@CUser@@QAEXH@Z		; CUser::ActiveCampusBuff
EXTRN	?GetInstance@CCampusHelper@@SAPAV1@XZ:NEAR	; CCampusHelper::GetInstance
EXTRN	?GetCampusBuff@CCampusHelper@@QAEKH@Z:NEAR	; CCampusHelper::GetCampusBuff
; Function compile flags: /Ogty
;	COMDAT ?ActiveCampusBuff@CUser@@QAEXH@Z
_TEXT	SEGMENT
_nLevel$ = 8						; size = 4
?ActiveCampusBuff@CUser@@QAEXH@Z PROC NEAR		; CUser::ActiveCampusBuff, COMDAT
; _this$ = ecx

; 8881 : 	ItemProp* pProp	= prj.GetItemProp( CCampusHelper::GetInstance()->GetCampusBuff( nLevel ) );

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _nLevel$[esp-4]
  00004	56		 push	 esi
  00005	50		 push	 eax
  00006	8b f1		 mov	 esi, ecx
  00008	e8 00 00 00 00	 call	 ?GetInstance@CCampusHelper@@SAPAV1@XZ ; CCampusHelper::GetInstance
  0000d	8b c8		 mov	 ecx, eax
  0000f	e8 00 00 00 00	 call	 ?GetCampusBuff@CCampusHelper@@QAEKH@Z ; CCampusHelper::GetCampusBuff
  00014	85 c0		 test	 eax, eax
  00016	8b 0d 5c 02 00
	00		 mov	 ecx, DWORD PTR ?prj@@3VCProject@@A+604
  0001c	7c 2a		 jl	 SHORT $L309124
  0001e	3b c1		 cmp	 eax, ecx
  00020	7d 26		 jge	 SHORT $L309124
  00022	73 20		 jae	 SHORT $L285748
  00024	8b 0d 4c 02 00
	00		 mov	 ecx, DWORD PTR ?prj@@3VCProject@@A+588
  0002a	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]

; 8882 : 	if( pProp )

  0002d	85 c0		 test	 eax, eax
  0002f	74 13		 je	 SHORT $L285748

; 8883 : 		DoApplySkill( this, pProp, NULL );

  00031	6a 00		 push	 0
  00033	6a 00		 push	 0
  00035	6a 00		 push	 0
  00037	6a 00		 push	 0
  00039	6a 00		 push	 0
  0003b	50		 push	 eax
  0003c	56		 push	 esi
  0003d	8b ce		 mov	 ecx, esi
  0003f	e8 00 00 00 00	 call	 ?DoApplySkill@CCtrl@@QAEHPAV1@PAUItemProp@@PAUAddSkillProp@@_NHHH@Z ; CCtrl::DoApplySkill
$L285748:
  00044	5e		 pop	 esi

; 8884 : }

  00045	c2 04 00	 ret	 4

; 8881 : 	ItemProp* pProp	= prj.GetItemProp( CCampusHelper::GetInstance()->GetCampusBuff( nLevel ) );

$L309124:
  00048	50		 push	 eax
  00049	51		 push	 ecx
  0004a	6a 00		 push	 0
  0004c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BI@BEIFNGEL@GetItemProp?5range_error?$AA@
  00051	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@HMFGHCP@?$CFs?5min?3?$CFd?0?5max?3?$CFd?0?5index?3?$CFd?$AA@
  00056	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  0005b	83 c4 14	 add	 esp, 20			; 00000014H
  0005e	5e		 pop	 esi

; 8884 : }

  0005f	c2 04 00	 ret	 4
?ActiveCampusBuff@CUser@@QAEXH@Z ENDP			; CUser::ActiveCampusBuff
_TEXT	ENDS
PUBLIC	?SendColosseumStart@CUser@@QAEXH@Z		; CUser::SendColosseumStart
; Function compile flags: /Ogty
;	COMDAT ?SendColosseumStart@CUser@@QAEXH@Z
_TEXT	SEGMENT
_nTime$ = 8						; size = 4
?SendColosseumStart@CUser@@QAEXH@Z PROC NEAR		; CUser::SendColosseumStart, COMDAT
; _this$ = ecx

; 9036 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	75 63		 jne	 SHORT $L309161

; 9037 : 	
; 9038 : 	m_Snapshot.cb++;

  00006	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  0000d	56		 push	 esi
  0000e	57		 push	 edi

; 9039 : 	m_Snapshot.ar << GetId();

  0000f	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  00015	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  0001b	6a 04		 push	 4
  0001d	8b ce		 mov	 ecx, esi
  0001f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00024	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00027	89 38		 mov	 DWORD PTR [eax], edi
  00029	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0002c	83 c0 04	 add	 eax, 4

; 9040 : 	m_Snapshot.ar << SNAPSHOTTYPE_COLOSSEUM_START;

  0002f	6a 02		 push	 2
  00031	8b ce		 mov	 ecx, esi
  00033	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00036	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003b	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003e	66 c7 01 81 88	 mov	 WORD PTR [ecx], 34945	; 00008881H
  00043	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00046	83 c2 02	 add	 edx, 2

; 9041 : 	m_Snapshot.ar << nTime;

  00049	6a 04		 push	 4
  0004b	8b ce		 mov	 ecx, esi
  0004d	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00050	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00055	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00058	8b 44 24 0c	 mov	 eax, DWORD PTR _nTime$[esp+4]
  0005c	89 02		 mov	 DWORD PTR [edx], eax
  0005e	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00061	83 c0 04	 add	 eax, 4
  00064	5f		 pop	 edi
  00065	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00068	5e		 pop	 esi
$L309161:

; 9042 : }

  00069	c2 04 00	 ret	 4
?SendColosseumStart@CUser@@QAEXH@Z ENDP			; CUser::SendColosseumStart
_TEXT	ENDS
PUBLIC	?SendColosseumReady1@CUser@@QAEXHE@Z		; CUser::SendColosseumReady1
; Function compile flags: /Ogty
;	COMDAT ?SendColosseumReady1@CUser@@QAEXHE@Z
_TEXT	SEGMENT
_nTime$ = 8						; size = 4
_nStage$ = 12						; size = 1
?SendColosseumReady1@CUser@@QAEXHE@Z PROC NEAR		; CUser::SendColosseumReady1, COMDAT
; _this$ = ecx

; 9045 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	75 7c		 jne	 SHORT $L309194

; 9046 : 	
; 9047 : 	m_Snapshot.cb++;

  00006	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  0000d	56		 push	 esi
  0000e	57		 push	 edi

; 9048 : 	m_Snapshot.ar << GetId();

  0000f	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  00015	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  0001b	6a 04		 push	 4
  0001d	8b ce		 mov	 ecx, esi
  0001f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00024	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00027	89 38		 mov	 DWORD PTR [eax], edi
  00029	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0002c	83 c2 04	 add	 edx, 4

; 9049 : 	m_Snapshot.ar << SNAPSHOTTYPE_COLOSSEUM_READY1;

  0002f	6a 02		 push	 2
  00031	8b ce		 mov	 ecx, esi
  00033	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00036	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003b	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003e	66 c7 01 83 88	 mov	 WORD PTR [ecx], 34947	; 00008883H
  00043	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00046	83 c0 02	 add	 eax, 2

; 9050 : 	m_Snapshot.ar << nTime << nStage;

  00049	6a 04		 push	 4
  0004b	8b ce		 mov	 ecx, esi
  0004d	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00050	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00055	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00058	8b 44 24 0c	 mov	 eax, DWORD PTR _nTime$[esp+4]
  0005c	89 02		 mov	 DWORD PTR [edx], eax
  0005e	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00061	83 c2 04	 add	 edx, 4
  00064	6a 01		 push	 1
  00066	8b ce		 mov	 ecx, esi
  00068	89 56 08	 mov	 DWORD PTR [esi+8], edx
  0006b	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00070	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00073	8a 54 24 10	 mov	 dl, BYTE PTR _nStage$[esp+4]
  00077	88 11		 mov	 BYTE PTR [ecx], dl
  00079	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0007c	40		 inc	 eax
  0007d	5f		 pop	 edi
  0007e	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00081	5e		 pop	 esi
$L309194:

; 9051 : }

  00082	c2 08 00	 ret	 8
?SendColosseumReady1@CUser@@QAEXHE@Z ENDP		; CUser::SendColosseumReady1
_TEXT	ENDS
PUBLIC	?SendColosseumReady2@CUser@@QAEXH@Z		; CUser::SendColosseumReady2
; Function compile flags: /Ogty
;	COMDAT ?SendColosseumReady2@CUser@@QAEXH@Z
_TEXT	SEGMENT
_nTime$ = 8						; size = 4
?SendColosseumReady2@CUser@@QAEXH@Z PROC NEAR		; CUser::SendColosseumReady2, COMDAT
; _this$ = ecx

; 9054 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	75 63		 jne	 SHORT $L309218

; 9055 : 	
; 9056 : 	m_Snapshot.cb++;

  00006	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  0000d	56		 push	 esi
  0000e	57		 push	 edi

; 9057 : 	m_Snapshot.ar << GetId();

  0000f	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  00015	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  0001b	6a 04		 push	 4
  0001d	8b ce		 mov	 ecx, esi
  0001f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00024	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00027	89 38		 mov	 DWORD PTR [eax], edi
  00029	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0002c	83 c0 04	 add	 eax, 4

; 9058 : 	m_Snapshot.ar << SNAPSHOTTYPE_COLOSSEUM_READY2;

  0002f	6a 02		 push	 2
  00031	8b ce		 mov	 ecx, esi
  00033	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00036	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003b	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003e	66 c7 01 84 88	 mov	 WORD PTR [ecx], 34948	; 00008884H
  00043	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00046	83 c2 02	 add	 edx, 2

; 9059 : 	m_Snapshot.ar << nTime;

  00049	6a 04		 push	 4
  0004b	8b ce		 mov	 ecx, esi
  0004d	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00050	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00055	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00058	8b 44 24 0c	 mov	 eax, DWORD PTR _nTime$[esp+4]
  0005c	89 02		 mov	 DWORD PTR [edx], eax
  0005e	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00061	83 c0 04	 add	 eax, 4
  00064	5f		 pop	 edi
  00065	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00068	5e		 pop	 esi
$L309218:

; 9060 : }

  00069	c2 04 00	 ret	 4
?SendColosseumReady2@CUser@@QAEXH@Z ENDP		; CUser::SendColosseumReady2
_TEXT	ENDS
PUBLIC	?SendColosseumEndMatch@CUser@@QAEXHH@Z		; CUser::SendColosseumEndMatch
; Function compile flags: /Ogty
;	COMDAT ?SendColosseumEndMatch@CUser@@QAEXHH@Z
_TEXT	SEGMENT
_bWin$ = 8						; size = 4
_nTime$ = 12						; size = 4
?SendColosseumEndMatch@CUser@@QAEXHH@Z PROC NEAR	; CUser::SendColosseumEndMatch, COMDAT
; _this$ = ecx

; 9063 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	75 7e		 jne	 SHORT $L309257

; 9064 : 	
; 9065 : 	m_Snapshot.cb++;

  00006	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  0000d	56		 push	 esi
  0000e	57		 push	 edi

; 9066 : 	m_Snapshot.ar << GetId();

  0000f	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  00015	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  0001b	6a 04		 push	 4
  0001d	8b ce		 mov	 ecx, esi
  0001f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00024	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00027	89 38		 mov	 DWORD PTR [eax], edi
  00029	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0002c	83 c2 04	 add	 edx, 4

; 9067 : 	m_Snapshot.ar << SNAPSHOTTYPE_COLOSSEUM_ENDMATCH;

  0002f	6a 02		 push	 2
  00031	8b ce		 mov	 ecx, esi
  00033	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00036	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003b	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003e	66 c7 01 85 88	 mov	 WORD PTR [ecx], 34949	; 00008885H
  00043	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00046	83 c0 02	 add	 eax, 2

; 9068 : 	m_Snapshot.ar << bWin << nTime;

  00049	6a 04		 push	 4
  0004b	8b ce		 mov	 ecx, esi
  0004d	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00050	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00055	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00058	8b 44 24 0c	 mov	 eax, DWORD PTR _bWin$[esp+4]
  0005c	89 02		 mov	 DWORD PTR [edx], eax
  0005e	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00061	83 c2 04	 add	 edx, 4
  00064	6a 04		 push	 4
  00066	8b ce		 mov	 ecx, esi
  00068	89 56 08	 mov	 DWORD PTR [esi+8], edx
  0006b	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00070	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00073	8b 54 24 10	 mov	 edx, DWORD PTR _nTime$[esp+4]
  00077	89 11		 mov	 DWORD PTR [ecx], edx
  00079	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0007c	83 c0 04	 add	 eax, 4
  0007f	5f		 pop	 edi
  00080	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00083	5e		 pop	 esi
$L309257:

; 9069 : }

  00084	c2 08 00	 ret	 8
?SendColosseumEndMatch@CUser@@QAEXHH@Z ENDP		; CUser::SendColosseumEndMatch
_TEXT	ENDS
PUBLIC	?AddActivateBarunaPet@CUser@@QAEXKKH@Z		; CUser::AddActivateBarunaPet
; Function compile flags: /Ogty
;	COMDAT ?AddActivateBarunaPet@CUser@@QAEXKKH@Z
_TEXT	SEGMENT
_dwItemId$ = 8						; size = 4
_dwBarunaPetID$ = 12					; size = 4
_bActivate$ = 16					; size = 4
?AddActivateBarunaPet@CUser@@QAEXKKH@Z PROC NEAR	; CUser::AddActivateBarunaPet, COMDAT
; _this$ = ecx

; 9075 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	0f 85 98 00 00
	00		 jne	 $L309290

; 9076 : 	
; 9077 : 	m_Snapshot.cb++;

  0000a	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  00011	53		 push	 ebx
  00012	56		 push	 esi
  00013	57		 push	 edi

; 9078 : 	m_Snapshot.ar << GetId();

  00014	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  0001a	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  00020	bb 04 00 00 00	 mov	 ebx, 4
  00025	53		 push	 ebx
  00026	8b ce		 mov	 ecx, esi
  00028	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0002d	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00030	89 38		 mov	 DWORD PTR [eax], edi
  00032	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00035	03 c3		 add	 eax, ebx

; 9079 : 	m_Snapshot.ar << SNAPSHOTTYPE_ADDBARUNAPET;

  00037	6a 02		 push	 2
  00039	8b ce		 mov	 ecx, esi
  0003b	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0003e	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00043	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00046	66 c7 01 86 88	 mov	 WORD PTR [ecx], 34950	; 00008886H
  0004b	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0004e	83 c2 02	 add	 edx, 2

; 9080 : 	m_Snapshot.ar << dwItemId << dwBarunaPetID <<bActivate;

  00051	53		 push	 ebx
  00052	8b ce		 mov	 ecx, esi
  00054	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00057	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0005c	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0005f	8b 44 24 10	 mov	 eax, DWORD PTR _dwItemId$[esp+8]
  00063	89 02		 mov	 DWORD PTR [edx], eax
  00065	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00068	03 c3		 add	 eax, ebx
  0006a	53		 push	 ebx
  0006b	8b ce		 mov	 ecx, esi
  0006d	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00070	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00075	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00078	8b 54 24 14	 mov	 edx, DWORD PTR _dwBarunaPetID$[esp+8]
  0007c	89 11		 mov	 DWORD PTR [ecx], edx
  0007e	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00081	03 d3		 add	 edx, ebx
  00083	53		 push	 ebx
  00084	8b ce		 mov	 ecx, esi
  00086	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00089	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0008e	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00091	8b 4c 24 18	 mov	 ecx, DWORD PTR _bActivate$[esp+8]
  00095	89 08		 mov	 DWORD PTR [eax], ecx
  00097	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0009a	03 c3		 add	 eax, ebx
  0009c	5f		 pop	 edi
  0009d	89 46 08	 mov	 DWORD PTR [esi+8], eax
  000a0	5e		 pop	 esi
  000a1	5b		 pop	 ebx
$L309290:

; 9081 : }

  000a2	c2 0c 00	 ret	 12			; 0000000cH
?AddActivateBarunaPet@CUser@@QAEXKKH@Z ENDP		; CUser::AddActivateBarunaPet
_TEXT	ENDS
PUBLIC	?SendTreasure@CUser@@QAEXQAUTreasureItem@@QAH@Z	; CUser::SendTreasure
; Function compile flags: /Ogty
;	COMDAT ?SendTreasure@CUser@@QAEXQAUTreasureItem@@QAH@Z
_TEXT	SEGMENT
_dwIDs$ = 8						; size = 4
_nCount$ = 12						; size = 4
?SendTreasure@CUser@@QAEXQAUTreasureItem@@QAH@Z PROC NEAR ; CUser::SendTreasure, COMDAT
; _this$ = ecx

; 9087 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	0f 85 95 00 00
	00		 jne	 $L285845

; 9088 : 
; 9089 : 	m_Snapshot.cb++;

  0000a	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  00011	53		 push	 ebx
  00012	55		 push	 ebp
  00013	56		 push	 esi
  00014	57		 push	 edi

; 9090 : 	m_Snapshot.ar << GetId();

  00015	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  0001b	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  00021	6a 04		 push	 4
  00023	8b ce		 mov	 ecx, esi
  00025	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0002a	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0002d	89 38		 mov	 DWORD PTR [eax], edi
  0002f	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00032	83 c2 04	 add	 edx, 4

; 9091 : 	m_Snapshot.ar << SNAPSHOTTYPE_SENDTREASURE;

  00035	6a 02		 push	 2
  00037	8b ce		 mov	 ecx, esi
  00039	89 56 08	 mov	 DWORD PTR [esi+8], edx
  0003c	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00041	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00044	8b 5c 24 14	 mov	 ebx, DWORD PTR _dwIDs$[esp+12]
  00048	66 c7 01 87 88	 mov	 WORD PTR [ecx], 34951	; 00008887H
  0004d	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00050	83 c0 02	 add	 eax, 2

; 9092 : 	for( int i=0;i<3;i++ )

  00053	33 ff		 xor	 edi, edi
  00055	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00058	83 c3 04	 add	 ebx, 4
  0005b	eb 03 8d 49 00	 npad	 5
$L285843:

; 9093 : 	{
; 9094 : 		m_Snapshot.ar << dwIDs[i].dwItemID;

  00060	8b 2b		 mov	 ebp, DWORD PTR [ebx]
  00062	6a 04		 push	 4
  00064	8b ce		 mov	 ecx, esi
  00066	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0006b	8b 56 08	 mov	 edx, DWORD PTR [esi+8]

; 9095 : 		m_Snapshot.ar << nCount[i];

  0006e	8b 44 24 18	 mov	 eax, DWORD PTR _nCount$[esp+12]
  00072	89 2a		 mov	 DWORD PTR [edx], ebp
  00074	83 46 08 04	 add	 DWORD PTR [esi+8], 4
  00078	8b 2c b8	 mov	 ebp, DWORD PTR [eax+edi*4]
  0007b	6a 04		 push	 4
  0007d	8b ce		 mov	 ecx, esi
  0007f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00084	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00087	89 29		 mov	 DWORD PTR [ecx], ebp
  00089	8b 6e 08	 mov	 ebp, DWORD PTR [esi+8]
  0008c	83 c5 04	 add	 ebp, 4
  0008f	47		 inc	 edi
  00090	83 c3 1c	 add	 ebx, 28			; 0000001cH
  00093	83 ff 03	 cmp	 edi, 3
  00096	89 6e 08	 mov	 DWORD PTR [esi+8], ebp
  00099	7c c5		 jl	 SHORT $L285843
  0009b	5f		 pop	 edi
  0009c	5e		 pop	 esi
  0009d	5d		 pop	 ebp
  0009e	5b		 pop	 ebx
$L285845:

; 9096 : 	}
; 9097 : }

  0009f	c2 08 00	 ret	 8
?SendTreasure@CUser@@QAEXQAUTreasureItem@@QAH@Z ENDP	; CUser::SendTreasure
_TEXT	ENDS
PUBLIC	??A?$CSimpleStringT@D$0A@@ATL@@QBEDH@Z		; ATL::CSimpleStringT<char,0>::operator[]
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlsimpstr.h
;	COMDAT ??A?$CSimpleStringT@D$0A@@ATL@@QBEDH@Z
_TEXT	SEGMENT
_iChar$ = 8						; size = 4
??A?$CSimpleStringT@D$0A@@ATL@@QBEDH@Z PROC NEAR	; ATL::CSimpleStringT<char,0>::operator[], COMDAT
; _this$ = ecx

; 369  : 		ATLASSERT( (iChar >= 0) && (iChar <= GetLength()) );  // Indexing the '\0' is OK
; 370  : 		
; 371  : 		if( (iChar < 0) || (iChar > GetLength()) )

  00000	8b 54 24 04	 mov	 edx, DWORD PTR _iChar$[esp-4]
  00004	85 d2		 test	 edx, edx
  00006	7c 0d		 jl	 SHORT $L285850
  00008	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000a	3b 50 f4	 cmp	 edx, DWORD PTR [eax-12]
  0000d	7f 06		 jg	 SHORT $L285850

; 372  : 			AtlThrow(E_INVALIDARG);
; 373  : 			
; 374  : 		return( m_pszData[iChar] );

  0000f	8a 04 10	 mov	 al, BYTE PTR [eax+edx]

; 375  : 	}

  00012	c2 04 00	 ret	 4
$L285850:
  00015	68 57 00 07 80	 push	 -2147024809		; 80070057H
  0001a	e8 00 00 00 00	 call	 ?AtlThrow@ATL@@YGXJ@Z	; ATL::AtlThrow
$L309339:
$L309338:
  0001f	cc		 int	 3
??A?$CSimpleStringT@D$0A@@ATL@@QBEDH@Z ENDP		; ATL::CSimpleStringT<char,0>::operator[]
_TEXT	ENDS
PUBLIC	??Citerator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QBEPAU?$pair@$$CBKPAVCUser@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::iterator::operator->
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ??Citerator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QBEPAU?$pair@$$CBKPAVCUser@@@2@XZ
_TEXT	SEGMENT
??Citerator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QBEPAU?$pair@$$CBKPAVCUser@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::iterator::operator->, COMDAT
; _this$ = ecx

; 322  : 			return (&**this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 0c	 add	 eax, 12			; 0000000cH

; 323  : 			}

  00005	c3		 ret	 0
??Citerator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QBEPAU?$pair@$$CBKPAVCUser@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::iterator::operator->
_TEXT	ENDS
PUBLIC	?begin@?$_Tree@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,CParty *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CParty *> >,0> >::begin
; Function compile flags: /Ogty
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$_Tree@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CParty *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CParty *> >,0> >::begin, COMDAT
; _this$ = ecx

; 408  : 		return (_TREE_ITERATOR(_Lmost()));

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	8b 08		 mov	 ecx, DWORD PTR [eax]
  00005	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 409  : 		}

  0000b	c2 04 00	 ret	 4
?begin@?$_Tree@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CParty *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CParty *> >,0> >::begin
_TEXT	ENDS
PUBLIC	?end@?$_Tree@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,CParty *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CParty *> >,0> >::end
; Function compile flags: /Ogty
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$_Tree@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CParty *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CParty *> >,0> >::end, COMDAT
; _this$ = ecx

; 418  : 		return (_TREE_ITERATOR(_Myhead));

  00000	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00003	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  00007	89 08		 mov	 DWORD PTR [eax], ecx

; 419  : 		}

  00009	c2 04 00	 ret	 4
?end@?$_Tree@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CParty *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CParty *> >,0> >::end
_TEXT	ENDS
PUBLIC	?begin@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,_Friend,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,_Friend> >,0> >::begin
; Function compile flags: /Ogty
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,_Friend,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,_Friend> >,0> >::begin, COMDAT
; _this$ = ecx

; 408  : 		return (_TREE_ITERATOR(_Lmost()));

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	8b 08		 mov	 ecx, DWORD PTR [eax]
  00005	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 409  : 		}

  0000b	c2 04 00	 ret	 4
?begin@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,_Friend,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,_Friend> >,0> >::begin
_TEXT	ENDS
PUBLIC	?end@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,_Friend,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,_Friend> >,0> >::end
; Function compile flags: /Ogty
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,_Friend,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,_Friend> >,0> >::end, COMDAT
; _this$ = ecx

; 418  : 		return (_TREE_ITERATOR(_Myhead));

  00000	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00003	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  00007	89 08		 mov	 DWORD PTR [eax], ecx

; 419  : 		}

  00009	c2 04 00	 ret	 4
?end@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,_Friend,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,_Friend> >,0> >::end
_TEXT	ENDS
PUBLIC	?begin@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,CGuildMember *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuildMember *> >,0> >::begin
; Function compile flags: /Ogty
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CGuildMember *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuildMember *> >,0> >::begin, COMDAT
; _this$ = ecx

; 408  : 		return (_TREE_ITERATOR(_Lmost()));

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	8b 08		 mov	 ecx, DWORD PTR [eax]
  00005	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 409  : 		}

  0000b	c2 04 00	 ret	 4
?begin@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CGuildMember *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuildMember *> >,0> >::begin
_TEXT	ENDS
PUBLIC	?end@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,CGuildMember *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuildMember *> >,0> >::end
; Function compile flags: /Ogty
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CGuildMember *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuildMember *> >,0> >::end, COMDAT
; _this$ = ecx

; 418  : 		return (_TREE_ITERATOR(_Myhead));

  00000	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00003	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  00007	89 08		 mov	 DWORD PTR [eax], ecx

; 419  : 		}

  00009	c2 04 00	 ret	 4
?end@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CGuildMember *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuildMember *> >,0> >::end
_TEXT	ENDS
PUBLIC	?begin@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE?AViterator@12@XZ ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::begin
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\list
;	COMDAT ?begin@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::begin, COMDAT
; _this$ = ecx

; 377  : 		return (iterator(_Nextnode(_Myhead)));

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	8b 08		 mov	 ecx, DWORD PTR [eax]
  00005	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 378  : 		}

  0000b	c2 04 00	 ret	 4
?begin@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::begin
_TEXT	ENDS
PUBLIC	?end@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE?AViterator@12@XZ ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::end
; Function compile flags: /Ogty
;	COMDAT ?end@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::end, COMDAT
; _this$ = ecx

; 387  : 		return (iterator(_Myhead));

  00000	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00003	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  00007	89 08		 mov	 DWORD PTR [eax], ecx

; 388  : 		}

  00009	c2 04 00	 ret	 4
?end@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::end
_TEXT	ENDS
PUBLIC	?clear@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAEXXZ ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::clear
; Function compile flags: /Ogty
;	COMDAT ?clear@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAEXXZ PROC NEAR ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::clear, COMDAT
; _this$ = ecx

; 610  : 		{	// erase all

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 611  : 		_Nodeptr _Pnext;
; 612  : 		_Nodeptr _Pnode = _Nextnode(_Myhead);

  00003	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00006	8b 01		 mov	 eax, DWORD PTR [ecx]

; 613  : 		_Nextnode(_Myhead) = _Myhead;

  00008	89 09		 mov	 DWORD PTR [ecx], ecx

; 614  : 		_Prevnode(_Myhead) = _Myhead;

  0000a	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0000d	89 49 04	 mov	 DWORD PTR [ecx+4], ecx

; 615  : 		_Mysize = 0;
; 616  : 
; 617  : 		for (; _Pnode != _Myhead; _Pnode = _Pnext)

  00010	3b 46 04	 cmp	 eax, DWORD PTR [esi+4]
  00013	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  0001a	74 19		 je	 SHORT $L286765
  0001c	57		 push	 edi
  0001d	8d 49 00	 npad	 3
$L286763:

; 618  : 			{	// delete an element
; 619  : 			_Pnext = _Nextnode(_Pnode);

  00020	8b 38		 mov	 edi, DWORD PTR [eax]

; 620  : 			this->_Alnod.destroy(_Pnode);
; 621  : 			this->_Alnod.deallocate(_Pnode, 1);

  00022	50		 push	 eax
  00023	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00028	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0002b	83 c4 04	 add	 esp, 4
  0002e	3b f9		 cmp	 edi, ecx
  00030	8b c7		 mov	 eax, edi
  00032	75 ec		 jne	 SHORT $L286763
  00034	5f		 pop	 edi
$L286765:
  00035	5e		 pop	 esi

; 622  : 			}
; 623  : 		}

  00036	c3		 ret	 0
?clear@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAEXXZ ENDP ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::clear
_TEXT	ENDS
PUBLIC	??Diterator@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEAAPAU__JOINPLAYER@CGuildCombat@@XZ ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::iterator::operator*
; Function compile flags: /Ogty
;	COMDAT ??Diterator@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEAAPAU__JOINPLAYER@CGuildCombat@@XZ
_TEXT	SEGMENT
??Diterator@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEAAPAU__JOINPLAYER@CGuildCombat@@XZ PROC NEAR ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::iterator::operator*, COMDAT
; _this$ = ecx

; 240  : 			return ((reference)**(const_iterator *)this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 08	 add	 eax, 8

; 241  : 			}

  00005	c3		 ret	 0
??Diterator@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEAAPAU__JOINPLAYER@CGuildCombat@@XZ ENDP ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::iterator::operator*
_TEXT	ENDS
PUBLIC	?begin@?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@QAE?AViterator@12@XZ ; std::list<CUser *,std::allocator<CUser *> >::begin
; Function compile flags: /Ogty
;	COMDAT ?begin@?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::list<CUser *,std::allocator<CUser *> >::begin, COMDAT
; _this$ = ecx

; 377  : 		return (iterator(_Nextnode(_Myhead)));

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	8b 08		 mov	 ecx, DWORD PTR [eax]
  00005	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 378  : 		}

  0000b	c2 04 00	 ret	 4
?begin@?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::list<CUser *,std::allocator<CUser *> >::begin
_TEXT	ENDS
PUBLIC	?end@?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@QAE?AViterator@12@XZ ; std::list<CUser *,std::allocator<CUser *> >::end
; Function compile flags: /Ogty
;	COMDAT ?end@?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::list<CUser *,std::allocator<CUser *> >::end, COMDAT
; _this$ = ecx

; 387  : 		return (iterator(_Myhead));

  00000	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00003	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  00007	89 08		 mov	 DWORD PTR [eax], ecx

; 388  : 		}

  00009	c2 04 00	 ret	 4
?end@?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::list<CUser *,std::allocator<CUser *> >::end
_TEXT	ENDS
PUBLIC	?clear@?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@QAEXXZ ; std::list<CUser *,std::allocator<CUser *> >::clear
; Function compile flags: /Ogty
;	COMDAT ?clear@?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@QAEXXZ PROC NEAR ; std::list<CUser *,std::allocator<CUser *> >::clear, COMDAT
; _this$ = ecx

; 610  : 		{	// erase all

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 611  : 		_Nodeptr _Pnext;
; 612  : 		_Nodeptr _Pnode = _Nextnode(_Myhead);

  00003	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00006	8b 01		 mov	 eax, DWORD PTR [ecx]

; 613  : 		_Nextnode(_Myhead) = _Myhead;

  00008	89 09		 mov	 DWORD PTR [ecx], ecx

; 614  : 		_Prevnode(_Myhead) = _Myhead;

  0000a	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0000d	89 49 04	 mov	 DWORD PTR [ecx+4], ecx

; 615  : 		_Mysize = 0;
; 616  : 
; 617  : 		for (; _Pnode != _Myhead; _Pnode = _Pnext)

  00010	3b 46 04	 cmp	 eax, DWORD PTR [esi+4]
  00013	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  0001a	74 19		 je	 SHORT $L288349
  0001c	57		 push	 edi
  0001d	8d 49 00	 npad	 3
$L288347:

; 618  : 			{	// delete an element
; 619  : 			_Pnext = _Nextnode(_Pnode);

  00020	8b 38		 mov	 edi, DWORD PTR [eax]

; 620  : 			this->_Alnod.destroy(_Pnode);
; 621  : 			this->_Alnod.deallocate(_Pnode, 1);

  00022	50		 push	 eax
  00023	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00028	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0002b	83 c4 04	 add	 esp, 4
  0002e	3b f9		 cmp	 edi, ecx
  00030	8b c7		 mov	 eax, edi
  00032	75 ec		 jne	 SHORT $L288347
  00034	5f		 pop	 edi
$L288349:
  00035	5e		 pop	 esi

; 622  : 			}
; 623  : 		}

  00036	c3		 ret	 0
?clear@?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@QAEXXZ ENDP ; std::list<CUser *,std::allocator<CUser *> >::clear
_TEXT	ENDS
PUBLIC	??Diterator@?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@QBEAAPAVCUser@@XZ ; std::list<CUser *,std::allocator<CUser *> >::iterator::operator*
; Function compile flags: /Ogty
;	COMDAT ??Diterator@?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@QBEAAPAVCUser@@XZ
_TEXT	SEGMENT
??Diterator@?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@QBEAAPAVCUser@@XZ PROC NEAR ; std::list<CUser *,std::allocator<CUser *> >::iterator::operator*, COMDAT
; _this$ = ecx

; 240  : 			return ((reference)**(const_iterator *)this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 08	 add	 eax, 8

; 241  : 			}

  00005	c3		 ret	 0
??Diterator@?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@QBEAAPAVCUser@@XZ ENDP ; std::list<CUser *,std::allocator<CUser *> >::iterator::operator*
_TEXT	ENDS
PUBLIC	?begin@?$vector@KV?$allocator@K@std@@@std@@QAE?AViterator@12@XZ ; std::vector<unsigned long,std::allocator<unsigned long> >::begin
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ?begin@?$vector@KV?$allocator@K@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@KV?$allocator@K@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::vector<unsigned long,std::allocator<unsigned long> >::begin, COMDAT
; _this$ = ecx

; 463  : 		return (iterator(_Myfirst));

  00000	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00003	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  00007	89 08		 mov	 DWORD PTR [eax], ecx

; 464  : 		}

  00009	c2 04 00	 ret	 4
?begin@?$vector@KV?$allocator@K@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::vector<unsigned long,std::allocator<unsigned long> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@KV?$allocator@K@std@@@std@@QAE?AViterator@12@XZ ; std::vector<unsigned long,std::allocator<unsigned long> >::end
; Function compile flags: /Ogty
;	COMDAT ?end@?$vector@KV?$allocator@K@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@KV?$allocator@K@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::vector<unsigned long,std::allocator<unsigned long> >::end, COMDAT
; _this$ = ecx

; 473  : 		return (iterator(_Mylast));

  00000	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  00003	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  00007	89 08		 mov	 DWORD PTR [eax], ecx

; 474  : 		}

  00009	c2 04 00	 ret	 4
?end@?$vector@KV?$allocator@K@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::vector<unsigned long,std::allocator<unsigned long> >::end
_TEXT	ENDS
PUBLIC	?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AViterator@12@XZ ; std::vector<int,std::allocator<int> >::begin
; Function compile flags: /Ogty
;	COMDAT ?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::vector<int,std::allocator<int> >::begin, COMDAT
; _this$ = ecx

; 463  : 		return (iterator(_Myfirst));

  00000	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00003	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  00007	89 08		 mov	 DWORD PTR [eax], ecx

; 464  : 		}

  00009	c2 04 00	 ret	 4
?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::vector<int,std::allocator<int> >::begin
_TEXT	ENDS
PUBLIC	?begin@?$vector@EV?$allocator@E@std@@@std@@QAE?AViterator@12@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::begin
; Function compile flags: /Ogty
;	COMDAT ?begin@?$vector@EV?$allocator@E@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@EV?$allocator@E@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::vector<unsigned char,std::allocator<unsigned char> >::begin, COMDAT
; _this$ = ecx

; 463  : 		return (iterator(_Myfirst));

  00000	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00003	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  00007	89 08		 mov	 DWORD PTR [eax], ecx

; 464  : 		}

  00009	c2 04 00	 ret	 4
?begin@?$vector@EV?$allocator@E@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::begin
_TEXT	ENDS
PUBLIC	?begin@?$vector@VCGuildCombat1to1@@V?$allocator@VCGuildCombat1to1@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<CGuildCombat1to1,std::allocator<CGuildCombat1to1> >::begin
; Function compile flags: /Ogty
;	COMDAT ?begin@?$vector@VCGuildCombat1to1@@V?$allocator@VCGuildCombat1to1@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@VCGuildCombat1to1@@V?$allocator@VCGuildCombat1to1@@@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::vector<CGuildCombat1to1,std::allocator<CGuildCombat1to1> >::begin, COMDAT
; _this$ = ecx

; 463  : 		return (iterator(_Myfirst));

  00000	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00003	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  00007	89 08		 mov	 DWORD PTR [eax], ecx

; 464  : 		}

  00009	c2 04 00	 ret	 4
?begin@?$vector@VCGuildCombat1to1@@V?$allocator@VCGuildCombat1to1@@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::vector<CGuildCombat1to1,std::allocator<CGuildCombat1to1> >::begin
_TEXT	ENDS
PUBLIC	?begin@?$vector@U__GC1TO1TENDER@CGuildCombat1to1Mng@@V?$allocator@U__GC1TO1TENDER@CGuildCombat1to1Mng@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<CGuildCombat1to1Mng::__GC1TO1TENDER,std::allocator<CGuildCombat1to1Mng::__GC1TO1TENDER> >::begin
; Function compile flags: /Ogty
;	COMDAT ?begin@?$vector@U__GC1TO1TENDER@CGuildCombat1to1Mng@@V?$allocator@U__GC1TO1TENDER@CGuildCombat1to1Mng@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@U__GC1TO1TENDER@CGuildCombat1to1Mng@@V?$allocator@U__GC1TO1TENDER@CGuildCombat1to1Mng@@@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::vector<CGuildCombat1to1Mng::__GC1TO1TENDER,std::allocator<CGuildCombat1to1Mng::__GC1TO1TENDER> >::begin, COMDAT
; _this$ = ecx

; 463  : 		return (iterator(_Myfirst));

  00000	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00003	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  00007	89 08		 mov	 DWORD PTR [eax], ecx

; 464  : 		}

  00009	c2 04 00	 ret	 4
?begin@?$vector@U__GC1TO1TENDER@CGuildCombat1to1Mng@@V?$allocator@U__GC1TO1TENDER@CGuildCombat1to1Mng@@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::vector<CGuildCombat1to1Mng::__GC1TO1TENDER,std::allocator<CGuildCombat1to1Mng::__GC1TO1TENDER> >::begin
_TEXT	ENDS
PUBLIC	??Diterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBEAAU?$pair@$$CBHH@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::iterator::operator*
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ??Diterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBEAAU?$pair@$$CBHH@2@XZ
_TEXT	SEGMENT
??Diterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBEAAU?$pair@$$CBHH@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::iterator::operator*, COMDAT
; _this$ = ecx

; 317  : 			return ((reference)**(const_iterator *)this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 0c	 add	 eax, 12			; 0000000cH

; 318  : 			}

  00005	c3		 ret	 0
??Diterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBEAAU?$pair@$$CBHH@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::iterator::operator*
_TEXT	ENDS
PUBLIC	??Diterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QBEAAU?$pair@$$CBKU_Friend@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,_Friend,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,_Friend> >,0> >::iterator::operator*
; Function compile flags: /Ogty
;	COMDAT ??Diterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QBEAAU?$pair@$$CBKU_Friend@@@2@XZ
_TEXT	SEGMENT
??Diterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QBEAAU?$pair@$$CBKU_Friend@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,_Friend,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,_Friend> >,0> >::iterator::operator*, COMDAT
; _this$ = ecx

; 317  : 			return ((reference)**(const_iterator *)this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 0c	 add	 eax, 12			; 0000000cH

; 318  : 			}

  00005	c3		 ret	 0
??Diterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QBEAAU?$pair@$$CBKU_Friend@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,_Friend,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,_Friend> >,0> >::iterator::operator*
_TEXT	ENDS
PUBLIC	??Econst_iterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,_Friend,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,_Friend> >,0> >::const_iterator::operator++
; Function compile flags: /Ogty
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??Econst_iterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,_Friend,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,_Friend> >,0> >::const_iterator::operator++, COMDAT
; _this$ = ecx

; 214  : 			{	// preincrement

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 215  : 			_Inc();

  00003	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned long,_Friend,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,_Friend> >,0> >::const_iterator::_Inc

; 216  : 			return (*this);

  00008	8b c6		 mov	 eax, esi
  0000a	5e		 pop	 esi

; 217  : 			}

  0000b	c3		 ret	 0
??Econst_iterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,_Friend,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,_Friend> >,0> >::const_iterator::operator++
_TEXT	ENDS
PUBLIC	?begin@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::begin
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ?begin@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::vector<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::begin, COMDAT
; _this$ = ecx

; 463  : 		return (iterator(_Myfirst));

  00000	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00003	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  00007	89 08		 mov	 DWORD PTR [eax], ecx

; 464  : 		}

  00009	c2 04 00	 ret	 4
?begin@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::vector<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::begin
_TEXT	ENDS
PUBLIC	?_Buynode@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAEPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@XZ ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Buynode
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\list
;	COMDAT ?_Buynode@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAEPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@XZ
_TEXT	SEGMENT
?_Buynode@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAEPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@XZ PROC NEAR ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Buynode, COMDAT
; _this$ = ecx

; 899  : 		_Nodeptr _Pnode = this->_Alnod.allocate(1);

  00000	6a 0c		 push	 12			; 0000000cH
  00002	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00007	83 c4 04	 add	 esp, 4

; 900  : 		int _Linkcnt = 0;
; 901  : 
; 902  : 		_TRY_BEGIN
; 903  : 		this->_Alptr.construct(&_Nextnode(_Pnode), _Pnode);

  0000a	85 c0		 test	 eax, eax
  0000c	74 02		 je	 SHORT $L309723
  0000e	89 00		 mov	 DWORD PTR [eax], eax
$L309723:

; 904  : 		++_Linkcnt;
; 905  : 		this->_Alptr.construct(&_Prevnode(_Pnode), _Pnode);

  00010	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
  00013	85 c9		 test	 ecx, ecx
  00015	74 02		 je	 SHORT $L309751
  00017	89 01		 mov	 DWORD PTR [ecx], eax
$L309751:

; 906  : 		_CATCH_ALL
; 907  : 		if (0 < _Linkcnt)
; 908  : 			this->_Alptr.destroy(&_Nextnode(_Pnode));
; 909  : 		this->_Alnod.deallocate(_Pnode, 1);
; 910  : 		_RERAISE;
; 911  : 		_CATCH_END
; 912  : 		return (_Pnode);
; 913  : 		}

  00019	c3		 ret	 0
?_Buynode@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAEPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@XZ ENDP ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Buynode
_TEXT	ENDS
PUBLIC	?_Tidy@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAEXXZ ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Tidy
; Function compile flags: /Ogty
;	COMDAT ?_Tidy@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAEXXZ PROC NEAR ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Tidy, COMDAT
; _this$ = ecx

; 929  : 		{	// free all storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 930  : 		clear();

  00003	e8 00 00 00 00	 call	 ?clear@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAEXXZ ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::clear

; 931  : 		this->_Alptr.destroy(&_Nextnode(_Myhead));
; 932  : 		this->_Alptr.destroy(&_Prevnode(_Myhead));
; 933  : 		this->_Alnod.deallocate(_Myhead, 1);

  00008	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00011	83 c4 04	 add	 esp, 4

; 934  : 		_Myhead = 0;

  00014	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  0001b	5e		 pop	 esi

; 935  : 		}

  0001c	c3		 ret	 0
?_Tidy@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAEXXZ ENDP ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Tidy
_TEXT	ENDS
PUBLIC	?begin@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<CGuildCombat::__GCGETPOINT,std::allocator<CGuildCombat::__GCGETPOINT> >::begin
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ?begin@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::vector<CGuildCombat::__GCGETPOINT,std::allocator<CGuildCombat::__GCGETPOINT> >::begin, COMDAT
; _this$ = ecx

; 463  : 		return (iterator(_Myfirst));

  00000	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00003	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  00007	89 08		 mov	 DWORD PTR [eax], ecx

; 464  : 		}

  00009	c2 04 00	 ret	 4
?begin@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::vector<CGuildCombat::__GCGETPOINT,std::allocator<CGuildCombat::__GCGETPOINT> >::begin
_TEXT	ENDS
PUBLIC	?begin@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<CGuildCombat::__GCPLAYERPOINT,std::allocator<CGuildCombat::__GCPLAYERPOINT> >::begin
; Function compile flags: /Ogty
;	COMDAT ?begin@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::vector<CGuildCombat::__GCPLAYERPOINT,std::allocator<CGuildCombat::__GCPLAYERPOINT> >::begin, COMDAT
; _this$ = ecx

; 463  : 		return (iterator(_Myfirst));

  00000	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00003	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  00007	89 08		 mov	 DWORD PTR [eax], ecx

; 464  : 		}

  00009	c2 04 00	 ret	 4
?begin@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::vector<CGuildCombat::__GCPLAYERPOINT,std::allocator<CGuildCombat::__GCPLAYERPOINT> >::begin
_TEXT	ENDS
PUBLIC	?begin@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<CGuildCombat::__GuildCombatMember *,std::allocator<CGuildCombat::__GuildCombatMember *> >::begin
; Function compile flags: /Ogty
;	COMDAT ?begin@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::vector<CGuildCombat::__GuildCombatMember *,std::allocator<CGuildCombat::__GuildCombatMember *> >::begin, COMDAT
; _this$ = ecx

; 463  : 		return (iterator(_Myfirst));

  00000	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00003	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  00007	89 08		 mov	 DWORD PTR [eax], ecx

; 464  : 		}

  00009	c2 04 00	 ret	 4
?begin@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::vector<CGuildCombat::__GuildCombatMember *,std::allocator<CGuildCombat::__GuildCombatMember *> >::begin
_TEXT	ENDS
PUBLIC	?begin@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::begin
; Function compile flags: /Ogty
;	COMDAT ?begin@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::begin, COMDAT
; _this$ = ecx

; 463  : 		return (iterator(_Myfirst));

  00000	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00003	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  00007	89 08		 mov	 DWORD PTR [eax], ecx

; 464  : 		}

  00009	c2 04 00	 ret	 4
?begin@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::begin
_TEXT	ENDS
PUBLIC	?begin@?$vector@U__SECRETROOM_TENDER@@V?$allocator@U__SECRETROOM_TENDER@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<__SECRETROOM_TENDER,std::allocator<__SECRETROOM_TENDER> >::begin
; Function compile flags: /Ogty
;	COMDAT ?begin@?$vector@U__SECRETROOM_TENDER@@V?$allocator@U__SECRETROOM_TENDER@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@U__SECRETROOM_TENDER@@V?$allocator@U__SECRETROOM_TENDER@@@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::vector<__SECRETROOM_TENDER,std::allocator<__SECRETROOM_TENDER> >::begin, COMDAT
; _this$ = ecx

; 463  : 		return (iterator(_Myfirst));

  00000	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00003	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  00007	89 08		 mov	 DWORD PTR [eax], ecx

; 464  : 		}

  00009	c2 04 00	 ret	 4
?begin@?$vector@U__SECRETROOM_TENDER@@V?$allocator@U__SECRETROOM_TENDER@@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::vector<__SECRETROOM_TENDER,std::allocator<__SECRETROOM_TENDER> >::begin
_TEXT	ENDS
PUBLIC	?begin@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AViterator@12@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::begin
; Function compile flags: /Ogty
;	COMDAT ?begin@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::begin, COMDAT
; _this$ = ecx

; 463  : 		return (iterator(_Myfirst));

  00000	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00003	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  00007	89 08		 mov	 DWORD PTR [eax], ecx

; 464  : 		}

  00009	c2 04 00	 ret	 4
?begin@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AViterator@12@XZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AViterator@12@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::end
; Function compile flags: /Ogty
;	COMDAT ?end@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::end, COMDAT
; _this$ = ecx

; 473  : 		return (iterator(_Mylast));

  00000	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  00003	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  00007	89 08		 mov	 DWORD PTR [eax], ecx

; 474  : 		}

  00009	c2 04 00	 ret	 4
?end@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AViterator@12@XZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::end
_TEXT	ENDS
PUBLIC	??Diterator@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@QBEAAU?$pair@$$CBKPAVCGuildMember@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,CGuildMember *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuildMember *> >,0> >::iterator::operator*
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ??Diterator@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@QBEAAU?$pair@$$CBKPAVCGuildMember@@@2@XZ
_TEXT	SEGMENT
??Diterator@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@QBEAAU?$pair@$$CBKPAVCGuildMember@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CGuildMember *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuildMember *> >,0> >::iterator::operator*, COMDAT
; _this$ = ecx

; 317  : 			return ((reference)**(const_iterator *)this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 0c	 add	 eax, 12			; 0000000cH

; 318  : 			}

  00005	c3		 ret	 0
??Diterator@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@QBEAAU?$pair@$$CBKPAVCGuildMember@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CGuildMember *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuildMember *> >,0> >::iterator::operator*
_TEXT	ENDS
PUBLIC	??Econst_iterator@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,CGuildMember *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuildMember *> >,0> >::const_iterator::operator++
; Function compile flags: /Ogty
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??Econst_iterator@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CGuildMember *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuildMember *> >,0> >::const_iterator::operator++, COMDAT
; _this$ = ecx

; 214  : 			{	// preincrement

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 215  : 			_Inc();

  00003	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned long,CGuildMember *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuildMember *> >,0> >::const_iterator::_Inc

; 216  : 			return (*this);

  00008	8b c6		 mov	 eax, esi
  0000a	5e		 pop	 esi

; 217  : 			}

  0000b	c3		 ret	 0
??Econst_iterator@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CGuildMember *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuildMember *> >,0> >::const_iterator::operator++
_TEXT	ENDS
PUBLIC	??Diterator@?$_Tree@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@std@@QBEAAU?$pair@$$CBKPAVCParty@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,CParty *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CParty *> >,0> >::iterator::operator*
; Function compile flags: /Ogty
;	COMDAT ??Diterator@?$_Tree@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@std@@QBEAAU?$pair@$$CBKPAVCParty@@@2@XZ
_TEXT	SEGMENT
??Diterator@?$_Tree@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@std@@QBEAAU?$pair@$$CBKPAVCParty@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CParty *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CParty *> >,0> >::iterator::operator*, COMDAT
; _this$ = ecx

; 317  : 			return ((reference)**(const_iterator *)this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 0c	 add	 eax, 12			; 0000000cH

; 318  : 			}

  00005	c3		 ret	 0
??Diterator@?$_Tree@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@std@@QBEAAU?$pair@$$CBKPAVCParty@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CParty *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CParty *> >,0> >::iterator::operator*
_TEXT	ENDS
PUBLIC	??Econst_iterator@?$_Tree@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,CParty *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CParty *> >,0> >::const_iterator::operator++
; Function compile flags: /Ogty
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??Econst_iterator@?$_Tree@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CParty *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CParty *> >,0> >::const_iterator::operator++, COMDAT
; _this$ = ecx

; 214  : 			{	// preincrement

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 215  : 			_Inc();

  00003	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned long,CParty *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CParty *> >,0> >::const_iterator::_Inc

; 216  : 			return (*this);

  00008	8b c6		 mov	 eax, esi
  0000a	5e		 pop	 esi

; 217  : 			}

  0000b	c3		 ret	 0
??Econst_iterator@?$_Tree@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CParty *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CParty *> >,0> >::const_iterator::operator++
_TEXT	ENDS
PUBLIC	?begin@?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<CGuildCombat::__JOINPLAYER,std::allocator<CGuildCombat::__JOINPLAYER> >::begin
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ?begin@?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::vector<CGuildCombat::__JOINPLAYER,std::allocator<CGuildCombat::__JOINPLAYER> >::begin, COMDAT
; _this$ = ecx

; 463  : 		return (iterator(_Myfirst));

  00000	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00003	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  00007	89 08		 mov	 DWORD PTR [eax], ecx

; 464  : 		}

  00009	c2 04 00	 ret	 4
?begin@?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::vector<CGuildCombat::__JOINPLAYER,std::allocator<CGuildCombat::__JOINPLAYER> >::begin
_TEXT	ENDS
PUBLIC	?_Buynode@?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@IAEPAU_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@2@XZ ; std::list<CUser *,std::allocator<CUser *> >::_Buynode
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\list
;	COMDAT ?_Buynode@?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@IAEPAU_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@2@XZ
_TEXT	SEGMENT
?_Buynode@?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@IAEPAU_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@2@XZ PROC NEAR ; std::list<CUser *,std::allocator<CUser *> >::_Buynode, COMDAT
; _this$ = ecx

; 899  : 		_Nodeptr _Pnode = this->_Alnod.allocate(1);

  00000	6a 0c		 push	 12			; 0000000cH
  00002	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00007	83 c4 04	 add	 esp, 4

; 900  : 		int _Linkcnt = 0;
; 901  : 
; 902  : 		_TRY_BEGIN
; 903  : 		this->_Alptr.construct(&_Nextnode(_Pnode), _Pnode);

  0000a	85 c0		 test	 eax, eax
  0000c	74 02		 je	 SHORT $L309940
  0000e	89 00		 mov	 DWORD PTR [eax], eax
$L309940:

; 904  : 		++_Linkcnt;
; 905  : 		this->_Alptr.construct(&_Prevnode(_Pnode), _Pnode);

  00010	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
  00013	85 c9		 test	 ecx, ecx
  00015	74 02		 je	 SHORT $L309969
  00017	89 01		 mov	 DWORD PTR [ecx], eax
$L309969:

; 906  : 		_CATCH_ALL
; 907  : 		if (0 < _Linkcnt)
; 908  : 			this->_Alptr.destroy(&_Nextnode(_Pnode));
; 909  : 		this->_Alnod.deallocate(_Pnode, 1);
; 910  : 		_RERAISE;
; 911  : 		_CATCH_END
; 912  : 		return (_Pnode);
; 913  : 		}

  00019	c3		 ret	 0
?_Buynode@?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@IAEPAU_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@2@XZ ENDP ; std::list<CUser *,std::allocator<CUser *> >::_Buynode
_TEXT	ENDS
PUBLIC	?_Tidy@?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@IAEXXZ ; std::list<CUser *,std::allocator<CUser *> >::_Tidy
; Function compile flags: /Ogty
;	COMDAT ?_Tidy@?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@IAEXXZ PROC NEAR ; std::list<CUser *,std::allocator<CUser *> >::_Tidy, COMDAT
; _this$ = ecx

; 929  : 		{	// free all storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 930  : 		clear();

  00003	e8 00 00 00 00	 call	 ?clear@?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@QAEXXZ ; std::list<CUser *,std::allocator<CUser *> >::clear

; 931  : 		this->_Alptr.destroy(&_Nextnode(_Myhead));
; 932  : 		this->_Alptr.destroy(&_Prevnode(_Myhead));
; 933  : 		this->_Alnod.deallocate(_Myhead, 1);

  00008	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00011	83 c4 04	 add	 esp, 4

; 934  : 		_Myhead = 0;

  00014	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  0001b	5e		 pop	 esi

; 935  : 		}

  0001c	c3		 ret	 0
?_Tidy@?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@IAEXXZ ENDP ; std::list<CUser *,std::allocator<CUser *> >::_Tidy
_TEXT	ENDS
PUBLIC	?begin@?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<__ITEMINFO,std::allocator<__ITEMINFO> >::begin
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ?begin@?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::vector<__ITEMINFO,std::allocator<__ITEMINFO> >::begin, COMDAT
; _this$ = ecx

; 463  : 		return (iterator(_Myfirst));

  00000	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00003	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  00007	89 08		 mov	 DWORD PTR [eax], ecx

; 464  : 		}

  00009	c2 04 00	 ret	 4
?begin@?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::vector<__ITEMINFO,std::allocator<__ITEMINFO> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<__ITEMINFO,std::allocator<__ITEMINFO> >::end
; Function compile flags: /Ogty
;	COMDAT ?end@?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::vector<__ITEMINFO,std::allocator<__ITEMINFO> >::end, COMDAT
; _this$ = ecx

; 473  : 		return (iterator(_Mylast));

  00000	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  00003	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  00007	89 08		 mov	 DWORD PTR [eax], ecx

; 474  : 		}

  00009	c2 04 00	 ret	 4
?end@?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::vector<__ITEMINFO,std::allocator<__ITEMINFO> >::end
_TEXT	ENDS
PUBLIC	?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Buynode
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Buynode, COMDAT
; _this$ = ecx

; 1106 : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

  00000	6a 18		 push	 24			; 00000018H
  00002	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00007	83 c4 04	 add	 esp, 4

; 1107 : 		int _Linkcnt = 0;
; 1108 : 
; 1109 : 		_TRY_BEGIN
; 1110 : 		this->_Alptr.construct(&_Left(_Wherenode), 0);

  0000a	85 c0		 test	 eax, eax
  0000c	74 06		 je	 SHORT $L310060
  0000e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
$L310060:

; 1111 : 		++_Linkcnt;
; 1112 : 		this->_Alptr.construct(&_Parent(_Wherenode), 0);

  00014	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
  00017	85 c9		 test	 ecx, ecx
  00019	74 06		 je	 SHORT $L310087
  0001b	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
$L310087:

; 1113 : 		++_Linkcnt;
; 1114 : 		this->_Alptr.construct(&_Right(_Wherenode), 0);

  00021	8d 48 08	 lea	 ecx, DWORD PTR [eax+8]
  00024	85 c9		 test	 ecx, ecx
  00026	74 06		 je	 SHORT $L310114
  00028	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
$L310114:

; 1115 : 		_CATCH_ALL
; 1116 : 		if (1 < _Linkcnt)
; 1117 : 			this->_Alptr.destroy(&_Parent(_Wherenode));
; 1118 : 		if (0 < _Linkcnt)
; 1119 : 			this->_Alptr.destroy(&_Left(_Wherenode));
; 1120 : 		this->_Alnod.deallocate(_Wherenode, 1);
; 1121 : 		_RERAISE;
; 1122 : 		_CATCH_END
; 1123 : 		_Color(_Wherenode) = _Black;

  0002e	c6 40 14 01	 mov	 BYTE PTR [eax+20], 1

; 1124 : 		_Isnil(_Wherenode) = false;

  00032	c6 40 15 00	 mov	 BYTE PTR [eax+21], 0

; 1125 : 		return (_Wherenode);
; 1126 : 		}

  00036	c3		 ret	 0
?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Buynode
_TEXT	ENDS
PUBLIC	??0?$_Tree_ptr@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z ; std::_Tree_ptr<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Tree_ptr<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >
; Function compile flags: /Ogty
;	COMDAT ??0?$_Tree_ptr@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 1
??0?$_Tree_ptr@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z PROC NEAR ; std::_Tree_ptr<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Tree_ptr<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >, COMDAT
; _this$ = ecx

; 76   : 		{	// construct base, and allocator from _Al

  00000	8b c1		 mov	 eax, ecx

; 77   : 		}

  00002	c2 08 00	 ret	 8
??0?$_Tree_ptr@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z ENDP ; std::_Tree_ptr<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Tree_ptr<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >
_TEXT	ENDS
PUBLIC	?_Buynode@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAEPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@PAU342@0ABQAU__JOINPLAYER@CGuildCombat@@@Z ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Buynode
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\list
;	COMDAT ?_Buynode@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAEPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@PAU342@0ABQAU__JOINPLAYER@CGuildCombat@@@Z
_TEXT	SEGMENT
__Next$ = 8						; size = 4
__Prev$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Buynode@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAEPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@PAU342@0ABQAU__JOINPLAYER@CGuildCombat@@@Z PROC NEAR ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Buynode, COMDAT
; _this$ = ecx

; 918  : 		_Nodeptr _Pnode = this->_Alnod.allocate(1);

  00000	6a 0c		 push	 12			; 0000000cH
  00002	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00007	83 c4 04	 add	 esp, 4

; 919  : 		_TRY_BEGIN
; 920  : 		new ((void *)_Pnode) _Node(_Next, _Prev, _Val);

  0000a	85 c0		 test	 eax, eax
  0000c	74 16		 je	 SHORT $L310166
  0000e	8b 4c 24 04	 mov	 ecx, DWORD PTR __Next$[esp-4]
  00012	8b 54 24 08	 mov	 edx, DWORD PTR __Prev$[esp-4]
  00016	89 08		 mov	 DWORD PTR [eax], ecx
  00018	8b 4c 24 0c	 mov	 ecx, DWORD PTR __Val$[esp-4]
  0001c	89 50 04	 mov	 DWORD PTR [eax+4], edx
  0001f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00021	89 50 08	 mov	 DWORD PTR [eax+8], edx
$L310166:

; 921  : 		_CATCH_ALL
; 922  : 		this->_Alnod.deallocate(_Pnode, 1);
; 923  : 		_RERAISE;
; 924  : 		_CATCH_END
; 925  : 		return (_Pnode);
; 926  : 		}

  00024	c2 0c 00	 ret	 12			; 0000000cH
?_Buynode@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAEPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@PAU342@0ABQAU__JOINPLAYER@CGuildCombat@@@Z ENDP ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Buynode
_TEXT	ENDS
PUBLIC	??0?$_List_ptr@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAE@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@1@@Z ; std::_List_ptr<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_List_ptr<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >
; Function compile flags: /Ogty
;	COMDAT ??0?$_List_ptr@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAE@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_List_ptr@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAE@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@1@@Z PROC NEAR ; std::_List_ptr<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_List_ptr<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >, COMDAT
; _this$ = ecx

; 64   : 		{	// construct base, and allocator from _Al

  00000	8b c1		 mov	 eax, ecx

; 65   : 		}

  00002	c2 04 00	 ret	 4
??0?$_List_ptr@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAE@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@1@@Z ENDP ; std::_List_ptr<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_List_ptr<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >
_TEXT	ENDS
PUBLIC	?_Buynode@?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@IAEPAU_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@2@PAU342@0ABQAVCUser@@@Z ; std::list<CUser *,std::allocator<CUser *> >::_Buynode
; Function compile flags: /Ogty
;	COMDAT ?_Buynode@?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@IAEPAU_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@2@PAU342@0ABQAVCUser@@@Z
_TEXT	SEGMENT
__Next$ = 8						; size = 4
__Prev$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Buynode@?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@IAEPAU_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@2@PAU342@0ABQAVCUser@@@Z PROC NEAR ; std::list<CUser *,std::allocator<CUser *> >::_Buynode, COMDAT
; _this$ = ecx

; 918  : 		_Nodeptr _Pnode = this->_Alnod.allocate(1);

  00000	6a 0c		 push	 12			; 0000000cH
  00002	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00007	83 c4 04	 add	 esp, 4

; 919  : 		_TRY_BEGIN
; 920  : 		new ((void *)_Pnode) _Node(_Next, _Prev, _Val);

  0000a	85 c0		 test	 eax, eax
  0000c	74 16		 je	 SHORT $L310216
  0000e	8b 4c 24 04	 mov	 ecx, DWORD PTR __Next$[esp-4]
  00012	8b 54 24 08	 mov	 edx, DWORD PTR __Prev$[esp-4]
  00016	89 08		 mov	 DWORD PTR [eax], ecx
  00018	8b 4c 24 0c	 mov	 ecx, DWORD PTR __Val$[esp-4]
  0001c	89 50 04	 mov	 DWORD PTR [eax+4], edx
  0001f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00021	89 50 08	 mov	 DWORD PTR [eax+8], edx
$L310216:

; 921  : 		_CATCH_ALL
; 922  : 		this->_Alnod.deallocate(_Pnode, 1);
; 923  : 		_RERAISE;
; 924  : 		_CATCH_END
; 925  : 		return (_Pnode);
; 926  : 		}

  00024	c2 0c 00	 ret	 12			; 0000000cH
?_Buynode@?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@IAEPAU_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@2@PAU342@0ABQAVCUser@@@Z ENDP ; std::list<CUser *,std::allocator<CUser *> >::_Buynode
_TEXT	ENDS
PUBLIC	??0?$_List_ptr@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@IAE@V?$allocator@PAVCUser@@@1@@Z ; std::_List_ptr<CUser *,std::allocator<CUser *> >::_List_ptr<CUser *,std::allocator<CUser *> >
; Function compile flags: /Ogty
;	COMDAT ??0?$_List_ptr@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@IAE@V?$allocator@PAVCUser@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_List_ptr@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@IAE@V?$allocator@PAVCUser@@@1@@Z PROC NEAR ; std::_List_ptr<CUser *,std::allocator<CUser *> >::_List_ptr<CUser *,std::allocator<CUser *> >, COMDAT
; _this$ = ecx

; 64   : 		{	// construct base, and allocator from _Al

  00000	8b c1		 mov	 eax, ecx

; 65   : 		}

  00002	c2 04 00	 ret	 4
??0?$_List_ptr@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@IAE@V?$allocator@PAVCUser@@@1@@Z ENDP ; std::_List_ptr<CUser *,std::allocator<CUser *> >::_List_ptr<CUser *,std::allocator<CUser *> >
_TEXT	ENDS
PUBLIC	?_Buynode@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Buynode
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Buynode@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Buynode, COMDAT
; _this$ = ecx

; 1106 : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

  00000	6a 18		 push	 24			; 00000018H
  00002	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00007	83 c4 04	 add	 esp, 4

; 1107 : 		int _Linkcnt = 0;
; 1108 : 
; 1109 : 		_TRY_BEGIN
; 1110 : 		this->_Alptr.construct(&_Left(_Wherenode), 0);

  0000a	85 c0		 test	 eax, eax
  0000c	74 06		 je	 SHORT $L310298
  0000e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
$L310298:

; 1111 : 		++_Linkcnt;
; 1112 : 		this->_Alptr.construct(&_Parent(_Wherenode), 0);

  00014	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
  00017	85 c9		 test	 ecx, ecx
  00019	74 06		 je	 SHORT $L310325
  0001b	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
$L310325:

; 1113 : 		++_Linkcnt;
; 1114 : 		this->_Alptr.construct(&_Right(_Wherenode), 0);

  00021	8d 48 08	 lea	 ecx, DWORD PTR [eax+8]
  00024	85 c9		 test	 ecx, ecx
  00026	74 06		 je	 SHORT $L310352
  00028	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
$L310352:

; 1115 : 		_CATCH_ALL
; 1116 : 		if (1 < _Linkcnt)
; 1117 : 			this->_Alptr.destroy(&_Parent(_Wherenode));
; 1118 : 		if (0 < _Linkcnt)
; 1119 : 			this->_Alptr.destroy(&_Left(_Wherenode));
; 1120 : 		this->_Alnod.deallocate(_Wherenode, 1);
; 1121 : 		_RERAISE;
; 1122 : 		_CATCH_END
; 1123 : 		_Color(_Wherenode) = _Black;

  0002e	c6 40 14 01	 mov	 BYTE PTR [eax+20], 1

; 1124 : 		_Isnil(_Wherenode) = false;

  00032	c6 40 15 00	 mov	 BYTE PTR [eax+21], 0

; 1125 : 		return (_Wherenode);
; 1126 : 		}

  00036	c3		 ret	 0
?_Buynode@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Buynode
_TEXT	ENDS
PUBLIC	??0?$_Tree_ptr@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@K@1@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@1@@Z ; std::_Tree_ptr<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Tree_ptr<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >
; Function compile flags: /Ogty
;	COMDAT ??0?$_Tree_ptr@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@K@1@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 1
??0?$_Tree_ptr@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@K@1@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@1@@Z PROC NEAR ; std::_Tree_ptr<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Tree_ptr<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >, COMDAT
; _this$ = ecx

; 76   : 		{	// construct base, and allocator from _Al

  00000	8b c1		 mov	 eax, ecx

; 77   : 		}

  00002	c2 08 00	 ret	 8
??0?$_Tree_ptr@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@K@1@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@1@@Z ENDP ; std::_Tree_ptr<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Tree_ptr<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >
_TEXT	ENDS
PUBLIC	?_Buynode@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::_Buynode
; Function compile flags: /Ogty
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Buynode@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::_Buynode, COMDAT
; _this$ = ecx

; 1106 : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

  00000	6a 18		 push	 24			; 00000018H
  00002	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00007	83 c4 04	 add	 esp, 4

; 1107 : 		int _Linkcnt = 0;
; 1108 : 
; 1109 : 		_TRY_BEGIN
; 1110 : 		this->_Alptr.construct(&_Left(_Wherenode), 0);

  0000a	85 c0		 test	 eax, eax
  0000c	74 06		 je	 SHORT $L310438
  0000e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
$L310438:

; 1111 : 		++_Linkcnt;
; 1112 : 		this->_Alptr.construct(&_Parent(_Wherenode), 0);

  00014	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
  00017	85 c9		 test	 ecx, ecx
  00019	74 06		 je	 SHORT $L310465
  0001b	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
$L310465:

; 1113 : 		++_Linkcnt;
; 1114 : 		this->_Alptr.construct(&_Right(_Wherenode), 0);

  00021	8d 48 08	 lea	 ecx, DWORD PTR [eax+8]
  00024	85 c9		 test	 ecx, ecx
  00026	74 06		 je	 SHORT $L310492
  00028	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
$L310492:

; 1115 : 		_CATCH_ALL
; 1116 : 		if (1 < _Linkcnt)
; 1117 : 			this->_Alptr.destroy(&_Parent(_Wherenode));
; 1118 : 		if (0 < _Linkcnt)
; 1119 : 			this->_Alptr.destroy(&_Left(_Wherenode));
; 1120 : 		this->_Alnod.deallocate(_Wherenode, 1);
; 1121 : 		_RERAISE;
; 1122 : 		_CATCH_END
; 1123 : 		_Color(_Wherenode) = _Black;

  0002e	c6 40 14 01	 mov	 BYTE PTR [eax+20], 1

; 1124 : 		_Isnil(_Wherenode) = false;

  00032	c6 40 15 00	 mov	 BYTE PTR [eax+21], 0

; 1125 : 		return (_Wherenode);
; 1126 : 		}

  00036	c3		 ret	 0
?_Buynode@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::_Buynode
_TEXT	ENDS
PUBLIC	??0?$_Tree_ptr@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@K@1@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@1@@Z ; std::_Tree_ptr<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::_Tree_ptr<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >
; Function compile flags: /Ogty
;	COMDAT ??0?$_Tree_ptr@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@K@1@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 1
??0?$_Tree_ptr@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@K@1@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@1@@Z PROC NEAR ; std::_Tree_ptr<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::_Tree_ptr<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >, COMDAT
; _this$ = ecx

; 76   : 		{	// construct base, and allocator from _Al

  00000	8b c1		 mov	 eax, ecx

; 77   : 		}

  00002	c2 08 00	 ret	 8
??0?$_Tree_ptr@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@K@1@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@1@@Z ENDP ; std::_Tree_ptr<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::_Tree_ptr<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >
_TEXT	ENDS
PUBLIC	?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHH@2@D@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Buynode
; Function compile flags: /Ogty
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHH@2@D@Z
_TEXT	SEGMENT
__Larg$ = 8						; size = 4
__Parg$ = 12						; size = 4
__Rarg$ = 16						; size = 4
__Val$ = 20						; size = 4
__Carg$ = 24						; size = 1
?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHH@2@D@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Buynode, COMDAT
; _this$ = ecx

; 1131 : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

  00000	6a 18		 push	 24			; 00000018H
  00002	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00007	83 c4 04	 add	 esp, 4

; 1132 : 		_TRY_BEGIN
; 1133 : 		new (_Wherenode) _Node(_Larg, _Parg, _Rarg, _Val, _Carg);

  0000a	85 c0		 test	 eax, eax
  0000c	74 2e		 je	 SHORT $L310544
  0000e	8b 4c 24 04	 mov	 ecx, DWORD PTR __Larg$[esp-4]
  00012	8b 54 24 08	 mov	 edx, DWORD PTR __Parg$[esp-4]
  00016	89 08		 mov	 DWORD PTR [eax], ecx
  00018	8b 4c 24 0c	 mov	 ecx, DWORD PTR __Rarg$[esp-4]
  0001c	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  0001f	8b 4c 24 10	 mov	 ecx, DWORD PTR __Val$[esp-4]
  00023	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00026	8b 11		 mov	 edx, DWORD PTR [ecx]
  00028	89 50 0c	 mov	 DWORD PTR [eax+12], edx
  0002b	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0002e	8a 54 24 14	 mov	 dl, BYTE PTR __Carg$[esp-4]
  00032	89 48 10	 mov	 DWORD PTR [eax+16], ecx
  00035	88 50 14	 mov	 BYTE PTR [eax+20], dl
  00038	c6 40 15 00	 mov	 BYTE PTR [eax+21], 0
$L310544:

; 1134 : 		_CATCH_ALL
; 1135 : 		this->_Alnod.deallocate(_Wherenode, 1);
; 1136 : 		_RERAISE;
; 1137 : 		_CATCH_END
; 1138 : 		return (_Wherenode);
; 1139 : 		}

  0003c	c2 14 00	 ret	 20			; 00000014H
?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHH@2@D@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Buynode
_TEXT	ENDS
PUBLIC	??$_Ucopy@PAK@?$vector@KV?$allocator@K@std@@@std@@IAEPAKPAK00@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::_Ucopy<unsigned long *>
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ??$_Ucopy@PAK@?$vector@KV?$allocator@K@std@@@std@@IAEPAKPAK00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Ucopy@PAK@?$vector@KV?$allocator@K@std@@@std@@IAEPAKPAK00@Z PROC NEAR ; std::vector<unsigned long,std::allocator<unsigned long> >::_Ucopy<unsigned long *>, COMDAT
; _this$ = ecx

; 802  : 		{	// copy initializing [_First, _Last), using allocator
; 803  : 		return (_Uninitialized_copy(_First, _Last,
; 804  : 			_Ptr, this->_Alval));

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR __First$[esp-4]
  00004	8b 44 24 08	 mov	 eax, DWORD PTR __Last$[esp-4]
  00008	2b c1		 sub	 eax, ecx
  0000a	56		 push	 esi
  0000b	c1 f8 02	 sar	 eax, 2
  0000e	8d 34 85 00 00
	00 00		 lea	 esi, DWORD PTR [eax*4]
  00015	8b 44 24 10	 mov	 eax, DWORD PTR __Ptr$[esp]
  00019	56		 push	 esi
  0001a	51		 push	 ecx
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 _memmove
  00021	83 c4 0c	 add	 esp, 12			; 0000000cH
  00024	03 c6		 add	 eax, esi
  00026	5e		 pop	 esi

; 805  : 		}

  00027	c2 0c 00	 ret	 12			; 0000000cH
??$_Ucopy@PAK@?$vector@KV?$allocator@K@std@@@std@@IAEPAKPAK00@Z ENDP ; std::vector<unsigned long,std::allocator<unsigned long> >::_Ucopy<unsigned long *>
_TEXT	ENDS
PUBLIC	??$_Uninitialized_fill_n@PAKIKV?$allocator@K@std@@@std@@YAXPAKIABKAAV?$allocator@K@0@@Z ; std::_Uninitialized_fill_n<unsigned long *,unsigned int,unsigned long,std::allocator<unsigned long> >
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\memory
;	COMDAT ??$_Uninitialized_fill_n@PAKIKV?$allocator@K@std@@@std@@YAXPAKIABKAAV?$allocator@K@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_fill_n@PAKIKV?$allocator@K@std@@@std@@YAXPAKIABKAAV?$allocator@K@0@@Z PROC NEAR ; std::_Uninitialized_fill_n<unsigned long *,unsigned int,unsigned long,std::allocator<unsigned long> >, COMDAT

; 256  : 	_Uninit_fill_n(_First, _Count, _Val, _Al,
; 257  : 		_Ptr_cat(_First, _First));

  00000	8b 4c 24 08	 mov	 ecx, DWORD PTR __Count$[esp-4]
  00004	85 c9		 test	 ecx, ecx
  00006	8b 44 24 04	 mov	 eax, DWORD PTR __First$[esp-4]
  0000a	76 10		 jbe	 SHORT $L310613
  0000c	8b 54 24 0c	 mov	 edx, DWORD PTR __Val$[esp-4]
  00010	56		 push	 esi
$L310611:
  00011	8b 32		 mov	 esi, DWORD PTR [edx]
  00013	89 30		 mov	 DWORD PTR [eax], esi
  00015	83 c0 04	 add	 eax, 4
  00018	49		 dec	 ecx
  00019	75 f6		 jne	 SHORT $L310611
  0001b	5e		 pop	 esi
$L310613:

; 258  : 	}

  0001c	c3		 ret	 0
??$_Uninitialized_fill_n@PAKIKV?$allocator@K@std@@@std@@YAXPAKIABKAAV?$allocator@K@0@@Z ENDP ; std::_Uninitialized_fill_n<unsigned long *,unsigned int,unsigned long,std::allocator<unsigned long> >
_TEXT	ENDS
PUBLIC	?IsEatPet@CItemElem@@QAEHXZ			; CItemElem::IsEatPet
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\item.h
;	COMDAT ?IsEatPet@CItemElem@@QAEHXZ
_TEXT	SEGMENT
?IsEatPet@CItemElem@@QAEHXZ PROC NEAR			; CItemElem::IsEatPet, COMDAT
; _this$ = ecx

; 217  : 	BOOL	IsEatPet( void )	{	return GetProp()->dwItemKind3 == IK3_PET;	}

  00000	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  00003	85 c0		 test	 eax, eax
  00005	8b 0d 5c 02 00
	00		 mov	 ecx, DWORD PTR ?prj@@3VCProject@@A+604
  0000b	7c 1d		 jl	 SHORT $L310670
  0000d	3b c1		 cmp	 eax, ecx
  0000f	7d 19		 jge	 SHORT $L310670
  00011	73 2d		 jae	 SHORT $L310685
  00013	8b 0d 4c 02 00
	00		 mov	 ecx, DWORD PTR ?prj@@3VCProject@@A+588
  00019	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  0001c	8b 48 78	 mov	 ecx, DWORD PTR [eax+120]
  0001f	33 d2		 xor	 edx, edx
  00021	83 f9 64	 cmp	 ecx, 100		; 00000064H
  00024	0f 94 c2	 sete	 dl
  00027	8b c2		 mov	 eax, edx
  00029	c3		 ret	 0
$L310670:
  0002a	50		 push	 eax
  0002b	51		 push	 ecx
  0002c	6a 00		 push	 0
  0002e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BI@BEIFNGEL@GetItemProp?5range_error?$AA@
  00033	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@HMFGHCP@?$CFs?5min?3?$CFd?0?5max?3?$CFd?0?5index?3?$CFd?$AA@
  00038	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  0003d	83 c4 14	 add	 esp, 20			; 00000014H
$L310685:
  00040	33 c0		 xor	 eax, eax
  00042	8b 48 78	 mov	 ecx, DWORD PTR [eax+120]
  00045	33 d2		 xor	 edx, edx
  00047	83 f9 64	 cmp	 ecx, 100		; 00000064H
  0004a	0f 94 c2	 sete	 dl
  0004d	8b c2		 mov	 eax, edx
  0004f	c3		 ret	 0
?IsEatPet@CItemElem@@QAEHXZ ENDP			; CItemElem::IsEatPet
_TEXT	ENDS
PUBLIC	??$_Uninit_fill_n@PAU__ITEMINFO@@IU1@V?$allocator@U__ITEMINFO@@@std@@@std@@YAXPAU__ITEMINFO@@IABU1@AAV?$allocator@U__ITEMINFO@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<__ITEMINFO *,unsigned int,__ITEMINFO,std::allocator<__ITEMINFO> >
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\memory
;	COMDAT ??$_Uninit_fill_n@PAU__ITEMINFO@@IU1@V?$allocator@U__ITEMINFO@@@std@@@std@@YAXPAU__ITEMINFO@@IABU1@AAV?$allocator@U__ITEMINFO@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
??$_Uninit_fill_n@PAU__ITEMINFO@@IU1@V?$allocator@U__ITEMINFO@@@std@@@std@@YAXPAU__ITEMINFO@@IABU1@AAV?$allocator@U__ITEMINFO@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Uninit_fill_n<__ITEMINFO *,unsigned int,__ITEMINFO,std::allocator<__ITEMINFO> >, COMDAT

; 208  : 	_FwdIt _Next = _First;
; 209  : 
; 210  : 	_TRY_BEGIN
; 211  : 	for (; 0 < _Count; --_Count, ++_First)

  00000	8b 44 24 08	 mov	 eax, DWORD PTR __Count$[esp-4]
  00004	85 c0		 test	 eax, eax
  00006	76 2e		 jbe	 SHORT $L293276
  00008	8b 54 24 0c	 mov	 edx, DWORD PTR __Val$[esp-4]
  0000c	53		 push	 ebx
  0000d	56		 push	 esi
  0000e	8b c8		 mov	 ecx, eax
  00010	8b 44 24 0c	 mov	 eax, DWORD PTR __First$[esp+4]
  00014	57		 push	 edi
$L293274:

; 212  : 		_Al.construct(_First, _Val);

  00015	85 c0		 test	 eax, eax
  00017	74 14		 je	 SHORT $L293275
  00019	8b f2		 mov	 esi, edx
  0001b	8b 1e		 mov	 ebx, DWORD PTR [esi]
  0001d	8b f8		 mov	 edi, eax
  0001f	89 1f		 mov	 DWORD PTR [edi], ebx
  00021	8b 5e 04	 mov	 ebx, DWORD PTR [esi+4]
  00024	89 5f 04	 mov	 DWORD PTR [edi+4], ebx
  00027	8b 76 08	 mov	 esi, DWORD PTR [esi+8]
  0002a	89 77 08	 mov	 DWORD PTR [edi+8], esi
$L293275:
  0002d	83 c0 0c	 add	 eax, 12			; 0000000cH
  00030	49		 dec	 ecx
  00031	75 e2		 jne	 SHORT $L293274
  00033	5f		 pop	 edi
  00034	5e		 pop	 esi
  00035	5b		 pop	 ebx
$L293276:

; 213  : 	_CATCH_ALL
; 214  : 	for (; _Next != _First; ++_Next)
; 215  : 		_Al.destroy(_Next);
; 216  : 	_RERAISE;
; 217  : 	_CATCH_END
; 218  : 	}

  00036	c3		 ret	 0
??$_Uninit_fill_n@PAU__ITEMINFO@@IU1@V?$allocator@U__ITEMINFO@@@std@@@std@@YAXPAU__ITEMINFO@@IABU1@AAV?$allocator@U__ITEMINFO@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<__ITEMINFO *,unsigned int,__ITEMINFO,std::allocator<__ITEMINFO> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@YAXPAU__REQUESTGUILD@CGuildCombat@@0AAV?$allocator@U__REQUESTGUILD@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??$_Destroy_range@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@YAXPAU__REQUESTGUILD@CGuildCombat@@0AAV?$allocator@U__REQUESTGUILD@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@YAXPAU__REQUESTGUILD@CGuildCombat@@0AAV?$allocator@U__REQUESTGUILD@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Destroy_range<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >, COMDAT

; 225  : 	for (; _First != _Last; ++_First)
; 226  : 		_Al.destroy(_First);
; 227  : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@YAXPAU__REQUESTGUILD@CGuildCombat@@0AAV?$allocator@U__REQUESTGUILD@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@YAXPAU__ITEMINFO@@0AAV?$allocator@U__ITEMINFO@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<__ITEMINFO,std::allocator<__ITEMINFO> >
; Function compile flags: /Ogty
;	COMDAT ??$_Destroy_range@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@YAXPAU__ITEMINFO@@0AAV?$allocator@U__ITEMINFO@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@YAXPAU__ITEMINFO@@0AAV?$allocator@U__ITEMINFO@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Destroy_range<__ITEMINFO,std::allocator<__ITEMINFO> >, COMDAT

; 225  : 	for (; _First != _Last; ++_First)
; 226  : 		_Al.destroy(_First);
; 227  : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@YAXPAU__ITEMINFO@@0AAV?$allocator@U__ITEMINFO@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<__ITEMINFO,std::allocator<__ITEMINFO> >
_TEXT	ENDS
PUBLIC	??$_Uninitialized_copy@PAU__ITEMINFO@@PAU1@V?$allocator@U__ITEMINFO@@@std@@@std@@YAPAU__ITEMINFO@@PAU1@00AAV?$allocator@U__ITEMINFO@@@0@@Z ; std::_Uninitialized_copy<__ITEMINFO *,__ITEMINFO *,std::allocator<__ITEMINFO> >
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\memory
;	COMDAT ??$_Uninitialized_copy@PAU__ITEMINFO@@PAU1@V?$allocator@U__ITEMINFO@@@std@@@std@@YAPAU__ITEMINFO@@PAU1@00AAV?$allocator@U__ITEMINFO@@@0@@Z
_TEXT	SEGMENT
__Cat$310735 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_copy@PAU__ITEMINFO@@PAU1@V?$allocator@U__ITEMINFO@@@std@@@std@@YAPAU__ITEMINFO@@PAU1@00AAV?$allocator@U__ITEMINFO@@@0@@Z PROC NEAR ; std::_Uninitialized_copy<__ITEMINFO *,__ITEMINFO *,std::allocator<__ITEMINFO> >, COMDAT

; 126  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

  00000	51		 push	 ecx

; 127  : 	return (_Uninit_copy(_First, _Last, _Dest, _Al,
; 128  : 		_Ptr_cat(_First, _Dest)));

  00001	8b 04 24	 mov	 eax, DWORD PTR __Cat$310735[esp+4]
  00004	8b 4c 24 14	 mov	 ecx, DWORD PTR __Al$[esp]
  00008	8b 54 24 10	 mov	 edx, DWORD PTR __Dest$[esp]
  0000c	50		 push	 eax
  0000d	8b 44 24 10	 mov	 eax, DWORD PTR __Last$[esp+4]
  00011	51		 push	 ecx
  00012	8b 4c 24 10	 mov	 ecx, DWORD PTR __First$[esp+8]
  00016	52		 push	 edx
  00017	50		 push	 eax
  00018	51		 push	 ecx
  00019	e8 00 00 00 00	 call	 ??$_Uninit_copy@PAU__ITEMINFO@@PAU1@V?$allocator@U__ITEMINFO@@@std@@@std@@YAPAU__ITEMINFO@@PAU1@00AAV?$allocator@U__ITEMINFO@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<__ITEMINFO *,__ITEMINFO *,std::allocator<__ITEMINFO> >

; 129  : 	}

  0001e	83 c4 18	 add	 esp, 24			; 00000018H
  00021	c3		 ret	 0
??$_Uninitialized_copy@PAU__ITEMINFO@@PAU1@V?$allocator@U__ITEMINFO@@@std@@@std@@YAPAU__ITEMINFO@@PAU1@00AAV?$allocator@U__ITEMINFO@@@0@@Z ENDP ; std::_Uninitialized_copy<__ITEMINFO *,__ITEMINFO *,std::allocator<__ITEMINFO> >
_TEXT	ENDS
PUBLIC	??1?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::~CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\cstringt.h
;	COMDAT ??1?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
_TEXT	SEGMENT
??1?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ PROC NEAR ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::~CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >, COMDAT
; _this$ = ecx

; 963  : 	}

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 e8 10	 sub	 eax, 16			; 00000010H
  00005	8d 48 0c	 lea	 ecx, DWORD PTR [eax+12]
  00008	83 ca ff	 or	 edx, -1
  0000b	f0 0f c1 11	 lock	  xadd	 DWORD PTR [ecx], edx
  0000f	4a		 dec	 edx
  00010	85 d2		 test	 edx, edx
  00012	7f 08		 jg	 SHORT $L310753
  00014	8b 08		 mov	 ecx, DWORD PTR [eax]
  00016	8b 11		 mov	 edx, DWORD PTR [ecx]
  00018	50		 push	 eax
  00019	ff 52 04	 call	 DWORD PTR [edx+4]
$L310753:
  0001c	c3		 ret	 0
??1?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ ENDP ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::~CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >
_TEXT	ENDS
PUBLIC	?end@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::end
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::end, COMDAT
; _this$ = ecx

; 418  : 		return (_TREE_ITERATOR(_Myhead));

  00000	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00003	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  00007	89 08		 mov	 DWORD PTR [eax], ecx

; 419  : 		}

  00009	c2 04 00	 ret	 4
?end@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::end
_TEXT	ENDS
PUBLIC	??Citerator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QBEPAU?$pair@$$CBKPAVCCtrl@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::iterator::operator->
; Function compile flags: /Ogty
;	COMDAT ??Citerator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QBEPAU?$pair@$$CBKPAVCCtrl@@@2@XZ
_TEXT	SEGMENT
??Citerator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QBEPAU?$pair@$$CBKPAVCCtrl@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::iterator::operator->, COMDAT
; _this$ = ecx

; 322  : 			return (&**this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 0c	 add	 eax, 12			; 0000000cH

; 323  : 			}

  00005	c3		 ret	 0
??Citerator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QBEPAU?$pair@$$CBKPAVCCtrl@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::iterator::operator->
_TEXT	ENDS
PUBLIC	?end@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::end
; Function compile flags: /Ogty
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::end, COMDAT
; _this$ = ecx

; 418  : 		return (_TREE_ITERATOR(_Myhead));

  00000	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00003	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  00007	89 08		 mov	 DWORD PTR [eax], ecx

; 419  : 		}

  00009	c2 04 00	 ret	 4
?end@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::end
_TEXT	ENDS
PUBLIC	??Citerator@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QBEPAU?$pair@$$CBKPAVCMover@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::iterator::operator->
; Function compile flags: /Ogty
;	COMDAT ??Citerator@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QBEPAU?$pair@$$CBKPAVCMover@@@2@XZ
_TEXT	SEGMENT
??Citerator@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QBEPAU?$pair@$$CBKPAVCMover@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::iterator::operator->, COMDAT
; _this$ = ecx

; 322  : 			return (&**this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 0c	 add	 eax, 12			; 0000000cH

; 323  : 			}

  00005	c3		 ret	 0
??Citerator@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QBEPAU?$pair@$$CBKPAVCMover@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::iterator::operator->
_TEXT	ENDS
PUBLIC	?PrepareWrite@?$CSimpleStringT@D$0A@@ATL@@AAEPADH@Z ; ATL::CSimpleStringT<char,0>::PrepareWrite
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlsimpstr.h
;	COMDAT ?PrepareWrite@?$CSimpleStringT@D$0A@@ATL@@AAEPADH@Z
_TEXT	SEGMENT
_nLength$ = 8						; size = 4
?PrepareWrite@?$CSimpleStringT@D$0A@@ATL@@AAEPADH@Z PROC NEAR ; ATL::CSimpleStringT<char,0>::PrepareWrite, COMDAT
; _this$ = ecx

; 734  : 	{

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 735  : 		CStringData* pOldData = GetData();

  00003	8b 06		 mov	 eax, DWORD PTR [esi]

; 736  : 		int nShared = 1-pOldData->nRefs;  // nShared < 0 means true, >= 0 means false

  00005	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00008	83 e8 10	 sub	 eax, 16			; 00000010H
  0000b	b9 01 00 00 00	 mov	 ecx, 1
  00010	2b ca		 sub	 ecx, edx

; 737  : 		int nTooShort = pOldData->nAllocLength-nLength;  // nTooShort < 0 means true, >= 0 means false

  00012	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00015	8b 44 24 08	 mov	 eax, DWORD PTR _nLength$[esp]
  00019	2b d0		 sub	 edx, eax

; 738  : 		if( (nShared|nTooShort) < 0 )  // If either sign bit is set (i.e. either is less than zero), we need to copy data

  0001b	0b ca		 or	 ecx, edx
  0001d	7d 08		 jge	 SHORT $L310822

; 739  : 		{
; 740  : 			PrepareWrite2( nLength );

  0001f	50		 push	 eax
  00020	8b ce		 mov	 ecx, esi
  00022	e8 00 00 00 00	 call	 ?PrepareWrite2@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z ; ATL::CSimpleStringT<char,0>::PrepareWrite2
$L310822:

; 741  : 		}
; 742  : 
; 743  : 		return( m_pszData );

  00027	8b 06		 mov	 eax, DWORD PTR [esi]
  00029	5e		 pop	 esi

; 744  : 	}

  0002a	c2 04 00	 ret	 4
?PrepareWrite@?$CSimpleStringT@D$0A@@ATL@@AAEPADH@Z ENDP ; ATL::CSimpleStringT<char,0>::PrepareWrite
_TEXT	ENDS
PUBLIC	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z
_TEXT	SEGMENT
__Built$ = 8						; size = 1
__Newsize$ = 12						; size = 4
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy, COMDAT
; _this$ = ecx

; 1510 : 		if (!_Built)

  00000	8a 44 24 04	 mov	 al, BYTE PTR __Built$[esp-4]
  00004	84 c0		 test	 al, al
  00006	53		 push	 ebx
  00007	55		 push	 ebp
  00008	8b 6c 24 10	 mov	 ebp, DWORD PTR __Newsize$[esp+4]
  0000c	8b d9		 mov	 ebx, ecx
  0000e	74 2f		 je	 SHORT $L310830

; 1511 : 			;
; 1512 : 		else if (_BUF_SIZE <= _Myres)

  00010	83 7b 18 10	 cmp	 DWORD PTR [ebx+24], 16	; 00000010H
  00014	72 29		 jb	 SHORT $L310830

; 1513 : 			{	// copy any leftovers to small buffer and deallocate
; 1514 : 			_Elem *_Ptr = _Bx._Ptr;
; 1515 : 			if (0 < _Newsize)

  00016	85 ed		 test	 ebp, ebp
  00018	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  0001b	57		 push	 edi
  0001c	8d 7b 04	 lea	 edi, DWORD PTR [ebx+4]
  0001f	76 14		 jbe	 SHORT $L310827
  00021	56		 push	 esi

; 1516 : 				_Traits::copy(_Bx._Buf, _Ptr, _Newsize);

  00022	8b cd		 mov	 ecx, ebp
  00024	8b d1		 mov	 edx, ecx
  00026	c1 e9 02	 shr	 ecx, 2
  00029	8b f0		 mov	 esi, eax
  0002b	f3 a5		 rep movsd
  0002d	8b ca		 mov	 ecx, edx
  0002f	83 e1 03	 and	 ecx, 3
  00032	f3 a4		 rep movsb
  00034	5e		 pop	 esi
$L310827:

; 1517 : 			_Mybase::_Alval.deallocate(_Ptr, _Myres + 1);

  00035	50		 push	 eax
  00036	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0003b	83 c4 04	 add	 esp, 4
  0003e	5f		 pop	 edi
$L310830:

; 1518 : 			}
; 1519 : 		_Myres = _BUF_SIZE - 1;
; 1520 : 		_Eos(_Newsize);

  0003f	89 6b 14	 mov	 DWORD PTR [ebx+20], ebp
  00042	c7 43 18 0f 00
	00 00		 mov	 DWORD PTR [ebx+24], 15	; 0000000fH
  00049	c6 44 2b 04 00	 mov	 BYTE PTR [ebx+ebp+4], 0
  0004e	5d		 pop	 ebp
  0004f	5b		 pop	 ebx

; 1521 : 		}

  00050	c2 08 00	 ret	 8
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
_TEXT	ENDS
PUBLIC	?end@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::end
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::end, COMDAT
; _this$ = ecx

; 418  : 		return (_TREE_ITERATOR(_Myhead));

  00000	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00003	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  00007	89 08		 mov	 DWORD PTR [eax], ecx

; 419  : 		}

  00009	c2 04 00	 ret	 4
?end@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::end
_TEXT	ENDS
PUBLIC	?lower_bound@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::lower_bound
; Function compile flags: /Ogty
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
?lower_bound@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::lower_bound, COMDAT
; _this$ = ecx

; 810  : 		return (_TREE_ITERATOR(_Lbound(_Keyval)));

  00000	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00003	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00006	8a 50 15	 mov	 dl, BYTE PTR [eax+21]
  00009	84 d2		 test	 dl, dl
  0000b	75 1d		 jne	 SHORT $L310938
  0000d	8b 54 24 08	 mov	 edx, DWORD PTR __Keyval$[esp-4]
  00011	8b 12		 mov	 edx, DWORD PTR [edx]
  00013	53		 push	 ebx
$L310906:
  00014	39 50 0c	 cmp	 DWORD PTR [eax+12], edx
  00017	73 05		 jae	 SHORT $L310908
  00019	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0001c	eb 04		 jmp	 SHORT $L310909
$L310908:
  0001e	8b c8		 mov	 ecx, eax
  00020	8b 00		 mov	 eax, DWORD PTR [eax]
$L310909:
  00022	8a 58 15	 mov	 bl, BYTE PTR [eax+21]
  00025	84 db		 test	 bl, bl
  00027	74 eb		 je	 SHORT $L310906
  00029	5b		 pop	 ebx
$L310938:
  0002a	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  0002e	89 08		 mov	 DWORD PTR [eax], ecx

; 811  : 		}

  00030	c2 08 00	 ret	 8
?lower_bound@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::lower_bound
_TEXT	ENDS
PUBLIC	?begin@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::begin
; Function compile flags: /Ogty
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::begin, COMDAT
; _this$ = ecx

; 408  : 		return (_TREE_ITERATOR(_Lmost()));

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	8b 08		 mov	 ecx, DWORD PTR [eax]
  00005	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 409  : 		}

  0000b	c2 04 00	 ret	 4
?begin@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::begin
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@KV?$allocator@K@std@@@std@@IAEXXZ ; std::vector<unsigned long,std::allocator<unsigned long> >::_Tidy
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ?_Tidy@?$vector@KV?$allocator@K@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@KV?$allocator@K@std@@@std@@IAEXXZ PROC NEAR ; std::vector<unsigned long,std::allocator<unsigned long> >::_Tidy, COMDAT
; _this$ = ecx

; 791  : 		{	// free all storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 792  : 		if (_Myfirst != 0)

  00003	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00006	85 c0		 test	 eax, eax
  00008	74 09		 je	 SHORT $L310964

; 793  : 			{	// something to free, destroy and deallocate it
; 794  : 			_Destroy(_Myfirst, _Mylast);
; 795  : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00010	83 c4 04	 add	 esp, 4
$L310964:

; 796  : 			}
; 797  : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

  00013	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  0001a	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00021	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
  00028	5e		 pop	 esi

; 798  : 		}

  00029	c3		 ret	 0
?_Tidy@?$vector@KV?$allocator@K@std@@@std@@IAEXXZ ENDP	; std::vector<unsigned long,std::allocator<unsigned long> >::_Tidy
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@EV?$allocator@E@std@@@std@@IAEXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Tidy
; Function compile flags: /Ogty
;	COMDAT ?_Tidy@?$vector@EV?$allocator@E@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@EV?$allocator@E@std@@@std@@IAEXXZ PROC NEAR ; std::vector<unsigned char,std::allocator<unsigned char> >::_Tidy, COMDAT
; _this$ = ecx

; 791  : 		{	// free all storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 792  : 		if (_Myfirst != 0)

  00003	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00006	85 c0		 test	 eax, eax
  00008	74 09		 je	 SHORT $L310973

; 793  : 			{	// something to free, destroy and deallocate it
; 794  : 			_Destroy(_Myfirst, _Mylast);
; 795  : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00010	83 c4 04	 add	 esp, 4
$L310973:

; 796  : 			}
; 797  : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

  00013	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  0001a	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00021	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
  00028	5e		 pop	 esi

; 798  : 		}

  00029	c3		 ret	 0
?_Tidy@?$vector@EV?$allocator@E@std@@@std@@IAEXXZ ENDP	; std::vector<unsigned char,std::allocator<unsigned char> >::_Tidy
_TEXT	ENDS
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
EXTRN	?_Xran@_String_base@std@@QBEXXZ:NEAR		; std::_String_base::_Xran
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 792  : 		{	// erase elements [_Off, _Off + _Count)

  00000	55		 push	 ebp

; 793  : 		if (_Mysize < _Off)

  00001	8b 6c 24 08	 mov	 ebp, DWORD PTR __Off$[esp]
  00005	56		 push	 esi
  00006	8b f1		 mov	 esi, ecx
  00008	39 6e 14	 cmp	 DWORD PTR [esi+20], ebp
  0000b	57		 push	 edi
  0000c	73 05		 jae	 SHORT $L221371

; 794  : 			_String_base::_Xran();	// _Off off end

  0000e	e8 00 00 00 00	 call	 ?_Xran@_String_base@std@@QBEXXZ ; std::_String_base::_Xran
$L221371:

; 795  : 		if (_Mysize - _Off < _Count)

  00013	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00016	8b 7c 24 14	 mov	 edi, DWORD PTR __Count$[esp+8]
  0001a	2b c5		 sub	 eax, ebp
  0001c	3b c7		 cmp	 eax, edi
  0001e	73 02		 jae	 SHORT $L221372

; 796  : 			_Count = _Mysize - _Off;	// trim _Count

  00020	8b f8		 mov	 edi, eax
$L221372:

; 797  : 		if (0 < _Count)

  00022	85 ff		 test	 edi, edi
  00024	76 47		 jbe	 SHORT $L311018

; 798  : 			{	// move elements down
; 799  : 			_Traits::move(_Myptr() + _Off, _Myptr() + _Off + _Count,
; 800  : 				_Mysize - _Off - _Count);

  00026	8b 4e 18	 mov	 ecx, DWORD PTR [esi+24]
  00029	83 f9 10	 cmp	 ecx, 16			; 00000010H
  0002c	53		 push	 ebx
  0002d	8d 5e 04	 lea	 ebx, DWORD PTR [esi+4]
  00030	72 04		 jb	 SHORT $L310984
  00032	8b 13		 mov	 edx, DWORD PTR [ebx]
  00034	eb 02		 jmp	 SHORT $L310985
$L310984:
  00036	8b d3		 mov	 edx, ebx
$L310985:
  00038	83 f9 10	 cmp	 ecx, 16			; 00000010H
  0003b	72 04		 jb	 SHORT $L310991
  0003d	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  0003f	eb 02		 jmp	 SHORT $L310992
$L310991:
  00041	8b cb		 mov	 ecx, ebx
$L310992:
  00043	2b c7		 sub	 eax, edi

; 803  : 			}
; 804  : 		return (*this);

  00045	03 d5		 add	 edx, ebp
  00047	50		 push	 eax
  00048	03 d7		 add	 edx, edi
  0004a	52		 push	 edx
  0004b	03 cd		 add	 ecx, ebp
  0004d	51		 push	 ecx
  0004e	e8 00 00 00 00	 call	 _memmove
  00053	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00056	8b 4e 18	 mov	 ecx, DWORD PTR [esi+24]
  00059	2b c7		 sub	 eax, edi
  0005b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0005e	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00061	89 46 14	 mov	 DWORD PTR [esi+20], eax
  00064	72 02		 jb	 SHORT $L311015

; 801  : 			size_type _Newsize = _Mysize - _Count;
; 802  : 			_Eos(_Newsize);

  00066	8b 1b		 mov	 ebx, DWORD PTR [ebx]
$L311015:
  00068	c6 04 03 00	 mov	 BYTE PTR [ebx+eax], 0
  0006c	5b		 pop	 ebx
$L311018:
  0006d	5f		 pop	 edi

; 803  : 			}
; 804  : 		return (*this);

  0006e	8b c6		 mov	 eax, esi
  00070	5e		 pop	 esi
  00071	5d		 pop	 ebp

; 805  : 		}

  00072	c2 08 00	 ret	 8
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
PUBLIC	?begin@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::begin
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::begin, COMDAT
; _this$ = ecx

; 408  : 		return (_TREE_ITERATOR(_Lmost()));

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	8b 08		 mov	 ecx, DWORD PTR [eax]
  00005	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 409  : 		}

  0000b	c2 04 00	 ret	 4
?begin@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::begin
_TEXT	ENDS
PUBLIC	?upper_bound@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::upper_bound
; Function compile flags: /Ogty
;	COMDAT ?upper_bound@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
?upper_bound@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::upper_bound, COMDAT
; _this$ = ecx

; 820  : 		return (_TREE_ITERATOR(_Ubound(_Keyval)));

  00000	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00003	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00006	8a 50 15	 mov	 dl, BYTE PTR [eax+21]
  00009	84 d2		 test	 dl, dl
  0000b	75 1d		 jne	 SHORT $L311112
  0000d	8b 54 24 08	 mov	 edx, DWORD PTR __Keyval$[esp-4]
  00011	8b 12		 mov	 edx, DWORD PTR [edx]
  00013	53		 push	 ebx
$L311080:
  00014	3b 50 0c	 cmp	 edx, DWORD PTR [eax+12]
  00017	73 06		 jae	 SHORT $L311082
  00019	8b c8		 mov	 ecx, eax
  0001b	8b 00		 mov	 eax, DWORD PTR [eax]
  0001d	eb 03		 jmp	 SHORT $L311083
$L311082:
  0001f	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
$L311083:
  00022	8a 58 15	 mov	 bl, BYTE PTR [eax+21]
  00025	84 db		 test	 bl, bl
  00027	74 eb		 je	 SHORT $L311080
  00029	5b		 pop	 ebx
$L311112:
  0002a	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  0002e	89 08		 mov	 DWORD PTR [eax], ecx

; 821  : 		}

  00030	c2 08 00	 ret	 8
?upper_bound@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::upper_bound
_TEXT	ENDS
PUBLIC	??Eiterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::iterator::operator++
; Function compile flags: /Ogty
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??Eiterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::iterator::operator++, COMDAT
; _this$ = ecx

; 326  : 			{	// preincrement

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 327  : 			++(*(const_iterator *)this);

  00003	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::const_iterator::_Inc

; 328  : 			return (*this);

  00008	8b c6		 mov	 eax, esi
  0000a	5e		 pop	 esi

; 329  : 			}

  0000b	c3		 ret	 0
??Eiterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::iterator::operator++
_TEXT	ENDS
PUBLIC	??Eiterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAE?AV012@H@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::iterator::operator++
; Function compile flags: /Ogty
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAE?AV012@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??Eiterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAE?AV012@H@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::iterator::operator++, COMDAT
; _this$ = ecx

; 332  : 			{	// postincrement

  00000	56		 push	 esi

; 333  : 			iterator _Tmp = *this;

  00001	8b 31		 mov	 esi, DWORD PTR [ecx]

; 334  : 			++*this;

  00003	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::const_iterator::_Inc

; 335  : 			return (_Tmp);

  00008	8b 44 24 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp]
  0000c	89 30		 mov	 DWORD PTR [eax], esi
  0000e	5e		 pop	 esi

; 336  : 			}

  0000f	c2 08 00	 ret	 8
??Eiterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAE?AV012@H@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::iterator::operator++
_TEXT	ENDS
PUBLIC	??Fiterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::iterator::operator--
; Function compile flags: /Ogty
;	COMDAT ??Fiterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??Fiterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::iterator::operator--, COMDAT
; _this$ = ecx

; 339  : 			{	// predecrement

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 340  : 			--(*(const_iterator *)this);

  00003	e8 00 00 00 00	 call	 ?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::const_iterator::_Dec

; 341  : 			return (*this);

  00008	8b c6		 mov	 eax, esi
  0000a	5e		 pop	 esi

; 342  : 			}

  0000b	c3		 ret	 0
??Fiterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::iterator::operator--
_TEXT	ENDS
PUBLIC	?begin@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::begin
; Function compile flags: /Ogty
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::begin, COMDAT
; _this$ = ecx

; 408  : 		return (_TREE_ITERATOR(_Lmost()));

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	8b 08		 mov	 ecx, DWORD PTR [eax]
  00005	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 409  : 		}

  0000b	c2 04 00	 ret	 4
?begin@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::begin
_TEXT	ENDS
PUBLIC	?end@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::end
; Function compile flags: /Ogty
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::end, COMDAT
; _this$ = ecx

; 418  : 		return (_TREE_ITERATOR(_Myhead));

  00000	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00003	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  00007	89 08		 mov	 DWORD PTR [eax], ecx

; 419  : 		}

  00009	c2 04 00	 ret	 4
?end@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::end
_TEXT	ENDS
PUBLIC	?_Lbound@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@ABK@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::_Lbound
; Function compile flags: /Ogty
;	COMDAT ?_Lbound@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@ABK@Z
_TEXT	SEGMENT
__Keyval$ = 8						; size = 4
?_Lbound@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@ABK@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::_Lbound, COMDAT
; _this$ = ecx

; 988  : 		_Nodeptr _Pnode = _Root();

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]

; 989  : 		_Nodeptr _Wherenode = _Myhead;	// end() if search fails
; 990  : 
; 991  : 		while (!_Isnil(_Pnode))

  00006	8a 51 15	 mov	 dl, BYTE PTR [ecx+21]
  00009	84 d2		 test	 dl, dl
  0000b	75 1d		 jne	 SHORT $L222610
  0000d	8b 54 24 04	 mov	 edx, DWORD PTR __Keyval$[esp-4]
  00011	8b 12		 mov	 edx, DWORD PTR [edx]
  00013	53		 push	 ebx
$L222609:

; 992  : 			if (this->comp(_Key(_Pnode), _Keyval))

  00014	39 51 0c	 cmp	 DWORD PTR [ecx+12], edx
  00017	73 05		 jae	 SHORT $L222611

; 993  : 				_Pnode = _Right(_Pnode);	// descend right subtree

  00019	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]

; 994  : 			else

  0001c	eb 04		 jmp	 SHORT $L222612
$L222611:

; 995  : 				{	// _Pnode not less than _Keyval, remember it
; 996  : 				_Wherenode = _Pnode;

  0001e	8b c1		 mov	 eax, ecx

; 997  : 				_Pnode = _Left(_Pnode);	// descend left subtree

  00020	8b 09		 mov	 ecx, DWORD PTR [ecx]
$L222612:
  00022	8a 59 15	 mov	 bl, BYTE PTR [ecx+21]
  00025	84 db		 test	 bl, bl
  00027	74 eb		 je	 SHORT $L222609
  00029	5b		 pop	 ebx
$L222610:

; 998  : 				}
; 999  : 
; 1000 : 		return (_Wherenode);	// return best remembered candidate
; 1001 : 		}

  0002a	c2 04 00	 ret	 4
?_Lbound@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@ABK@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::_Lbound
_TEXT	ENDS
PUBLIC	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\iosfwd
xdata$x	SEGMENT
$T311410 DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
$T311412 DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L311213
$T311413 DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L311211
$T311411 DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:$T311412
	DD	00H
	DD	00H
	DD	03H
	DD	01H
	DD	FLAT:$T311413
$T311405 DD	019930520H
	DD	04H
	DD	FLAT:$T311410
	DD	02H
	DD	FLAT:$T311411
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
xdata$x	ENDS
;	COMDAT ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z
_TEXT	SEGMENT
__Newres$ = -24						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Ptr$ = 8						; size = 4
__Newsize$ = 8						; size = 4
__Oldlen$ = 12						; size = 4
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy, COMDAT
; _this$ = ecx

; 1444 : 		{	// copy _Oldlen elements to newly allocated buffer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 1445 : 		size_type _Newres = _Newsize | _ALLOC_MASK;

  0001b	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	8b d8		 mov	 ebx, eax
  00022	83 cb 0f	 or	 ebx, 15			; 0000000fH

; 1446 : 		if (max_size() < _Newres)

  00025	83 fb fe	 cmp	 ebx, -2			; fffffffeH
  00028	57		 push	 edi
  00029	8b f1		 mov	 esi, ecx
  0002b	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002e	89 75 ec	 mov	 DWORD PTR _this$[ebp], esi
  00031	76 04		 jbe	 SHORT $L222778

; 1447 : 			_Newres = _Newsize;	// undo roundup if too big

  00033	8b d8		 mov	 ebx, eax

; 1448 : 		else if (_Newres / 3 < _Myres / 2

  00035	eb 22		 jmp	 SHORT $L222780
$L222778:

; 1449 : 			&& _Myres <= max_size() - _Myres / 2)

  00037	8b 7e 18	 mov	 edi, DWORD PTR [esi+24]
  0003a	b8 ab aa aa aa	 mov	 eax, -1431655765	; aaaaaaabH
  0003f	f7 e3		 mul	 ebx
  00041	8b cf		 mov	 ecx, edi
  00043	d1 e9		 shr	 ecx, 1
  00045	d1 ea		 shr	 edx, 1
  00047	3b d1		 cmp	 edx, ecx
  00049	73 0e		 jae	 SHORT $L222780
  0004b	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00050	2b c1		 sub	 eax, ecx
  00052	3b f8		 cmp	 edi, eax
  00054	77 03		 ja	 SHORT $L222780

; 1450 : 			_Newres = _Myres + _Myres / 2;	// grow exponentially if possible

  00056	8d 1c 39	 lea	 ebx, DWORD PTR [ecx+edi]
$L222780:

; 1451 : 		_Elem *_Ptr;
; 1452 : 
; 1453 : 		_TRY_BEGIN
; 1454 : 			_Ptr = _Mybase::_Alval.allocate(_Newres + 1);

  00059	8d 4b 01	 lea	 ecx, DWORD PTR [ebx+1]
  0005c	51		 push	 ecx
  0005d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00064	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00069	8b d0		 mov	 edx, eax
  0006b	83 c4 04	 add	 esp, 4
  0006e	89 55 08	 mov	 DWORD PTR __Ptr$[ebp], edx
  00071	eb 29		 jmp	 SHORT $L222782
$L311211:

; 1455 : 		_CATCH_ALL
; 1456 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry

  00073	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00076	89 45 e8	 mov	 DWORD PTR __Newres$[ebp], eax

; 1457 : 			_TRY_BEGIN
; 1458 : 				_Ptr = _Mybase::_Alval.allocate(_Newres + 1);

  00079	40		 inc	 eax
  0007a	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0007d	50		 push	 eax
  0007e	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2
  00082	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00087	89 45 08	 mov	 DWORD PTR __Ptr$[ebp], eax
  0008a	83 c4 04	 add	 esp, 4

; 1462 : 			_CATCH_END
; 1463 : 		_CATCH_END

  0008d	b8 00 00 00 00	 mov	 eax, $L311406
  00092	c3		 ret	 0
$L311406:
  00093	8b 5d e8	 mov	 ebx, DWORD PTR __Newres$[ebp]
  00096	8b 75 ec	 mov	 esi, DWORD PTR _this$[ebp]
  00099	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
$L222782:

; 1464 : 
; 1465 : 		if (0 < _Oldlen)

  0009c	8b 4d 0c	 mov	 ecx, DWORD PTR __Oldlen$[ebp]
  0009f	85 c9		 test	 ecx, ecx
  000a1	76 24		 jbe	 SHORT $L311330

; 1466 : 			_Traits::copy(_Ptr, _Myptr(), _Oldlen);	// copy existing elements

  000a3	83 7e 18 10	 cmp	 DWORD PTR [esi+24], 16	; 00000010H
  000a7	72 05		 jb	 SHORT $L311326
  000a9	8b 76 04	 mov	 esi, DWORD PTR [esi+4]
  000ac	eb 03		 jmp	 SHORT $L311327
$L311326:
  000ae	83 c6 04	 add	 esi, 4
$L311327:
  000b1	8b c1		 mov	 eax, ecx
  000b3	c1 e9 02	 shr	 ecx, 2
  000b6	8b fa		 mov	 edi, edx
  000b8	f3 a5		 rep movsd
  000ba	8b c8		 mov	 ecx, eax
  000bc	83 e1 03	 and	 ecx, 3
  000bf	f3 a4		 rep movsb
  000c1	8b 75 ec	 mov	 esi, DWORD PTR _this$[ebp]
  000c4	8b 4d 0c	 mov	 ecx, DWORD PTR __Oldlen$[ebp]
$L311330:

; 1467 : 		_Tidy(true);

  000c7	83 7e 18 10	 cmp	 DWORD PTR [esi+24], 16	; 00000010H
  000cb	72 12		 jb	 SHORT $L311367
  000cd	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  000d0	51		 push	 ecx
  000d1	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000d6	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  000d9	8b 4d 0c	 mov	 ecx, DWORD PTR __Oldlen$[ebp]
  000dc	83 c4 04	 add	 esp, 4
$L311367:

; 1468 : 		_Bx._Ptr = _Ptr;
; 1469 : 		_Myres = _Newres;
; 1470 : 		_Eos(_Oldlen);

  000df	83 fb 10	 cmp	 ebx, 16			; 00000010H
  000e2	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  000e5	c6 00 00	 mov	 BYTE PTR [eax], 0
  000e8	89 10		 mov	 DWORD PTR [eax], edx
  000ea	89 5e 18	 mov	 DWORD PTR [esi+24], ebx
  000ed	89 4e 14	 mov	 DWORD PTR [esi+20], ecx
  000f0	72 02		 jb	 SHORT $L311399
  000f2	8b c2		 mov	 eax, edx
$L311399:

; 1471 : 		}

  000f4	5f		 pop	 edi
  000f5	c6 04 08 00	 mov	 BYTE PTR [eax+ecx], 0
  000f9	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000fc	5e		 pop	 esi
  000fd	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00104	5b		 pop	 ebx
  00105	8b e5		 mov	 esp, ebp
  00107	5d		 pop	 ebp
  00108	c2 08 00	 ret	 8
$L311213:

; 1459 : 			_CATCH_ALL
; 1460 : 			_Tidy(true);	// failed again, discard storage and reraise

  0010b	8b 75 ec	 mov	 esi, DWORD PTR _this$[ebp]
  0010e	83 7e 18 10	 cmp	 DWORD PTR [esi+24], 16	; 00000010H
  00112	72 0c		 jb	 SHORT $L311316
  00114	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00117	52		 push	 edx
  00118	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0011d	83 c4 04	 add	 esp, 4
$L311316:

; 1461 : 			_RERAISE;

  00120	6a 00		 push	 0
  00122	c7 46 18 0f 00
	00 00		 mov	 DWORD PTR [esi+24], 15	; 0000000fH
  00129	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0
  00130	6a 00		 push	 0
  00132	c6 46 04 00	 mov	 BYTE PTR [esi+4], 0
  00136	e8 00 00 00 00	 call	 __CxxThrowException@8
$L311414:
$L311409:
  0013b	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z:
  00000	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T311405
  00005	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
PUBLIC	?_Erase@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Erase
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ?_Erase@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Rootnode$ = 8						; size = 4
?_Erase@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Erase, COMDAT
; _this$ = ecx

; 890  : 		{	// free entire subtree, recursively

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	57		 push	 edi

; 891  : 		for (_Nodeptr _Pnode = _Rootnode; !_Isnil(_Pnode); _Rootnode = _Pnode)

  00003	8b 7c 24 10	 mov	 edi, DWORD PTR __Rootnode$[esp+8]
  00007	8a 47 15	 mov	 al, BYTE PTR [edi+21]
  0000a	84 c0		 test	 al, al
  0000c	8b d9		 mov	 ebx, ecx
  0000e	8b f7		 mov	 esi, edi
  00010	75 1f		 jne	 SHORT $L222808
$L222806:

; 892  : 			{	// free subtrees, then node
; 893  : 			_Erase(_Right(_Pnode));

  00012	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00015	50		 push	 eax
  00016	8b cb		 mov	 ecx, ebx
  00018	e8 00 00 00 00	 call	 ?_Erase@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Erase

; 894  : 			_Pnode = _Left(_Pnode);

  0001d	8b 36		 mov	 esi, DWORD PTR [esi]

; 895  : 			this->_Alnod.destroy(_Rootnode);	// destroy, free erased node
; 896  : 			this->_Alnod.deallocate(_Rootnode, 1);

  0001f	57		 push	 edi
  00020	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00025	8a 46 15	 mov	 al, BYTE PTR [esi+21]
  00028	83 c4 04	 add	 esp, 4
  0002b	84 c0		 test	 al, al
  0002d	8b fe		 mov	 edi, esi
  0002f	74 e1		 je	 SHORT $L222806
$L222808:
  00031	5f		 pop	 edi
  00032	5e		 pop	 esi
  00033	5b		 pop	 ebx

; 897  : 			}
; 898  : 		}

  00034	c2 04 00	 ret	 4
?_Erase@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Erase
_TEXT	ENDS
PUBLIC	?_Buynode@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBKPAVCUser@@@2@D@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Buynode
; Function compile flags: /Ogty
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBKPAVCUser@@@2@D@Z
_TEXT	SEGMENT
__Larg$ = 8						; size = 4
__Parg$ = 12						; size = 4
__Rarg$ = 16						; size = 4
__Val$ = 20						; size = 4
__Carg$ = 24						; size = 1
?_Buynode@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBKPAVCUser@@@2@D@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Buynode, COMDAT
; _this$ = ecx

; 1131 : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

  00000	6a 18		 push	 24			; 00000018H
  00002	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00007	83 c4 04	 add	 esp, 4

; 1132 : 		_TRY_BEGIN
; 1133 : 		new (_Wherenode) _Node(_Larg, _Parg, _Rarg, _Val, _Carg);

  0000a	85 c0		 test	 eax, eax
  0000c	74 2e		 je	 SHORT $L311438
  0000e	8b 4c 24 04	 mov	 ecx, DWORD PTR __Larg$[esp-4]
  00012	8b 54 24 08	 mov	 edx, DWORD PTR __Parg$[esp-4]
  00016	89 08		 mov	 DWORD PTR [eax], ecx
  00018	8b 4c 24 0c	 mov	 ecx, DWORD PTR __Rarg$[esp-4]
  0001c	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  0001f	8b 4c 24 10	 mov	 ecx, DWORD PTR __Val$[esp-4]
  00023	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00026	8b 11		 mov	 edx, DWORD PTR [ecx]
  00028	89 50 0c	 mov	 DWORD PTR [eax+12], edx
  0002b	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0002e	8a 54 24 14	 mov	 dl, BYTE PTR __Carg$[esp-4]
  00032	89 48 10	 mov	 DWORD PTR [eax+16], ecx
  00035	88 50 14	 mov	 BYTE PTR [eax+20], dl
  00038	c6 40 15 00	 mov	 BYTE PTR [eax+21], 0
$L311438:

; 1134 : 		_CATCH_ALL
; 1135 : 		this->_Alnod.deallocate(_Wherenode, 1);
; 1136 : 		_RERAISE;
; 1137 : 		_CATCH_END
; 1138 : 		return (_Wherenode);
; 1139 : 		}

  0003c	c2 14 00	 ret	 20			; 00000014H
?_Buynode@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBKPAVCUser@@@2@D@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Buynode
_TEXT	ENDS
PUBLIC	?_Erase@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::_Erase
; Function compile flags: /Ogty
;	COMDAT ?_Erase@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Rootnode$ = 8						; size = 4
?_Erase@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::_Erase, COMDAT
; _this$ = ecx

; 890  : 		{	// free entire subtree, recursively

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	57		 push	 edi

; 891  : 		for (_Nodeptr _Pnode = _Rootnode; !_Isnil(_Pnode); _Rootnode = _Pnode)

  00003	8b 7c 24 10	 mov	 edi, DWORD PTR __Rootnode$[esp+8]
  00007	8a 47 15	 mov	 al, BYTE PTR [edi+21]
  0000a	84 c0		 test	 al, al
  0000c	8b d9		 mov	 ebx, ecx
  0000e	8b f7		 mov	 esi, edi
  00010	75 1f		 jne	 SHORT $L222883
$L222881:

; 892  : 			{	// free subtrees, then node
; 893  : 			_Erase(_Right(_Pnode));

  00012	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00015	50		 push	 eax
  00016	8b cb		 mov	 ecx, ebx
  00018	e8 00 00 00 00	 call	 ?_Erase@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::_Erase

; 894  : 			_Pnode = _Left(_Pnode);

  0001d	8b 36		 mov	 esi, DWORD PTR [esi]

; 895  : 			this->_Alnod.destroy(_Rootnode);	// destroy, free erased node
; 896  : 			this->_Alnod.deallocate(_Rootnode, 1);

  0001f	57		 push	 edi
  00020	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00025	8a 46 15	 mov	 al, BYTE PTR [esi+21]
  00028	83 c4 04	 add	 esp, 4
  0002b	84 c0		 test	 al, al
  0002d	8b fe		 mov	 edi, esi
  0002f	74 e1		 je	 SHORT $L222881
$L222883:
  00031	5f		 pop	 edi
  00032	5e		 pop	 esi
  00033	5b		 pop	 ebx

; 897  : 			}
; 898  : 		}

  00034	c2 04 00	 ret	 4
?_Erase@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::_Erase
_TEXT	ENDS
PUBLIC	??Eiterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::iterator::operator++
; Function compile flags: /Ogty
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??Eiterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::iterator::operator++, COMDAT
; _this$ = ecx

; 326  : 			{	// preincrement

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 327  : 			++(*(const_iterator *)this);

  00003	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::const_iterator::_Inc

; 328  : 			return (*this);

  00008	8b c6		 mov	 eax, esi
  0000a	5e		 pop	 esi

; 329  : 			}

  0000b	c3		 ret	 0
??Eiterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::iterator::operator++
_TEXT	ENDS
PUBLIC	?_Erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Erase
; Function compile flags: /Ogty
;	COMDAT ?_Erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Rootnode$ = 8						; size = 4
?_Erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Erase, COMDAT
; _this$ = ecx

; 890  : 		{	// free entire subtree, recursively

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	57		 push	 edi

; 891  : 		for (_Nodeptr _Pnode = _Rootnode; !_Isnil(_Pnode); _Rootnode = _Pnode)

  00003	8b 7c 24 10	 mov	 edi, DWORD PTR __Rootnode$[esp+8]
  00007	8a 47 15	 mov	 al, BYTE PTR [edi+21]
  0000a	84 c0		 test	 al, al
  0000c	8b d9		 mov	 ebx, ecx
  0000e	8b f7		 mov	 esi, edi
  00010	75 1f		 jne	 SHORT $L223646
$L223644:

; 892  : 			{	// free subtrees, then node
; 893  : 			_Erase(_Right(_Pnode));

  00012	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00015	50		 push	 eax
  00016	8b cb		 mov	 ecx, ebx
  00018	e8 00 00 00 00	 call	 ?_Erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Erase

; 894  : 			_Pnode = _Left(_Pnode);

  0001d	8b 36		 mov	 esi, DWORD PTR [esi]

; 895  : 			this->_Alnod.destroy(_Rootnode);	// destroy, free erased node
; 896  : 			this->_Alnod.deallocate(_Rootnode, 1);

  0001f	57		 push	 edi
  00020	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00025	8a 46 15	 mov	 al, BYTE PTR [esi+21]
  00028	83 c4 04	 add	 esp, 4
  0002b	84 c0		 test	 al, al
  0002d	8b fe		 mov	 edi, esi
  0002f	74 e1		 je	 SHORT $L223644
$L223646:
  00031	5f		 pop	 edi
  00032	5e		 pop	 esi
  00033	5b		 pop	 ebx

; 897  : 			}
; 898  : 		}

  00034	c2 04 00	 ret	 4
?_Erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Erase
_TEXT	ENDS
PUBLIC	??Eiterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::iterator::operator++
; Function compile flags: /Ogty
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??Eiterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::iterator::operator++, COMDAT
; _this$ = ecx

; 326  : 			{	// preincrement

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 327  : 			++(*(const_iterator *)this);

  00003	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::const_iterator::_Inc

; 328  : 			return (*this);

  00008	8b c6		 mov	 eax, esi
  0000a	5e		 pop	 esi

; 329  : 			}

  0000b	c3		 ret	 0
??Eiterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::iterator::operator++
_TEXT	ENDS
PUBLIC	??_C@_02DPKJAMEF@?$CFd?$AA@			; `string'
PUBLIC	??_C@_05DNIIFBMG@?$CFs?5?$CFs?$AA@		; `string'
PUBLIC	?AddGoldText@CUser@@QAEXH@Z			; CUser::AddGoldText
EXTRN	?GetNumberFormatEx@@YA?AV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PBD@Z:NEAR ; GetNumberFormatEx
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlsimpstr.h
xdata$x	SEGMENT
$T311578 DD	0ffffffffH
	DD	FLAT:$L311513
	DD	00H
	DD	FLAT:$L311514
$T311575 DD	019930520H
	DD	02H
	DD	FLAT:$T311578
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_C@_02DPKJAMEF@?$CFd?$AA@
CONST	SEGMENT
??_C@_02DPKJAMEF@?$CFd?$AA@ DB '%d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05DNIIFBMG@?$CFs?5?$CFs?$AA@
CONST	SEGMENT
??_C@_05DNIIFBMG@?$CFs?5?$CFs?$AA@ DB '%s %s', 00H	; `string'
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
CONST	ENDS
;	COMDAT ?AddGoldText@CUser@@QAEXH@Z
_TEXT	SEGMENT
_strPlus$ = -152					; size = 4
_strGold$ = -148					; size = 4
_szPlus$ = -144						; size = 64
_szGold$ = -80						; size = 64
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_nPlus$ = 8						; size = 4
?AddGoldText@CUser@@QAEXH@Z PROC NEAR			; CUser::AddGoldText, COMDAT
; _this$ = ecx

; 2214 : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?AddGoldText@CUser@@QAEXH@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	81 ec 8c 00 00
	00		 sub	 esp, 140		; 0000008cH
  0001b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00020	33 c4		 xor	 eax, esp
  00022	56		 push	 esi
  00023	89 84 24 8c 00
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+156], eax

; 2215 : 	char szPlus[64];
; 2216 : 	char szGold[64];
; 2217 : 
; 2218 : 	sprintf( szPlus, "%d", nPlus );

  0002a	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR _nPlus$[esp+152]
  00031	50		 push	 eax
  00032	8b f1		 mov	 esi, ecx
  00034	8d 4c 24 10	 lea	 ecx, DWORD PTR _szPlus$[esp+160]
  00038	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_02DPKJAMEF@?$CFd?$AA@
  0003d	51		 push	 ecx
  0003e	e8 00 00 00 00	 call	 _sprintf

; 2219 : 	sprintf( szGold, "%d", GetGold() );

  00043	8b 86 84 16 00
	00		 mov	 eax, DWORD PTR [esi+5764]
  00049	50		 push	 eax
  0004a	8d 54 24 5c	 lea	 edx, DWORD PTR _szGold$[esp+172]
  0004e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_02DPKJAMEF@?$CFd?$AA@
  00053	52		 push	 edx
  00054	e8 00 00 00 00	 call	 _sprintf

; 2220 : 
; 2221 : 	CString strPlus = GetNumberFormatEx( szPlus );

  00059	8d 44 24 24	 lea	 eax, DWORD PTR _szPlus$[esp+180]
  0005d	50		 push	 eax
  0005e	8d 4c 24 20	 lea	 ecx, DWORD PTR _strPlus$[esp+184]
  00062	51		 push	 ecx
  00063	e8 00 00 00 00	 call	 ?GetNumberFormatEx@@YA?AV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PBD@Z ; GetNumberFormatEx

; 2222 : 	CString strGold = GetNumberFormatEx( szGold );

  00068	8d 54 24 6c	 lea	 edx, DWORD PTR _szGold$[esp+188]
  0006c	52		 push	 edx
  0006d	8d 44 24 2c	 lea	 eax, DWORD PTR _strGold$[esp+192]
  00071	50		 push	 eax
  00072	c7 84 24 c0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+204], 0
  0007d	e8 00 00 00 00	 call	 ?GetNumberFormatEx@@YA?AV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PBD@Z ; GetNumberFormatEx

; 2223 : 
; 2224 : 	AddDefinedText( TID_GAME_REAPMONEY, "%s %s", strPlus, strGold );

  00082	8b 4c 24 30	 mov	 ecx, DWORD PTR _strGold$[esp+196]
  00086	8b 54 24 2c	 mov	 edx, DWORD PTR _strPlus$[esp+196]
  0008a	51		 push	 ecx
  0008b	52		 push	 edx
  0008c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_05DNIIFBMG@?$CFs?5?$CFs?$AA@
  00091	68 77 02 00 00	 push	 631			; 00000277H
  00096	56		 push	 esi
  00097	c6 84 24 d4 00
	00 00 01	 mov	 BYTE PTR __$EHRec$[esp+224], 1
  0009f	e8 00 00 00 00	 call	 ?AddDefinedText@CUser@@QAAXHPBDZZ ; CUser::AddDefinedText

; 2225 : }

  000a4	8b 44 24 44	 mov	 eax, DWORD PTR _strGold$[esp+216]
  000a8	83 c0 f0	 add	 eax, -16		; fffffff0H
  000ab	83 c4 3c	 add	 esp, 60			; 0000003cH
  000ae	c6 84 24 98 00
	00 00 00	 mov	 BYTE PTR __$EHRec$[esp+164], 0
  000b6	8d 48 0c	 lea	 ecx, DWORD PTR [eax+12]
  000b9	83 ca ff	 or	 edx, -1
  000bc	f0 0f c1 11	 lock	  xadd	 DWORD PTR [ecx], edx
  000c0	4a		 dec	 edx
  000c1	85 d2		 test	 edx, edx
  000c3	5e		 pop	 esi
  000c4	7f 08		 jg	 SHORT $L311542
  000c6	8b 08		 mov	 ecx, DWORD PTR [eax]
  000c8	8b 11		 mov	 edx, DWORD PTR [ecx]
  000ca	50		 push	 eax
  000cb	ff 52 04	 call	 DWORD PTR [edx+4]
$L311542:
  000ce	8b 04 24	 mov	 eax, DWORD PTR _strPlus$[esp+152]
  000d1	83 c0 f0	 add	 eax, -16		; fffffff0H
  000d4	c7 84 24 94 00
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+160], -1
  000df	8d 48 0c	 lea	 ecx, DWORD PTR [eax+12]
  000e2	83 ca ff	 or	 edx, -1
  000e5	f0 0f c1 11	 lock	  xadd	 DWORD PTR [ecx], edx
  000e9	4a		 dec	 edx
  000ea	85 d2		 test	 edx, edx
  000ec	7f 08		 jg	 SHORT $L311569
  000ee	8b 08		 mov	 ecx, DWORD PTR [eax]
  000f0	8b 11		 mov	 edx, DWORD PTR [ecx]
  000f2	50		 push	 eax
  000f3	ff 52 04	 call	 DWORD PTR [edx+4]
$L311569:
  000f6	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+152]
  000fd	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00104	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+152]
  0010b	33 cc		 xor	 ecx, esp
  0010d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00112	81 c4 98 00 00
	00		 add	 esp, 152		; 00000098H
  00118	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L311513:
  00000	8d 8d 68 ff ff
	ff		 lea	 ecx, DWORD PTR _strPlus$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::~CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >
$L311514:
  0000b	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR _strGold$[ebp]
  00011	e9 00 00 00 00	 jmp	 ??1?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::~CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >
__ehhandler$?AddGoldText@CUser@@QAEXH@Z:
  00016	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T311575
  0001b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?AddGoldText@CUser@@QAEXH@Z ENDP			; CUser::AddGoldText
PUBLIC	?RemoveAngel@CUser@@QAEXXZ			; CUser::RemoveAngel
PUBLIC	??_C@_01HNPIGOCE@?$CG?$AA@			; `string'
PUBLIC	??_C@_09GKNMOCMA@ANGEL_DIE?$AA@			; `string'
EXTRN	?RemoveIk3Buffs@CMover@@QAEXK@Z:NEAR		; CMover::RemoveIk3Buffs
EXTRN	?GetBuffByIk3@CBuffMgr@@QAEPAVIBuff@@K@Z:NEAR	; CBuffMgr::GetBuffByIk3
;	COMDAT ??_C@_01HNPIGOCE@?$CG?$AA@
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\mover.h
CONST	SEGMENT
??_C@_01HNPIGOCE@?$CG?$AA@ DB '&', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09GKNMOCMA@ANGEL_DIE?$AA@
CONST	SEGMENT
??_C@_09GKNMOCMA@ANGEL_DIE?$AA@ DB 'ANGEL_DIE', 00H	; `string'
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
CONST	ENDS
;	COMDAT ?RemoveAngel@CUser@@QAEXXZ
_TEXT	SEGMENT
_aLogItem$279814 = -204					; size = 200
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
?RemoveAngel@CUser@@QAEXXZ PROC NEAR			; CUser::RemoveAngel, COMDAT
; _this$ = ecx

; 3551 : {

  00000	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c4		 xor	 eax, esp
  0000d	56		 push	 esi

; 3552 : #ifdef __ANGEL_LOG
; 3553 : 	if( HasBuffByIk3( IK3_ANGEL_BUFF ) )

  0000e	6a 5f		 push	 95			; 0000005fH
  00010	89 84 24 d0 00
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+212], eax
  00017	8b f1		 mov	 esi, ecx
  00019	e8 00 00 00 00	 call	 ?HasBuffByIk3@CMover@@QAEHK@Z ; CMover::HasBuffByIk3
  0001e	85 c0		 test	 eax, eax
  00020	0f 84 bd 00 00
	00		 je	 $L279809

; 3554 : 	{
; 3555 : #ifdef __BUFF_1107
; 3556 : 		IBuff* pBuff	= m_buffs.GetBuffByIk3( IK3_ANGEL_BUFF );

  00026	6a 5f		 push	 95			; 0000005fH
  00028	8d 8e f0 02 00
	00		 lea	 ecx, DWORD PTR [esi+752]
  0002e	e8 00 00 00 00	 call	 ?GetBuffByIk3@CBuffMgr@@QAEPAVIBuff@@K@Z ; CBuffMgr::GetBuffByIk3

; 3557 : 		ItemProp* pItemProp	= NULL;
; 3558 : 		if( pBuff )

  00033	85 c0		 test	 eax, eax
  00035	0f 84 81 00 00
	00		 je	 $L279813

; 3559 : 			pItemProp	= pBuff->GetProp();

  0003b	8b 10		 mov	 edx, DWORD PTR [eax]
  0003d	57		 push	 edi
  0003e	8b c8		 mov	 ecx, eax
  00040	ff 52 24	 call	 DWORD PTR [edx+36]
  00043	8b f8		 mov	 edi, eax

; 3560 : #else	// __BUFF_1107
; 3561 : 		LPSKILLINFLUENCE lpSkillIn	= m_SkillState.GetItemBuf( IK3_ANGEL_BUFF );
; 3562 : 		ItemProp* pItemProp	= NULL;
; 3563 : 		if( lpSkillIn )
; 3564 : 			pItemProp	= prj.GetItemProp( lpSkillIn->wID );
; 3565 : #endif	// __BUFF_1107
; 3566 : 		if( pItemProp )

  00045	85 ff		 test	 edi, edi
  00047	74 72		 je	 SHORT $L311599

; 3567 : 		{
; 3568 : 			LogItemInfo aLogItem;

  00049	8d 4c 24 08	 lea	 ecx, DWORD PTR _aLogItem$279814[esp+212]
  0004d	e8 00 00 00 00	 call	 ??0_LogItemInfo@@QAE@XZ	; _LogItemInfo::_LogItemInfo

; 3569 : 			aLogItem.Action = "&";
; 3570 : 			aLogItem.SendName	= GetName();

  00052	6a 00		 push	 0
  00054	8b ce		 mov	 ecx, esi
  00056	c7 44 24 0c 00
	00 00 00	 mov	 DWORD PTR _aLogItem$279814[esp+216], OFFSET FLAT:??_C@_01HNPIGOCE@?$CG?$AA@
  0005e	e8 00 00 00 00	 call	 ?GetName@CMover@@QAEPBDH@Z ; CMover::GetName

; 3571 : 			aLogItem.RecvName	= "ANGEL_DIE";
; 3572 : 			aLogItem.WorldId	= GetWorld()->GetID();
; 3573 : 			aLogItem.Gold		= aLogItem.Gold2	= GetGold();
; 3574 : 			aLogItem.Gold_1		= (DWORD)( m_nAngelExp );

  00063	8b 96 68 07 00
	00		 mov	 edx, DWORD PTR [esi+1896]
  00069	89 44 24 0c	 mov	 DWORD PTR _aLogItem$279814[esp+216], eax
  0006d	8b 86 6c 01 00
	00		 mov	 eax, DWORD PTR [esi+364]
  00073	c7 44 24 10 00
	00 00 00	 mov	 DWORD PTR _aLogItem$279814[esp+220], OFFSET FLAT:??_C@_09GKNMOCMA@ANGEL_DIE?$AA@
  0007b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0007d	8b 86 84 16 00
	00		 mov	 eax, DWORD PTR [esi+5764]
  00083	89 44 24 1c	 mov	 DWORD PTR _aLogItem$279814[esp+232], eax
  00087	89 44 24 18	 mov	 DWORD PTR _aLogItem$279814[esp+228], eax

; 3575 : 			//aLogItem.ItemName	= pItemProp->szName;
; 3576 : 			_stprintf( aLogItem.szItemName, "%d", pItemProp->dwID );

  0008b	8b 07		 mov	 eax, DWORD PTR [edi]
  0008d	50		 push	 eax
  0008e	89 4c 24 18	 mov	 DWORD PTR _aLogItem$279814[esp+228], ecx
  00092	8d 4c 24 30	 lea	 ecx, DWORD PTR _aLogItem$279814[esp+252]
  00096	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_02DPKJAMEF@?$CFd?$AA@
  0009b	51		 push	 ecx
  0009c	89 54 24 60	 mov	 DWORD PTR _aLogItem$279814[esp+300], edx
  000a0	e8 00 00 00 00	 call	 _sprintf
  000a5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3577 : 			g_DPSrvr.OnLogItem( aLogItem );

  000a8	6a 00		 push	 0
  000aa	6a 00		 push	 0
  000ac	8d 54 24 10	 lea	 edx, DWORD PTR _aLogItem$279814[esp+220]
  000b0	52		 push	 edx
  000b1	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_DPSrvr@@3VCDPSrvr@@A
  000b6	e8 00 00 00 00	 call	 ?OnLogItem@CDPSrvr@@QAEXAAU_LogItemInfo@@PAVCItemElem@@H@Z ; CDPSrvr::OnLogItem
$L311599:
  000bb	5f		 pop	 edi
$L279813:

; 3578 : 		}
; 3579 : 		RemoveIk3Buffs( IK3_ANGEL_BUFF );

  000bc	6a 5f		 push	 95			; 0000005fH
  000be	8b ce		 mov	 ecx, esi
  000c0	e8 00 00 00 00	 call	 ?RemoveIk3Buffs@CMover@@QAEXK@Z ; CMover::RemoveIk3Buffs

; 3580 : 		m_nAngelLevel	= 0;

  000c5	c7 86 70 07 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+1904], 0

; 3581 : 		m_nAngelExp		= 0;

  000cf	c7 86 68 07 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+1896], 0
  000d9	c7 86 6c 07 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+1900], 0
$L279809:

; 3582 : 	}
; 3583 : #else // __ANGEL_LOG
; 3584 : 	m_SkillState.RemoveLikeItemBuf( IK3_ANGEL_BUFF );
; 3585 : 	m_nAngelLevel	= m_nAngelExp	= 0;
; 3586 : #endif // __ANGEL_LOG
; 3587 : 	AddAngelInfo();

  000e3	6a 00		 push	 0
  000e5	8b ce		 mov	 ecx, esi
  000e7	e8 00 00 00 00	 call	 ?AddAngelInfo@CUser@@QAEXH@Z ; CUser::AddAngelInfo

; 3588 : }

  000ec	8b 8c 24 cc 00
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+208]
  000f3	5e		 pop	 esi
  000f4	33 cc		 xor	 ecx, esp
  000f6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000fb	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00101	c3		 ret	 0
?RemoveAngel@CUser@@QAEXXZ ENDP				; CUser::RemoveAngel
_TEXT	ENDS
PUBLIC	?AdjustPartyQuest@CUser@@QAEXK@Z		; CUser::AdjustPartyQuest
EXTRN	?GetPartyQuest@CPartyQuestProcessor@@QAEPAU_PARTYQUESTELEM@@H@Z:NEAR ; CPartyQuestProcessor::GetPartyQuest
EXTRN	?GetInstance@CPartyQuestProcessor@@SAPAV1@XZ:NEAR ; CPartyQuestProcessor::GetInstance
EXTRN	?PtInQuestRect@CPartyQuestProcessor@@QAEHKABUD3DXVECTOR3@@@Z:NEAR ; CPartyQuestProcessor::PtInQuestRect
; Function compile flags: /Ogty
;	COMDAT ?AdjustPartyQuest@CUser@@QAEXK@Z
_TEXT	SEGMENT
$T311603 = -12						; size = 12
_dwWorldId$ = 8						; size = 4
?AdjustPartyQuest@CUser@@QAEXK@Z PROC NEAR		; CUser::AdjustPartyQuest, COMDAT
; _this$ = ecx

; 3739 : {

  00000	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00003	56		 push	 esi
  00004	57		 push	 edi
  00005	8b f9		 mov	 edi, ecx

; 3740 : 	CPartyQuestProcessor* pProc		= CPartyQuestProcessor::GetInstance();

  00007	e8 00 00 00 00	 call	 ?GetInstance@CPartyQuestProcessor@@SAPAV1@XZ ; CPartyQuestProcessor::GetInstance
  0000c	8b f0		 mov	 esi, eax

; 3741 : 	int nId		= pProc->PtInQuestRect( dwWorldId, GetPos() );

  0000e	8d 87 60 01 00
	00		 lea	 eax, DWORD PTR [edi+352]
  00014	8b 08		 mov	 ecx, DWORD PTR [eax]
  00016	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00019	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0001c	89 4c 24 08	 mov	 DWORD PTR $T311603[esp+20], ecx
  00020	8d 4c 24 08	 lea	 ecx, DWORD PTR $T311603[esp+20]
  00024	89 54 24 0c	 mov	 DWORD PTR $T311603[esp+24], edx
  00028	8b 54 24 18	 mov	 edx, DWORD PTR _dwWorldId$[esp+16]
  0002c	51		 push	 ecx
  0002d	52		 push	 edx
  0002e	8b ce		 mov	 ecx, esi
  00030	89 44 24 18	 mov	 DWORD PTR $T311603[esp+36], eax
  00034	e8 00 00 00 00	 call	 ?PtInQuestRect@CPartyQuestProcessor@@QAEHKABUD3DXVECTOR3@@@Z ; CPartyQuestProcessor::PtInQuestRect

; 3742 : 	if( nId > -1 )

  00039	83 f8 ff	 cmp	 eax, -1
  0003c	7e 45		 jle	 SHORT $L311609

; 3743 : 	{
; 3744 : 		PPARTYQUESTELEM pElem	= pProc->GetPartyQuest( nId );

  0003e	50		 push	 eax
  0003f	8b ce		 mov	 ecx, esi
  00041	e8 00 00 00 00	 call	 ?GetPartyQuest@CPartyQuestProcessor@@QAEPAU_PARTYQUESTELEM@@H@Z ; CPartyQuestProcessor::GetPartyQuest
  00046	8b f0		 mov	 esi, eax

; 3745 : 		if( pElem && pElem->idParty == m_idparty )

  00048	85 f6		 test	 esi, esi
  0004a	74 2d		 je	 SHORT $L279941
  0004c	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0004f	3b 87 18 07 00
	00		 cmp	 eax, DWORD PTR [edi+1816]
  00055	75 22		 jne	 SHORT $L279941

; 3746 : 		{
; 3747 : 			DWORD dwTime	= pElem->dwEndTime - GetTickCount();

  00057	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0005d	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  00060	2b c8		 sub	 ecx, eax

; 3748 : 			AddQuestTextTime( TRUE, pElem->nProcess , dwTime );

  00062	51		 push	 ecx
  00063	0f b6 4e 10	 movzx	 ecx, BYTE PTR [esi+16]
  00067	51		 push	 ecx
  00068	6a 01		 push	 1
  0006a	8b cf		 mov	 ecx, edi
  0006c	e8 00 00 00 00	 call	 ?AddQuestTextTime@CUser@@QAEXHHK@Z ; CUser::AddQuestTextTime
  00071	5f		 pop	 edi
  00072	5e		 pop	 esi

; 3753 : 		}
; 3754 : 	}
; 3755 : }

  00073	83 c4 0c	 add	 esp, 12			; 0000000cH
  00076	c2 04 00	 ret	 4
$L279941:

; 3749 : 		}
; 3750 : 		else if( !pElem || pElem->idParty != m_idparty )
; 3751 : 		{
; 3752 : 			SetMode( MODE_OUTOF_PARTYQUESTRGN );

  00079	81 8f 44 02 00
	00 00 00 00 80	 or	 DWORD PTR [edi+580], -2147483648 ; 80000000H
$L311609:
  00083	5f		 pop	 edi
  00084	5e		 pop	 esi

; 3753 : 		}
; 3754 : 	}
; 3755 : }

  00085	83 c4 0c	 add	 esp, 12			; 0000000cH
  00088	c2 04 00	 ret	 4
?AdjustPartyQuest@CUser@@QAEXK@Z ENDP			; CUser::AdjustPartyQuest
_TEXT	ENDS
PUBLIC	?AddEventMessage@CUserMng@@QAEXPAVCCtrl@@PBDHK@Z ; CUserMng::AddEventMessage
EXTRN	??0CAr@@QAE@PAXI@Z:NEAR				; CAr::CAr
EXTRN	??1CAr@@QAE@XZ:NEAR				; CAr::~CAr
EXTRN	__chkstk:NEAR
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
xdata$x	SEGMENT
$T311889 DD	0ffffffffH
	DD	FLAT:$L311616
$T311880 DD	019930520H
	DD	01H
	DD	FLAT:$T311889
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
xdata$x	ENDS
;	COMDAT ?AddEventMessage@CUserMng@@QAEXPAVCCtrl@@PBDHK@Z
_TEXT	SEGMENT
_nBufSize$ = -16424					; size = 4
_ar$ = -16420						; size = 16404
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_pCtrl$ = 8						; size = 4
_szChat$ = 12						; size = 4
_nFlag$ = 16						; size = 4
_dwItemId$ = 20						; size = 4
?AddEventMessage@CUserMng@@QAEXPAVCCtrl@@PBDHK@Z PROC NEAR ; CUserMng::AddEventMessage, COMDAT
; _this$ = ecx

; 4295 : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?AddEventMessage@CUserMng@@QAEXPAVCCtrl@@PBDHK@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	b8 1c 40 00 00	 mov	 eax, 16412		; 0000401cH
  00013	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0001a	e8 00 00 00 00	 call	 __chkstk
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00024	33 c4		 xor	 eax, esp
  00026	53		 push	 ebx
  00027	8b 9c 24 34 40
	00 00		 mov	 ebx, DWORD PTR _szChat$[esp+16424]
  0002e	55		 push	 ebp
  0002f	56		 push	 esi
  00030	8b b4 24 38 40
	00 00		 mov	 esi, DWORD PTR _pCtrl$[esp+16432]
  00037	57		 push	 edi

; 4296 : 	CAr ar;

  00038	6a 00		 push	 0
  0003a	6a 00		 push	 0
  0003c	8d 4c 24 1c	 lea	 ecx, DWORD PTR _ar$[esp+16448]
  00040	89 84 24 30 40
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+16448], eax
  00047	e8 00 00 00 00	 call	 ??0CAr@@QAE@PAXI@Z	; CAr::CAr

; 4297 : 	
; 4298 : 	ar << GETID( pCtrl ) << SNAPSHOTTYPE_EVENTMESSAGE;

  0004c	85 f6		 test	 esi, esi
  0004e	c7 84 24 34 40
	00 00 00 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+16448], 0
  00059	74 08		 je	 SHORT $L311614
  0005b	8b be bc 01 00
	00		 mov	 edi, DWORD PTR [esi+444]
  00061	eb 03		 jmp	 SHORT $L311615
$L311614:
  00063	83 cf ff	 or	 edi, -1
$L311615:
  00066	bd 04 00 00 00	 mov	 ebp, 4
  0006b	55		 push	 ebp
  0006c	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  00070	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00075	8b 44 24 1c	 mov	 eax, DWORD PTR _ar$[esp+16448]
  00079	89 38		 mov	 DWORD PTR [eax], edi
  0007b	8b 44 24 1c	 mov	 eax, DWORD PTR _ar$[esp+16448]
  0007f	03 c5		 add	 eax, ebp
  00081	6a 02		 push	 2
  00083	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  00087	89 44 24 20	 mov	 DWORD PTR _ar$[esp+16452], eax
  0008b	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00090	8b 4c 24 1c	 mov	 ecx, DWORD PTR _ar$[esp+16448]
  00094	66 c7 01 2f 00	 mov	 WORD PTR [ecx], 47	; 0000002fH
  00099	8b 54 24 1c	 mov	 edx, DWORD PTR _ar$[esp+16448]
  0009d	83 c2 02	 add	 edx, 2

; 4299 : 	ar.WriteString( szChat );

  000a0	53		 push	 ebx
  000a1	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  000a5	89 54 24 20	 mov	 DWORD PTR _ar$[esp+16452], edx
  000a9	e8 00 00 00 00	 call	 ?WriteString@CAr@@QAEXPBD@Z ; CAr::WriteString

; 4300 : 	ar << nFlag;

  000ae	55		 push	 ebp
  000af	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  000b3	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000b8	8b 54 24 1c	 mov	 edx, DWORD PTR _ar$[esp+16448]
  000bc	8b 84 24 44 40
	00 00		 mov	 eax, DWORD PTR _nFlag$[esp+16436]
  000c3	89 02		 mov	 DWORD PTR [edx], eax
  000c5	8b 5c 24 1c	 mov	 ebx, DWORD PTR _ar$[esp+16448]
  000c9	03 dd		 add	 ebx, ebp

; 4301 : 	ar << dwItemId;

  000cb	55		 push	 ebp
  000cc	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  000d0	89 5c 24 20	 mov	 DWORD PTR _ar$[esp+16452], ebx
  000d4	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000d9	8b 4c 24 1c	 mov	 ecx, DWORD PTR _ar$[esp+16448]
  000dd	8b 94 24 48 40
	00 00		 mov	 edx, DWORD PTR _dwItemId$[esp+16436]
  000e4	89 11		 mov	 DWORD PTR [ecx], edx
  000e6	8b 54 24 1c	 mov	 edx, DWORD PTR _ar$[esp+16448]

; 4302 : 	
; 4303 : 	GETBLOCK( ar, lpBuf, nBufSize );

  000ea	8d 44 24 10	 lea	 eax, DWORD PTR _nBufSize$[esp+16440]
  000ee	03 d5		 add	 edx, ebp
  000f0	50		 push	 eax
  000f1	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  000f5	89 54 24 20	 mov	 DWORD PTR _ar$[esp+16452], edx
  000f9	e8 00 00 00 00	 call	 ?GetBuffer@CAr@@QAEPAEPAH@Z ; CAr::GetBuffer

; 4304 : 	
; 4305 : 	FOR_VISIBILITYRANGE( pCtrl )

  000fe	8b be 10 02 00
	00		 mov	 edi, DWORD PTR [esi+528]
  00104	8b 37		 mov	 esi, DWORD PTR [edi]
  00106	3b f7		 cmp	 esi, edi
  00108	8b e8		 mov	 ebp, eax
  0010a	74 72		 je	 SHORT $L280268
  0010c	b3 01		 mov	 bl, 1
  0010e	8b ff		 npad	 2
$L280267:

; 4306 : 	USERPTR->AddBlock( lpBuf, nBufSize );

  00110	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00113	84 58 04	 test	 BYTE PTR [eax+4], bl
  00116	8b 4c 24 10	 mov	 ecx, DWORD PTR _nBufSize$[esp+16440]
  0011a	75 14		 jne	 SHORT $L311723
  0011c	66 ff 80 0c 57
	00 00		 inc	 WORD PTR [eax+22284]
  00123	51		 push	 ecx
  00124	55		 push	 ebp
  00125	8d 88 f8 16 00
	00		 lea	 ecx, DWORD PTR [eax+5880]
  0012b	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
$L311723:

; 4307 : 	NEXT_VISIBILITYRANGE( pCtrl )

  00130	8a 46 15	 mov	 al, BYTE PTR [esi+21]
  00133	84 c0		 test	 al, al
  00135	75 43		 jne	 SHORT $L311847
  00137	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0013a	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  0013d	84 c9		 test	 cl, cl
  0013f	75 1c		 jne	 SHORT $L311883
  00141	8b f0		 mov	 esi, eax
  00143	8b 06		 mov	 eax, DWORD PTR [esi]
  00145	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00148	84 c9		 test	 cl, cl
  0014a	75 2e		 jne	 SHORT $L311847
  0014c	8d 64 24 00	 npad	 4
$L311868:
  00150	8b f0		 mov	 esi, eax
  00152	8b 06		 mov	 eax, DWORD PTR [esi]
  00154	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00157	84 c9		 test	 cl, cl
  00159	74 f5		 je	 SHORT $L311868
  0015b	eb 1d		 jmp	 SHORT $L311847
$L311883:
  0015d	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00160	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00163	84 c9		 test	 cl, cl
  00165	75 11		 jne	 SHORT $L311850
$L311849:
  00167	3b 70 08	 cmp	 esi, DWORD PTR [eax+8]
  0016a	75 0c		 jne	 SHORT $L311850
  0016c	8b f0		 mov	 esi, eax
  0016e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00171	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00174	84 c9		 test	 cl, cl
  00176	74 ef		 je	 SHORT $L311849
$L311850:
  00178	8b f0		 mov	 esi, eax
$L311847:

; 4304 : 	
; 4305 : 	FOR_VISIBILITYRANGE( pCtrl )

  0017a	3b f7		 cmp	 esi, edi
  0017c	75 92		 jne	 SHORT $L280267
$L280268:

; 4308 : }

  0017e	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  00182	c7 84 24 34 40
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+16448], -1
  0018d	e8 00 00 00 00	 call	 ??1CAr@@QAE@XZ		; CAr::~CAr
  00192	8b 8c 24 2c 40
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+16440]
  00199	5f		 pop	 edi
  0019a	5e		 pop	 esi
  0019b	5d		 pop	 ebp
  0019c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  001a3	8b 8c 24 1c 40
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+16428]
  001aa	5b		 pop	 ebx
  001ab	33 cc		 xor	 ecx, esp
  001ad	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001b2	81 c4 28 40 00
	00		 add	 esp, 16424		; 00004028H
  001b8	c2 10 00	 ret	 16			; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L311616:
  00000	8d 8d dc bf ff
	ff		 lea	 ecx, DWORD PTR _ar$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CAr@@QAE@XZ		; CAr::~CAr
__ehhandler$?AddEventMessage@CUserMng@@QAEXPAVCCtrl@@PBDHK@Z:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T311880
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?AddEventMessage@CUserMng@@QAEXPAVCCtrl@@PBDHK@Z ENDP	; CUserMng::AddEventMessage
PUBLIC	?AddStartCollecting@CUserMng@@QAEXPAVCUser@@@Z	; CUserMng::AddStartCollecting
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
xdata$x	SEGMENT
$T312158 DD	0ffffffffH
	DD	FLAT:$L311898
$T312150 DD	019930520H
	DD	01H
	DD	FLAT:$T312158
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
xdata$x	ENDS
;	COMDAT ?AddStartCollecting@CUserMng@@QAEXPAVCUser@@@Z
_TEXT	SEGMENT
_nBufSize$ = -16424					; size = 4
_ar$ = -16420						; size = 16404
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_pUser$ = 8						; size = 4
?AddStartCollecting@CUserMng@@QAEXPAVCUser@@@Z PROC NEAR ; CUserMng::AddStartCollecting, COMDAT
; _this$ = ecx

; 4321 : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?AddStartCollecting@CUserMng@@QAEXPAVCUser@@@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	b8 1c 40 00 00	 mov	 eax, 16412		; 0000401cH
  00013	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0001a	e8 00 00 00 00	 call	 __chkstk
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00024	33 c4		 xor	 eax, esp
  00026	55		 push	 ebp
  00027	56		 push	 esi
  00028	8b b4 24 34 40
	00 00		 mov	 esi, DWORD PTR _pUser$[esp+16428]
  0002f	57		 push	 edi

; 4322 : 	CAr ar;

  00030	6a 00		 push	 0
  00032	6a 00		 push	 0
  00034	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  00038	89 84 24 2c 40
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+16444], eax
  0003f	e8 00 00 00 00	 call	 ??0CAr@@QAE@PAXI@Z	; CAr::CAr

; 4323 : 
; 4324 : 	ar << GETID( pUser ) << SNAPSHOTTYPE_START_COLLECTING;

  00044	85 f6		 test	 esi, esi
  00046	c7 84 24 30 40
	00 00 00 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+16444], 0
  00051	74 08		 je	 SHORT $L311896
  00053	8b be bc 01 00
	00		 mov	 edi, DWORD PTR [esi+444]
  00059	eb 03		 jmp	 SHORT $L311897
$L311896:
  0005b	83 cf ff	 or	 edi, -1
$L311897:
  0005e	6a 04		 push	 4
  00060	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  00064	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00069	8b 44 24 18	 mov	 eax, DWORD PTR _ar$[esp+16444]
  0006d	89 38		 mov	 DWORD PTR [eax], edi
  0006f	8b 6c 24 18	 mov	 ebp, DWORD PTR _ar$[esp+16444]
  00073	83 c5 04	 add	 ebp, 4
  00076	6a 02		 push	 2
  00078	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  0007c	89 6c 24 1c	 mov	 DWORD PTR _ar$[esp+16448], ebp
  00080	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00085	8b 4c 24 18	 mov	 ecx, DWORD PTR _ar$[esp+16444]
  00089	66 c7 01 23 01	 mov	 WORD PTR [ecx], 291	; 00000123H
  0008e	83 44 24 18 02	 add	 DWORD PTR _ar$[esp+16444], 2

; 4325 : 	
; 4326 : 	GETBLOCK( ar, lpBuf, nBufSize );

  00093	8d 54 24 0c	 lea	 edx, DWORD PTR _nBufSize$[esp+16436]
  00097	52		 push	 edx
  00098	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  0009c	e8 00 00 00 00	 call	 ?GetBuffer@CAr@@QAEPAEPAH@Z ; CAr::GetBuffer

; 4327 : 
; 4328 : 	FOR_VISIBILITYRANGE( pUser )

  000a1	8b be 10 02 00
	00		 mov	 edi, DWORD PTR [esi+528]
  000a7	8b 37		 mov	 esi, DWORD PTR [edi]
  000a9	3b f7		 cmp	 esi, edi
  000ab	8b e8		 mov	 ebp, eax
  000ad	74 6f		 je	 SHORT $L280301
  000af	90		 npad	 1
$L280300:

; 4329 : 	{
; 4330 : 		USERPTR->AddBlock( lpBuf, nBufSize );

  000b0	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  000b3	f6 40 04 01	 test	 BYTE PTR [eax+4], 1
  000b7	8b 4c 24 0c	 mov	 ecx, DWORD PTR _nBufSize$[esp+16436]
  000bb	75 14		 jne	 SHORT $L311991
  000bd	66 ff 80 0c 57
	00 00		 inc	 WORD PTR [eax+22284]
  000c4	51		 push	 ecx
  000c5	55		 push	 ebp
  000c6	8d 88 f8 16 00
	00		 lea	 ecx, DWORD PTR [eax+5880]
  000cc	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
$L311991:

; 4331 : 	}
; 4332 : 	NEXT_VISIBILITYRANGE( pUser )

  000d1	8a 46 15	 mov	 al, BYTE PTR [esi+21]
  000d4	84 c0		 test	 al, al
  000d6	75 42		 jne	 SHORT $L312119
  000d8	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000db	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  000de	84 c9		 test	 cl, cl
  000e0	75 1b		 jne	 SHORT $L312153
  000e2	8b f0		 mov	 esi, eax
  000e4	8b 06		 mov	 eax, DWORD PTR [esi]
  000e6	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  000e9	84 c9		 test	 cl, cl
  000eb	75 2d		 jne	 SHORT $L312119
  000ed	8d 49 00	 npad	 3
$L312133:
  000f0	8b f0		 mov	 esi, eax
  000f2	8b 06		 mov	 eax, DWORD PTR [esi]
  000f4	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  000f7	84 c9		 test	 cl, cl
  000f9	74 f5		 je	 SHORT $L312133
  000fb	eb 1d		 jmp	 SHORT $L312119
$L312153:
  000fd	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00100	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00103	84 c9		 test	 cl, cl
  00105	75 11		 jne	 SHORT $L312122
$L312121:
  00107	3b 70 08	 cmp	 esi, DWORD PTR [eax+8]
  0010a	75 0c		 jne	 SHORT $L312122
  0010c	8b f0		 mov	 esi, eax
  0010e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00111	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00114	84 c9		 test	 cl, cl
  00116	74 ef		 je	 SHORT $L312121
$L312122:
  00118	8b f0		 mov	 esi, eax
$L312119:

; 4327 : 
; 4328 : 	FOR_VISIBILITYRANGE( pUser )

  0011a	3b f7		 cmp	 esi, edi
  0011c	75 92		 jne	 SHORT $L280300
$L280301:

; 4333 : }

  0011e	8d 4c 24 10	 lea	 ecx, DWORD PTR _ar$[esp+16436]
  00122	c7 84 24 30 40
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+16444], -1
  0012d	e8 00 00 00 00	 call	 ??1CAr@@QAE@XZ		; CAr::~CAr
  00132	8b 8c 24 28 40
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+16436]
  00139	5f		 pop	 edi
  0013a	5e		 pop	 esi
  0013b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00142	8b 8c 24 1c 40
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+16428]
  00149	5d		 pop	 ebp
  0014a	33 cc		 xor	 ecx, esp
  0014c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00151	81 c4 28 40 00
	00		 add	 esp, 16424		; 00004028H
  00157	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L311898:
  00000	8d 8d dc bf ff
	ff		 lea	 ecx, DWORD PTR _ar$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CAr@@QAE@XZ		; CAr::~CAr
__ehhandler$?AddStartCollecting@CUserMng@@QAEXPAVCUser@@@Z:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T312150
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?AddStartCollecting@CUserMng@@QAEXPAVCUser@@@Z ENDP	; CUserMng::AddStartCollecting
PUBLIC	?AddStopCollecting@CUserMng@@QAEXPAVCUser@@@Z	; CUserMng::AddStopCollecting
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
xdata$x	SEGMENT
$T312427 DD	0ffffffffH
	DD	FLAT:$L312167
$T312419 DD	019930520H
	DD	01H
	DD	FLAT:$T312427
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
xdata$x	ENDS
;	COMDAT ?AddStopCollecting@CUserMng@@QAEXPAVCUser@@@Z
_TEXT	SEGMENT
_nBufSize$ = -16424					; size = 4
_ar$ = -16420						; size = 16404
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_pUser$ = 8						; size = 4
?AddStopCollecting@CUserMng@@QAEXPAVCUser@@@Z PROC NEAR	; CUserMng::AddStopCollecting, COMDAT
; _this$ = ecx

; 4336 : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?AddStopCollecting@CUserMng@@QAEXPAVCUser@@@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	b8 1c 40 00 00	 mov	 eax, 16412		; 0000401cH
  00013	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0001a	e8 00 00 00 00	 call	 __chkstk
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00024	33 c4		 xor	 eax, esp
  00026	55		 push	 ebp
  00027	56		 push	 esi
  00028	8b b4 24 34 40
	00 00		 mov	 esi, DWORD PTR _pUser$[esp+16428]
  0002f	57		 push	 edi

; 4337 : 	CAr ar;

  00030	6a 00		 push	 0
  00032	6a 00		 push	 0
  00034	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  00038	89 84 24 2c 40
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+16444], eax
  0003f	e8 00 00 00 00	 call	 ??0CAr@@QAE@PAXI@Z	; CAr::CAr

; 4338 : 
; 4339 : 	ar << GETID( pUser ) << SNAPSHOTTYPE_STOP_COLLECTING;

  00044	85 f6		 test	 esi, esi
  00046	c7 84 24 30 40
	00 00 00 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+16444], 0
  00051	74 08		 je	 SHORT $L312165
  00053	8b be bc 01 00
	00		 mov	 edi, DWORD PTR [esi+444]
  00059	eb 03		 jmp	 SHORT $L312166
$L312165:
  0005b	83 cf ff	 or	 edi, -1
$L312166:
  0005e	6a 04		 push	 4
  00060	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  00064	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00069	8b 44 24 18	 mov	 eax, DWORD PTR _ar$[esp+16444]
  0006d	89 38		 mov	 DWORD PTR [eax], edi
  0006f	8b 6c 24 18	 mov	 ebp, DWORD PTR _ar$[esp+16444]
  00073	83 c5 04	 add	 ebp, 4
  00076	6a 02		 push	 2
  00078	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  0007c	89 6c 24 1c	 mov	 DWORD PTR _ar$[esp+16448], ebp
  00080	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00085	8b 4c 24 18	 mov	 ecx, DWORD PTR _ar$[esp+16444]
  00089	66 c7 01 24 01	 mov	 WORD PTR [ecx], 292	; 00000124H
  0008e	83 44 24 18 02	 add	 DWORD PTR _ar$[esp+16444], 2

; 4340 : 	
; 4341 : 	GETBLOCK( ar, lpBuf, nBufSize );

  00093	8d 54 24 0c	 lea	 edx, DWORD PTR _nBufSize$[esp+16436]
  00097	52		 push	 edx
  00098	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  0009c	e8 00 00 00 00	 call	 ?GetBuffer@CAr@@QAEPAEPAH@Z ; CAr::GetBuffer

; 4342 : 
; 4343 : 	FOR_VISIBILITYRANGE( pUser )

  000a1	8b be 10 02 00
	00		 mov	 edi, DWORD PTR [esi+528]
  000a7	8b 37		 mov	 esi, DWORD PTR [edi]
  000a9	3b f7		 cmp	 esi, edi
  000ab	8b e8		 mov	 ebp, eax
  000ad	74 6f		 je	 SHORT $L280326
  000af	90		 npad	 1
$L280325:

; 4344 : 	{
; 4345 : 		USERPTR->AddBlock( lpBuf, nBufSize );

  000b0	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  000b3	f6 40 04 01	 test	 BYTE PTR [eax+4], 1
  000b7	8b 4c 24 0c	 mov	 ecx, DWORD PTR _nBufSize$[esp+16436]
  000bb	75 14		 jne	 SHORT $L312260
  000bd	66 ff 80 0c 57
	00 00		 inc	 WORD PTR [eax+22284]
  000c4	51		 push	 ecx
  000c5	55		 push	 ebp
  000c6	8d 88 f8 16 00
	00		 lea	 ecx, DWORD PTR [eax+5880]
  000cc	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
$L312260:

; 4346 : 	}
; 4347 : 	NEXT_VISIBILITYRANGE( pUser )

  000d1	8a 46 15	 mov	 al, BYTE PTR [esi+21]
  000d4	84 c0		 test	 al, al
  000d6	75 42		 jne	 SHORT $L312411
  000d8	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000db	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  000de	84 c9		 test	 cl, cl
  000e0	75 1b		 jne	 SHORT $L312422
  000e2	8b f0		 mov	 esi, eax
  000e4	8b 06		 mov	 eax, DWORD PTR [esi]
  000e6	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  000e9	84 c9		 test	 cl, cl
  000eb	75 2d		 jne	 SHORT $L312411
  000ed	8d 49 00	 npad	 3
$L312390:
  000f0	8b f0		 mov	 esi, eax
  000f2	8b 06		 mov	 eax, DWORD PTR [esi]
  000f4	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  000f7	84 c9		 test	 cl, cl
  000f9	74 f5		 je	 SHORT $L312390
  000fb	eb 1d		 jmp	 SHORT $L312411
$L312422:
  000fd	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00100	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00103	84 c9		 test	 cl, cl
  00105	75 11		 jne	 SHORT $L312414
$L312413:
  00107	3b 70 08	 cmp	 esi, DWORD PTR [eax+8]
  0010a	75 0c		 jne	 SHORT $L312414
  0010c	8b f0		 mov	 esi, eax
  0010e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00111	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00114	84 c9		 test	 cl, cl
  00116	74 ef		 je	 SHORT $L312413
$L312414:
  00118	8b f0		 mov	 esi, eax
$L312411:

; 4342 : 
; 4343 : 	FOR_VISIBILITYRANGE( pUser )

  0011a	3b f7		 cmp	 esi, edi
  0011c	75 92		 jne	 SHORT $L280325
$L280326:

; 4348 : }

  0011e	8d 4c 24 10	 lea	 ecx, DWORD PTR _ar$[esp+16436]
  00122	c7 84 24 30 40
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+16444], -1
  0012d	e8 00 00 00 00	 call	 ??1CAr@@QAE@XZ		; CAr::~CAr
  00132	8b 8c 24 28 40
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+16436]
  00139	5f		 pop	 edi
  0013a	5e		 pop	 esi
  0013b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00142	8b 8c 24 1c 40
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+16428]
  00149	5d		 pop	 ebp
  0014a	33 cc		 xor	 ecx, esp
  0014c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00151	81 c4 28 40 00
	00		 add	 esp, 16424		; 00004028H
  00157	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L312167:
  00000	8d 8d dc bf ff
	ff		 lea	 ecx, DWORD PTR _ar$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CAr@@QAE@XZ		; CAr::~CAr
__ehhandler$?AddStopCollecting@CUserMng@@QAEXPAVCUser@@@Z:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T312419
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?AddStopCollecting@CUserMng@@QAEXPAVCUser@@@Z ENDP	; CUserMng::AddStopCollecting
PUBLIC	?AddChat@CUserMng@@QAEXPAVCCtrl@@PBD@Z		; CUserMng::AddChat
PUBLIC	__real@41200000
EXTRN	?g_DPCoreClient@@3VCDPCoreClient@@A:BYTE	; g_DPCoreClient
EXTRN	?SendChat@CDPCoreClient@@QAEXKKPBD@Z:NEAR	; CDPCoreClient::SendChat
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
xdata$x	SEGMENT
$T312863 DD	0ffffffffH
	DD	FLAT:$L312438
$T312851 DD	019930520H
	DD	01H
	DD	FLAT:$T312863
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT __real@41200000
CONST	SEGMENT
__real@41200000 DD 041200000r			; 10
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
CONST	ENDS
;	COMDAT ?AddChat@CUserMng@@QAEXPAVCCtrl@@PBD@Z
_TEXT	SEGMENT
_nBufSize$ = -16456					; size = 4
_vPos$ = -16452						; size = 12
_bCheck$ = -16440					; size = 4
tv379 = -16436						; size = 4
$T312437 = -16432					; size = 12
_ar$ = -16420						; size = 16404
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_pCtrl$ = 8						; size = 4
_szChat$ = 12						; size = 4
?AddChat@CUserMng@@QAEXPAVCCtrl@@PBD@Z PROC NEAR	; CUserMng::AddChat, COMDAT
; _this$ = ecx

; 4352 : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?AddChat@CUserMng@@QAEXPAVCCtrl@@PBD@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	b8 3c 40 00 00	 mov	 eax, 16444		; 0000403cH
  00013	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0001a	e8 00 00 00 00	 call	 __chkstk
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00024	33 c4		 xor	 eax, esp
  00026	53		 push	 ebx
  00027	8b 9c 24 54 40
	00 00		 mov	 ebx, DWORD PTR _szChat$[esp+16456]
  0002e	55		 push	 ebp
  0002f	56		 push	 esi
  00030	57		 push	 edi
  00031	8b bc 24 5c 40
	00 00		 mov	 edi, DWORD PTR _pCtrl$[esp+16468]

; 4353 : 	CAr ar;

  00038	6a 00		 push	 0
  0003a	6a 00		 push	 0
  0003c	8d 4c 24 3c	 lea	 ecx, DWORD PTR _ar$[esp+16480]
  00040	89 84 24 50 40
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+16480], eax
  00047	e8 00 00 00 00	 call	 ??0CAr@@QAE@PAXI@Z	; CAr::CAr

; 4354 : 
; 4355 : 	ar << GETID( pCtrl ) << SNAPSHOTTYPE_CHAT;

  0004c	85 ff		 test	 edi, edi
  0004e	c7 84 24 54 40
	00 00 00 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+16480], 0
  00059	74 08		 je	 SHORT $L312434
  0005b	8b b7 bc 01 00
	00		 mov	 esi, DWORD PTR [edi+444]
  00061	eb 03		 jmp	 SHORT $L312435
$L312434:
  00063	83 ce ff	 or	 esi, -1
$L312435:
  00066	6a 04		 push	 4
  00068	8d 4c 24 38	 lea	 ecx, DWORD PTR _ar$[esp+16476]
  0006c	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00071	8b 44 24 3c	 mov	 eax, DWORD PTR _ar$[esp+16480]
  00075	89 30		 mov	 DWORD PTR [eax], esi
  00077	8b 54 24 3c	 mov	 edx, DWORD PTR _ar$[esp+16480]
  0007b	83 c2 04	 add	 edx, 4
  0007e	6a 02		 push	 2
  00080	8d 4c 24 38	 lea	 ecx, DWORD PTR _ar$[esp+16476]
  00084	89 54 24 40	 mov	 DWORD PTR _ar$[esp+16484], edx
  00088	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0008d	8b 4c 24 3c	 mov	 ecx, DWORD PTR _ar$[esp+16480]
  00091	66 c7 01 01 00	 mov	 WORD PTR [ecx], 1
  00096	8b 44 24 3c	 mov	 eax, DWORD PTR _ar$[esp+16480]
  0009a	83 c0 02	 add	 eax, 2

; 4356 : 	ar.WriteString( szChat );

  0009d	53		 push	 ebx
  0009e	8d 4c 24 38	 lea	 ecx, DWORD PTR _ar$[esp+16476]
  000a2	89 44 24 40	 mov	 DWORD PTR _ar$[esp+16484], eax
  000a6	e8 00 00 00 00	 call	 ?WriteString@CAr@@QAEXPBD@Z ; CAr::WriteString

; 4357 : 	
; 4358 : 	GETBLOCK( ar, lpBuf, nBufSize );

  000ab	8d 54 24 10	 lea	 edx, DWORD PTR _nBufSize$[esp+16472]
  000af	52		 push	 edx
  000b0	8d 4c 24 38	 lea	 ecx, DWORD PTR _ar$[esp+16476]
  000b4	e8 00 00 00 00	 call	 ?GetBuffer@CAr@@QAEPAEPAH@Z ; CAr::GetBuffer
  000b9	8b e8		 mov	 ebp, eax

; 4359 : 
; 4360 : #ifdef __QUIZ
; 4361 : 	BOOL bCheck = FALSE;
; 4362 : 	D3DXVECTOR3 vPos = D3DXVECTOR3( 0, 0, 0 );
; 4363 : 	if( pCtrl->GetType() == OT_MOVER && ( (CMover*)pCtrl )->IsPlayer() 
; 4364 : 		&& ( (CUser*)pCtrl )->GetWorld() && ( (CUser*)pCtrl )->GetWorld()->GetID() == WI_WORLD_QUIZ )

  000bb	8b 87 70 01 00
	00		 mov	 eax, DWORD PTR [edi+368]
  000c1	83 f8 05	 cmp	 eax, 5
  000c4	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR _bCheck$[esp+16472], 0
  000cc	c7 44 24 14 00
	00 00 00	 mov	 DWORD PTR _vPos$[esp+16472], 0
  000d4	c7 44 24 18 00
	00 00 00	 mov	 DWORD PTR _vPos$[esp+16476], 0
  000dc	c7 44 24 1c 00
	00 00 00	 mov	 DWORD PTR _vPos$[esp+16480], 0
  000e4	75 3e		 jne	 SHORT $L280342
  000e6	8b 87 34 02 00
	00		 mov	 eax, DWORD PTR [edi+564]
  000ec	85 c0		 test	 eax, eax
  000ee	74 34		 je	 SHORT $L280342
  000f0	8b 87 6c 01 00
	00		 mov	 eax, DWORD PTR [edi+364]
  000f6	85 c0		 test	 eax, eax
  000f8	74 2a		 je	 SHORT $L280342
  000fa	81 38 d3 00 00
	00		 cmp	 DWORD PTR [eax], 211	; 000000d3H
  00100	75 22		 jne	 SHORT $L280342

; 4365 : 	{
; 4366 : 		bCheck = TRUE;
; 4367 : 		vPos = ( (CUser*)pCtrl )->GetPos();

  00102	8d 87 60 01 00
	00		 lea	 eax, DWORD PTR [edi+352]
  00108	8b 08		 mov	 ecx, DWORD PTR [eax]
  0010a	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0010d	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00110	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR _bCheck$[esp+16472], 1
  00118	89 4c 24 14	 mov	 DWORD PTR _vPos$[esp+16472], ecx
  0011c	89 54 24 18	 mov	 DWORD PTR _vPos$[esp+16476], edx
  00120	89 44 24 1c	 mov	 DWORD PTR _vPos$[esp+16480], eax
$L280342:

; 4368 : 	}
; 4369 : #endif // __QUIZ
; 4370 : 
; 4371 : 	FOR_VISIBILITYRANGE( pCtrl )

  00124	8b 87 10 02 00
	00		 mov	 eax, DWORD PTR [edi+528]
  0012a	8b 30		 mov	 esi, DWORD PTR [eax]
  0012c	3b f0		 cmp	 esi, eax
  0012e	89 44 24 24	 mov	 DWORD PTR tv379[esp+16472], eax
  00132	0f 84 15 01 00
	00		 je	 $L280361
  00138	eb 06 8d 9b 00
	00 00 00	 npad	 8
$L280360:

; 4372 : 	{
; 4373 : #ifdef __QUIZ
; 4374 : 		if( bCheck )

  00140	8b 44 24 20	 mov	 eax, DWORD PTR _bCheck$[esp+16472]
  00144	85 c0		 test	 eax, eax

; 4375 : 		{
; 4376 : 			D3DXVECTOR3 vDist = vPos - USERPTR->GetPos();

  00146	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00149	74 57		 je	 SHORT $L280362
  0014b	d9 44 24 1c	 fld	 DWORD PTR _vPos$[esp+16480]
  0014f	05 60 01 00 00	 add	 eax, 352		; 00000160H
  00154	8b 08		 mov	 ecx, DWORD PTR [eax]
  00156	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00159	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0015c	89 44 24 30	 mov	 DWORD PTR $T312437[esp+16480], eax
  00160	d8 64 24 30	 fsub	 DWORD PTR $T312437[esp+16480]
  00164	d9 44 24 18	 fld	 DWORD PTR _vPos$[esp+16476]
  00168	89 54 24 2c	 mov	 DWORD PTR $T312437[esp+16476], edx
  0016c	d8 64 24 2c	 fsub	 DWORD PTR $T312437[esp+16476]
  00170	89 4c 24 28	 mov	 DWORD PTR $T312437[esp+16472], ecx
  00174	d9 44 24 14	 fld	 DWORD PTR _vPos$[esp+16472]
  00178	d8 64 24 28	 fsub	 DWORD PTR $T312437[esp+16472]

; 4377 : 			float fDistSq = D3DXVec3LengthSq( &vDist );

  0017c	d9 c0		 fld	 ST(0)
  0017e	d8 c9		 fmul	 ST(0), ST(1)
  00180	d9 c2		 fld	 ST(2)
  00182	d8 cb		 fmul	 ST(0), ST(3)
  00184	de c1		 faddp	 ST(1), ST(0)
  00186	d9 c3		 fld	 ST(3)
  00188	d8 cc		 fmul	 ST(0), ST(4)
  0018a	de c1		 faddp	 ST(1), ST(0)
  0018c	dd db		 fstp	 ST(3)
  0018e	dd d8		 fstp	 ST(0)
  00190	dd d8		 fstp	 ST(0)

; 4378 : 			if( fDistSq <= 10.0f )

  00192	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@41200000
  00198	df e0		 fnstsw	 ax
  0019a	f6 c4 41	 test	 ah, 65			; 00000041H
  0019d	7a 21		 jp	 SHORT $L312638

; 4379 : #endif // __QUIZ
; 4380 : 				USERPTR->AddBlock( lpBuf, nBufSize );

  0019f	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
$L280362:

; 4381 : #ifdef __QUIZ
; 4382 : 		}
; 4383 : 		else
; 4384 : 			USERPTR->AddBlock( lpBuf, nBufSize );

  001a2	f6 40 04 01	 test	 BYTE PTR [eax+4], 1
  001a6	8b 4c 24 10	 mov	 ecx, DWORD PTR _nBufSize$[esp+16472]
  001aa	75 14		 jne	 SHORT $L312638
  001ac	66 ff 80 0c 57
	00 00		 inc	 WORD PTR [eax+22284]
  001b3	51		 push	 ecx
  001b4	8d 88 f8 16 00
	00		 lea	 ecx, DWORD PTR [eax+5880]
  001ba	55		 push	 ebp
  001bb	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
$L312638:

; 4385 : #endif // __QUIZ
; 4386 : 		
; 4387 : 		if( USERPTR->m_idSnoop > 0 && pCtrl->GetType() == OT_MOVER && ( (CMover*)pCtrl )->IsPlayer() )

  001c0	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  001c3	8b 88 9c 95 00
	00		 mov	 ecx, DWORD PTR [eax+38300]
  001c9	85 c9		 test	 ecx, ecx
  001cb	76 2c		 jbe	 SHORT $L280370
  001cd	83 bf 70 01 00
	00 05		 cmp	 DWORD PTR [edi+368], 5
  001d4	75 23		 jne	 SHORT $L280370
  001d6	8b 8f 34 02 00
	00		 mov	 ecx, DWORD PTR [edi+564]
  001dc	85 c9		 test	 ecx, ecx
  001de	74 19		 je	 SHORT $L280370

; 4388 : 			g_DPCoreClient.SendChat( ( (CMover*)pCtrl )->m_idPlayer, USERPTR->m_idPlayer, szChat );

  001e0	8b 88 38 02 00
	00		 mov	 ecx, DWORD PTR [eax+568]
  001e6	8b 97 38 02 00
	00		 mov	 edx, DWORD PTR [edi+568]
  001ec	53		 push	 ebx
  001ed	51		 push	 ecx
  001ee	52		 push	 edx
  001ef	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_DPCoreClient@@3VCDPCoreClient@@A
  001f4	e8 00 00 00 00	 call	 ?SendChat@CDPCoreClient@@QAEXKKPBD@Z ; CDPCoreClient::SendChat
$L280370:

; 4389 : 	}
; 4390 : 	NEXT_VISIBILITYRANGE( pCtrl )

  001f9	8a 46 15	 mov	 al, BYTE PTR [esi+21]
  001fc	84 c0		 test	 al, al
  001fe	75 43		 jne	 SHORT $L312827
  00200	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00203	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00206	84 c9		 test	 cl, cl
  00208	75 18		 jne	 SHORT $L312854
  0020a	8b f0		 mov	 esi, eax
  0020c	8b 06		 mov	 eax, DWORD PTR [esi]
  0020e	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00211	84 c9		 test	 cl, cl
  00213	75 2e		 jne	 SHORT $L312827
$L312839:
  00215	8b f0		 mov	 esi, eax
  00217	8b 06		 mov	 eax, DWORD PTR [esi]
  00219	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  0021c	84 c9		 test	 cl, cl
  0021e	74 f5		 je	 SHORT $L312839
  00220	eb 21		 jmp	 SHORT $L312827
$L312854:
  00222	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00225	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00228	84 c9		 test	 cl, cl
  0022a	75 15		 jne	 SHORT $L312830
  0022c	8d 64 24 00	 npad	 4
$L312829:
  00230	3b 70 08	 cmp	 esi, DWORD PTR [eax+8]
  00233	75 0c		 jne	 SHORT $L312830
  00235	8b f0		 mov	 esi, eax
  00237	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0023a	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  0023d	84 c9		 test	 cl, cl
  0023f	74 ef		 je	 SHORT $L312829
$L312830:
  00241	8b f0		 mov	 esi, eax
$L312827:
  00243	3b 74 24 24	 cmp	 esi, DWORD PTR tv379[esp+16472]
  00247	0f 85 f3 fe ff
	ff		 jne	 $L280360
$L280361:

; 4391 : }

  0024d	8d 4c 24 34	 lea	 ecx, DWORD PTR _ar$[esp+16472]
  00251	c7 84 24 54 40
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+16480], -1
  0025c	e8 00 00 00 00	 call	 ??1CAr@@QAE@XZ		; CAr::~CAr
  00261	8b 8c 24 4c 40
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+16472]
  00268	5f		 pop	 edi
  00269	5e		 pop	 esi
  0026a	5d		 pop	 ebp
  0026b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00272	8b 8c 24 3c 40
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+16460]
  00279	5b		 pop	 ebx
  0027a	33 cc		 xor	 ecx, esp
  0027c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00281	81 c4 48 40 00
	00		 add	 esp, 16456		; 00004048H
  00287	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L312438:
  00000	8d 8d dc bf ff
	ff		 lea	 ecx, DWORD PTR _ar$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CAr@@QAE@XZ		; CAr::~CAr
__ehhandler$?AddChat@CUserMng@@QAEXPAVCCtrl@@PBD@Z:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T312851
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?AddChat@CUserMng@@QAEXPAVCCtrl@@PBD@Z ENDP		; CUserMng::AddChat
PUBLIC	?AddDefinedText@CUserMng@@QAAXPAVCMover@@HPBDZZ	; CUserMng::AddDefinedText
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
xdata$x	SEGMENT
$T312993 DD	0ffffffffH
	DD	FLAT:$L312872
$T312989 DD	019930520H
	DD	01H
	DD	FLAT:$T312993
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
xdata$x	ENDS
;	COMDAT ?AddDefinedText@CUserMng@@QAAXPAVCMover@@HPBDZZ
_TEXT	SEGMENT
__it$ = -17452						; size = 4
_nBufSize$ = -17448					; size = 4
_ar$ = -17444						; size = 16404
_szBuffer$ = -1040					; size = 1024
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_this$ = 8						; size = 4
_pMover$ = 12						; size = 4
_dwText$ = 16						; size = 4
_lpszFormat$ = 20					; size = 4
?AddDefinedText@CUserMng@@QAAXPAVCMover@@HPBDZZ PROC NEAR ; CUserMng::AddDefinedText, COMDAT

; 4394 : {

  00000	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00006	6a ff		 push	 -1
  00008	68 00 00 00 00	 push	 __ehhandler$?AddDefinedText@CUserMng@@QAAXPAVCMover@@HPBDZZ
  0000d	50		 push	 eax
  0000e	b8 20 44 00 00	 mov	 eax, 17440		; 00004420H
  00013	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0001a	e8 00 00 00 00	 call	 __chkstk
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie

; 4395 : 	TCHAR szBuffer[1024];
; 4396 : 	
; 4397 : 	va_list args;
; 4398 : 	va_start( args, lpszFormat );
; 4399 : 	int nBuf = _vsntprintf( szBuffer, sizeof(szBuffer)-1, lpszFormat, args );

  00024	8b 8c 24 3c 44
	00 00		 mov	 ecx, DWORD PTR _lpszFormat$[esp+17448]
  0002b	33 c4		 xor	 eax, esp
  0002d	89 84 24 1c 44
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+17452], eax
  00034	8d 84 24 40 44
	00 00		 lea	 eax, DWORD PTR _lpszFormat$[esp+17452]
  0003b	50		 push	 eax
  0003c	51		 push	 ecx
  0003d	8d 94 24 24 40
	00 00		 lea	 edx, DWORD PTR _szBuffer$[esp+17460]
  00044	68 ff 03 00 00	 push	 1023			; 000003ffH
  00049	52		 push	 edx
  0004a	e8 00 00 00 00	 call	 __vsnprintf
  0004f	83 c4 10	 add	 esp, 16			; 00000010H

; 4400 : 	va_end( args );
; 4401 : 	
; 4402 : 	if( nBuf <= 0 )

  00052	85 c0		 test	 eax, eax
  00054	0f 8e 0f 01 00
	00		 jle	 $L280378
  0005a	55		 push	 ebp
  0005b	56		 push	 esi
  0005c	57		 push	 edi

; 4403 : 		return;
; 4404 : 
; 4405 : 	CAr ar;

  0005d	6a 00		 push	 0
  0005f	6a 00		 push	 0
  00061	8d 4c 24 1c	 lea	 ecx, DWORD PTR _ar$[esp+17472]
  00065	e8 00 00 00 00	 call	 ??0CAr@@QAE@PAXI@Z	; CAr::CAr

; 4406 : 	
; 4407 : 	ar << GETID( pMover ) << SNAPSHOTTYPE_DEFINEDTEXT;

  0006a	8b bc 24 40 44
	00 00		 mov	 edi, DWORD PTR _pMover$[esp+17460]
  00071	85 ff		 test	 edi, edi
  00073	c7 84 24 34 44
	00 00 00 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+17472], 0
  0007e	74 08		 je	 SHORT $L312870
  00080	8b b7 bc 01 00
	00		 mov	 esi, DWORD PTR [edi+444]
  00086	eb 03		 jmp	 SHORT $L312871
$L312870:
  00088	83 ce ff	 or	 esi, -1
$L312871:
  0008b	6a 04		 push	 4
  0008d	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+17468]
  00091	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00096	8b 44 24 1c	 mov	 eax, DWORD PTR _ar$[esp+17472]
  0009a	89 30		 mov	 DWORD PTR [eax], esi
  0009c	8b 6c 24 1c	 mov	 ebp, DWORD PTR _ar$[esp+17472]
  000a0	83 c5 04	 add	 ebp, 4
  000a3	6a 02		 push	 2
  000a5	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+17468]
  000a9	89 6c 24 20	 mov	 DWORD PTR _ar$[esp+17476], ebp
  000ad	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000b2	8b 4c 24 1c	 mov	 ecx, DWORD PTR _ar$[esp+17472]
  000b6	66 c7 01 95 00	 mov	 WORD PTR [ecx], 149	; 00000095H
  000bb	8b 54 24 1c	 mov	 edx, DWORD PTR _ar$[esp+17472]
  000bf	83 c2 02	 add	 edx, 2

; 4408 : 	ar << dwText;

  000c2	6a 04		 push	 4
  000c4	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+17468]
  000c8	89 54 24 20	 mov	 DWORD PTR _ar$[esp+17476], edx
  000cc	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000d1	8b 54 24 1c	 mov	 edx, DWORD PTR _ar$[esp+17472]
  000d5	8b 84 24 44 44
	00 00		 mov	 eax, DWORD PTR _dwText$[esp+17460]
  000dc	89 02		 mov	 DWORD PTR [edx], eax
  000de	8b 44 24 1c	 mov	 eax, DWORD PTR _ar$[esp+17472]

; 4409 : 	ar.WriteString( szBuffer );

  000e2	8d 8c 24 28 40
	00 00		 lea	 ecx, DWORD PTR _szBuffer$[esp+17464]
  000e9	83 c0 04	 add	 eax, 4
  000ec	51		 push	 ecx
  000ed	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+17468]
  000f1	89 44 24 20	 mov	 DWORD PTR _ar$[esp+17476], eax
  000f5	e8 00 00 00 00	 call	 ?WriteString@CAr@@QAEXPBD@Z ; CAr::WriteString

; 4410 : 	
; 4411 : 	GETBLOCK( ar, lpBuf, nBufSize );

  000fa	8d 54 24 10	 lea	 edx, DWORD PTR _nBufSize$[esp+17464]
  000fe	52		 push	 edx
  000ff	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+17468]
  00103	e8 00 00 00 00	 call	 ?GetBuffer@CAr@@QAEPAEPAH@Z ; CAr::GetBuffer

; 4412 : 	
; 4413 : 	FOR_VISIBILITYRANGE( pMover )

  00108	8b b7 10 02 00
	00		 mov	 esi, DWORD PTR [edi+528]
  0010e	8b e8		 mov	 ebp, eax
  00110	8b 06		 mov	 eax, DWORD PTR [esi]
  00112	3b c6		 cmp	 eax, esi
  00114	89 44 24 0c	 mov	 DWORD PTR __it$[esp+17464], eax
  00118	74 38		 je	 SHORT $L280408
  0011a	8d 9b 00 00 00
	00		 npad	 6
$L280407:

; 4414 : 	{
; 4415 : 		USERPTR->AddBlock( lpBuf, nBufSize );

  00120	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00123	f6 40 04 01	 test	 BYTE PTR [eax+4], 1
  00127	8b 4c 24 10	 mov	 ecx, DWORD PTR _nBufSize$[esp+17464]
  0012b	75 14		 jne	 SHORT $L312973
  0012d	66 ff 80 0c 57
	00 00		 inc	 WORD PTR [eax+22284]
  00134	51		 push	 ecx
  00135	55		 push	 ebp
  00136	8d 88 f8 16 00
	00		 lea	 ecx, DWORD PTR [eax+5880]
  0013c	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
$L312973:

; 4416 : 	}
; 4417 : 	NEXT_VISIBILITYRANGE( pMover )		

  00141	8d 4c 24 0c	 lea	 ecx, DWORD PTR __it$[esp+17464]
  00145	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::const_iterator::_Inc
  0014a	8b 44 24 0c	 mov	 eax, DWORD PTR __it$[esp+17464]
  0014e	3b c6		 cmp	 eax, esi
  00150	75 ce		 jne	 SHORT $L280407
$L280408:

; 4418 : }

  00152	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+17464]
  00156	c7 84 24 34 44
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+17472], -1
  00161	e8 00 00 00 00	 call	 ??1CAr@@QAE@XZ		; CAr::~CAr
  00166	5f		 pop	 edi
  00167	5e		 pop	 esi
  00168	5d		 pop	 ebp
$L280378:
  00169	8b 8c 24 20 44
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+17452]
  00170	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00177	8b 8c 24 1c 44
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+17452]
  0017e	33 cc		 xor	 ecx, esp
  00180	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00185	81 c4 2c 44 00
	00		 add	 esp, 17452		; 0000442cH
  0018b	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L312872:
  00000	8d 8d dc bb ff
	ff		 lea	 ecx, DWORD PTR _ar$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CAr@@QAE@XZ		; CAr::~CAr
__ehhandler$?AddDefinedText@CUserMng@@QAAXPAVCMover@@HPBDZZ:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T312989
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?AddDefinedText@CUserMng@@QAAXPAVCMover@@HPBDZZ ENDP	; CUserMng::AddDefinedText
PUBLIC	?AddShipActMsg@CUserMng@@QAEXPAVCMover@@PAVCShip@@KHH@Z ; CUserMng::AddShipActMsg
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
xdata$x	SEGMENT
$T313312 DD	0ffffffffH
	DD	FLAT:$L313002
$T313304 DD	019930520H
	DD	01H
	DD	FLAT:$T313312
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
xdata$x	ENDS
;	COMDAT ?AddShipActMsg@CUserMng@@QAEXPAVCMover@@PAVCShip@@KHH@Z
_TEXT	SEGMENT
_nBufSize$ = -16424					; size = 4
_ar$ = -16420						; size = 16404
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_pMover$ = 8						; size = 4
_pShip$ = 12						; size = 4
_dwMsg$ = 16						; size = 4
_nParam1$ = 20						; size = 4
_nParam2$ = 24						; size = 4
?AddShipActMsg@CUserMng@@QAEXPAVCMover@@PAVCShip@@KHH@Z PROC NEAR ; CUserMng::AddShipActMsg, COMDAT
; _this$ = ecx

; 4420 : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?AddShipActMsg@CUserMng@@QAEXPAVCMover@@PAVCShip@@KHH@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	b8 1c 40 00 00	 mov	 eax, 16412		; 0000401cH
  00013	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0001a	e8 00 00 00 00	 call	 __chkstk
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00024	33 c4		 xor	 eax, esp
  00026	53		 push	 ebx
  00027	55		 push	 ebp
  00028	8b ac 24 34 40
	00 00		 mov	 ebp, DWORD PTR _pMover$[esp+16428]
  0002f	56		 push	 esi
  00030	57		 push	 edi

; 4421 : 	CAr ar;

  00031	6a 00		 push	 0
  00033	6a 00		 push	 0
  00035	8d 4c 24 1c	 lea	 ecx, DWORD PTR _ar$[esp+16448]
  00039	89 84 24 30 40
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+16448], eax
  00040	e8 00 00 00 00	 call	 ??0CAr@@QAE@PAXI@Z	; CAr::CAr

; 4422 : 	
; 4423 : 	ar << GETID( pMover ) << SNAPSHOTTYPE_SHIP_ACTMSG;

  00045	85 ed		 test	 ebp, ebp
  00047	c7 84 24 34 40
	00 00 00 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+16448], 0
  00052	74 08		 je	 SHORT $L313000
  00054	8b b5 bc 01 00
	00		 mov	 esi, DWORD PTR [ebp+444]
  0005a	eb 03		 jmp	 SHORT $L313001
$L313000:
  0005c	83 ce ff	 or	 esi, -1
$L313001:
  0005f	bf 04 00 00 00	 mov	 edi, 4
  00064	57		 push	 edi
  00065	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  00069	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0006e	8b 44 24 1c	 mov	 eax, DWORD PTR _ar$[esp+16448]
  00072	89 30		 mov	 DWORD PTR [eax], esi
  00074	8b 5c 24 1c	 mov	 ebx, DWORD PTR _ar$[esp+16448]
  00078	03 df		 add	 ebx, edi
  0007a	6a 02		 push	 2
  0007c	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  00080	89 5c 24 20	 mov	 DWORD PTR _ar$[esp+16452], ebx
  00084	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00089	8b 4c 24 1c	 mov	 ecx, DWORD PTR _ar$[esp+16448]
  0008d	66 c7 01 ec 00	 mov	 WORD PTR [ecx], 236	; 000000ecH
  00092	83 44 24 1c 02	 add	 DWORD PTR _ar$[esp+16448], 2

; 4424 : 	ar << dwMsg << nParam1 << nParam2 << pShip->GetId();

  00097	8b 94 24 40 40
	00 00		 mov	 edx, DWORD PTR _pShip$[esp+16436]
  0009e	8b b2 bc 01 00
	00		 mov	 esi, DWORD PTR [edx+444]
  000a4	57		 push	 edi
  000a5	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  000a9	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000ae	8b 44 24 1c	 mov	 eax, DWORD PTR _ar$[esp+16448]
  000b2	8b 8c 24 44 40
	00 00		 mov	 ecx, DWORD PTR _dwMsg$[esp+16436]
  000b9	89 08		 mov	 DWORD PTR [eax], ecx
  000bb	8b 44 24 1c	 mov	 eax, DWORD PTR _ar$[esp+16448]
  000bf	03 c7		 add	 eax, edi
  000c1	57		 push	 edi
  000c2	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  000c6	89 44 24 20	 mov	 DWORD PTR _ar$[esp+16452], eax
  000ca	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000cf	8b 54 24 1c	 mov	 edx, DWORD PTR _ar$[esp+16448]
  000d3	8b 84 24 48 40
	00 00		 mov	 eax, DWORD PTR _nParam1$[esp+16436]
  000da	89 02		 mov	 DWORD PTR [edx], eax
  000dc	8b 54 24 1c	 mov	 edx, DWORD PTR _ar$[esp+16448]
  000e0	03 d7		 add	 edx, edi
  000e2	57		 push	 edi
  000e3	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  000e7	89 54 24 20	 mov	 DWORD PTR _ar$[esp+16452], edx
  000eb	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000f0	8b 4c 24 1c	 mov	 ecx, DWORD PTR _ar$[esp+16448]
  000f4	8b 94 24 4c 40
	00 00		 mov	 edx, DWORD PTR _nParam2$[esp+16436]
  000fb	89 11		 mov	 DWORD PTR [ecx], edx
  000fd	8b 44 24 1c	 mov	 eax, DWORD PTR _ar$[esp+16448]
  00101	03 c7		 add	 eax, edi
  00103	57		 push	 edi
  00104	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  00108	89 44 24 20	 mov	 DWORD PTR _ar$[esp+16452], eax
  0010c	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00111	8b 44 24 1c	 mov	 eax, DWORD PTR _ar$[esp+16448]
  00115	89 30		 mov	 DWORD PTR [eax], esi
  00117	8b 74 24 1c	 mov	 esi, DWORD PTR _ar$[esp+16448]

; 4425 : 	
; 4426 : 	GETBLOCK( ar, lpBuf, nBufSize );

  0011b	8d 4c 24 10	 lea	 ecx, DWORD PTR _nBufSize$[esp+16440]
  0011f	51		 push	 ecx
  00120	03 f7		 add	 esi, edi
  00122	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  00126	89 74 24 20	 mov	 DWORD PTR _ar$[esp+16452], esi
  0012a	e8 00 00 00 00	 call	 ?GetBuffer@CAr@@QAEPAEPAH@Z ; CAr::GetBuffer

; 4427 : 	
; 4428 : 	FOR_VISIBILITYRANGE( pMover )

  0012f	8b bd 10 02 00
	00		 mov	 edi, DWORD PTR [ebp+528]
  00135	8b 37		 mov	 esi, DWORD PTR [edi]
  00137	3b f7		 cmp	 esi, edi
  00139	8b d8		 mov	 ebx, eax
  0013b	74 72		 je	 SHORT $L280437
  0013d	8d 49 00	 npad	 3
$L280436:

; 4429 : 		if( USERPTR != pMover )

  00140	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00143	3b c5		 cmp	 eax, ebp
  00145	74 1e		 je	 SHORT $L313145

; 4430 : 			USERPTR->AddBlock( lpBuf, nBufSize );

  00147	f6 40 04 01	 test	 BYTE PTR [eax+4], 1
  0014b	8b 4c 24 10	 mov	 ecx, DWORD PTR _nBufSize$[esp+16440]
  0014f	75 14		 jne	 SHORT $L313145
  00151	66 ff 80 0c 57
	00 00		 inc	 WORD PTR [eax+22284]
  00158	51		 push	 ecx
  00159	53		 push	 ebx
  0015a	8d 88 f8 16 00
	00		 lea	 ecx, DWORD PTR [eax+5880]
  00160	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
$L313145:

; 4431 : 	NEXT_VISIBILITYRANGE( pMover )

  00165	8a 46 15	 mov	 al, BYTE PTR [esi+21]
  00168	84 c0		 test	 al, al
  0016a	75 3f		 jne	 SHORT $L313273
  0016c	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0016f	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00172	84 c9		 test	 cl, cl
  00174	75 18		 jne	 SHORT $L313307
  00176	8b f0		 mov	 esi, eax
  00178	8b 06		 mov	 eax, DWORD PTR [esi]
  0017a	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  0017d	84 c9		 test	 cl, cl
  0017f	75 2a		 jne	 SHORT $L313273
$L313287:
  00181	8b f0		 mov	 esi, eax
  00183	8b 06		 mov	 eax, DWORD PTR [esi]
  00185	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00188	84 c9		 test	 cl, cl
  0018a	74 f5		 je	 SHORT $L313287
  0018c	eb 1d		 jmp	 SHORT $L313273
$L313307:
  0018e	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00191	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00194	84 c9		 test	 cl, cl
  00196	75 11		 jne	 SHORT $L313276
$L313275:
  00198	3b 70 08	 cmp	 esi, DWORD PTR [eax+8]
  0019b	75 0c		 jne	 SHORT $L313276
  0019d	8b f0		 mov	 esi, eax
  0019f	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001a2	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  001a5	84 c9		 test	 cl, cl
  001a7	74 ef		 je	 SHORT $L313275
$L313276:
  001a9	8b f0		 mov	 esi, eax
$L313273:

; 4427 : 	
; 4428 : 	FOR_VISIBILITYRANGE( pMover )

  001ab	3b f7		 cmp	 esi, edi
  001ad	75 91		 jne	 SHORT $L280436
$L280437:

; 4432 : }

  001af	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  001b3	c7 84 24 34 40
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+16448], -1
  001be	e8 00 00 00 00	 call	 ??1CAr@@QAE@XZ		; CAr::~CAr
  001c3	8b 8c 24 2c 40
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+16440]
  001ca	5f		 pop	 edi
  001cb	5e		 pop	 esi
  001cc	5d		 pop	 ebp
  001cd	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  001d4	8b 8c 24 1c 40
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+16428]
  001db	5b		 pop	 ebx
  001dc	33 cc		 xor	 ecx, esp
  001de	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001e3	81 c4 28 40 00
	00		 add	 esp, 16424		; 00004028H
  001e9	c2 14 00	 ret	 20			; 00000014H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L313002:
  00000	8d 8d dc bf ff
	ff		 lea	 ecx, DWORD PTR _ar$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CAr@@QAE@XZ		; CAr::~CAr
__ehhandler$?AddShipActMsg@CUserMng@@QAEXPAVCMover@@PAVCShip@@KHH@Z:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T313304
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?AddShipActMsg@CUserMng@@QAEXPAVCMover@@PAVCShip@@KHH@Z ENDP ; CUserMng::AddShipActMsg
PUBLIC	?AddMotion@CUserMng@@QAEXPAVCMover@@K@Z		; CUserMng::AddMotion
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
xdata$x	SEGMENT
$T313584 DD	0ffffffffH
	DD	FLAT:$L313321
$T313576 DD	019930520H
	DD	01H
	DD	FLAT:$T313584
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
xdata$x	ENDS
;	COMDAT ?AddMotion@CUserMng@@QAEXPAVCMover@@K@Z
_TEXT	SEGMENT
_nBufSize$ = -16424					; size = 4
_ar$ = -16420						; size = 16404
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_pMover$ = 8						; size = 4
_dwMsg$ = 12						; size = 4
?AddMotion@CUserMng@@QAEXPAVCMover@@K@Z PROC NEAR	; CUserMng::AddMotion, COMDAT
; _this$ = ecx

; 4435 : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?AddMotion@CUserMng@@QAEXPAVCMover@@K@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	b8 1c 40 00 00	 mov	 eax, 16412		; 0000401cH
  00013	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0001a	e8 00 00 00 00	 call	 __chkstk
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00024	33 c4		 xor	 eax, esp
  00026	55		 push	 ebp
  00027	56		 push	 esi
  00028	8b b4 24 34 40
	00 00		 mov	 esi, DWORD PTR _pMover$[esp+16428]
  0002f	57		 push	 edi

; 4436 : 	CAr ar;

  00030	6a 00		 push	 0
  00032	6a 00		 push	 0
  00034	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  00038	89 84 24 2c 40
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+16444], eax
  0003f	e8 00 00 00 00	 call	 ??0CAr@@QAE@PAXI@Z	; CAr::CAr

; 4437 : 	ar << GETID( pMover ) << SNAPSHOTTYPE_MOTION;

  00044	85 f6		 test	 esi, esi
  00046	c7 84 24 30 40
	00 00 00 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+16444], 0
  00051	74 08		 je	 SHORT $L313319
  00053	8b be bc 01 00
	00		 mov	 edi, DWORD PTR [esi+444]
  00059	eb 03		 jmp	 SHORT $L313320
$L313319:
  0005b	83 cf ff	 or	 edi, -1
$L313320:
  0005e	6a 04		 push	 4
  00060	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  00064	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00069	8b 44 24 18	 mov	 eax, DWORD PTR _ar$[esp+16444]
  0006d	89 38		 mov	 DWORD PTR [eax], edi
  0006f	8b 54 24 18	 mov	 edx, DWORD PTR _ar$[esp+16444]
  00073	83 c2 04	 add	 edx, 4
  00076	6a 02		 push	 2
  00078	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  0007c	89 54 24 1c	 mov	 DWORD PTR _ar$[esp+16448], edx
  00080	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00085	8b 4c 24 18	 mov	 ecx, DWORD PTR _ar$[esp+16444]
  00089	66 c7 01 98 00	 mov	 WORD PTR [ecx], 152	; 00000098H
  0008e	8b 44 24 18	 mov	 eax, DWORD PTR _ar$[esp+16444]
  00092	83 c0 02	 add	 eax, 2

; 4438 : 	ar << dwMsg;

  00095	6a 04		 push	 4
  00097	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  0009b	89 44 24 1c	 mov	 DWORD PTR _ar$[esp+16448], eax
  0009f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000a4	8b 54 24 18	 mov	 edx, DWORD PTR _ar$[esp+16444]
  000a8	8b 84 24 3c 40
	00 00		 mov	 eax, DWORD PTR _dwMsg$[esp+16432]
  000af	89 02		 mov	 DWORD PTR [edx], eax
  000b1	8b 7c 24 18	 mov	 edi, DWORD PTR _ar$[esp+16444]

; 4439 : 
; 4440 : 	GETBLOCK( ar, lpBuf, nBufSize );

  000b5	8d 4c 24 0c	 lea	 ecx, DWORD PTR _nBufSize$[esp+16436]
  000b9	51		 push	 ecx
  000ba	83 c7 04	 add	 edi, 4
  000bd	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  000c1	89 7c 24 1c	 mov	 DWORD PTR _ar$[esp+16448], edi
  000c5	e8 00 00 00 00	 call	 ?GetBuffer@CAr@@QAEPAEPAH@Z ; CAr::GetBuffer

; 4441 : 
; 4442 : 	FOR_VISIBILITYRANGE( pMover )

  000ca	8b be 10 02 00
	00		 mov	 edi, DWORD PTR [esi+528]
  000d0	8b 37		 mov	 esi, DWORD PTR [edi]
  000d2	3b f7		 cmp	 esi, edi
  000d4	8b e8		 mov	 ebp, eax
  000d6	74 76		 je	 SHORT $L280464
  000d8	eb 06 8d 9b 00
	00 00 00	 npad	 8
$L280463:

; 4443 : 		USERPTR->AddBlock( lpBuf, nBufSize );

  000e0	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  000e3	f6 40 04 01	 test	 BYTE PTR [eax+4], 1
  000e7	8b 4c 24 0c	 mov	 ecx, DWORD PTR _nBufSize$[esp+16436]
  000eb	75 14		 jne	 SHORT $L313420
  000ed	66 ff 80 0c 57
	00 00		 inc	 WORD PTR [eax+22284]
  000f4	51		 push	 ecx
  000f5	55		 push	 ebp
  000f6	8d 88 f8 16 00
	00		 lea	 ecx, DWORD PTR [eax+5880]
  000fc	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
$L313420:

; 4444 : 	NEXT_VISIBILITYRANGE( pMover )

  00101	8a 46 15	 mov	 al, BYTE PTR [esi+21]
  00104	84 c0		 test	 al, al
  00106	75 42		 jne	 SHORT $L313568
  00108	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0010b	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  0010e	84 c9		 test	 cl, cl
  00110	75 1b		 jne	 SHORT $L313579
  00112	8b f0		 mov	 esi, eax
  00114	8b 06		 mov	 eax, DWORD PTR [esi]
  00116	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00119	84 c9		 test	 cl, cl
  0011b	75 2d		 jne	 SHORT $L313568
  0011d	8d 49 00	 npad	 3
$L313556:
  00120	8b f0		 mov	 esi, eax
  00122	8b 06		 mov	 eax, DWORD PTR [esi]
  00124	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00127	84 c9		 test	 cl, cl
  00129	74 f5		 je	 SHORT $L313556
  0012b	eb 1d		 jmp	 SHORT $L313568
$L313579:
  0012d	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00130	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00133	84 c9		 test	 cl, cl
  00135	75 11		 jne	 SHORT $L313571
$L313570:
  00137	3b 70 08	 cmp	 esi, DWORD PTR [eax+8]
  0013a	75 0c		 jne	 SHORT $L313571
  0013c	8b f0		 mov	 esi, eax
  0013e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00141	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00144	84 c9		 test	 cl, cl
  00146	74 ef		 je	 SHORT $L313570
$L313571:
  00148	8b f0		 mov	 esi, eax
$L313568:

; 4441 : 
; 4442 : 	FOR_VISIBILITYRANGE( pMover )

  0014a	3b f7		 cmp	 esi, edi
  0014c	75 92		 jne	 SHORT $L280463
$L280464:

; 4445 : }

  0014e	8d 4c 24 10	 lea	 ecx, DWORD PTR _ar$[esp+16436]
  00152	c7 84 24 30 40
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+16444], -1
  0015d	e8 00 00 00 00	 call	 ??1CAr@@QAE@XZ		; CAr::~CAr
  00162	8b 8c 24 28 40
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+16436]
  00169	5f		 pop	 edi
  0016a	5e		 pop	 esi
  0016b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00172	8b 8c 24 1c 40
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+16428]
  00179	5d		 pop	 ebp
  0017a	33 cc		 xor	 ecx, esp
  0017c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00181	81 c4 28 40 00
	00		 add	 esp, 16424		; 00004028H
  00187	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L313321:
  00000	8d 8d dc bf ff
	ff		 lea	 ecx, DWORD PTR _ar$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CAr@@QAE@XZ		; CAr::~CAr
__ehhandler$?AddMotion@CUserMng@@QAEXPAVCMover@@K@Z:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T313576
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?AddMotion@CUserMng@@QAEXPAVCMover@@K@Z ENDP		; CUserMng::AddMotion
PUBLIC	?AddRemoveAllSkillInfluence@CUserMng@@QAEXPAVCMover@@@Z ; CUserMng::AddRemoveAllSkillInfluence
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
xdata$x	SEGMENT
$T313853 DD	0ffffffffH
	DD	FLAT:$L313593
$T313845 DD	019930520H
	DD	01H
	DD	FLAT:$T313853
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
xdata$x	ENDS
;	COMDAT ?AddRemoveAllSkillInfluence@CUserMng@@QAEXPAVCMover@@@Z
_TEXT	SEGMENT
_nBufSize$ = -16424					; size = 4
_ar$ = -16420						; size = 16404
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_pMover$ = 8						; size = 4
?AddRemoveAllSkillInfluence@CUserMng@@QAEXPAVCMover@@@Z PROC NEAR ; CUserMng::AddRemoveAllSkillInfluence, COMDAT
; _this$ = ecx

; 4448 : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?AddRemoveAllSkillInfluence@CUserMng@@QAEXPAVCMover@@@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	b8 1c 40 00 00	 mov	 eax, 16412		; 0000401cH
  00013	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0001a	e8 00 00 00 00	 call	 __chkstk
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00024	33 c4		 xor	 eax, esp
  00026	55		 push	 ebp
  00027	56		 push	 esi
  00028	8b b4 24 34 40
	00 00		 mov	 esi, DWORD PTR _pMover$[esp+16428]
  0002f	57		 push	 edi

; 4449 : 	CAr ar;

  00030	6a 00		 push	 0
  00032	6a 00		 push	 0
  00034	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  00038	89 84 24 2c 40
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+16444], eax
  0003f	e8 00 00 00 00	 call	 ??0CAr@@QAE@PAXI@Z	; CAr::CAr

; 4450 : 	ar << GETID( pMover ) << SNAPSHOTTYPE_REMOVEALLSKILLINFULENCE;

  00044	85 f6		 test	 esi, esi
  00046	c7 84 24 30 40
	00 00 00 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+16444], 0
  00051	74 08		 je	 SHORT $L313591
  00053	8b be bc 01 00
	00		 mov	 edi, DWORD PTR [esi+444]
  00059	eb 03		 jmp	 SHORT $L313592
$L313591:
  0005b	83 cf ff	 or	 edi, -1
$L313592:
  0005e	6a 04		 push	 4
  00060	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  00064	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00069	8b 44 24 18	 mov	 eax, DWORD PTR _ar$[esp+16444]
  0006d	89 38		 mov	 DWORD PTR [eax], edi
  0006f	8b 6c 24 18	 mov	 ebp, DWORD PTR _ar$[esp+16444]
  00073	83 c5 04	 add	 ebp, 4
  00076	6a 02		 push	 2
  00078	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  0007c	89 6c 24 1c	 mov	 DWORD PTR _ar$[esp+16448], ebp
  00080	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00085	8b 4c 24 18	 mov	 ecx, DWORD PTR _ar$[esp+16444]
  00089	66 c7 01 f4 00	 mov	 WORD PTR [ecx], 244	; 000000f4H
  0008e	83 44 24 18 02	 add	 DWORD PTR _ar$[esp+16444], 2

; 4451 : 	
; 4452 : 	GETBLOCK( ar, lpBuf, nBufSize );

  00093	8d 54 24 0c	 lea	 edx, DWORD PTR _nBufSize$[esp+16436]
  00097	52		 push	 edx
  00098	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  0009c	e8 00 00 00 00	 call	 ?GetBuffer@CAr@@QAEPAEPAH@Z ; CAr::GetBuffer

; 4453 : 	
; 4454 : 	FOR_VISIBILITYRANGE( pMover )

  000a1	8b be 10 02 00
	00		 mov	 edi, DWORD PTR [esi+528]
  000a7	8b 37		 mov	 esi, DWORD PTR [edi]
  000a9	3b f7		 cmp	 esi, edi
  000ab	8b e8		 mov	 ebp, eax
  000ad	74 6f		 je	 SHORT $L280489
  000af	90		 npad	 1
$L280488:

; 4455 : 		USERPTR->AddBlock( lpBuf, nBufSize );

  000b0	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  000b3	f6 40 04 01	 test	 BYTE PTR [eax+4], 1
  000b7	8b 4c 24 0c	 mov	 ecx, DWORD PTR _nBufSize$[esp+16436]
  000bb	75 14		 jne	 SHORT $L313689
  000bd	66 ff 80 0c 57
	00 00		 inc	 WORD PTR [eax+22284]
  000c4	51		 push	 ecx
  000c5	55		 push	 ebp
  000c6	8d 88 f8 16 00
	00		 lea	 ecx, DWORD PTR [eax+5880]
  000cc	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
$L313689:

; 4456 : 	NEXT_VISIBILITYRANGE( pMover )

  000d1	8a 46 15	 mov	 al, BYTE PTR [esi+21]
  000d4	84 c0		 test	 al, al
  000d6	75 42		 jne	 SHORT $L313838
  000d8	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000db	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  000de	84 c9		 test	 cl, cl
  000e0	75 1b		 jne	 SHORT $L313848
  000e2	8b f0		 mov	 esi, eax
  000e4	8b 06		 mov	 eax, DWORD PTR [esi]
  000e6	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  000e9	84 c9		 test	 cl, cl
  000eb	75 2d		 jne	 SHORT $L313838
  000ed	8d 49 00	 npad	 3
$L313826:
  000f0	8b f0		 mov	 esi, eax
  000f2	8b 06		 mov	 eax, DWORD PTR [esi]
  000f4	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  000f7	84 c9		 test	 cl, cl
  000f9	74 f5		 je	 SHORT $L313826
  000fb	eb 1d		 jmp	 SHORT $L313838
$L313848:
  000fd	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00100	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00103	84 c9		 test	 cl, cl
  00105	75 11		 jne	 SHORT $L313841
$L313840:
  00107	3b 70 08	 cmp	 esi, DWORD PTR [eax+8]
  0010a	75 0c		 jne	 SHORT $L313841
  0010c	8b f0		 mov	 esi, eax
  0010e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00111	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00114	84 c9		 test	 cl, cl
  00116	74 ef		 je	 SHORT $L313840
$L313841:
  00118	8b f0		 mov	 esi, eax
$L313838:

; 4453 : 	
; 4454 : 	FOR_VISIBILITYRANGE( pMover )

  0011a	3b f7		 cmp	 esi, edi
  0011c	75 92		 jne	 SHORT $L280488
$L280489:

; 4457 : }

  0011e	8d 4c 24 10	 lea	 ecx, DWORD PTR _ar$[esp+16436]
  00122	c7 84 24 30 40
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+16444], -1
  0012d	e8 00 00 00 00	 call	 ??1CAr@@QAE@XZ		; CAr::~CAr
  00132	8b 8c 24 28 40
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+16436]
  00139	5f		 pop	 edi
  0013a	5e		 pop	 esi
  0013b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00142	8b 8c 24 1c 40
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+16428]
  00149	5d		 pop	 ebp
  0014a	33 cc		 xor	 ecx, esp
  0014c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00151	81 c4 28 40 00
	00		 add	 esp, 16424		; 00004028H
  00157	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L313593:
  00000	8d 8d dc bf ff
	ff		 lea	 ecx, DWORD PTR _ar$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CAr@@QAE@XZ		; CAr::~CAr
__ehhandler$?AddRemoveAllSkillInfluence@CUserMng@@QAEXPAVCMover@@@Z:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T313845
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?AddRemoveAllSkillInfluence@CUserMng@@QAEXPAVCMover@@@Z ENDP ; CUserMng::AddRemoveAllSkillInfluence
PUBLIC	?AddDamage@CUserMng@@QAEXPAVCMover@@KKK@Z	; CUserMng::AddDamage
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
xdata$x	SEGMENT
$T314146 DD	0ffffffffH
	DD	FLAT:$L313863
$T314138 DD	019930520H
	DD	01H
	DD	FLAT:$T314146
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
xdata$x	ENDS
;	COMDAT ?AddDamage@CUserMng@@QAEXPAVCMover@@KKK@Z
_TEXT	SEGMENT
_nBufSize$ = -16440					; size = 4
$T313894 = -16436					; size = 4
$T313890 = -16432					; size = 12
_ar$ = -16420						; size = 16404
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_pMover$ = 8						; size = 4
_objidAttacker$ = 12					; size = 4
_dwHit$ = 16						; size = 4
_dwAtkFlags$ = 20					; size = 4
?AddDamage@CUserMng@@QAEXPAVCMover@@KKK@Z PROC NEAR	; CUserMng::AddDamage, COMDAT
; _this$ = ecx

; 4478 : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?AddDamage@CUserMng@@QAEXPAVCMover@@KKK@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	b8 2c 40 00 00	 mov	 eax, 16428		; 0000402cH
  00013	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0001a	e8 00 00 00 00	 call	 __chkstk
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00024	33 c4		 xor	 eax, esp
  00026	53		 push	 ebx
  00027	55		 push	 ebp
  00028	56		 push	 esi
  00029	57		 push	 edi
  0002a	8b bc 24 4c 40
	00 00		 mov	 edi, DWORD PTR _pMover$[esp+16452]

; 4479 : 	CAr ar;

  00031	6a 00		 push	 0
  00033	6a 00		 push	 0
  00035	8d 4c 24 2c	 lea	 ecx, DWORD PTR _ar$[esp+16464]
  00039	89 84 24 40 40
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+16464], eax
  00040	e8 00 00 00 00	 call	 ??0CAr@@QAE@PAXI@Z	; CAr::CAr

; 4480 : 	ar << GETID( pMover ) << SNAPSHOTTYPE_DAMAGE;

  00045	85 ff		 test	 edi, edi
  00047	c7 84 24 44 40
	00 00 00 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+16464], 0
  00052	74 08		 je	 SHORT $L313860
  00054	8b b7 bc 01 00
	00		 mov	 esi, DWORD PTR [edi+444]
  0005a	eb 03		 jmp	 SHORT $L313861
$L313860:
  0005c	83 ce ff	 or	 esi, -1
$L313861:
  0005f	bb 04 00 00 00	 mov	 ebx, 4
  00064	53		 push	 ebx
  00065	8d 4c 24 28	 lea	 ecx, DWORD PTR _ar$[esp+16460]
  00069	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0006e	8b 44 24 2c	 mov	 eax, DWORD PTR _ar$[esp+16464]
  00072	89 30		 mov	 DWORD PTR [eax], esi
  00074	8b 44 24 2c	 mov	 eax, DWORD PTR _ar$[esp+16464]
  00078	03 c3		 add	 eax, ebx
  0007a	6a 02		 push	 2
  0007c	8d 4c 24 28	 lea	 ecx, DWORD PTR _ar$[esp+16460]
  00080	89 44 24 30	 mov	 DWORD PTR _ar$[esp+16468], eax
  00084	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00089	8b 4c 24 2c	 mov	 ecx, DWORD PTR _ar$[esp+16464]
  0008d	66 c7 01 13 00	 mov	 WORD PTR [ecx], 19	; 00000013H
  00092	8b 74 24 2c	 mov	 esi, DWORD PTR _ar$[esp+16464]
  00096	83 c6 02	 add	 esi, 2

; 4481 : 	ar << objidAttacker << dwHit;

  00099	53		 push	 ebx
  0009a	8d 4c 24 28	 lea	 ecx, DWORD PTR _ar$[esp+16460]
  0009e	89 74 24 30	 mov	 DWORD PTR _ar$[esp+16468], esi
  000a2	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000a7	8b 54 24 2c	 mov	 edx, DWORD PTR _ar$[esp+16464]
  000ab	8b 84 24 50 40
	00 00		 mov	 eax, DWORD PTR _objidAttacker$[esp+16452]
  000b2	89 02		 mov	 DWORD PTR [edx], eax
  000b4	01 5c 24 2c	 add	 DWORD PTR _ar$[esp+16464], ebx
  000b8	53		 push	 ebx
  000b9	8d 4c 24 28	 lea	 ecx, DWORD PTR _ar$[esp+16460]
  000bd	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000c2	8b 4c 24 2c	 mov	 ecx, DWORD PTR _ar$[esp+16464]
  000c6	8b 94 24 54 40
	00 00		 mov	 edx, DWORD PTR _dwHit$[esp+16452]
  000cd	89 11		 mov	 DWORD PTR [ecx], edx
  000cf	8b 6c 24 2c	 mov	 ebp, DWORD PTR _ar$[esp+16464]
  000d3	03 eb		 add	 ebp, ebx

; 4482 : 	ar << dwAtkFlags;

  000d5	53		 push	 ebx
  000d6	8d 4c 24 28	 lea	 ecx, DWORD PTR _ar$[esp+16460]
  000da	89 6c 24 30	 mov	 DWORD PTR _ar$[esp+16468], ebp
  000de	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000e3	8b 84 24 58 40
	00 00		 mov	 eax, DWORD PTR _dwAtkFlags$[esp+16452]
  000ea	8b 4c 24 2c	 mov	 ecx, DWORD PTR _ar$[esp+16464]
  000ee	89 01		 mov	 DWORD PTR [ecx], eax
  000f0	8b 54 24 2c	 mov	 edx, DWORD PTR _ar$[esp+16464]
  000f4	03 d3		 add	 edx, ebx

; 4483 : 
; 4484 : 	if( dwAtkFlags & AF_FLYING )

  000f6	a9 00 00 00 10	 test	 eax, 268435456		; 10000000H
  000fb	89 54 24 2c	 mov	 DWORD PTR _ar$[esp+16464], edx
  000ff	74 4f		 je	 SHORT $L313897

; 4485 : 	{
; 4486 : 		ar << pMover->GetPos();

  00101	8d 97 60 01 00
	00		 lea	 edx, DWORD PTR [edi+352]
  00107	8b 02		 mov	 eax, DWORD PTR [edx]
  00109	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  0010c	8b 52 08	 mov	 edx, DWORD PTR [edx+8]
  0010f	89 44 24 18	 mov	 DWORD PTR $T313890[esp+16456], eax
  00113	6a 0c		 push	 12			; 0000000cH
  00115	8d 44 24 1c	 lea	 eax, DWORD PTR $T313890[esp+16460]
  00119	89 4c 24 20	 mov	 DWORD PTR $T313890[esp+16464], ecx
  0011d	50		 push	 eax
  0011e	8d 4c 24 2c	 lea	 ecx, DWORD PTR _ar$[esp+16464]
  00122	89 54 24 28	 mov	 DWORD PTR $T313890[esp+16472], edx
  00126	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write

; 4487 : 		ar << pMover->GetAngle();

  0012b	8b 4f 18	 mov	 ecx, DWORD PTR [edi+24]
  0012e	89 4c 24 14	 mov	 DWORD PTR $T313894[esp+16456], ecx
  00132	53		 push	 ebx
  00133	8d 4c 24 28	 lea	 ecx, DWORD PTR _ar$[esp+16460]
  00137	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0013c	d9 44 24 14	 fld	 DWORD PTR $T313894[esp+16456]
  00140	8b 54 24 2c	 mov	 edx, DWORD PTR _ar$[esp+16464]
  00144	d9 1a		 fstp	 DWORD PTR [edx]
  00146	8b 44 24 2c	 mov	 eax, DWORD PTR _ar$[esp+16464]
  0014a	03 c3		 add	 eax, ebx
  0014c	89 44 24 2c	 mov	 DWORD PTR _ar$[esp+16464], eax
$L313897:

; 4488 : 	}
; 4489 : 
; 4490 : 	GETBLOCK( ar, lpBuf, nBufSize );

  00150	8d 44 24 10	 lea	 eax, DWORD PTR _nBufSize$[esp+16456]
  00154	50		 push	 eax
  00155	8d 4c 24 28	 lea	 ecx, DWORD PTR _ar$[esp+16460]
  00159	e8 00 00 00 00	 call	 ?GetBuffer@CAr@@QAEPAEPAH@Z ; CAr::GetBuffer

; 4491 : 
; 4492 : 	FOR_VISIBILITYRANGE( pMover )

  0015e	8b bf 10 02 00
	00		 mov	 edi, DWORD PTR [edi+528]
  00164	8b 37		 mov	 esi, DWORD PTR [edi]
  00166	3b f7		 cmp	 esi, edi
  00168	8b e8		 mov	 ebp, eax
  0016a	74 72		 je	 SHORT $L280533
  0016c	b3 01		 mov	 bl, 1
  0016e	8b ff		 npad	 2
$L280532:

; 4493 : 		USERPTR->AddBlock( lpBuf, nBufSize );

  00170	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00173	84 58 04	 test	 BYTE PTR [eax+4], bl
  00176	8b 4c 24 10	 mov	 ecx, DWORD PTR _nBufSize$[esp+16456]
  0017a	75 14		 jne	 SHORT $L313979
  0017c	66 ff 80 0c 57
	00 00		 inc	 WORD PTR [eax+22284]
  00183	51		 push	 ecx
  00184	55		 push	 ebp
  00185	8d 88 f8 16 00
	00		 lea	 ecx, DWORD PTR [eax+5880]
  0018b	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
$L313979:

; 4494 : 	NEXT_VISIBILITYRANGE( pMover )

  00190	8a 46 15	 mov	 al, BYTE PTR [esi+21]
  00193	84 c0		 test	 al, al
  00195	75 43		 jne	 SHORT $L314107
  00197	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0019a	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  0019d	84 c9		 test	 cl, cl
  0019f	75 1c		 jne	 SHORT $L314141
  001a1	8b f0		 mov	 esi, eax
  001a3	8b 06		 mov	 eax, DWORD PTR [esi]
  001a5	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  001a8	84 c9		 test	 cl, cl
  001aa	75 2e		 jne	 SHORT $L314107
  001ac	8d 64 24 00	 npad	 4
$L314121:
  001b0	8b f0		 mov	 esi, eax
  001b2	8b 06		 mov	 eax, DWORD PTR [esi]
  001b4	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  001b7	84 c9		 test	 cl, cl
  001b9	74 f5		 je	 SHORT $L314121
  001bb	eb 1d		 jmp	 SHORT $L314107
$L314141:
  001bd	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  001c0	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  001c3	84 c9		 test	 cl, cl
  001c5	75 11		 jne	 SHORT $L314110
$L314109:
  001c7	3b 70 08	 cmp	 esi, DWORD PTR [eax+8]
  001ca	75 0c		 jne	 SHORT $L314110
  001cc	8b f0		 mov	 esi, eax
  001ce	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001d1	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  001d4	84 c9		 test	 cl, cl
  001d6	74 ef		 je	 SHORT $L314109
$L314110:
  001d8	8b f0		 mov	 esi, eax
$L314107:

; 4491 : 
; 4492 : 	FOR_VISIBILITYRANGE( pMover )

  001da	3b f7		 cmp	 esi, edi
  001dc	75 92		 jne	 SHORT $L280532
$L280533:

; 4495 : }

  001de	8d 4c 24 24	 lea	 ecx, DWORD PTR _ar$[esp+16456]
  001e2	c7 84 24 44 40
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+16464], -1
  001ed	e8 00 00 00 00	 call	 ??1CAr@@QAE@XZ		; CAr::~CAr
  001f2	8b 8c 24 3c 40
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+16456]
  001f9	5f		 pop	 edi
  001fa	5e		 pop	 esi
  001fb	5d		 pop	 ebp
  001fc	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00203	8b 8c 24 2c 40
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+16444]
  0020a	5b		 pop	 ebx
  0020b	33 cc		 xor	 ecx, esp
  0020d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00212	81 c4 38 40 00
	00		 add	 esp, 16440		; 00004038H
  00218	c2 10 00	 ret	 16			; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L313863:
  00000	8d 8d dc bf ff
	ff		 lea	 ecx, DWORD PTR _ar$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CAr@@QAE@XZ		; CAr::~CAr
__ehhandler$?AddDamage@CUserMng@@QAEXPAVCMover@@KKK@Z:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T314138
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?AddDamage@CUserMng@@QAEXPAVCMover@@KKK@Z ENDP		; CUserMng::AddDamage
PUBLIC	?AddDisguise@CUserMng@@QAEXPAVCMover@@K@Z	; CUserMng::AddDisguise
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
xdata$x	SEGMENT
$T314418 DD	0ffffffffH
	DD	FLAT:$L314155
$T314410 DD	019930520H
	DD	01H
	DD	FLAT:$T314418
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
xdata$x	ENDS
;	COMDAT ?AddDisguise@CUserMng@@QAEXPAVCMover@@K@Z
_TEXT	SEGMENT
_nBufSize$ = -16424					; size = 4
_ar$ = -16420						; size = 16404
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_pMover$ = 8						; size = 4
_dwMoverIdx$ = 12					; size = 4
?AddDisguise@CUserMng@@QAEXPAVCMover@@K@Z PROC NEAR	; CUserMng::AddDisguise, COMDAT
; _this$ = ecx

; 4498 : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?AddDisguise@CUserMng@@QAEXPAVCMover@@K@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	b8 1c 40 00 00	 mov	 eax, 16412		; 0000401cH
  00013	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0001a	e8 00 00 00 00	 call	 __chkstk
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00024	33 c4		 xor	 eax, esp
  00026	55		 push	 ebp
  00027	56		 push	 esi
  00028	8b b4 24 34 40
	00 00		 mov	 esi, DWORD PTR _pMover$[esp+16428]
  0002f	57		 push	 edi

; 4499 : 	CAr ar;

  00030	6a 00		 push	 0
  00032	6a 00		 push	 0
  00034	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  00038	89 84 24 2c 40
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+16444], eax
  0003f	e8 00 00 00 00	 call	 ??0CAr@@QAE@PAXI@Z	; CAr::CAr

; 4500 : 	ar << GETID( pMover ) << SNAPSHOTTYPE_DISGUISE << dwMoverIdx;

  00044	85 f6		 test	 esi, esi
  00046	c7 84 24 30 40
	00 00 00 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+16444], 0
  00051	74 08		 je	 SHORT $L314153
  00053	8b be bc 01 00
	00		 mov	 edi, DWORD PTR [esi+444]
  00059	eb 03		 jmp	 SHORT $L314154
$L314153:
  0005b	83 cf ff	 or	 edi, -1
$L314154:
  0005e	6a 04		 push	 4
  00060	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  00064	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00069	8b 44 24 18	 mov	 eax, DWORD PTR _ar$[esp+16444]
  0006d	89 38		 mov	 DWORD PTR [eax], edi
  0006f	8b 54 24 18	 mov	 edx, DWORD PTR _ar$[esp+16444]
  00073	83 c2 04	 add	 edx, 4
  00076	6a 02		 push	 2
  00078	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  0007c	89 54 24 1c	 mov	 DWORD PTR _ar$[esp+16448], edx
  00080	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00085	8b 4c 24 18	 mov	 ecx, DWORD PTR _ar$[esp+16444]
  00089	66 c7 01 f5 00	 mov	 WORD PTR [ecx], 245	; 000000f5H
  0008e	8b 44 24 18	 mov	 eax, DWORD PTR _ar$[esp+16444]
  00092	83 c0 02	 add	 eax, 2
  00095	6a 04		 push	 4
  00097	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  0009b	89 44 24 1c	 mov	 DWORD PTR _ar$[esp+16448], eax
  0009f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000a4	8b 54 24 18	 mov	 edx, DWORD PTR _ar$[esp+16444]
  000a8	8b 84 24 3c 40
	00 00		 mov	 eax, DWORD PTR _dwMoverIdx$[esp+16432]
  000af	89 02		 mov	 DWORD PTR [edx], eax
  000b1	8b 7c 24 18	 mov	 edi, DWORD PTR _ar$[esp+16444]

; 4501 : 
; 4502 : 	GETBLOCK( ar, lpBuf, nBufSize );

  000b5	8d 4c 24 0c	 lea	 ecx, DWORD PTR _nBufSize$[esp+16436]
  000b9	51		 push	 ecx
  000ba	83 c7 04	 add	 edi, 4
  000bd	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  000c1	89 7c 24 1c	 mov	 DWORD PTR _ar$[esp+16448], edi
  000c5	e8 00 00 00 00	 call	 ?GetBuffer@CAr@@QAEPAEPAH@Z ; CAr::GetBuffer

; 4503 : 
; 4504 : 	FOR_VISIBILITYRANGE( pMover )

  000ca	8b be 10 02 00
	00		 mov	 edi, DWORD PTR [esi+528]
  000d0	8b 37		 mov	 esi, DWORD PTR [edi]
  000d2	3b f7		 cmp	 esi, edi
  000d4	8b e8		 mov	 ebp, eax
  000d6	74 76		 je	 SHORT $L280559
  000d8	eb 06 8d 9b 00
	00 00 00	 npad	 8
$L280558:

; 4505 : 		USERPTR->AddBlock( lpBuf, nBufSize );

  000e0	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  000e3	f6 40 04 01	 test	 BYTE PTR [eax+4], 1
  000e7	8b 4c 24 0c	 mov	 ecx, DWORD PTR _nBufSize$[esp+16436]
  000eb	75 14		 jne	 SHORT $L314251
  000ed	66 ff 80 0c 57
	00 00		 inc	 WORD PTR [eax+22284]
  000f4	51		 push	 ecx
  000f5	55		 push	 ebp
  000f6	8d 88 f8 16 00
	00		 lea	 ecx, DWORD PTR [eax+5880]
  000fc	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
$L314251:

; 4506 : 	NEXT_VISIBILITYRANGE( pMover )

  00101	8a 46 15	 mov	 al, BYTE PTR [esi+21]
  00104	84 c0		 test	 al, al
  00106	75 42		 jne	 SHORT $L314382
  00108	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0010b	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  0010e	84 c9		 test	 cl, cl
  00110	75 1b		 jne	 SHORT $L314413
  00112	8b f0		 mov	 esi, eax
  00114	8b 06		 mov	 eax, DWORD PTR [esi]
  00116	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00119	84 c9		 test	 cl, cl
  0011b	75 2d		 jne	 SHORT $L314382
  0011d	8d 49 00	 npad	 3
$L314396:
  00120	8b f0		 mov	 esi, eax
  00122	8b 06		 mov	 eax, DWORD PTR [esi]
  00124	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00127	84 c9		 test	 cl, cl
  00129	74 f5		 je	 SHORT $L314396
  0012b	eb 1d		 jmp	 SHORT $L314382
$L314413:
  0012d	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00130	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00133	84 c9		 test	 cl, cl
  00135	75 11		 jne	 SHORT $L314385
$L314384:
  00137	3b 70 08	 cmp	 esi, DWORD PTR [eax+8]
  0013a	75 0c		 jne	 SHORT $L314385
  0013c	8b f0		 mov	 esi, eax
  0013e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00141	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00144	84 c9		 test	 cl, cl
  00146	74 ef		 je	 SHORT $L314384
$L314385:
  00148	8b f0		 mov	 esi, eax
$L314382:

; 4503 : 
; 4504 : 	FOR_VISIBILITYRANGE( pMover )

  0014a	3b f7		 cmp	 esi, edi
  0014c	75 92		 jne	 SHORT $L280558
$L280559:

; 4507 : }

  0014e	8d 4c 24 10	 lea	 ecx, DWORD PTR _ar$[esp+16436]
  00152	c7 84 24 30 40
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+16444], -1
  0015d	e8 00 00 00 00	 call	 ??1CAr@@QAE@XZ		; CAr::~CAr
  00162	8b 8c 24 28 40
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+16436]
  00169	5f		 pop	 edi
  0016a	5e		 pop	 esi
  0016b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00172	8b 8c 24 1c 40
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+16428]
  00179	5d		 pop	 ebp
  0017a	33 cc		 xor	 ecx, esp
  0017c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00181	81 c4 28 40 00
	00		 add	 esp, 16424		; 00004028H
  00187	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L314155:
  00000	8d 8d dc bf ff
	ff		 lea	 ecx, DWORD PTR _ar$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CAr@@QAE@XZ		; CAr::~CAr
__ehhandler$?AddDisguise@CUserMng@@QAEXPAVCMover@@K@Z:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T314410
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?AddDisguise@CUserMng@@QAEXPAVCMover@@K@Z ENDP		; CUserMng::AddDisguise
PUBLIC	?AddNoDisguise@CUserMng@@QAEXPAVCMover@@@Z	; CUserMng::AddNoDisguise
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
xdata$x	SEGMENT
$T314687 DD	0ffffffffH
	DD	FLAT:$L314427
$T314679 DD	019930520H
	DD	01H
	DD	FLAT:$T314687
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
xdata$x	ENDS
;	COMDAT ?AddNoDisguise@CUserMng@@QAEXPAVCMover@@@Z
_TEXT	SEGMENT
_nBufSize$ = -16424					; size = 4
_ar$ = -16420						; size = 16404
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_pMover$ = 8						; size = 4
?AddNoDisguise@CUserMng@@QAEXPAVCMover@@@Z PROC NEAR	; CUserMng::AddNoDisguise, COMDAT
; _this$ = ecx

; 4509 : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?AddNoDisguise@CUserMng@@QAEXPAVCMover@@@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	b8 1c 40 00 00	 mov	 eax, 16412		; 0000401cH
  00013	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0001a	e8 00 00 00 00	 call	 __chkstk
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00024	33 c4		 xor	 eax, esp
  00026	55		 push	 ebp
  00027	56		 push	 esi
  00028	8b b4 24 34 40
	00 00		 mov	 esi, DWORD PTR _pMover$[esp+16428]
  0002f	57		 push	 edi

; 4510 : 	CAr ar;

  00030	6a 00		 push	 0
  00032	6a 00		 push	 0
  00034	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  00038	89 84 24 2c 40
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+16444], eax
  0003f	e8 00 00 00 00	 call	 ??0CAr@@QAE@PAXI@Z	; CAr::CAr

; 4511 : 	ar << GETID( pMover ) << SNAPSHOTTYPE_NODISGUISE;

  00044	85 f6		 test	 esi, esi
  00046	c7 84 24 30 40
	00 00 00 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+16444], 0
  00051	74 08		 je	 SHORT $L314425
  00053	8b be bc 01 00
	00		 mov	 edi, DWORD PTR [esi+444]
  00059	eb 03		 jmp	 SHORT $L314426
$L314425:
  0005b	83 cf ff	 or	 edi, -1
$L314426:
  0005e	6a 04		 push	 4
  00060	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  00064	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00069	8b 44 24 18	 mov	 eax, DWORD PTR _ar$[esp+16444]
  0006d	89 38		 mov	 DWORD PTR [eax], edi
  0006f	8b 6c 24 18	 mov	 ebp, DWORD PTR _ar$[esp+16444]
  00073	83 c5 04	 add	 ebp, 4
  00076	6a 02		 push	 2
  00078	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  0007c	89 6c 24 1c	 mov	 DWORD PTR _ar$[esp+16448], ebp
  00080	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00085	8b 4c 24 18	 mov	 ecx, DWORD PTR _ar$[esp+16444]
  00089	66 c7 01 f6 00	 mov	 WORD PTR [ecx], 246	; 000000f6H
  0008e	83 44 24 18 02	 add	 DWORD PTR _ar$[esp+16444], 2

; 4512 : 
; 4513 : 	GETBLOCK( ar, lpBuf, nBufSize );

  00093	8d 54 24 0c	 lea	 edx, DWORD PTR _nBufSize$[esp+16436]
  00097	52		 push	 edx
  00098	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  0009c	e8 00 00 00 00	 call	 ?GetBuffer@CAr@@QAEPAEPAH@Z ; CAr::GetBuffer

; 4514 : 
; 4515 : 	FOR_VISIBILITYRANGE( pMover )

  000a1	8b be 10 02 00
	00		 mov	 edi, DWORD PTR [esi+528]
  000a7	8b 37		 mov	 esi, DWORD PTR [edi]
  000a9	3b f7		 cmp	 esi, edi
  000ab	8b e8		 mov	 ebp, eax
  000ad	74 6f		 je	 SHORT $L280584
  000af	90		 npad	 1
$L280583:

; 4516 : 		USERPTR->AddBlock( lpBuf, nBufSize );

  000b0	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  000b3	f6 40 04 01	 test	 BYTE PTR [eax+4], 1
  000b7	8b 4c 24 0c	 mov	 ecx, DWORD PTR _nBufSize$[esp+16436]
  000bb	75 14		 jne	 SHORT $L314523
  000bd	66 ff 80 0c 57
	00 00		 inc	 WORD PTR [eax+22284]
  000c4	51		 push	 ecx
  000c5	55		 push	 ebp
  000c6	8d 88 f8 16 00
	00		 lea	 ecx, DWORD PTR [eax+5880]
  000cc	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
$L314523:

; 4517 : 	NEXT_VISIBILITYRANGE( pMover )

  000d1	8a 46 15	 mov	 al, BYTE PTR [esi+21]
  000d4	84 c0		 test	 al, al
  000d6	75 42		 jne	 SHORT $L314671
  000d8	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000db	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  000de	84 c9		 test	 cl, cl
  000e0	75 1b		 jne	 SHORT $L314682
  000e2	8b f0		 mov	 esi, eax
  000e4	8b 06		 mov	 eax, DWORD PTR [esi]
  000e6	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  000e9	84 c9		 test	 cl, cl
  000eb	75 2d		 jne	 SHORT $L314671
  000ed	8d 49 00	 npad	 3
$L314659:
  000f0	8b f0		 mov	 esi, eax
  000f2	8b 06		 mov	 eax, DWORD PTR [esi]
  000f4	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  000f7	84 c9		 test	 cl, cl
  000f9	74 f5		 je	 SHORT $L314659
  000fb	eb 1d		 jmp	 SHORT $L314671
$L314682:
  000fd	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00100	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00103	84 c9		 test	 cl, cl
  00105	75 11		 jne	 SHORT $L314674
$L314673:
  00107	3b 70 08	 cmp	 esi, DWORD PTR [eax+8]
  0010a	75 0c		 jne	 SHORT $L314674
  0010c	8b f0		 mov	 esi, eax
  0010e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00111	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00114	84 c9		 test	 cl, cl
  00116	74 ef		 je	 SHORT $L314673
$L314674:
  00118	8b f0		 mov	 esi, eax
$L314671:

; 4514 : 
; 4515 : 	FOR_VISIBILITYRANGE( pMover )

  0011a	3b f7		 cmp	 esi, edi
  0011c	75 92		 jne	 SHORT $L280583
$L280584:

; 4518 : }

  0011e	8d 4c 24 10	 lea	 ecx, DWORD PTR _ar$[esp+16436]
  00122	c7 84 24 30 40
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+16444], -1
  0012d	e8 00 00 00 00	 call	 ??1CAr@@QAE@XZ		; CAr::~CAr
  00132	8b 8c 24 28 40
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+16436]
  00139	5f		 pop	 edi
  0013a	5e		 pop	 esi
  0013b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00142	8b 8c 24 1c 40
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+16428]
  00149	5d		 pop	 ebp
  0014a	33 cc		 xor	 ecx, esp
  0014c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00151	81 c4 28 40 00
	00		 add	 esp, 16424		; 00004028H
  00157	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L314427:
  00000	8d 8d dc bf ff
	ff		 lea	 ecx, DWORD PTR _ar$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CAr@@QAE@XZ		; CAr::~CAr
__ehhandler$?AddNoDisguise@CUserMng@@QAEXPAVCMover@@@Z:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T314679
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?AddNoDisguise@CUserMng@@QAEXPAVCMover@@@Z ENDP		; CUserMng::AddNoDisguise
PUBLIC	?AddSetStateLevel@CUserMng@@QAEXPAVCMover@@DJ@Z	; CUserMng::AddSetStateLevel
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
xdata$x	SEGMENT
$T314971 DD	0ffffffffH
	DD	FLAT:$L314696
$T314963 DD	019930520H
	DD	01H
	DD	FLAT:$T314971
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
xdata$x	ENDS
;	COMDAT ?AddSetStateLevel@CUserMng@@QAEXPAVCMover@@DJ@Z
_TEXT	SEGMENT
_nBufSize$ = -16424					; size = 4
_ar$ = -16420						; size = 16404
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_pMover$ = 8						; size = 4
_chID$ = 12						; size = 1
_nValue$ = 16						; size = 4
?AddSetStateLevel@CUserMng@@QAEXPAVCMover@@DJ@Z PROC NEAR ; CUserMng::AddSetStateLevel, COMDAT
; _this$ = ecx

; 4520 : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?AddSetStateLevel@CUserMng@@QAEXPAVCMover@@DJ@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	b8 1c 40 00 00	 mov	 eax, 16412		; 0000401cH
  00013	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0001a	e8 00 00 00 00	 call	 __chkstk
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00024	33 c4		 xor	 eax, esp
  00026	55		 push	 ebp
  00027	56		 push	 esi
  00028	8b b4 24 34 40
	00 00		 mov	 esi, DWORD PTR _pMover$[esp+16428]
  0002f	57		 push	 edi

; 4521 : 	CAr ar;

  00030	6a 00		 push	 0
  00032	6a 00		 push	 0
  00034	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  00038	89 84 24 2c 40
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+16444], eax
  0003f	e8 00 00 00 00	 call	 ??0CAr@@QAE@PAXI@Z	; CAr::CAr

; 4522 : 	ar << GETID( pMover ) << SNAPSHOTTYPE_SET_STAT_LEVEL;

  00044	85 f6		 test	 esi, esi
  00046	c7 84 24 30 40
	00 00 00 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+16444], 0
  00051	74 08		 je	 SHORT $L314694
  00053	8b be bc 01 00
	00		 mov	 edi, DWORD PTR [esi+444]
  00059	eb 03		 jmp	 SHORT $L314695
$L314694:
  0005b	83 cf ff	 or	 edi, -1
$L314695:
  0005e	bd 04 00 00 00	 mov	 ebp, 4
  00063	55		 push	 ebp
  00064	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  00068	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0006d	8b 44 24 18	 mov	 eax, DWORD PTR _ar$[esp+16444]
  00071	89 38		 mov	 DWORD PTR [eax], edi
  00073	8b 7c 24 18	 mov	 edi, DWORD PTR _ar$[esp+16444]
  00077	03 fd		 add	 edi, ebp
  00079	6a 02		 push	 2
  0007b	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  0007f	89 7c 24 1c	 mov	 DWORD PTR _ar$[esp+16448], edi
  00083	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00088	8b 4c 24 18	 mov	 ecx, DWORD PTR _ar$[esp+16444]
  0008c	66 c7 01 a4 00	 mov	 WORD PTR [ecx], 164	; 000000a4H
  00091	83 44 24 18 02	 add	 DWORD PTR _ar$[esp+16444], 2

; 4523 : 	ar << chID << nValue << pMover->m_nRemainGP;

  00096	6a 01		 push	 1
  00098	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  0009c	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000a1	8b 54 24 18	 mov	 edx, DWORD PTR _ar$[esp+16444]
  000a5	8a 84 24 3c 40
	00 00		 mov	 al, BYTE PTR _chID$[esp+16432]
  000ac	88 02		 mov	 BYTE PTR [edx], al
  000ae	8b 7c 24 18	 mov	 edi, DWORD PTR _ar$[esp+16444]
  000b2	47		 inc	 edi
  000b3	55		 push	 ebp
  000b4	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  000b8	89 7c 24 1c	 mov	 DWORD PTR _ar$[esp+16448], edi
  000bc	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000c1	8b 4c 24 18	 mov	 ecx, DWORD PTR _ar$[esp+16444]
  000c5	8b 94 24 40 40
	00 00		 mov	 edx, DWORD PTR _nValue$[esp+16432]
  000cc	89 11		 mov	 DWORD PTR [ecx], edx
  000ce	8b 4c 24 18	 mov	 ecx, DWORD PTR _ar$[esp+16444]
  000d2	8b be 0c 06 00
	00		 mov	 edi, DWORD PTR [esi+1548]
  000d8	03 cd		 add	 ecx, ebp
  000da	89 4c 24 18	 mov	 DWORD PTR _ar$[esp+16444], ecx
  000de	55		 push	 ebp
  000df	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  000e3	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000e8	8b 44 24 18	 mov	 eax, DWORD PTR _ar$[esp+16444]
  000ec	89 38		 mov	 DWORD PTR [eax], edi
  000ee	8b 7c 24 18	 mov	 edi, DWORD PTR _ar$[esp+16444]

; 4524 : 	GETBLOCK( ar, lpBuf, nBufSize );

  000f2	8d 4c 24 0c	 lea	 ecx, DWORD PTR _nBufSize$[esp+16436]
  000f6	51		 push	 ecx
  000f7	03 fd		 add	 edi, ebp
  000f9	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  000fd	89 7c 24 1c	 mov	 DWORD PTR _ar$[esp+16448], edi
  00101	e8 00 00 00 00	 call	 ?GetBuffer@CAr@@QAEPAEPAH@Z ; CAr::GetBuffer

; 4525 : 	
; 4526 : 	FOR_VISIBILITYRANGE( pMover )

  00106	8b be 10 02 00
	00		 mov	 edi, DWORD PTR [esi+528]
  0010c	8b 37		 mov	 esi, DWORD PTR [edi]
  0010e	3b f7		 cmp	 esi, edi
  00110	8b e8		 mov	 ebp, eax
  00112	74 6b		 je	 SHORT $L280611
$L280610:

; 4527 : 		USERPTR->AddBlock( lpBuf, nBufSize );

  00114	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00117	f6 40 04 01	 test	 BYTE PTR [eax+4], 1
  0011b	8b 4c 24 0c	 mov	 ecx, DWORD PTR _nBufSize$[esp+16436]
  0011f	75 14		 jne	 SHORT $L314807
  00121	66 ff 80 0c 57
	00 00		 inc	 WORD PTR [eax+22284]
  00128	51		 push	 ecx
  00129	55		 push	 ebp
  0012a	8d 88 f8 16 00
	00		 lea	 ecx, DWORD PTR [eax+5880]
  00130	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
$L314807:

; 4528 : 	NEXT_VISIBILITYRANGE( pMover )

  00135	8a 46 15	 mov	 al, BYTE PTR [esi+21]
  00138	84 c0		 test	 al, al
  0013a	75 3f		 jne	 SHORT $L314931
  0013c	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0013f	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00142	84 c9		 test	 cl, cl
  00144	75 18		 jne	 SHORT $L314966
  00146	8b f0		 mov	 esi, eax
  00148	8b 06		 mov	 eax, DWORD PTR [esi]
  0014a	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  0014d	84 c9		 test	 cl, cl
  0014f	75 2a		 jne	 SHORT $L314931
$L314952:
  00151	8b f0		 mov	 esi, eax
  00153	8b 06		 mov	 eax, DWORD PTR [esi]
  00155	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00158	84 c9		 test	 cl, cl
  0015a	74 f5		 je	 SHORT $L314952
  0015c	eb 1d		 jmp	 SHORT $L314931
$L314966:
  0015e	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00161	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00164	84 c9		 test	 cl, cl
  00166	75 11		 jne	 SHORT $L314934
$L314933:
  00168	3b 70 08	 cmp	 esi, DWORD PTR [eax+8]
  0016b	75 0c		 jne	 SHORT $L314934
  0016d	8b f0		 mov	 esi, eax
  0016f	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00172	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00175	84 c9		 test	 cl, cl
  00177	74 ef		 je	 SHORT $L314933
$L314934:
  00179	8b f0		 mov	 esi, eax
$L314931:

; 4525 : 	
; 4526 : 	FOR_VISIBILITYRANGE( pMover )

  0017b	3b f7		 cmp	 esi, edi
  0017d	75 95		 jne	 SHORT $L280610
$L280611:

; 4529 : }

  0017f	8d 4c 24 10	 lea	 ecx, DWORD PTR _ar$[esp+16436]
  00183	c7 84 24 30 40
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+16444], -1
  0018e	e8 00 00 00 00	 call	 ??1CAr@@QAE@XZ		; CAr::~CAr
  00193	8b 8c 24 28 40
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+16436]
  0019a	5f		 pop	 edi
  0019b	5e		 pop	 esi
  0019c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  001a3	8b 8c 24 1c 40
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+16428]
  001aa	5d		 pop	 ebp
  001ab	33 cc		 xor	 ecx, esp
  001ad	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001b2	81 c4 28 40 00
	00		 add	 esp, 16424		; 00004028H
  001b8	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L314696:
  00000	8d 8d dc bf ff
	ff		 lea	 ecx, DWORD PTR _ar$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CAr@@QAE@XZ		; CAr::~CAr
__ehhandler$?AddSetStateLevel@CUserMng@@QAEXPAVCMover@@DJ@Z:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T314963
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?AddSetStateLevel@CUserMng@@QAEXPAVCMover@@DJ@Z ENDP	; CUserMng::AddSetStateLevel
PUBLIC	?AddMoverDeath@CUserMng@@QAEXPAVCMover@@0K@Z	; CUserMng::AddMoverDeath
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
xdata$x	SEGMENT
$T315253 DD	0ffffffffH
	DD	FLAT:$L314982
$T315245 DD	019930520H
	DD	01H
	DD	FLAT:$T315253
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
xdata$x	ENDS
;	COMDAT ?AddMoverDeath@CUserMng@@QAEXPAVCMover@@0K@Z
_TEXT	SEGMENT
_nBufSize$ = -16424					; size = 4
_ar$ = -16420						; size = 16404
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_pMover$ = 8						; size = 4
_pAttacker$ = 12					; size = 4
_dwMsg$ = 16						; size = 4
?AddMoverDeath@CUserMng@@QAEXPAVCMover@@0K@Z PROC NEAR	; CUserMng::AddMoverDeath, COMDAT
; _this$ = ecx

; 4531 : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?AddMoverDeath@CUserMng@@QAEXPAVCMover@@0K@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	b8 1c 40 00 00	 mov	 eax, 16412		; 0000401cH
  00013	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0001a	e8 00 00 00 00	 call	 __chkstk
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00024	33 c4		 xor	 eax, esp
  00026	53		 push	 ebx
  00027	55		 push	 ebp
  00028	56		 push	 esi
  00029	57		 push	 edi
  0002a	8b bc 24 3c 40
	00 00		 mov	 edi, DWORD PTR _pMover$[esp+16436]

; 4532 : 	CAr ar;

  00031	6a 00		 push	 0
  00033	6a 00		 push	 0
  00035	8d 4c 24 1c	 lea	 ecx, DWORD PTR _ar$[esp+16448]
  00039	89 84 24 30 40
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+16448], eax
  00040	e8 00 00 00 00	 call	 ??0CAr@@QAE@PAXI@Z	; CAr::CAr

; 4533 : 	ar << GETID( pMover ) << SNAPSHOTTYPE_MOVERDEATH;

  00045	85 ff		 test	 edi, edi
  00047	c7 84 24 34 40
	00 00 00 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+16448], 0
  00052	74 08		 je	 SHORT $L314978
  00054	8b b7 bc 01 00
	00		 mov	 esi, DWORD PTR [edi+444]
  0005a	eb 03		 jmp	 SHORT $L314979
$L314978:
  0005c	83 ce ff	 or	 esi, -1
$L314979:
  0005f	bb 04 00 00 00	 mov	 ebx, 4
  00064	53		 push	 ebx
  00065	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  00069	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0006e	8b 44 24 1c	 mov	 eax, DWORD PTR _ar$[esp+16448]
  00072	89 30		 mov	 DWORD PTR [eax], esi
  00074	8b 6c 24 1c	 mov	 ebp, DWORD PTR _ar$[esp+16448]
  00078	03 eb		 add	 ebp, ebx
  0007a	6a 02		 push	 2
  0007c	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  00080	89 6c 24 20	 mov	 DWORD PTR _ar$[esp+16452], ebp
  00084	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00089	8b 4c 24 1c	 mov	 ecx, DWORD PTR _ar$[esp+16448]

; 4534 : 	ar << GETID( pAttacker ) << dwMsg;

  0008d	8b 84 24 40 40
	00 00		 mov	 eax, DWORD PTR _pAttacker$[esp+16436]
  00094	66 c7 01 c7 00	 mov	 WORD PTR [ecx], 199	; 000000c7H
  00099	8b 54 24 1c	 mov	 edx, DWORD PTR _ar$[esp+16448]
  0009d	83 c2 02	 add	 edx, 2
  000a0	85 c0		 test	 eax, eax
  000a2	89 54 24 1c	 mov	 DWORD PTR _ar$[esp+16448], edx
  000a6	74 08		 je	 SHORT $L314980
  000a8	8b b0 bc 01 00
	00		 mov	 esi, DWORD PTR [eax+444]
  000ae	eb 03		 jmp	 SHORT $L314981
$L314980:
  000b0	83 ce ff	 or	 esi, -1
$L314981:
  000b3	53		 push	 ebx
  000b4	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  000b8	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000bd	8b 54 24 1c	 mov	 edx, DWORD PTR _ar$[esp+16448]
  000c1	89 32		 mov	 DWORD PTR [edx], esi
  000c3	8b 6c 24 1c	 mov	 ebp, DWORD PTR _ar$[esp+16448]
  000c7	03 eb		 add	 ebp, ebx
  000c9	53		 push	 ebx
  000ca	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  000ce	89 6c 24 20	 mov	 DWORD PTR _ar$[esp+16452], ebp
  000d2	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000d7	8b 44 24 1c	 mov	 eax, DWORD PTR _ar$[esp+16448]
  000db	8b 8c 24 44 40
	00 00		 mov	 ecx, DWORD PTR _dwMsg$[esp+16436]
  000e2	89 08		 mov	 DWORD PTR [eax], ecx
  000e4	01 5c 24 1c	 add	 DWORD PTR _ar$[esp+16448], ebx

; 4535 : 
; 4536 : 	GETBLOCK( ar, lpBuf, nBufSize );

  000e8	8d 54 24 10	 lea	 edx, DWORD PTR _nBufSize$[esp+16440]
  000ec	52		 push	 edx
  000ed	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  000f1	e8 00 00 00 00	 call	 ?GetBuffer@CAr@@QAEPAEPAH@Z ; CAr::GetBuffer

; 4537 : 
; 4538 : 	FOR_VISIBILITYRANGE( pMover )

  000f6	8b bf 10 02 00
	00		 mov	 edi, DWORD PTR [edi+528]
  000fc	8b 37		 mov	 esi, DWORD PTR [edi]
  000fe	3b f7		 cmp	 esi, edi
  00100	8b e8		 mov	 ebp, eax
  00102	74 73		 je	 SHORT $L280638
  00104	b3 01		 mov	 bl, 1
$L280637:

; 4539 : 		USERPTR->AddBlock( lpBuf, nBufSize );

  00106	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00109	84 58 04	 test	 BYTE PTR [eax+4], bl
  0010c	8b 4c 24 10	 mov	 ecx, DWORD PTR _nBufSize$[esp+16440]
  00110	75 14		 jne	 SHORT $L315086
  00112	66 ff 80 0c 57
	00 00		 inc	 WORD PTR [eax+22284]
  00119	51		 push	 ecx
  0011a	55		 push	 ebp
  0011b	8d 88 f8 16 00
	00		 lea	 ecx, DWORD PTR [eax+5880]
  00121	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
$L315086:

; 4540 : 	NEXT_VISIBILITYRANGE( pMover )

  00126	8a 46 15	 mov	 al, BYTE PTR [esi+21]
  00129	84 c0		 test	 al, al
  0012b	75 46		 jne	 SHORT $L315214
  0012d	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00130	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00133	84 c9		 test	 cl, cl
  00135	75 18		 jne	 SHORT $L315248
  00137	8b f0		 mov	 esi, eax
  00139	8b 06		 mov	 eax, DWORD PTR [esi]
  0013b	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  0013e	84 c9		 test	 cl, cl
  00140	75 31		 jne	 SHORT $L315214
$L315228:
  00142	8b f0		 mov	 esi, eax
  00144	8b 06		 mov	 eax, DWORD PTR [esi]
  00146	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00149	84 c9		 test	 cl, cl
  0014b	74 f5		 je	 SHORT $L315228
  0014d	eb 24		 jmp	 SHORT $L315214
$L315248:
  0014f	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00152	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00155	84 c9		 test	 cl, cl
  00157	75 18		 jne	 SHORT $L315217
  00159	8d a4 24 00 00
	00 00		 npad	 7
$L315216:
  00160	3b 70 08	 cmp	 esi, DWORD PTR [eax+8]
  00163	75 0c		 jne	 SHORT $L315217
  00165	8b f0		 mov	 esi, eax
  00167	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0016a	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  0016d	84 c9		 test	 cl, cl
  0016f	74 ef		 je	 SHORT $L315216
$L315217:
  00171	8b f0		 mov	 esi, eax
$L315214:

; 4537 : 
; 4538 : 	FOR_VISIBILITYRANGE( pMover )

  00173	3b f7		 cmp	 esi, edi
  00175	75 8f		 jne	 SHORT $L280637
$L280638:

; 4541 : }

  00177	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  0017b	c7 84 24 34 40
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+16448], -1
  00186	e8 00 00 00 00	 call	 ??1CAr@@QAE@XZ		; CAr::~CAr
  0018b	8b 8c 24 2c 40
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+16440]
  00192	5f		 pop	 edi
  00193	5e		 pop	 esi
  00194	5d		 pop	 ebp
  00195	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0019c	8b 8c 24 1c 40
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+16428]
  001a3	5b		 pop	 ebx
  001a4	33 cc		 xor	 ecx, esp
  001a6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001ab	81 c4 28 40 00
	00		 add	 esp, 16424		; 00004028H
  001b1	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L314982:
  00000	8d 8d dc bf ff
	ff		 lea	 ecx, DWORD PTR _ar$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CAr@@QAE@XZ		; CAr::~CAr
__ehhandler$?AddMoverDeath@CUserMng@@QAEXPAVCMover@@0K@Z:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T315245
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?AddMoverDeath@CUserMng@@QAEXPAVCMover@@0K@Z ENDP	; CUserMng::AddMoverDeath
PUBLIC	?AddUseSkill@CUserMng@@QAEXPAVCMover@@KKKHH@Z	; CUserMng::AddUseSkill
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
xdata$x	SEGMENT
$T315547 DD	0ffffffffH
	DD	FLAT:$L315262
$T315539 DD	019930520H
	DD	01H
	DD	FLAT:$T315547
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
xdata$x	ENDS
;	COMDAT ?AddUseSkill@CUserMng@@QAEXPAVCMover@@KKKHH@Z
_TEXT	SEGMENT
_nBufSize$ = -16424					; size = 4
_ar$ = -16420						; size = 16404
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_pMover$ = 8						; size = 4
_dwSkill$ = 12						; size = 4
_dwLevel$ = 16						; size = 4
_objid$ = 20						; size = 4
_nUseType$ = 24						; size = 4
_nCastingTime$ = 28					; size = 4
?AddUseSkill@CUserMng@@QAEXPAVCMover@@KKKHH@Z PROC NEAR	; CUserMng::AddUseSkill, COMDAT
; _this$ = ecx

; 4544 : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?AddUseSkill@CUserMng@@QAEXPAVCMover@@KKKHH@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	b8 1c 40 00 00	 mov	 eax, 16412		; 0000401cH
  00013	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0001a	e8 00 00 00 00	 call	 __chkstk
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00024	33 c4		 xor	 eax, esp
  00026	53		 push	 ebx
  00027	55		 push	 ebp
  00028	56		 push	 esi
  00029	8b b4 24 38 40
	00 00		 mov	 esi, DWORD PTR _pMover$[esp+16432]
  00030	57		 push	 edi

; 4545 : 	CAr ar;

  00031	6a 00		 push	 0
  00033	6a 00		 push	 0
  00035	8d 4c 24 1c	 lea	 ecx, DWORD PTR _ar$[esp+16448]
  00039	89 84 24 30 40
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+16448], eax
  00040	e8 00 00 00 00	 call	 ??0CAr@@QAE@PAXI@Z	; CAr::CAr

; 4546 : 	ar << GETID( pMover ) << SNAPSHOTTYPE_USESKILL;

  00045	85 f6		 test	 esi, esi
  00047	c7 84 24 34 40
	00 00 00 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+16448], 0
  00052	74 08		 je	 SHORT $L315260
  00054	8b be bc 01 00
	00		 mov	 edi, DWORD PTR [esi+444]
  0005a	eb 03		 jmp	 SHORT $L315261
$L315260:
  0005c	83 cf ff	 or	 edi, -1
$L315261:
  0005f	bb 04 00 00 00	 mov	 ebx, 4
  00064	53		 push	 ebx
  00065	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  00069	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0006e	8b 44 24 1c	 mov	 eax, DWORD PTR _ar$[esp+16448]
  00072	89 38		 mov	 DWORD PTR [eax], edi
  00074	8b 6c 24 1c	 mov	 ebp, DWORD PTR _ar$[esp+16448]
  00078	03 eb		 add	 ebp, ebx
  0007a	6a 02		 push	 2
  0007c	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  00080	89 6c 24 20	 mov	 DWORD PTR _ar$[esp+16452], ebp
  00084	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00089	8b 4c 24 1c	 mov	 ecx, DWORD PTR _ar$[esp+16448]
  0008d	66 c7 01 19 00	 mov	 WORD PTR [ecx], 25	; 00000019H
  00092	8b 54 24 1c	 mov	 edx, DWORD PTR _ar$[esp+16448]
  00096	83 c2 02	 add	 edx, 2

; 4547 : 	ar << dwSkill << dwLevel;

  00099	53		 push	 ebx
  0009a	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  0009e	89 54 24 20	 mov	 DWORD PTR _ar$[esp+16452], edx
  000a2	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000a7	8b 54 24 1c	 mov	 edx, DWORD PTR _ar$[esp+16448]
  000ab	8b 84 24 40 40
	00 00		 mov	 eax, DWORD PTR _dwSkill$[esp+16436]
  000b2	89 02		 mov	 DWORD PTR [edx], eax
  000b4	8b 44 24 1c	 mov	 eax, DWORD PTR _ar$[esp+16448]
  000b8	03 c3		 add	 eax, ebx
  000ba	53		 push	 ebx
  000bb	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  000bf	89 44 24 20	 mov	 DWORD PTR _ar$[esp+16452], eax
  000c3	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000c8	8b 4c 24 1c	 mov	 ecx, DWORD PTR _ar$[esp+16448]
  000cc	8b 94 24 44 40
	00 00		 mov	 edx, DWORD PTR _dwLevel$[esp+16436]
  000d3	89 11		 mov	 DWORD PTR [ecx], edx
  000d5	8b 7c 24 1c	 mov	 edi, DWORD PTR _ar$[esp+16448]
  000d9	03 fb		 add	 edi, ebx

; 4548 : 	ar << objid << nUseType << nCastingTime;

  000db	53		 push	 ebx
  000dc	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  000e0	89 7c 24 20	 mov	 DWORD PTR _ar$[esp+16452], edi
  000e4	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000e9	8b 44 24 1c	 mov	 eax, DWORD PTR _ar$[esp+16448]
  000ed	8b 8c 24 48 40
	00 00		 mov	 ecx, DWORD PTR _objid$[esp+16436]
  000f4	89 08		 mov	 DWORD PTR [eax], ecx
  000f6	01 5c 24 1c	 add	 DWORD PTR _ar$[esp+16448], ebx
  000fa	53		 push	 ebx
  000fb	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  000ff	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00104	8b 54 24 1c	 mov	 edx, DWORD PTR _ar$[esp+16448]
  00108	8b 84 24 4c 40
	00 00		 mov	 eax, DWORD PTR _nUseType$[esp+16436]
  0010f	89 02		 mov	 DWORD PTR [edx], eax
  00111	8b 6c 24 1c	 mov	 ebp, DWORD PTR _ar$[esp+16448]
  00115	03 eb		 add	 ebp, ebx
  00117	53		 push	 ebx
  00118	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  0011c	89 6c 24 20	 mov	 DWORD PTR _ar$[esp+16452], ebp
  00120	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00125	8b 4c 24 1c	 mov	 ecx, DWORD PTR _ar$[esp+16448]
  00129	8b 94 24 50 40
	00 00		 mov	 edx, DWORD PTR _nCastingTime$[esp+16436]
  00130	89 11		 mov	 DWORD PTR [ecx], edx
  00132	8b 54 24 1c	 mov	 edx, DWORD PTR _ar$[esp+16448]

; 4549 : 
; 4550 : 	GETBLOCK( ar, lpBuf, nBufSize );

  00136	8d 44 24 10	 lea	 eax, DWORD PTR _nBufSize$[esp+16440]
  0013a	03 d3		 add	 edx, ebx
  0013c	50		 push	 eax
  0013d	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  00141	89 54 24 20	 mov	 DWORD PTR _ar$[esp+16452], edx
  00145	e8 00 00 00 00	 call	 ?GetBuffer@CAr@@QAEPAEPAH@Z ; CAr::GetBuffer

; 4551 : 
; 4552 : 	FOR_VISIBILITYRANGE( pMover )

  0014a	8b be 10 02 00
	00		 mov	 edi, DWORD PTR [esi+528]
  00150	8b 37		 mov	 esi, DWORD PTR [edi]
  00152	3b f7		 cmp	 esi, edi
  00154	8b e8		 mov	 ebp, eax
  00156	74 76		 je	 SHORT $L280668
  00158	b3 01		 mov	 bl, 1
  0015a	8d 9b 00 00 00
	00		 npad	 6
$L280667:

; 4553 : 		USERPTR->AddBlock( lpBuf, nBufSize );

  00160	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00163	84 58 04	 test	 BYTE PTR [eax+4], bl
  00166	8b 4c 24 10	 mov	 ecx, DWORD PTR _nBufSize$[esp+16440]
  0016a	75 14		 jne	 SHORT $L315380
  0016c	66 ff 80 0c 57
	00 00		 inc	 WORD PTR [eax+22284]
  00173	51		 push	 ecx
  00174	55		 push	 ebp
  00175	8d 88 f8 16 00
	00		 lea	 ecx, DWORD PTR [eax+5880]
  0017b	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
$L315380:

; 4554 : 	NEXT_VISIBILITYRANGE( pMover )

  00180	8a 46 15	 mov	 al, BYTE PTR [esi+21]
  00183	84 c0		 test	 al, al
  00185	75 43		 jne	 SHORT $L315527
  00187	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0018a	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  0018d	84 c9		 test	 cl, cl
  0018f	75 1c		 jne	 SHORT $L315542
  00191	8b f0		 mov	 esi, eax
  00193	8b 06		 mov	 eax, DWORD PTR [esi]
  00195	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00198	84 c9		 test	 cl, cl
  0019a	75 2e		 jne	 SHORT $L315527
  0019c	8d 64 24 00	 npad	 4
$L315515:
  001a0	8b f0		 mov	 esi, eax
  001a2	8b 06		 mov	 eax, DWORD PTR [esi]
  001a4	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  001a7	84 c9		 test	 cl, cl
  001a9	74 f5		 je	 SHORT $L315515
  001ab	eb 1d		 jmp	 SHORT $L315527
$L315542:
  001ad	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  001b0	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  001b3	84 c9		 test	 cl, cl
  001b5	75 11		 jne	 SHORT $L315530
$L315529:
  001b7	3b 70 08	 cmp	 esi, DWORD PTR [eax+8]
  001ba	75 0c		 jne	 SHORT $L315530
  001bc	8b f0		 mov	 esi, eax
  001be	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001c1	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  001c4	84 c9		 test	 cl, cl
  001c6	74 ef		 je	 SHORT $L315529
$L315530:
  001c8	8b f0		 mov	 esi, eax
$L315527:

; 4551 : 
; 4552 : 	FOR_VISIBILITYRANGE( pMover )

  001ca	3b f7		 cmp	 esi, edi
  001cc	75 92		 jne	 SHORT $L280667
$L280668:

; 4555 : }

  001ce	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  001d2	c7 84 24 34 40
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+16448], -1
  001dd	e8 00 00 00 00	 call	 ??1CAr@@QAE@XZ		; CAr::~CAr
  001e2	8b 8c 24 2c 40
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+16440]
  001e9	5f		 pop	 edi
  001ea	5e		 pop	 esi
  001eb	5d		 pop	 ebp
  001ec	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  001f3	8b 8c 24 1c 40
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+16428]
  001fa	5b		 pop	 ebx
  001fb	33 cc		 xor	 ecx, esp
  001fd	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00202	81 c4 28 40 00
	00		 add	 esp, 16424		; 00004028H
  00208	c2 18 00	 ret	 24			; 00000018H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L315262:
  00000	8d 8d dc bf ff
	ff		 lea	 ecx, DWORD PTR _ar$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CAr@@QAE@XZ		; CAr::~CAr
__ehhandler$?AddUseSkill@CUserMng@@QAEXPAVCMover@@KKKHH@Z:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T315539
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?AddUseSkill@CUserMng@@QAEXPAVCMover@@KKKHH@Z ENDP	; CUserMng::AddUseSkill
PUBLIC	?AddDoEquip@CUserMng@@QAEXPAVCMover@@HEABU_EQUIP_INFO@@E@Z ; CUserMng::AddDoEquip
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
xdata$x	SEGMENT
$T315834 DD	0ffffffffH
	DD	FLAT:$L315556
$T315826 DD	019930520H
	DD	01H
	DD	FLAT:$T315834
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
xdata$x	ENDS
;	COMDAT ?AddDoEquip@CUserMng@@QAEXPAVCMover@@HEABU_EQUIP_INFO@@E@Z
_TEXT	SEGMENT
_nBufSize$ = -16424					; size = 4
_ar$ = -16420						; size = 16404
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_pMover$ = 8						; size = 4
_nPart$ = 12						; size = 4
_nId$ = 16						; size = 1
_rEquipInfo$ = 20					; size = 4
_fEquip$ = 24						; size = 1
?AddDoEquip@CUserMng@@QAEXPAVCMover@@HEABU_EQUIP_INFO@@E@Z PROC NEAR ; CUserMng::AddDoEquip, COMDAT
; _this$ = ecx

; 4558 : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?AddDoEquip@CUserMng@@QAEXPAVCMover@@HEABU_EQUIP_INFO@@E@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	b8 1c 40 00 00	 mov	 eax, 16412		; 0000401cH
  00013	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0001a	e8 00 00 00 00	 call	 __chkstk
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00024	33 c4		 xor	 eax, esp
  00026	55		 push	 ebp
  00027	8b ac 24 3c 40
	00 00		 mov	 ebp, DWORD PTR _rEquipInfo$[esp+16424]
  0002e	56		 push	 esi
  0002f	8b b4 24 34 40
	00 00		 mov	 esi, DWORD PTR _pMover$[esp+16428]
  00036	57		 push	 edi

; 4559 : 	CAr ar;

  00037	6a 00		 push	 0
  00039	6a 00		 push	 0
  0003b	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  0003f	89 84 24 2c 40
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+16444], eax
  00046	e8 00 00 00 00	 call	 ??0CAr@@QAE@PAXI@Z	; CAr::CAr

; 4560 : 	DWORD	idGuild = 0;
; 4561 : 
; 4562 : 	ar << GETID( pMover ) << SNAPSHOTTYPE_DOEQUIP;

  0004b	85 f6		 test	 esi, esi
  0004d	c7 84 24 30 40
	00 00 00 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+16444], 0
  00058	74 08		 je	 SHORT $L315554
  0005a	8b be bc 01 00
	00		 mov	 edi, DWORD PTR [esi+444]
  00060	eb 03		 jmp	 SHORT $L315555
$L315554:
  00062	83 cf ff	 or	 edi, -1
$L315555:
  00065	6a 04		 push	 4
  00067	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  0006b	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00070	8b 44 24 18	 mov	 eax, DWORD PTR _ar$[esp+16444]
  00074	89 38		 mov	 DWORD PTR [eax], edi
  00076	8b 7c 24 18	 mov	 edi, DWORD PTR _ar$[esp+16444]
  0007a	83 c7 04	 add	 edi, 4
  0007d	6a 02		 push	 2
  0007f	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  00083	89 7c 24 1c	 mov	 DWORD PTR _ar$[esp+16448], edi
  00087	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0008c	8b 4c 24 18	 mov	 ecx, DWORD PTR _ar$[esp+16444]
  00090	66 c7 01 06 00	 mov	 WORD PTR [ecx], 6
  00095	83 44 24 18 02	 add	 DWORD PTR _ar$[esp+16444], 2

; 4563 : 
; 4564 : 	ar  << nId << idGuild << fEquip;

  0009a	6a 01		 push	 1
  0009c	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  000a0	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000a5	8b 54 24 18	 mov	 edx, DWORD PTR _ar$[esp+16444]
  000a9	8a 84 24 40 40
	00 00		 mov	 al, BYTE PTR _nId$[esp+16432]
  000b0	88 02		 mov	 BYTE PTR [edx], al
  000b2	ff 44 24 18	 inc	 DWORD PTR _ar$[esp+16444]
  000b6	bf 04 00 00 00	 mov	 edi, 4
  000bb	57		 push	 edi
  000bc	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  000c0	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000c5	8b 4c 24 18	 mov	 ecx, DWORD PTR _ar$[esp+16444]
  000c9	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  000cf	01 7c 24 18	 add	 DWORD PTR _ar$[esp+16444], edi
  000d3	6a 01		 push	 1
  000d5	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  000d9	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000de	8b 54 24 18	 mov	 edx, DWORD PTR _ar$[esp+16444]
  000e2	8a 84 24 48 40
	00 00		 mov	 al, BYTE PTR _fEquip$[esp+16432]
  000e9	88 02		 mov	 BYTE PTR [edx], al
  000eb	8b 54 24 18	 mov	 edx, DWORD PTR _ar$[esp+16444]

; 4565 : 	ar.Write( (void*)&rEquipInfo, sizeof(EQUIP_INFO) );

  000ef	6a 0c		 push	 12			; 0000000cH
  000f1	42		 inc	 edx
  000f2	55		 push	 ebp
  000f3	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  000f7	89 54 24 20	 mov	 DWORD PTR _ar$[esp+16452], edx
  000fb	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write

; 4566 : 
; 4567 : 	ar << nPart;

  00100	57		 push	 edi
  00101	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  00105	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0010a	8b 4c 24 18	 mov	 ecx, DWORD PTR _ar$[esp+16444]
  0010e	8b 94 24 3c 40
	00 00		 mov	 edx, DWORD PTR _nPart$[esp+16432]
  00115	89 11		 mov	 DWORD PTR [ecx], edx
  00117	8b 54 24 18	 mov	 edx, DWORD PTR _ar$[esp+16444]

; 4568 : 
; 4569 : 	GETBLOCK( ar, lpBuf, nBufSize );

  0011b	8d 44 24 0c	 lea	 eax, DWORD PTR _nBufSize$[esp+16436]
  0011f	03 d7		 add	 edx, edi
  00121	50		 push	 eax
  00122	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  00126	89 54 24 1c	 mov	 DWORD PTR _ar$[esp+16448], edx
  0012a	e8 00 00 00 00	 call	 ?GetBuffer@CAr@@QAEPAEPAH@Z ; CAr::GetBuffer

; 4570 : 
; 4571 : 	FOR_VISIBILITYRANGE( pMover )

  0012f	8b be 10 02 00
	00		 mov	 edi, DWORD PTR [esi+528]
  00135	8b 37		 mov	 esi, DWORD PTR [edi]
  00137	3b f7		 cmp	 esi, edi
  00139	8b e8		 mov	 ebp, eax
  0013b	74 71		 je	 SHORT $L280700
  0013d	8d 49 00	 npad	 3
$L280699:

; 4572 : 		USERPTR->AddBlock( lpBuf, nBufSize );

  00140	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00143	f6 40 04 01	 test	 BYTE PTR [eax+4], 1
  00147	8b 4c 24 0c	 mov	 ecx, DWORD PTR _nBufSize$[esp+16436]
  0014b	75 14		 jne	 SHORT $L315669
  0014d	66 ff 80 0c 57
	00 00		 inc	 WORD PTR [eax+22284]
  00154	51		 push	 ecx
  00155	55		 push	 ebp
  00156	8d 88 f8 16 00
	00		 lea	 ecx, DWORD PTR [eax+5880]
  0015c	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
$L315669:

; 4573 : 	NEXT_VISIBILITYRANGE( pMover )

  00161	8a 46 15	 mov	 al, BYTE PTR [esi+21]
  00164	84 c0		 test	 al, al
  00166	75 42		 jne	 SHORT $L315817
  00168	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0016b	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  0016e	84 c9		 test	 cl, cl
  00170	75 1b		 jne	 SHORT $L315829
  00172	8b f0		 mov	 esi, eax
  00174	8b 06		 mov	 eax, DWORD PTR [esi]
  00176	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00179	84 c9		 test	 cl, cl
  0017b	75 2d		 jne	 SHORT $L315817
  0017d	8d 49 00	 npad	 3
$L315805:
  00180	8b f0		 mov	 esi, eax
  00182	8b 06		 mov	 eax, DWORD PTR [esi]
  00184	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00187	84 c9		 test	 cl, cl
  00189	74 f5		 je	 SHORT $L315805
  0018b	eb 1d		 jmp	 SHORT $L315817
$L315829:
  0018d	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00190	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00193	84 c9		 test	 cl, cl
  00195	75 11		 jne	 SHORT $L315820
$L315819:
  00197	3b 70 08	 cmp	 esi, DWORD PTR [eax+8]
  0019a	75 0c		 jne	 SHORT $L315820
  0019c	8b f0		 mov	 esi, eax
  0019e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001a1	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  001a4	84 c9		 test	 cl, cl
  001a6	74 ef		 je	 SHORT $L315819
$L315820:
  001a8	8b f0		 mov	 esi, eax
$L315817:

; 4570 : 
; 4571 : 	FOR_VISIBILITYRANGE( pMover )

  001aa	3b f7		 cmp	 esi, edi
  001ac	75 92		 jne	 SHORT $L280699
$L280700:

; 4574 : }

  001ae	8d 4c 24 10	 lea	 ecx, DWORD PTR _ar$[esp+16436]
  001b2	c7 84 24 30 40
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+16444], -1
  001bd	e8 00 00 00 00	 call	 ??1CAr@@QAE@XZ		; CAr::~CAr
  001c2	8b 8c 24 28 40
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+16436]
  001c9	5f		 pop	 edi
  001ca	5e		 pop	 esi
  001cb	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  001d2	8b 8c 24 1c 40
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+16428]
  001d9	5d		 pop	 ebp
  001da	33 cc		 xor	 ecx, esp
  001dc	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001e1	81 c4 28 40 00
	00		 add	 esp, 16424		; 00004028H
  001e7	c2 14 00	 ret	 20			; 00000014H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L315556:
  00000	8d 8d dc bf ff
	ff		 lea	 ecx, DWORD PTR _ar$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CAr@@QAE@XZ		; CAr::~CAr
__ehhandler$?AddDoEquip@CUserMng@@QAEXPAVCMover@@HEABU_EQUIP_INFO@@E@Z:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T315826
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?AddDoEquip@CUserMng@@QAEXPAVCMover@@HEABU_EQUIP_INFO@@E@Z ENDP ; CUserMng::AddDoEquip
PUBLIC	?AddDoEquip@CUserMng@@QAEXPAVCMover@@HPAVCItemElem@@E@Z ; CUserMng::AddDoEquip
; Function compile flags: /Ogty
;	COMDAT ?AddDoEquip@CUserMng@@QAEXPAVCMover@@HPAVCItemElem@@E@Z
_TEXT	SEGMENT
_equipInfo$ = -12					; size = 12
_pMover$ = 8						; size = 4
_nPart$ = 12						; size = 4
_pItemElem$ = 16					; size = 4
_fEquip$ = 20						; size = 1
?AddDoEquip@CUserMng@@QAEXPAVCMover@@HPAVCItemElem@@E@Z PROC NEAR ; CUserMng::AddDoEquip, COMDAT
; _this$ = ecx

; 4577 : {

  00000	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 4578 : 	EQUIP_INFO equipInfo;
; 4579 : 	equipInfo.dwId	= pItemElem->m_dwItemId;

  00003	8b 44 24 18	 mov	 eax, DWORD PTR _pItemElem$[esp+8]
  00007	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  0000a	89 14 24	 mov	 DWORD PTR _equipInfo$[esp+12], edx

; 4580 : 	equipInfo.nOption	= pItemElem->GetAttrOption();

  0000d	8b 90 8c 00 00
	00		 mov	 edx, DWORD PTR [eax+140]
  00013	56		 push	 esi
  00014	0f b6 b0 88 00
	00 00		 movzx	 esi, BYTE PTR [eax+136]
  0001b	c1 e2 08	 shl	 edx, 8
  0001e	0b d6		 or	 edx, esi
  00020	8b 70 70	 mov	 esi, DWORD PTR [eax+112]
  00023	c1 e2 10	 shl	 edx, 16			; 00000010H
  00026	0b d6		 or	 edx, esi
  00028	89 54 24 08	 mov	 DWORD PTR _equipInfo$[esp+20], edx

; 4581 : 	equipInfo.byFlag	= pItemElem->m_byFlag;

  0002c	8a 90 82 00 00
	00		 mov	 dl, BYTE PTR [eax+130]

; 4582 : 	AddDoEquip( pMover, nPart, (BYTE)pItemElem->m_dwObjId, equipInfo, fEquip );

  00032	0f b6 40 04	 movzx	 eax, BYTE PTR [eax+4]
  00036	88 54 24 0c	 mov	 BYTE PTR _equipInfo$[esp+24], dl
  0003a	8b 54 24 20	 mov	 edx, DWORD PTR _fEquip$[esp+12]
  0003e	52		 push	 edx
  0003f	8d 54 24 08	 lea	 edx, DWORD PTR _equipInfo$[esp+20]
  00043	52		 push	 edx
  00044	8b 54 24 20	 mov	 edx, DWORD PTR _nPart$[esp+20]
  00048	50		 push	 eax
  00049	8b 44 24 20	 mov	 eax, DWORD PTR _pMover$[esp+24]
  0004d	52		 push	 edx
  0004e	50		 push	 eax
  0004f	e8 00 00 00 00	 call	 ?AddDoEquip@CUserMng@@QAEXPAVCMover@@HEABU_EQUIP_INFO@@E@Z ; CUserMng::AddDoEquip
  00054	5e		 pop	 esi

; 4583 : }

  00055	83 c4 0c	 add	 esp, 12			; 0000000cH
  00058	c2 10 00	 ret	 16			; 00000010H
?AddDoEquip@CUserMng@@QAEXPAVCMover@@HPAVCItemElem@@E@Z ENDP ; CUserMng::AddDoEquip
_TEXT	ENDS
PUBLIC	?AddVendor@CUserMng@@QAEXPAVCMover@@@Z		; CUserMng::AddVendor
EXTRN	?GetOther@CVTInfo@@QAEPAVCMover@@XZ:NEAR	; CVTInfo::GetOther
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
xdata$x	SEGMENT
$T316139 DD	0ffffffffH
	DD	FLAT:$L315852
$T316129 DD	019930520H
	DD	01H
	DD	FLAT:$T316139
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
xdata$x	ENDS
;	COMDAT ?AddVendor@CUserMng@@QAEXPAVCMover@@@Z
_TEXT	SEGMENT
_nBufSize$ = -16424					; size = 4
_ar$ = -16420						; size = 16404
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_pVendor$ = 8						; size = 4
?AddVendor@CUserMng@@QAEXPAVCMover@@@Z PROC NEAR	; CUserMng::AddVendor, COMDAT
; _this$ = ecx

; 4587 : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?AddVendor@CUserMng@@QAEXPAVCMover@@@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	b8 1c 40 00 00	 mov	 eax, 16412		; 0000401cH
  00013	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0001a	e8 00 00 00 00	 call	 __chkstk
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00024	33 c4		 xor	 eax, esp
  00026	53		 push	 ebx
  00027	55		 push	 ebp
  00028	8b ac 24 34 40
	00 00		 mov	 ebp, DWORD PTR _pVendor$[esp+16428]
  0002f	56		 push	 esi
  00030	57		 push	 edi

; 4588 : 	CAr ar;

  00031	6a 00		 push	 0
  00033	6a 00		 push	 0
  00035	8d 4c 24 1c	 lea	 ecx, DWORD PTR _ar$[esp+16448]
  00039	89 84 24 30 40
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+16448], eax
  00040	e8 00 00 00 00	 call	 ??0CAr@@QAE@PAXI@Z	; CAr::CAr

; 4589 : 	ar << GETID( pVendor ) << SNAPSHOTTYPE_VENDOR;

  00045	85 ed		 test	 ebp, ebp
  00047	c7 84 24 34 40
	00 00 00 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+16448], 0
  00052	74 08		 je	 SHORT $L315850
  00054	8b b5 bc 01 00
	00		 mov	 esi, DWORD PTR [ebp+444]
  0005a	eb 03		 jmp	 SHORT $L315851
$L315850:
  0005c	83 ce ff	 or	 esi, -1
$L315851:
  0005f	6a 04		 push	 4
  00061	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  00065	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0006a	8b 44 24 1c	 mov	 eax, DWORD PTR _ar$[esp+16448]
  0006e	89 30		 mov	 DWORD PTR [eax], esi
  00070	8b 54 24 1c	 mov	 edx, DWORD PTR _ar$[esp+16448]
  00074	83 c2 04	 add	 edx, 4
  00077	6a 02		 push	 2
  00079	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  0007d	89 54 24 20	 mov	 DWORD PTR _ar$[esp+16452], edx
  00081	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00086	8b 4c 24 1c	 mov	 ecx, DWORD PTR _ar$[esp+16448]
  0008a	66 c7 01 15 00	 mov	 WORD PTR [ecx], 21	; 00000015H
  0008f	83 44 24 1c 02	 add	 DWORD PTR _ar$[esp+16448], 2
  00094	8d b5 80 0b 00
	00		 lea	 esi, DWORD PTR [ebp+2944]
  0009a	bf 04 00 00 00	 mov	 edi, 4
  0009f	90		 npad	 1
$L280717:

; 4590 : 
; 4591 : 	for( int i = 0; i < MAX_VENDOR_INVENTORY_TAB; i++ )
; 4592 : 		pVendor->m_ShopInventory[i]->Serialize( ar );

  000a0	8b 0e		 mov	 ecx, DWORD PTR [esi]
  000a2	8d 54 24 14	 lea	 edx, DWORD PTR _ar$[esp+16440]
  000a6	52		 push	 edx
  000a7	e8 00 00 00 00	 call	 ?Serialize@?$CItemContainer@VCItemElem@@@@QAEXAAVCAr@@@Z ; CItemContainer<CItemElem>::Serialize
  000ac	83 c6 04	 add	 esi, 4
  000af	4f		 dec	 edi
  000b0	75 ee		 jne	 SHORT $L280717

; 4593 : 
; 4594 : 	GETBLOCK( ar, lpBuf, nBufSize );

  000b2	8d 44 24 10	 lea	 eax, DWORD PTR _nBufSize$[esp+16440]
  000b6	50		 push	 eax
  000b7	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  000bb	e8 00 00 00 00	 call	 ?GetBuffer@CAr@@QAEPAEPAH@Z ; CAr::GetBuffer

; 4595 : 
; 4596 : 	FOR_VISIBILITYRANGE( pVendor )

  000c0	8b bd 10 02 00
	00		 mov	 edi, DWORD PTR [ebp+528]
  000c6	8b 37		 mov	 esi, DWORD PTR [edi]
  000c8	3b f7		 cmp	 esi, edi
  000ca	8b d8		 mov	 ebx, eax
  000cc	0f 84 7d 00 00
	00		 je	 $L280738
$L280737:

; 4597 : 		if( USERPTR->m_vtInfo.GetOther() == pVendor )

  000d2	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  000d5	81 c1 7c 0d 00
	00		 add	 ecx, 3452		; 00000d7cH
  000db	e8 00 00 00 00	 call	 ?GetOther@CVTInfo@@QAEPAVCMover@@XZ ; CVTInfo::GetOther
  000e0	3b c5		 cmp	 eax, ebp
  000e2	75 21		 jne	 SHORT $L315970

; 4598 : 			USERPTR->AddBlock( lpBuf, nBufSize );

  000e4	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  000e7	f6 40 04 01	 test	 BYTE PTR [eax+4], 1
  000eb	8b 4c 24 10	 mov	 ecx, DWORD PTR _nBufSize$[esp+16440]
  000ef	75 14		 jne	 SHORT $L315970
  000f1	66 ff 80 0c 57
	00 00		 inc	 WORD PTR [eax+22284]
  000f8	51		 push	 ecx
  000f9	53		 push	 ebx
  000fa	8d 88 f8 16 00
	00		 lea	 ecx, DWORD PTR [eax+5880]
  00100	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
$L315970:

; 4599 : 	NEXT_VISIBILITYRANGE( pVendor )

  00105	8a 46 15	 mov	 al, BYTE PTR [esi+21]
  00108	84 c0		 test	 al, al
  0010a	75 3f		 jne	 SHORT $L316097
  0010c	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0010f	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00112	84 c9		 test	 cl, cl
  00114	75 18		 jne	 SHORT $L316133
  00116	8b f0		 mov	 esi, eax
  00118	8b 06		 mov	 eax, DWORD PTR [esi]
  0011a	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  0011d	84 c9		 test	 cl, cl
  0011f	75 2a		 jne	 SHORT $L316097
$L316118:
  00121	8b f0		 mov	 esi, eax
  00123	8b 06		 mov	 eax, DWORD PTR [esi]
  00125	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00128	84 c9		 test	 cl, cl
  0012a	74 f5		 je	 SHORT $L316118
  0012c	eb 1d		 jmp	 SHORT $L316097
$L316133:
  0012e	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00131	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00134	84 c9		 test	 cl, cl
  00136	75 11		 jne	 SHORT $L316100
$L316099:
  00138	3b 70 08	 cmp	 esi, DWORD PTR [eax+8]
  0013b	75 0c		 jne	 SHORT $L316100
  0013d	8b f0		 mov	 esi, eax
  0013f	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00142	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00145	84 c9		 test	 cl, cl
  00147	74 ef		 je	 SHORT $L316099
$L316100:
  00149	8b f0		 mov	 esi, eax
$L316097:

; 4595 : 
; 4596 : 	FOR_VISIBILITYRANGE( pVendor )

  0014b	3b f7		 cmp	 esi, edi
  0014d	75 83		 jne	 SHORT $L280737
$L280738:

; 4600 : }

  0014f	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  00153	c7 84 24 34 40
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+16448], -1
  0015e	e8 00 00 00 00	 call	 ??1CAr@@QAE@XZ		; CAr::~CAr
  00163	8b 8c 24 2c 40
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+16440]
  0016a	5f		 pop	 edi
  0016b	5e		 pop	 esi
  0016c	5d		 pop	 ebp
  0016d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00174	8b 8c 24 1c 40
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+16428]
  0017b	5b		 pop	 ebx
  0017c	33 cc		 xor	 ecx, esp
  0017e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00183	81 c4 28 40 00
	00		 add	 esp, 16424		; 00004028H
  00189	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L315852:
  00000	8d 8d dc bf ff
	ff		 lea	 ecx, DWORD PTR _ar$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CAr@@QAE@XZ		; CAr::~CAr
__ehhandler$?AddVendor@CUserMng@@QAEXPAVCMover@@@Z:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T316129
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?AddVendor@CUserMng@@QAEXPAVCMover@@@Z ENDP		; CUserMng::AddVendor
PUBLIC	?AddUpdateVendor@CUserMng@@QAEXPAVCMover@@DEF@Z	; CUserMng::AddUpdateVendor
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
xdata$x	SEGMENT
$T316452 DD	0ffffffffH
	DD	FLAT:$L316148
$T316444 DD	019930520H
	DD	01H
	DD	FLAT:$T316452
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
xdata$x	ENDS
;	COMDAT ?AddUpdateVendor@CUserMng@@QAEXPAVCMover@@DEF@Z
_TEXT	SEGMENT
_nBufSize$ = -16424					; size = 4
_ar$ = -16420						; size = 16404
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_pVendor$ = 8						; size = 4
_cTab$ = 12						; size = 1
_nId$ = 16						; size = 1
_nNum$ = 20						; size = 2
?AddUpdateVendor@CUserMng@@QAEXPAVCMover@@DEF@Z PROC NEAR ; CUserMng::AddUpdateVendor, COMDAT
; _this$ = ecx

; 4603 : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?AddUpdateVendor@CUserMng@@QAEXPAVCMover@@DEF@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	b8 1c 40 00 00	 mov	 eax, 16412		; 0000401cH
  00013	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0001a	e8 00 00 00 00	 call	 __chkstk
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00024	33 c4		 xor	 eax, esp
  00026	53		 push	 ebx
  00027	55		 push	 ebp
  00028	8b ac 24 34 40
	00 00		 mov	 ebp, DWORD PTR _pVendor$[esp+16428]
  0002f	56		 push	 esi
  00030	57		 push	 edi

; 4604 : 	CAr ar;

  00031	6a 00		 push	 0
  00033	6a 00		 push	 0
  00035	8d 4c 24 1c	 lea	 ecx, DWORD PTR _ar$[esp+16448]
  00039	89 84 24 30 40
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+16448], eax
  00040	e8 00 00 00 00	 call	 ??0CAr@@QAE@PAXI@Z	; CAr::CAr

; 4605 : 	ar << GETID( pVendor ) << SNAPSHOTTYPE_UPDATE_VENDOR;

  00045	85 ed		 test	 ebp, ebp
  00047	c7 84 24 34 40
	00 00 00 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+16448], 0
  00052	74 08		 je	 SHORT $L316146
  00054	8b b5 bc 01 00
	00		 mov	 esi, DWORD PTR [ebp+444]
  0005a	eb 03		 jmp	 SHORT $L316147
$L316146:
  0005c	83 ce ff	 or	 esi, -1
$L316147:
  0005f	6a 04		 push	 4
  00061	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  00065	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0006a	8b 44 24 1c	 mov	 eax, DWORD PTR _ar$[esp+16448]
  0006e	89 30		 mov	 DWORD PTR [eax], esi
  00070	8b 44 24 1c	 mov	 eax, DWORD PTR _ar$[esp+16448]
  00074	83 c0 04	 add	 eax, 4
  00077	be 02 00 00 00	 mov	 esi, 2
  0007c	56		 push	 esi
  0007d	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  00081	89 44 24 20	 mov	 DWORD PTR _ar$[esp+16452], eax
  00085	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0008a	8b 4c 24 1c	 mov	 ecx, DWORD PTR _ar$[esp+16448]
  0008e	66 c7 01 16 00	 mov	 WORD PTR [ecx], 22	; 00000016H
  00093	8b 7c 24 1c	 mov	 edi, DWORD PTR _ar$[esp+16448]
  00097	03 fe		 add	 edi, esi

; 4606 : 
; 4607 : 	ar << cTab << nId << nNum;

  00099	6a 01		 push	 1
  0009b	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  0009f	89 7c 24 20	 mov	 DWORD PTR _ar$[esp+16452], edi
  000a3	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000a8	8b 54 24 1c	 mov	 edx, DWORD PTR _ar$[esp+16448]
  000ac	8a 84 24 40 40
	00 00		 mov	 al, BYTE PTR _cTab$[esp+16436]
  000b3	88 02		 mov	 BYTE PTR [edx], al
  000b5	ff 44 24 1c	 inc	 DWORD PTR _ar$[esp+16448]
  000b9	6a 01		 push	 1
  000bb	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  000bf	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000c4	8b 4c 24 1c	 mov	 ecx, DWORD PTR _ar$[esp+16448]
  000c8	8a 94 24 44 40
	00 00		 mov	 dl, BYTE PTR _nId$[esp+16436]
  000cf	88 11		 mov	 BYTE PTR [ecx], dl
  000d1	8b 5c 24 1c	 mov	 ebx, DWORD PTR _ar$[esp+16448]
  000d5	43		 inc	 ebx
  000d6	56		 push	 esi
  000d7	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  000db	89 5c 24 20	 mov	 DWORD PTR _ar$[esp+16452], ebx
  000df	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000e4	8b 44 24 1c	 mov	 eax, DWORD PTR _ar$[esp+16448]
  000e8	66 8b 8c 24 48
	40 00 00	 mov	 cx, WORD PTR _nNum$[esp+16436]
  000f0	66 89 08	 mov	 WORD PTR [eax], cx
  000f3	01 74 24 1c	 add	 DWORD PTR _ar$[esp+16448], esi

; 4608 : 
; 4609 : 	GETBLOCK( ar, lpBuf, nBufSize );

  000f7	8d 54 24 10	 lea	 edx, DWORD PTR _nBufSize$[esp+16440]
  000fb	52		 push	 edx
  000fc	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  00100	e8 00 00 00 00	 call	 ?GetBuffer@CAr@@QAEPAEPAH@Z ; CAr::GetBuffer

; 4610 : 
; 4611 : 	FOR_VISIBILITYRANGE( pVendor )

  00105	8b bd 10 02 00
	00		 mov	 edi, DWORD PTR [ebp+528]
  0010b	8b 37		 mov	 esi, DWORD PTR [edi]
  0010d	3b f7		 cmp	 esi, edi
  0010f	8b d8		 mov	 ebx, eax
  00111	0f 84 87 00 00
	00		 je	 $L280767
  00117	eb 07 8d a4 24
	00 00 00 00	 npad	 9
$L280766:

; 4612 : 		if( USERPTR->m_vtInfo.GetOther() == pVendor )

  00120	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00123	81 c1 7c 0d 00
	00		 add	 ecx, 3452		; 00000d7cH
  00129	e8 00 00 00 00	 call	 ?GetOther@CVTInfo@@QAEPAVCMover@@XZ ; CVTInfo::GetOther
  0012e	3b c5		 cmp	 eax, ebp
  00130	75 21		 jne	 SHORT $L316285

; 4613 : 			USERPTR->AddBlock( lpBuf, nBufSize );

  00132	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00135	f6 40 04 01	 test	 BYTE PTR [eax+4], 1
  00139	8b 4c 24 10	 mov	 ecx, DWORD PTR _nBufSize$[esp+16440]
  0013d	75 14		 jne	 SHORT $L316285
  0013f	66 ff 80 0c 57
	00 00		 inc	 WORD PTR [eax+22284]
  00146	51		 push	 ecx
  00147	53		 push	 ebx
  00148	8d 88 f8 16 00
	00		 lea	 ecx, DWORD PTR [eax+5880]
  0014e	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
$L316285:

; 4614 : 	NEXT_VISIBILITYRANGE( pVendor )

  00153	8a 46 15	 mov	 al, BYTE PTR [esi+21]
  00156	84 c0		 test	 al, al
  00158	75 40		 jne	 SHORT $L316413
  0015a	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0015d	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00160	84 c9		 test	 cl, cl
  00162	75 19		 jne	 SHORT $L316447
  00164	8b f0		 mov	 esi, eax
  00166	8b 06		 mov	 eax, DWORD PTR [esi]
  00168	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  0016b	84 c9		 test	 cl, cl
  0016d	75 2b		 jne	 SHORT $L316413
  0016f	90		 npad	 1
$L316427:
  00170	8b f0		 mov	 esi, eax
  00172	8b 06		 mov	 eax, DWORD PTR [esi]
  00174	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00177	84 c9		 test	 cl, cl
  00179	74 f5		 je	 SHORT $L316427
  0017b	eb 1d		 jmp	 SHORT $L316413
$L316447:
  0017d	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00180	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00183	84 c9		 test	 cl, cl
  00185	75 11		 jne	 SHORT $L316416
$L316415:
  00187	3b 70 08	 cmp	 esi, DWORD PTR [eax+8]
  0018a	75 0c		 jne	 SHORT $L316416
  0018c	8b f0		 mov	 esi, eax
  0018e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00191	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00194	84 c9		 test	 cl, cl
  00196	74 ef		 je	 SHORT $L316415
$L316416:
  00198	8b f0		 mov	 esi, eax
$L316413:

; 4610 : 
; 4611 : 	FOR_VISIBILITYRANGE( pVendor )

  0019a	3b f7		 cmp	 esi, edi
  0019c	75 82		 jne	 SHORT $L280766
$L280767:

; 4615 : }

  0019e	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  001a2	c7 84 24 34 40
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+16448], -1
  001ad	e8 00 00 00 00	 call	 ??1CAr@@QAE@XZ		; CAr::~CAr
  001b2	8b 8c 24 2c 40
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+16440]
  001b9	5f		 pop	 edi
  001ba	5e		 pop	 esi
  001bb	5d		 pop	 ebp
  001bc	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  001c3	8b 8c 24 1c 40
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+16428]
  001ca	5b		 pop	 ebx
  001cb	33 cc		 xor	 ecx, esp
  001cd	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001d2	81 c4 28 40 00
	00		 add	 esp, 16424		; 00004028H
  001d8	c2 10 00	 ret	 16			; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L316148:
  00000	8d 8d dc bf ff
	ff		 lea	 ecx, DWORD PTR _ar$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CAr@@QAE@XZ		; CAr::~CAr
__ehhandler$?AddUpdateVendor@CUserMng@@QAEXPAVCMover@@DEF@Z:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T316444
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?AddUpdateVendor@CUserMng@@QAEXPAVCMover@@DEF@Z ENDP	; CUserMng::AddUpdateVendor
PUBLIC	?AddSetDestParam@CUserMng@@QAEXPAVCMover@@HHH@Z	; CUserMng::AddSetDestParam
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
xdata$x	SEGMENT
$T316745 DD	0ffffffffH
	DD	FLAT:$L316461
$T316737 DD	019930520H
	DD	01H
	DD	FLAT:$T316745
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
xdata$x	ENDS
;	COMDAT ?AddSetDestParam@CUserMng@@QAEXPAVCMover@@HHH@Z
_TEXT	SEGMENT
_nBufSize$ = -16424					; size = 4
_ar$ = -16420						; size = 16404
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_pMover$ = 8						; size = 4
_nDstParameter$ = 12					; size = 4
_nAdjParameterValue$ = 16				; size = 4
_nChgParameterValue$ = 20				; size = 4
?AddSetDestParam@CUserMng@@QAEXPAVCMover@@HHH@Z PROC NEAR ; CUserMng::AddSetDestParam, COMDAT
; _this$ = ecx

; 4618 : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?AddSetDestParam@CUserMng@@QAEXPAVCMover@@HHH@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	b8 1c 40 00 00	 mov	 eax, 16412		; 0000401cH
  00013	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0001a	e8 00 00 00 00	 call	 __chkstk
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00024	33 c4		 xor	 eax, esp
  00026	53		 push	 ebx
  00027	55		 push	 ebp
  00028	56		 push	 esi
  00029	8b b4 24 38 40
	00 00		 mov	 esi, DWORD PTR _pMover$[esp+16432]
  00030	57		 push	 edi

; 4619 : 	CAr ar;

  00031	6a 00		 push	 0
  00033	6a 00		 push	 0
  00035	8d 4c 24 1c	 lea	 ecx, DWORD PTR _ar$[esp+16448]
  00039	89 84 24 30 40
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+16448], eax
  00040	e8 00 00 00 00	 call	 ??0CAr@@QAE@PAXI@Z	; CAr::CAr

; 4620 : 
; 4621 : 	ar << GETID( pMover );

  00045	85 f6		 test	 esi, esi
  00047	c7 84 24 34 40
	00 00 00 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+16448], 0
  00052	74 08		 je	 SHORT $L316459
  00054	8b be bc 01 00
	00		 mov	 edi, DWORD PTR [esi+444]
  0005a	eb 03		 jmp	 SHORT $L316460
$L316459:
  0005c	83 cf ff	 or	 edi, -1
$L316460:
  0005f	bb 04 00 00 00	 mov	 ebx, 4
  00064	53		 push	 ebx
  00065	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  00069	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0006e	8b 44 24 1c	 mov	 eax, DWORD PTR _ar$[esp+16448]
  00072	89 38		 mov	 DWORD PTR [eax], edi
  00074	8b 44 24 1c	 mov	 eax, DWORD PTR _ar$[esp+16448]
  00078	03 c3		 add	 eax, ebx

; 4622 : 	ar << SNAPSHOTTYPE_SETDESTPARAM;

  0007a	6a 02		 push	 2
  0007c	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  00080	89 44 24 20	 mov	 DWORD PTR _ar$[esp+16452], eax
  00084	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00089	8b 4c 24 1c	 mov	 ecx, DWORD PTR _ar$[esp+16448]
  0008d	66 c7 01 1c 00	 mov	 WORD PTR [ecx], 28	; 0000001cH
  00092	8b 7c 24 1c	 mov	 edi, DWORD PTR _ar$[esp+16448]
  00096	83 c7 02	 add	 edi, 2

; 4623 : 
; 4624 : 	ar << nDstParameter << nAdjParameterValue << nChgParameterValue;

  00099	53		 push	 ebx
  0009a	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  0009e	89 7c 24 20	 mov	 DWORD PTR _ar$[esp+16452], edi
  000a2	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000a7	8b 54 24 1c	 mov	 edx, DWORD PTR _ar$[esp+16448]
  000ab	8b 84 24 40 40
	00 00		 mov	 eax, DWORD PTR _nDstParameter$[esp+16436]
  000b2	89 02		 mov	 DWORD PTR [edx], eax
  000b4	01 5c 24 1c	 add	 DWORD PTR _ar$[esp+16448], ebx
  000b8	53		 push	 ebx
  000b9	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  000bd	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000c2	8b 4c 24 1c	 mov	 ecx, DWORD PTR _ar$[esp+16448]
  000c6	8b 94 24 44 40
	00 00		 mov	 edx, DWORD PTR _nAdjParameterValue$[esp+16436]
  000cd	89 11		 mov	 DWORD PTR [ecx], edx
  000cf	8b 6c 24 1c	 mov	 ebp, DWORD PTR _ar$[esp+16448]
  000d3	03 eb		 add	 ebp, ebx
  000d5	53		 push	 ebx
  000d6	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  000da	89 6c 24 20	 mov	 DWORD PTR _ar$[esp+16452], ebp
  000de	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000e3	8b 44 24 1c	 mov	 eax, DWORD PTR _ar$[esp+16448]
  000e7	8b 8c 24 48 40
	00 00		 mov	 ecx, DWORD PTR _nChgParameterValue$[esp+16436]
  000ee	89 08		 mov	 DWORD PTR [eax], ecx
  000f0	01 5c 24 1c	 add	 DWORD PTR _ar$[esp+16448], ebx

; 4625 : 
; 4626 : 	GETBLOCK( ar, lpBuf, nBufSize );

  000f4	8d 54 24 10	 lea	 edx, DWORD PTR _nBufSize$[esp+16440]
  000f8	52		 push	 edx
  000f9	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  000fd	e8 00 00 00 00	 call	 ?GetBuffer@CAr@@QAEPAEPAH@Z ; CAr::GetBuffer

; 4627 : 
; 4628 : 	FOR_VISIBILITYRANGE( pMover )

  00102	8b be 10 02 00
	00		 mov	 edi, DWORD PTR [esi+528]
  00108	8b 37		 mov	 esi, DWORD PTR [edi]
  0010a	3b f7		 cmp	 esi, edi
  0010c	8b e8		 mov	 ebp, eax
  0010e	74 6e		 je	 SHORT $L280796
  00110	b3 01		 mov	 bl, 1
$L280795:

; 4629 : 		USERPTR->AddBlock( lpBuf, nBufSize );

  00112	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00115	84 58 04	 test	 BYTE PTR [eax+4], bl
  00118	8b 4c 24 10	 mov	 ecx, DWORD PTR _nBufSize$[esp+16440]
  0011c	75 14		 jne	 SHORT $L316581
  0011e	66 ff 80 0c 57
	00 00		 inc	 WORD PTR [eax+22284]
  00125	51		 push	 ecx
  00126	55		 push	 ebp
  00127	8d 88 f8 16 00
	00		 lea	 ecx, DWORD PTR [eax+5880]
  0012d	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
$L316581:

; 4630 : 	NEXT_VISIBILITYRANGE( pMover )

  00132	8a 46 15	 mov	 al, BYTE PTR [esi+21]
  00135	84 c0		 test	 al, al
  00137	75 41		 jne	 SHORT $L316729
  00139	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0013c	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  0013f	84 c9		 test	 cl, cl
  00141	75 1a		 jne	 SHORT $L316740
  00143	8b f0		 mov	 esi, eax
  00145	8b 06		 mov	 eax, DWORD PTR [esi]
  00147	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  0014a	84 c9		 test	 cl, cl
  0014c	75 2c		 jne	 SHORT $L316729
  0014e	8b ff		 npad	 2
$L316717:
  00150	8b f0		 mov	 esi, eax
  00152	8b 06		 mov	 eax, DWORD PTR [esi]
  00154	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00157	84 c9		 test	 cl, cl
  00159	74 f5		 je	 SHORT $L316717
  0015b	eb 1d		 jmp	 SHORT $L316729
$L316740:
  0015d	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00160	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00163	84 c9		 test	 cl, cl
  00165	75 11		 jne	 SHORT $L316732
$L316731:
  00167	3b 70 08	 cmp	 esi, DWORD PTR [eax+8]
  0016a	75 0c		 jne	 SHORT $L316732
  0016c	8b f0		 mov	 esi, eax
  0016e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00171	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00174	84 c9		 test	 cl, cl
  00176	74 ef		 je	 SHORT $L316731
$L316732:
  00178	8b f0		 mov	 esi, eax
$L316729:

; 4627 : 
; 4628 : 	FOR_VISIBILITYRANGE( pMover )

  0017a	3b f7		 cmp	 esi, edi
  0017c	75 94		 jne	 SHORT $L280795
$L280796:

; 4631 : }

  0017e	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  00182	c7 84 24 34 40
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+16448], -1
  0018d	e8 00 00 00 00	 call	 ??1CAr@@QAE@XZ		; CAr::~CAr
  00192	8b 8c 24 2c 40
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+16440]
  00199	5f		 pop	 edi
  0019a	5e		 pop	 esi
  0019b	5d		 pop	 ebp
  0019c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  001a3	8b 8c 24 1c 40
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+16428]
  001aa	5b		 pop	 ebx
  001ab	33 cc		 xor	 ecx, esp
  001ad	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001b2	81 c4 28 40 00
	00		 add	 esp, 16424		; 00004028H
  001b8	c2 10 00	 ret	 16			; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L316461:
  00000	8d 8d dc bf ff
	ff		 lea	 ecx, DWORD PTR _ar$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CAr@@QAE@XZ		; CAr::~CAr
__ehhandler$?AddSetDestParam@CUserMng@@QAEXPAVCMover@@HHH@Z:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T316737
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?AddSetDestParam@CUserMng@@QAEXPAVCMover@@HHH@Z ENDP	; CUserMng::AddSetDestParam
PUBLIC	?AddResetDestParam@CUserMng@@QAEXPAVCMover@@HH@Z ; CUserMng::AddResetDestParam
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
xdata$x	SEGMENT
$T317030 DD	0ffffffffH
	DD	FLAT:$L316754
$T317022 DD	019930520H
	DD	01H
	DD	FLAT:$T317030
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
xdata$x	ENDS
;	COMDAT ?AddResetDestParam@CUserMng@@QAEXPAVCMover@@HH@Z
_TEXT	SEGMENT
_nBufSize$ = -16424					; size = 4
_ar$ = -16420						; size = 16404
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_pMover$ = 8						; size = 4
_nDstParameter$ = 12					; size = 4
_nAdjParameterValue$ = 16				; size = 4
?AddResetDestParam@CUserMng@@QAEXPAVCMover@@HH@Z PROC NEAR ; CUserMng::AddResetDestParam, COMDAT
; _this$ = ecx

; 4634 : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?AddResetDestParam@CUserMng@@QAEXPAVCMover@@HH@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	b8 1c 40 00 00	 mov	 eax, 16412		; 0000401cH
  00013	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0001a	e8 00 00 00 00	 call	 __chkstk
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00024	33 c4		 xor	 eax, esp
  00026	53		 push	 ebx
  00027	55		 push	 ebp
  00028	56		 push	 esi
  00029	8b b4 24 38 40
	00 00		 mov	 esi, DWORD PTR _pMover$[esp+16432]
  00030	57		 push	 edi

; 4635 : 	CAr ar;

  00031	6a 00		 push	 0
  00033	6a 00		 push	 0
  00035	8d 4c 24 1c	 lea	 ecx, DWORD PTR _ar$[esp+16448]
  00039	89 84 24 30 40
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+16448], eax
  00040	e8 00 00 00 00	 call	 ??0CAr@@QAE@PAXI@Z	; CAr::CAr

; 4636 : 
; 4637 : 	ar << GETID( pMover );

  00045	85 f6		 test	 esi, esi
  00047	c7 84 24 34 40
	00 00 00 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+16448], 0
  00052	74 08		 je	 SHORT $L316752
  00054	8b be bc 01 00
	00		 mov	 edi, DWORD PTR [esi+444]
  0005a	eb 03		 jmp	 SHORT $L316753
$L316752:
  0005c	83 cf ff	 or	 edi, -1
$L316753:
  0005f	bb 04 00 00 00	 mov	 ebx, 4
  00064	53		 push	 ebx
  00065	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  00069	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0006e	8b 44 24 1c	 mov	 eax, DWORD PTR _ar$[esp+16448]
  00072	89 38		 mov	 DWORD PTR [eax], edi
  00074	8b 7c 24 1c	 mov	 edi, DWORD PTR _ar$[esp+16448]
  00078	03 fb		 add	 edi, ebx

; 4638 : 	ar << SNAPSHOTTYPE_RESETDESTPARAM;

  0007a	6a 02		 push	 2
  0007c	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  00080	89 7c 24 20	 mov	 DWORD PTR _ar$[esp+16452], edi
  00084	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00089	8b 4c 24 1c	 mov	 ecx, DWORD PTR _ar$[esp+16448]
  0008d	66 c7 01 1d 00	 mov	 WORD PTR [ecx], 29	; 0000001dH
  00092	83 44 24 1c 02	 add	 DWORD PTR _ar$[esp+16448], 2

; 4639 : 
; 4640 : 	ar << nDstParameter << nAdjParameterValue;

  00097	53		 push	 ebx
  00098	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  0009c	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000a1	8b 54 24 1c	 mov	 edx, DWORD PTR _ar$[esp+16448]
  000a5	8b 84 24 40 40
	00 00		 mov	 eax, DWORD PTR _nDstParameter$[esp+16436]
  000ac	89 02		 mov	 DWORD PTR [edx], eax
  000ae	8b 6c 24 1c	 mov	 ebp, DWORD PTR _ar$[esp+16448]
  000b2	03 eb		 add	 ebp, ebx
  000b4	53		 push	 ebx
  000b5	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  000b9	89 6c 24 20	 mov	 DWORD PTR _ar$[esp+16452], ebp
  000bd	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000c2	8b 4c 24 1c	 mov	 ecx, DWORD PTR _ar$[esp+16448]
  000c6	8b 94 24 44 40
	00 00		 mov	 edx, DWORD PTR _nAdjParameterValue$[esp+16436]
  000cd	89 11		 mov	 DWORD PTR [ecx], edx
  000cf	8b 54 24 1c	 mov	 edx, DWORD PTR _ar$[esp+16448]

; 4641 : 
; 4642 : 	GETBLOCK( ar, lpBuf, nBufSize );

  000d3	8d 44 24 10	 lea	 eax, DWORD PTR _nBufSize$[esp+16440]
  000d7	03 d3		 add	 edx, ebx
  000d9	50		 push	 eax
  000da	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  000de	89 54 24 20	 mov	 DWORD PTR _ar$[esp+16452], edx
  000e2	e8 00 00 00 00	 call	 ?GetBuffer@CAr@@QAEPAEPAH@Z ; CAr::GetBuffer

; 4643 : 
; 4644 : 	FOR_VISIBILITYRANGE( pMover )

  000e7	8b be 10 02 00
	00		 mov	 edi, DWORD PTR [esi+528]
  000ed	8b 37		 mov	 esi, DWORD PTR [edi]
  000ef	3b f7		 cmp	 esi, edi
  000f1	8b e8		 mov	 ebp, eax
  000f3	74 79		 je	 SHORT $L280823
  000f5	b3 01		 mov	 bl, 1
  000f7	eb 07 8d a4 24
	00 00 00 00	 npad	 9
$L280822:

; 4645 : 		USERPTR->AddBlock( lpBuf, nBufSize );

  00100	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00103	84 58 04	 test	 BYTE PTR [eax+4], bl
  00106	8b 4c 24 10	 mov	 ecx, DWORD PTR _nBufSize$[esp+16440]
  0010a	75 14		 jne	 SHORT $L316866
  0010c	66 ff 80 0c 57
	00 00		 inc	 WORD PTR [eax+22284]
  00113	51		 push	 ecx
  00114	55		 push	 ebp
  00115	8d 88 f8 16 00
	00		 lea	 ecx, DWORD PTR [eax+5880]
  0011b	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
$L316866:

; 4646 : 	NEXT_VISIBILITYRANGE( pMover )

  00120	8a 46 15	 mov	 al, BYTE PTR [esi+21]
  00123	84 c0		 test	 al, al
  00125	75 43		 jne	 SHORT $L316990
  00127	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0012a	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  0012d	84 c9		 test	 cl, cl
  0012f	75 1c		 jne	 SHORT $L317025
  00131	8b f0		 mov	 esi, eax
  00133	8b 06		 mov	 eax, DWORD PTR [esi]
  00135	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00138	84 c9		 test	 cl, cl
  0013a	75 2e		 jne	 SHORT $L316990
  0013c	8d 64 24 00	 npad	 4
$L317011:
  00140	8b f0		 mov	 esi, eax
  00142	8b 06		 mov	 eax, DWORD PTR [esi]
  00144	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00147	84 c9		 test	 cl, cl
  00149	74 f5		 je	 SHORT $L317011
  0014b	eb 1d		 jmp	 SHORT $L316990
$L317025:
  0014d	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00150	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00153	84 c9		 test	 cl, cl
  00155	75 11		 jne	 SHORT $L316993
$L316992:
  00157	3b 70 08	 cmp	 esi, DWORD PTR [eax+8]
  0015a	75 0c		 jne	 SHORT $L316993
  0015c	8b f0		 mov	 esi, eax
  0015e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00161	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00164	84 c9		 test	 cl, cl
  00166	74 ef		 je	 SHORT $L316992
$L316993:
  00168	8b f0		 mov	 esi, eax
$L316990:

; 4643 : 
; 4644 : 	FOR_VISIBILITYRANGE( pMover )

  0016a	3b f7		 cmp	 esi, edi
  0016c	75 92		 jne	 SHORT $L280822
$L280823:

; 4647 : }

  0016e	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  00172	c7 84 24 34 40
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+16448], -1
  0017d	e8 00 00 00 00	 call	 ??1CAr@@QAE@XZ		; CAr::~CAr
  00182	8b 8c 24 2c 40
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+16440]
  00189	5f		 pop	 edi
  0018a	5e		 pop	 esi
  0018b	5d		 pop	 ebp
  0018c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00193	8b 8c 24 1c 40
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+16428]
  0019a	5b		 pop	 ebx
  0019b	33 cc		 xor	 ecx, esp
  0019d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001a2	81 c4 28 40 00
	00		 add	 esp, 16424		; 00004028H
  001a8	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L316754:
  00000	8d 8d dc bf ff
	ff		 lea	 ecx, DWORD PTR _ar$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CAr@@QAE@XZ		; CAr::~CAr
__ehhandler$?AddResetDestParam@CUserMng@@QAEXPAVCMover@@HH@Z:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T317022
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?AddResetDestParam@CUserMng@@QAEXPAVCMover@@HH@Z ENDP	; CUserMng::AddResetDestParam
PUBLIC	?AddResetDestParamSync@CUserMng@@QAEXPAVCMover@@HHH@Z ; CUserMng::AddResetDestParamSync
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
xdata$x	SEGMENT
$T317323 DD	0ffffffffH
	DD	FLAT:$L317039
$T317315 DD	019930520H
	DD	01H
	DD	FLAT:$T317323
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
xdata$x	ENDS
;	COMDAT ?AddResetDestParamSync@CUserMng@@QAEXPAVCMover@@HHH@Z
_TEXT	SEGMENT
_nBufSize$ = -16424					; size = 4
_ar$ = -16420						; size = 16404
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_pMover$ = 8						; size = 4
_nDstParameter$ = 12					; size = 4
_nAdjParameterValue$ = 16				; size = 4
_nParameterValue$ = 20					; size = 4
?AddResetDestParamSync@CUserMng@@QAEXPAVCMover@@HHH@Z PROC NEAR ; CUserMng::AddResetDestParamSync, COMDAT
; _this$ = ecx

; 4650 : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?AddResetDestParamSync@CUserMng@@QAEXPAVCMover@@HHH@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	b8 1c 40 00 00	 mov	 eax, 16412		; 0000401cH
  00013	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0001a	e8 00 00 00 00	 call	 __chkstk
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00024	33 c4		 xor	 eax, esp
  00026	53		 push	 ebx
  00027	55		 push	 ebp
  00028	56		 push	 esi
  00029	8b b4 24 38 40
	00 00		 mov	 esi, DWORD PTR _pMover$[esp+16432]
  00030	57		 push	 edi

; 4651 : 	CAr ar;

  00031	6a 00		 push	 0
  00033	6a 00		 push	 0
  00035	8d 4c 24 1c	 lea	 ecx, DWORD PTR _ar$[esp+16448]
  00039	89 84 24 30 40
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+16448], eax
  00040	e8 00 00 00 00	 call	 ??0CAr@@QAE@PAXI@Z	; CAr::CAr

; 4652 : 
; 4653 : 	ar << GETID( pMover );

  00045	85 f6		 test	 esi, esi
  00047	c7 84 24 34 40
	00 00 00 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+16448], 0
  00052	74 08		 je	 SHORT $L317037
  00054	8b be bc 01 00
	00		 mov	 edi, DWORD PTR [esi+444]
  0005a	eb 03		 jmp	 SHORT $L317038
$L317037:
  0005c	83 cf ff	 or	 edi, -1
$L317038:
  0005f	bb 04 00 00 00	 mov	 ebx, 4
  00064	53		 push	 ebx
  00065	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  00069	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0006e	8b 44 24 1c	 mov	 eax, DWORD PTR _ar$[esp+16448]
  00072	89 38		 mov	 DWORD PTR [eax], edi
  00074	8b 44 24 1c	 mov	 eax, DWORD PTR _ar$[esp+16448]
  00078	03 c3		 add	 eax, ebx

; 4654 : 	ar << SNAPSHOTTYPE_RESETDESTPARAM_SYNC;

  0007a	6a 02		 push	 2
  0007c	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  00080	89 44 24 20	 mov	 DWORD PTR _ar$[esp+16452], eax
  00084	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00089	8b 4c 24 1c	 mov	 ecx, DWORD PTR _ar$[esp+16448]
  0008d	66 c7 01 00 98	 mov	 WORD PTR [ecx], 38912	; 00009800H
  00092	8b 7c 24 1c	 mov	 edi, DWORD PTR _ar$[esp+16448]
  00096	83 c7 02	 add	 edi, 2

; 4655 : 
; 4656 : 	ar << nDstParameter << nAdjParameterValue << nParameterValue;

  00099	53		 push	 ebx
  0009a	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  0009e	89 7c 24 20	 mov	 DWORD PTR _ar$[esp+16452], edi
  000a2	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000a7	8b 54 24 1c	 mov	 edx, DWORD PTR _ar$[esp+16448]
  000ab	8b 84 24 40 40
	00 00		 mov	 eax, DWORD PTR _nDstParameter$[esp+16436]
  000b2	89 02		 mov	 DWORD PTR [edx], eax
  000b4	01 5c 24 1c	 add	 DWORD PTR _ar$[esp+16448], ebx
  000b8	53		 push	 ebx
  000b9	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  000bd	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000c2	8b 4c 24 1c	 mov	 ecx, DWORD PTR _ar$[esp+16448]
  000c6	8b 94 24 44 40
	00 00		 mov	 edx, DWORD PTR _nAdjParameterValue$[esp+16436]
  000cd	89 11		 mov	 DWORD PTR [ecx], edx
  000cf	8b 6c 24 1c	 mov	 ebp, DWORD PTR _ar$[esp+16448]
  000d3	03 eb		 add	 ebp, ebx
  000d5	53		 push	 ebx
  000d6	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  000da	89 6c 24 20	 mov	 DWORD PTR _ar$[esp+16452], ebp
  000de	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000e3	8b 44 24 1c	 mov	 eax, DWORD PTR _ar$[esp+16448]
  000e7	8b 8c 24 48 40
	00 00		 mov	 ecx, DWORD PTR _nParameterValue$[esp+16436]
  000ee	89 08		 mov	 DWORD PTR [eax], ecx
  000f0	01 5c 24 1c	 add	 DWORD PTR _ar$[esp+16448], ebx

; 4657 : 
; 4658 : 	GETBLOCK( ar, lpBuf, nBufSize );

  000f4	8d 54 24 10	 lea	 edx, DWORD PTR _nBufSize$[esp+16440]
  000f8	52		 push	 edx
  000f9	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  000fd	e8 00 00 00 00	 call	 ?GetBuffer@CAr@@QAEPAEPAH@Z ; CAr::GetBuffer

; 4659 : 
; 4660 : 	FOR_VISIBILITYRANGE( pMover )

  00102	8b be 10 02 00
	00		 mov	 edi, DWORD PTR [esi+528]
  00108	8b 37		 mov	 esi, DWORD PTR [edi]
  0010a	3b f7		 cmp	 esi, edi
  0010c	8b e8		 mov	 ebp, eax
  0010e	74 6e		 je	 SHORT $L280851
  00110	b3 01		 mov	 bl, 1
$L280850:

; 4661 : 		USERPTR->AddBlock( lpBuf, nBufSize );

  00112	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00115	84 58 04	 test	 BYTE PTR [eax+4], bl
  00118	8b 4c 24 10	 mov	 ecx, DWORD PTR _nBufSize$[esp+16440]
  0011c	75 14		 jne	 SHORT $L317156
  0011e	66 ff 80 0c 57
	00 00		 inc	 WORD PTR [eax+22284]
  00125	51		 push	 ecx
  00126	55		 push	 ebp
  00127	8d 88 f8 16 00
	00		 lea	 ecx, DWORD PTR [eax+5880]
  0012d	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
$L317156:

; 4662 : 	NEXT_VISIBILITYRANGE( pMover )

  00132	8a 46 15	 mov	 al, BYTE PTR [esi+21]
  00135	84 c0		 test	 al, al
  00137	75 41		 jne	 SHORT $L317284
  00139	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0013c	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  0013f	84 c9		 test	 cl, cl
  00141	75 1a		 jne	 SHORT $L317318
  00143	8b f0		 mov	 esi, eax
  00145	8b 06		 mov	 eax, DWORD PTR [esi]
  00147	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  0014a	84 c9		 test	 cl, cl
  0014c	75 2c		 jne	 SHORT $L317284
  0014e	8b ff		 npad	 2
$L317298:
  00150	8b f0		 mov	 esi, eax
  00152	8b 06		 mov	 eax, DWORD PTR [esi]
  00154	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00157	84 c9		 test	 cl, cl
  00159	74 f5		 je	 SHORT $L317298
  0015b	eb 1d		 jmp	 SHORT $L317284
$L317318:
  0015d	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00160	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00163	84 c9		 test	 cl, cl
  00165	75 11		 jne	 SHORT $L317287
$L317286:
  00167	3b 70 08	 cmp	 esi, DWORD PTR [eax+8]
  0016a	75 0c		 jne	 SHORT $L317287
  0016c	8b f0		 mov	 esi, eax
  0016e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00171	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00174	84 c9		 test	 cl, cl
  00176	74 ef		 je	 SHORT $L317286
$L317287:
  00178	8b f0		 mov	 esi, eax
$L317284:

; 4659 : 
; 4660 : 	FOR_VISIBILITYRANGE( pMover )

  0017a	3b f7		 cmp	 esi, edi
  0017c	75 94		 jne	 SHORT $L280850
$L280851:

; 4663 : }

  0017e	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  00182	c7 84 24 34 40
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+16448], -1
  0018d	e8 00 00 00 00	 call	 ??1CAr@@QAE@XZ		; CAr::~CAr
  00192	8b 8c 24 2c 40
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+16440]
  00199	5f		 pop	 edi
  0019a	5e		 pop	 esi
  0019b	5d		 pop	 ebp
  0019c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  001a3	8b 8c 24 1c 40
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+16428]
  001aa	5b		 pop	 ebx
  001ab	33 cc		 xor	 ecx, esp
  001ad	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001b2	81 c4 28 40 00
	00		 add	 esp, 16424		; 00004028H
  001b8	c2 10 00	 ret	 16			; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L317039:
  00000	8d 8d dc bf ff
	ff		 lea	 ecx, DWORD PTR _ar$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CAr@@QAE@XZ		; CAr::~CAr
__ehhandler$?AddResetDestParamSync@CUserMng@@QAEXPAVCMover@@HHH@Z:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T317315
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?AddResetDestParamSync@CUserMng@@QAEXPAVCMover@@HHH@Z ENDP ; CUserMng::AddResetDestParamSync
PUBLIC	?AddSetPointParam@CUserMng@@QAEXPAVCMover@@HH@Z	; CUserMng::AddSetPointParam
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
xdata$x	SEGMENT
$T317608 DD	0ffffffffH
	DD	FLAT:$L317332
$T317600 DD	019930520H
	DD	01H
	DD	FLAT:$T317608
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
xdata$x	ENDS
;	COMDAT ?AddSetPointParam@CUserMng@@QAEXPAVCMover@@HH@Z
_TEXT	SEGMENT
_nBufSize$ = -16424					; size = 4
_ar$ = -16420						; size = 16404
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_pMover$ = 8						; size = 4
_nDstParameter$ = 12					; size = 4
_nValue$ = 16						; size = 4
?AddSetPointParam@CUserMng@@QAEXPAVCMover@@HH@Z PROC NEAR ; CUserMng::AddSetPointParam, COMDAT
; _this$ = ecx

; 4667 : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?AddSetPointParam@CUserMng@@QAEXPAVCMover@@HH@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	b8 1c 40 00 00	 mov	 eax, 16412		; 0000401cH
  00013	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0001a	e8 00 00 00 00	 call	 __chkstk
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00024	33 c4		 xor	 eax, esp
  00026	53		 push	 ebx
  00027	55		 push	 ebp
  00028	56		 push	 esi
  00029	8b b4 24 38 40
	00 00		 mov	 esi, DWORD PTR _pMover$[esp+16432]
  00030	57		 push	 edi

; 4668 : 	CAr ar;

  00031	6a 00		 push	 0
  00033	6a 00		 push	 0
  00035	8d 4c 24 1c	 lea	 ecx, DWORD PTR _ar$[esp+16448]
  00039	89 84 24 30 40
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+16448], eax
  00040	e8 00 00 00 00	 call	 ??0CAr@@QAE@PAXI@Z	; CAr::CAr

; 4669 : 
; 4670 : 	ar << GETID( pMover );

  00045	85 f6		 test	 esi, esi
  00047	c7 84 24 34 40
	00 00 00 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+16448], 0
  00052	74 08		 je	 SHORT $L317330
  00054	8b be bc 01 00
	00		 mov	 edi, DWORD PTR [esi+444]
  0005a	eb 03		 jmp	 SHORT $L317331
$L317330:
  0005c	83 cf ff	 or	 edi, -1
$L317331:
  0005f	bb 04 00 00 00	 mov	 ebx, 4
  00064	53		 push	 ebx
  00065	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  00069	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0006e	8b 44 24 1c	 mov	 eax, DWORD PTR _ar$[esp+16448]
  00072	89 38		 mov	 DWORD PTR [eax], edi
  00074	8b 7c 24 1c	 mov	 edi, DWORD PTR _ar$[esp+16448]
  00078	03 fb		 add	 edi, ebx

; 4671 : 	ar << SNAPSHOTTYPE_SETPOINTPARAM;

  0007a	6a 02		 push	 2
  0007c	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  00080	89 7c 24 20	 mov	 DWORD PTR _ar$[esp+16452], edi
  00084	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00089	8b 4c 24 1c	 mov	 ecx, DWORD PTR _ar$[esp+16448]
  0008d	66 c7 01 1e 00	 mov	 WORD PTR [ecx], 30	; 0000001eH
  00092	83 44 24 1c 02	 add	 DWORD PTR _ar$[esp+16448], 2

; 4672 : 
; 4673 : 	ar << nDstParameter << nValue;

  00097	53		 push	 ebx
  00098	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  0009c	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000a1	8b 54 24 1c	 mov	 edx, DWORD PTR _ar$[esp+16448]
  000a5	8b 84 24 40 40
	00 00		 mov	 eax, DWORD PTR _nDstParameter$[esp+16436]
  000ac	89 02		 mov	 DWORD PTR [edx], eax
  000ae	8b 6c 24 1c	 mov	 ebp, DWORD PTR _ar$[esp+16448]
  000b2	03 eb		 add	 ebp, ebx
  000b4	53		 push	 ebx
  000b5	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  000b9	89 6c 24 20	 mov	 DWORD PTR _ar$[esp+16452], ebp
  000bd	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000c2	8b 4c 24 1c	 mov	 ecx, DWORD PTR _ar$[esp+16448]
  000c6	8b 94 24 44 40
	00 00		 mov	 edx, DWORD PTR _nValue$[esp+16436]
  000cd	89 11		 mov	 DWORD PTR [ecx], edx
  000cf	8b 54 24 1c	 mov	 edx, DWORD PTR _ar$[esp+16448]

; 4674 : 
; 4675 : 	GETBLOCK( ar, lpBuf, nBufSize );

  000d3	8d 44 24 10	 lea	 eax, DWORD PTR _nBufSize$[esp+16440]
  000d7	03 d3		 add	 edx, ebx
  000d9	50		 push	 eax
  000da	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  000de	89 54 24 20	 mov	 DWORD PTR _ar$[esp+16452], edx
  000e2	e8 00 00 00 00	 call	 ?GetBuffer@CAr@@QAEPAEPAH@Z ; CAr::GetBuffer

; 4676 : 
; 4677 : 	FOR_VISIBILITYRANGE( pMover )

  000e7	8b be 10 02 00
	00		 mov	 edi, DWORD PTR [esi+528]
  000ed	8b 37		 mov	 esi, DWORD PTR [edi]
  000ef	3b f7		 cmp	 esi, edi
  000f1	8b e8		 mov	 ebp, eax
  000f3	74 79		 je	 SHORT $L280878
  000f5	b3 01		 mov	 bl, 1
  000f7	eb 07 8d a4 24
	00 00 00 00	 npad	 9
$L280877:

; 4678 : 		USERPTR->AddBlock( lpBuf, nBufSize );

  00100	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00103	84 58 04	 test	 BYTE PTR [eax+4], bl
  00106	8b 4c 24 10	 mov	 ecx, DWORD PTR _nBufSize$[esp+16440]
  0010a	75 14		 jne	 SHORT $L317442
  0010c	66 ff 80 0c 57
	00 00		 inc	 WORD PTR [eax+22284]
  00113	51		 push	 ecx
  00114	55		 push	 ebp
  00115	8d 88 f8 16 00
	00		 lea	 ecx, DWORD PTR [eax+5880]
  0011b	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
$L317442:

; 4679 : 	NEXT_VISIBILITYRANGE( pMover )

  00120	8a 46 15	 mov	 al, BYTE PTR [esi+21]
  00123	84 c0		 test	 al, al
  00125	75 43		 jne	 SHORT $L317592
  00127	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0012a	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  0012d	84 c9		 test	 cl, cl
  0012f	75 1c		 jne	 SHORT $L317603
  00131	8b f0		 mov	 esi, eax
  00133	8b 06		 mov	 eax, DWORD PTR [esi]
  00135	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00138	84 c9		 test	 cl, cl
  0013a	75 2e		 jne	 SHORT $L317592
  0013c	8d 64 24 00	 npad	 4
$L317580:
  00140	8b f0		 mov	 esi, eax
  00142	8b 06		 mov	 eax, DWORD PTR [esi]
  00144	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00147	84 c9		 test	 cl, cl
  00149	74 f5		 je	 SHORT $L317580
  0014b	eb 1d		 jmp	 SHORT $L317592
$L317603:
  0014d	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00150	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00153	84 c9		 test	 cl, cl
  00155	75 11		 jne	 SHORT $L317595
$L317594:
  00157	3b 70 08	 cmp	 esi, DWORD PTR [eax+8]
  0015a	75 0c		 jne	 SHORT $L317595
  0015c	8b f0		 mov	 esi, eax
  0015e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00161	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00164	84 c9		 test	 cl, cl
  00166	74 ef		 je	 SHORT $L317594
$L317595:
  00168	8b f0		 mov	 esi, eax
$L317592:

; 4676 : 
; 4677 : 	FOR_VISIBILITYRANGE( pMover )

  0016a	3b f7		 cmp	 esi, edi
  0016c	75 92		 jne	 SHORT $L280877
$L280878:

; 4680 : }

  0016e	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  00172	c7 84 24 34 40
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+16448], -1
  0017d	e8 00 00 00 00	 call	 ??1CAr@@QAE@XZ		; CAr::~CAr
  00182	8b 8c 24 2c 40
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+16440]
  00189	5f		 pop	 edi
  0018a	5e		 pop	 esi
  0018b	5d		 pop	 ebp
  0018c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00193	8b 8c 24 1c 40
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+16428]
  0019a	5b		 pop	 ebx
  0019b	33 cc		 xor	 ecx, esp
  0019d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001a2	81 c4 28 40 00
	00		 add	 esp, 16424		; 00004028H
  001a8	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L317332:
  00000	8d 8d dc bf ff
	ff		 lea	 ecx, DWORD PTR _ar$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CAr@@QAE@XZ		; CAr::~CAr
__ehhandler$?AddSetPointParam@CUserMng@@QAEXPAVCMover@@HH@Z:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T317600
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?AddSetPointParam@CUserMng@@QAEXPAVCMover@@HH@Z ENDP	; CUserMng::AddSetPointParam
PUBLIC	?AddSetPos@CUserMng@@QAEXPAVCCtrl@@AAUD3DXVECTOR3@@@Z ; CUserMng::AddSetPos
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
xdata$x	SEGMENT
$T317882 DD	0ffffffffH
	DD	FLAT:$L317617
$T317874 DD	019930520H
	DD	01H
	DD	FLAT:$T317882
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
xdata$x	ENDS
;	COMDAT ?AddSetPos@CUserMng@@QAEXPAVCCtrl@@AAUD3DXVECTOR3@@@Z
_TEXT	SEGMENT
_nBufSize$ = -16436					; size = 4
$T317632 = -16432					; size = 12
_ar$ = -16420						; size = 16404
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_pCtrl$ = 8						; size = 4
_vPos$ = 12						; size = 4
?AddSetPos@CUserMng@@QAEXPAVCCtrl@@AAUD3DXVECTOR3@@@Z PROC NEAR ; CUserMng::AddSetPos, COMDAT
; _this$ = ecx

; 4683 : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?AddSetPos@CUserMng@@QAEXPAVCCtrl@@AAUD3DXVECTOR3@@@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	b8 28 40 00 00	 mov	 eax, 16424		; 00004028H
  00013	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0001a	e8 00 00 00 00	 call	 __chkstk
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00024	33 c4		 xor	 eax, esp
  00026	53		 push	 ebx
  00027	55		 push	 ebp
  00028	56		 push	 esi
  00029	8b b4 24 48 40
	00 00		 mov	 esi, DWORD PTR _vPos$[esp+16444]
  00030	57		 push	 edi
  00031	8b bc 24 48 40
	00 00		 mov	 edi, DWORD PTR _pCtrl$[esp+16448]

; 4684 : 	CAr ar;

  00038	6a 00		 push	 0
  0003a	6a 00		 push	 0
  0003c	8d 4c 24 28	 lea	 ecx, DWORD PTR _ar$[esp+16460]
  00040	89 84 24 3c 40
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+16460], eax
  00047	e8 00 00 00 00	 call	 ??0CAr@@QAE@PAXI@Z	; CAr::CAr

; 4685 : 
; 4686 : 	ar << GETID( pCtrl ) << SNAPSHOTTYPE_SETPOS;

  0004c	85 ff		 test	 edi, edi
  0004e	c7 84 24 40 40
	00 00 00 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+16460], 0
  00059	74 08		 je	 SHORT $L317615
  0005b	8b 9f bc 01 00
	00		 mov	 ebx, DWORD PTR [edi+444]
  00061	eb 03		 jmp	 SHORT $L317616
$L317615:
  00063	83 cb ff	 or	 ebx, -1
$L317616:
  00066	6a 04		 push	 4
  00068	8d 4c 24 24	 lea	 ecx, DWORD PTR _ar$[esp+16456]
  0006c	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00071	8b 44 24 28	 mov	 eax, DWORD PTR _ar$[esp+16460]
  00075	89 18		 mov	 DWORD PTR [eax], ebx
  00077	83 44 24 28 04	 add	 DWORD PTR _ar$[esp+16460], 4
  0007c	6a 02		 push	 2
  0007e	8d 4c 24 24	 lea	 ecx, DWORD PTR _ar$[esp+16456]
  00082	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00087	8b 4c 24 28	 mov	 ecx, DWORD PTR _ar$[esp+16460]
  0008b	66 c7 01 10 00	 mov	 WORD PTR [ecx], 16	; 00000010H

; 4687 : 	ar << vPos;

  00090	8b 16		 mov	 edx, DWORD PTR [esi]
  00092	8b 6c 24 28	 mov	 ebp, DWORD PTR _ar$[esp+16460]
  00096	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00099	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0009c	89 54 24 14	 mov	 DWORD PTR $T317632[esp+16452], edx
  000a0	6a 0c		 push	 12			; 0000000cH
  000a2	8d 54 24 18	 lea	 edx, DWORD PTR $T317632[esp+16456]
  000a6	89 4c 24 20	 mov	 DWORD PTR $T317632[esp+16464], ecx
  000aa	83 c5 02	 add	 ebp, 2
  000ad	52		 push	 edx
  000ae	8d 4c 24 28	 lea	 ecx, DWORD PTR _ar$[esp+16460]
  000b2	89 6c 24 30	 mov	 DWORD PTR _ar$[esp+16468], ebp
  000b6	89 44 24 20	 mov	 DWORD PTR $T317632[esp+16464], eax
  000ba	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write

; 4688 : 
; 4689 : 	GETBLOCK( ar, lpBuf, nBufSize );

  000bf	8d 44 24 10	 lea	 eax, DWORD PTR _nBufSize$[esp+16452]
  000c3	50		 push	 eax
  000c4	8d 4c 24 24	 lea	 ecx, DWORD PTR _ar$[esp+16456]
  000c8	e8 00 00 00 00	 call	 ?GetBuffer@CAr@@QAEPAEPAH@Z ; CAr::GetBuffer

; 4690 : 
; 4691 : 	FOR_VISIBILITYRANGE( pCtrl )

  000cd	8b bf 10 02 00
	00		 mov	 edi, DWORD PTR [edi+528]
  000d3	8b 37		 mov	 esi, DWORD PTR [edi]
  000d5	3b f7		 cmp	 esi, edi
  000d7	8b e8		 mov	 ebp, eax
  000d9	74 73		 je	 SHORT $L280904
  000db	b3 01		 mov	 bl, 1
  000dd	8d 49 00	 npad	 3
$L280903:

; 4692 : 		USERPTR->AddBlock( lpBuf, nBufSize );

  000e0	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  000e3	84 58 04	 test	 BYTE PTR [eax+4], bl
  000e6	8b 4c 24 10	 mov	 ecx, DWORD PTR _nBufSize$[esp+16452]
  000ea	75 14		 jne	 SHORT $L317717
  000ec	66 ff 80 0c 57
	00 00		 inc	 WORD PTR [eax+22284]
  000f3	51		 push	 ecx
  000f4	55		 push	 ebp
  000f5	8d 88 f8 16 00
	00		 lea	 ecx, DWORD PTR [eax+5880]
  000fb	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
$L317717:

; 4693 : 	NEXT_VISIBILITYRANGE( pCtrl )

  00100	8a 46 15	 mov	 al, BYTE PTR [esi+21]
  00103	84 c0		 test	 al, al
  00105	75 43		 jne	 SHORT $L317865
  00107	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0010a	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  0010d	84 c9		 test	 cl, cl
  0010f	75 1c		 jne	 SHORT $L317877
  00111	8b f0		 mov	 esi, eax
  00113	8b 06		 mov	 eax, DWORD PTR [esi]
  00115	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00118	84 c9		 test	 cl, cl
  0011a	75 2e		 jne	 SHORT $L317865
  0011c	8d 64 24 00	 npad	 4
$L317853:
  00120	8b f0		 mov	 esi, eax
  00122	8b 06		 mov	 eax, DWORD PTR [esi]
  00124	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00127	84 c9		 test	 cl, cl
  00129	74 f5		 je	 SHORT $L317853
  0012b	eb 1d		 jmp	 SHORT $L317865
$L317877:
  0012d	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00130	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00133	84 c9		 test	 cl, cl
  00135	75 11		 jne	 SHORT $L317868
$L317867:
  00137	3b 70 08	 cmp	 esi, DWORD PTR [eax+8]
  0013a	75 0c		 jne	 SHORT $L317868
  0013c	8b f0		 mov	 esi, eax
  0013e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00141	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00144	84 c9		 test	 cl, cl
  00146	74 ef		 je	 SHORT $L317867
$L317868:
  00148	8b f0		 mov	 esi, eax
$L317865:

; 4690 : 
; 4691 : 	FOR_VISIBILITYRANGE( pCtrl )

  0014a	3b f7		 cmp	 esi, edi
  0014c	75 92		 jne	 SHORT $L280903
$L280904:

; 4694 : }

  0014e	8d 4c 24 20	 lea	 ecx, DWORD PTR _ar$[esp+16452]
  00152	c7 84 24 40 40
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+16460], -1
  0015d	e8 00 00 00 00	 call	 ??1CAr@@QAE@XZ		; CAr::~CAr
  00162	8b 8c 24 38 40
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+16452]
  00169	5f		 pop	 edi
  0016a	5e		 pop	 esi
  0016b	5d		 pop	 ebp
  0016c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00173	8b 8c 24 28 40
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+16440]
  0017a	5b		 pop	 ebx
  0017b	33 cc		 xor	 ecx, esp
  0017d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00182	81 c4 34 40 00
	00		 add	 esp, 16436		; 00004034H
  00188	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L317617:
  00000	8d 8d dc bf ff
	ff		 lea	 ecx, DWORD PTR _ar$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CAr@@QAE@XZ		; CAr::~CAr
__ehhandler$?AddSetPos@CUserMng@@QAEXPAVCCtrl@@AAUD3DXVECTOR3@@@Z:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T317874
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?AddSetPos@CUserMng@@QAEXPAVCCtrl@@AAUD3DXVECTOR3@@@Z ENDP ; CUserMng::AddSetPos
PUBLIC	?AddSetLevel@CUserMng@@QAEXPAVCMover@@G@Z	; CUserMng::AddSetLevel
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
xdata$x	SEGMENT
$T318178 DD	0ffffffffH
	DD	FLAT:$L317891
$T318170 DD	019930520H
	DD	01H
	DD	FLAT:$T318178
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
xdata$x	ENDS
;	COMDAT ?AddSetLevel@CUserMng@@QAEXPAVCMover@@G@Z
_TEXT	SEGMENT
_nBufSize$ = -16424					; size = 4
_ar$ = -16420						; size = 16404
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_pMover$ = 8						; size = 4
_wLevel$ = 12						; size = 2
?AddSetLevel@CUserMng@@QAEXPAVCMover@@G@Z PROC NEAR	; CUserMng::AddSetLevel, COMDAT
; _this$ = ecx

; 4698 : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?AddSetLevel@CUserMng@@QAEXPAVCMover@@G@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	b8 1c 40 00 00	 mov	 eax, 16412		; 0000401cH
  00013	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0001a	e8 00 00 00 00	 call	 __chkstk
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00024	33 c4		 xor	 eax, esp
  00026	53		 push	 ebx
  00027	55		 push	 ebp
  00028	8b ac 24 34 40
	00 00		 mov	 ebp, DWORD PTR _pMover$[esp+16428]
  0002f	56		 push	 esi
  00030	57		 push	 edi

; 4699 : 	CAr ar;

  00031	6a 00		 push	 0
  00033	6a 00		 push	 0
  00035	8d 4c 24 1c	 lea	 ecx, DWORD PTR _ar$[esp+16448]
  00039	89 84 24 30 40
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+16448], eax
  00040	e8 00 00 00 00	 call	 ??0CAr@@QAE@PAXI@Z	; CAr::CAr

; 4700 : 
; 4701 : 	ar << GETID( pMover ) << SNAPSHOTTYPE_SETLEVEL;

  00045	85 ed		 test	 ebp, ebp
  00047	c7 84 24 34 40
	00 00 00 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+16448], 0
  00052	74 08		 je	 SHORT $L317889
  00054	8b b5 bc 01 00
	00		 mov	 esi, DWORD PTR [ebp+444]
  0005a	eb 03		 jmp	 SHORT $L317890
$L317889:
  0005c	83 ce ff	 or	 esi, -1
$L317890:
  0005f	6a 04		 push	 4
  00061	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  00065	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0006a	8b 44 24 1c	 mov	 eax, DWORD PTR _ar$[esp+16448]
  0006e	89 30		 mov	 DWORD PTR [eax], esi
  00070	8b 54 24 1c	 mov	 edx, DWORD PTR _ar$[esp+16448]
  00074	83 c2 04	 add	 edx, 4
  00077	be 02 00 00 00	 mov	 esi, 2
  0007c	56		 push	 esi
  0007d	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  00081	89 54 24 20	 mov	 DWORD PTR _ar$[esp+16452], edx
  00085	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0008a	8b 4c 24 1c	 mov	 ecx, DWORD PTR _ar$[esp+16448]
  0008e	66 c7 01 11 00	 mov	 WORD PTR [ecx], 17	; 00000011H
  00093	8b 44 24 1c	 mov	 eax, DWORD PTR _ar$[esp+16448]
  00097	03 c6		 add	 eax, esi

; 4702 : 	ar << wLevel;

  00099	56		 push	 esi
  0009a	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  0009e	89 44 24 20	 mov	 DWORD PTR _ar$[esp+16452], eax
  000a2	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000a7	8b 54 24 1c	 mov	 edx, DWORD PTR _ar$[esp+16448]
  000ab	66 8b 84 24 40
	40 00 00	 mov	 ax, WORD PTR _wLevel$[esp+16436]
  000b3	66 89 02	 mov	 WORD PTR [edx], ax
  000b6	8b 7c 24 1c	 mov	 edi, DWORD PTR _ar$[esp+16448]

; 4703 : 
; 4704 : 	GETBLOCK( ar, lpBuf, nBufSize );

  000ba	8d 4c 24 10	 lea	 ecx, DWORD PTR _nBufSize$[esp+16440]
  000be	51		 push	 ecx
  000bf	03 fe		 add	 edi, esi
  000c1	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  000c5	89 7c 24 20	 mov	 DWORD PTR _ar$[esp+16452], edi
  000c9	e8 00 00 00 00	 call	 ?GetBuffer@CAr@@QAEPAEPAH@Z ; CAr::GetBuffer

; 4705 : 
; 4706 : 	FOR_VISIBILITYRANGE( pMover )

  000ce	8b bd 10 02 00
	00		 mov	 edi, DWORD PTR [ebp+528]
  000d4	8b 37		 mov	 esi, DWORD PTR [edi]
  000d6	3b f7		 cmp	 esi, edi
  000d8	8b d8		 mov	 ebx, eax
  000da	74 73		 je	 SHORT $L280930
  000dc	8d 64 24 00	 npad	 4
$L280929:

; 4707 : 		if( USERPTR != pMover )

  000e0	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  000e3	3b c5		 cmp	 eax, ebp
  000e5	74 1e		 je	 SHORT $L318011

; 4708 : 			USERPTR->AddBlock( lpBuf, nBufSize );

  000e7	f6 40 04 01	 test	 BYTE PTR [eax+4], 1
  000eb	8b 4c 24 10	 mov	 ecx, DWORD PTR _nBufSize$[esp+16440]
  000ef	75 14		 jne	 SHORT $L318011
  000f1	66 ff 80 0c 57
	00 00		 inc	 WORD PTR [eax+22284]
  000f8	51		 push	 ecx
  000f9	53		 push	 ebx
  000fa	8d 88 f8 16 00
	00		 lea	 ecx, DWORD PTR [eax+5880]
  00100	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
$L318011:

; 4709 : 	NEXT_VISIBILITYRANGE( pMover )

  00105	8a 46 15	 mov	 al, BYTE PTR [esi+21]
  00108	84 c0		 test	 al, al
  0010a	75 3f		 jne	 SHORT $L318138
  0010c	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0010f	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00112	84 c9		 test	 cl, cl
  00114	75 18		 jne	 SHORT $L318173
  00116	8b f0		 mov	 esi, eax
  00118	8b 06		 mov	 eax, DWORD PTR [esi]
  0011a	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  0011d	84 c9		 test	 cl, cl
  0011f	75 2a		 jne	 SHORT $L318138
$L318159:
  00121	8b f0		 mov	 esi, eax
  00123	8b 06		 mov	 eax, DWORD PTR [esi]
  00125	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00128	84 c9		 test	 cl, cl
  0012a	74 f5		 je	 SHORT $L318159
  0012c	eb 1d		 jmp	 SHORT $L318138
$L318173:
  0012e	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00131	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00134	84 c9		 test	 cl, cl
  00136	75 11		 jne	 SHORT $L318141
$L318140:
  00138	3b 70 08	 cmp	 esi, DWORD PTR [eax+8]
  0013b	75 0c		 jne	 SHORT $L318141
  0013d	8b f0		 mov	 esi, eax
  0013f	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00142	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00145	84 c9		 test	 cl, cl
  00147	74 ef		 je	 SHORT $L318140
$L318141:
  00149	8b f0		 mov	 esi, eax
$L318138:

; 4705 : 
; 4706 : 	FOR_VISIBILITYRANGE( pMover )

  0014b	3b f7		 cmp	 esi, edi
  0014d	75 91		 jne	 SHORT $L280929
$L280930:

; 4710 : }

  0014f	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  00153	c7 84 24 34 40
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+16448], -1
  0015e	e8 00 00 00 00	 call	 ??1CAr@@QAE@XZ		; CAr::~CAr
  00163	8b 8c 24 2c 40
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+16440]
  0016a	5f		 pop	 edi
  0016b	5e		 pop	 esi
  0016c	5d		 pop	 ebp
  0016d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00174	8b 8c 24 1c 40
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+16428]
  0017b	5b		 pop	 ebx
  0017c	33 cc		 xor	 ecx, esp
  0017e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00183	81 c4 28 40 00
	00		 add	 esp, 16424		; 00004028H
  00189	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L317891:
  00000	8d 8d dc bf ff
	ff		 lea	 ecx, DWORD PTR _ar$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CAr@@QAE@XZ		; CAr::~CAr
__ehhandler$?AddSetLevel@CUserMng@@QAEXPAVCMover@@G@Z:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T318170
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?AddSetLevel@CUserMng@@QAEXPAVCMover@@G@Z ENDP		; CUserMng::AddSetLevel
PUBLIC	?AddSetFlightLevel@CUserMng@@QAEXPAVCMover@@H@Z	; CUserMng::AddSetFlightLevel
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
xdata$x	SEGMENT
$T318474 DD	0ffffffffH
	DD	FLAT:$L318187
$T318466 DD	019930520H
	DD	01H
	DD	FLAT:$T318474
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
xdata$x	ENDS
;	COMDAT ?AddSetFlightLevel@CUserMng@@QAEXPAVCMover@@H@Z
_TEXT	SEGMENT
_nBufSize$ = -16424					; size = 4
_ar$ = -16420						; size = 16404
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_pMover$ = 8						; size = 4
_nFlightLv$ = 12					; size = 4
?AddSetFlightLevel@CUserMng@@QAEXPAVCMover@@H@Z PROC NEAR ; CUserMng::AddSetFlightLevel, COMDAT
; _this$ = ecx

; 4713 : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?AddSetFlightLevel@CUserMng@@QAEXPAVCMover@@H@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	b8 1c 40 00 00	 mov	 eax, 16412		; 0000401cH
  00013	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0001a	e8 00 00 00 00	 call	 __chkstk
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00024	33 c4		 xor	 eax, esp
  00026	53		 push	 ebx
  00027	55		 push	 ebp
  00028	8b ac 24 34 40
	00 00		 mov	 ebp, DWORD PTR _pMover$[esp+16428]
  0002f	56		 push	 esi
  00030	57		 push	 edi

; 4714 : 	CAr ar;

  00031	6a 00		 push	 0
  00033	6a 00		 push	 0
  00035	8d 4c 24 1c	 lea	 ecx, DWORD PTR _ar$[esp+16448]
  00039	89 84 24 30 40
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+16448], eax
  00040	e8 00 00 00 00	 call	 ??0CAr@@QAE@PAXI@Z	; CAr::CAr

; 4715 : 	
; 4716 : 	ar << GETID( pMover ) << SNAPSHOTTYPE_SETFLIGHTLEVEL;

  00045	85 ed		 test	 ebp, ebp
  00047	c7 84 24 34 40
	00 00 00 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+16448], 0
  00052	74 08		 je	 SHORT $L318185
  00054	8b b5 bc 01 00
	00		 mov	 esi, DWORD PTR [ebp+444]
  0005a	eb 03		 jmp	 SHORT $L318186
$L318185:
  0005c	83 ce ff	 or	 esi, -1
$L318186:
  0005f	6a 04		 push	 4
  00061	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  00065	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0006a	8b 44 24 1c	 mov	 eax, DWORD PTR _ar$[esp+16448]
  0006e	89 30		 mov	 DWORD PTR [eax], esi
  00070	8b 54 24 1c	 mov	 edx, DWORD PTR _ar$[esp+16448]
  00074	83 c2 04	 add	 edx, 4
  00077	be 02 00 00 00	 mov	 esi, 2
  0007c	56		 push	 esi
  0007d	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  00081	89 54 24 20	 mov	 DWORD PTR _ar$[esp+16452], edx
  00085	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0008a	8b 4c 24 1c	 mov	 ecx, DWORD PTR _ar$[esp+16448]
  0008e	66 c7 01 2a 00	 mov	 WORD PTR [ecx], 42	; 0000002aH
  00093	8b 44 24 1c	 mov	 eax, DWORD PTR _ar$[esp+16448]
  00097	03 c6		 add	 eax, esi

; 4717 : 	ar << (WORD)nFlightLv;

  00099	56		 push	 esi
  0009a	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  0009e	89 44 24 20	 mov	 DWORD PTR _ar$[esp+16452], eax
  000a2	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000a7	8b 54 24 1c	 mov	 edx, DWORD PTR _ar$[esp+16448]
  000ab	66 8b 84 24 40
	40 00 00	 mov	 ax, WORD PTR _nFlightLv$[esp+16436]
  000b3	66 89 02	 mov	 WORD PTR [edx], ax
  000b6	8b 7c 24 1c	 mov	 edi, DWORD PTR _ar$[esp+16448]

; 4718 : 	
; 4719 : 	GETBLOCK( ar, lpBuf, nBufSize );

  000ba	8d 4c 24 10	 lea	 ecx, DWORD PTR _nBufSize$[esp+16440]
  000be	51		 push	 ecx
  000bf	03 fe		 add	 edi, esi
  000c1	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  000c5	89 7c 24 20	 mov	 DWORD PTR _ar$[esp+16452], edi
  000c9	e8 00 00 00 00	 call	 ?GetBuffer@CAr@@QAEPAEPAH@Z ; CAr::GetBuffer

; 4720 : 	
; 4721 : 	FOR_VISIBILITYRANGE( pMover )

  000ce	8b bd 10 02 00
	00		 mov	 edi, DWORD PTR [ebp+528]
  000d4	8b 37		 mov	 esi, DWORD PTR [edi]
  000d6	3b f7		 cmp	 esi, edi
  000d8	8b d8		 mov	 ebx, eax
  000da	74 73		 je	 SHORT $L280958
  000dc	8d 64 24 00	 npad	 4
$L280957:

; 4722 : 		if( USERPTR != pMover )

  000e0	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  000e3	3b c5		 cmp	 eax, ebp
  000e5	74 1e		 je	 SHORT $L318307

; 4723 : 			USERPTR->AddBlock( lpBuf, nBufSize );

  000e7	f6 40 04 01	 test	 BYTE PTR [eax+4], 1
  000eb	8b 4c 24 10	 mov	 ecx, DWORD PTR _nBufSize$[esp+16440]
  000ef	75 14		 jne	 SHORT $L318307
  000f1	66 ff 80 0c 57
	00 00		 inc	 WORD PTR [eax+22284]
  000f8	51		 push	 ecx
  000f9	53		 push	 ebx
  000fa	8d 88 f8 16 00
	00		 lea	 ecx, DWORD PTR [eax+5880]
  00100	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
$L318307:

; 4724 : 	NEXT_VISIBILITYRANGE( pMover )

  00105	8a 46 15	 mov	 al, BYTE PTR [esi+21]
  00108	84 c0		 test	 al, al
  0010a	75 3f		 jne	 SHORT $L318435
  0010c	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0010f	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00112	84 c9		 test	 cl, cl
  00114	75 18		 jne	 SHORT $L318469
  00116	8b f0		 mov	 esi, eax
  00118	8b 06		 mov	 eax, DWORD PTR [esi]
  0011a	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  0011d	84 c9		 test	 cl, cl
  0011f	75 2a		 jne	 SHORT $L318435
$L318449:
  00121	8b f0		 mov	 esi, eax
  00123	8b 06		 mov	 eax, DWORD PTR [esi]
  00125	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00128	84 c9		 test	 cl, cl
  0012a	74 f5		 je	 SHORT $L318449
  0012c	eb 1d		 jmp	 SHORT $L318435
$L318469:
  0012e	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00131	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00134	84 c9		 test	 cl, cl
  00136	75 11		 jne	 SHORT $L318438
$L318437:
  00138	3b 70 08	 cmp	 esi, DWORD PTR [eax+8]
  0013b	75 0c		 jne	 SHORT $L318438
  0013d	8b f0		 mov	 esi, eax
  0013f	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00142	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00145	84 c9		 test	 cl, cl
  00147	74 ef		 je	 SHORT $L318437
$L318438:
  00149	8b f0		 mov	 esi, eax
$L318435:

; 4720 : 	
; 4721 : 	FOR_VISIBILITYRANGE( pMover )

  0014b	3b f7		 cmp	 esi, edi
  0014d	75 91		 jne	 SHORT $L280957
$L280958:

; 4725 : }

  0014f	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  00153	c7 84 24 34 40
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+16448], -1
  0015e	e8 00 00 00 00	 call	 ??1CAr@@QAE@XZ		; CAr::~CAr
  00163	8b 8c 24 2c 40
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+16440]
  0016a	5f		 pop	 edi
  0016b	5e		 pop	 esi
  0016c	5d		 pop	 ebp
  0016d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00174	8b 8c 24 1c 40
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+16428]
  0017b	5b		 pop	 ebx
  0017c	33 cc		 xor	 ecx, esp
  0017e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00183	81 c4 28 40 00
	00		 add	 esp, 16424		; 00004028H
  00189	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L318187:
  00000	8d 8d dc bf ff
	ff		 lea	 ecx, DWORD PTR _ar$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CAr@@QAE@XZ		; CAr::~CAr
__ehhandler$?AddSetFlightLevel@CUserMng@@QAEXPAVCMover@@H@Z:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T318466
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?AddSetFlightLevel@CUserMng@@QAEXPAVCMover@@H@Z ENDP	; CUserMng::AddSetFlightLevel
PUBLIC	?AddSetSkillLevel@CUserMng@@QAEXPAVCMover@@KK@Z	; CUserMng::AddSetSkillLevel
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
xdata$x	SEGMENT
$T318773 DD	0ffffffffH
	DD	FLAT:$L318483
$T318765 DD	019930520H
	DD	01H
	DD	FLAT:$T318773
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
xdata$x	ENDS
;	COMDAT ?AddSetSkillLevel@CUserMng@@QAEXPAVCMover@@KK@Z
_TEXT	SEGMENT
_nBufSize$ = -16424					; size = 4
_ar$ = -16420						; size = 16404
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_pMover$ = 8						; size = 4
_dwSkill$ = 12						; size = 4
_dwLevel$ = 16						; size = 4
?AddSetSkillLevel@CUserMng@@QAEXPAVCMover@@KK@Z PROC NEAR ; CUserMng::AddSetSkillLevel, COMDAT
; _this$ = ecx

; 4729 : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?AddSetSkillLevel@CUserMng@@QAEXPAVCMover@@KK@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	b8 1c 40 00 00	 mov	 eax, 16412		; 0000401cH
  00013	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0001a	e8 00 00 00 00	 call	 __chkstk
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00024	33 c4		 xor	 eax, esp
  00026	53		 push	 ebx
  00027	55		 push	 ebp
  00028	8b ac 24 34 40
	00 00		 mov	 ebp, DWORD PTR _pMover$[esp+16428]
  0002f	56		 push	 esi
  00030	57		 push	 edi

; 4730 : 	CAr ar;

  00031	6a 00		 push	 0
  00033	6a 00		 push	 0
  00035	8d 4c 24 1c	 lea	 ecx, DWORD PTR _ar$[esp+16448]
  00039	89 84 24 30 40
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+16448], eax
  00040	e8 00 00 00 00	 call	 ??0CAr@@QAE@PAXI@Z	; CAr::CAr

; 4731 : 
; 4732 : 	ar << GETID( pMover ) << SNAPSHOTTYPE_SETSKILLLEVEL;

  00045	85 ed		 test	 ebp, ebp
  00047	c7 84 24 34 40
	00 00 00 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+16448], 0
  00052	74 08		 je	 SHORT $L318481
  00054	8b b5 bc 01 00
	00		 mov	 esi, DWORD PTR [ebp+444]
  0005a	eb 03		 jmp	 SHORT $L318482
$L318481:
  0005c	83 ce ff	 or	 esi, -1
$L318482:
  0005f	bf 04 00 00 00	 mov	 edi, 4
  00064	57		 push	 edi
  00065	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  00069	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0006e	8b 44 24 1c	 mov	 eax, DWORD PTR _ar$[esp+16448]
  00072	89 30		 mov	 DWORD PTR [eax], esi
  00074	8b 74 24 1c	 mov	 esi, DWORD PTR _ar$[esp+16448]
  00078	03 f7		 add	 esi, edi
  0007a	6a 02		 push	 2
  0007c	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  00080	89 74 24 20	 mov	 DWORD PTR _ar$[esp+16452], esi
  00084	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00089	8b 4c 24 1c	 mov	 ecx, DWORD PTR _ar$[esp+16448]
  0008d	66 c7 01 26 00	 mov	 WORD PTR [ecx], 38	; 00000026H
  00092	83 44 24 1c 02	 add	 DWORD PTR _ar$[esp+16448], 2

; 4733 : 	ar << dwSkill << dwLevel;

  00097	57		 push	 edi
  00098	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  0009c	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000a1	8b 54 24 1c	 mov	 edx, DWORD PTR _ar$[esp+16448]
  000a5	8b 84 24 40 40
	00 00		 mov	 eax, DWORD PTR _dwSkill$[esp+16436]
  000ac	89 02		 mov	 DWORD PTR [edx], eax
  000ae	8b 5c 24 1c	 mov	 ebx, DWORD PTR _ar$[esp+16448]
  000b2	03 df		 add	 ebx, edi
  000b4	57		 push	 edi
  000b5	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  000b9	89 5c 24 20	 mov	 DWORD PTR _ar$[esp+16452], ebx
  000bd	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000c2	8b 4c 24 1c	 mov	 ecx, DWORD PTR _ar$[esp+16448]
  000c6	8b 94 24 44 40
	00 00		 mov	 edx, DWORD PTR _dwLevel$[esp+16436]
  000cd	89 11		 mov	 DWORD PTR [ecx], edx
  000cf	8b 54 24 1c	 mov	 edx, DWORD PTR _ar$[esp+16448]

; 4734 : 
; 4735 : 	GETBLOCK( ar, lpBuf, nBufSize );

  000d3	8d 44 24 10	 lea	 eax, DWORD PTR _nBufSize$[esp+16440]
  000d7	03 d7		 add	 edx, edi
  000d9	50		 push	 eax
  000da	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  000de	89 54 24 20	 mov	 DWORD PTR _ar$[esp+16452], edx
  000e2	e8 00 00 00 00	 call	 ?GetBuffer@CAr@@QAEPAEPAH@Z ; CAr::GetBuffer

; 4736 : 
; 4737 : 	FOR_VISIBILITYRANGE( pMover )

  000e7	8b bd 10 02 00
	00		 mov	 edi, DWORD PTR [ebp+528]
  000ed	8b 37		 mov	 esi, DWORD PTR [edi]
  000ef	3b f7		 cmp	 esi, edi
  000f1	8b d8		 mov	 ebx, eax
  000f3	74 72		 je	 SHORT $L280986
$L280985:

; 4738 : 		if( USERPTR != pMover )

  000f5	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  000f8	3b c5		 cmp	 eax, ebp
  000fa	74 1e		 je	 SHORT $L318609

; 4739 : 			USERPTR->AddBlock( lpBuf, nBufSize );

  000fc	f6 40 04 01	 test	 BYTE PTR [eax+4], 1
  00100	8b 4c 24 10	 mov	 ecx, DWORD PTR _nBufSize$[esp+16440]
  00104	75 14		 jne	 SHORT $L318609
  00106	66 ff 80 0c 57
	00 00		 inc	 WORD PTR [eax+22284]
  0010d	51		 push	 ecx
  0010e	53		 push	 ebx
  0010f	8d 88 f8 16 00
	00		 lea	 ecx, DWORD PTR [eax+5880]
  00115	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
$L318609:

; 4740 : 	NEXT_VISIBILITYRANGE( pMover )

  0011a	8a 46 15	 mov	 al, BYTE PTR [esi+21]
  0011d	84 c0		 test	 al, al
  0011f	75 42		 jne	 SHORT $L318757
  00121	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00124	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00127	84 c9		 test	 cl, cl
  00129	75 18		 jne	 SHORT $L318768
  0012b	8b f0		 mov	 esi, eax
  0012d	8b 06		 mov	 eax, DWORD PTR [esi]
  0012f	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00132	84 c9		 test	 cl, cl
  00134	75 2d		 jne	 SHORT $L318757
$L318745:
  00136	8b f0		 mov	 esi, eax
  00138	8b 06		 mov	 eax, DWORD PTR [esi]
  0013a	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  0013d	84 c9		 test	 cl, cl
  0013f	74 f5		 je	 SHORT $L318745
  00141	eb 20		 jmp	 SHORT $L318757
$L318768:
  00143	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00146	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00149	84 c9		 test	 cl, cl
  0014b	75 14		 jne	 SHORT $L318760
  0014d	8d 49 00	 npad	 3
$L318759:
  00150	3b 70 08	 cmp	 esi, DWORD PTR [eax+8]
  00153	75 0c		 jne	 SHORT $L318760
  00155	8b f0		 mov	 esi, eax
  00157	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0015a	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  0015d	84 c9		 test	 cl, cl
  0015f	74 ef		 je	 SHORT $L318759
$L318760:
  00161	8b f0		 mov	 esi, eax
$L318757:

; 4736 : 
; 4737 : 	FOR_VISIBILITYRANGE( pMover )

  00163	3b f7		 cmp	 esi, edi
  00165	75 8e		 jne	 SHORT $L280985
$L280986:

; 4741 : }

  00167	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  0016b	c7 84 24 34 40
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+16448], -1
  00176	e8 00 00 00 00	 call	 ??1CAr@@QAE@XZ		; CAr::~CAr
  0017b	8b 8c 24 2c 40
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+16440]
  00182	5f		 pop	 edi
  00183	5e		 pop	 esi
  00184	5d		 pop	 ebp
  00185	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0018c	8b 8c 24 1c 40
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+16428]
  00193	5b		 pop	 ebx
  00194	33 cc		 xor	 ecx, esp
  00196	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0019b	81 c4 28 40 00
	00		 add	 esp, 16424		; 00004028H
  001a1	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L318483:
  00000	8d 8d dc bf ff
	ff		 lea	 ecx, DWORD PTR _ar$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CAr@@QAE@XZ		; CAr::~CAr
__ehhandler$?AddSetSkillLevel@CUserMng@@QAEXPAVCMover@@KK@Z:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T318765
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?AddSetSkillLevel@CUserMng@@QAEXPAVCMover@@KK@Z ENDP	; CUserMng::AddSetSkillLevel
PUBLIC	?AddSetDestPos@CUserMng@@QAEXPAVCMover@@ABUD3DXVECTOR3@@E@Z ; CUserMng::AddSetDestPos
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
xdata$x	SEGMENT
$T319074 DD	0ffffffffH
	DD	FLAT:$L318782
$T319066 DD	019930520H
	DD	01H
	DD	FLAT:$T319074
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
xdata$x	ENDS
;	COMDAT ?AddSetDestPos@CUserMng@@QAEXPAVCMover@@ABUD3DXVECTOR3@@E@Z
_TEXT	SEGMENT
_nBufSize$ = -16436					; size = 4
$T318797 = -16432					; size = 12
_ar$ = -16420						; size = 16404
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_pMover$ = 8						; size = 4
_vPos$ = 12						; size = 4
_fForward$ = 16						; size = 1
?AddSetDestPos@CUserMng@@QAEXPAVCMover@@ABUD3DXVECTOR3@@E@Z PROC NEAR ; CUserMng::AddSetDestPos, COMDAT
; _this$ = ecx

; 4749 : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?AddSetDestPos@CUserMng@@QAEXPAVCMover@@ABUD3DXVECTOR3@@E@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	b8 28 40 00 00	 mov	 eax, 16424		; 00004028H
  00013	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0001a	e8 00 00 00 00	 call	 __chkstk
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00024	33 c4		 xor	 eax, esp
  00026	53		 push	 ebx
  00027	55		 push	 ebp
  00028	8b ac 24 40 40
	00 00		 mov	 ebp, DWORD PTR _pMover$[esp+16440]
  0002f	56		 push	 esi
  00030	8b b4 24 48 40
	00 00		 mov	 esi, DWORD PTR _vPos$[esp+16444]
  00037	57		 push	 edi

; 4750 : 	CAr ar;

  00038	6a 00		 push	 0
  0003a	6a 00		 push	 0
  0003c	8d 4c 24 28	 lea	 ecx, DWORD PTR _ar$[esp+16460]
  00040	89 84 24 3c 40
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+16460], eax
  00047	e8 00 00 00 00	 call	 ??0CAr@@QAE@PAXI@Z	; CAr::CAr

; 4751 : 
; 4752 : 	ar << GETID( pMover ) << SNAPSHOTTYPE_DESTPOS;

  0004c	85 ed		 test	 ebp, ebp
  0004e	c7 84 24 40 40
	00 00 00 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+16460], 0
  00059	74 08		 je	 SHORT $L318780
  0005b	8b bd bc 01 00
	00		 mov	 edi, DWORD PTR [ebp+444]
  00061	eb 03		 jmp	 SHORT $L318781
$L318780:
  00063	83 cf ff	 or	 edi, -1
$L318781:
  00066	6a 04		 push	 4
  00068	8d 4c 24 24	 lea	 ecx, DWORD PTR _ar$[esp+16456]
  0006c	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00071	8b 44 24 28	 mov	 eax, DWORD PTR _ar$[esp+16460]
  00075	89 38		 mov	 DWORD PTR [eax], edi
  00077	8b 54 24 28	 mov	 edx, DWORD PTR _ar$[esp+16460]
  0007b	83 c2 04	 add	 edx, 4
  0007e	6a 02		 push	 2
  00080	8d 4c 24 24	 lea	 ecx, DWORD PTR _ar$[esp+16456]
  00084	89 54 24 2c	 mov	 DWORD PTR _ar$[esp+16464], edx
  00088	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0008d	8b 4c 24 28	 mov	 ecx, DWORD PTR _ar$[esp+16460]
  00091	66 c7 01 c1 00	 mov	 WORD PTR [ecx], 193	; 000000c1H
  00096	8b 44 24 28	 mov	 eax, DWORD PTR _ar$[esp+16460]

; 4753 : 	ar << vPos << fForward;

  0009a	8b 16		 mov	 edx, DWORD PTR [esi]
  0009c	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0009f	83 c0 02	 add	 eax, 2
  000a2	89 54 24 14	 mov	 DWORD PTR $T318797[esp+16452], edx
  000a6	89 44 24 28	 mov	 DWORD PTR _ar$[esp+16460], eax
  000aa	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000ad	6a 0c		 push	 12			; 0000000cH
  000af	8d 54 24 18	 lea	 edx, DWORD PTR $T318797[esp+16456]
  000b3	89 4c 24 20	 mov	 DWORD PTR $T318797[esp+16464], ecx
  000b7	52		 push	 edx
  000b8	8d 4c 24 28	 lea	 ecx, DWORD PTR _ar$[esp+16460]
  000bc	89 44 24 20	 mov	 DWORD PTR $T318797[esp+16464], eax
  000c0	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
  000c5	6a 01		 push	 1
  000c7	8d 4c 24 24	 lea	 ecx, DWORD PTR _ar$[esp+16456]
  000cb	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000d0	8b 44 24 28	 mov	 eax, DWORD PTR _ar$[esp+16460]
  000d4	8a 8c 24 50 40
	00 00		 mov	 cl, BYTE PTR _fForward$[esp+16448]
  000db	88 08		 mov	 BYTE PTR [eax], cl
  000dd	ff 44 24 28	 inc	 DWORD PTR _ar$[esp+16460]

; 4754 : 
; 4755 : #ifdef __IAOBJ0622
; 4756 : 	ar << objidIAObj;
; 4757 : #endif	// __IAOBJ0622
; 4758 : 
; 4759 : 	GETBLOCK( ar, lpBuf, nBufSize );

  000e1	8d 54 24 10	 lea	 edx, DWORD PTR _nBufSize$[esp+16452]
  000e5	52		 push	 edx
  000e6	8d 4c 24 24	 lea	 ecx, DWORD PTR _ar$[esp+16456]
  000ea	e8 00 00 00 00	 call	 ?GetBuffer@CAr@@QAEPAEPAH@Z ; CAr::GetBuffer

; 4760 : 
; 4761 : 	FOR_VISIBILITYRANGE( pMover )

  000ef	8b bd 10 02 00
	00		 mov	 edi, DWORD PTR [ebp+528]
  000f5	8b 37		 mov	 esi, DWORD PTR [edi]
  000f7	3b f7		 cmp	 esi, edi
  000f9	8b d8		 mov	 ebx, eax
  000fb	74 72		 je	 SHORT $L281014
  000fd	8d 49 00	 npad	 3
$L281013:

; 4762 : 		if( USERPTR != pMover )

  00100	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00103	3b c5		 cmp	 eax, ebp
  00105	74 1e		 je	 SHORT $L318909

; 4763 : 			USERPTR->AddBlock( lpBuf, nBufSize );

  00107	f6 40 04 01	 test	 BYTE PTR [eax+4], 1
  0010b	8b 4c 24 10	 mov	 ecx, DWORD PTR _nBufSize$[esp+16452]
  0010f	75 14		 jne	 SHORT $L318909
  00111	66 ff 80 0c 57
	00 00		 inc	 WORD PTR [eax+22284]
  00118	51		 push	 ecx
  00119	53		 push	 ebx
  0011a	8d 88 f8 16 00
	00		 lea	 ecx, DWORD PTR [eax+5880]
  00120	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
$L318909:

; 4764 : 	NEXT_VISIBILITYRANGE( pMover )

  00125	8a 46 15	 mov	 al, BYTE PTR [esi+21]
  00128	84 c0		 test	 al, al
  0012a	75 3f		 jne	 SHORT $L319033
  0012c	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0012f	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00132	84 c9		 test	 cl, cl
  00134	75 18		 jne	 SHORT $L319069
  00136	8b f0		 mov	 esi, eax
  00138	8b 06		 mov	 eax, DWORD PTR [esi]
  0013a	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  0013d	84 c9		 test	 cl, cl
  0013f	75 2a		 jne	 SHORT $L319033
$L319054:
  00141	8b f0		 mov	 esi, eax
  00143	8b 06		 mov	 eax, DWORD PTR [esi]
  00145	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00148	84 c9		 test	 cl, cl
  0014a	74 f5		 je	 SHORT $L319054
  0014c	eb 1d		 jmp	 SHORT $L319033
$L319069:
  0014e	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00151	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00154	84 c9		 test	 cl, cl
  00156	75 11		 jne	 SHORT $L319036
$L319035:
  00158	3b 70 08	 cmp	 esi, DWORD PTR [eax+8]
  0015b	75 0c		 jne	 SHORT $L319036
  0015d	8b f0		 mov	 esi, eax
  0015f	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00162	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00165	84 c9		 test	 cl, cl
  00167	74 ef		 je	 SHORT $L319035
$L319036:
  00169	8b f0		 mov	 esi, eax
$L319033:

; 4760 : 
; 4761 : 	FOR_VISIBILITYRANGE( pMover )

  0016b	3b f7		 cmp	 esi, edi
  0016d	75 91		 jne	 SHORT $L281013
$L281014:

; 4765 : }

  0016f	8d 4c 24 20	 lea	 ecx, DWORD PTR _ar$[esp+16452]
  00173	c7 84 24 40 40
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+16460], -1
  0017e	e8 00 00 00 00	 call	 ??1CAr@@QAE@XZ		; CAr::~CAr
  00183	8b 8c 24 38 40
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+16452]
  0018a	5f		 pop	 edi
  0018b	5e		 pop	 esi
  0018c	5d		 pop	 ebp
  0018d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00194	8b 8c 24 28 40
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+16440]
  0019b	5b		 pop	 ebx
  0019c	33 cc		 xor	 ecx, esp
  0019e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001a3	81 c4 34 40 00
	00		 add	 esp, 16436		; 00004034H
  001a9	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L318782:
  00000	8d 8d dc bf ff
	ff		 lea	 ecx, DWORD PTR _ar$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CAr@@QAE@XZ		; CAr::~CAr
__ehhandler$?AddSetDestPos@CUserMng@@QAEXPAVCMover@@ABUD3DXVECTOR3@@E@Z:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T319066
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?AddSetDestPos@CUserMng@@QAEXPAVCMover@@ABUD3DXVECTOR3@@E@Z ENDP ; CUserMng::AddSetDestPos
PUBLIC	?AddSetMovePattern@CUserMng@@QAEXPAVCMover@@HABUD3DXVECTOR3@@MM@Z ; CUserMng::AddSetMovePattern
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
xdata$x	SEGMENT
$T319386 DD	0ffffffffH
	DD	FLAT:$L319083
$T319378 DD	019930520H
	DD	01H
	DD	FLAT:$T319386
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
xdata$x	ENDS
;	COMDAT ?AddSetMovePattern@CUserMng@@QAEXPAVCMover@@HABUD3DXVECTOR3@@MM@Z
_TEXT	SEGMENT
_nBufSize$ = -16436					; size = 4
$T319106 = -16432					; size = 12
_ar$ = -16420						; size = 16404
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_pMover$ = 8						; size = 4
_nPattern$ = 12						; size = 4
_vPos$ = 16						; size = 4
_fAngle$ = 20						; size = 4
_fAngleX$ = 24						; size = 4
?AddSetMovePattern@CUserMng@@QAEXPAVCMover@@HABUD3DXVECTOR3@@MM@Z PROC NEAR ; CUserMng::AddSetMovePattern, COMDAT
; _this$ = ecx

; 4768 : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?AddSetMovePattern@CUserMng@@QAEXPAVCMover@@HABUD3DXVECTOR3@@MM@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	b8 28 40 00 00	 mov	 eax, 16424		; 00004028H
  00013	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0001a	e8 00 00 00 00	 call	 __chkstk
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00024	33 c4		 xor	 eax, esp
  00026	53		 push	 ebx
  00027	55		 push	 ebp
  00028	8b ac 24 40 40
	00 00		 mov	 ebp, DWORD PTR _pMover$[esp+16440]
  0002f	56		 push	 esi
  00030	8b b4 24 4c 40
	00 00		 mov	 esi, DWORD PTR _vPos$[esp+16444]
  00037	57		 push	 edi

; 4769 : 	CAr ar;

  00038	6a 00		 push	 0
  0003a	6a 00		 push	 0
  0003c	8d 4c 24 28	 lea	 ecx, DWORD PTR _ar$[esp+16460]
  00040	89 84 24 3c 40
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+16460], eax
  00047	e8 00 00 00 00	 call	 ??0CAr@@QAE@PAXI@Z	; CAr::CAr

; 4770 : 	
; 4771 : 	ar << GETID( pMover ) << SNAPSHOTTYPE_SETMOVEPATTERN;

  0004c	85 ed		 test	 ebp, ebp
  0004e	c7 84 24 40 40
	00 00 00 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+16460], 0
  00059	74 08		 je	 SHORT $L319081
  0005b	8b bd bc 01 00
	00		 mov	 edi, DWORD PTR [ebp+444]
  00061	eb 03		 jmp	 SHORT $L319082
$L319081:
  00063	83 cf ff	 or	 edi, -1
$L319082:
  00066	bb 04 00 00 00	 mov	 ebx, 4
  0006b	53		 push	 ebx
  0006c	8d 4c 24 24	 lea	 ecx, DWORD PTR _ar$[esp+16456]
  00070	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00075	8b 44 24 28	 mov	 eax, DWORD PTR _ar$[esp+16460]
  00079	89 38		 mov	 DWORD PTR [eax], edi
  0007b	8b 7c 24 28	 mov	 edi, DWORD PTR _ar$[esp+16460]
  0007f	03 fb		 add	 edi, ebx
  00081	6a 02		 push	 2
  00083	8d 4c 24 24	 lea	 ecx, DWORD PTR _ar$[esp+16456]
  00087	89 7c 24 2c	 mov	 DWORD PTR _ar$[esp+16464], edi
  0008b	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00090	8b 4c 24 28	 mov	 ecx, DWORD PTR _ar$[esp+16460]
  00094	66 c7 01 cf 00	 mov	 WORD PTR [ecx], 207	; 000000cfH
  00099	83 44 24 28 02	 add	 DWORD PTR _ar$[esp+16460], 2

; 4772 : 	ar << nPattern << vPos << fAngle << fAngleX;

  0009e	53		 push	 ebx
  0009f	8d 4c 24 24	 lea	 ecx, DWORD PTR _ar$[esp+16456]
  000a3	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000a8	8b 54 24 28	 mov	 edx, DWORD PTR _ar$[esp+16460]
  000ac	8b 84 24 4c 40
	00 00		 mov	 eax, DWORD PTR _nPattern$[esp+16448]
  000b3	89 02		 mov	 DWORD PTR [edx], eax
  000b5	8b 0e		 mov	 ecx, DWORD PTR [esi]
  000b7	8b 7c 24 28	 mov	 edi, DWORD PTR _ar$[esp+16460]
  000bb	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  000be	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000c1	89 4c 24 14	 mov	 DWORD PTR $T319106[esp+16452], ecx
  000c5	6a 0c		 push	 12			; 0000000cH
  000c7	8d 4c 24 18	 lea	 ecx, DWORD PTR $T319106[esp+16456]
  000cb	51		 push	 ecx
  000cc	03 fb		 add	 edi, ebx
  000ce	8d 4c 24 28	 lea	 ecx, DWORD PTR _ar$[esp+16460]
  000d2	89 7c 24 30	 mov	 DWORD PTR _ar$[esp+16468], edi
  000d6	89 54 24 20	 mov	 DWORD PTR $T319106[esp+16464], edx
  000da	89 44 24 24	 mov	 DWORD PTR $T319106[esp+16468], eax
  000de	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
  000e3	53		 push	 ebx
  000e4	8d 4c 24 24	 lea	 ecx, DWORD PTR _ar$[esp+16456]
  000e8	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000ed	d9 84 24 54 40
	00 00		 fld	 DWORD PTR _fAngle$[esp+16448]
  000f4	8b 54 24 28	 mov	 edx, DWORD PTR _ar$[esp+16460]
  000f8	d9 1a		 fstp	 DWORD PTR [edx]
  000fa	8b 44 24 28	 mov	 eax, DWORD PTR _ar$[esp+16460]
  000fe	03 c3		 add	 eax, ebx
  00100	53		 push	 ebx
  00101	8d 4c 24 24	 lea	 ecx, DWORD PTR _ar$[esp+16456]
  00105	89 44 24 2c	 mov	 DWORD PTR _ar$[esp+16464], eax
  00109	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0010e	d9 84 24 58 40
	00 00		 fld	 DWORD PTR _fAngleX$[esp+16448]
  00115	8b 44 24 28	 mov	 eax, DWORD PTR _ar$[esp+16460]
  00119	d9 18		 fstp	 DWORD PTR [eax]
  0011b	8b 74 24 28	 mov	 esi, DWORD PTR _ar$[esp+16460]

; 4773 : 	
; 4774 : 	GETBLOCK( ar, lpBuf, nBufSize );

  0011f	8d 4c 24 10	 lea	 ecx, DWORD PTR _nBufSize$[esp+16452]
  00123	51		 push	 ecx
  00124	03 f3		 add	 esi, ebx
  00126	8d 4c 24 24	 lea	 ecx, DWORD PTR _ar$[esp+16456]
  0012a	89 74 24 2c	 mov	 DWORD PTR _ar$[esp+16464], esi
  0012e	e8 00 00 00 00	 call	 ?GetBuffer@CAr@@QAEPAEPAH@Z ; CAr::GetBuffer

; 4775 : 	
; 4776 : 	FOR_VISIBILITYRANGE( pMover )

  00133	8b bd 10 02 00
	00		 mov	 edi, DWORD PTR [ebp+528]
  00139	8b 37		 mov	 esi, DWORD PTR [edi]
  0013b	3b f7		 cmp	 esi, edi
  0013d	8b d8		 mov	 ebx, eax
  0013f	74 76		 je	 SHORT $L281044
$L281043:

; 4777 : 		if( USERPTR != pMover )

  00141	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00144	3b c5		 cmp	 eax, ebp
  00146	74 1e		 je	 SHORT $L319218

; 4778 : 			USERPTR->AddBlock( lpBuf, nBufSize );

  00148	f6 40 04 01	 test	 BYTE PTR [eax+4], 1
  0014c	8b 4c 24 10	 mov	 ecx, DWORD PTR _nBufSize$[esp+16452]
  00150	75 14		 jne	 SHORT $L319218
  00152	66 ff 80 0c 57
	00 00		 inc	 WORD PTR [eax+22284]
  00159	51		 push	 ecx
  0015a	53		 push	 ebx
  0015b	8d 88 f8 16 00
	00		 lea	 ecx, DWORD PTR [eax+5880]
  00161	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
$L319218:

; 4779 : 	NEXT_VISIBILITYRANGE( pMover )

  00166	8a 46 15	 mov	 al, BYTE PTR [esi+21]
  00169	84 c0		 test	 al, al
  0016b	75 46		 jne	 SHORT $L319346
  0016d	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00170	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00173	84 c9		 test	 cl, cl
  00175	75 18		 jne	 SHORT $L319381
  00177	8b f0		 mov	 esi, eax
  00179	8b 06		 mov	 eax, DWORD PTR [esi]
  0017b	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  0017e	84 c9		 test	 cl, cl
  00180	75 31		 jne	 SHORT $L319346
$L319360:
  00182	8b f0		 mov	 esi, eax
  00184	8b 06		 mov	 eax, DWORD PTR [esi]
  00186	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00189	84 c9		 test	 cl, cl
  0018b	74 f5		 je	 SHORT $L319360
  0018d	eb 24		 jmp	 SHORT $L319346
$L319381:
  0018f	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00192	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00195	84 c9		 test	 cl, cl
  00197	75 18		 jne	 SHORT $L319349
  00199	8d a4 24 00 00
	00 00		 npad	 7
$L319348:
  001a0	3b 70 08	 cmp	 esi, DWORD PTR [eax+8]
  001a3	75 0c		 jne	 SHORT $L319349
  001a5	8b f0		 mov	 esi, eax
  001a7	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001aa	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  001ad	84 c9		 test	 cl, cl
  001af	74 ef		 je	 SHORT $L319348
$L319349:
  001b1	8b f0		 mov	 esi, eax
$L319346:

; 4775 : 	
; 4776 : 	FOR_VISIBILITYRANGE( pMover )

  001b3	3b f7		 cmp	 esi, edi
  001b5	75 8a		 jne	 SHORT $L281043
$L281044:

; 4780 : }

  001b7	8d 4c 24 20	 lea	 ecx, DWORD PTR _ar$[esp+16452]
  001bb	c7 84 24 40 40
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+16460], -1
  001c6	e8 00 00 00 00	 call	 ??1CAr@@QAE@XZ		; CAr::~CAr
  001cb	8b 8c 24 38 40
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+16452]
  001d2	5f		 pop	 edi
  001d3	5e		 pop	 esi
  001d4	5d		 pop	 ebp
  001d5	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  001dc	8b 8c 24 28 40
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+16440]
  001e3	5b		 pop	 ebx
  001e4	33 cc		 xor	 ecx, esp
  001e6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001eb	81 c4 34 40 00
	00		 add	 esp, 16436		; 00004034H
  001f1	c2 14 00	 ret	 20			; 00000014H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L319083:
  00000	8d 8d dc bf ff
	ff		 lea	 ecx, DWORD PTR _ar$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CAr@@QAE@XZ		; CAr::~CAr
__ehhandler$?AddSetMovePattern@CUserMng@@QAEXPAVCMover@@HABUD3DXVECTOR3@@MM@Z:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T319378
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?AddSetMovePattern@CUserMng@@QAEXPAVCMover@@HABUD3DXVECTOR3@@MM@Z ENDP ; CUserMng::AddSetMovePattern
PUBLIC	?AddSetDestAngle@CUserMng@@QAEXPAVCMover@@ME@Z	; CUserMng::AddSetDestAngle
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
xdata$x	SEGMENT
$T319685 DD	0ffffffffH
	DD	FLAT:$L319395
$T319677 DD	019930520H
	DD	01H
	DD	FLAT:$T319685
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
xdata$x	ENDS
;	COMDAT ?AddSetDestAngle@CUserMng@@QAEXPAVCMover@@ME@Z
_TEXT	SEGMENT
_nBufSize$ = -16424					; size = 4
_ar$ = -16420						; size = 16404
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_pMover$ = 8						; size = 4
_fAngle$ = 12						; size = 4
_fLeft$ = 16						; size = 1
?AddSetDestAngle@CUserMng@@QAEXPAVCMover@@ME@Z PROC NEAR ; CUserMng::AddSetDestAngle, COMDAT
; _this$ = ecx

; 4783 : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?AddSetDestAngle@CUserMng@@QAEXPAVCMover@@ME@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	b8 1c 40 00 00	 mov	 eax, 16412		; 0000401cH
  00013	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0001a	e8 00 00 00 00	 call	 __chkstk
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00024	33 c4		 xor	 eax, esp
  00026	53		 push	 ebx
  00027	55		 push	 ebp
  00028	8b ac 24 34 40
	00 00		 mov	 ebp, DWORD PTR _pMover$[esp+16428]
  0002f	56		 push	 esi
  00030	57		 push	 edi

; 4784 : 	CAr ar;

  00031	6a 00		 push	 0
  00033	6a 00		 push	 0
  00035	8d 4c 24 1c	 lea	 ecx, DWORD PTR _ar$[esp+16448]
  00039	89 84 24 30 40
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+16448], eax
  00040	e8 00 00 00 00	 call	 ??0CAr@@QAE@PAXI@Z	; CAr::CAr

; 4785 : 
; 4786 : 	ar << GETID( pMover ) << SNAPSHOTTYPE_DESTANGLE;

  00045	85 ed		 test	 ebp, ebp
  00047	c7 84 24 34 40
	00 00 00 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+16448], 0
  00052	74 08		 je	 SHORT $L319393
  00054	8b b5 bc 01 00
	00		 mov	 esi, DWORD PTR [ebp+444]
  0005a	eb 03		 jmp	 SHORT $L319394
$L319393:
  0005c	83 ce ff	 or	 esi, -1
$L319394:
  0005f	bf 04 00 00 00	 mov	 edi, 4
  00064	57		 push	 edi
  00065	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  00069	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0006e	8b 44 24 1c	 mov	 eax, DWORD PTR _ar$[esp+16448]
  00072	89 30		 mov	 DWORD PTR [eax], esi
  00074	8b 74 24 1c	 mov	 esi, DWORD PTR _ar$[esp+16448]
  00078	03 f7		 add	 esi, edi
  0007a	6a 02		 push	 2
  0007c	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  00080	89 74 24 20	 mov	 DWORD PTR _ar$[esp+16452], esi
  00084	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00089	8b 4c 24 1c	 mov	 ecx, DWORD PTR _ar$[esp+16448]
  0008d	66 c7 01 c3 00	 mov	 WORD PTR [ecx], 195	; 000000c3H
  00092	83 44 24 1c 02	 add	 DWORD PTR _ar$[esp+16448], 2

; 4787 : 	ar << fAngle << fLeft;

  00097	57		 push	 edi
  00098	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  0009c	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000a1	d9 84 24 40 40
	00 00		 fld	 DWORD PTR _fAngle$[esp+16436]
  000a8	8b 54 24 1c	 mov	 edx, DWORD PTR _ar$[esp+16448]
  000ac	d9 1a		 fstp	 DWORD PTR [edx]
  000ae	8b 5c 24 1c	 mov	 ebx, DWORD PTR _ar$[esp+16448]
  000b2	03 df		 add	 ebx, edi
  000b4	6a 01		 push	 1
  000b6	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  000ba	89 5c 24 20	 mov	 DWORD PTR _ar$[esp+16452], ebx
  000be	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000c3	8b 44 24 1c	 mov	 eax, DWORD PTR _ar$[esp+16448]
  000c7	8a 8c 24 44 40
	00 00		 mov	 cl, BYTE PTR _fLeft$[esp+16436]
  000ce	88 08		 mov	 BYTE PTR [eax], cl
  000d0	ff 44 24 1c	 inc	 DWORD PTR _ar$[esp+16448]

; 4788 : 
; 4789 : 	GETBLOCK( ar, lpBuf, nBufSize );

  000d4	8d 54 24 10	 lea	 edx, DWORD PTR _nBufSize$[esp+16440]
  000d8	52		 push	 edx
  000d9	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  000dd	e8 00 00 00 00	 call	 ?GetBuffer@CAr@@QAEPAEPAH@Z ; CAr::GetBuffer

; 4790 : 
; 4791 : 	FOR_VISIBILITYRANGE( pMover )

  000e2	8b bd 10 02 00
	00		 mov	 edi, DWORD PTR [ebp+528]
  000e8	8b 37		 mov	 esi, DWORD PTR [edi]
  000ea	3b f7		 cmp	 esi, edi
  000ec	8b d8		 mov	 ebx, eax
  000ee	74 6f		 je	 SHORT $L281072
$L281071:

; 4792 : 		if( USERPTR != pMover )

  000f0	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  000f3	3b c5		 cmp	 eax, ebp
  000f5	74 1e		 je	 SHORT $L319521

; 4793 : 			USERPTR->AddBlock( lpBuf, nBufSize );

  000f7	f6 40 04 01	 test	 BYTE PTR [eax+4], 1
  000fb	8b 4c 24 10	 mov	 ecx, DWORD PTR _nBufSize$[esp+16440]
  000ff	75 14		 jne	 SHORT $L319521
  00101	66 ff 80 0c 57
	00 00		 inc	 WORD PTR [eax+22284]
  00108	51		 push	 ecx
  00109	53		 push	 ebx
  0010a	8d 88 f8 16 00
	00		 lea	 ecx, DWORD PTR [eax+5880]
  00110	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
$L319521:

; 4794 : 	NEXT_VISIBILITYRANGE( pMover )

  00115	8a 46 15	 mov	 al, BYTE PTR [esi+21]
  00118	84 c0		 test	 al, al
  0011a	75 3f		 jne	 SHORT $L319669
  0011c	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0011f	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00122	84 c9		 test	 cl, cl
  00124	75 18		 jne	 SHORT $L319680
  00126	8b f0		 mov	 esi, eax
  00128	8b 06		 mov	 eax, DWORD PTR [esi]
  0012a	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  0012d	84 c9		 test	 cl, cl
  0012f	75 2a		 jne	 SHORT $L319669
$L319657:
  00131	8b f0		 mov	 esi, eax
  00133	8b 06		 mov	 eax, DWORD PTR [esi]
  00135	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00138	84 c9		 test	 cl, cl
  0013a	74 f5		 je	 SHORT $L319657
  0013c	eb 1d		 jmp	 SHORT $L319669
$L319680:
  0013e	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00141	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00144	84 c9		 test	 cl, cl
  00146	75 11		 jne	 SHORT $L319672
$L319671:
  00148	3b 70 08	 cmp	 esi, DWORD PTR [eax+8]
  0014b	75 0c		 jne	 SHORT $L319672
  0014d	8b f0		 mov	 esi, eax
  0014f	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00152	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00155	84 c9		 test	 cl, cl
  00157	74 ef		 je	 SHORT $L319671
$L319672:
  00159	8b f0		 mov	 esi, eax
$L319669:

; 4790 : 
; 4791 : 	FOR_VISIBILITYRANGE( pMover )

  0015b	3b f7		 cmp	 esi, edi
  0015d	75 91		 jne	 SHORT $L281071
$L281072:

; 4795 : }

  0015f	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  00163	c7 84 24 34 40
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+16448], -1
  0016e	e8 00 00 00 00	 call	 ??1CAr@@QAE@XZ		; CAr::~CAr
  00173	8b 8c 24 2c 40
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+16440]
  0017a	5f		 pop	 edi
  0017b	5e		 pop	 esi
  0017c	5d		 pop	 ebp
  0017d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00184	8b 8c 24 1c 40
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+16428]
  0018b	5b		 pop	 ebx
  0018c	33 cc		 xor	 ecx, esp
  0018e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00193	81 c4 28 40 00
	00		 add	 esp, 16424		; 00004028H
  00199	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L319395:
  00000	8d 8d dc bf ff
	ff		 lea	 ecx, DWORD PTR _ar$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CAr@@QAE@XZ		; CAr::~CAr
__ehhandler$?AddSetDestAngle@CUserMng@@QAEXPAVCMover@@ME@Z:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T319677
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?AddSetDestAngle@CUserMng@@QAEXPAVCMover@@ME@Z ENDP	; CUserMng::AddSetDestAngle
PUBLIC	?AddMoverSetDestObj@CUserMng@@QAEXPAVCMover@@KMH@Z ; CUserMng::AddMoverSetDestObj
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
xdata$x	SEGMENT
$T319984 DD	0ffffffffH
	DD	FLAT:$L319694
$T319976 DD	019930520H
	DD	01H
	DD	FLAT:$T319984
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
xdata$x	ENDS
;	COMDAT ?AddMoverSetDestObj@CUserMng@@QAEXPAVCMover@@KMH@Z
_TEXT	SEGMENT
_nBufSize$ = -16424					; size = 4
_ar$ = -16420						; size = 16404
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_pMover$ = 8						; size = 4
_objid$ = 12						; size = 4
_fRange$ = 16						; size = 4
_fTransferToMe$ = 20					; size = 4
?AddMoverSetDestObj@CUserMng@@QAEXPAVCMover@@KMH@Z PROC NEAR ; CUserMng::AddMoverSetDestObj, COMDAT
; _this$ = ecx

; 4797 : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?AddMoverSetDestObj@CUserMng@@QAEXPAVCMover@@KMH@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	b8 1c 40 00 00	 mov	 eax, 16412		; 0000401cH
  00013	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0001a	e8 00 00 00 00	 call	 __chkstk
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00024	33 c4		 xor	 eax, esp
  00026	53		 push	 ebx
  00027	55		 push	 ebp
  00028	8b ac 24 34 40
	00 00		 mov	 ebp, DWORD PTR _pMover$[esp+16428]
  0002f	56		 push	 esi
  00030	57		 push	 edi

; 4798 : 	CAr ar;

  00031	6a 00		 push	 0
  00033	6a 00		 push	 0
  00035	8d 4c 24 1c	 lea	 ecx, DWORD PTR _ar$[esp+16448]
  00039	89 84 24 30 40
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+16448], eax
  00040	e8 00 00 00 00	 call	 ??0CAr@@QAE@PAXI@Z	; CAr::CAr

; 4799 : 
; 4800 : 	ar << GETID( pMover ) << SNAPSHOTTYPE_MOVERSETDESTOBJ;

  00045	85 ed		 test	 ebp, ebp
  00047	c7 84 24 34 40
	00 00 00 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+16448], 0
  00052	74 08		 je	 SHORT $L319692
  00054	8b b5 bc 01 00
	00		 mov	 esi, DWORD PTR [ebp+444]
  0005a	eb 03		 jmp	 SHORT $L319693
$L319692:
  0005c	83 ce ff	 or	 esi, -1
$L319693:
  0005f	bf 04 00 00 00	 mov	 edi, 4
  00064	57		 push	 edi
  00065	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  00069	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0006e	8b 44 24 1c	 mov	 eax, DWORD PTR _ar$[esp+16448]
  00072	89 30		 mov	 DWORD PTR [eax], esi
  00074	8b 74 24 1c	 mov	 esi, DWORD PTR _ar$[esp+16448]
  00078	03 f7		 add	 esi, edi
  0007a	6a 02		 push	 2
  0007c	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  00080	89 74 24 20	 mov	 DWORD PTR _ar$[esp+16452], esi
  00084	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00089	8b 4c 24 1c	 mov	 ecx, DWORD PTR _ar$[esp+16448]
  0008d	66 c7 01 c2 00	 mov	 WORD PTR [ecx], 194	; 000000c2H
  00092	83 44 24 1c 02	 add	 DWORD PTR _ar$[esp+16448], 2

; 4801 : 	ar << objid << fRange;

  00097	57		 push	 edi
  00098	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  0009c	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000a1	8b 54 24 1c	 mov	 edx, DWORD PTR _ar$[esp+16448]
  000a5	8b 84 24 40 40
	00 00		 mov	 eax, DWORD PTR _objid$[esp+16436]
  000ac	89 02		 mov	 DWORD PTR [edx], eax
  000ae	8b 5c 24 1c	 mov	 ebx, DWORD PTR _ar$[esp+16448]
  000b2	03 df		 add	 ebx, edi
  000b4	57		 push	 edi
  000b5	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  000b9	89 5c 24 20	 mov	 DWORD PTR _ar$[esp+16452], ebx
  000bd	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000c2	d9 84 24 44 40
	00 00		 fld	 DWORD PTR _fRange$[esp+16436]
  000c9	8b 4c 24 1c	 mov	 ecx, DWORD PTR _ar$[esp+16448]
  000cd	d9 19		 fstp	 DWORD PTR [ecx]
  000cf	8b 54 24 1c	 mov	 edx, DWORD PTR _ar$[esp+16448]
  000d3	03 d7		 add	 edx, edi
  000d5	89 54 24 1c	 mov	 DWORD PTR _ar$[esp+16448], edx

; 4802 : 
; 4803 : 	GETBLOCK( ar, lpBuf, nBufSize );

  000d9	8d 54 24 10	 lea	 edx, DWORD PTR _nBufSize$[esp+16440]
  000dd	52		 push	 edx
  000de	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  000e2	e8 00 00 00 00	 call	 ?GetBuffer@CAr@@QAEPAEPAH@Z ; CAr::GetBuffer

; 4804 : 
; 4805 : 	FOR_VISIBILITYRANGE( pMover )

  000e7	8b bd 10 02 00
	00		 mov	 edi, DWORD PTR [ebp+528]
  000ed	8b 37		 mov	 esi, DWORD PTR [edi]
  000ef	3b f7		 cmp	 esi, edi
  000f1	8b d8		 mov	 ebx, eax
  000f3	0f 84 85 00 00
	00		 je	 $L281101
  000f9	8d a4 24 00 00
	00 00		 npad	 7
$L281100:

; 4806 : 		if( ( fTransferToMe || USERPTR != pMover ) )

  00100	8b 84 24 48 40
	00 00		 mov	 eax, DWORD PTR _fTransferToMe$[esp+16436]
  00107	85 c0		 test	 eax, eax
  00109	75 05		 jne	 SHORT $L281103
  0010b	39 6e 10	 cmp	 DWORD PTR [esi+16], ebp
  0010e	74 21		 je	 SHORT $L319820
$L281103:

; 4807 : 			USERPTR->AddBlock( lpBuf, nBufSize );

  00110	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00113	f6 40 04 01	 test	 BYTE PTR [eax+4], 1
  00117	8b 4c 24 10	 mov	 ecx, DWORD PTR _nBufSize$[esp+16440]
  0011b	75 14		 jne	 SHORT $L319820
  0011d	66 ff 80 0c 57
	00 00		 inc	 WORD PTR [eax+22284]
  00124	51		 push	 ecx
  00125	53		 push	 ebx
  00126	8d 88 f8 16 00
	00		 lea	 ecx, DWORD PTR [eax+5880]
  0012c	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
$L319820:

; 4808 : 	NEXT_VISIBILITYRANGE( pMover )

  00131	8a 46 15	 mov	 al, BYTE PTR [esi+21]
  00134	84 c0		 test	 al, al
  00136	75 42		 jne	 SHORT $L319969
  00138	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0013b	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  0013e	84 c9		 test	 cl, cl
  00140	75 1b		 jne	 SHORT $L319979
  00142	8b f0		 mov	 esi, eax
  00144	8b 06		 mov	 eax, DWORD PTR [esi]
  00146	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00149	84 c9		 test	 cl, cl
  0014b	75 2d		 jne	 SHORT $L319969
  0014d	8d 49 00	 npad	 3
$L319956:
  00150	8b f0		 mov	 esi, eax
  00152	8b 06		 mov	 eax, DWORD PTR [esi]
  00154	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00157	84 c9		 test	 cl, cl
  00159	74 f5		 je	 SHORT $L319956
  0015b	eb 1d		 jmp	 SHORT $L319969
$L319979:
  0015d	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00160	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00163	84 c9		 test	 cl, cl
  00165	75 11		 jne	 SHORT $L319972
$L319971:
  00167	3b 70 08	 cmp	 esi, DWORD PTR [eax+8]
  0016a	75 0c		 jne	 SHORT $L319972
  0016c	8b f0		 mov	 esi, eax
  0016e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00171	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00174	84 c9		 test	 cl, cl
  00176	74 ef		 je	 SHORT $L319971
$L319972:
  00178	8b f0		 mov	 esi, eax
$L319969:

; 4804 : 
; 4805 : 	FOR_VISIBILITYRANGE( pMover )

  0017a	3b f7		 cmp	 esi, edi
  0017c	75 82		 jne	 SHORT $L281100
$L281101:

; 4809 : }

  0017e	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  00182	c7 84 24 34 40
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+16448], -1
  0018d	e8 00 00 00 00	 call	 ??1CAr@@QAE@XZ		; CAr::~CAr
  00192	8b 8c 24 2c 40
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+16440]
  00199	5f		 pop	 edi
  0019a	5e		 pop	 esi
  0019b	5d		 pop	 ebp
  0019c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  001a3	8b 8c 24 1c 40
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+16428]
  001aa	5b		 pop	 ebx
  001ab	33 cc		 xor	 ecx, esp
  001ad	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001b2	81 c4 28 40 00
	00		 add	 esp, 16424		; 00004028H
  001b8	c2 10 00	 ret	 16			; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L319694:
  00000	8d 8d dc bf ff
	ff		 lea	 ecx, DWORD PTR _ar$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CAr@@QAE@XZ		; CAr::~CAr
__ehhandler$?AddMoverSetDestObj@CUserMng@@QAEXPAVCMover@@KMH@Z:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T319976
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?AddMoverSetDestObj@CUserMng@@QAEXPAVCMover@@KMH@Z ENDP	; CUserMng::AddMoverSetDestObj
PUBLIC	?AddMeleeAttack@CUserMng@@QAEXPAVCMover@@KKHH@Z	; CUserMng::AddMeleeAttack
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
xdata$x	SEGMENT
$T320299 DD	0ffffffffH
	DD	FLAT:$L319993
$T320291 DD	019930520H
	DD	01H
	DD	FLAT:$T320299
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
xdata$x	ENDS
;	COMDAT ?AddMeleeAttack@CUserMng@@QAEXPAVCMover@@KKHH@Z
_TEXT	SEGMENT
_nBufSize$ = -16424					; size = 4
_ar$ = -16420						; size = 16404
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_pMover$ = 8						; size = 4
_dwAtkMsg$ = 12						; size = 4
_objid$ = 16						; size = 4
_nParam2$ = 20						; size = 4
_nParam3$ = 24						; size = 4
?AddMeleeAttack@CUserMng@@QAEXPAVCMover@@KKHH@Z PROC NEAR ; CUserMng::AddMeleeAttack, COMDAT
; _this$ = ecx

; 4812 : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?AddMeleeAttack@CUserMng@@QAEXPAVCMover@@KKHH@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	b8 1c 40 00 00	 mov	 eax, 16412		; 0000401cH
  00013	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0001a	e8 00 00 00 00	 call	 __chkstk
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00024	33 c4		 xor	 eax, esp
  00026	53		 push	 ebx
  00027	55		 push	 ebp
  00028	8b ac 24 34 40
	00 00		 mov	 ebp, DWORD PTR _pMover$[esp+16428]
  0002f	56		 push	 esi
  00030	57		 push	 edi

; 4813 : 	CAr ar;

  00031	6a 00		 push	 0
  00033	6a 00		 push	 0
  00035	8d 4c 24 1c	 lea	 ecx, DWORD PTR _ar$[esp+16448]
  00039	89 84 24 30 40
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+16448], eax
  00040	e8 00 00 00 00	 call	 ??0CAr@@QAE@PAXI@Z	; CAr::CAr

; 4814 : 	ar << GETID( pMover ) << SNAPSHOTTYPE_MELEE_ATTACK;

  00045	85 ed		 test	 ebp, ebp
  00047	c7 84 24 34 40
	00 00 00 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+16448], 0
  00052	74 08		 je	 SHORT $L319991
  00054	8b b5 bc 01 00
	00		 mov	 esi, DWORD PTR [ebp+444]
  0005a	eb 03		 jmp	 SHORT $L319992
$L319991:
  0005c	83 ce ff	 or	 esi, -1
$L319992:
  0005f	bf 04 00 00 00	 mov	 edi, 4
  00064	57		 push	 edi
  00065	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  00069	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0006e	8b 44 24 1c	 mov	 eax, DWORD PTR _ar$[esp+16448]
  00072	89 30		 mov	 DWORD PTR [eax], esi
  00074	8b 74 24 1c	 mov	 esi, DWORD PTR _ar$[esp+16448]
  00078	03 f7		 add	 esi, edi
  0007a	6a 02		 push	 2
  0007c	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  00080	89 74 24 20	 mov	 DWORD PTR _ar$[esp+16452], esi
  00084	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00089	8b 4c 24 1c	 mov	 ecx, DWORD PTR _ar$[esp+16448]
  0008d	66 c7 01 e0 00	 mov	 WORD PTR [ecx], 224	; 000000e0H
  00092	83 44 24 1c 02	 add	 DWORD PTR _ar$[esp+16448], 2

; 4815 : 	ar << dwAtkMsg << objid << nParam2 << nParam3;

  00097	57		 push	 edi
  00098	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  0009c	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000a1	8b 54 24 1c	 mov	 edx, DWORD PTR _ar$[esp+16448]
  000a5	8b 84 24 40 40
	00 00		 mov	 eax, DWORD PTR _dwAtkMsg$[esp+16436]
  000ac	89 02		 mov	 DWORD PTR [edx], eax
  000ae	8b 5c 24 1c	 mov	 ebx, DWORD PTR _ar$[esp+16448]
  000b2	03 df		 add	 ebx, edi
  000b4	57		 push	 edi
  000b5	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  000b9	89 5c 24 20	 mov	 DWORD PTR _ar$[esp+16452], ebx
  000bd	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000c2	8b 4c 24 1c	 mov	 ecx, DWORD PTR _ar$[esp+16448]
  000c6	8b 94 24 44 40
	00 00		 mov	 edx, DWORD PTR _objid$[esp+16436]
  000cd	89 11		 mov	 DWORD PTR [ecx], edx
  000cf	8b 54 24 1c	 mov	 edx, DWORD PTR _ar$[esp+16448]
  000d3	03 d7		 add	 edx, edi
  000d5	57		 push	 edi
  000d6	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  000da	89 54 24 20	 mov	 DWORD PTR _ar$[esp+16452], edx
  000de	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000e3	8b 44 24 1c	 mov	 eax, DWORD PTR _ar$[esp+16448]
  000e7	8b 8c 24 48 40
	00 00		 mov	 ecx, DWORD PTR _nParam2$[esp+16436]
  000ee	89 08		 mov	 DWORD PTR [eax], ecx
  000f0	8b 44 24 1c	 mov	 eax, DWORD PTR _ar$[esp+16448]
  000f4	03 c7		 add	 eax, edi
  000f6	57		 push	 edi
  000f7	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  000fb	89 44 24 20	 mov	 DWORD PTR _ar$[esp+16452], eax
  000ff	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00104	8b 54 24 1c	 mov	 edx, DWORD PTR _ar$[esp+16448]
  00108	8b 84 24 4c 40
	00 00		 mov	 eax, DWORD PTR _nParam3$[esp+16436]
  0010f	89 02		 mov	 DWORD PTR [edx], eax
  00111	8b 74 24 1c	 mov	 esi, DWORD PTR _ar$[esp+16448]

; 4816 : 	
; 4817 : 	GETBLOCK( ar, lpBuf, nBufSize );

  00115	8d 4c 24 10	 lea	 ecx, DWORD PTR _nBufSize$[esp+16440]
  00119	51		 push	 ecx
  0011a	03 f7		 add	 esi, edi
  0011c	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  00120	89 74 24 20	 mov	 DWORD PTR _ar$[esp+16452], esi
  00124	e8 00 00 00 00	 call	 ?GetBuffer@CAr@@QAEPAEPAH@Z ; CAr::GetBuffer

; 4818 : 
; 4819 : 	FOR_VISIBILITYRANGE( pMover )

  00129	8b bd 10 02 00
	00		 mov	 edi, DWORD PTR [ebp+528]
  0012f	8b 37		 mov	 esi, DWORD PTR [edi]
  00131	3b f7		 cmp	 esi, edi
  00133	8b d8		 mov	 ebx, eax
  00135	74 70		 je	 SHORT $L281132
$L281131:

; 4820 : 		if( USERPTR != pMover )

  00137	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0013a	3b c5		 cmp	 eax, ebp
  0013c	74 1e		 je	 SHORT $L320132

; 4821 : 			USERPTR->AddBlock( lpBuf, nBufSize );

  0013e	f6 40 04 01	 test	 BYTE PTR [eax+4], 1
  00142	8b 4c 24 10	 mov	 ecx, DWORD PTR _nBufSize$[esp+16440]
  00146	75 14		 jne	 SHORT $L320132
  00148	66 ff 80 0c 57
	00 00		 inc	 WORD PTR [eax+22284]
  0014f	51		 push	 ecx
  00150	53		 push	 ebx
  00151	8d 88 f8 16 00
	00		 lea	 ecx, DWORD PTR [eax+5880]
  00157	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
$L320132:

; 4822 : 	NEXT_VISIBILITYRANGE( pMover )

  0015c	8a 46 15	 mov	 al, BYTE PTR [esi+21]
  0015f	84 c0		 test	 al, al
  00161	75 40		 jne	 SHORT $L320260
  00163	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00166	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00169	84 c9		 test	 cl, cl
  0016b	75 18		 jne	 SHORT $L320294
  0016d	8b f0		 mov	 esi, eax
  0016f	8b 06		 mov	 eax, DWORD PTR [esi]
  00171	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00174	84 c9		 test	 cl, cl
  00176	75 2b		 jne	 SHORT $L320260
$L320274:
  00178	8b f0		 mov	 esi, eax
  0017a	8b 06		 mov	 eax, DWORD PTR [esi]
  0017c	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  0017f	84 c9		 test	 cl, cl
  00181	74 f5		 je	 SHORT $L320274
  00183	eb 1e		 jmp	 SHORT $L320260
$L320294:
  00185	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00188	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  0018b	84 c9		 test	 cl, cl
  0018d	75 12		 jne	 SHORT $L320263
  0018f	90		 npad	 1
$L320262:
  00190	3b 70 08	 cmp	 esi, DWORD PTR [eax+8]
  00193	75 0c		 jne	 SHORT $L320263
  00195	8b f0		 mov	 esi, eax
  00197	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0019a	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  0019d	84 c9		 test	 cl, cl
  0019f	74 ef		 je	 SHORT $L320262
$L320263:
  001a1	8b f0		 mov	 esi, eax
$L320260:

; 4818 : 
; 4819 : 	FOR_VISIBILITYRANGE( pMover )

  001a3	3b f7		 cmp	 esi, edi
  001a5	75 90		 jne	 SHORT $L281131
$L281132:

; 4823 : }

  001a7	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  001ab	c7 84 24 34 40
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+16448], -1
  001b6	e8 00 00 00 00	 call	 ??1CAr@@QAE@XZ		; CAr::~CAr
  001bb	8b 8c 24 2c 40
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+16440]
  001c2	5f		 pop	 edi
  001c3	5e		 pop	 esi
  001c4	5d		 pop	 ebp
  001c5	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  001cc	8b 8c 24 1c 40
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+16428]
  001d3	5b		 pop	 ebx
  001d4	33 cc		 xor	 ecx, esp
  001d6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001db	81 c4 28 40 00
	00		 add	 esp, 16424		; 00004028H
  001e1	c2 14 00	 ret	 20			; 00000014H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L319993:
  00000	8d 8d dc bf ff
	ff		 lea	 ecx, DWORD PTR _ar$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CAr@@QAE@XZ		; CAr::~CAr
__ehhandler$?AddMeleeAttack@CUserMng@@QAEXPAVCMover@@KKHH@Z:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T320291
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?AddMeleeAttack@CUserMng@@QAEXPAVCMover@@KKHH@Z ENDP	; CUserMng::AddMeleeAttack
PUBLIC	?AddMeleeAttack2@CUserMng@@QAEXPAVCMover@@KKHH@Z ; CUserMng::AddMeleeAttack2
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
xdata$x	SEGMENT
$T320614 DD	0ffffffffH
	DD	FLAT:$L320308
$T320606 DD	019930520H
	DD	01H
	DD	FLAT:$T320614
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
xdata$x	ENDS
;	COMDAT ?AddMeleeAttack2@CUserMng@@QAEXPAVCMover@@KKHH@Z
_TEXT	SEGMENT
_nBufSize$ = -16424					; size = 4
_ar$ = -16420						; size = 16404
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_pMover$ = 8						; size = 4
_dwAtkMsg$ = 12						; size = 4
_objid$ = 16						; size = 4
_nParam2$ = 20						; size = 4
_nParam3$ = 24						; size = 4
?AddMeleeAttack2@CUserMng@@QAEXPAVCMover@@KKHH@Z PROC NEAR ; CUserMng::AddMeleeAttack2, COMDAT
; _this$ = ecx

; 4826 : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?AddMeleeAttack2@CUserMng@@QAEXPAVCMover@@KKHH@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	b8 1c 40 00 00	 mov	 eax, 16412		; 0000401cH
  00013	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0001a	e8 00 00 00 00	 call	 __chkstk
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00024	33 c4		 xor	 eax, esp
  00026	53		 push	 ebx
  00027	55		 push	 ebp
  00028	8b ac 24 34 40
	00 00		 mov	 ebp, DWORD PTR _pMover$[esp+16428]
  0002f	56		 push	 esi
  00030	57		 push	 edi

; 4827 : 	CAr ar;

  00031	6a 00		 push	 0
  00033	6a 00		 push	 0
  00035	8d 4c 24 1c	 lea	 ecx, DWORD PTR _ar$[esp+16448]
  00039	89 84 24 30 40
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+16448], eax
  00040	e8 00 00 00 00	 call	 ??0CAr@@QAE@PAXI@Z	; CAr::CAr

; 4828 : 	ar << GETID( pMover ) << SNAPSHOTTYPE_MELEE_ATTACK2;

  00045	85 ed		 test	 ebp, ebp
  00047	c7 84 24 34 40
	00 00 00 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+16448], 0
  00052	74 08		 je	 SHORT $L320306
  00054	8b b5 bc 01 00
	00		 mov	 esi, DWORD PTR [ebp+444]
  0005a	eb 03		 jmp	 SHORT $L320307
$L320306:
  0005c	83 ce ff	 or	 esi, -1
$L320307:
  0005f	bf 04 00 00 00	 mov	 edi, 4
  00064	57		 push	 edi
  00065	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  00069	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0006e	8b 44 24 1c	 mov	 eax, DWORD PTR _ar$[esp+16448]
  00072	89 30		 mov	 DWORD PTR [eax], esi
  00074	8b 74 24 1c	 mov	 esi, DWORD PTR _ar$[esp+16448]
  00078	03 f7		 add	 esi, edi
  0007a	6a 02		 push	 2
  0007c	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  00080	89 74 24 20	 mov	 DWORD PTR _ar$[esp+16452], esi
  00084	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00089	8b 4c 24 1c	 mov	 ecx, DWORD PTR _ar$[esp+16448]
  0008d	66 c7 01 e4 00	 mov	 WORD PTR [ecx], 228	; 000000e4H
  00092	83 44 24 1c 02	 add	 DWORD PTR _ar$[esp+16448], 2

; 4829 : 	ar << dwAtkMsg << objid << nParam2 << nParam3;

  00097	57		 push	 edi
  00098	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  0009c	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000a1	8b 54 24 1c	 mov	 edx, DWORD PTR _ar$[esp+16448]
  000a5	8b 84 24 40 40
	00 00		 mov	 eax, DWORD PTR _dwAtkMsg$[esp+16436]
  000ac	89 02		 mov	 DWORD PTR [edx], eax
  000ae	8b 5c 24 1c	 mov	 ebx, DWORD PTR _ar$[esp+16448]
  000b2	03 df		 add	 ebx, edi
  000b4	57		 push	 edi
  000b5	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  000b9	89 5c 24 20	 mov	 DWORD PTR _ar$[esp+16452], ebx
  000bd	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000c2	8b 4c 24 1c	 mov	 ecx, DWORD PTR _ar$[esp+16448]
  000c6	8b 94 24 44 40
	00 00		 mov	 edx, DWORD PTR _objid$[esp+16436]
  000cd	89 11		 mov	 DWORD PTR [ecx], edx
  000cf	8b 54 24 1c	 mov	 edx, DWORD PTR _ar$[esp+16448]
  000d3	03 d7		 add	 edx, edi
  000d5	57		 push	 edi
  000d6	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  000da	89 54 24 20	 mov	 DWORD PTR _ar$[esp+16452], edx
  000de	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000e3	8b 44 24 1c	 mov	 eax, DWORD PTR _ar$[esp+16448]
  000e7	8b 8c 24 48 40
	00 00		 mov	 ecx, DWORD PTR _nParam2$[esp+16436]
  000ee	89 08		 mov	 DWORD PTR [eax], ecx
  000f0	8b 44 24 1c	 mov	 eax, DWORD PTR _ar$[esp+16448]
  000f4	03 c7		 add	 eax, edi
  000f6	57		 push	 edi
  000f7	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  000fb	89 44 24 20	 mov	 DWORD PTR _ar$[esp+16452], eax
  000ff	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00104	8b 54 24 1c	 mov	 edx, DWORD PTR _ar$[esp+16448]
  00108	8b 84 24 4c 40
	00 00		 mov	 eax, DWORD PTR _nParam3$[esp+16436]
  0010f	89 02		 mov	 DWORD PTR [edx], eax
  00111	8b 74 24 1c	 mov	 esi, DWORD PTR _ar$[esp+16448]

; 4830 : 	
; 4831 : 	GETBLOCK( ar, lpBuf, nBufSize );

  00115	8d 4c 24 10	 lea	 ecx, DWORD PTR _nBufSize$[esp+16440]
  00119	51		 push	 ecx
  0011a	03 f7		 add	 esi, edi
  0011c	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  00120	89 74 24 20	 mov	 DWORD PTR _ar$[esp+16452], esi
  00124	e8 00 00 00 00	 call	 ?GetBuffer@CAr@@QAEPAEPAH@Z ; CAr::GetBuffer

; 4832 : 	
; 4833 : 	FOR_VISIBILITYRANGE( pMover )

  00129	8b bd 10 02 00
	00		 mov	 edi, DWORD PTR [ebp+528]
  0012f	8b 37		 mov	 esi, DWORD PTR [edi]
  00131	3b f7		 cmp	 esi, edi
  00133	8b d8		 mov	 ebx, eax
  00135	74 70		 je	 SHORT $L281162
$L281161:

; 4834 : 		if( USERPTR != pMover )

  00137	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0013a	3b c5		 cmp	 eax, ebp
  0013c	74 1e		 je	 SHORT $L320447

; 4835 : 			USERPTR->AddBlock( lpBuf, nBufSize );

  0013e	f6 40 04 01	 test	 BYTE PTR [eax+4], 1
  00142	8b 4c 24 10	 mov	 ecx, DWORD PTR _nBufSize$[esp+16440]
  00146	75 14		 jne	 SHORT $L320447
  00148	66 ff 80 0c 57
	00 00		 inc	 WORD PTR [eax+22284]
  0014f	51		 push	 ecx
  00150	53		 push	 ebx
  00151	8d 88 f8 16 00
	00		 lea	 ecx, DWORD PTR [eax+5880]
  00157	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
$L320447:

; 4836 : 		NEXT_VISIBILITYRANGE( pMover )

  0015c	8a 46 15	 mov	 al, BYTE PTR [esi+21]
  0015f	84 c0		 test	 al, al
  00161	75 40		 jne	 SHORT $L320593
  00163	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00166	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00169	84 c9		 test	 cl, cl
  0016b	75 18		 jne	 SHORT $L320609
  0016d	8b f0		 mov	 esi, eax
  0016f	8b 06		 mov	 eax, DWORD PTR [esi]
  00171	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00174	84 c9		 test	 cl, cl
  00176	75 2b		 jne	 SHORT $L320593
$L320572:
  00178	8b f0		 mov	 esi, eax
  0017a	8b 06		 mov	 eax, DWORD PTR [esi]
  0017c	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  0017f	84 c9		 test	 cl, cl
  00181	74 f5		 je	 SHORT $L320572
  00183	eb 1e		 jmp	 SHORT $L320593
$L320609:
  00185	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00188	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  0018b	84 c9		 test	 cl, cl
  0018d	75 12		 jne	 SHORT $L320596
  0018f	90		 npad	 1
$L320595:
  00190	3b 70 08	 cmp	 esi, DWORD PTR [eax+8]
  00193	75 0c		 jne	 SHORT $L320596
  00195	8b f0		 mov	 esi, eax
  00197	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0019a	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  0019d	84 c9		 test	 cl, cl
  0019f	74 ef		 je	 SHORT $L320595
$L320596:
  001a1	8b f0		 mov	 esi, eax
$L320593:

; 4832 : 	
; 4833 : 	FOR_VISIBILITYRANGE( pMover )

  001a3	3b f7		 cmp	 esi, edi
  001a5	75 90		 jne	 SHORT $L281161
$L281162:

; 4837 : }

  001a7	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  001ab	c7 84 24 34 40
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+16448], -1
  001b6	e8 00 00 00 00	 call	 ??1CAr@@QAE@XZ		; CAr::~CAr
  001bb	8b 8c 24 2c 40
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+16440]
  001c2	5f		 pop	 edi
  001c3	5e		 pop	 esi
  001c4	5d		 pop	 ebp
  001c5	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  001cc	8b 8c 24 1c 40
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+16428]
  001d3	5b		 pop	 ebx
  001d4	33 cc		 xor	 ecx, esp
  001d6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001db	81 c4 28 40 00
	00		 add	 esp, 16424		; 00004028H
  001e1	c2 14 00	 ret	 20			; 00000014H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L320308:
  00000	8d 8d dc bf ff
	ff		 lea	 ecx, DWORD PTR _ar$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CAr@@QAE@XZ		; CAr::~CAr
__ehhandler$?AddMeleeAttack2@CUserMng@@QAEXPAVCMover@@KKHH@Z:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T320606
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?AddMeleeAttack2@CUserMng@@QAEXPAVCMover@@KKHH@Z ENDP	; CUserMng::AddMeleeAttack2
PUBLIC	?AddMagicAttack@CUserMng@@QAEXPAVCMover@@KKHHHH@Z ; CUserMng::AddMagicAttack
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
xdata$x	SEGMENT
$T320945 DD	0ffffffffH
	DD	FLAT:$L320623
$T320937 DD	019930520H
	DD	01H
	DD	FLAT:$T320945
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
xdata$x	ENDS
;	COMDAT ?AddMagicAttack@CUserMng@@QAEXPAVCMover@@KKHHHH@Z
_TEXT	SEGMENT
_nBufSize$ = -16424					; size = 4
_ar$ = -16420						; size = 16404
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_pMover$ = 8						; size = 4
_dwAtkMsg$ = 12						; size = 4
_objid$ = 16						; size = 4
_nParam2$ = 20						; size = 4
_nParam3$ = 24						; size = 4
_nMagicPower$ = 28					; size = 4
_idSfxHit$ = 32						; size = 4
?AddMagicAttack@CUserMng@@QAEXPAVCMover@@KKHHHH@Z PROC NEAR ; CUserMng::AddMagicAttack, COMDAT
; _this$ = ecx

; 4840 : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?AddMagicAttack@CUserMng@@QAEXPAVCMover@@KKHHHH@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	b8 1c 40 00 00	 mov	 eax, 16412		; 0000401cH
  00013	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0001a	e8 00 00 00 00	 call	 __chkstk
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00024	33 c4		 xor	 eax, esp
  00026	53		 push	 ebx
  00027	55		 push	 ebp
  00028	8b ac 24 34 40
	00 00		 mov	 ebp, DWORD PTR _pMover$[esp+16428]
  0002f	56		 push	 esi
  00030	57		 push	 edi

; 4841 : 	CAr ar;

  00031	6a 00		 push	 0
  00033	6a 00		 push	 0
  00035	8d 4c 24 1c	 lea	 ecx, DWORD PTR _ar$[esp+16448]
  00039	89 84 24 30 40
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+16448], eax
  00040	e8 00 00 00 00	 call	 ??0CAr@@QAE@PAXI@Z	; CAr::CAr

; 4842 : 	ar << GETID( pMover ) << SNAPSHOTTYPE_MAGIC_ATTACK;

  00045	85 ed		 test	 ebp, ebp
  00047	c7 84 24 34 40
	00 00 00 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+16448], 0
  00052	74 08		 je	 SHORT $L320621
  00054	8b b5 bc 01 00
	00		 mov	 esi, DWORD PTR [ebp+444]
  0005a	eb 03		 jmp	 SHORT $L320622
$L320621:
  0005c	83 ce ff	 or	 esi, -1
$L320622:
  0005f	bf 04 00 00 00	 mov	 edi, 4
  00064	57		 push	 edi
  00065	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  00069	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0006e	8b 44 24 1c	 mov	 eax, DWORD PTR _ar$[esp+16448]
  00072	89 30		 mov	 DWORD PTR [eax], esi
  00074	01 7c 24 1c	 add	 DWORD PTR _ar$[esp+16448], edi
  00078	6a 02		 push	 2
  0007a	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  0007e	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00083	8b 4c 24 1c	 mov	 ecx, DWORD PTR _ar$[esp+16448]
  00087	66 c7 01 e1 00	 mov	 WORD PTR [ecx], 225	; 000000e1H
  0008c	8b 5c 24 1c	 mov	 ebx, DWORD PTR _ar$[esp+16448]
  00090	83 c3 02	 add	 ebx, 2

; 4843 : 	ar << dwAtkMsg << objid << nParam2 << nParam3 << nMagicPower << idSfxHit;

  00093	57		 push	 edi
  00094	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  00098	89 5c 24 20	 mov	 DWORD PTR _ar$[esp+16452], ebx
  0009c	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000a1	8b 54 24 1c	 mov	 edx, DWORD PTR _ar$[esp+16448]
  000a5	8b 84 24 40 40
	00 00		 mov	 eax, DWORD PTR _dwAtkMsg$[esp+16436]
  000ac	89 02		 mov	 DWORD PTR [edx], eax
  000ae	8b 54 24 1c	 mov	 edx, DWORD PTR _ar$[esp+16448]
  000b2	03 d7		 add	 edx, edi
  000b4	57		 push	 edi
  000b5	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  000b9	89 54 24 20	 mov	 DWORD PTR _ar$[esp+16452], edx
  000bd	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000c2	8b 4c 24 1c	 mov	 ecx, DWORD PTR _ar$[esp+16448]
  000c6	8b 94 24 44 40
	00 00		 mov	 edx, DWORD PTR _objid$[esp+16436]
  000cd	89 11		 mov	 DWORD PTR [ecx], edx
  000cf	8b 44 24 1c	 mov	 eax, DWORD PTR _ar$[esp+16448]
  000d3	03 c7		 add	 eax, edi
  000d5	57		 push	 edi
  000d6	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  000da	89 44 24 20	 mov	 DWORD PTR _ar$[esp+16452], eax
  000de	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000e3	8b 44 24 1c	 mov	 eax, DWORD PTR _ar$[esp+16448]
  000e7	8b 8c 24 48 40
	00 00		 mov	 ecx, DWORD PTR _nParam2$[esp+16436]
  000ee	89 08		 mov	 DWORD PTR [eax], ecx
  000f0	8b 74 24 1c	 mov	 esi, DWORD PTR _ar$[esp+16448]
  000f4	03 f7		 add	 esi, edi
  000f6	57		 push	 edi
  000f7	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  000fb	89 74 24 20	 mov	 DWORD PTR _ar$[esp+16452], esi
  000ff	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00104	8b 54 24 1c	 mov	 edx, DWORD PTR _ar$[esp+16448]
  00108	8b 84 24 4c 40
	00 00		 mov	 eax, DWORD PTR _nParam3$[esp+16436]
  0010f	89 02		 mov	 DWORD PTR [edx], eax
  00111	01 7c 24 1c	 add	 DWORD PTR _ar$[esp+16448], edi
  00115	57		 push	 edi
  00116	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  0011a	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0011f	8b 4c 24 1c	 mov	 ecx, DWORD PTR _ar$[esp+16448]
  00123	8b 94 24 50 40
	00 00		 mov	 edx, DWORD PTR _nMagicPower$[esp+16436]
  0012a	89 11		 mov	 DWORD PTR [ecx], edx
  0012c	8b 5c 24 1c	 mov	 ebx, DWORD PTR _ar$[esp+16448]
  00130	03 df		 add	 ebx, edi
  00132	57		 push	 edi
  00133	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  00137	89 5c 24 20	 mov	 DWORD PTR _ar$[esp+16452], ebx
  0013b	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00140	8b 44 24 1c	 mov	 eax, DWORD PTR _ar$[esp+16448]
  00144	8b 8c 24 54 40
	00 00		 mov	 ecx, DWORD PTR _idSfxHit$[esp+16436]
  0014b	89 08		 mov	 DWORD PTR [eax], ecx
  0014d	01 7c 24 1c	 add	 DWORD PTR _ar$[esp+16448], edi

; 4844 : 
; 4845 : 	GETBLOCK( ar, lpBuf, nBufSize );

  00151	8d 54 24 10	 lea	 edx, DWORD PTR _nBufSize$[esp+16440]
  00155	52		 push	 edx
  00156	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  0015a	e8 00 00 00 00	 call	 ?GetBuffer@CAr@@QAEPAEPAH@Z ; CAr::GetBuffer

; 4846 : 
; 4847 : 	FOR_VISIBILITYRANGE( pMover )

  0015f	8b bd 10 02 00
	00		 mov	 edi, DWORD PTR [ebp+528]
  00165	8b 37		 mov	 esi, DWORD PTR [edi]
  00167	3b f7		 cmp	 esi, edi
  00169	8b d8		 mov	 ebx, eax
  0016b	74 72		 je	 SHORT $L281194
  0016d	8d 49 00	 npad	 3
$L281193:

; 4848 : 		if( USERPTR != pMover )

  00170	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00173	3b c5		 cmp	 eax, ebp
  00175	74 1e		 je	 SHORT $L320781

; 4849 : 			USERPTR->AddBlock( lpBuf, nBufSize );

  00177	f6 40 04 01	 test	 BYTE PTR [eax+4], 1
  0017b	8b 4c 24 10	 mov	 ecx, DWORD PTR _nBufSize$[esp+16440]
  0017f	75 14		 jne	 SHORT $L320781
  00181	66 ff 80 0c 57
	00 00		 inc	 WORD PTR [eax+22284]
  00188	51		 push	 ecx
  00189	53		 push	 ebx
  0018a	8d 88 f8 16 00
	00		 lea	 ecx, DWORD PTR [eax+5880]
  00190	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
$L320781:

; 4850 : 	NEXT_VISIBILITYRANGE( pMover )

  00195	8a 46 15	 mov	 al, BYTE PTR [esi+21]
  00198	84 c0		 test	 al, al
  0019a	75 3f		 jne	 SHORT $L320929
  0019c	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0019f	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  001a2	84 c9		 test	 cl, cl
  001a4	75 18		 jne	 SHORT $L320940
  001a6	8b f0		 mov	 esi, eax
  001a8	8b 06		 mov	 eax, DWORD PTR [esi]
  001aa	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  001ad	84 c9		 test	 cl, cl
  001af	75 2a		 jne	 SHORT $L320929
$L320917:
  001b1	8b f0		 mov	 esi, eax
  001b3	8b 06		 mov	 eax, DWORD PTR [esi]
  001b5	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  001b8	84 c9		 test	 cl, cl
  001ba	74 f5		 je	 SHORT $L320917
  001bc	eb 1d		 jmp	 SHORT $L320929
$L320940:
  001be	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  001c1	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  001c4	84 c9		 test	 cl, cl
  001c6	75 11		 jne	 SHORT $L320932
$L320931:
  001c8	3b 70 08	 cmp	 esi, DWORD PTR [eax+8]
  001cb	75 0c		 jne	 SHORT $L320932
  001cd	8b f0		 mov	 esi, eax
  001cf	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001d2	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  001d5	84 c9		 test	 cl, cl
  001d7	74 ef		 je	 SHORT $L320931
$L320932:
  001d9	8b f0		 mov	 esi, eax
$L320929:

; 4846 : 
; 4847 : 	FOR_VISIBILITYRANGE( pMover )

  001db	3b f7		 cmp	 esi, edi
  001dd	75 91		 jne	 SHORT $L281193
$L281194:

; 4851 : }

  001df	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  001e3	c7 84 24 34 40
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+16448], -1
  001ee	e8 00 00 00 00	 call	 ??1CAr@@QAE@XZ		; CAr::~CAr
  001f3	8b 8c 24 2c 40
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+16440]
  001fa	5f		 pop	 edi
  001fb	5e		 pop	 esi
  001fc	5d		 pop	 ebp
  001fd	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00204	8b 8c 24 1c 40
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+16428]
  0020b	5b		 pop	 ebx
  0020c	33 cc		 xor	 ecx, esp
  0020e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00213	81 c4 28 40 00
	00		 add	 esp, 16424		; 00004028H
  00219	c2 1c 00	 ret	 28			; 0000001cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L320623:
  00000	8d 8d dc bf ff
	ff		 lea	 ecx, DWORD PTR _ar$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CAr@@QAE@XZ		; CAr::~CAr
__ehhandler$?AddMagicAttack@CUserMng@@QAEXPAVCMover@@KKHHHH@Z:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T320937
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?AddMagicAttack@CUserMng@@QAEXPAVCMover@@KKHHHH@Z ENDP	; CUserMng::AddMagicAttack
PUBLIC	?AddRangeAttack@CUserMng@@QAEXPAVCMover@@KKHHH@Z ; CUserMng::AddRangeAttack
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
xdata$x	SEGMENT
$T321268 DD	0ffffffffH
	DD	FLAT:$L320954
$T321260 DD	019930520H
	DD	01H
	DD	FLAT:$T321268
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
xdata$x	ENDS
;	COMDAT ?AddRangeAttack@CUserMng@@QAEXPAVCMover@@KKHHH@Z
_TEXT	SEGMENT
_nBufSize$ = -16424					; size = 4
_ar$ = -16420						; size = 16404
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_pMover$ = 8						; size = 4
_dwAtkMsg$ = 12						; size = 4
_objid$ = 16						; size = 4
_nParam2$ = 20						; size = 4
_nParam3$ = 24						; size = 4
_idSfxHit$ = 28						; size = 4
?AddRangeAttack@CUserMng@@QAEXPAVCMover@@KKHHH@Z PROC NEAR ; CUserMng::AddRangeAttack, COMDAT
; _this$ = ecx

; 4854 : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?AddRangeAttack@CUserMng@@QAEXPAVCMover@@KKHHH@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	b8 1c 40 00 00	 mov	 eax, 16412		; 0000401cH
  00013	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0001a	e8 00 00 00 00	 call	 __chkstk
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00024	33 c4		 xor	 eax, esp
  00026	53		 push	 ebx
  00027	55		 push	 ebp
  00028	8b ac 24 34 40
	00 00		 mov	 ebp, DWORD PTR _pMover$[esp+16428]
  0002f	56		 push	 esi
  00030	57		 push	 edi

; 4855 : 	CAr ar;

  00031	6a 00		 push	 0
  00033	6a 00		 push	 0
  00035	8d 4c 24 1c	 lea	 ecx, DWORD PTR _ar$[esp+16448]
  00039	89 84 24 30 40
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+16448], eax
  00040	e8 00 00 00 00	 call	 ??0CAr@@QAE@PAXI@Z	; CAr::CAr

; 4856 : 	ar << GETID( pMover ) << SNAPSHOTTYPE_RANGE_ATTACK;

  00045	85 ed		 test	 ebp, ebp
  00047	c7 84 24 34 40
	00 00 00 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+16448], 0
  00052	74 08		 je	 SHORT $L320952
  00054	8b b5 bc 01 00
	00		 mov	 esi, DWORD PTR [ebp+444]
  0005a	eb 03		 jmp	 SHORT $L320953
$L320952:
  0005c	83 ce ff	 or	 esi, -1
$L320953:
  0005f	bf 04 00 00 00	 mov	 edi, 4
  00064	57		 push	 edi
  00065	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  00069	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0006e	8b 44 24 1c	 mov	 eax, DWORD PTR _ar$[esp+16448]
  00072	89 30		 mov	 DWORD PTR [eax], esi
  00074	8b 5c 24 1c	 mov	 ebx, DWORD PTR _ar$[esp+16448]
  00078	03 df		 add	 ebx, edi
  0007a	6a 02		 push	 2
  0007c	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  00080	89 5c 24 20	 mov	 DWORD PTR _ar$[esp+16452], ebx
  00084	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00089	8b 4c 24 1c	 mov	 ecx, DWORD PTR _ar$[esp+16448]
  0008d	66 c7 01 e2 00	 mov	 WORD PTR [ecx], 226	; 000000e2H
  00092	8b 54 24 1c	 mov	 edx, DWORD PTR _ar$[esp+16448]
  00096	83 c2 02	 add	 edx, 2

; 4857 : 	ar << dwAtkMsg << objid << nParam2 << nParam3 << idSfxHit;

  00099	57		 push	 edi
  0009a	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  0009e	89 54 24 20	 mov	 DWORD PTR _ar$[esp+16452], edx
  000a2	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000a7	8b 54 24 1c	 mov	 edx, DWORD PTR _ar$[esp+16448]
  000ab	8b 84 24 40 40
	00 00		 mov	 eax, DWORD PTR _dwAtkMsg$[esp+16436]
  000b2	89 02		 mov	 DWORD PTR [edx], eax
  000b4	8b 44 24 1c	 mov	 eax, DWORD PTR _ar$[esp+16448]
  000b8	03 c7		 add	 eax, edi
  000ba	57		 push	 edi
  000bb	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  000bf	89 44 24 20	 mov	 DWORD PTR _ar$[esp+16452], eax
  000c3	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000c8	8b 4c 24 1c	 mov	 ecx, DWORD PTR _ar$[esp+16448]
  000cc	8b 94 24 44 40
	00 00		 mov	 edx, DWORD PTR _objid$[esp+16436]
  000d3	89 11		 mov	 DWORD PTR [ecx], edx
  000d5	8b 74 24 1c	 mov	 esi, DWORD PTR _ar$[esp+16448]
  000d9	03 f7		 add	 esi, edi
  000db	57		 push	 edi
  000dc	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  000e0	89 74 24 20	 mov	 DWORD PTR _ar$[esp+16452], esi
  000e4	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000e9	8b 44 24 1c	 mov	 eax, DWORD PTR _ar$[esp+16448]
  000ed	8b 8c 24 48 40
	00 00		 mov	 ecx, DWORD PTR _nParam2$[esp+16436]
  000f4	89 08		 mov	 DWORD PTR [eax], ecx
  000f6	01 7c 24 1c	 add	 DWORD PTR _ar$[esp+16448], edi
  000fa	57		 push	 edi
  000fb	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  000ff	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00104	8b 54 24 1c	 mov	 edx, DWORD PTR _ar$[esp+16448]
  00108	8b 84 24 4c 40
	00 00		 mov	 eax, DWORD PTR _nParam3$[esp+16436]
  0010f	89 02		 mov	 DWORD PTR [edx], eax
  00111	8b 5c 24 1c	 mov	 ebx, DWORD PTR _ar$[esp+16448]
  00115	03 df		 add	 ebx, edi
  00117	57		 push	 edi
  00118	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  0011c	89 5c 24 20	 mov	 DWORD PTR _ar$[esp+16452], ebx
  00120	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00125	8b 4c 24 1c	 mov	 ecx, DWORD PTR _ar$[esp+16448]
  00129	8b 94 24 50 40
	00 00		 mov	 edx, DWORD PTR _idSfxHit$[esp+16436]
  00130	89 11		 mov	 DWORD PTR [ecx], edx
  00132	8b 54 24 1c	 mov	 edx, DWORD PTR _ar$[esp+16448]

; 4858 : 	
; 4859 : 	GETBLOCK( ar, lpBuf, nBufSize );

  00136	8d 44 24 10	 lea	 eax, DWORD PTR _nBufSize$[esp+16440]
  0013a	03 d7		 add	 edx, edi
  0013c	50		 push	 eax
  0013d	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  00141	89 54 24 20	 mov	 DWORD PTR _ar$[esp+16452], edx
  00145	e8 00 00 00 00	 call	 ?GetBuffer@CAr@@QAEPAEPAH@Z ; CAr::GetBuffer

; 4860 : 
; 4861 : 	FOR_VISIBILITYRANGE( pMover )

  0014a	8b bd 10 02 00
	00		 mov	 edi, DWORD PTR [ebp+528]
  00150	8b 37		 mov	 esi, DWORD PTR [edi]
  00152	3b f7		 cmp	 esi, edi
  00154	8b d8		 mov	 ebx, eax
  00156	74 76		 je	 SHORT $L281225
$L281224:

; 4862 : 		if( USERPTR != pMover )

  00158	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0015b	3b c5		 cmp	 eax, ebp
  0015d	74 1e		 je	 SHORT $L321101

; 4863 : 			USERPTR->AddBlock( lpBuf, nBufSize );

  0015f	f6 40 04 01	 test	 BYTE PTR [eax+4], 1
  00163	8b 4c 24 10	 mov	 ecx, DWORD PTR _nBufSize$[esp+16440]
  00167	75 14		 jne	 SHORT $L321101
  00169	66 ff 80 0c 57
	00 00		 inc	 WORD PTR [eax+22284]
  00170	51		 push	 ecx
  00171	53		 push	 ebx
  00172	8d 88 f8 16 00
	00		 lea	 ecx, DWORD PTR [eax+5880]
  00178	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
$L321101:

; 4864 : 	NEXT_VISIBILITYRANGE( pMover )

  0017d	8a 46 15	 mov	 al, BYTE PTR [esi+21]
  00180	84 c0		 test	 al, al
  00182	75 46		 jne	 SHORT $L321228
  00184	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00187	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  0018a	84 c9		 test	 cl, cl
  0018c	75 1f		 jne	 SHORT $L321263
  0018e	8b f0		 mov	 esi, eax
  00190	8b 06		 mov	 eax, DWORD PTR [esi]
  00192	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00195	84 c9		 test	 cl, cl
  00197	75 31		 jne	 SHORT $L321228
  00199	8d a4 24 00 00
	00 00		 npad	 7
$L321247:
  001a0	8b f0		 mov	 esi, eax
  001a2	8b 06		 mov	 eax, DWORD PTR [esi]
  001a4	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  001a7	84 c9		 test	 cl, cl
  001a9	74 f5		 je	 SHORT $L321247
  001ab	eb 1d		 jmp	 SHORT $L321228
$L321263:
  001ad	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  001b0	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  001b3	84 c9		 test	 cl, cl
  001b5	75 11		 jne	 SHORT $L321231
$L321230:
  001b7	3b 70 08	 cmp	 esi, DWORD PTR [eax+8]
  001ba	75 0c		 jne	 SHORT $L321231
  001bc	8b f0		 mov	 esi, eax
  001be	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001c1	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  001c4	84 c9		 test	 cl, cl
  001c6	74 ef		 je	 SHORT $L321230
$L321231:
  001c8	8b f0		 mov	 esi, eax
$L321228:

; 4860 : 
; 4861 : 	FOR_VISIBILITYRANGE( pMover )

  001ca	3b f7		 cmp	 esi, edi
  001cc	75 8a		 jne	 SHORT $L281224
$L281225:

; 4865 : }

  001ce	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  001d2	c7 84 24 34 40
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+16448], -1
  001dd	e8 00 00 00 00	 call	 ??1CAr@@QAE@XZ		; CAr::~CAr
  001e2	8b 8c 24 2c 40
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+16440]
  001e9	5f		 pop	 edi
  001ea	5e		 pop	 esi
  001eb	5d		 pop	 ebp
  001ec	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  001f3	8b 8c 24 1c 40
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+16428]
  001fa	5b		 pop	 ebx
  001fb	33 cc		 xor	 ecx, esp
  001fd	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00202	81 c4 28 40 00
	00		 add	 esp, 16424		; 00004028H
  00208	c2 18 00	 ret	 24			; 00000018H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L320954:
  00000	8d 8d dc bf ff
	ff		 lea	 ecx, DWORD PTR _ar$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CAr@@QAE@XZ		; CAr::~CAr
__ehhandler$?AddRangeAttack@CUserMng@@QAEXPAVCMover@@KKHHH@Z:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T321260
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?AddRangeAttack@CUserMng@@QAEXPAVCMover@@KKHHH@Z ENDP	; CUserMng::AddRangeAttack
PUBLIC	?AddAttackSP@CUserMng@@QAEXPAVCMover@@KKHH@Z	; CUserMng::AddAttackSP
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
xdata$x	SEGMENT
$T321583 DD	0ffffffffH
	DD	FLAT:$L321277
$T321575 DD	019930520H
	DD	01H
	DD	FLAT:$T321583
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
xdata$x	ENDS
;	COMDAT ?AddAttackSP@CUserMng@@QAEXPAVCMover@@KKHH@Z
_TEXT	SEGMENT
_nBufSize$ = -16424					; size = 4
_ar$ = -16420						; size = 16404
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_pMover$ = 8						; size = 4
_dwAtkMsg$ = 12						; size = 4
_objid$ = 16						; size = 4
_nParam2$ = 20						; size = 4
_nParam3$ = 24						; size = 4
?AddAttackSP@CUserMng@@QAEXPAVCMover@@KKHH@Z PROC NEAR	; CUserMng::AddAttackSP, COMDAT
; _this$ = ecx

; 4868 : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?AddAttackSP@CUserMng@@QAEXPAVCMover@@KKHH@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	b8 1c 40 00 00	 mov	 eax, 16412		; 0000401cH
  00013	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0001a	e8 00 00 00 00	 call	 __chkstk
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00024	33 c4		 xor	 eax, esp
  00026	53		 push	 ebx
  00027	55		 push	 ebp
  00028	8b ac 24 34 40
	00 00		 mov	 ebp, DWORD PTR _pMover$[esp+16428]
  0002f	56		 push	 esi
  00030	57		 push	 edi

; 4869 : 	CAr ar;

  00031	6a 00		 push	 0
  00033	6a 00		 push	 0
  00035	8d 4c 24 1c	 lea	 ecx, DWORD PTR _ar$[esp+16448]
  00039	89 84 24 30 40
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+16448], eax
  00040	e8 00 00 00 00	 call	 ??0CAr@@QAE@PAXI@Z	; CAr::CAr

; 4870 : 	ar << GETID( pMover ) << SNAPSHOTTYPE_SP_ATTACK;

  00045	85 ed		 test	 ebp, ebp
  00047	c7 84 24 34 40
	00 00 00 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+16448], 0
  00052	74 08		 je	 SHORT $L321275
  00054	8b b5 bc 01 00
	00		 mov	 esi, DWORD PTR [ebp+444]
  0005a	eb 03		 jmp	 SHORT $L321276
$L321275:
  0005c	83 ce ff	 or	 esi, -1
$L321276:
  0005f	bf 04 00 00 00	 mov	 edi, 4
  00064	57		 push	 edi
  00065	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  00069	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0006e	8b 44 24 1c	 mov	 eax, DWORD PTR _ar$[esp+16448]
  00072	89 30		 mov	 DWORD PTR [eax], esi
  00074	8b 74 24 1c	 mov	 esi, DWORD PTR _ar$[esp+16448]
  00078	03 f7		 add	 esi, edi
  0007a	6a 02		 push	 2
  0007c	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  00080	89 74 24 20	 mov	 DWORD PTR _ar$[esp+16452], esi
  00084	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00089	8b 4c 24 1c	 mov	 ecx, DWORD PTR _ar$[esp+16448]
  0008d	66 c7 01 e3 00	 mov	 WORD PTR [ecx], 227	; 000000e3H
  00092	83 44 24 1c 02	 add	 DWORD PTR _ar$[esp+16448], 2

; 4871 : 	ar << dwAtkMsg << objid << nParam2 << nParam3 ;

  00097	57		 push	 edi
  00098	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  0009c	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000a1	8b 54 24 1c	 mov	 edx, DWORD PTR _ar$[esp+16448]
  000a5	8b 84 24 40 40
	00 00		 mov	 eax, DWORD PTR _dwAtkMsg$[esp+16436]
  000ac	89 02		 mov	 DWORD PTR [edx], eax
  000ae	8b 5c 24 1c	 mov	 ebx, DWORD PTR _ar$[esp+16448]
  000b2	03 df		 add	 ebx, edi
  000b4	57		 push	 edi
  000b5	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  000b9	89 5c 24 20	 mov	 DWORD PTR _ar$[esp+16452], ebx
  000bd	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000c2	8b 4c 24 1c	 mov	 ecx, DWORD PTR _ar$[esp+16448]
  000c6	8b 94 24 44 40
	00 00		 mov	 edx, DWORD PTR _objid$[esp+16436]
  000cd	89 11		 mov	 DWORD PTR [ecx], edx
  000cf	8b 54 24 1c	 mov	 edx, DWORD PTR _ar$[esp+16448]
  000d3	03 d7		 add	 edx, edi
  000d5	57		 push	 edi
  000d6	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  000da	89 54 24 20	 mov	 DWORD PTR _ar$[esp+16452], edx
  000de	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000e3	8b 44 24 1c	 mov	 eax, DWORD PTR _ar$[esp+16448]
  000e7	8b 8c 24 48 40
	00 00		 mov	 ecx, DWORD PTR _nParam2$[esp+16436]
  000ee	89 08		 mov	 DWORD PTR [eax], ecx
  000f0	8b 44 24 1c	 mov	 eax, DWORD PTR _ar$[esp+16448]
  000f4	03 c7		 add	 eax, edi
  000f6	57		 push	 edi
  000f7	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  000fb	89 44 24 20	 mov	 DWORD PTR _ar$[esp+16452], eax
  000ff	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00104	8b 54 24 1c	 mov	 edx, DWORD PTR _ar$[esp+16448]
  00108	8b 84 24 4c 40
	00 00		 mov	 eax, DWORD PTR _nParam3$[esp+16436]
  0010f	89 02		 mov	 DWORD PTR [edx], eax
  00111	8b 74 24 1c	 mov	 esi, DWORD PTR _ar$[esp+16448]

; 4872 : 	
; 4873 : 	GETBLOCK( ar, lpBuf, nBufSize );

  00115	8d 4c 24 10	 lea	 ecx, DWORD PTR _nBufSize$[esp+16440]
  00119	51		 push	 ecx
  0011a	03 f7		 add	 esi, edi
  0011c	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  00120	89 74 24 20	 mov	 DWORD PTR _ar$[esp+16452], esi
  00124	e8 00 00 00 00	 call	 ?GetBuffer@CAr@@QAEPAEPAH@Z ; CAr::GetBuffer

; 4874 : 	
; 4875 : 	FOR_VISIBILITYRANGE( pMover )

  00129	8b bd 10 02 00
	00		 mov	 edi, DWORD PTR [ebp+528]
  0012f	8b 37		 mov	 esi, DWORD PTR [edi]
  00131	3b f7		 cmp	 esi, edi
  00133	8b d8		 mov	 ebx, eax
  00135	74 70		 je	 SHORT $L281255
$L281254:

; 4876 : 		if( USERPTR != pMover )

  00137	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0013a	3b c5		 cmp	 eax, ebp
  0013c	74 1e		 je	 SHORT $L321416

; 4877 : 			USERPTR->AddBlock( lpBuf, nBufSize );

  0013e	f6 40 04 01	 test	 BYTE PTR [eax+4], 1
  00142	8b 4c 24 10	 mov	 ecx, DWORD PTR _nBufSize$[esp+16440]
  00146	75 14		 jne	 SHORT $L321416
  00148	66 ff 80 0c 57
	00 00		 inc	 WORD PTR [eax+22284]
  0014f	51		 push	 ecx
  00150	53		 push	 ebx
  00151	8d 88 f8 16 00
	00		 lea	 ecx, DWORD PTR [eax+5880]
  00157	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
$L321416:

; 4878 : 		NEXT_VISIBILITYRANGE( pMover )

  0015c	8a 46 15	 mov	 al, BYTE PTR [esi+21]
  0015f	84 c0		 test	 al, al
  00161	75 40		 jne	 SHORT $L321544
  00163	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00166	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00169	84 c9		 test	 cl, cl
  0016b	75 18		 jne	 SHORT $L321578
  0016d	8b f0		 mov	 esi, eax
  0016f	8b 06		 mov	 eax, DWORD PTR [esi]
  00171	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00174	84 c9		 test	 cl, cl
  00176	75 2b		 jne	 SHORT $L321544
$L321558:
  00178	8b f0		 mov	 esi, eax
  0017a	8b 06		 mov	 eax, DWORD PTR [esi]
  0017c	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  0017f	84 c9		 test	 cl, cl
  00181	74 f5		 je	 SHORT $L321558
  00183	eb 1e		 jmp	 SHORT $L321544
$L321578:
  00185	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00188	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  0018b	84 c9		 test	 cl, cl
  0018d	75 12		 jne	 SHORT $L321547
  0018f	90		 npad	 1
$L321546:
  00190	3b 70 08	 cmp	 esi, DWORD PTR [eax+8]
  00193	75 0c		 jne	 SHORT $L321547
  00195	8b f0		 mov	 esi, eax
  00197	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0019a	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  0019d	84 c9		 test	 cl, cl
  0019f	74 ef		 je	 SHORT $L321546
$L321547:
  001a1	8b f0		 mov	 esi, eax
$L321544:

; 4874 : 	
; 4875 : 	FOR_VISIBILITYRANGE( pMover )

  001a3	3b f7		 cmp	 esi, edi
  001a5	75 90		 jne	 SHORT $L281254
$L281255:

; 4879 : }

  001a7	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  001ab	c7 84 24 34 40
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+16448], -1
  001b6	e8 00 00 00 00	 call	 ??1CAr@@QAE@XZ		; CAr::~CAr
  001bb	8b 8c 24 2c 40
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+16440]
  001c2	5f		 pop	 edi
  001c3	5e		 pop	 esi
  001c4	5d		 pop	 ebp
  001c5	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  001cc	8b 8c 24 1c 40
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+16428]
  001d3	5b		 pop	 ebx
  001d4	33 cc		 xor	 ecx, esp
  001d6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001db	81 c4 28 40 00
	00		 add	 esp, 16424		; 00004028H
  001e1	c2 14 00	 ret	 20			; 00000014H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L321277:
  00000	8d 8d dc bf ff
	ff		 lea	 ecx, DWORD PTR _ar$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CAr@@QAE@XZ		; CAr::~CAr
__ehhandler$?AddAttackSP@CUserMng@@QAEXPAVCMover@@KKHH@Z:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T321575
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?AddAttackSP@CUserMng@@QAEXPAVCMover@@KKHH@Z ENDP	; CUserMng::AddAttackSP
PUBLIC	?AddMoverMoved@CUserMng@@QAEXPAVCMover@@AAUD3DXVECTOR3@@1MKKKHHK_J@Z ; CUserMng::AddMoverMoved
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
xdata$x	SEGMENT
$T321921 DD	0ffffffffH
	DD	FLAT:$L321592
$T321913 DD	019930520H
	DD	01H
	DD	FLAT:$T321921
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
xdata$x	ENDS
;	COMDAT ?AddMoverMoved@CUserMng@@QAEXPAVCMover@@AAUD3DXVECTOR3@@1MKKKHHK_J@Z
_TEXT	SEGMENT
$T321646 = -16448					; size = 8
$T321607 = -16448					; size = 12
_nBufSize$ = -16436					; size = 4
$T321611 = -16432					; size = 12
_ar$ = -16420						; size = 16404
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_pMover$ = 8						; size = 4
_v$ = 12						; size = 4
_vd$ = 16						; size = 4
_f$ = 20						; size = 4
_dwState$ = 24						; size = 4
_dwStateFlag$ = 28					; size = 4
_dwMotion$ = 32						; size = 4
_nMotionEx$ = 36					; size = 4
_nLoop$ = 40						; size = 4
_dwMotionOption$ = 44					; size = 4
_nTickCount$ = 48					; size = 8
?AddMoverMoved@CUserMng@@QAEXPAVCMover@@AAUD3DXVECTOR3@@1MKKKHHK_J@Z PROC NEAR ; CUserMng::AddMoverMoved, COMDAT
; _this$ = ecx

; 4884 : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?AddMoverMoved@CUserMng@@QAEXPAVCMover@@AAUD3DXVECTOR3@@1MKKKHHK_J@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	b8 34 40 00 00	 mov	 eax, 16436		; 00004034H
  00013	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0001a	e8 00 00 00 00	 call	 __chkstk
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00024	33 c4		 xor	 eax, esp
  00026	53		 push	 ebx
  00027	55		 push	 ebp
  00028	8b ac 24 4c 40
	00 00		 mov	 ebp, DWORD PTR _pMover$[esp+16452]
  0002f	56		 push	 esi
  00030	8b b4 24 54 40
	00 00		 mov	 esi, DWORD PTR _v$[esp+16456]
  00037	57		 push	 edi
  00038	8b bc 24 5c 40
	00 00		 mov	 edi, DWORD PTR _vd$[esp+16460]

; 4885 : 	CAr ar;

  0003f	6a 00		 push	 0
  00041	6a 00		 push	 0
  00043	8d 4c 24 34	 lea	 ecx, DWORD PTR _ar$[esp+16472]
  00047	89 84 24 48 40
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+16472], eax
  0004e	e8 00 00 00 00	 call	 ??0CAr@@QAE@PAXI@Z	; CAr::CAr

; 4886 : 	ar << GETID( pMover ) << SNAPSHOTTYPE_MOVERMOVED;

  00053	85 ed		 test	 ebp, ebp
  00055	c7 84 24 4c 40
	00 00 00 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+16472], 0
  00060	74 08		 je	 SHORT $L321590
  00062	8b 9d bc 01 00
	00		 mov	 ebx, DWORD PTR [ebp+444]
  00068	eb 03		 jmp	 SHORT $L321591
$L321590:
  0006a	83 cb ff	 or	 ebx, -1
$L321591:
  0006d	6a 04		 push	 4
  0006f	8d 4c 24 30	 lea	 ecx, DWORD PTR _ar$[esp+16468]
  00073	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00078	8b 44 24 34	 mov	 eax, DWORD PTR _ar$[esp+16472]
  0007c	89 18		 mov	 DWORD PTR [eax], ebx
  0007e	8b 4c 24 34	 mov	 ecx, DWORD PTR _ar$[esp+16472]
  00082	bb 04 00 00 00	 mov	 ebx, 4
  00087	03 cb		 add	 ecx, ebx
  00089	89 4c 24 34	 mov	 DWORD PTR _ar$[esp+16472], ecx
  0008d	6a 02		 push	 2
  0008f	8d 4c 24 30	 lea	 ecx, DWORD PTR _ar$[esp+16468]
  00093	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00098	8b 4c 24 34	 mov	 ecx, DWORD PTR _ar$[esp+16472]
  0009c	66 c7 01 ca 00	 mov	 WORD PTR [ecx], 202	; 000000caH
  000a1	8b 54 24 34	 mov	 edx, DWORD PTR _ar$[esp+16472]

; 4887 : 	ar << v << vd << f;

  000a5	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  000a8	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000ab	83 c2 02	 add	 edx, 2
  000ae	89 54 24 34	 mov	 DWORD PTR _ar$[esp+16472], edx
  000b2	8b 16		 mov	 edx, DWORD PTR [esi]
  000b4	89 54 24 10	 mov	 DWORD PTR $T321607[esp+16464], edx
  000b8	6a 0c		 push	 12			; 0000000cH
  000ba	8d 54 24 14	 lea	 edx, DWORD PTR $T321607[esp+16468]
  000be	89 4c 24 1c	 mov	 DWORD PTR $T321607[esp+16476], ecx
  000c2	52		 push	 edx
  000c3	8d 4c 24 34	 lea	 ecx, DWORD PTR _ar$[esp+16472]
  000c7	89 44 24 1c	 mov	 DWORD PTR $T321607[esp+16476], eax
  000cb	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
  000d0	8b 07		 mov	 eax, DWORD PTR [edi]
  000d2	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  000d5	8b 57 08	 mov	 edx, DWORD PTR [edi+8]
  000d8	89 44 24 20	 mov	 DWORD PTR $T321611[esp+16464], eax
  000dc	6a 0c		 push	 12			; 0000000cH
  000de	8d 44 24 24	 lea	 eax, DWORD PTR $T321611[esp+16468]
  000e2	89 4c 24 28	 mov	 DWORD PTR $T321611[esp+16472], ecx
  000e6	50		 push	 eax
  000e7	8d 4c 24 34	 lea	 ecx, DWORD PTR _ar$[esp+16472]
  000eb	89 54 24 30	 mov	 DWORD PTR $T321611[esp+16480], edx
  000ef	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
  000f4	53		 push	 ebx
  000f5	8d 4c 24 30	 lea	 ecx, DWORD PTR _ar$[esp+16468]
  000f9	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000fe	d9 84 24 60 40
	00 00		 fld	 DWORD PTR _f$[esp+16460]
  00105	8b 4c 24 34	 mov	 ecx, DWORD PTR _ar$[esp+16472]
  00109	d9 19		 fstp	 DWORD PTR [ecx]
  0010b	8b 4c 24 34	 mov	 ecx, DWORD PTR _ar$[esp+16472]
  0010f	03 cb		 add	 ecx, ebx
  00111	89 4c 24 34	 mov	 DWORD PTR _ar$[esp+16472], ecx

; 4888 : 	ar << dwState << dwStateFlag << dwMotion << nMotionEx;

  00115	53		 push	 ebx
  00116	8d 4c 24 30	 lea	 ecx, DWORD PTR _ar$[esp+16468]
  0011a	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0011f	8b 54 24 34	 mov	 edx, DWORD PTR _ar$[esp+16472]
  00123	8b 84 24 64 40
	00 00		 mov	 eax, DWORD PTR _dwState$[esp+16460]
  0012a	89 02		 mov	 DWORD PTR [edx], eax
  0012c	8b 7c 24 34	 mov	 edi, DWORD PTR _ar$[esp+16472]
  00130	03 fb		 add	 edi, ebx
  00132	53		 push	 ebx
  00133	8d 4c 24 30	 lea	 ecx, DWORD PTR _ar$[esp+16468]
  00137	89 7c 24 38	 mov	 DWORD PTR _ar$[esp+16476], edi
  0013b	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00140	8b 4c 24 34	 mov	 ecx, DWORD PTR _ar$[esp+16472]
  00144	8b 94 24 68 40
	00 00		 mov	 edx, DWORD PTR _dwStateFlag$[esp+16460]
  0014b	89 11		 mov	 DWORD PTR [ecx], edx
  0014d	8b 54 24 34	 mov	 edx, DWORD PTR _ar$[esp+16472]
  00151	03 d3		 add	 edx, ebx
  00153	53		 push	 ebx
  00154	8d 4c 24 30	 lea	 ecx, DWORD PTR _ar$[esp+16468]
  00158	89 54 24 38	 mov	 DWORD PTR _ar$[esp+16476], edx
  0015c	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00161	8b 44 24 34	 mov	 eax, DWORD PTR _ar$[esp+16472]
  00165	8b 8c 24 6c 40
	00 00		 mov	 ecx, DWORD PTR _dwMotion$[esp+16460]
  0016c	89 08		 mov	 DWORD PTR [eax], ecx
  0016e	8b 44 24 34	 mov	 eax, DWORD PTR _ar$[esp+16472]
  00172	03 c3		 add	 eax, ebx
  00174	53		 push	 ebx
  00175	8d 4c 24 30	 lea	 ecx, DWORD PTR _ar$[esp+16468]
  00179	89 44 24 38	 mov	 DWORD PTR _ar$[esp+16476], eax
  0017d	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00182	8b 54 24 34	 mov	 edx, DWORD PTR _ar$[esp+16472]
  00186	8b 84 24 70 40
	00 00		 mov	 eax, DWORD PTR _nMotionEx$[esp+16460]
  0018d	89 02		 mov	 DWORD PTR [edx], eax
  0018f	8b 74 24 34	 mov	 esi, DWORD PTR _ar$[esp+16472]
  00193	03 f3		 add	 esi, ebx

; 4889 : 	ar << nLoop << dwMotionOption << nTickCount;

  00195	53		 push	 ebx
  00196	8d 4c 24 30	 lea	 ecx, DWORD PTR _ar$[esp+16468]
  0019a	89 74 24 38	 mov	 DWORD PTR _ar$[esp+16476], esi
  0019e	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  001a3	8b 4c 24 34	 mov	 ecx, DWORD PTR _ar$[esp+16472]
  001a7	8b 94 24 74 40
	00 00		 mov	 edx, DWORD PTR _nLoop$[esp+16460]
  001ae	89 11		 mov	 DWORD PTR [ecx], edx
  001b0	01 5c 24 34	 add	 DWORD PTR _ar$[esp+16472], ebx
  001b4	53		 push	 ebx
  001b5	8d 4c 24 30	 lea	 ecx, DWORD PTR _ar$[esp+16468]
  001b9	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  001be	8b 44 24 34	 mov	 eax, DWORD PTR _ar$[esp+16472]
  001c2	8b 8c 24 78 40
	00 00		 mov	 ecx, DWORD PTR _dwMotionOption$[esp+16460]
  001c9	8b 94 24 7c 40
	00 00		 mov	 edx, DWORD PTR _nTickCount$[esp+16460]
  001d0	89 08		 mov	 DWORD PTR [eax], ecx
  001d2	8b 7c 24 34	 mov	 edi, DWORD PTR _ar$[esp+16472]
  001d6	8b 84 24 80 40
	00 00		 mov	 eax, DWORD PTR _nTickCount$[esp+16464]
  001dd	6a 08		 push	 8
  001df	8d 4c 24 14	 lea	 ecx, DWORD PTR $T321646[esp+16468]
  001e3	51		 push	 ecx
  001e4	03 fb		 add	 edi, ebx
  001e6	8d 4c 24 34	 lea	 ecx, DWORD PTR _ar$[esp+16472]
  001ea	89 7c 24 3c	 mov	 DWORD PTR _ar$[esp+16480], edi
  001ee	89 54 24 18	 mov	 DWORD PTR $T321646[esp+16472], edx
  001f2	89 44 24 1c	 mov	 DWORD PTR $T321646[esp+16476], eax
  001f6	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write

; 4890 : 	
; 4891 : 	GETBLOCK( ar, lpBuf, nBufSize );

  001fb	8d 54 24 1c	 lea	 edx, DWORD PTR _nBufSize$[esp+16464]
  001ff	52		 push	 edx
  00200	8d 4c 24 30	 lea	 ecx, DWORD PTR _ar$[esp+16468]
  00204	e8 00 00 00 00	 call	 ?GetBuffer@CAr@@QAEPAEPAH@Z ; CAr::GetBuffer

; 4892 : 
; 4893 : 	FOR_VISIBILITYRANGE( pMover )

  00209	8b bd 10 02 00
	00		 mov	 edi, DWORD PTR [ebp+528]
  0020f	8b 37		 mov	 esi, DWORD PTR [edi]
  00211	3b f7		 cmp	 esi, edi
  00213	8b d8		 mov	 ebx, eax
  00215	74 70		 je	 SHORT $L281291
$L281290:

; 4894 : 		if( USERPTR != pMover )

  00217	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0021a	3b c5		 cmp	 eax, ebp
  0021c	74 1e		 je	 SHORT $L321755

; 4895 : 			USERPTR->AddBlock( lpBuf, nBufSize );

  0021e	f6 40 04 01	 test	 BYTE PTR [eax+4], 1
  00222	8b 4c 24 1c	 mov	 ecx, DWORD PTR _nBufSize$[esp+16464]
  00226	75 14		 jne	 SHORT $L321755
  00228	66 ff 80 0c 57
	00 00		 inc	 WORD PTR [eax+22284]
  0022f	51		 push	 ecx
  00230	53		 push	 ebx
  00231	8d 88 f8 16 00
	00		 lea	 ecx, DWORD PTR [eax+5880]
  00237	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
$L321755:

; 4896 : 	NEXT_VISIBILITYRANGE( pMover )

  0023c	8a 46 15	 mov	 al, BYTE PTR [esi+21]
  0023f	84 c0		 test	 al, al
  00241	75 40		 jne	 SHORT $L321903
  00243	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00246	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00249	84 c9		 test	 cl, cl
  0024b	75 18		 jne	 SHORT $L321916
  0024d	8b f0		 mov	 esi, eax
  0024f	8b 06		 mov	 eax, DWORD PTR [esi]
  00251	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00254	84 c9		 test	 cl, cl
  00256	75 2b		 jne	 SHORT $L321903
$L321891:
  00258	8b f0		 mov	 esi, eax
  0025a	8b 06		 mov	 eax, DWORD PTR [esi]
  0025c	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  0025f	84 c9		 test	 cl, cl
  00261	74 f5		 je	 SHORT $L321891
  00263	eb 1e		 jmp	 SHORT $L321903
$L321916:
  00265	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00268	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  0026b	84 c9		 test	 cl, cl
  0026d	75 12		 jne	 SHORT $L321906
  0026f	90		 npad	 1
$L321905:
  00270	3b 70 08	 cmp	 esi, DWORD PTR [eax+8]
  00273	75 0c		 jne	 SHORT $L321906
  00275	8b f0		 mov	 esi, eax
  00277	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0027a	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  0027d	84 c9		 test	 cl, cl
  0027f	74 ef		 je	 SHORT $L321905
$L321906:
  00281	8b f0		 mov	 esi, eax
$L321903:

; 4892 : 
; 4893 : 	FOR_VISIBILITYRANGE( pMover )

  00283	3b f7		 cmp	 esi, edi
  00285	75 90		 jne	 SHORT $L281290
$L281291:

; 4897 : }

  00287	8d 4c 24 2c	 lea	 ecx, DWORD PTR _ar$[esp+16464]
  0028b	c7 84 24 4c 40
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+16472], -1
  00296	e8 00 00 00 00	 call	 ??1CAr@@QAE@XZ		; CAr::~CAr
  0029b	8b 8c 24 44 40
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+16464]
  002a2	5f		 pop	 edi
  002a3	5e		 pop	 esi
  002a4	5d		 pop	 ebp
  002a5	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  002ac	8b 8c 24 34 40
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+16452]
  002b3	5b		 pop	 ebx
  002b4	33 cc		 xor	 ecx, esp
  002b6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002bb	81 c4 40 40 00
	00		 add	 esp, 16448		; 00004040H
  002c1	c2 30 00	 ret	 48			; 00000030H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L321592:
  00000	8d 8d dc bf ff
	ff		 lea	 ecx, DWORD PTR _ar$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CAr@@QAE@XZ		; CAr::~CAr
__ehhandler$?AddMoverMoved@CUserMng@@QAEXPAVCMover@@AAUD3DXVECTOR3@@1MKKKHHK_J@Z:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T321913
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?AddMoverMoved@CUserMng@@QAEXPAVCMover@@AAUD3DXVECTOR3@@1MKKKHHK_J@Z ENDP ; CUserMng::AddMoverMoved
PUBLIC	?AddMoverBehavior@CUserMng@@QAEXPAVCMover@@AAUD3DXVECTOR3@@1MKKKHHK_JH@Z ; CUserMng::AddMoverBehavior
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
xdata$x	SEGMENT
$T322259 DD	0ffffffffH
	DD	FLAT:$L321930
$T322251 DD	019930520H
	DD	01H
	DD	FLAT:$T322259
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
xdata$x	ENDS
;	COMDAT ?AddMoverBehavior@CUserMng@@QAEXPAVCMover@@AAUD3DXVECTOR3@@1MKKKHHK_JH@Z
_TEXT	SEGMENT
$T321984 = -16448					; size = 8
$T321945 = -16448					; size = 12
_nBufSize$ = -16436					; size = 4
$T321949 = -16432					; size = 12
_ar$ = -16420						; size = 16404
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_pMover$ = 8						; size = 4
_v$ = 12						; size = 4
_vd$ = 16						; size = 4
_f$ = 20						; size = 4
_dwState$ = 24						; size = 4
_dwStateFlag$ = 28					; size = 4
_dwMotion$ = 32						; size = 4
_nMotionEx$ = 36					; size = 4
_nLoop$ = 40						; size = 4
_dwMotionOption$ = 44					; size = 4
_nTickCount$ = 48					; size = 8
_fTransferToMe$ = 56					; size = 4
?AddMoverBehavior@CUserMng@@QAEXPAVCMover@@AAUD3DXVECTOR3@@1MKKKHHK_JH@Z PROC NEAR ; CUserMng::AddMoverBehavior, COMDAT
; _this$ = ecx

; 4902 : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?AddMoverBehavior@CUserMng@@QAEXPAVCMover@@AAUD3DXVECTOR3@@1MKKKHHK_JH@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	b8 34 40 00 00	 mov	 eax, 16436		; 00004034H
  00013	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0001a	e8 00 00 00 00	 call	 __chkstk
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00024	33 c4		 xor	 eax, esp
  00026	53		 push	 ebx
  00027	55		 push	 ebp
  00028	8b ac 24 4c 40
	00 00		 mov	 ebp, DWORD PTR _pMover$[esp+16452]
  0002f	56		 push	 esi
  00030	8b b4 24 54 40
	00 00		 mov	 esi, DWORD PTR _v$[esp+16456]
  00037	57		 push	 edi
  00038	8b bc 24 5c 40
	00 00		 mov	 edi, DWORD PTR _vd$[esp+16460]

; 4903 : 	CAr ar;

  0003f	6a 00		 push	 0
  00041	6a 00		 push	 0
  00043	8d 4c 24 34	 lea	 ecx, DWORD PTR _ar$[esp+16472]
  00047	89 84 24 48 40
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+16472], eax
  0004e	e8 00 00 00 00	 call	 ??0CAr@@QAE@PAXI@Z	; CAr::CAr

; 4904 : 	ar << GETID( pMover ) << SNAPSHOTTYPE_MOVERBEHAVIOR;

  00053	85 ed		 test	 ebp, ebp
  00055	c7 84 24 4c 40
	00 00 00 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+16472], 0
  00060	74 08		 je	 SHORT $L321928
  00062	8b 9d bc 01 00
	00		 mov	 ebx, DWORD PTR [ebp+444]
  00068	eb 03		 jmp	 SHORT $L321929
$L321928:
  0006a	83 cb ff	 or	 ebx, -1
$L321929:
  0006d	6a 04		 push	 4
  0006f	8d 4c 24 30	 lea	 ecx, DWORD PTR _ar$[esp+16468]
  00073	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00078	8b 44 24 34	 mov	 eax, DWORD PTR _ar$[esp+16472]
  0007c	89 18		 mov	 DWORD PTR [eax], ebx
  0007e	8b 4c 24 34	 mov	 ecx, DWORD PTR _ar$[esp+16472]
  00082	bb 04 00 00 00	 mov	 ebx, 4
  00087	03 cb		 add	 ecx, ebx
  00089	89 4c 24 34	 mov	 DWORD PTR _ar$[esp+16472], ecx
  0008d	6a 02		 push	 2
  0008f	8d 4c 24 30	 lea	 ecx, DWORD PTR _ar$[esp+16468]
  00093	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00098	8b 4c 24 34	 mov	 ecx, DWORD PTR _ar$[esp+16472]
  0009c	66 c7 01 cb 00	 mov	 WORD PTR [ecx], 203	; 000000cbH
  000a1	8b 54 24 34	 mov	 edx, DWORD PTR _ar$[esp+16472]

; 4905 : 	ar << v << vd << f;

  000a5	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  000a8	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000ab	83 c2 02	 add	 edx, 2
  000ae	89 54 24 34	 mov	 DWORD PTR _ar$[esp+16472], edx
  000b2	8b 16		 mov	 edx, DWORD PTR [esi]
  000b4	89 54 24 10	 mov	 DWORD PTR $T321945[esp+16464], edx
  000b8	6a 0c		 push	 12			; 0000000cH
  000ba	8d 54 24 14	 lea	 edx, DWORD PTR $T321945[esp+16468]
  000be	89 4c 24 1c	 mov	 DWORD PTR $T321945[esp+16476], ecx
  000c2	52		 push	 edx
  000c3	8d 4c 24 34	 lea	 ecx, DWORD PTR _ar$[esp+16472]
  000c7	89 44 24 1c	 mov	 DWORD PTR $T321945[esp+16476], eax
  000cb	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
  000d0	8b 07		 mov	 eax, DWORD PTR [edi]
  000d2	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  000d5	8b 57 08	 mov	 edx, DWORD PTR [edi+8]
  000d8	89 44 24 20	 mov	 DWORD PTR $T321949[esp+16464], eax
  000dc	6a 0c		 push	 12			; 0000000cH
  000de	8d 44 24 24	 lea	 eax, DWORD PTR $T321949[esp+16468]
  000e2	89 4c 24 28	 mov	 DWORD PTR $T321949[esp+16472], ecx
  000e6	50		 push	 eax
  000e7	8d 4c 24 34	 lea	 ecx, DWORD PTR _ar$[esp+16472]
  000eb	89 54 24 30	 mov	 DWORD PTR $T321949[esp+16480], edx
  000ef	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
  000f4	53		 push	 ebx
  000f5	8d 4c 24 30	 lea	 ecx, DWORD PTR _ar$[esp+16468]
  000f9	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000fe	d9 84 24 60 40
	00 00		 fld	 DWORD PTR _f$[esp+16460]
  00105	8b 4c 24 34	 mov	 ecx, DWORD PTR _ar$[esp+16472]
  00109	d9 19		 fstp	 DWORD PTR [ecx]
  0010b	8b 4c 24 34	 mov	 ecx, DWORD PTR _ar$[esp+16472]
  0010f	03 cb		 add	 ecx, ebx
  00111	89 4c 24 34	 mov	 DWORD PTR _ar$[esp+16472], ecx

; 4906 : 	ar << dwState << dwStateFlag << dwMotion << nMotionEx;

  00115	53		 push	 ebx
  00116	8d 4c 24 30	 lea	 ecx, DWORD PTR _ar$[esp+16468]
  0011a	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0011f	8b 54 24 34	 mov	 edx, DWORD PTR _ar$[esp+16472]
  00123	8b 84 24 64 40
	00 00		 mov	 eax, DWORD PTR _dwState$[esp+16460]
  0012a	89 02		 mov	 DWORD PTR [edx], eax
  0012c	8b 7c 24 34	 mov	 edi, DWORD PTR _ar$[esp+16472]
  00130	03 fb		 add	 edi, ebx
  00132	53		 push	 ebx
  00133	8d 4c 24 30	 lea	 ecx, DWORD PTR _ar$[esp+16468]
  00137	89 7c 24 38	 mov	 DWORD PTR _ar$[esp+16476], edi
  0013b	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00140	8b 4c 24 34	 mov	 ecx, DWORD PTR _ar$[esp+16472]
  00144	8b 94 24 68 40
	00 00		 mov	 edx, DWORD PTR _dwStateFlag$[esp+16460]
  0014b	89 11		 mov	 DWORD PTR [ecx], edx
  0014d	8b 54 24 34	 mov	 edx, DWORD PTR _ar$[esp+16472]
  00151	03 d3		 add	 edx, ebx
  00153	53		 push	 ebx
  00154	8d 4c 24 30	 lea	 ecx, DWORD PTR _ar$[esp+16468]
  00158	89 54 24 38	 mov	 DWORD PTR _ar$[esp+16476], edx
  0015c	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00161	8b 44 24 34	 mov	 eax, DWORD PTR _ar$[esp+16472]
  00165	8b 8c 24 6c 40
	00 00		 mov	 ecx, DWORD PTR _dwMotion$[esp+16460]
  0016c	89 08		 mov	 DWORD PTR [eax], ecx
  0016e	8b 44 24 34	 mov	 eax, DWORD PTR _ar$[esp+16472]
  00172	03 c3		 add	 eax, ebx
  00174	53		 push	 ebx
  00175	8d 4c 24 30	 lea	 ecx, DWORD PTR _ar$[esp+16468]
  00179	89 44 24 38	 mov	 DWORD PTR _ar$[esp+16476], eax
  0017d	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00182	8b 54 24 34	 mov	 edx, DWORD PTR _ar$[esp+16472]
  00186	8b 84 24 70 40
	00 00		 mov	 eax, DWORD PTR _nMotionEx$[esp+16460]
  0018d	89 02		 mov	 DWORD PTR [edx], eax
  0018f	8b 74 24 34	 mov	 esi, DWORD PTR _ar$[esp+16472]
  00193	03 f3		 add	 esi, ebx

; 4907 : 	ar << nLoop << dwMotionOption << nTickCount;

  00195	53		 push	 ebx
  00196	8d 4c 24 30	 lea	 ecx, DWORD PTR _ar$[esp+16468]
  0019a	89 74 24 38	 mov	 DWORD PTR _ar$[esp+16476], esi
  0019e	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  001a3	8b 4c 24 34	 mov	 ecx, DWORD PTR _ar$[esp+16472]
  001a7	8b 94 24 74 40
	00 00		 mov	 edx, DWORD PTR _nLoop$[esp+16460]
  001ae	89 11		 mov	 DWORD PTR [ecx], edx
  001b0	01 5c 24 34	 add	 DWORD PTR _ar$[esp+16472], ebx
  001b4	53		 push	 ebx
  001b5	8d 4c 24 30	 lea	 ecx, DWORD PTR _ar$[esp+16468]
  001b9	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  001be	8b 44 24 34	 mov	 eax, DWORD PTR _ar$[esp+16472]
  001c2	8b 8c 24 78 40
	00 00		 mov	 ecx, DWORD PTR _dwMotionOption$[esp+16460]
  001c9	8b 94 24 7c 40
	00 00		 mov	 edx, DWORD PTR _nTickCount$[esp+16460]
  001d0	89 08		 mov	 DWORD PTR [eax], ecx
  001d2	8b 7c 24 34	 mov	 edi, DWORD PTR _ar$[esp+16472]
  001d6	8b 84 24 80 40
	00 00		 mov	 eax, DWORD PTR _nTickCount$[esp+16464]
  001dd	6a 08		 push	 8
  001df	8d 4c 24 14	 lea	 ecx, DWORD PTR $T321984[esp+16468]
  001e3	51		 push	 ecx
  001e4	03 fb		 add	 edi, ebx
  001e6	8d 4c 24 34	 lea	 ecx, DWORD PTR _ar$[esp+16472]
  001ea	89 7c 24 3c	 mov	 DWORD PTR _ar$[esp+16480], edi
  001ee	89 54 24 18	 mov	 DWORD PTR $T321984[esp+16472], edx
  001f2	89 44 24 1c	 mov	 DWORD PTR $T321984[esp+16476], eax
  001f6	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write

; 4908 : 	
; 4909 : 	GETBLOCK( ar, lpBuf, nBufSize );

  001fb	8d 54 24 1c	 lea	 edx, DWORD PTR _nBufSize$[esp+16464]
  001ff	52		 push	 edx
  00200	8d 4c 24 30	 lea	 ecx, DWORD PTR _ar$[esp+16468]
  00204	e8 00 00 00 00	 call	 ?GetBuffer@CAr@@QAEPAEPAH@Z ; CAr::GetBuffer

; 4910 : 
; 4911 : 	FOR_VISIBILITYRANGE( pMover )

  00209	8b bd 10 02 00
	00		 mov	 edi, DWORD PTR [ebp+528]
  0020f	8b 37		 mov	 esi, DWORD PTR [edi]
  00211	3b f7		 cmp	 esi, edi
  00213	8b d8		 mov	 ebx, eax
  00215	0f 84 83 00 00
	00		 je	 $L281328
  0021b	eb 03 8d 49 00	 npad	 5
$L281327:

; 4912 : 		if( fTransferToMe || USERPTR != pMover )

  00220	8b 84 24 84 40
	00 00		 mov	 eax, DWORD PTR _fTransferToMe$[esp+16460]
  00227	85 c0		 test	 eax, eax
  00229	75 05		 jne	 SHORT $L281330
  0022b	39 6e 10	 cmp	 DWORD PTR [esi+16], ebp
  0022e	74 21		 je	 SHORT $L322090
$L281330:

; 4913 : 			USERPTR->AddBlock( lpBuf, nBufSize );

  00230	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00233	f6 40 04 01	 test	 BYTE PTR [eax+4], 1
  00237	8b 4c 24 1c	 mov	 ecx, DWORD PTR _nBufSize$[esp+16464]
  0023b	75 14		 jne	 SHORT $L322090
  0023d	66 ff 80 0c 57
	00 00		 inc	 WORD PTR [eax+22284]
  00244	51		 push	 ecx
  00245	53		 push	 ebx
  00246	8d 88 f8 16 00
	00		 lea	 ecx, DWORD PTR [eax+5880]
  0024c	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
$L322090:

; 4914 : 	NEXT_VISIBILITYRANGE( pMover )

  00251	8a 46 15	 mov	 al, BYTE PTR [esi+21]
  00254	84 c0		 test	 al, al
  00256	75 42		 jne	 SHORT $L322217
  00258	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0025b	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  0025e	84 c9		 test	 cl, cl
  00260	75 1b		 jne	 SHORT $L322254
  00262	8b f0		 mov	 esi, eax
  00264	8b 06		 mov	 eax, DWORD PTR [esi]
  00266	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00269	84 c9		 test	 cl, cl
  0026b	75 2d		 jne	 SHORT $L322217
  0026d	8d 49 00	 npad	 3
$L322238:
  00270	8b f0		 mov	 esi, eax
  00272	8b 06		 mov	 eax, DWORD PTR [esi]
  00274	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00277	84 c9		 test	 cl, cl
  00279	74 f5		 je	 SHORT $L322238
  0027b	eb 1d		 jmp	 SHORT $L322217
$L322254:
  0027d	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00280	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00283	84 c9		 test	 cl, cl
  00285	75 11		 jne	 SHORT $L322220
$L322219:
  00287	3b 70 08	 cmp	 esi, DWORD PTR [eax+8]
  0028a	75 0c		 jne	 SHORT $L322220
  0028c	8b f0		 mov	 esi, eax
  0028e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00291	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00294	84 c9		 test	 cl, cl
  00296	74 ef		 je	 SHORT $L322219
$L322220:
  00298	8b f0		 mov	 esi, eax
$L322217:

; 4910 : 
; 4911 : 	FOR_VISIBILITYRANGE( pMover )

  0029a	3b f7		 cmp	 esi, edi
  0029c	75 82		 jne	 SHORT $L281327
$L281328:

; 4915 : }

  0029e	8d 4c 24 2c	 lea	 ecx, DWORD PTR _ar$[esp+16464]
  002a2	c7 84 24 4c 40
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+16472], -1
  002ad	e8 00 00 00 00	 call	 ??1CAr@@QAE@XZ		; CAr::~CAr
  002b2	8b 8c 24 44 40
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+16464]
  002b9	5f		 pop	 edi
  002ba	5e		 pop	 esi
  002bb	5d		 pop	 ebp
  002bc	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  002c3	8b 8c 24 34 40
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+16452]
  002ca	5b		 pop	 ebx
  002cb	33 cc		 xor	 ecx, esp
  002cd	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002d2	81 c4 40 40 00
	00		 add	 esp, 16448		; 00004040H
  002d8	c2 34 00	 ret	 52			; 00000034H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L321930:
  00000	8d 8d dc bf ff
	ff		 lea	 ecx, DWORD PTR _ar$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CAr@@QAE@XZ		; CAr::~CAr
__ehhandler$?AddMoverBehavior@CUserMng@@QAEXPAVCMover@@AAUD3DXVECTOR3@@1MKKKHHK_JH@Z:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T322251
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?AddMoverBehavior@CUserMng@@QAEXPAVCMover@@AAUD3DXVECTOR3@@1MKKKHHK_JH@Z ENDP ; CUserMng::AddMoverBehavior
PUBLIC	?AddMoverMoved2@CUserMng@@QAEXPAVCMover@@AAUD3DXVECTOR3@@1MMMMKKKHHK_JE@Z ; CUserMng::AddMoverMoved2
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
xdata$x	SEGMENT
$T322609 DD	0ffffffffH
	DD	FLAT:$L322268
$T322601 DD	019930520H
	DD	01H
	DD	FLAT:$T322609
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
xdata$x	ENDS
;	COMDAT ?AddMoverMoved2@CUserMng@@QAEXPAVCMover@@AAUD3DXVECTOR3@@1MMMMKKKHHK_JE@Z
_TEXT	SEGMENT
$T322331 = -16448					; size = 8
$T322283 = -16448					; size = 12
_nBufSize$ = -16436					; size = 4
$T322287 = -16432					; size = 12
_ar$ = -16420						; size = 16404
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_pMover$ = 8						; size = 4
_v$ = 12						; size = 4
_vd$ = 16						; size = 4
_f$ = 20						; size = 4
_fAngleX$ = 24						; size = 4
_fAccPower$ = 28					; size = 4
_fTurnAngle$ = 32					; size = 4
_dwState$ = 36						; size = 4
_dwStateFlag$ = 40					; size = 4
_dwMotion$ = 44						; size = 4
_nMotionEx$ = 48					; size = 4
_nLoop$ = 52						; size = 4
_dwMotionOption$ = 56					; size = 4
_nTickCount$ = 60					; size = 8
_nFrame$ = 68						; size = 1
?AddMoverMoved2@CUserMng@@QAEXPAVCMover@@AAUD3DXVECTOR3@@1MMMMKKKHHK_JE@Z PROC NEAR ; CUserMng::AddMoverMoved2, COMDAT
; _this$ = ecx

; 4921 : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?AddMoverMoved2@CUserMng@@QAEXPAVCMover@@AAUD3DXVECTOR3@@1MMMMKKKHHK_JE@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	b8 34 40 00 00	 mov	 eax, 16436		; 00004034H
  00013	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0001a	e8 00 00 00 00	 call	 __chkstk
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00024	33 c4		 xor	 eax, esp
  00026	53		 push	 ebx
  00027	55		 push	 ebp
  00028	8b ac 24 4c 40
	00 00		 mov	 ebp, DWORD PTR _pMover$[esp+16452]
  0002f	56		 push	 esi
  00030	8b b4 24 54 40
	00 00		 mov	 esi, DWORD PTR _v$[esp+16456]
  00037	57		 push	 edi
  00038	8b bc 24 5c 40
	00 00		 mov	 edi, DWORD PTR _vd$[esp+16460]

; 4922 : 	CAr ar;

  0003f	6a 00		 push	 0
  00041	6a 00		 push	 0
  00043	8d 4c 24 34	 lea	 ecx, DWORD PTR _ar$[esp+16472]
  00047	89 84 24 48 40
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+16472], eax
  0004e	e8 00 00 00 00	 call	 ??0CAr@@QAE@PAXI@Z	; CAr::CAr

; 4923 : 	ar << GETID( pMover ) << SNAPSHOTTYPE_MOVERMOVED2;

  00053	85 ed		 test	 ebp, ebp
  00055	c7 84 24 4c 40
	00 00 00 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+16472], 0
  00060	74 08		 je	 SHORT $L322266
  00062	8b 9d bc 01 00
	00		 mov	 ebx, DWORD PTR [ebp+444]
  00068	eb 03		 jmp	 SHORT $L322267
$L322266:
  0006a	83 cb ff	 or	 ebx, -1
$L322267:
  0006d	6a 04		 push	 4
  0006f	8d 4c 24 30	 lea	 ecx, DWORD PTR _ar$[esp+16468]
  00073	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00078	8b 44 24 34	 mov	 eax, DWORD PTR _ar$[esp+16472]
  0007c	89 18		 mov	 DWORD PTR [eax], ebx
  0007e	8b 44 24 34	 mov	 eax, DWORD PTR _ar$[esp+16472]
  00082	bb 04 00 00 00	 mov	 ebx, 4
  00087	03 c3		 add	 eax, ebx
  00089	6a 02		 push	 2
  0008b	8d 4c 24 30	 lea	 ecx, DWORD PTR _ar$[esp+16468]
  0008f	89 44 24 38	 mov	 DWORD PTR _ar$[esp+16476], eax
  00093	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00098	8b 4c 24 34	 mov	 ecx, DWORD PTR _ar$[esp+16472]
  0009c	66 c7 01 cc 00	 mov	 WORD PTR [ecx], 204	; 000000ccH
  000a1	8b 4c 24 34	 mov	 ecx, DWORD PTR _ar$[esp+16472]

; 4924 : 	ar << v << vd << f << fAngleX << fAccPower << fTurnAngle;

  000a5	8b 16		 mov	 edx, DWORD PTR [esi]
  000a7	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000aa	83 c1 02	 add	 ecx, 2
  000ad	89 4c 24 34	 mov	 DWORD PTR _ar$[esp+16472], ecx
  000b1	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  000b4	89 54 24 10	 mov	 DWORD PTR $T322283[esp+16464], edx
  000b8	6a 0c		 push	 12			; 0000000cH
  000ba	8d 54 24 14	 lea	 edx, DWORD PTR $T322283[esp+16468]
  000be	89 4c 24 1c	 mov	 DWORD PTR $T322283[esp+16476], ecx
  000c2	52		 push	 edx
  000c3	8d 4c 24 34	 lea	 ecx, DWORD PTR _ar$[esp+16472]
  000c7	89 44 24 1c	 mov	 DWORD PTR $T322283[esp+16476], eax
  000cb	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
  000d0	8b 07		 mov	 eax, DWORD PTR [edi]
  000d2	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  000d5	8b 57 08	 mov	 edx, DWORD PTR [edi+8]
  000d8	89 44 24 20	 mov	 DWORD PTR $T322287[esp+16464], eax
  000dc	6a 0c		 push	 12			; 0000000cH
  000de	8d 44 24 24	 lea	 eax, DWORD PTR $T322287[esp+16468]
  000e2	89 4c 24 28	 mov	 DWORD PTR $T322287[esp+16472], ecx
  000e6	50		 push	 eax
  000e7	8d 4c 24 34	 lea	 ecx, DWORD PTR _ar$[esp+16472]
  000eb	89 54 24 30	 mov	 DWORD PTR $T322287[esp+16480], edx
  000ef	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
  000f4	53		 push	 ebx
  000f5	8d 4c 24 30	 lea	 ecx, DWORD PTR _ar$[esp+16468]
  000f9	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000fe	d9 84 24 60 40
	00 00		 fld	 DWORD PTR _f$[esp+16460]
  00105	8b 4c 24 34	 mov	 ecx, DWORD PTR _ar$[esp+16472]
  00109	d9 19		 fstp	 DWORD PTR [ecx]
  0010b	8b 7c 24 34	 mov	 edi, DWORD PTR _ar$[esp+16472]
  0010f	03 fb		 add	 edi, ebx
  00111	53		 push	 ebx
  00112	8d 4c 24 30	 lea	 ecx, DWORD PTR _ar$[esp+16468]
  00116	89 7c 24 38	 mov	 DWORD PTR _ar$[esp+16476], edi
  0011a	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0011f	d9 84 24 64 40
	00 00		 fld	 DWORD PTR _fAngleX$[esp+16460]
  00126	8b 54 24 34	 mov	 edx, DWORD PTR _ar$[esp+16472]
  0012a	d9 1a		 fstp	 DWORD PTR [edx]
  0012c	8b 54 24 34	 mov	 edx, DWORD PTR _ar$[esp+16472]
  00130	03 d3		 add	 edx, ebx
  00132	53		 push	 ebx
  00133	8d 4c 24 30	 lea	 ecx, DWORD PTR _ar$[esp+16468]
  00137	89 54 24 38	 mov	 DWORD PTR _ar$[esp+16476], edx
  0013b	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00140	d9 84 24 68 40
	00 00		 fld	 DWORD PTR _fAccPower$[esp+16460]
  00147	8b 44 24 34	 mov	 eax, DWORD PTR _ar$[esp+16472]
  0014b	d9 18		 fstp	 DWORD PTR [eax]
  0014d	8b 44 24 34	 mov	 eax, DWORD PTR _ar$[esp+16472]
  00151	03 c3		 add	 eax, ebx
  00153	53		 push	 ebx
  00154	8d 4c 24 30	 lea	 ecx, DWORD PTR _ar$[esp+16468]
  00158	89 44 24 38	 mov	 DWORD PTR _ar$[esp+16476], eax
  0015c	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00161	d9 84 24 6c 40
	00 00		 fld	 DWORD PTR _fTurnAngle$[esp+16460]
  00168	8b 4c 24 34	 mov	 ecx, DWORD PTR _ar$[esp+16472]
  0016c	d9 19		 fstp	 DWORD PTR [ecx]
  0016e	8b 74 24 34	 mov	 esi, DWORD PTR _ar$[esp+16472]
  00172	03 f3		 add	 esi, ebx

; 4925 : 	ar << dwState << dwStateFlag << dwMotion << nMotionEx;

  00174	53		 push	 ebx
  00175	8d 4c 24 30	 lea	 ecx, DWORD PTR _ar$[esp+16468]
  00179	89 74 24 38	 mov	 DWORD PTR _ar$[esp+16476], esi
  0017d	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00182	8b 54 24 34	 mov	 edx, DWORD PTR _ar$[esp+16472]
  00186	8b 84 24 70 40
	00 00		 mov	 eax, DWORD PTR _dwState$[esp+16460]
  0018d	89 02		 mov	 DWORD PTR [edx], eax
  0018f	01 5c 24 34	 add	 DWORD PTR _ar$[esp+16472], ebx
  00193	53		 push	 ebx
  00194	8d 4c 24 30	 lea	 ecx, DWORD PTR _ar$[esp+16468]
  00198	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0019d	8b 4c 24 34	 mov	 ecx, DWORD PTR _ar$[esp+16472]
  001a1	8b 94 24 74 40
	00 00		 mov	 edx, DWORD PTR _dwStateFlag$[esp+16460]
  001a8	89 11		 mov	 DWORD PTR [ecx], edx
  001aa	8b 7c 24 34	 mov	 edi, DWORD PTR _ar$[esp+16472]
  001ae	03 fb		 add	 edi, ebx
  001b0	53		 push	 ebx
  001b1	8d 4c 24 30	 lea	 ecx, DWORD PTR _ar$[esp+16468]
  001b5	89 7c 24 38	 mov	 DWORD PTR _ar$[esp+16476], edi
  001b9	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  001be	8b 44 24 34	 mov	 eax, DWORD PTR _ar$[esp+16472]
  001c2	8b 8c 24 78 40
	00 00		 mov	 ecx, DWORD PTR _dwMotion$[esp+16460]
  001c9	89 08		 mov	 DWORD PTR [eax], ecx
  001cb	8b 54 24 34	 mov	 edx, DWORD PTR _ar$[esp+16472]
  001cf	03 d3		 add	 edx, ebx
  001d1	53		 push	 ebx
  001d2	8d 4c 24 30	 lea	 ecx, DWORD PTR _ar$[esp+16468]
  001d6	89 54 24 38	 mov	 DWORD PTR _ar$[esp+16476], edx
  001da	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  001df	8b 54 24 34	 mov	 edx, DWORD PTR _ar$[esp+16472]
  001e3	8b 84 24 7c 40
	00 00		 mov	 eax, DWORD PTR _nMotionEx$[esp+16460]
  001ea	89 02		 mov	 DWORD PTR [edx], eax
  001ec	8b 44 24 34	 mov	 eax, DWORD PTR _ar$[esp+16472]
  001f0	03 c3		 add	 eax, ebx

; 4926 : 	ar << nLoop << dwMotionOption << nTickCount;

  001f2	53		 push	 ebx
  001f3	8d 4c 24 30	 lea	 ecx, DWORD PTR _ar$[esp+16468]
  001f7	89 44 24 38	 mov	 DWORD PTR _ar$[esp+16476], eax
  001fb	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00200	8b 4c 24 34	 mov	 ecx, DWORD PTR _ar$[esp+16472]
  00204	8b 94 24 80 40
	00 00		 mov	 edx, DWORD PTR _nLoop$[esp+16460]
  0020b	89 11		 mov	 DWORD PTR [ecx], edx
  0020d	8b 74 24 34	 mov	 esi, DWORD PTR _ar$[esp+16472]
  00211	03 f3		 add	 esi, ebx
  00213	53		 push	 ebx
  00214	8d 4c 24 30	 lea	 ecx, DWORD PTR _ar$[esp+16468]
  00218	89 74 24 38	 mov	 DWORD PTR _ar$[esp+16476], esi
  0021c	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00221	8b 44 24 34	 mov	 eax, DWORD PTR _ar$[esp+16472]
  00225	8b 8c 24 84 40
	00 00		 mov	 ecx, DWORD PTR _dwMotionOption$[esp+16460]
  0022c	8b 94 24 88 40
	00 00		 mov	 edx, DWORD PTR _nTickCount$[esp+16460]
  00233	89 08		 mov	 DWORD PTR [eax], ecx
  00235	8b 4c 24 34	 mov	 ecx, DWORD PTR _ar$[esp+16472]
  00239	8b 84 24 8c 40
	00 00		 mov	 eax, DWORD PTR _nTickCount$[esp+16464]
  00240	03 cb		 add	 ecx, ebx
  00242	89 4c 24 34	 mov	 DWORD PTR _ar$[esp+16472], ecx
  00246	6a 08		 push	 8
  00248	8d 4c 24 14	 lea	 ecx, DWORD PTR $T322331[esp+16468]
  0024c	51		 push	 ecx
  0024d	8d 4c 24 34	 lea	 ecx, DWORD PTR _ar$[esp+16472]
  00251	89 54 24 18	 mov	 DWORD PTR $T322331[esp+16472], edx
  00255	89 44 24 1c	 mov	 DWORD PTR $T322331[esp+16476], eax
  00259	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write

; 4927 : 	ar << nFrame;

  0025e	6a 01		 push	 1
  00260	8d 4c 24 30	 lea	 ecx, DWORD PTR _ar$[esp+16468]
  00264	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00269	8b 54 24 34	 mov	 edx, DWORD PTR _ar$[esp+16472]
  0026d	8a 84 24 90 40
	00 00		 mov	 al, BYTE PTR _nFrame$[esp+16460]
  00274	88 02		 mov	 BYTE PTR [edx], al
  00276	8b 74 24 34	 mov	 esi, DWORD PTR _ar$[esp+16472]

; 4928 : 	
; 4929 : 	GETBLOCK( ar, lpBuf, nBufSize );

  0027a	8d 4c 24 1c	 lea	 ecx, DWORD PTR _nBufSize$[esp+16464]
  0027e	51		 push	 ecx
  0027f	46		 inc	 esi
  00280	8d 4c 24 30	 lea	 ecx, DWORD PTR _ar$[esp+16468]
  00284	89 74 24 38	 mov	 DWORD PTR _ar$[esp+16476], esi
  00288	e8 00 00 00 00	 call	 ?GetBuffer@CAr@@QAEPAEPAH@Z ; CAr::GetBuffer

; 4930 : 
; 4931 : 	FOR_VISIBILITYRANGE( pMover )

  0028d	8b bd 10 02 00
	00		 mov	 edi, DWORD PTR [ebp+528]
  00293	8b 37		 mov	 esi, DWORD PTR [edi]
  00295	3b f7		 cmp	 esi, edi
  00297	8b d8		 mov	 ebx, eax
  00299	74 74		 je	 SHORT $L281369
  0029b	eb 03 8d 49 00	 npad	 5
$L281368:

; 4932 : 		if( USERPTR != pMover )

  002a0	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  002a3	3b c5		 cmp	 eax, ebp
  002a5	74 1e		 je	 SHORT $L322440

; 4933 : 			USERPTR->AddBlock( lpBuf, nBufSize );

  002a7	f6 40 04 01	 test	 BYTE PTR [eax+4], 1
  002ab	8b 4c 24 1c	 mov	 ecx, DWORD PTR _nBufSize$[esp+16464]
  002af	75 14		 jne	 SHORT $L322440
  002b1	66 ff 80 0c 57
	00 00		 inc	 WORD PTR [eax+22284]
  002b8	51		 push	 ecx
  002b9	53		 push	 ebx
  002ba	8d 88 f8 16 00
	00		 lea	 ecx, DWORD PTR [eax+5880]
  002c0	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
$L322440:

; 4934 : 	NEXT_VISIBILITYRANGE( pMover )

  002c5	8a 46 15	 mov	 al, BYTE PTR [esi+21]
  002c8	84 c0		 test	 al, al
  002ca	75 3f		 jne	 SHORT $L322568
  002cc	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  002cf	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  002d2	84 c9		 test	 cl, cl
  002d4	75 18		 jne	 SHORT $L322604
  002d6	8b f0		 mov	 esi, eax
  002d8	8b 06		 mov	 eax, DWORD PTR [esi]
  002da	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  002dd	84 c9		 test	 cl, cl
  002df	75 2a		 jne	 SHORT $L322568
$L322582:
  002e1	8b f0		 mov	 esi, eax
  002e3	8b 06		 mov	 eax, DWORD PTR [esi]
  002e5	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  002e8	84 c9		 test	 cl, cl
  002ea	74 f5		 je	 SHORT $L322582
  002ec	eb 1d		 jmp	 SHORT $L322568
$L322604:
  002ee	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  002f1	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  002f4	84 c9		 test	 cl, cl
  002f6	75 11		 jne	 SHORT $L322571
$L322570:
  002f8	3b 70 08	 cmp	 esi, DWORD PTR [eax+8]
  002fb	75 0c		 jne	 SHORT $L322571
  002fd	8b f0		 mov	 esi, eax
  002ff	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00302	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00305	84 c9		 test	 cl, cl
  00307	74 ef		 je	 SHORT $L322570
$L322571:
  00309	8b f0		 mov	 esi, eax
$L322568:

; 4930 : 
; 4931 : 	FOR_VISIBILITYRANGE( pMover )

  0030b	3b f7		 cmp	 esi, edi
  0030d	75 91		 jne	 SHORT $L281368
$L281369:

; 4935 : }

  0030f	8d 4c 24 2c	 lea	 ecx, DWORD PTR _ar$[esp+16464]
  00313	c7 84 24 4c 40
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+16472], -1
  0031e	e8 00 00 00 00	 call	 ??1CAr@@QAE@XZ		; CAr::~CAr
  00323	8b 8c 24 44 40
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+16464]
  0032a	5f		 pop	 edi
  0032b	5e		 pop	 esi
  0032c	5d		 pop	 ebp
  0032d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00334	8b 8c 24 34 40
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+16452]
  0033b	5b		 pop	 ebx
  0033c	33 cc		 xor	 ecx, esp
  0033e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00343	81 c4 40 40 00
	00		 add	 esp, 16448		; 00004040H
  00349	c2 40 00	 ret	 64			; 00000040H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L322268:
  00000	8d 8d dc bf ff
	ff		 lea	 ecx, DWORD PTR _ar$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CAr@@QAE@XZ		; CAr::~CAr
__ehhandler$?AddMoverMoved2@CUserMng@@QAEXPAVCMover@@AAUD3DXVECTOR3@@1MMMMKKKHHK_JE@Z:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T322601
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?AddMoverMoved2@CUserMng@@QAEXPAVCMover@@AAUD3DXVECTOR3@@1MMMMKKKHHK_JE@Z ENDP ; CUserMng::AddMoverMoved2
PUBLIC	?AddMoverBehavior2@CUserMng@@QAEXPAVCMover@@AAUD3DXVECTOR3@@1MMMMKKKHHK_JH@Z ; CUserMng::AddMoverBehavior2
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
xdata$x	SEGMENT
$T322956 DD	0ffffffffH
	DD	FLAT:$L322618
$T322948 DD	019930520H
	DD	01H
	DD	FLAT:$T322956
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
xdata$x	ENDS
;	COMDAT ?AddMoverBehavior2@CUserMng@@QAEXPAVCMover@@AAUD3DXVECTOR3@@1MMMMKKKHHK_JH@Z
_TEXT	SEGMENT
$T322681 = -16448					; size = 8
$T322633 = -16448					; size = 12
_nBufSize$ = -16436					; size = 4
$T322637 = -16432					; size = 12
_ar$ = -16420						; size = 16404
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_pMover$ = 8						; size = 4
_v$ = 12						; size = 4
_vd$ = 16						; size = 4
_f$ = 20						; size = 4
_fAngleX$ = 24						; size = 4
_fAccPower$ = 28					; size = 4
_fTurnAngle$ = 32					; size = 4
_dwState$ = 36						; size = 4
_dwStateFlag$ = 40					; size = 4
_dwMotion$ = 44						; size = 4
_nMotionEx$ = 48					; size = 4
_nLoop$ = 52						; size = 4
_dwMotionOption$ = 56					; size = 4
_nTickCount$ = 60					; size = 8
_fTransferToMe$ = 68					; size = 4
?AddMoverBehavior2@CUserMng@@QAEXPAVCMover@@AAUD3DXVECTOR3@@1MMMMKKKHHK_JH@Z PROC NEAR ; CUserMng::AddMoverBehavior2, COMDAT
; _this$ = ecx

; 4941 : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?AddMoverBehavior2@CUserMng@@QAEXPAVCMover@@AAUD3DXVECTOR3@@1MMMMKKKHHK_JH@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	b8 34 40 00 00	 mov	 eax, 16436		; 00004034H
  00013	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0001a	e8 00 00 00 00	 call	 __chkstk
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00024	33 c4		 xor	 eax, esp
  00026	53		 push	 ebx
  00027	55		 push	 ebp
  00028	8b ac 24 4c 40
	00 00		 mov	 ebp, DWORD PTR _pMover$[esp+16452]
  0002f	56		 push	 esi
  00030	8b b4 24 54 40
	00 00		 mov	 esi, DWORD PTR _v$[esp+16456]
  00037	57		 push	 edi
  00038	8b bc 24 5c 40
	00 00		 mov	 edi, DWORD PTR _vd$[esp+16460]

; 4942 : 	CAr ar;

  0003f	6a 00		 push	 0
  00041	6a 00		 push	 0
  00043	8d 4c 24 34	 lea	 ecx, DWORD PTR _ar$[esp+16472]
  00047	89 84 24 48 40
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+16472], eax
  0004e	e8 00 00 00 00	 call	 ??0CAr@@QAE@PAXI@Z	; CAr::CAr

; 4943 : 	ar << GETID( pMover ) << SNAPSHOTTYPE_MOVERBEHAVIOR2;

  00053	85 ed		 test	 ebp, ebp
  00055	c7 84 24 4c 40
	00 00 00 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+16472], 0
  00060	74 08		 je	 SHORT $L322616
  00062	8b 9d bc 01 00
	00		 mov	 ebx, DWORD PTR [ebp+444]
  00068	eb 03		 jmp	 SHORT $L322617
$L322616:
  0006a	83 cb ff	 or	 ebx, -1
$L322617:
  0006d	6a 04		 push	 4
  0006f	8d 4c 24 30	 lea	 ecx, DWORD PTR _ar$[esp+16468]
  00073	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00078	8b 44 24 34	 mov	 eax, DWORD PTR _ar$[esp+16472]
  0007c	89 18		 mov	 DWORD PTR [eax], ebx
  0007e	8b 54 24 34	 mov	 edx, DWORD PTR _ar$[esp+16472]
  00082	bb 04 00 00 00	 mov	 ebx, 4
  00087	03 d3		 add	 edx, ebx
  00089	6a 02		 push	 2
  0008b	8d 4c 24 30	 lea	 ecx, DWORD PTR _ar$[esp+16468]
  0008f	89 54 24 38	 mov	 DWORD PTR _ar$[esp+16476], edx
  00093	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00098	8b 4c 24 34	 mov	 ecx, DWORD PTR _ar$[esp+16472]
  0009c	66 c7 01 cd 00	 mov	 WORD PTR [ecx], 205	; 000000cdH
  000a1	8b 44 24 34	 mov	 eax, DWORD PTR _ar$[esp+16472]

; 4944 : 	ar << v << vd << f << fAngleX << fAccPower << fTurnAngle;

  000a5	8b 16		 mov	 edx, DWORD PTR [esi]
  000a7	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  000aa	83 c0 02	 add	 eax, 2
  000ad	89 54 24 10	 mov	 DWORD PTR $T322633[esp+16464], edx
  000b1	89 44 24 34	 mov	 DWORD PTR _ar$[esp+16472], eax
  000b5	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000b8	6a 0c		 push	 12			; 0000000cH
  000ba	8d 54 24 14	 lea	 edx, DWORD PTR $T322633[esp+16468]
  000be	89 4c 24 1c	 mov	 DWORD PTR $T322633[esp+16476], ecx
  000c2	52		 push	 edx
  000c3	8d 4c 24 34	 lea	 ecx, DWORD PTR _ar$[esp+16472]
  000c7	89 44 24 1c	 mov	 DWORD PTR $T322633[esp+16476], eax
  000cb	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
  000d0	8b 07		 mov	 eax, DWORD PTR [edi]
  000d2	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  000d5	8b 57 08	 mov	 edx, DWORD PTR [edi+8]
  000d8	89 44 24 20	 mov	 DWORD PTR $T322637[esp+16464], eax
  000dc	6a 0c		 push	 12			; 0000000cH
  000de	8d 44 24 24	 lea	 eax, DWORD PTR $T322637[esp+16468]
  000e2	89 4c 24 28	 mov	 DWORD PTR $T322637[esp+16472], ecx
  000e6	50		 push	 eax
  000e7	8d 4c 24 34	 lea	 ecx, DWORD PTR _ar$[esp+16472]
  000eb	89 54 24 30	 mov	 DWORD PTR $T322637[esp+16480], edx
  000ef	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
  000f4	53		 push	 ebx
  000f5	8d 4c 24 30	 lea	 ecx, DWORD PTR _ar$[esp+16468]
  000f9	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000fe	d9 84 24 60 40
	00 00		 fld	 DWORD PTR _f$[esp+16460]
  00105	8b 4c 24 34	 mov	 ecx, DWORD PTR _ar$[esp+16472]
  00109	d9 19		 fstp	 DWORD PTR [ecx]
  0010b	8b 54 24 34	 mov	 edx, DWORD PTR _ar$[esp+16472]
  0010f	03 d3		 add	 edx, ebx
  00111	53		 push	 ebx
  00112	8d 4c 24 30	 lea	 ecx, DWORD PTR _ar$[esp+16468]
  00116	89 54 24 38	 mov	 DWORD PTR _ar$[esp+16476], edx
  0011a	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0011f	d9 84 24 64 40
	00 00		 fld	 DWORD PTR _fAngleX$[esp+16460]
  00126	8b 54 24 34	 mov	 edx, DWORD PTR _ar$[esp+16472]
  0012a	d9 1a		 fstp	 DWORD PTR [edx]
  0012c	8b 44 24 34	 mov	 eax, DWORD PTR _ar$[esp+16472]
  00130	03 c3		 add	 eax, ebx
  00132	53		 push	 ebx
  00133	8d 4c 24 30	 lea	 ecx, DWORD PTR _ar$[esp+16468]
  00137	89 44 24 38	 mov	 DWORD PTR _ar$[esp+16476], eax
  0013b	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00140	d9 84 24 68 40
	00 00		 fld	 DWORD PTR _fAccPower$[esp+16460]
  00147	8b 44 24 34	 mov	 eax, DWORD PTR _ar$[esp+16472]
  0014b	d9 18		 fstp	 DWORD PTR [eax]
  0014d	8b 74 24 34	 mov	 esi, DWORD PTR _ar$[esp+16472]
  00151	03 f3		 add	 esi, ebx
  00153	53		 push	 ebx
  00154	8d 4c 24 30	 lea	 ecx, DWORD PTR _ar$[esp+16468]
  00158	89 74 24 38	 mov	 DWORD PTR _ar$[esp+16476], esi
  0015c	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00161	d9 84 24 6c 40
	00 00		 fld	 DWORD PTR _fTurnAngle$[esp+16460]
  00168	8b 4c 24 34	 mov	 ecx, DWORD PTR _ar$[esp+16472]
  0016c	d9 19		 fstp	 DWORD PTR [ecx]
  0016e	8b 4c 24 34	 mov	 ecx, DWORD PTR _ar$[esp+16472]
  00172	03 cb		 add	 ecx, ebx
  00174	89 4c 24 34	 mov	 DWORD PTR _ar$[esp+16472], ecx

; 4945 : 	ar << dwState << dwStateFlag << dwMotion << nMotionEx;

  00178	53		 push	 ebx
  00179	8d 4c 24 30	 lea	 ecx, DWORD PTR _ar$[esp+16468]
  0017d	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00182	8b 54 24 34	 mov	 edx, DWORD PTR _ar$[esp+16472]
  00186	8b 84 24 70 40
	00 00		 mov	 eax, DWORD PTR _dwState$[esp+16460]
  0018d	89 02		 mov	 DWORD PTR [edx], eax
  0018f	8b 7c 24 34	 mov	 edi, DWORD PTR _ar$[esp+16472]
  00193	03 fb		 add	 edi, ebx
  00195	53		 push	 ebx
  00196	8d 4c 24 30	 lea	 ecx, DWORD PTR _ar$[esp+16468]
  0019a	89 7c 24 38	 mov	 DWORD PTR _ar$[esp+16476], edi
  0019e	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  001a3	8b 4c 24 34	 mov	 ecx, DWORD PTR _ar$[esp+16472]
  001a7	8b 94 24 74 40
	00 00		 mov	 edx, DWORD PTR _dwStateFlag$[esp+16460]
  001ae	89 11		 mov	 DWORD PTR [ecx], edx
  001b0	8b 54 24 34	 mov	 edx, DWORD PTR _ar$[esp+16472]
  001b4	03 d3		 add	 edx, ebx
  001b6	53		 push	 ebx
  001b7	8d 4c 24 30	 lea	 ecx, DWORD PTR _ar$[esp+16468]
  001bb	89 54 24 38	 mov	 DWORD PTR _ar$[esp+16476], edx
  001bf	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  001c4	8b 44 24 34	 mov	 eax, DWORD PTR _ar$[esp+16472]
  001c8	8b 8c 24 78 40
	00 00		 mov	 ecx, DWORD PTR _dwMotion$[esp+16460]
  001cf	89 08		 mov	 DWORD PTR [eax], ecx
  001d1	8b 44 24 34	 mov	 eax, DWORD PTR _ar$[esp+16472]
  001d5	03 c3		 add	 eax, ebx
  001d7	53		 push	 ebx
  001d8	8d 4c 24 30	 lea	 ecx, DWORD PTR _ar$[esp+16468]
  001dc	89 44 24 38	 mov	 DWORD PTR _ar$[esp+16476], eax
  001e0	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  001e5	8b 54 24 34	 mov	 edx, DWORD PTR _ar$[esp+16472]
  001e9	8b 84 24 7c 40
	00 00		 mov	 eax, DWORD PTR _nMotionEx$[esp+16460]
  001f0	89 02		 mov	 DWORD PTR [edx], eax
  001f2	8b 74 24 34	 mov	 esi, DWORD PTR _ar$[esp+16472]
  001f6	03 f3		 add	 esi, ebx

; 4946 : 	ar << nLoop << dwMotionOption << nTickCount;

  001f8	53		 push	 ebx
  001f9	8d 4c 24 30	 lea	 ecx, DWORD PTR _ar$[esp+16468]
  001fd	89 74 24 38	 mov	 DWORD PTR _ar$[esp+16476], esi
  00201	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00206	8b 4c 24 34	 mov	 ecx, DWORD PTR _ar$[esp+16472]
  0020a	8b 94 24 80 40
	00 00		 mov	 edx, DWORD PTR _nLoop$[esp+16460]
  00211	89 11		 mov	 DWORD PTR [ecx], edx
  00213	01 5c 24 34	 add	 DWORD PTR _ar$[esp+16472], ebx
  00217	53		 push	 ebx
  00218	8d 4c 24 30	 lea	 ecx, DWORD PTR _ar$[esp+16468]
  0021c	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00221	8b 44 24 34	 mov	 eax, DWORD PTR _ar$[esp+16472]
  00225	8b 8c 24 84 40
	00 00		 mov	 ecx, DWORD PTR _dwMotionOption$[esp+16460]
  0022c	8b 94 24 88 40
	00 00		 mov	 edx, DWORD PTR _nTickCount$[esp+16460]
  00233	89 08		 mov	 DWORD PTR [eax], ecx
  00235	8b 7c 24 34	 mov	 edi, DWORD PTR _ar$[esp+16472]
  00239	8b 84 24 8c 40
	00 00		 mov	 eax, DWORD PTR _nTickCount$[esp+16464]
  00240	6a 08		 push	 8
  00242	8d 4c 24 14	 lea	 ecx, DWORD PTR $T322681[esp+16468]
  00246	51		 push	 ecx
  00247	03 fb		 add	 edi, ebx
  00249	8d 4c 24 34	 lea	 ecx, DWORD PTR _ar$[esp+16472]
  0024d	89 7c 24 3c	 mov	 DWORD PTR _ar$[esp+16480], edi
  00251	89 54 24 18	 mov	 DWORD PTR $T322681[esp+16472], edx
  00255	89 44 24 1c	 mov	 DWORD PTR $T322681[esp+16476], eax
  00259	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write

; 4947 : 	
; 4948 : 	GETBLOCK( ar, lpBuf, nBufSize );

  0025e	8d 54 24 1c	 lea	 edx, DWORD PTR _nBufSize$[esp+16464]
  00262	52		 push	 edx
  00263	8d 4c 24 30	 lea	 ecx, DWORD PTR _ar$[esp+16468]
  00267	e8 00 00 00 00	 call	 ?GetBuffer@CAr@@QAEPAEPAH@Z ; CAr::GetBuffer

; 4949 : 
; 4950 : 	FOR_VISIBILITYRANGE( pMover )

  0026c	8b bd 10 02 00
	00		 mov	 edi, DWORD PTR [ebp+528]
  00272	8b 37		 mov	 esi, DWORD PTR [edi]
  00274	3b f7		 cmp	 esi, edi
  00276	8b d8		 mov	 ebx, eax
  00278	0f 84 80 00 00
	00		 je	 $L281409
  0027e	8b ff		 npad	 2
$L281408:

; 4951 : 		if( fTransferToMe || USERPTR != pMover )

  00280	8b 84 24 90 40
	00 00		 mov	 eax, DWORD PTR _fTransferToMe$[esp+16460]
  00287	85 c0		 test	 eax, eax
  00289	75 05		 jne	 SHORT $L281411
  0028b	39 6e 10	 cmp	 DWORD PTR [esi+16], ebp
  0028e	74 21		 je	 SHORT $L322790
$L281411:

; 4952 : 			USERPTR->AddBlock( lpBuf, nBufSize );

  00290	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00293	f6 40 04 01	 test	 BYTE PTR [eax+4], 1
  00297	8b 4c 24 1c	 mov	 ecx, DWORD PTR _nBufSize$[esp+16464]
  0029b	75 14		 jne	 SHORT $L322790
  0029d	66 ff 80 0c 57
	00 00		 inc	 WORD PTR [eax+22284]
  002a4	51		 push	 ecx
  002a5	53		 push	 ebx
  002a6	8d 88 f8 16 00
	00		 lea	 ecx, DWORD PTR [eax+5880]
  002ac	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
$L322790:

; 4953 : 	NEXT_VISIBILITYRANGE( pMover )

  002b1	8a 46 15	 mov	 al, BYTE PTR [esi+21]
  002b4	84 c0		 test	 al, al
  002b6	75 42		 jne	 SHORT $L322938
  002b8	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  002bb	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  002be	84 c9		 test	 cl, cl
  002c0	75 1b		 jne	 SHORT $L322951
  002c2	8b f0		 mov	 esi, eax
  002c4	8b 06		 mov	 eax, DWORD PTR [esi]
  002c6	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  002c9	84 c9		 test	 cl, cl
  002cb	75 2d		 jne	 SHORT $L322938
  002cd	8d 49 00	 npad	 3
$L322926:
  002d0	8b f0		 mov	 esi, eax
  002d2	8b 06		 mov	 eax, DWORD PTR [esi]
  002d4	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  002d7	84 c9		 test	 cl, cl
  002d9	74 f5		 je	 SHORT $L322926
  002db	eb 1d		 jmp	 SHORT $L322938
$L322951:
  002dd	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  002e0	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  002e3	84 c9		 test	 cl, cl
  002e5	75 11		 jne	 SHORT $L322941
$L322940:
  002e7	3b 70 08	 cmp	 esi, DWORD PTR [eax+8]
  002ea	75 0c		 jne	 SHORT $L322941
  002ec	8b f0		 mov	 esi, eax
  002ee	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  002f1	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  002f4	84 c9		 test	 cl, cl
  002f6	74 ef		 je	 SHORT $L322940
$L322941:
  002f8	8b f0		 mov	 esi, eax
$L322938:

; 4949 : 
; 4950 : 	FOR_VISIBILITYRANGE( pMover )

  002fa	3b f7		 cmp	 esi, edi
  002fc	75 82		 jne	 SHORT $L281408
$L281409:

; 4954 : }

  002fe	8d 4c 24 2c	 lea	 ecx, DWORD PTR _ar$[esp+16464]
  00302	c7 84 24 4c 40
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+16472], -1
  0030d	e8 00 00 00 00	 call	 ??1CAr@@QAE@XZ		; CAr::~CAr
  00312	8b 8c 24 44 40
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+16464]
  00319	5f		 pop	 edi
  0031a	5e		 pop	 esi
  0031b	5d		 pop	 ebp
  0031c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00323	8b 8c 24 34 40
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+16452]
  0032a	5b		 pop	 ebx
  0032b	33 cc		 xor	 ecx, esp
  0032d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00332	81 c4 40 40 00
	00		 add	 esp, 16448		; 00004040H
  00338	c2 40 00	 ret	 64			; 00000040H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L322618:
  00000	8d 8d dc bf ff
	ff		 lea	 ecx, DWORD PTR _ar$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CAr@@QAE@XZ		; CAr::~CAr
__ehhandler$?AddMoverBehavior2@CUserMng@@QAEXPAVCMover@@AAUD3DXVECTOR3@@1MMMMKKKHHK_JH@Z:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T322948
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?AddMoverBehavior2@CUserMng@@QAEXPAVCMover@@AAUD3DXVECTOR3@@1MMMMKKKHHK_JH@Z ENDP ; CUserMng::AddMoverBehavior2
PUBLIC	?AddMoverAngle@CUserMng@@QAEXPAVCMover@@AAUD3DXVECTOR3@@1MMMM_J@Z ; CUserMng::AddMoverAngle
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
xdata$x	SEGMENT
$T323275 DD	0ffffffffH
	DD	FLAT:$L322965
$T323267 DD	019930520H
	DD	01H
	DD	FLAT:$T323275
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
xdata$x	ENDS
;	COMDAT ?AddMoverAngle@CUserMng@@QAEXPAVCMover@@AAUD3DXVECTOR3@@1MMMM_J@Z
_TEXT	SEGMENT
_nBufSize$ = -16456					; size = 4
$T323000 = -16452					; size = 8
$T322980 = -16444					; size = 12
$T322984 = -16432					; size = 12
_ar$ = -16420						; size = 16404
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_pMover$ = 8						; size = 4
_v$ = 12						; size = 4
_vd$ = 16						; size = 4
_f$ = 20						; size = 4
_fAngleX$ = 24						; size = 4
_fAccPower$ = 28					; size = 4
_fTurnAngle$ = 32					; size = 4
_nTickCount$ = 36					; size = 8
?AddMoverAngle@CUserMng@@QAEXPAVCMover@@AAUD3DXVECTOR3@@1MMMM_J@Z PROC NEAR ; CUserMng::AddMoverAngle, COMDAT
; _this$ = ecx

; 4958 : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?AddMoverAngle@CUserMng@@QAEXPAVCMover@@AAUD3DXVECTOR3@@1MMMM_J@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	b8 3c 40 00 00	 mov	 eax, 16444		; 0000403cH
  00013	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0001a	e8 00 00 00 00	 call	 __chkstk
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00024	33 c4		 xor	 eax, esp
  00026	53		 push	 ebx
  00027	55		 push	 ebp
  00028	8b ac 24 54 40
	00 00		 mov	 ebp, DWORD PTR _pMover$[esp+16460]
  0002f	56		 push	 esi
  00030	8b b4 24 5c 40
	00 00		 mov	 esi, DWORD PTR _v$[esp+16464]
  00037	57		 push	 edi
  00038	8b bc 24 64 40
	00 00		 mov	 edi, DWORD PTR _vd$[esp+16468]

; 4959 : 	CAr ar;

  0003f	6a 00		 push	 0
  00041	6a 00		 push	 0
  00043	8d 4c 24 3c	 lea	 ecx, DWORD PTR _ar$[esp+16480]
  00047	89 84 24 50 40
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+16480], eax
  0004e	e8 00 00 00 00	 call	 ??0CAr@@QAE@PAXI@Z	; CAr::CAr

; 4960 : 	ar << GETID( pMover ) << SNAPSHOTTYPE_MOVERANGLE;

  00053	85 ed		 test	 ebp, ebp
  00055	c7 84 24 54 40
	00 00 00 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+16480], 0
  00060	74 08		 je	 SHORT $L322963
  00062	8b 9d bc 01 00
	00		 mov	 ebx, DWORD PTR [ebp+444]
  00068	eb 03		 jmp	 SHORT $L322964
$L322963:
  0006a	83 cb ff	 or	 ebx, -1
$L322964:
  0006d	6a 04		 push	 4
  0006f	8d 4c 24 38	 lea	 ecx, DWORD PTR _ar$[esp+16476]
  00073	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00078	8b 44 24 3c	 mov	 eax, DWORD PTR _ar$[esp+16480]
  0007c	89 18		 mov	 DWORD PTR [eax], ebx
  0007e	8b 4c 24 3c	 mov	 ecx, DWORD PTR _ar$[esp+16480]
  00082	bb 04 00 00 00	 mov	 ebx, 4
  00087	03 cb		 add	 ecx, ebx
  00089	89 4c 24 3c	 mov	 DWORD PTR _ar$[esp+16480], ecx
  0008d	6a 02		 push	 2
  0008f	8d 4c 24 38	 lea	 ecx, DWORD PTR _ar$[esp+16476]
  00093	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00098	8b 4c 24 3c	 mov	 ecx, DWORD PTR _ar$[esp+16480]
  0009c	66 c7 01 ce 00	 mov	 WORD PTR [ecx], 206	; 000000ceH
  000a1	8b 54 24 3c	 mov	 edx, DWORD PTR _ar$[esp+16480]

; 4961 : 	ar << v << vd << f << fAngleX << fAccPower << fTurnAngle << nTickCount;

  000a5	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  000a8	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000ab	83 c2 02	 add	 edx, 2
  000ae	89 54 24 3c	 mov	 DWORD PTR _ar$[esp+16480], edx
  000b2	8b 16		 mov	 edx, DWORD PTR [esi]
  000b4	89 54 24 1c	 mov	 DWORD PTR $T322980[esp+16472], edx
  000b8	6a 0c		 push	 12			; 0000000cH
  000ba	8d 54 24 20	 lea	 edx, DWORD PTR $T322980[esp+16476]
  000be	89 4c 24 28	 mov	 DWORD PTR $T322980[esp+16484], ecx
  000c2	52		 push	 edx
  000c3	8d 4c 24 3c	 lea	 ecx, DWORD PTR _ar$[esp+16480]
  000c7	89 44 24 28	 mov	 DWORD PTR $T322980[esp+16484], eax
  000cb	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
  000d0	8b 07		 mov	 eax, DWORD PTR [edi]
  000d2	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  000d5	8b 57 08	 mov	 edx, DWORD PTR [edi+8]
  000d8	89 44 24 28	 mov	 DWORD PTR $T322984[esp+16472], eax
  000dc	6a 0c		 push	 12			; 0000000cH
  000de	8d 44 24 2c	 lea	 eax, DWORD PTR $T322984[esp+16476]
  000e2	89 4c 24 30	 mov	 DWORD PTR $T322984[esp+16480], ecx
  000e6	50		 push	 eax
  000e7	8d 4c 24 3c	 lea	 ecx, DWORD PTR _ar$[esp+16480]
  000eb	89 54 24 38	 mov	 DWORD PTR $T322984[esp+16488], edx
  000ef	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
  000f4	53		 push	 ebx
  000f5	8d 4c 24 38	 lea	 ecx, DWORD PTR _ar$[esp+16476]
  000f9	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000fe	d9 84 24 68 40
	00 00		 fld	 DWORD PTR _f$[esp+16468]
  00105	8b 4c 24 3c	 mov	 ecx, DWORD PTR _ar$[esp+16480]
  00109	d9 19		 fstp	 DWORD PTR [ecx]
  0010b	8b 44 24 3c	 mov	 eax, DWORD PTR _ar$[esp+16480]
  0010f	03 c3		 add	 eax, ebx
  00111	53		 push	 ebx
  00112	8d 4c 24 38	 lea	 ecx, DWORD PTR _ar$[esp+16476]
  00116	89 44 24 40	 mov	 DWORD PTR _ar$[esp+16484], eax
  0011a	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0011f	d9 84 24 6c 40
	00 00		 fld	 DWORD PTR _fAngleX$[esp+16468]
  00126	8b 54 24 3c	 mov	 edx, DWORD PTR _ar$[esp+16480]
  0012a	d9 1a		 fstp	 DWORD PTR [edx]
  0012c	8b 74 24 3c	 mov	 esi, DWORD PTR _ar$[esp+16480]
  00130	03 f3		 add	 esi, ebx
  00132	53		 push	 ebx
  00133	8d 4c 24 38	 lea	 ecx, DWORD PTR _ar$[esp+16476]
  00137	89 74 24 40	 mov	 DWORD PTR _ar$[esp+16484], esi
  0013b	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00140	d9 84 24 70 40
	00 00		 fld	 DWORD PTR _fAccPower$[esp+16468]
  00147	8b 44 24 3c	 mov	 eax, DWORD PTR _ar$[esp+16480]
  0014b	d9 18		 fstp	 DWORD PTR [eax]
  0014d	8b 4c 24 3c	 mov	 ecx, DWORD PTR _ar$[esp+16480]
  00151	03 cb		 add	 ecx, ebx
  00153	89 4c 24 3c	 mov	 DWORD PTR _ar$[esp+16480], ecx
  00157	53		 push	 ebx
  00158	8d 4c 24 38	 lea	 ecx, DWORD PTR _ar$[esp+16476]
  0015c	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00161	d9 84 24 74 40
	00 00		 fld	 DWORD PTR _fTurnAngle$[esp+16468]
  00168	8b 4c 24 3c	 mov	 ecx, DWORD PTR _ar$[esp+16480]
  0016c	8b 94 24 78 40
	00 00		 mov	 edx, DWORD PTR _nTickCount$[esp+16468]
  00173	d9 19		 fstp	 DWORD PTR [ecx]
  00175	8b 7c 24 3c	 mov	 edi, DWORD PTR _ar$[esp+16480]
  00179	8b 84 24 7c 40
	00 00		 mov	 eax, DWORD PTR _nTickCount$[esp+16472]
  00180	03 fb		 add	 edi, ebx
  00182	89 7c 24 3c	 mov	 DWORD PTR _ar$[esp+16480], edi
  00186	89 54 24 14	 mov	 DWORD PTR $T323000[esp+16472], edx
  0018a	89 44 24 18	 mov	 DWORD PTR $T323000[esp+16476], eax
  0018e	6a 08		 push	 8
  00190	8d 4c 24 18	 lea	 ecx, DWORD PTR $T323000[esp+16476]
  00194	51		 push	 ecx
  00195	8d 4c 24 3c	 lea	 ecx, DWORD PTR _ar$[esp+16480]
  00199	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write

; 4962 : 	
; 4963 : 	GETBLOCK( ar, lpBuf, nBufSize );

  0019e	8d 54 24 10	 lea	 edx, DWORD PTR _nBufSize$[esp+16472]
  001a2	52		 push	 edx
  001a3	8d 4c 24 38	 lea	 ecx, DWORD PTR _ar$[esp+16476]
  001a7	e8 00 00 00 00	 call	 ?GetBuffer@CAr@@QAEPAEPAH@Z ; CAr::GetBuffer

; 4964 : 	
; 4965 : 	FOR_VISIBILITYRANGE( pMover )

  001ac	8b bd 10 02 00
	00		 mov	 edi, DWORD PTR [ebp+528]
  001b2	8b 37		 mov	 esi, DWORD PTR [edi]
  001b4	3b f7		 cmp	 esi, edi
  001b6	8b d8		 mov	 ebx, eax
  001b8	74 75		 je	 SHORT $L281443
  001ba	8d 9b 00 00 00
	00		 npad	 6
$L281442:

; 4966 : 		if( USERPTR != pMover )

  001c0	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  001c3	3b c5		 cmp	 eax, ebp
  001c5	74 1e		 je	 SHORT $L323106

; 4967 : 			USERPTR->AddBlock( lpBuf, nBufSize );

  001c7	f6 40 04 01	 test	 BYTE PTR [eax+4], 1
  001cb	8b 4c 24 10	 mov	 ecx, DWORD PTR _nBufSize$[esp+16472]
  001cf	75 14		 jne	 SHORT $L323106
  001d1	66 ff 80 0c 57
	00 00		 inc	 WORD PTR [eax+22284]
  001d8	51		 push	 ecx
  001d9	53		 push	 ebx
  001da	8d 88 f8 16 00
	00		 lea	 ecx, DWORD PTR [eax+5880]
  001e0	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
$L323106:

; 4968 : 	NEXT_VISIBILITYRANGE( pMover )

  001e5	8a 46 15	 mov	 al, BYTE PTR [esi+21]
  001e8	84 c0		 test	 al, al
  001ea	75 3f		 jne	 SHORT $L323233
  001ec	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  001ef	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  001f2	84 c9		 test	 cl, cl
  001f4	75 18		 jne	 SHORT $L323270
  001f6	8b f0		 mov	 esi, eax
  001f8	8b 06		 mov	 eax, DWORD PTR [esi]
  001fa	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  001fd	84 c9		 test	 cl, cl
  001ff	75 2a		 jne	 SHORT $L323233
$L323254:
  00201	8b f0		 mov	 esi, eax
  00203	8b 06		 mov	 eax, DWORD PTR [esi]
  00205	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00208	84 c9		 test	 cl, cl
  0020a	74 f5		 je	 SHORT $L323254
  0020c	eb 1d		 jmp	 SHORT $L323233
$L323270:
  0020e	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00211	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00214	84 c9		 test	 cl, cl
  00216	75 11		 jne	 SHORT $L323236
$L323235:
  00218	3b 70 08	 cmp	 esi, DWORD PTR [eax+8]
  0021b	75 0c		 jne	 SHORT $L323236
  0021d	8b f0		 mov	 esi, eax
  0021f	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00222	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00225	84 c9		 test	 cl, cl
  00227	74 ef		 je	 SHORT $L323235
$L323236:
  00229	8b f0		 mov	 esi, eax
$L323233:

; 4964 : 	
; 4965 : 	FOR_VISIBILITYRANGE( pMover )

  0022b	3b f7		 cmp	 esi, edi
  0022d	75 91		 jne	 SHORT $L281442
$L281443:

; 4969 : }

  0022f	8d 4c 24 34	 lea	 ecx, DWORD PTR _ar$[esp+16472]
  00233	c7 84 24 54 40
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+16480], -1
  0023e	e8 00 00 00 00	 call	 ??1CAr@@QAE@XZ		; CAr::~CAr
  00243	8b 8c 24 4c 40
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+16472]
  0024a	5f		 pop	 edi
  0024b	5e		 pop	 esi
  0024c	5d		 pop	 ebp
  0024d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00254	8b 8c 24 3c 40
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+16460]
  0025b	5b		 pop	 ebx
  0025c	33 cc		 xor	 ecx, esp
  0025e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00263	81 c4 48 40 00
	00		 add	 esp, 16456		; 00004048H
  00269	c2 24 00	 ret	 36			; 00000024H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L322965:
  00000	8d 8d dc bf ff
	ff		 lea	 ecx, DWORD PTR _ar$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CAr@@QAE@XZ		; CAr::~CAr
__ehhandler$?AddMoverAngle@CUserMng@@QAEXPAVCMover@@AAUD3DXVECTOR3@@1MMMM_J@Z:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T323267
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?AddMoverAngle@CUserMng@@QAEXPAVCMover@@AAUD3DXVECTOR3@@1MMMM_J@Z ENDP ; CUserMng::AddMoverAngle
PUBLIC	?AddMoverCorr@CUserMng@@QAEXPAVCMover@@AAUD3DXVECTOR3@@1MKKKHHK_J@Z ; CUserMng::AddMoverCorr
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
xdata$x	SEGMENT
$T323617 DD	0ffffffffH
	DD	FLAT:$L323284
$T323609 DD	019930520H
	DD	01H
	DD	FLAT:$T323617
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
xdata$x	ENDS
;	COMDAT ?AddMoverCorr@CUserMng@@QAEXPAVCMover@@AAUD3DXVECTOR3@@1MKKKHHK_J@Z
_TEXT	SEGMENT
$T323342 = -16448					; size = 8
$T323303 = -16448					; size = 12
_nBufSize$ = -16436					; size = 4
$T323307 = -16432					; size = 12
_ar$ = -16420						; size = 16404
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_pMover$ = 8						; size = 4
_v$ = 12						; size = 4
_vd$ = 16						; size = 4
_f$ = 20						; size = 4
_dwState$ = 24						; size = 4
_dwStateFlag$ = 28					; size = 4
_dwMotion$ = 32						; size = 4
_nMotionEx$ = 36					; size = 4
_nLoop$ = 40						; size = 4
_dwMotionOption$ = 44					; size = 4
_nTickCount$ = 48					; size = 8
?AddMoverCorr@CUserMng@@QAEXPAVCMover@@AAUD3DXVECTOR3@@1MKKKHHK_J@Z PROC NEAR ; CUserMng::AddMoverCorr, COMDAT
; _this$ = ecx

; 4977 : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?AddMoverCorr@CUserMng@@QAEXPAVCMover@@AAUD3DXVECTOR3@@1MKKKHHK_J@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	b8 34 40 00 00	 mov	 eax, 16436		; 00004034H
  00013	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0001a	e8 00 00 00 00	 call	 __chkstk
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00024	33 c4		 xor	 eax, esp
  00026	55		 push	 ebp
  00027	8b ac 24 48 40
	00 00		 mov	 ebp, DWORD PTR _pMover$[esp+16448]

; 4978 : 	if( pMover )

  0002e	85 ed		 test	 ebp, ebp
  00030	56		 push	 esi
  00031	8b b4 24 50 40
	00 00		 mov	 esi, DWORD PTR _v$[esp+16452]
  00038	57		 push	 edi
  00039	8b bc 24 58 40
	00 00		 mov	 edi, DWORD PTR _vd$[esp+16456]
  00040	89 84 24 3c 40
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+16460], eax
  00047	74 13		 je	 SHORT $L281460

; 4979 : 	{
; 4980 : 		if( (pMover->m_pActMover->GetState() & OBJSTA_DMG_FLY) )

  00049	8b 85 3c 02 00
	00		 mov	 eax, DWORD PTR [ebp+572]
  0004f	f7 40 04 00 00
	00 02		 test	 DWORD PTR [eax+4], 33554432 ; 02000000H
  00056	0f 85 58 02 00
	00		 jne	 $L281458
$L281460:
  0005c	53		 push	 ebx

; 4981 : 		{
; 4982 : 			return;
; 4983 : 		}
; 4984 : 	}
; 4985 : 	CAr ar;

  0005d	6a 00		 push	 0
  0005f	6a 00		 push	 0
  00061	8d 4c 24 34	 lea	 ecx, DWORD PTR _ar$[esp+16472]
  00065	e8 00 00 00 00	 call	 ??0CAr@@QAE@PAXI@Z	; CAr::CAr

; 4986 : 	ar << GETID( pMover ) << SNAPSHOTTYPE_MOVERCORR;

  0006a	85 ed		 test	 ebp, ebp
  0006c	c7 84 24 4c 40
	00 00 00 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+16472], 0
  00077	74 08		 je	 SHORT $L323282
  00079	8b 9d bc 01 00
	00		 mov	 ebx, DWORD PTR [ebp+444]
  0007f	eb 03		 jmp	 SHORT $L323283
$L323282:
  00081	83 cb ff	 or	 ebx, -1
$L323283:
  00084	6a 04		 push	 4
  00086	8d 4c 24 30	 lea	 ecx, DWORD PTR _ar$[esp+16468]
  0008a	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0008f	8b 4c 24 34	 mov	 ecx, DWORD PTR _ar$[esp+16472]
  00093	89 19		 mov	 DWORD PTR [ecx], ebx
  00095	8b 54 24 34	 mov	 edx, DWORD PTR _ar$[esp+16472]
  00099	bb 04 00 00 00	 mov	 ebx, 4
  0009e	03 d3		 add	 edx, ebx
  000a0	6a 02		 push	 2
  000a2	8d 4c 24 30	 lea	 ecx, DWORD PTR _ar$[esp+16468]
  000a6	89 54 24 38	 mov	 DWORD PTR _ar$[esp+16476], edx
  000aa	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000af	8b 54 24 34	 mov	 edx, DWORD PTR _ar$[esp+16472]
  000b3	66 c7 02 c8 00	 mov	 WORD PTR [edx], 200	; 000000c8H
  000b8	8b 44 24 34	 mov	 eax, DWORD PTR _ar$[esp+16472]

; 4987 : 	ar << v << vd << f;

  000bc	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  000bf	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  000c2	83 c0 02	 add	 eax, 2
  000c5	89 44 24 34	 mov	 DWORD PTR _ar$[esp+16472], eax
  000c9	8b 06		 mov	 eax, DWORD PTR [esi]
  000cb	89 44 24 10	 mov	 DWORD PTR $T323303[esp+16464], eax
  000cf	6a 0c		 push	 12			; 0000000cH
  000d1	8d 44 24 14	 lea	 eax, DWORD PTR $T323303[esp+16468]
  000d5	89 4c 24 18	 mov	 DWORD PTR $T323303[esp+16472], ecx
  000d9	50		 push	 eax
  000da	8d 4c 24 34	 lea	 ecx, DWORD PTR _ar$[esp+16472]
  000de	89 54 24 20	 mov	 DWORD PTR $T323303[esp+16480], edx
  000e2	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
  000e7	8b 0f		 mov	 ecx, DWORD PTR [edi]
  000e9	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  000ec	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  000ef	89 4c 24 20	 mov	 DWORD PTR $T323307[esp+16464], ecx
  000f3	6a 0c		 push	 12			; 0000000cH
  000f5	8d 4c 24 24	 lea	 ecx, DWORD PTR $T323307[esp+16468]
  000f9	51		 push	 ecx
  000fa	8d 4c 24 34	 lea	 ecx, DWORD PTR _ar$[esp+16472]
  000fe	89 54 24 2c	 mov	 DWORD PTR $T323307[esp+16476], edx
  00102	89 44 24 30	 mov	 DWORD PTR $T323307[esp+16480], eax
  00106	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
  0010b	53		 push	 ebx
  0010c	8d 4c 24 30	 lea	 ecx, DWORD PTR _ar$[esp+16468]
  00110	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00115	d9 84 24 60 40
	00 00		 fld	 DWORD PTR _f$[esp+16460]
  0011c	8b 54 24 34	 mov	 edx, DWORD PTR _ar$[esp+16472]
  00120	d9 1a		 fstp	 DWORD PTR [edx]
  00122	8b 54 24 34	 mov	 edx, DWORD PTR _ar$[esp+16472]
  00126	03 d3		 add	 edx, ebx

; 4988 : 	ar << dwState << dwStateFlag << dwMotion << nMotionEx;

  00128	53		 push	 ebx
  00129	8d 4c 24 30	 lea	 ecx, DWORD PTR _ar$[esp+16468]
  0012d	89 54 24 38	 mov	 DWORD PTR _ar$[esp+16476], edx
  00131	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00136	8b 44 24 34	 mov	 eax, DWORD PTR _ar$[esp+16472]
  0013a	8b 8c 24 64 40
	00 00		 mov	 ecx, DWORD PTR _dwState$[esp+16460]
  00141	89 08		 mov	 DWORD PTR [eax], ecx
  00143	8b 44 24 34	 mov	 eax, DWORD PTR _ar$[esp+16472]
  00147	03 c3		 add	 eax, ebx
  00149	53		 push	 ebx
  0014a	8d 4c 24 30	 lea	 ecx, DWORD PTR _ar$[esp+16468]
  0014e	89 44 24 38	 mov	 DWORD PTR _ar$[esp+16476], eax
  00152	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00157	8b 54 24 34	 mov	 edx, DWORD PTR _ar$[esp+16472]
  0015b	8b 84 24 68 40
	00 00		 mov	 eax, DWORD PTR _dwStateFlag$[esp+16460]
  00162	89 02		 mov	 DWORD PTR [edx], eax
  00164	8b 74 24 34	 mov	 esi, DWORD PTR _ar$[esp+16472]
  00168	03 f3		 add	 esi, ebx
  0016a	53		 push	 ebx
  0016b	8d 4c 24 30	 lea	 ecx, DWORD PTR _ar$[esp+16468]
  0016f	89 74 24 38	 mov	 DWORD PTR _ar$[esp+16476], esi
  00173	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00178	8b 4c 24 34	 mov	 ecx, DWORD PTR _ar$[esp+16472]
  0017c	8b 94 24 6c 40
	00 00		 mov	 edx, DWORD PTR _dwMotion$[esp+16460]
  00183	89 11		 mov	 DWORD PTR [ecx], edx
  00185	01 5c 24 34	 add	 DWORD PTR _ar$[esp+16472], ebx
  00189	53		 push	 ebx
  0018a	8d 4c 24 30	 lea	 ecx, DWORD PTR _ar$[esp+16468]
  0018e	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00193	8b 44 24 34	 mov	 eax, DWORD PTR _ar$[esp+16472]
  00197	8b 8c 24 70 40
	00 00		 mov	 ecx, DWORD PTR _nMotionEx$[esp+16460]
  0019e	89 08		 mov	 DWORD PTR [eax], ecx
  001a0	8b 7c 24 34	 mov	 edi, DWORD PTR _ar$[esp+16472]
  001a4	03 fb		 add	 edi, ebx

; 4989 : 	ar << nLoop << dwMotionOption << nTickCount;

  001a6	53		 push	 ebx
  001a7	8d 4c 24 30	 lea	 ecx, DWORD PTR _ar$[esp+16468]
  001ab	89 7c 24 38	 mov	 DWORD PTR _ar$[esp+16476], edi
  001af	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  001b4	8b 54 24 34	 mov	 edx, DWORD PTR _ar$[esp+16472]
  001b8	8b 84 24 74 40
	00 00		 mov	 eax, DWORD PTR _nLoop$[esp+16460]
  001bf	89 02		 mov	 DWORD PTR [edx], eax
  001c1	8b 54 24 34	 mov	 edx, DWORD PTR _ar$[esp+16472]
  001c5	03 d3		 add	 edx, ebx
  001c7	53		 push	 ebx
  001c8	8d 4c 24 30	 lea	 ecx, DWORD PTR _ar$[esp+16468]
  001cc	89 54 24 38	 mov	 DWORD PTR _ar$[esp+16476], edx
  001d0	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  001d5	8b 4c 24 34	 mov	 ecx, DWORD PTR _ar$[esp+16472]
  001d9	8b 94 24 78 40
	00 00		 mov	 edx, DWORD PTR _dwMotionOption$[esp+16460]
  001e0	89 11		 mov	 DWORD PTR [ecx], edx
  001e2	8b 44 24 34	 mov	 eax, DWORD PTR _ar$[esp+16472]
  001e6	8b 8c 24 80 40
	00 00		 mov	 ecx, DWORD PTR _nTickCount$[esp+16464]
  001ed	03 c3		 add	 eax, ebx
  001ef	89 44 24 34	 mov	 DWORD PTR _ar$[esp+16472], eax
  001f3	8b 84 24 7c 40
	00 00		 mov	 eax, DWORD PTR _nTickCount$[esp+16460]
  001fa	6a 08		 push	 8
  001fc	8d 54 24 14	 lea	 edx, DWORD PTR $T323342[esp+16468]
  00200	89 4c 24 18	 mov	 DWORD PTR $T323342[esp+16472], ecx
  00204	52		 push	 edx
  00205	8d 4c 24 34	 lea	 ecx, DWORD PTR _ar$[esp+16472]
  00209	89 44 24 18	 mov	 DWORD PTR $T323342[esp+16472], eax
  0020d	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write

; 4990 : 	
; 4991 : 	GETBLOCK( ar, lpBuf, nBufSize );

  00212	8d 44 24 1c	 lea	 eax, DWORD PTR _nBufSize$[esp+16464]
  00216	50		 push	 eax
  00217	8d 4c 24 30	 lea	 ecx, DWORD PTR _ar$[esp+16468]
  0021b	e8 00 00 00 00	 call	 ?GetBuffer@CAr@@QAEPAEPAH@Z ; CAr::GetBuffer

; 4992 : 
; 4993 : 	FOR_VISIBILITYRANGE( pMover )

  00220	8b bd 10 02 00
	00		 mov	 edi, DWORD PTR [ebp+528]
  00226	8b 37		 mov	 esi, DWORD PTR [edi]
  00228	3b f7		 cmp	 esi, edi
  0022a	8b d8		 mov	 ebx, eax
  0022c	74 71		 je	 SHORT $L281481
  0022e	8b ff		 npad	 2
$L281480:

; 4994 : 		if( USERPTR != pMover )

  00230	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00233	3b c5		 cmp	 eax, ebp
  00235	74 1e		 je	 SHORT $L323448

; 4995 : 			USERPTR->AddBlock( lpBuf, nBufSize );

  00237	f6 40 04 01	 test	 BYTE PTR [eax+4], 1
  0023b	8b 4c 24 1c	 mov	 ecx, DWORD PTR _nBufSize$[esp+16464]
  0023f	75 14		 jne	 SHORT $L323448
  00241	66 ff 80 0c 57
	00 00		 inc	 WORD PTR [eax+22284]
  00248	51		 push	 ecx
  00249	53		 push	 ebx
  0024a	8d 88 f8 16 00
	00		 lea	 ecx, DWORD PTR [eax+5880]
  00250	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
$L323448:

; 4996 : 	NEXT_VISIBILITYRANGE( pMover )

  00255	8a 46 15	 mov	 al, BYTE PTR [esi+21]
  00258	84 c0		 test	 al, al
  0025a	75 3f		 jne	 SHORT $L323576
  0025c	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0025f	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00262	84 c9		 test	 cl, cl
  00264	75 18		 jne	 SHORT $L323612
  00266	8b f0		 mov	 esi, eax
  00268	8b 06		 mov	 eax, DWORD PTR [esi]
  0026a	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  0026d	84 c9		 test	 cl, cl
  0026f	75 2a		 jne	 SHORT $L323576
$L323590:
  00271	8b f0		 mov	 esi, eax
  00273	8b 06		 mov	 eax, DWORD PTR [esi]
  00275	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00278	84 c9		 test	 cl, cl
  0027a	74 f5		 je	 SHORT $L323590
  0027c	eb 1d		 jmp	 SHORT $L323576
$L323612:
  0027e	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00281	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00284	84 c9		 test	 cl, cl
  00286	75 11		 jne	 SHORT $L323579
$L323578:
  00288	3b 70 08	 cmp	 esi, DWORD PTR [eax+8]
  0028b	75 0c		 jne	 SHORT $L323579
  0028d	8b f0		 mov	 esi, eax
  0028f	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00292	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00295	84 c9		 test	 cl, cl
  00297	74 ef		 je	 SHORT $L323578
$L323579:
  00299	8b f0		 mov	 esi, eax
$L323576:

; 4992 : 
; 4993 : 	FOR_VISIBILITYRANGE( pMover )

  0029b	3b f7		 cmp	 esi, edi
  0029d	75 91		 jne	 SHORT $L281480
$L281481:

; 4997 : }

  0029f	8d 4c 24 2c	 lea	 ecx, DWORD PTR _ar$[esp+16464]
  002a3	c7 84 24 4c 40
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+16472], -1
  002ae	e8 00 00 00 00	 call	 ??1CAr@@QAE@XZ		; CAr::~CAr
  002b3	5b		 pop	 ebx
$L281458:
  002b4	8b 8c 24 40 40
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+16460]
  002bb	5f		 pop	 edi
  002bc	5e		 pop	 esi
  002bd	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  002c4	8b 8c 24 34 40
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+16452]
  002cb	5d		 pop	 ebp
  002cc	33 cc		 xor	 ecx, esp
  002ce	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002d3	81 c4 40 40 00
	00		 add	 esp, 16448		; 00004040H
  002d9	c2 30 00	 ret	 48			; 00000030H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L323284:
  00000	8d 8d dc bf ff
	ff		 lea	 ecx, DWORD PTR _ar$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CAr@@QAE@XZ		; CAr::~CAr
__ehhandler$?AddMoverCorr@CUserMng@@QAEXPAVCMover@@AAUD3DXVECTOR3@@1MKKKHHK_J@Z:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T323609
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?AddMoverCorr@CUserMng@@QAEXPAVCMover@@AAUD3DXVECTOR3@@1MKKKHHK_J@Z ENDP ; CUserMng::AddMoverCorr
PUBLIC	?AddMoverCorr2@CUserMng@@QAEXPAVCMover@@AAUD3DXVECTOR3@@1MMMMKKKHHK_J@Z ; CUserMng::AddMoverCorr2
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
xdata$x	SEGMENT
$T323964 DD	0ffffffffH
	DD	FLAT:$L323626
$T323956 DD	019930520H
	DD	01H
	DD	FLAT:$T323964
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
xdata$x	ENDS
;	COMDAT ?AddMoverCorr2@CUserMng@@QAEXPAVCMover@@AAUD3DXVECTOR3@@1MMMMKKKHHK_J@Z
_TEXT	SEGMENT
$T323689 = -16448					; size = 8
$T323641 = -16448					; size = 12
_nBufSize$ = -16436					; size = 4
$T323645 = -16432					; size = 12
_ar$ = -16420						; size = 16404
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_pMover$ = 8						; size = 4
_v$ = 12						; size = 4
_vd$ = 16						; size = 4
_f$ = 20						; size = 4
_fAngleX$ = 24						; size = 4
_fAccPower$ = 28					; size = 4
_fTurnAngle$ = 32					; size = 4
_dwState$ = 36						; size = 4
_dwStateFlag$ = 40					; size = 4
_dwMotion$ = 44						; size = 4
_nMotionEx$ = 48					; size = 4
_nLoop$ = 52						; size = 4
_dwMotionOption$ = 56					; size = 4
_nTickCount$ = 60					; size = 8
?AddMoverCorr2@CUserMng@@QAEXPAVCMover@@AAUD3DXVECTOR3@@1MMMMKKKHHK_J@Z PROC NEAR ; CUserMng::AddMoverCorr2, COMDAT
; _this$ = ecx

; 5003 : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?AddMoverCorr2@CUserMng@@QAEXPAVCMover@@AAUD3DXVECTOR3@@1MMMMKKKHHK_J@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	b8 34 40 00 00	 mov	 eax, 16436		; 00004034H
  00013	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0001a	e8 00 00 00 00	 call	 __chkstk
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00024	33 c4		 xor	 eax, esp
  00026	53		 push	 ebx
  00027	55		 push	 ebp
  00028	8b ac 24 4c 40
	00 00		 mov	 ebp, DWORD PTR _pMover$[esp+16452]
  0002f	56		 push	 esi
  00030	8b b4 24 54 40
	00 00		 mov	 esi, DWORD PTR _v$[esp+16456]
  00037	57		 push	 edi
  00038	8b bc 24 5c 40
	00 00		 mov	 edi, DWORD PTR _vd$[esp+16460]

; 5004 : 	CAr ar;

  0003f	6a 00		 push	 0
  00041	6a 00		 push	 0
  00043	8d 4c 24 34	 lea	 ecx, DWORD PTR _ar$[esp+16472]
  00047	89 84 24 48 40
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+16472], eax
  0004e	e8 00 00 00 00	 call	 ??0CAr@@QAE@PAXI@Z	; CAr::CAr

; 5005 : 	ar << GETID( pMover ) << SNAPSHOTTYPE_MOVERCORR2;

  00053	85 ed		 test	 ebp, ebp
  00055	c7 84 24 4c 40
	00 00 00 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+16472], 0
  00060	74 08		 je	 SHORT $L323624
  00062	8b 9d bc 01 00
	00		 mov	 ebx, DWORD PTR [ebp+444]
  00068	eb 03		 jmp	 SHORT $L323625
$L323624:
  0006a	83 cb ff	 or	 ebx, -1
$L323625:
  0006d	6a 04		 push	 4
  0006f	8d 4c 24 30	 lea	 ecx, DWORD PTR _ar$[esp+16468]
  00073	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00078	8b 44 24 34	 mov	 eax, DWORD PTR _ar$[esp+16472]
  0007c	89 18		 mov	 DWORD PTR [eax], ebx
  0007e	8b 54 24 34	 mov	 edx, DWORD PTR _ar$[esp+16472]
  00082	bb 04 00 00 00	 mov	 ebx, 4
  00087	03 d3		 add	 edx, ebx
  00089	6a 02		 push	 2
  0008b	8d 4c 24 30	 lea	 ecx, DWORD PTR _ar$[esp+16468]
  0008f	89 54 24 38	 mov	 DWORD PTR _ar$[esp+16476], edx
  00093	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00098	8b 4c 24 34	 mov	 ecx, DWORD PTR _ar$[esp+16472]
  0009c	66 c7 01 c9 00	 mov	 WORD PTR [ecx], 201	; 000000c9H
  000a1	8b 44 24 34	 mov	 eax, DWORD PTR _ar$[esp+16472]

; 5006 : 	ar << v << vd << f << fAngleX << fAccPower << fTurnAngle;

  000a5	8b 16		 mov	 edx, DWORD PTR [esi]
  000a7	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  000aa	83 c0 02	 add	 eax, 2
  000ad	89 54 24 10	 mov	 DWORD PTR $T323641[esp+16464], edx
  000b1	89 44 24 34	 mov	 DWORD PTR _ar$[esp+16472], eax
  000b5	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000b8	6a 0c		 push	 12			; 0000000cH
  000ba	8d 54 24 14	 lea	 edx, DWORD PTR $T323641[esp+16468]
  000be	89 4c 24 1c	 mov	 DWORD PTR $T323641[esp+16476], ecx
  000c2	52		 push	 edx
  000c3	8d 4c 24 34	 lea	 ecx, DWORD PTR _ar$[esp+16472]
  000c7	89 44 24 1c	 mov	 DWORD PTR $T323641[esp+16476], eax
  000cb	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
  000d0	8b 07		 mov	 eax, DWORD PTR [edi]
  000d2	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  000d5	8b 57 08	 mov	 edx, DWORD PTR [edi+8]
  000d8	89 44 24 20	 mov	 DWORD PTR $T323645[esp+16464], eax
  000dc	6a 0c		 push	 12			; 0000000cH
  000de	8d 44 24 24	 lea	 eax, DWORD PTR $T323645[esp+16468]
  000e2	89 4c 24 28	 mov	 DWORD PTR $T323645[esp+16472], ecx
  000e6	50		 push	 eax
  000e7	8d 4c 24 34	 lea	 ecx, DWORD PTR _ar$[esp+16472]
  000eb	89 54 24 30	 mov	 DWORD PTR $T323645[esp+16480], edx
  000ef	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
  000f4	53		 push	 ebx
  000f5	8d 4c 24 30	 lea	 ecx, DWORD PTR _ar$[esp+16468]
  000f9	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000fe	d9 84 24 60 40
	00 00		 fld	 DWORD PTR _f$[esp+16460]
  00105	8b 4c 24 34	 mov	 ecx, DWORD PTR _ar$[esp+16472]
  00109	d9 19		 fstp	 DWORD PTR [ecx]
  0010b	8b 54 24 34	 mov	 edx, DWORD PTR _ar$[esp+16472]
  0010f	03 d3		 add	 edx, ebx
  00111	53		 push	 ebx
  00112	8d 4c 24 30	 lea	 ecx, DWORD PTR _ar$[esp+16468]
  00116	89 54 24 38	 mov	 DWORD PTR _ar$[esp+16476], edx
  0011a	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0011f	d9 84 24 64 40
	00 00		 fld	 DWORD PTR _fAngleX$[esp+16460]
  00126	8b 54 24 34	 mov	 edx, DWORD PTR _ar$[esp+16472]
  0012a	d9 1a		 fstp	 DWORD PTR [edx]
  0012c	8b 44 24 34	 mov	 eax, DWORD PTR _ar$[esp+16472]
  00130	03 c3		 add	 eax, ebx
  00132	53		 push	 ebx
  00133	8d 4c 24 30	 lea	 ecx, DWORD PTR _ar$[esp+16468]
  00137	89 44 24 38	 mov	 DWORD PTR _ar$[esp+16476], eax
  0013b	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00140	d9 84 24 68 40
	00 00		 fld	 DWORD PTR _fAccPower$[esp+16460]
  00147	8b 44 24 34	 mov	 eax, DWORD PTR _ar$[esp+16472]
  0014b	d9 18		 fstp	 DWORD PTR [eax]
  0014d	8b 74 24 34	 mov	 esi, DWORD PTR _ar$[esp+16472]
  00151	03 f3		 add	 esi, ebx
  00153	53		 push	 ebx
  00154	8d 4c 24 30	 lea	 ecx, DWORD PTR _ar$[esp+16468]
  00158	89 74 24 38	 mov	 DWORD PTR _ar$[esp+16476], esi
  0015c	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00161	d9 84 24 6c 40
	00 00		 fld	 DWORD PTR _fTurnAngle$[esp+16460]
  00168	8b 4c 24 34	 mov	 ecx, DWORD PTR _ar$[esp+16472]
  0016c	d9 19		 fstp	 DWORD PTR [ecx]
  0016e	8b 4c 24 34	 mov	 ecx, DWORD PTR _ar$[esp+16472]
  00172	03 cb		 add	 ecx, ebx
  00174	89 4c 24 34	 mov	 DWORD PTR _ar$[esp+16472], ecx

; 5007 : 	ar << dwState << dwStateFlag << dwMotion << nMotionEx;

  00178	53		 push	 ebx
  00179	8d 4c 24 30	 lea	 ecx, DWORD PTR _ar$[esp+16468]
  0017d	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00182	8b 54 24 34	 mov	 edx, DWORD PTR _ar$[esp+16472]
  00186	8b 84 24 70 40
	00 00		 mov	 eax, DWORD PTR _dwState$[esp+16460]
  0018d	89 02		 mov	 DWORD PTR [edx], eax
  0018f	8b 7c 24 34	 mov	 edi, DWORD PTR _ar$[esp+16472]
  00193	03 fb		 add	 edi, ebx
  00195	53		 push	 ebx
  00196	8d 4c 24 30	 lea	 ecx, DWORD PTR _ar$[esp+16468]
  0019a	89 7c 24 38	 mov	 DWORD PTR _ar$[esp+16476], edi
  0019e	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  001a3	8b 4c 24 34	 mov	 ecx, DWORD PTR _ar$[esp+16472]
  001a7	8b 94 24 74 40
	00 00		 mov	 edx, DWORD PTR _dwStateFlag$[esp+16460]
  001ae	89 11		 mov	 DWORD PTR [ecx], edx
  001b0	8b 54 24 34	 mov	 edx, DWORD PTR _ar$[esp+16472]
  001b4	03 d3		 add	 edx, ebx
  001b6	53		 push	 ebx
  001b7	8d 4c 24 30	 lea	 ecx, DWORD PTR _ar$[esp+16468]
  001bb	89 54 24 38	 mov	 DWORD PTR _ar$[esp+16476], edx
  001bf	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  001c4	8b 44 24 34	 mov	 eax, DWORD PTR _ar$[esp+16472]
  001c8	8b 8c 24 78 40
	00 00		 mov	 ecx, DWORD PTR _dwMotion$[esp+16460]
  001cf	89 08		 mov	 DWORD PTR [eax], ecx
  001d1	8b 44 24 34	 mov	 eax, DWORD PTR _ar$[esp+16472]
  001d5	03 c3		 add	 eax, ebx
  001d7	53		 push	 ebx
  001d8	8d 4c 24 30	 lea	 ecx, DWORD PTR _ar$[esp+16468]
  001dc	89 44 24 38	 mov	 DWORD PTR _ar$[esp+16476], eax
  001e0	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  001e5	8b 54 24 34	 mov	 edx, DWORD PTR _ar$[esp+16472]
  001e9	8b 84 24 7c 40
	00 00		 mov	 eax, DWORD PTR _nMotionEx$[esp+16460]
  001f0	89 02		 mov	 DWORD PTR [edx], eax
  001f2	8b 74 24 34	 mov	 esi, DWORD PTR _ar$[esp+16472]
  001f6	03 f3		 add	 esi, ebx

; 5008 : 	ar << nLoop << dwMotionOption << nTickCount;

  001f8	53		 push	 ebx
  001f9	8d 4c 24 30	 lea	 ecx, DWORD PTR _ar$[esp+16468]
  001fd	89 74 24 38	 mov	 DWORD PTR _ar$[esp+16476], esi
  00201	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00206	8b 4c 24 34	 mov	 ecx, DWORD PTR _ar$[esp+16472]
  0020a	8b 94 24 80 40
	00 00		 mov	 edx, DWORD PTR _nLoop$[esp+16460]
  00211	89 11		 mov	 DWORD PTR [ecx], edx
  00213	01 5c 24 34	 add	 DWORD PTR _ar$[esp+16472], ebx
  00217	53		 push	 ebx
  00218	8d 4c 24 30	 lea	 ecx, DWORD PTR _ar$[esp+16468]
  0021c	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00221	8b 44 24 34	 mov	 eax, DWORD PTR _ar$[esp+16472]
  00225	8b 8c 24 84 40
	00 00		 mov	 ecx, DWORD PTR _dwMotionOption$[esp+16460]
  0022c	8b 94 24 88 40
	00 00		 mov	 edx, DWORD PTR _nTickCount$[esp+16460]
  00233	89 08		 mov	 DWORD PTR [eax], ecx
  00235	8b 7c 24 34	 mov	 edi, DWORD PTR _ar$[esp+16472]
  00239	8b 84 24 8c 40
	00 00		 mov	 eax, DWORD PTR _nTickCount$[esp+16464]
  00240	6a 08		 push	 8
  00242	8d 4c 24 14	 lea	 ecx, DWORD PTR $T323689[esp+16468]
  00246	51		 push	 ecx
  00247	03 fb		 add	 edi, ebx
  00249	8d 4c 24 34	 lea	 ecx, DWORD PTR _ar$[esp+16472]
  0024d	89 7c 24 3c	 mov	 DWORD PTR _ar$[esp+16480], edi
  00251	89 54 24 18	 mov	 DWORD PTR $T323689[esp+16472], edx
  00255	89 44 24 1c	 mov	 DWORD PTR $T323689[esp+16476], eax
  00259	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write

; 5009 : 	
; 5010 : 	GETBLOCK( ar, lpBuf, nBufSize );

  0025e	8d 54 24 1c	 lea	 edx, DWORD PTR _nBufSize$[esp+16464]
  00262	52		 push	 edx
  00263	8d 4c 24 30	 lea	 ecx, DWORD PTR _ar$[esp+16468]
  00267	e8 00 00 00 00	 call	 ?GetBuffer@CAr@@QAEPAEPAH@Z ; CAr::GetBuffer

; 5011 : 
; 5012 : 	FOR_VISIBILITYRANGE( pMover )

  0026c	8b bd 10 02 00
	00		 mov	 edi, DWORD PTR [ebp+528]
  00272	8b 37		 mov	 esi, DWORD PTR [edi]
  00274	3b f7		 cmp	 esi, edi
  00276	8b d8		 mov	 ebx, eax
  00278	74 75		 je	 SHORT $L281520
  0027a	8d 9b 00 00 00
	00		 npad	 6
$L281519:

; 5013 : 		if( USERPTR != pMover )

  00280	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00283	3b c5		 cmp	 eax, ebp
  00285	74 1e		 je	 SHORT $L323798

; 5014 : 			USERPTR->AddBlock( lpBuf, nBufSize );

  00287	f6 40 04 01	 test	 BYTE PTR [eax+4], 1
  0028b	8b 4c 24 1c	 mov	 ecx, DWORD PTR _nBufSize$[esp+16464]
  0028f	75 14		 jne	 SHORT $L323798
  00291	66 ff 80 0c 57
	00 00		 inc	 WORD PTR [eax+22284]
  00298	51		 push	 ecx
  00299	53		 push	 ebx
  0029a	8d 88 f8 16 00
	00		 lea	 ecx, DWORD PTR [eax+5880]
  002a0	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
$L323798:

; 5015 : 	NEXT_VISIBILITYRANGE( pMover )

  002a5	8a 46 15	 mov	 al, BYTE PTR [esi+21]
  002a8	84 c0		 test	 al, al
  002aa	75 3f		 jne	 SHORT $L323946
  002ac	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  002af	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  002b2	84 c9		 test	 cl, cl
  002b4	75 18		 jne	 SHORT $L323959
  002b6	8b f0		 mov	 esi, eax
  002b8	8b 06		 mov	 eax, DWORD PTR [esi]
  002ba	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  002bd	84 c9		 test	 cl, cl
  002bf	75 2a		 jne	 SHORT $L323946
$L323934:
  002c1	8b f0		 mov	 esi, eax
  002c3	8b 06		 mov	 eax, DWORD PTR [esi]
  002c5	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  002c8	84 c9		 test	 cl, cl
  002ca	74 f5		 je	 SHORT $L323934
  002cc	eb 1d		 jmp	 SHORT $L323946
$L323959:
  002ce	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  002d1	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  002d4	84 c9		 test	 cl, cl
  002d6	75 11		 jne	 SHORT $L323949
$L323948:
  002d8	3b 70 08	 cmp	 esi, DWORD PTR [eax+8]
  002db	75 0c		 jne	 SHORT $L323949
  002dd	8b f0		 mov	 esi, eax
  002df	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  002e2	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  002e5	84 c9		 test	 cl, cl
  002e7	74 ef		 je	 SHORT $L323948
$L323949:
  002e9	8b f0		 mov	 esi, eax
$L323946:

; 5011 : 
; 5012 : 	FOR_VISIBILITYRANGE( pMover )

  002eb	3b f7		 cmp	 esi, edi
  002ed	75 91		 jne	 SHORT $L281519
$L281520:

; 5016 : }

  002ef	8d 4c 24 2c	 lea	 ecx, DWORD PTR _ar$[esp+16464]
  002f3	c7 84 24 4c 40
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+16472], -1
  002fe	e8 00 00 00 00	 call	 ??1CAr@@QAE@XZ		; CAr::~CAr
  00303	8b 8c 24 44 40
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+16464]
  0030a	5f		 pop	 edi
  0030b	5e		 pop	 esi
  0030c	5d		 pop	 ebp
  0030d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00314	8b 8c 24 34 40
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+16452]
  0031b	5b		 pop	 ebx
  0031c	33 cc		 xor	 ecx, esp
  0031e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00323	81 c4 40 40 00
	00		 add	 esp, 16448		; 00004040H
  00329	c2 3c 00	 ret	 60			; 0000003cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L323626:
  00000	8d 8d dc bf ff
	ff		 lea	 ecx, DWORD PTR _ar$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CAr@@QAE@XZ		; CAr::~CAr
__ehhandler$?AddMoverCorr2@CUserMng@@QAEXPAVCMover@@AAUD3DXVECTOR3@@1MMMMKKKHHK_J@Z:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T323956
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?AddMoverCorr2@CUserMng@@QAEXPAVCMover@@AAUD3DXVECTOR3@@1MMMMKKKHHK_J@Z ENDP ; CUserMng::AddMoverCorr2
PUBLIC	?AddCreateSfxObj@CUserMng@@QAEXPAVCCtrl@@KMMMH@Z ; CUserMng::AddCreateSfxObj
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
xdata$x	SEGMENT
$T324253 DD	0ffffffffH
	DD	FLAT:$L323973
$T324245 DD	019930520H
	DD	01H
	DD	FLAT:$T324253
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
xdata$x	ENDS
;	COMDAT ?AddCreateSfxObj@CUserMng@@QAEXPAVCCtrl@@KMMMH@Z
_TEXT	SEGMENT
_nBufSize$ = -16424					; size = 4
_ar$ = -16420						; size = 16404
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_pCtrl$ = 8						; size = 4
_dwSfxObj$ = 12						; size = 4
_x$ = 16						; size = 4
_y$ = 20						; size = 4
_z$ = 24						; size = 4
_bFlag$ = 28						; size = 4
?AddCreateSfxObj@CUserMng@@QAEXPAVCCtrl@@KMMMH@Z PROC NEAR ; CUserMng::AddCreateSfxObj, COMDAT
; _this$ = ecx

; 5020 : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?AddCreateSfxObj@CUserMng@@QAEXPAVCCtrl@@KMMMH@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	b8 1c 40 00 00	 mov	 eax, 16412		; 0000401cH
  00013	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0001a	e8 00 00 00 00	 call	 __chkstk
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00024	33 c4		 xor	 eax, esp
  00026	53		 push	 ebx
  00027	55		 push	 ebp
  00028	56		 push	 esi
  00029	8b b4 24 38 40
	00 00		 mov	 esi, DWORD PTR _pCtrl$[esp+16432]
  00030	57		 push	 edi

; 5021 : 	CAr ar;

  00031	6a 00		 push	 0
  00033	6a 00		 push	 0
  00035	8d 4c 24 1c	 lea	 ecx, DWORD PTR _ar$[esp+16448]
  00039	89 84 24 30 40
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+16448], eax
  00040	e8 00 00 00 00	 call	 ??0CAr@@QAE@PAXI@Z	; CAr::CAr

; 5022 : 	ar << GETID( pCtrl ) << SNAPSHOTTYPE_CREATESFXOBJ;

  00045	85 f6		 test	 esi, esi
  00047	c7 84 24 34 40
	00 00 00 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+16448], 0
  00052	74 08		 je	 SHORT $L323971
  00054	8b be bc 01 00
	00		 mov	 edi, DWORD PTR [esi+444]
  0005a	eb 03		 jmp	 SHORT $L323972
$L323971:
  0005c	83 cf ff	 or	 edi, -1
$L323972:
  0005f	bb 04 00 00 00	 mov	 ebx, 4
  00064	53		 push	 ebx
  00065	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  00069	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0006e	8b 44 24 1c	 mov	 eax, DWORD PTR _ar$[esp+16448]
  00072	89 38		 mov	 DWORD PTR [eax], edi
  00074	8b 6c 24 1c	 mov	 ebp, DWORD PTR _ar$[esp+16448]
  00078	03 eb		 add	 ebp, ebx
  0007a	6a 02		 push	 2
  0007c	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  00080	89 6c 24 20	 mov	 DWORD PTR _ar$[esp+16452], ebp
  00084	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00089	8b 4c 24 1c	 mov	 ecx, DWORD PTR _ar$[esp+16448]
  0008d	66 c7 01 0f 00	 mov	 WORD PTR [ecx], 15	; 0000000fH
  00092	8b 54 24 1c	 mov	 edx, DWORD PTR _ar$[esp+16448]
  00096	83 c2 02	 add	 edx, 2

; 5023 : 
; 5024 : 	ar << dwSfxObj << x << y << z;

  00099	53		 push	 ebx
  0009a	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  0009e	89 54 24 20	 mov	 DWORD PTR _ar$[esp+16452], edx
  000a2	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000a7	8b 54 24 1c	 mov	 edx, DWORD PTR _ar$[esp+16448]
  000ab	8b 84 24 40 40
	00 00		 mov	 eax, DWORD PTR _dwSfxObj$[esp+16436]
  000b2	89 02		 mov	 DWORD PTR [edx], eax
  000b4	8b 44 24 1c	 mov	 eax, DWORD PTR _ar$[esp+16448]
  000b8	03 c3		 add	 eax, ebx
  000ba	53		 push	 ebx
  000bb	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  000bf	89 44 24 20	 mov	 DWORD PTR _ar$[esp+16452], eax
  000c3	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000c8	d9 84 24 44 40
	00 00		 fld	 DWORD PTR _x$[esp+16436]
  000cf	8b 4c 24 1c	 mov	 ecx, DWORD PTR _ar$[esp+16448]
  000d3	d9 19		 fstp	 DWORD PTR [ecx]
  000d5	8b 7c 24 1c	 mov	 edi, DWORD PTR _ar$[esp+16448]
  000d9	03 fb		 add	 edi, ebx
  000db	53		 push	 ebx
  000dc	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  000e0	89 7c 24 20	 mov	 DWORD PTR _ar$[esp+16452], edi
  000e4	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000e9	d9 84 24 48 40
	00 00		 fld	 DWORD PTR _y$[esp+16436]
  000f0	8b 54 24 1c	 mov	 edx, DWORD PTR _ar$[esp+16448]
  000f4	d9 1a		 fstp	 DWORD PTR [edx]
  000f6	8b 4c 24 1c	 mov	 ecx, DWORD PTR _ar$[esp+16448]
  000fa	03 cb		 add	 ecx, ebx
  000fc	89 4c 24 1c	 mov	 DWORD PTR _ar$[esp+16448], ecx
  00100	53		 push	 ebx
  00101	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  00105	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0010a	d9 84 24 4c 40
	00 00		 fld	 DWORD PTR _z$[esp+16436]
  00111	8b 44 24 1c	 mov	 eax, DWORD PTR _ar$[esp+16448]
  00115	d9 18		 fstp	 DWORD PTR [eax]
  00117	8b 6c 24 1c	 mov	 ebp, DWORD PTR _ar$[esp+16448]
  0011b	03 eb		 add	 ebp, ebx

; 5025 : 	ar << bFlag;

  0011d	53		 push	 ebx
  0011e	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  00122	89 6c 24 20	 mov	 DWORD PTR _ar$[esp+16452], ebp
  00126	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0012b	8b 4c 24 1c	 mov	 ecx, DWORD PTR _ar$[esp+16448]
  0012f	8b 94 24 50 40
	00 00		 mov	 edx, DWORD PTR _bFlag$[esp+16436]
  00136	89 11		 mov	 DWORD PTR [ecx], edx
  00138	8b 54 24 1c	 mov	 edx, DWORD PTR _ar$[esp+16448]

; 5026 : 
; 5027 : 	GETBLOCK( ar, lpBuf, nBufSize );

  0013c	8d 44 24 10	 lea	 eax, DWORD PTR _nBufSize$[esp+16440]
  00140	03 d3		 add	 edx, ebx
  00142	50		 push	 eax
  00143	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  00147	89 54 24 20	 mov	 DWORD PTR _ar$[esp+16452], edx
  0014b	e8 00 00 00 00	 call	 ?GetBuffer@CAr@@QAEPAEPAH@Z ; CAr::GetBuffer

; 5028 : 	
; 5029 : 	FOR_VISIBILITYRANGE( pCtrl )

  00150	8b be 10 02 00
	00		 mov	 edi, DWORD PTR [esi+528]
  00156	8b 37		 mov	 esi, DWORD PTR [edi]
  00158	3b f7		 cmp	 esi, edi
  0015a	8b e8		 mov	 ebp, eax
  0015c	74 70		 je	 SHORT $L281551
  0015e	b3 01		 mov	 bl, 1
$L281550:

; 5030 : 		USERPTR->AddBlock( lpBuf, nBufSize );

  00160	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00163	84 58 04	 test	 BYTE PTR [eax+4], bl
  00166	8b 4c 24 10	 mov	 ecx, DWORD PTR _nBufSize$[esp+16440]
  0016a	75 14		 jne	 SHORT $L324089
  0016c	66 ff 80 0c 57
	00 00		 inc	 WORD PTR [eax+22284]
  00173	51		 push	 ecx
  00174	55		 push	 ebp
  00175	8d 88 f8 16 00
	00		 lea	 ecx, DWORD PTR [eax+5880]
  0017b	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
$L324089:

; 5031 : 	NEXT_VISIBILITYRANGE( pCtrl )

  00180	8a 46 15	 mov	 al, BYTE PTR [esi+21]
  00183	84 c0		 test	 al, al
  00185	75 43		 jne	 SHORT $L324213
  00187	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0018a	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  0018d	84 c9		 test	 cl, cl
  0018f	75 1c		 jne	 SHORT $L324248
  00191	8b f0		 mov	 esi, eax
  00193	8b 06		 mov	 eax, DWORD PTR [esi]
  00195	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00198	84 c9		 test	 cl, cl
  0019a	75 2e		 jne	 SHORT $L324213
  0019c	8d 64 24 00	 npad	 4
$L324234:
  001a0	8b f0		 mov	 esi, eax
  001a2	8b 06		 mov	 eax, DWORD PTR [esi]
  001a4	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  001a7	84 c9		 test	 cl, cl
  001a9	74 f5		 je	 SHORT $L324234
  001ab	eb 1d		 jmp	 SHORT $L324213
$L324248:
  001ad	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  001b0	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  001b3	84 c9		 test	 cl, cl
  001b5	75 11		 jne	 SHORT $L324216
$L324215:
  001b7	3b 70 08	 cmp	 esi, DWORD PTR [eax+8]
  001ba	75 0c		 jne	 SHORT $L324216
  001bc	8b f0		 mov	 esi, eax
  001be	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001c1	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  001c4	84 c9		 test	 cl, cl
  001c6	74 ef		 je	 SHORT $L324215
$L324216:
  001c8	8b f0		 mov	 esi, eax
$L324213:

; 5028 : 	
; 5029 : 	FOR_VISIBILITYRANGE( pCtrl )

  001ca	3b f7		 cmp	 esi, edi
  001cc	75 92		 jne	 SHORT $L281550
$L281551:

; 5032 : }

  001ce	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  001d2	c7 84 24 34 40
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+16448], -1
  001dd	e8 00 00 00 00	 call	 ??1CAr@@QAE@XZ		; CAr::~CAr
  001e2	8b 8c 24 2c 40
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+16440]
  001e9	5f		 pop	 edi
  001ea	5e		 pop	 esi
  001eb	5d		 pop	 ebp
  001ec	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  001f3	8b 8c 24 1c 40
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+16428]
  001fa	5b		 pop	 ebx
  001fb	33 cc		 xor	 ecx, esp
  001fd	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00202	81 c4 28 40 00
	00		 add	 esp, 16424		; 00004028H
  00208	c2 18 00	 ret	 24			; 00000018H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L323973:
  00000	8d 8d dc bf ff
	ff		 lea	 ecx, DWORD PTR _ar$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CAr@@QAE@XZ		; CAr::~CAr
__ehhandler$?AddCreateSfxObj@CUserMng@@QAEXPAVCCtrl@@KMMMH@Z:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T324245
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?AddCreateSfxObj@CUserMng@@QAEXPAVCCtrl@@KMMMH@Z ENDP	; CUserMng::AddCreateSfxObj
PUBLIC	?AddRemoveSfxObj@CUserMng@@QAEXPAVCCtrl@@KMMMH@Z ; CUserMng::AddRemoveSfxObj
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
xdata$x	SEGMENT
$T324542 DD	0ffffffffH
	DD	FLAT:$L324262
$T324534 DD	019930520H
	DD	01H
	DD	FLAT:$T324542
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
xdata$x	ENDS
;	COMDAT ?AddRemoveSfxObj@CUserMng@@QAEXPAVCCtrl@@KMMMH@Z
_TEXT	SEGMENT
_nBufSize$ = -16424					; size = 4
_ar$ = -16420						; size = 16404
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_pCtrl$ = 8						; size = 4
_dwSfxObj$ = 12						; size = 4
_x$ = 16						; size = 4
_y$ = 20						; size = 4
_z$ = 24						; size = 4
_bFlag$ = 28						; size = 4
?AddRemoveSfxObj@CUserMng@@QAEXPAVCCtrl@@KMMMH@Z PROC NEAR ; CUserMng::AddRemoveSfxObj, COMDAT
; _this$ = ecx

; 5036 : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?AddRemoveSfxObj@CUserMng@@QAEXPAVCCtrl@@KMMMH@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	b8 1c 40 00 00	 mov	 eax, 16412		; 0000401cH
  00013	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0001a	e8 00 00 00 00	 call	 __chkstk
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00024	33 c4		 xor	 eax, esp
  00026	53		 push	 ebx
  00027	55		 push	 ebp
  00028	56		 push	 esi
  00029	8b b4 24 38 40
	00 00		 mov	 esi, DWORD PTR _pCtrl$[esp+16432]
  00030	57		 push	 edi

; 5037 : 	CAr ar;

  00031	6a 00		 push	 0
  00033	6a 00		 push	 0
  00035	8d 4c 24 1c	 lea	 ecx, DWORD PTR _ar$[esp+16448]
  00039	89 84 24 30 40
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+16448], eax
  00040	e8 00 00 00 00	 call	 ??0CAr@@QAE@PAXI@Z	; CAr::CAr

; 5038 : 	ar << GETID( pCtrl ) << SNAPSHOTTYPE_REMOVESFXOBJ;

  00045	85 f6		 test	 esi, esi
  00047	c7 84 24 34 40
	00 00 00 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+16448], 0
  00052	74 08		 je	 SHORT $L324260
  00054	8b be bc 01 00
	00		 mov	 edi, DWORD PTR [esi+444]
  0005a	eb 03		 jmp	 SHORT $L324261
$L324260:
  0005c	83 cf ff	 or	 edi, -1
$L324261:
  0005f	bb 04 00 00 00	 mov	 ebx, 4
  00064	53		 push	 ebx
  00065	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  00069	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0006e	8b 44 24 1c	 mov	 eax, DWORD PTR _ar$[esp+16448]
  00072	89 38		 mov	 DWORD PTR [eax], edi
  00074	8b 6c 24 1c	 mov	 ebp, DWORD PTR _ar$[esp+16448]
  00078	03 eb		 add	 ebp, ebx
  0007a	6a 02		 push	 2
  0007c	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  00080	89 6c 24 20	 mov	 DWORD PTR _ar$[esp+16452], ebp
  00084	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00089	8b 4c 24 1c	 mov	 ecx, DWORD PTR _ar$[esp+16448]
  0008d	66 c7 01 04 02	 mov	 WORD PTR [ecx], 516	; 00000204H
  00092	8b 54 24 1c	 mov	 edx, DWORD PTR _ar$[esp+16448]
  00096	83 c2 02	 add	 edx, 2

; 5039 : 
; 5040 : 	ar << dwSfxObj << x << y << z;

  00099	53		 push	 ebx
  0009a	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  0009e	89 54 24 20	 mov	 DWORD PTR _ar$[esp+16452], edx
  000a2	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000a7	8b 54 24 1c	 mov	 edx, DWORD PTR _ar$[esp+16448]
  000ab	8b 84 24 40 40
	00 00		 mov	 eax, DWORD PTR _dwSfxObj$[esp+16436]
  000b2	89 02		 mov	 DWORD PTR [edx], eax
  000b4	8b 44 24 1c	 mov	 eax, DWORD PTR _ar$[esp+16448]
  000b8	03 c3		 add	 eax, ebx
  000ba	53		 push	 ebx
  000bb	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  000bf	89 44 24 20	 mov	 DWORD PTR _ar$[esp+16452], eax
  000c3	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000c8	d9 84 24 44 40
	00 00		 fld	 DWORD PTR _x$[esp+16436]
  000cf	8b 4c 24 1c	 mov	 ecx, DWORD PTR _ar$[esp+16448]
  000d3	d9 19		 fstp	 DWORD PTR [ecx]
  000d5	8b 7c 24 1c	 mov	 edi, DWORD PTR _ar$[esp+16448]
  000d9	03 fb		 add	 edi, ebx
  000db	53		 push	 ebx
  000dc	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  000e0	89 7c 24 20	 mov	 DWORD PTR _ar$[esp+16452], edi
  000e4	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000e9	d9 84 24 48 40
	00 00		 fld	 DWORD PTR _y$[esp+16436]
  000f0	8b 54 24 1c	 mov	 edx, DWORD PTR _ar$[esp+16448]
  000f4	d9 1a		 fstp	 DWORD PTR [edx]
  000f6	8b 4c 24 1c	 mov	 ecx, DWORD PTR _ar$[esp+16448]
  000fa	03 cb		 add	 ecx, ebx
  000fc	89 4c 24 1c	 mov	 DWORD PTR _ar$[esp+16448], ecx
  00100	53		 push	 ebx
  00101	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  00105	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0010a	d9 84 24 4c 40
	00 00		 fld	 DWORD PTR _z$[esp+16436]
  00111	8b 44 24 1c	 mov	 eax, DWORD PTR _ar$[esp+16448]
  00115	d9 18		 fstp	 DWORD PTR [eax]
  00117	8b 6c 24 1c	 mov	 ebp, DWORD PTR _ar$[esp+16448]
  0011b	03 eb		 add	 ebp, ebx

; 5041 : 	ar << bFlag;

  0011d	53		 push	 ebx
  0011e	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  00122	89 6c 24 20	 mov	 DWORD PTR _ar$[esp+16452], ebp
  00126	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0012b	8b 4c 24 1c	 mov	 ecx, DWORD PTR _ar$[esp+16448]
  0012f	8b 94 24 50 40
	00 00		 mov	 edx, DWORD PTR _bFlag$[esp+16436]
  00136	89 11		 mov	 DWORD PTR [ecx], edx
  00138	8b 54 24 1c	 mov	 edx, DWORD PTR _ar$[esp+16448]

; 5042 : 
; 5043 : 	GETBLOCK( ar, lpBuf, nBufSize );

  0013c	8d 44 24 10	 lea	 eax, DWORD PTR _nBufSize$[esp+16440]
  00140	03 d3		 add	 edx, ebx
  00142	50		 push	 eax
  00143	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  00147	89 54 24 20	 mov	 DWORD PTR _ar$[esp+16452], edx
  0014b	e8 00 00 00 00	 call	 ?GetBuffer@CAr@@QAEPAEPAH@Z ; CAr::GetBuffer

; 5044 : 	
; 5045 : 	FOR_VISIBILITYRANGE( pCtrl )

  00150	8b be 10 02 00
	00		 mov	 edi, DWORD PTR [esi+528]
  00156	8b 37		 mov	 esi, DWORD PTR [edi]
  00158	3b f7		 cmp	 esi, edi
  0015a	8b e8		 mov	 ebp, eax
  0015c	74 70		 je	 SHORT $L281581
  0015e	b3 01		 mov	 bl, 1
$L281580:

; 5046 : 		USERPTR->AddBlock( lpBuf, nBufSize );

  00160	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00163	84 58 04	 test	 BYTE PTR [eax+4], bl
  00166	8b 4c 24 10	 mov	 ecx, DWORD PTR _nBufSize$[esp+16440]
  0016a	75 14		 jne	 SHORT $L324375
  0016c	66 ff 80 0c 57
	00 00		 inc	 WORD PTR [eax+22284]
  00173	51		 push	 ecx
  00174	55		 push	 ebp
  00175	8d 88 f8 16 00
	00		 lea	 ecx, DWORD PTR [eax+5880]
  0017b	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
$L324375:

; 5047 : 	NEXT_VISIBILITYRANGE( pCtrl )

  00180	8a 46 15	 mov	 al, BYTE PTR [esi+21]
  00183	84 c0		 test	 al, al
  00185	75 43		 jne	 SHORT $L324503
  00187	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0018a	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  0018d	84 c9		 test	 cl, cl
  0018f	75 1c		 jne	 SHORT $L324537
  00191	8b f0		 mov	 esi, eax
  00193	8b 06		 mov	 eax, DWORD PTR [esi]
  00195	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00198	84 c9		 test	 cl, cl
  0019a	75 2e		 jne	 SHORT $L324503
  0019c	8d 64 24 00	 npad	 4
$L324517:
  001a0	8b f0		 mov	 esi, eax
  001a2	8b 06		 mov	 eax, DWORD PTR [esi]
  001a4	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  001a7	84 c9		 test	 cl, cl
  001a9	74 f5		 je	 SHORT $L324517
  001ab	eb 1d		 jmp	 SHORT $L324503
$L324537:
  001ad	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  001b0	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  001b3	84 c9		 test	 cl, cl
  001b5	75 11		 jne	 SHORT $L324506
$L324505:
  001b7	3b 70 08	 cmp	 esi, DWORD PTR [eax+8]
  001ba	75 0c		 jne	 SHORT $L324506
  001bc	8b f0		 mov	 esi, eax
  001be	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001c1	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  001c4	84 c9		 test	 cl, cl
  001c6	74 ef		 je	 SHORT $L324505
$L324506:
  001c8	8b f0		 mov	 esi, eax
$L324503:

; 5044 : 	
; 5045 : 	FOR_VISIBILITYRANGE( pCtrl )

  001ca	3b f7		 cmp	 esi, edi
  001cc	75 92		 jne	 SHORT $L281580
$L281581:

; 5048 : }

  001ce	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  001d2	c7 84 24 34 40
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+16448], -1
  001dd	e8 00 00 00 00	 call	 ??1CAr@@QAE@XZ		; CAr::~CAr
  001e2	8b 8c 24 2c 40
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+16440]
  001e9	5f		 pop	 edi
  001ea	5e		 pop	 esi
  001eb	5d		 pop	 ebp
  001ec	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  001f3	8b 8c 24 1c 40
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+16428]
  001fa	5b		 pop	 ebx
  001fb	33 cc		 xor	 ecx, esp
  001fd	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00202	81 c4 28 40 00
	00		 add	 esp, 16424		; 00004028H
  00208	c2 18 00	 ret	 24			; 00000018H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L324262:
  00000	8d 8d dc bf ff
	ff		 lea	 ecx, DWORD PTR _ar$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CAr@@QAE@XZ		; CAr::~CAr
__ehhandler$?AddRemoveSfxObj@CUserMng@@QAEXPAVCCtrl@@KMMMH@Z:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T324534
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?AddRemoveSfxObj@CUserMng@@QAEXPAVCCtrl@@KMMMH@Z ENDP	; CUserMng::AddRemoveSfxObj
PUBLIC	?AddMotionArrive@CUserMng@@QAEXPAVCMover@@W4OBJMSG@@@Z ; CUserMng::AddMotionArrive
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
xdata$x	SEGMENT
$T324819 DD	0ffffffffH
	DD	FLAT:$L324551
$T324811 DD	019930520H
	DD	01H
	DD	FLAT:$T324819
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
xdata$x	ENDS
;	COMDAT ?AddMotionArrive@CUserMng@@QAEXPAVCMover@@W4OBJMSG@@@Z
_TEXT	SEGMENT
_nBufSize$ = -16424					; size = 4
_ar$ = -16420						; size = 16404
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_pMover$ = 8						; size = 4
_objmsg$ = 12						; size = 4
?AddMotionArrive@CUserMng@@QAEXPAVCMover@@W4OBJMSG@@@Z PROC NEAR ; CUserMng::AddMotionArrive, COMDAT
; _this$ = ecx

; 5053 : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?AddMotionArrive@CUserMng@@QAEXPAVCMover@@W4OBJMSG@@@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	b8 1c 40 00 00	 mov	 eax, 16412		; 0000401cH
  00013	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0001a	e8 00 00 00 00	 call	 __chkstk
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00024	33 c4		 xor	 eax, esp
  00026	55		 push	 ebp
  00027	56		 push	 esi
  00028	8b b4 24 34 40
	00 00		 mov	 esi, DWORD PTR _pMover$[esp+16428]
  0002f	57		 push	 edi

; 5054 : 	CAr ar;

  00030	6a 00		 push	 0
  00032	6a 00		 push	 0
  00034	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  00038	89 84 24 2c 40
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+16444], eax
  0003f	e8 00 00 00 00	 call	 ??0CAr@@QAE@PAXI@Z	; CAr::CAr

; 5055 : 	ar << GETID( pMover ) << SNAPSHOTTYPE_MOTION_ARRIVE;

  00044	85 f6		 test	 esi, esi
  00046	c7 84 24 30 40
	00 00 00 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+16444], 0
  00051	74 08		 je	 SHORT $L324549
  00053	8b be bc 01 00
	00		 mov	 edi, DWORD PTR [esi+444]
  00059	eb 03		 jmp	 SHORT $L324550
$L324549:
  0005b	83 cf ff	 or	 edi, -1
$L324550:
  0005e	6a 04		 push	 4
  00060	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  00064	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00069	8b 44 24 18	 mov	 eax, DWORD PTR _ar$[esp+16444]
  0006d	89 38		 mov	 DWORD PTR [eax], edi
  0006f	8b 54 24 18	 mov	 edx, DWORD PTR _ar$[esp+16444]
  00073	83 c2 04	 add	 edx, 4
  00076	6a 02		 push	 2
  00078	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  0007c	89 54 24 1c	 mov	 DWORD PTR _ar$[esp+16448], edx
  00080	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00085	8b 4c 24 18	 mov	 ecx, DWORD PTR _ar$[esp+16444]
  00089	66 c7 01 ee 00	 mov	 WORD PTR [ecx], 238	; 000000eeH
  0008e	8b 44 24 18	 mov	 eax, DWORD PTR _ar$[esp+16444]
  00092	83 c0 02	 add	 eax, 2

; 5056 : 	
; 5057 : 	ar << objmsg;

  00095	6a 04		 push	 4
  00097	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  0009b	89 44 24 1c	 mov	 DWORD PTR _ar$[esp+16448], eax
  0009f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000a4	8b 54 24 18	 mov	 edx, DWORD PTR _ar$[esp+16444]
  000a8	8b 84 24 3c 40
	00 00		 mov	 eax, DWORD PTR _objmsg$[esp+16432]
  000af	89 02		 mov	 DWORD PTR [edx], eax
  000b1	8b 7c 24 18	 mov	 edi, DWORD PTR _ar$[esp+16444]

; 5058 : 	
; 5059 : 	GETBLOCK( ar, lpBuf, nBufSize );

  000b5	8d 4c 24 0c	 lea	 ecx, DWORD PTR _nBufSize$[esp+16436]
  000b9	51		 push	 ecx
  000ba	83 c7 04	 add	 edi, 4
  000bd	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  000c1	89 7c 24 1c	 mov	 DWORD PTR _ar$[esp+16448], edi
  000c5	e8 00 00 00 00	 call	 ?GetBuffer@CAr@@QAEPAEPAH@Z ; CAr::GetBuffer

; 5060 : 	FOR_VISIBILITYRANGE( pMover )

  000ca	8b be 10 02 00
	00		 mov	 edi, DWORD PTR [esi+528]
  000d0	8b 37		 mov	 esi, DWORD PTR [edi]
  000d2	3b f7		 cmp	 esi, edi
  000d4	8b e8		 mov	 ebp, eax
  000d6	74 76		 je	 SHORT $L281607
  000d8	eb 06 8d 9b 00
	00 00 00	 npad	 8
$L281606:

; 5061 : 		USERPTR->AddBlock( lpBuf, nBufSize );

  000e0	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  000e3	f6 40 04 01	 test	 BYTE PTR [eax+4], 1
  000e7	8b 4c 24 0c	 mov	 ecx, DWORD PTR _nBufSize$[esp+16436]
  000eb	75 14		 jne	 SHORT $L324655
  000ed	66 ff 80 0c 57
	00 00		 inc	 WORD PTR [eax+22284]
  000f4	51		 push	 ecx
  000f5	55		 push	 ebp
  000f6	8d 88 f8 16 00
	00		 lea	 ecx, DWORD PTR [eax+5880]
  000fc	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
$L324655:

; 5062 : 	NEXT_VISIBILITYRANGE( pMover )

  00101	8a 46 15	 mov	 al, BYTE PTR [esi+21]
  00104	84 c0		 test	 al, al
  00106	75 42		 jne	 SHORT $L324803
  00108	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0010b	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  0010e	84 c9		 test	 cl, cl
  00110	75 1b		 jne	 SHORT $L324814
  00112	8b f0		 mov	 esi, eax
  00114	8b 06		 mov	 eax, DWORD PTR [esi]
  00116	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00119	84 c9		 test	 cl, cl
  0011b	75 2d		 jne	 SHORT $L324803
  0011d	8d 49 00	 npad	 3
$L324791:
  00120	8b f0		 mov	 esi, eax
  00122	8b 06		 mov	 eax, DWORD PTR [esi]
  00124	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00127	84 c9		 test	 cl, cl
  00129	74 f5		 je	 SHORT $L324791
  0012b	eb 1d		 jmp	 SHORT $L324803
$L324814:
  0012d	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00130	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00133	84 c9		 test	 cl, cl
  00135	75 11		 jne	 SHORT $L324806
$L324805:
  00137	3b 70 08	 cmp	 esi, DWORD PTR [eax+8]
  0013a	75 0c		 jne	 SHORT $L324806
  0013c	8b f0		 mov	 esi, eax
  0013e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00141	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00144	84 c9		 test	 cl, cl
  00146	74 ef		 je	 SHORT $L324805
$L324806:
  00148	8b f0		 mov	 esi, eax
$L324803:

; 5060 : 	FOR_VISIBILITYRANGE( pMover )

  0014a	3b f7		 cmp	 esi, edi
  0014c	75 92		 jne	 SHORT $L281606
$L281607:

; 5063 : }

  0014e	8d 4c 24 10	 lea	 ecx, DWORD PTR _ar$[esp+16436]
  00152	c7 84 24 30 40
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+16444], -1
  0015d	e8 00 00 00 00	 call	 ??1CAr@@QAE@XZ		; CAr::~CAr
  00162	8b 8c 24 28 40
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+16436]
  00169	5f		 pop	 edi
  0016a	5e		 pop	 esi
  0016b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00172	8b 8c 24 1c 40
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+16428]
  00179	5d		 pop	 ebp
  0017a	33 cc		 xor	 ecx, esp
  0017c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00181	81 c4 28 40 00
	00		 add	 esp, 16424		; 00004028H
  00187	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L324551:
  00000	8d 8d dc bf ff
	ff		 lea	 ecx, DWORD PTR _ar$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CAr@@QAE@XZ		; CAr::~CAr
__ehhandler$?AddMotionArrive@CUserMng@@QAEXPAVCMover@@W4OBJMSG@@@Z:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T324811
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?AddMotionArrive@CUserMng@@QAEXPAVCMover@@W4OBJMSG@@@Z ENDP ; CUserMng::AddMotionArrive
PUBLIC	?AddPKPink@CUserMng@@QAEXPAVCMover@@E@Z		; CUserMng::AddPKPink
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
xdata$x	SEGMENT
$T325094 DD	0ffffffffH
	DD	FLAT:$L324828
$T325086 DD	019930520H
	DD	01H
	DD	FLAT:$T325094
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
xdata$x	ENDS
;	COMDAT ?AddPKPink@CUserMng@@QAEXPAVCMover@@E@Z
_TEXT	SEGMENT
_nBufSize$ = -16424					; size = 4
_ar$ = -16420						; size = 16404
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_pMover$ = 8						; size = 4
_byPink$ = 12						; size = 1
?AddPKPink@CUserMng@@QAEXPAVCMover@@E@Z PROC NEAR	; CUserMng::AddPKPink, COMDAT
; _this$ = ecx

; 5067 : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?AddPKPink@CUserMng@@QAEXPAVCMover@@E@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	b8 1c 40 00 00	 mov	 eax, 16412		; 0000401cH
  00013	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0001a	e8 00 00 00 00	 call	 __chkstk
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00024	33 c4		 xor	 eax, esp
  00026	55		 push	 ebp
  00027	56		 push	 esi
  00028	8b b4 24 34 40
	00 00		 mov	 esi, DWORD PTR _pMover$[esp+16428]
  0002f	57		 push	 edi

; 5068 : 	CAr ar;

  00030	6a 00		 push	 0
  00032	6a 00		 push	 0
  00034	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  00038	89 84 24 2c 40
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+16444], eax
  0003f	e8 00 00 00 00	 call	 ??0CAr@@QAE@PAXI@Z	; CAr::CAr

; 5069 : 	ar << GETID( pMover ) << SNAPSHOTTYPE_PK_RELATION;

  00044	85 f6		 test	 esi, esi
  00046	c7 84 24 30 40
	00 00 00 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+16444], 0
  00051	74 08		 je	 SHORT $L324826
  00053	8b be bc 01 00
	00		 mov	 edi, DWORD PTR [esi+444]
  00059	eb 03		 jmp	 SHORT $L324827
$L324826:
  0005b	83 cf ff	 or	 edi, -1
$L324827:
  0005e	6a 04		 push	 4
  00060	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  00064	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00069	8b 44 24 18	 mov	 eax, DWORD PTR _ar$[esp+16444]
  0006d	89 38		 mov	 DWORD PTR [eax], edi
  0006f	8b 7c 24 18	 mov	 edi, DWORD PTR _ar$[esp+16444]
  00073	83 c7 04	 add	 edi, 4
  00076	6a 02		 push	 2
  00078	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  0007c	89 7c 24 1c	 mov	 DWORD PTR _ar$[esp+16448], edi
  00080	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00085	8b 4c 24 18	 mov	 ecx, DWORD PTR _ar$[esp+16444]
  00089	66 c7 01 65 00	 mov	 WORD PTR [ecx], 101	; 00000065H
  0008e	83 44 24 18 02	 add	 DWORD PTR _ar$[esp+16444], 2

; 5070 : 	ar << PK_PINK;

  00093	6a 01		 push	 1
  00095	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  00099	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0009e	8b 54 24 18	 mov	 edx, DWORD PTR _ar$[esp+16444]
  000a2	c6 02 00	 mov	 BYTE PTR [edx], 0
  000a5	8b 6c 24 18	 mov	 ebp, DWORD PTR _ar$[esp+16444]
  000a9	45		 inc	 ebp

; 5071 : 	ar << byPink;

  000aa	6a 01		 push	 1
  000ac	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  000b0	89 6c 24 1c	 mov	 DWORD PTR _ar$[esp+16448], ebp
  000b4	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000b9	8b 44 24 18	 mov	 eax, DWORD PTR _ar$[esp+16444]
  000bd	8a 8c 24 3c 40
	00 00		 mov	 cl, BYTE PTR _byPink$[esp+16432]
  000c4	88 08		 mov	 BYTE PTR [eax], cl
  000c6	ff 44 24 18	 inc	 DWORD PTR _ar$[esp+16444]

; 5072 : 	
; 5073 : 	GETBLOCK( ar, lpBuf, nBufSize );

  000ca	8d 54 24 0c	 lea	 edx, DWORD PTR _nBufSize$[esp+16436]
  000ce	52		 push	 edx
  000cf	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  000d3	e8 00 00 00 00	 call	 ?GetBuffer@CAr@@QAEPAEPAH@Z ; CAr::GetBuffer

; 5074 : 	FOR_VISIBILITYRANGE( pMover )

  000d8	8b be 10 02 00
	00		 mov	 edi, DWORD PTR [esi+528]
  000de	8b 37		 mov	 esi, DWORD PTR [edi]
  000e0	3b f7		 cmp	 esi, edi
  000e2	8b e8		 mov	 ebp, eax
  000e4	74 78		 je	 SHORT $L281633
  000e6	eb 08 8d a4 24
	00 00 00 00 90	 npad	 10
$L281632:

; 5075 : 		USERPTR->AddBlock( lpBuf, nBufSize );

  000f0	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  000f3	f6 40 04 01	 test	 BYTE PTR [eax+4], 1
  000f7	8b 4c 24 0c	 mov	 ecx, DWORD PTR _nBufSize$[esp+16436]
  000fb	75 14		 jne	 SHORT $L324930
  000fd	66 ff 80 0c 57
	00 00		 inc	 WORD PTR [eax+22284]
  00104	51		 push	 ecx
  00105	55		 push	 ebp
  00106	8d 88 f8 16 00
	00		 lea	 ecx, DWORD PTR [eax+5880]
  0010c	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
$L324930:

; 5076 : 	NEXT_VISIBILITYRANGE( pMover )

  00111	8a 46 15	 mov	 al, BYTE PTR [esi+21]
  00114	84 c0		 test	 al, al
  00116	75 42		 jne	 SHORT $L325078
  00118	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0011b	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  0011e	84 c9		 test	 cl, cl
  00120	75 1b		 jne	 SHORT $L325089
  00122	8b f0		 mov	 esi, eax
  00124	8b 06		 mov	 eax, DWORD PTR [esi]
  00126	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00129	84 c9		 test	 cl, cl
  0012b	75 2d		 jne	 SHORT $L325078
  0012d	8d 49 00	 npad	 3
$L325066:
  00130	8b f0		 mov	 esi, eax
  00132	8b 06		 mov	 eax, DWORD PTR [esi]
  00134	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00137	84 c9		 test	 cl, cl
  00139	74 f5		 je	 SHORT $L325066
  0013b	eb 1d		 jmp	 SHORT $L325078
$L325089:
  0013d	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00140	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00143	84 c9		 test	 cl, cl
  00145	75 11		 jne	 SHORT $L325082
$L325080:
  00147	3b 70 08	 cmp	 esi, DWORD PTR [eax+8]
  0014a	75 0c		 jne	 SHORT $L325082
  0014c	8b f0		 mov	 esi, eax
  0014e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00151	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00154	84 c9		 test	 cl, cl
  00156	74 ef		 je	 SHORT $L325080
$L325082:
  00158	8b f0		 mov	 esi, eax
$L325078:

; 5074 : 	FOR_VISIBILITYRANGE( pMover )

  0015a	3b f7		 cmp	 esi, edi
  0015c	75 92		 jne	 SHORT $L281632
$L281633:

; 5077 : }

  0015e	8d 4c 24 10	 lea	 ecx, DWORD PTR _ar$[esp+16436]
  00162	c7 84 24 30 40
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+16444], -1
  0016d	e8 00 00 00 00	 call	 ??1CAr@@QAE@XZ		; CAr::~CAr
  00172	8b 8c 24 28 40
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+16436]
  00179	5f		 pop	 edi
  0017a	5e		 pop	 esi
  0017b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00182	8b 8c 24 1c 40
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+16428]
  00189	5d		 pop	 ebp
  0018a	33 cc		 xor	 ecx, esp
  0018c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00191	81 c4 28 40 00
	00		 add	 esp, 16424		; 00004028H
  00197	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L324828:
  00000	8d 8d dc bf ff
	ff		 lea	 ecx, DWORD PTR _ar$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CAr@@QAE@XZ		; CAr::~CAr
__ehhandler$?AddPKPink@CUserMng@@QAEXPAVCMover@@E@Z:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T325086
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?AddPKPink@CUserMng@@QAEXPAVCMover@@E@Z ENDP		; CUserMng::AddPKPink
PUBLIC	?AddPKPropensity@CUserMng@@QAEXPAVCMover@@@Z	; CUserMng::AddPKPropensity
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
xdata$x	SEGMENT
$T325373 DD	0ffffffffH
	DD	FLAT:$L325103
$T325365 DD	019930520H
	DD	01H
	DD	FLAT:$T325373
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
xdata$x	ENDS
;	COMDAT ?AddPKPropensity@CUserMng@@QAEXPAVCMover@@@Z
_TEXT	SEGMENT
_nBufSize$ = -16424					; size = 4
_ar$ = -16420						; size = 16404
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_pMover$ = 8						; size = 4
?AddPKPropensity@CUserMng@@QAEXPAVCMover@@@Z PROC NEAR	; CUserMng::AddPKPropensity, COMDAT
; _this$ = ecx

; 5079 : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?AddPKPropensity@CUserMng@@QAEXPAVCMover@@@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	b8 1c 40 00 00	 mov	 eax, 16412		; 0000401cH
  00013	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0001a	e8 00 00 00 00	 call	 __chkstk
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00024	33 c4		 xor	 eax, esp
  00026	55		 push	 ebp
  00027	56		 push	 esi
  00028	8b b4 24 34 40
	00 00		 mov	 esi, DWORD PTR _pMover$[esp+16428]
  0002f	57		 push	 edi

; 5080 : 	CAr ar;

  00030	6a 00		 push	 0
  00032	6a 00		 push	 0
  00034	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  00038	89 84 24 2c 40
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+16444], eax
  0003f	e8 00 00 00 00	 call	 ??0CAr@@QAE@PAXI@Z	; CAr::CAr

; 5081 : 	ar << GETID( pMover ) << SNAPSHOTTYPE_PK_RELATION;

  00044	85 f6		 test	 esi, esi
  00046	c7 84 24 30 40
	00 00 00 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+16444], 0
  00051	74 08		 je	 SHORT $L325101
  00053	8b be bc 01 00
	00		 mov	 edi, DWORD PTR [esi+444]
  00059	eb 03		 jmp	 SHORT $L325102
$L325101:
  0005b	83 cf ff	 or	 edi, -1
$L325102:
  0005e	bd 04 00 00 00	 mov	 ebp, 4
  00063	55		 push	 ebp
  00064	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  00068	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0006d	8b 44 24 18	 mov	 eax, DWORD PTR _ar$[esp+16444]
  00071	89 38		 mov	 DWORD PTR [eax], edi
  00073	01 6c 24 18	 add	 DWORD PTR _ar$[esp+16444], ebp
  00077	6a 02		 push	 2
  00079	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  0007d	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00082	8b 4c 24 18	 mov	 ecx, DWORD PTR _ar$[esp+16444]
  00086	66 c7 01 65 00	 mov	 WORD PTR [ecx], 101	; 00000065H
  0008b	8b 7c 24 18	 mov	 edi, DWORD PTR _ar$[esp+16444]
  0008f	83 c7 02	 add	 edi, 2

; 5082 : 	ar << PK_PROPENSITY;

  00092	6a 01		 push	 1
  00094	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  00098	89 7c 24 1c	 mov	 DWORD PTR _ar$[esp+16448], edi
  0009c	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000a1	8b 54 24 18	 mov	 edx, DWORD PTR _ar$[esp+16444]
  000a5	c6 02 01	 mov	 BYTE PTR [edx], 1
  000a8	8b 4c 24 18	 mov	 ecx, DWORD PTR _ar$[esp+16444]

; 5083 : 	ar << pMover->GetPKPropensity();

  000ac	8b be 60 07 00
	00		 mov	 edi, DWORD PTR [esi+1888]
  000b2	41		 inc	 ecx
  000b3	89 4c 24 18	 mov	 DWORD PTR _ar$[esp+16444], ecx
  000b7	55		 push	 ebp
  000b8	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  000bc	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000c1	8b 44 24 18	 mov	 eax, DWORD PTR _ar$[esp+16444]
  000c5	89 38		 mov	 DWORD PTR [eax], edi
  000c7	8b 7c 24 18	 mov	 edi, DWORD PTR _ar$[esp+16444]

; 5084 : 
; 5085 : 	GETBLOCK( ar, lpBuf, nBufSize );

  000cb	8d 4c 24 0c	 lea	 ecx, DWORD PTR _nBufSize$[esp+16436]
  000cf	51		 push	 ecx
  000d0	03 fd		 add	 edi, ebp
  000d2	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  000d6	89 7c 24 1c	 mov	 DWORD PTR _ar$[esp+16448], edi
  000da	e8 00 00 00 00	 call	 ?GetBuffer@CAr@@QAEPAEPAH@Z ; CAr::GetBuffer

; 5086 : 	FOR_VISIBILITYRANGE( pMover )

  000df	8b be 10 02 00
	00		 mov	 edi, DWORD PTR [esi+528]
  000e5	8b 37		 mov	 esi, DWORD PTR [edi]
  000e7	3b f7		 cmp	 esi, edi
  000e9	8b e8		 mov	 ebp, eax
  000eb	74 71		 je	 SHORT $L281658
  000ed	8d 49 00	 npad	 3
$L281657:

; 5087 : 		USERPTR->AddBlock( lpBuf, nBufSize );

  000f0	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  000f3	f6 40 04 01	 test	 BYTE PTR [eax+4], 1
  000f7	8b 4c 24 0c	 mov	 ecx, DWORD PTR _nBufSize$[esp+16436]
  000fb	75 14		 jne	 SHORT $L325206
  000fd	66 ff 80 0c 57
	00 00		 inc	 WORD PTR [eax+22284]
  00104	51		 push	 ecx
  00105	55		 push	 ebp
  00106	8d 88 f8 16 00
	00		 lea	 ecx, DWORD PTR [eax+5880]
  0010c	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
$L325206:

; 5088 : 	NEXT_VISIBILITYRANGE( pMover )

  00111	8a 46 15	 mov	 al, BYTE PTR [esi+21]
  00114	84 c0		 test	 al, al
  00116	75 42		 jne	 SHORT $L325333
  00118	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0011b	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  0011e	84 c9		 test	 cl, cl
  00120	75 1b		 jne	 SHORT $L325368
  00122	8b f0		 mov	 esi, eax
  00124	8b 06		 mov	 eax, DWORD PTR [esi]
  00126	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00129	84 c9		 test	 cl, cl
  0012b	75 2d		 jne	 SHORT $L325333
  0012d	8d 49 00	 npad	 3
$L325348:
  00130	8b f0		 mov	 esi, eax
  00132	8b 06		 mov	 eax, DWORD PTR [esi]
  00134	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00137	84 c9		 test	 cl, cl
  00139	74 f5		 je	 SHORT $L325348
  0013b	eb 1d		 jmp	 SHORT $L325333
$L325368:
  0013d	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00140	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00143	84 c9		 test	 cl, cl
  00145	75 11		 jne	 SHORT $L325336
$L325335:
  00147	3b 70 08	 cmp	 esi, DWORD PTR [eax+8]
  0014a	75 0c		 jne	 SHORT $L325336
  0014c	8b f0		 mov	 esi, eax
  0014e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00151	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00154	84 c9		 test	 cl, cl
  00156	74 ef		 je	 SHORT $L325335
$L325336:
  00158	8b f0		 mov	 esi, eax
$L325333:

; 5086 : 	FOR_VISIBILITYRANGE( pMover )

  0015a	3b f7		 cmp	 esi, edi
  0015c	75 92		 jne	 SHORT $L281657
$L281658:

; 5089 : }

  0015e	8d 4c 24 10	 lea	 ecx, DWORD PTR _ar$[esp+16436]
  00162	c7 84 24 30 40
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+16444], -1
  0016d	e8 00 00 00 00	 call	 ??1CAr@@QAE@XZ		; CAr::~CAr
  00172	8b 8c 24 28 40
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+16436]
  00179	5f		 pop	 edi
  0017a	5e		 pop	 esi
  0017b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00182	8b 8c 24 1c 40
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+16428]
  00189	5d		 pop	 ebp
  0018a	33 cc		 xor	 ecx, esp
  0018c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00191	81 c4 28 40 00
	00		 add	 esp, 16424		; 00004028H
  00197	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L325103:
  00000	8d 8d dc bf ff
	ff		 lea	 ecx, DWORD PTR _ar$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CAr@@QAE@XZ		; CAr::~CAr
__ehhandler$?AddPKPropensity@CUserMng@@QAEXPAVCMover@@@Z:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T325365
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?AddPKPropensity@CUserMng@@QAEXPAVCMover@@@Z ENDP	; CUserMng::AddPKPropensity
PUBLIC	?AddCreateSfxAllow@CUserMng@@QAEXPAVCMover@@KKUD3DXVECTOR3@@H@Z ; CUserMng::AddCreateSfxAllow
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
xdata$x	SEGMENT
$T325689 DD	0ffffffffH
	DD	FLAT:$L325382
$T325681 DD	019930520H
	DD	01H
	DD	FLAT:$T325689
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
xdata$x	ENDS
;	COMDAT ?AddCreateSfxAllow@CUserMng@@QAEXPAVCMover@@KKUD3DXVECTOR3@@H@Z
_TEXT	SEGMENT
_nBufSize$ = -16424					; size = 4
_ar$ = -16420						; size = 16404
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_pMover$ = 8						; size = 4
_dwSfxObjArrow$ = 12					; size = 4
_dwSfxObjHit$ = 16					; size = 4
_vPosDest$ = 20						; size = 12
_idTarget$ = 32						; size = 4
?AddCreateSfxAllow@CUserMng@@QAEXPAVCMover@@KKUD3DXVECTOR3@@H@Z PROC NEAR ; CUserMng::AddCreateSfxAllow, COMDAT
; _this$ = ecx

; 5102 : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?AddCreateSfxAllow@CUserMng@@QAEXPAVCMover@@KKUD3DXVECTOR3@@H@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	b8 1c 40 00 00	 mov	 eax, 16412		; 0000401cH
  00013	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0001a	e8 00 00 00 00	 call	 __chkstk
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00024	33 c4		 xor	 eax, esp
  00026	53		 push	 ebx
  00027	55		 push	 ebp
  00028	8b ac 24 34 40
	00 00		 mov	 ebp, DWORD PTR _pMover$[esp+16428]
  0002f	56		 push	 esi
  00030	57		 push	 edi

; 5103 : 	CAr ar;

  00031	6a 00		 push	 0
  00033	6a 00		 push	 0
  00035	8d 4c 24 1c	 lea	 ecx, DWORD PTR _ar$[esp+16448]
  00039	89 84 24 30 40
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+16448], eax
  00040	e8 00 00 00 00	 call	 ??0CAr@@QAE@PAXI@Z	; CAr::CAr

; 5104 : 	ar << GETID( pMover ) << SNAPSHOTTYPE_CREATESFXALLOW;

  00045	85 ed		 test	 ebp, ebp
  00047	c7 84 24 34 40
	00 00 00 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+16448], 0
  00052	74 08		 je	 SHORT $L325380
  00054	8b b5 bc 01 00
	00		 mov	 esi, DWORD PTR [ebp+444]
  0005a	eb 03		 jmp	 SHORT $L325381
$L325380:
  0005c	83 ce ff	 or	 esi, -1
$L325381:
  0005f	bf 04 00 00 00	 mov	 edi, 4
  00064	57		 push	 edi
  00065	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  00069	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0006e	8b 44 24 1c	 mov	 eax, DWORD PTR _ar$[esp+16448]
  00072	89 30		 mov	 DWORD PTR [eax], esi
  00074	01 7c 24 1c	 add	 DWORD PTR _ar$[esp+16448], edi
  00078	6a 02		 push	 2
  0007a	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  0007e	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00083	8b 4c 24 1c	 mov	 ecx, DWORD PTR _ar$[esp+16448]
  00087	66 c7 01 aa 00	 mov	 WORD PTR [ecx], 170	; 000000aaH
  0008c	8b 5c 24 1c	 mov	 ebx, DWORD PTR _ar$[esp+16448]
  00090	83 c3 02	 add	 ebx, 2

; 5105 : 	ar << dwSfxObjArrow << dwSfxObjHit << vPosDest.x << vPosDest.y << vPosDest.z << idTarget;

  00093	57		 push	 edi
  00094	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  00098	89 5c 24 20	 mov	 DWORD PTR _ar$[esp+16452], ebx
  0009c	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000a1	8b 54 24 1c	 mov	 edx, DWORD PTR _ar$[esp+16448]
  000a5	8b 84 24 40 40
	00 00		 mov	 eax, DWORD PTR _dwSfxObjArrow$[esp+16436]
  000ac	89 02		 mov	 DWORD PTR [edx], eax
  000ae	8b 54 24 1c	 mov	 edx, DWORD PTR _ar$[esp+16448]
  000b2	03 d7		 add	 edx, edi
  000b4	57		 push	 edi
  000b5	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  000b9	89 54 24 20	 mov	 DWORD PTR _ar$[esp+16452], edx
  000bd	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000c2	8b 4c 24 1c	 mov	 ecx, DWORD PTR _ar$[esp+16448]
  000c6	8b 94 24 44 40
	00 00		 mov	 edx, DWORD PTR _dwSfxObjHit$[esp+16436]
  000cd	89 11		 mov	 DWORD PTR [ecx], edx
  000cf	8b 44 24 1c	 mov	 eax, DWORD PTR _ar$[esp+16448]
  000d3	03 c7		 add	 eax, edi
  000d5	57		 push	 edi
  000d6	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  000da	89 44 24 20	 mov	 DWORD PTR _ar$[esp+16452], eax
  000de	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000e3	d9 84 24 48 40
	00 00		 fld	 DWORD PTR _vPosDest$[esp+16436]
  000ea	8b 44 24 1c	 mov	 eax, DWORD PTR _ar$[esp+16448]
  000ee	d9 18		 fstp	 DWORD PTR [eax]
  000f0	8b 74 24 1c	 mov	 esi, DWORD PTR _ar$[esp+16448]
  000f4	03 f7		 add	 esi, edi
  000f6	57		 push	 edi
  000f7	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  000fb	89 74 24 20	 mov	 DWORD PTR _ar$[esp+16452], esi
  000ff	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00104	d9 84 24 4c 40
	00 00		 fld	 DWORD PTR _vPosDest$[esp+16440]
  0010b	8b 4c 24 1c	 mov	 ecx, DWORD PTR _ar$[esp+16448]
  0010f	d9 19		 fstp	 DWORD PTR [ecx]
  00111	8b 4c 24 1c	 mov	 ecx, DWORD PTR _ar$[esp+16448]
  00115	03 cf		 add	 ecx, edi
  00117	89 4c 24 1c	 mov	 DWORD PTR _ar$[esp+16448], ecx
  0011b	57		 push	 edi
  0011c	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  00120	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00125	d9 84 24 50 40
	00 00		 fld	 DWORD PTR _vPosDest$[esp+16444]
  0012c	8b 54 24 1c	 mov	 edx, DWORD PTR _ar$[esp+16448]
  00130	d9 1a		 fstp	 DWORD PTR [edx]
  00132	8b 5c 24 1c	 mov	 ebx, DWORD PTR _ar$[esp+16448]
  00136	03 df		 add	 ebx, edi
  00138	57		 push	 edi
  00139	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  0013d	89 5c 24 20	 mov	 DWORD PTR _ar$[esp+16452], ebx
  00141	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00146	8b 44 24 1c	 mov	 eax, DWORD PTR _ar$[esp+16448]
  0014a	8b 8c 24 54 40
	00 00		 mov	 ecx, DWORD PTR _idTarget$[esp+16436]
  00151	89 08		 mov	 DWORD PTR [eax], ecx
  00153	01 7c 24 1c	 add	 DWORD PTR _ar$[esp+16448], edi

; 5106 : 	GETBLOCK( ar, lpBuf, nBufSize );

  00157	8d 54 24 10	 lea	 edx, DWORD PTR _nBufSize$[esp+16440]
  0015b	52		 push	 edx
  0015c	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  00160	e8 00 00 00 00	 call	 ?GetBuffer@CAr@@QAEPAEPAH@Z ; CAr::GetBuffer

; 5107 : 	
; 5108 : 	FOR_VISIBILITYRANGE( pMover )

  00165	8b bd 10 02 00
	00		 mov	 edi, DWORD PTR [ebp+528]
  0016b	8b 37		 mov	 esi, DWORD PTR [edi]
  0016d	3b f7		 cmp	 esi, edi
  0016f	8b d8		 mov	 ebx, eax
  00171	74 74		 je	 SHORT $L281701
$L281700:

; 5109 : 		if( USERPTR != pMover )

  00173	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00176	3b c5		 cmp	 eax, ebp
  00178	74 1e		 je	 SHORT $L325522

; 5110 : 			USERPTR->AddBlock( lpBuf, nBufSize );

  0017a	f6 40 04 01	 test	 BYTE PTR [eax+4], 1
  0017e	8b 4c 24 10	 mov	 ecx, DWORD PTR _nBufSize$[esp+16440]
  00182	75 14		 jne	 SHORT $L325522
  00184	66 ff 80 0c 57
	00 00		 inc	 WORD PTR [eax+22284]
  0018b	51		 push	 ecx
  0018c	53		 push	 ebx
  0018d	8d 88 f8 16 00
	00		 lea	 ecx, DWORD PTR [eax+5880]
  00193	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
$L325522:

; 5111 : 	NEXT_VISIBILITYRANGE( pMover )

  00198	8a 46 15	 mov	 al, BYTE PTR [esi+21]
  0019b	84 c0		 test	 al, al
  0019d	75 44		 jne	 SHORT $L325660
  0019f	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  001a2	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  001a5	84 c9		 test	 cl, cl
  001a7	75 18		 jne	 SHORT $L325684
  001a9	8b f0		 mov	 esi, eax
  001ab	8b 06		 mov	 eax, DWORD PTR [esi]
  001ad	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  001b0	84 c9		 test	 cl, cl
  001b2	75 2f		 jne	 SHORT $L325660
$L325674:
  001b4	8b f0		 mov	 esi, eax
  001b6	8b 06		 mov	 eax, DWORD PTR [esi]
  001b8	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  001bb	84 c9		 test	 cl, cl
  001bd	74 f5		 je	 SHORT $L325674
  001bf	eb 22		 jmp	 SHORT $L325660
$L325684:
  001c1	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  001c4	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  001c7	84 c9		 test	 cl, cl
  001c9	75 16		 jne	 SHORT $L325663
  001cb	eb 03 8d 49 00	 npad	 5
$L325662:
  001d0	3b 70 08	 cmp	 esi, DWORD PTR [eax+8]
  001d3	75 0c		 jne	 SHORT $L325663
  001d5	8b f0		 mov	 esi, eax
  001d7	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001da	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  001dd	84 c9		 test	 cl, cl
  001df	74 ef		 je	 SHORT $L325662
$L325663:
  001e1	8b f0		 mov	 esi, eax
$L325660:

; 5107 : 	
; 5108 : 	FOR_VISIBILITYRANGE( pMover )

  001e3	3b f7		 cmp	 esi, edi
  001e5	75 8c		 jne	 SHORT $L281700
$L281701:

; 5112 : }

  001e7	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  001eb	c7 84 24 34 40
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+16448], -1
  001f6	e8 00 00 00 00	 call	 ??1CAr@@QAE@XZ		; CAr::~CAr
  001fb	8b 8c 24 2c 40
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+16440]
  00202	5f		 pop	 edi
  00203	5e		 pop	 esi
  00204	5d		 pop	 ebp
  00205	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0020c	8b 8c 24 1c 40
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+16428]
  00213	5b		 pop	 ebx
  00214	33 cc		 xor	 ecx, esp
  00216	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0021b	81 c4 28 40 00
	00		 add	 esp, 16424		; 00004028H
  00221	c2 1c 00	 ret	 28			; 0000001cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L325382:
  00000	8d 8d dc bf ff
	ff		 lea	 ecx, DWORD PTR _ar$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CAr@@QAE@XZ		; CAr::~CAr
__ehhandler$?AddCreateSfxAllow@CUserMng@@QAEXPAVCMover@@KKUD3DXVECTOR3@@H@Z:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T325681
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?AddCreateSfxAllow@CUserMng@@QAEXPAVCMover@@KKUD3DXVECTOR3@@H@Z ENDP ; CUserMng::AddCreateSfxAllow
PUBLIC	?AddNearSetChangeJob@CUserMng@@QAEXPAVCMover@@HPAUtagSkill@@@Z ; CUserMng::AddNearSetChangeJob
EXTRN	?IsMaster@CMover@@QAEHXZ:NEAR			; CMover::IsMaster
EXTRN	?IsHero@CMover@@QAEHXZ:NEAR			; CMover::IsHero
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
xdata$x	SEGMENT
$T325991 DD	0ffffffffH
	DD	FLAT:$L325698
$T325982 DD	019930520H
	DD	01H
	DD	FLAT:$T325991
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
xdata$x	ENDS
;	COMDAT ?AddNearSetChangeJob@CUserMng@@QAEXPAVCMover@@HPAUtagSkill@@@Z
_TEXT	SEGMENT
_nBufSize$ = -16424					; size = 4
_ar$ = -16420						; size = 16404
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_pMover$ = 8						; size = 4
_nJob$ = 12						; size = 4
_lpSkill$ = 16						; size = 4
?AddNearSetChangeJob@CUserMng@@QAEXPAVCMover@@HPAUtagSkill@@@Z PROC NEAR ; CUserMng::AddNearSetChangeJob, COMDAT
; _this$ = ecx

; 5115 : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?AddNearSetChangeJob@CUserMng@@QAEXPAVCMover@@HPAUtagSkill@@@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	b8 1c 40 00 00	 mov	 eax, 16412		; 0000401cH
  00013	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0001a	e8 00 00 00 00	 call	 __chkstk
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00024	33 c4		 xor	 eax, esp
  00026	53		 push	 ebx
  00027	55		 push	 ebp
  00028	56		 push	 esi
  00029	57		 push	 edi
  0002a	8b bc 24 3c 40
	00 00		 mov	 edi, DWORD PTR _pMover$[esp+16436]

; 5116 : 	CAr ar;

  00031	6a 00		 push	 0
  00033	6a 00		 push	 0
  00035	8d 4c 24 1c	 lea	 ecx, DWORD PTR _ar$[esp+16448]
  00039	89 84 24 30 40
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+16448], eax
  00040	e8 00 00 00 00	 call	 ??0CAr@@QAE@PAXI@Z	; CAr::CAr

; 5117 : 	ar << GETID( pMover ) << SNAPSHOTTYPE_SET_NEAR_JOB_SKILL;

  00045	85 ff		 test	 edi, edi
  00047	c7 84 24 34 40
	00 00 00 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+16448], 0
  00052	74 08		 je	 SHORT $L325696
  00054	8b b7 bc 01 00
	00		 mov	 esi, DWORD PTR [edi+444]
  0005a	eb 03		 jmp	 SHORT $L325697
$L325696:
  0005c	83 ce ff	 or	 esi, -1
$L325697:
  0005f	bb 04 00 00 00	 mov	 ebx, 4
  00064	53		 push	 ebx
  00065	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  00069	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0006e	8b 44 24 1c	 mov	 eax, DWORD PTR _ar$[esp+16448]
  00072	89 30		 mov	 DWORD PTR [eax], esi
  00074	01 5c 24 1c	 add	 DWORD PTR _ar$[esp+16448], ebx
  00078	6a 02		 push	 2
  0007a	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  0007e	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00083	8b 4c 24 1c	 mov	 ecx, DWORD PTR _ar$[esp+16448]
  00087	66 c7 01 a8 00	 mov	 WORD PTR [ecx], 168	; 000000a8H
  0008c	8b 6c 24 1c	 mov	 ebp, DWORD PTR _ar$[esp+16448]
  00090	83 c5 02	 add	 ebp, 2

; 5118 : 	ar << nJob;

  00093	53		 push	 ebx
  00094	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  00098	89 6c 24 20	 mov	 DWORD PTR _ar$[esp+16452], ebp
  0009c	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000a1	8b 54 24 1c	 mov	 edx, DWORD PTR _ar$[esp+16448]
  000a5	8b 84 24 40 40
	00 00		 mov	 eax, DWORD PTR _nJob$[esp+16436]
  000ac	89 02		 mov	 DWORD PTR [edx], eax
  000ae	8b 54 24 1c	 mov	 edx, DWORD PTR _ar$[esp+16448]
  000b2	03 d3		 add	 edx, ebx

; 5119 : #if __VER >= 10 // __LEGEND	//	10 	Neuz, World, Trans
; 5120 : 	if( pMover->IsHero() )

  000b4	8b cf		 mov	 ecx, edi
  000b6	89 54 24 1c	 mov	 DWORD PTR _ar$[esp+16448], edx
  000ba	e8 00 00 00 00	 call	 ?IsHero@CMover@@QAEHXZ	; CMover::IsHero
  000bf	85 c0		 test	 eax, eax
  000c1	74 0e		 je	 SHORT $L281711

; 5121 : 		ar.Write( (void*)&pMover->m_aJobSkill[MAX_EXPERT_SKILL ], sizeof(SKILL) *  ( MAX_PRO_SKILL + MAX_MASTER_SKILL ) );

  000c3	68 a8 00 00 00	 push	 168			; 000000a8H
  000c8	8d 8f 0c 04 00
	00		 lea	 ecx, DWORD PTR [edi+1036]
  000ce	51		 push	 ecx

; 5122 : 	else if( pMover->IsMaster() )

  000cf	eb 25		 jmp	 SHORT $L325990
$L281711:
  000d1	8b cf		 mov	 ecx, edi
  000d3	e8 00 00 00 00	 call	 ?IsMaster@CMover@@QAEHXZ ; CMover::IsMaster
  000d8	85 c0		 test	 eax, eax
  000da	74 0e		 je	 SHORT $L281715

; 5123 : 		ar.Write( (void*)&pMover->m_aJobSkill[MAX_EXPERT_SKILL ], sizeof(SKILL) *  ( MAX_PRO_SKILL + MAX_MASTER_SKILL ) );

  000dc	68 a8 00 00 00	 push	 168			; 000000a8H
  000e1	8d 97 0c 04 00
	00		 lea	 edx, DWORD PTR [edi+1036]
  000e7	52		 push	 edx

; 5124 : 	else

  000e8	eb 0c		 jmp	 SHORT $L325990
$L281715:

; 5125 : 		ar.Write( (void*)&pMover->m_aJobSkill[MAX_JOB_SKILL], sizeof(SKILL) *  ( MAX_EXPERT_SKILL ) );

  000ea	68 a0 00 00 00	 push	 160			; 000000a0H
  000ef	8d 87 84 03 00
	00		 lea	 eax, DWORD PTR [edi+900]
  000f5	50		 push	 eax
$L325990:
  000f6	8d 4c 24 1c	 lea	 ecx, DWORD PTR _ar$[esp+16448]
  000fa	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write

; 5126 : #else //__LEGEND	//	10 	Neuz, World, Trans
; 5127 : 	ar.Write( (void*)&pMover->m_aJobSkill[MAX_JOB_SKILL], sizeof(SKILL) *  ( MAX_EXPERT_SKILL ) );
; 5128 : #endif	//__LEGEND	//	10 	Neuz, World, Trans
; 5129 : 
; 5130 : 	GETBLOCK( ar, lpBuf, nBufSize );

  000ff	8d 4c 24 10	 lea	 ecx, DWORD PTR _nBufSize$[esp+16440]
  00103	51		 push	 ecx
  00104	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  00108	e8 00 00 00 00	 call	 ?GetBuffer@CAr@@QAEPAEPAH@Z ; CAr::GetBuffer

; 5131 : 	
; 5132 : 	FOR_VISIBILITYRANGE( pMover )

  0010d	8b af 10 02 00
	00		 mov	 ebp, DWORD PTR [edi+528]
  00113	8b 75 00	 mov	 esi, DWORD PTR [ebp]
  00116	3b f5		 cmp	 esi, ebp
  00118	8b d8		 mov	 ebx, eax
  0011a	74 73		 je	 SHORT $L281739
  0011c	8d 64 24 00	 npad	 4
$L281738:

; 5133 : 		if( USERPTR != pMover )

  00120	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00123	3b c7		 cmp	 eax, edi
  00125	74 1e		 je	 SHORT $L325826

; 5134 : 			USERPTR->AddBlock( lpBuf, nBufSize );

  00127	f6 40 04 01	 test	 BYTE PTR [eax+4], 1
  0012b	8b 4c 24 10	 mov	 ecx, DWORD PTR _nBufSize$[esp+16440]
  0012f	75 14		 jne	 SHORT $L325826
  00131	66 ff 80 0c 57
	00 00		 inc	 WORD PTR [eax+22284]
  00138	51		 push	 ecx
  00139	53		 push	 ebx
  0013a	8d 88 f8 16 00
	00		 lea	 ecx, DWORD PTR [eax+5880]
  00140	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
$L325826:

; 5135 : 	NEXT_VISIBILITYRANGE( pMover )

  00145	8a 46 15	 mov	 al, BYTE PTR [esi+21]
  00148	84 c0		 test	 al, al
  0014a	75 3f		 jne	 SHORT $L325974
  0014c	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0014f	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00152	84 c9		 test	 cl, cl
  00154	75 18		 jne	 SHORT $L325985
  00156	8b f0		 mov	 esi, eax
  00158	8b 06		 mov	 eax, DWORD PTR [esi]
  0015a	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  0015d	84 c9		 test	 cl, cl
  0015f	75 2a		 jne	 SHORT $L325974
$L325962:
  00161	8b f0		 mov	 esi, eax
  00163	8b 06		 mov	 eax, DWORD PTR [esi]
  00165	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00168	84 c9		 test	 cl, cl
  0016a	74 f5		 je	 SHORT $L325962
  0016c	eb 1d		 jmp	 SHORT $L325974
$L325985:
  0016e	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00171	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00174	84 c9		 test	 cl, cl
  00176	75 11		 jne	 SHORT $L325977
$L325976:
  00178	3b 70 08	 cmp	 esi, DWORD PTR [eax+8]
  0017b	75 0c		 jne	 SHORT $L325977
  0017d	8b f0		 mov	 esi, eax
  0017f	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00182	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00185	84 c9		 test	 cl, cl
  00187	74 ef		 je	 SHORT $L325976
$L325977:
  00189	8b f0		 mov	 esi, eax
$L325974:

; 5131 : 	
; 5132 : 	FOR_VISIBILITYRANGE( pMover )

  0018b	3b f5		 cmp	 esi, ebp
  0018d	75 91		 jne	 SHORT $L281738
$L281739:

; 5136 : }

  0018f	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  00193	c7 84 24 34 40
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+16448], -1
  0019e	e8 00 00 00 00	 call	 ??1CAr@@QAE@XZ		; CAr::~CAr
  001a3	8b 8c 24 2c 40
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+16440]
  001aa	5f		 pop	 edi
  001ab	5e		 pop	 esi
  001ac	5d		 pop	 ebp
  001ad	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  001b4	8b 8c 24 1c 40
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+16428]
  001bb	5b		 pop	 ebx
  001bc	33 cc		 xor	 ecx, esp
  001be	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001c3	81 c4 28 40 00
	00		 add	 esp, 16424		; 00004028H
  001c9	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L325698:
  00000	8d 8d dc bf ff
	ff		 lea	 ecx, DWORD PTR _ar$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CAr@@QAE@XZ		; CAr::~CAr
__ehhandler$?AddNearSetChangeJob@CUserMng@@QAEXPAVCMover@@HPAUtagSkill@@@Z:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T325982
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?AddNearSetChangeJob@CUserMng@@QAEXPAVCMover@@HPAUtagSkill@@@Z ENDP ; CUserMng::AddNearSetChangeJob
PUBLIC	?AddModifyMode@CUserMng@@QAEXPAVCUser@@@Z	; CUserMng::AddModifyMode
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
xdata$x	SEGMENT
$T326264 DD	0ffffffffH
	DD	FLAT:$L326000
$T326256 DD	019930520H
	DD	01H
	DD	FLAT:$T326264
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
xdata$x	ENDS
;	COMDAT ?AddModifyMode@CUserMng@@QAEXPAVCUser@@@Z
_TEXT	SEGMENT
_nBufSize$ = -16424					; size = 4
_ar$ = -16420						; size = 16404
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_pUser$ = 8						; size = 4
?AddModifyMode@CUserMng@@QAEXPAVCUser@@@Z PROC NEAR	; CUserMng::AddModifyMode, COMDAT
; _this$ = ecx

; 5139 : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?AddModifyMode@CUserMng@@QAEXPAVCUser@@@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	b8 1c 40 00 00	 mov	 eax, 16412		; 0000401cH
  00013	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0001a	e8 00 00 00 00	 call	 __chkstk
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00024	33 c4		 xor	 eax, esp
  00026	55		 push	 ebp
  00027	56		 push	 esi
  00028	8b b4 24 34 40
	00 00		 mov	 esi, DWORD PTR _pUser$[esp+16428]
  0002f	57		 push	 edi

; 5140 : 	CAr ar;

  00030	6a 00		 push	 0
  00032	6a 00		 push	 0
  00034	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  00038	89 84 24 2c 40
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+16444], eax
  0003f	e8 00 00 00 00	 call	 ??0CAr@@QAE@PAXI@Z	; CAr::CAr

; 5141 : 	ar << GETID( pUser ) << SNAPSHOTTYPE_MODIFYMODE;

  00044	85 f6		 test	 esi, esi
  00046	c7 84 24 30 40
	00 00 00 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+16444], 0
  00051	74 08		 je	 SHORT $L325998
  00053	8b be bc 01 00
	00		 mov	 edi, DWORD PTR [esi+444]
  00059	eb 03		 jmp	 SHORT $L325999
$L325998:
  0005b	83 cf ff	 or	 edi, -1
$L325999:
  0005e	6a 04		 push	 4
  00060	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  00064	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00069	8b 44 24 18	 mov	 eax, DWORD PTR _ar$[esp+16444]
  0006d	89 38		 mov	 DWORD PTR [eax], edi
  0006f	8b 54 24 18	 mov	 edx, DWORD PTR _ar$[esp+16444]
  00073	83 c2 04	 add	 edx, 4
  00076	6a 02		 push	 2
  00078	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  0007c	89 54 24 1c	 mov	 DWORD PTR _ar$[esp+16448], edx
  00080	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00085	8b 4c 24 18	 mov	 ecx, DWORD PTR _ar$[esp+16444]
  00089	66 c7 01 d3 00	 mov	 WORD PTR [ecx], 211	; 000000d3H
  0008e	8b 44 24 18	 mov	 eax, DWORD PTR _ar$[esp+16444]

; 5142 : 	ar << pUser->m_dwMode;

  00092	8b be 44 02 00
	00		 mov	 edi, DWORD PTR [esi+580]
  00098	83 c0 02	 add	 eax, 2
  0009b	6a 04		 push	 4
  0009d	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  000a1	89 44 24 1c	 mov	 DWORD PTR _ar$[esp+16448], eax
  000a5	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000aa	8b 54 24 18	 mov	 edx, DWORD PTR _ar$[esp+16444]
  000ae	89 3a		 mov	 DWORD PTR [edx], edi
  000b0	8b 54 24 18	 mov	 edx, DWORD PTR _ar$[esp+16444]

; 5143 : 	
; 5144 : 	GETBLOCK( ar, lpBuf, nBufSize );

  000b4	8d 44 24 0c	 lea	 eax, DWORD PTR _nBufSize$[esp+16436]
  000b8	83 c2 04	 add	 edx, 4
  000bb	50		 push	 eax
  000bc	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  000c0	89 54 24 1c	 mov	 DWORD PTR _ar$[esp+16448], edx
  000c4	e8 00 00 00 00	 call	 ?GetBuffer@CAr@@QAEPAEPAH@Z ; CAr::GetBuffer

; 5145 : 	
; 5146 : 	FOR_VISIBILITYRANGE( pUser )

  000c9	8b be 10 02 00
	00		 mov	 edi, DWORD PTR [esi+528]
  000cf	8b 37		 mov	 esi, DWORD PTR [edi]
  000d1	3b f7		 cmp	 esi, edi
  000d3	8b e8		 mov	 ebp, eax
  000d5	74 77		 je	 SHORT $L281765
  000d7	eb 07 8d a4 24
	00 00 00 00	 npad	 9
$L281764:

; 5147 : 		USERPTR->AddBlock( lpBuf, nBufSize );

  000e0	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  000e3	f6 40 04 01	 test	 BYTE PTR [eax+4], 1
  000e7	8b 4c 24 0c	 mov	 ecx, DWORD PTR _nBufSize$[esp+16436]
  000eb	75 14		 jne	 SHORT $L326100
  000ed	66 ff 80 0c 57
	00 00		 inc	 WORD PTR [eax+22284]
  000f4	51		 push	 ecx
  000f5	55		 push	 ebp
  000f6	8d 88 f8 16 00
	00		 lea	 ecx, DWORD PTR [eax+5880]
  000fc	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
$L326100:

; 5148 : 	NEXT_VISIBILITYRANGE( pUser )

  00101	8a 46 15	 mov	 al, BYTE PTR [esi+21]
  00104	84 c0		 test	 al, al
  00106	75 42		 jne	 SHORT $L326224
  00108	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0010b	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  0010e	84 c9		 test	 cl, cl
  00110	75 1b		 jne	 SHORT $L326259
  00112	8b f0		 mov	 esi, eax
  00114	8b 06		 mov	 eax, DWORD PTR [esi]
  00116	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00119	84 c9		 test	 cl, cl
  0011b	75 2d		 jne	 SHORT $L326224
  0011d	8d 49 00	 npad	 3
$L326245:
  00120	8b f0		 mov	 esi, eax
  00122	8b 06		 mov	 eax, DWORD PTR [esi]
  00124	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00127	84 c9		 test	 cl, cl
  00129	74 f5		 je	 SHORT $L326245
  0012b	eb 1d		 jmp	 SHORT $L326224
$L326259:
  0012d	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00130	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00133	84 c9		 test	 cl, cl
  00135	75 11		 jne	 SHORT $L326227
$L326226:
  00137	3b 70 08	 cmp	 esi, DWORD PTR [eax+8]
  0013a	75 0c		 jne	 SHORT $L326227
  0013c	8b f0		 mov	 esi, eax
  0013e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00141	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00144	84 c9		 test	 cl, cl
  00146	74 ef		 je	 SHORT $L326226
$L326227:
  00148	8b f0		 mov	 esi, eax
$L326224:

; 5145 : 	
; 5146 : 	FOR_VISIBILITYRANGE( pUser )

  0014a	3b f7		 cmp	 esi, edi
  0014c	75 92		 jne	 SHORT $L281764
$L281765:

; 5149 : }

  0014e	8d 4c 24 10	 lea	 ecx, DWORD PTR _ar$[esp+16436]
  00152	c7 84 24 30 40
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+16444], -1
  0015d	e8 00 00 00 00	 call	 ??1CAr@@QAE@XZ		; CAr::~CAr
  00162	8b 8c 24 28 40
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+16436]
  00169	5f		 pop	 edi
  0016a	5e		 pop	 esi
  0016b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00172	8b 8c 24 1c 40
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+16428]
  00179	5d		 pop	 ebp
  0017a	33 cc		 xor	 ecx, esp
  0017c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00181	81 c4 28 40 00
	00		 add	 esp, 16424		; 00004028H
  00187	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L326000:
  00000	8d 8d dc bf ff
	ff		 lea	 ecx, DWORD PTR _ar$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CAr@@QAE@XZ		; CAr::~CAr
__ehhandler$?AddModifyMode@CUserMng@@QAEXPAVCUser@@@Z:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T326256
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?AddModifyMode@CUserMng@@QAEXPAVCUser@@@Z ENDP		; CUserMng::AddModifyMode
PUBLIC	??_C@_0BD@LCNGLDCF@?$LD?$KK?$LP?$MA?$LI?i?5?$LO?H?$LF?J?4?4?5?$LN?C?$MA?$PM?$AA@ ; `string'
PUBLIC	?AddStateMode@CUserMng@@QAEXPAVCUser@@E@Z	; CUserMng::AddStateMode
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
xdata$x	SEGMENT
$T326563 DD	0ffffffffH
	DD	FLAT:$L326273
$T326555 DD	019930520H
	DD	01H
	DD	FLAT:$T326563
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_C@_0BD@LCNGLDCF@?$LD?$KK?$LP?$MA?$LI?i?5?$LO?H?$LF?J?4?4?5?$LN?C?$MA?$PM?$AA@
CONST	SEGMENT
??_C@_0BD@LCNGLDCF@?$LD?$KK?$LP?$MA?$LI?i?5?$LO?H?$LF?J?4?4?5?$LN?C?$MA?$PM?$AA@ DB 0b3H
	DB	0aaH, 0bfH, 0c0H, 0b8H, 0e9H, ' ', 0beH, 0c8H, 0b5H, 0caH, '..'
	DB	' ', 0bdH, 0c3H, 0c0H, 0fcH, 00H		; `string'
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
CONST	ENDS
;	COMDAT ?AddStateMode@CUserMng@@QAEXPAVCUser@@E@Z
_TEXT	SEGMENT
_nBufSize$ = -16424					; size = 4
_ar$ = -16420						; size = 16404
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_pUser$ = 8						; size = 4
_nFlag$ = 12						; size = 1
?AddStateMode@CUserMng@@QAEXPAVCUser@@E@Z PROC NEAR	; CUserMng::AddStateMode, COMDAT
; _this$ = ecx

; 5152 : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?AddStateMode@CUserMng@@QAEXPAVCUser@@E@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	b8 1c 40 00 00	 mov	 eax, 16412		; 0000401cH
  00013	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0001a	e8 00 00 00 00	 call	 __chkstk
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00024	33 c4		 xor	 eax, esp
  00026	55		 push	 ebp
  00027	56		 push	 esi
  00028	8b b4 24 34 40
	00 00		 mov	 esi, DWORD PTR _pUser$[esp+16428]
  0002f	57		 push	 edi

; 5153 : 	CAr ar;

  00030	6a 00		 push	 0
  00032	6a 00		 push	 0
  00034	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  00038	89 84 24 2c 40
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+16444], eax
  0003f	e8 00 00 00 00	 call	 ??0CAr@@QAE@PAXI@Z	; CAr::CAr

; 5154 : 	ar << GETID( pUser ) << SNAPSHOTTYPE_STATEMODE;

  00044	85 f6		 test	 esi, esi
  00046	c7 84 24 30 40
	00 00 00 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+16444], 0
  00051	74 08		 je	 SHORT $L326271
  00053	8b be bc 01 00
	00		 mov	 edi, DWORD PTR [esi+444]
  00059	eb 03		 jmp	 SHORT $L326272
$L326271:
  0005b	83 cf ff	 or	 edi, -1
$L326272:
  0005e	bd 04 00 00 00	 mov	 ebp, 4
  00063	55		 push	 ebp
  00064	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  00068	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0006d	8b 44 24 18	 mov	 eax, DWORD PTR _ar$[esp+16444]
  00071	89 38		 mov	 DWORD PTR [eax], edi
  00073	8b 44 24 18	 mov	 eax, DWORD PTR _ar$[esp+16444]
  00077	03 c5		 add	 eax, ebp
  00079	6a 02		 push	 2
  0007b	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  0007f	89 44 24 1c	 mov	 DWORD PTR _ar$[esp+16448], eax
  00083	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00088	8b 4c 24 18	 mov	 ecx, DWORD PTR _ar$[esp+16444]
  0008c	66 c7 01 df 00	 mov	 WORD PTR [ecx], 223	; 000000dfH
  00091	8b 54 24 18	 mov	 edx, DWORD PTR _ar$[esp+16444]

; 5155 : 	ar << pUser->m_dwStateMode;

  00095	8b be 4c 02 00
	00		 mov	 edi, DWORD PTR [esi+588]
  0009b	83 c2 02	 add	 edx, 2
  0009e	55		 push	 ebp
  0009f	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  000a3	89 54 24 1c	 mov	 DWORD PTR _ar$[esp+16448], edx
  000a7	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000ac	8b 54 24 18	 mov	 edx, DWORD PTR _ar$[esp+16444]
  000b0	89 3a		 mov	 DWORD PTR [edx], edi
  000b2	8b 44 24 18	 mov	 eax, DWORD PTR _ar$[esp+16444]
  000b6	03 c5		 add	 eax, ebp

; 5156 : 	ar << nFlag;

  000b8	6a 01		 push	 1
  000ba	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  000be	89 44 24 1c	 mov	 DWORD PTR _ar$[esp+16448], eax
  000c2	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000c7	8a 84 24 3c 40
	00 00		 mov	 al, BYTE PTR _nFlag$[esp+16432]
  000ce	8b 4c 24 18	 mov	 ecx, DWORD PTR _ar$[esp+16444]
  000d2	88 01		 mov	 BYTE PTR [ecx], al
  000d4	8b 54 24 18	 mov	 edx, DWORD PTR _ar$[esp+16444]
  000d8	42		 inc	 edx

; 5157 : 	if( nFlag == STATEMODE_BASEMOTION_ON )

  000d9	84 c0		 test	 al, al
  000db	89 54 24 18	 mov	 DWORD PTR _ar$[esp+16444], edx
  000df	75 6e		 jne	 SHORT $L281782

; 5158 : 	{
; 5159 : 		ItemProp* pItemProp = NULL;
; 5160 : 		if( pUser->m_bItemFind )

  000e1	8b 86 88 06 00
	00		 mov	 eax, DWORD PTR [esi+1672]
  000e7	85 c0		 test	 eax, eax
  000e9	74 35		 je	 SHORT $L281776

; 5161 : 		{
; 5162 : 			CItemElem* pItemElem = ((CMover*)pUser)->m_Inventory.GetAtId( pUser->m_dwUseItemId );

  000eb	8b 86 90 06 00
	00		 mov	 eax, DWORD PTR [esi+1680]
  000f1	3b 86 9c 0b 00
	00		 cmp	 eax, DWORD PTR [esi+2972]
  000f7	0f 83 c0 00 00
	00		 jae	 $L281781
  000fd	8b 96 a0 0b 00
	00		 mov	 edx, DWORD PTR [esi+2976]
  00103	69 c0 b8 00 00
	00		 imul	 eax, 184		; 000000b8H
  00109	8b 4c 10 0c	 mov	 ecx, DWORD PTR [eax+edx+12]
  0010d	03 c2		 add	 eax, edx
  0010f	85 c9		 test	 ecx, ecx
  00111	0f 84 a6 00 00
	00		 je	 $L281781

; 5163 : 			if( pItemElem )
; 5164 : 			{
; 5165 : 				pItemProp = pItemElem->GetProp();

  00117	8b c8		 mov	 ecx, eax
  00119	e8 00 00 00 00	 call	 ?GetPropA@CItemElem@@QAEPAUItemProp@@XZ ; CItemElem::GetPropA

; 5166 : 			}
; 5167 : 		}
; 5168 : 		else

  0011e	eb 11		 jmp	 SHORT $L281780
$L281776:

; 5169 : 		{
; 5170 : 			pItemProp = prj.GetItemProp( pUser->m_dwUseItemId );

  00120	8b 96 90 06 00
	00		 mov	 edx, DWORD PTR [esi+1680]
  00126	52		 push	 edx
  00127	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?prj@@3VCProject@@A
  0012c	e8 00 00 00 00	 call	 ?GetItemProp@CProject@@QAEPAUItemProp@@H@Z ; CProject::GetItemProp
$L281780:

; 5171 : 		}
; 5172 : 
; 5173 : 		if( pItemProp )

  00131	85 c0		 test	 eax, eax
  00133	0f 84 84 00 00
	00		 je	 $L281781

; 5174 : 		{
; 5175 : 			ar << pItemProp->dwID;

  00139	8b 38		 mov	 edi, DWORD PTR [eax]
  0013b	55		 push	 ebp
  0013c	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  00140	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00145	8b 44 24 18	 mov	 eax, DWORD PTR _ar$[esp+16444]
  00149	89 38		 mov	 DWORD PTR [eax], edi
  0014b	01 6c 24 18	 add	 DWORD PTR _ar$[esp+16444], ebp
$L281782:

; 5181 : 		}
; 5182 : 	}
; 5183 : 	
; 5184 : 	GETBLOCK( ar, lpBuf, nBufSize );

  0014f	8d 4c 24 0c	 lea	 ecx, DWORD PTR _nBufSize$[esp+16436]
  00153	51		 push	 ecx
  00154	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  00158	e8 00 00 00 00	 call	 ?GetBuffer@CAr@@QAEPAEPAH@Z ; CAr::GetBuffer

; 5185 : 	
; 5186 : 	FOR_VISIBILITYRANGE( pUser )

  0015d	8b be 10 02 00
	00		 mov	 edi, DWORD PTR [esi+528]
  00163	8b 37		 mov	 esi, DWORD PTR [edi]
  00165	3b f7		 cmp	 esi, edi
  00167	8b e8		 mov	 ebp, eax
  00169	0f 84 7e 00 00
	00		 je	 $L281802
  0016f	90		 npad	 1
$L281801:

; 5187 : 		USERPTR->AddBlock( lpBuf, nBufSize );

  00170	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00173	f6 40 04 01	 test	 BYTE PTR [eax+4], 1
  00177	8b 4c 24 0c	 mov	 ecx, DWORD PTR _nBufSize$[esp+16436]
  0017b	75 14		 jne	 SHORT $L326396
  0017d	66 ff 80 0c 57
	00 00		 inc	 WORD PTR [eax+22284]
  00184	51		 push	 ecx
  00185	55		 push	 ebp
  00186	8d 88 f8 16 00
	00		 lea	 ecx, DWORD PTR [eax+5880]
  0018c	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
$L326396:

; 5188 : 	NEXT_VISIBILITYRANGE( pUser )

  00191	8a 46 15	 mov	 al, BYTE PTR [esi+21]
  00194	84 c0		 test	 al, al
  00196	75 51		 jne	 SHORT $L326524
  00198	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0019b	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  0019e	84 c9		 test	 cl, cl
  001a0	75 2a		 jne	 SHORT $L326558
  001a2	8b f0		 mov	 esi, eax
  001a4	8b 06		 mov	 eax, DWORD PTR [esi]
  001a6	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  001a9	84 c9		 test	 cl, cl
  001ab	75 3c		 jne	 SHORT $L326524
  001ad	8d 49 00	 npad	 3
$L326538:
  001b0	8b f0		 mov	 esi, eax
  001b2	8b 06		 mov	 eax, DWORD PTR [esi]
  001b4	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  001b7	84 c9		 test	 cl, cl
  001b9	74 f5		 je	 SHORT $L326538
  001bb	eb 2c		 jmp	 SHORT $L326524
$L281781:

; 5176 : 		}
; 5177 : 		else
; 5178 : 		{
; 5179 : 			Error( " .. " );

  001bd	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BD@LCNGLDCF@?$LD?$KK?$LP?$MA?$LI?i?5?$LO?H?$LF?J?4?4?5?$LN?C?$MA?$PM?$AA@
  001c2	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  001c7	83 c4 04	 add	 esp, 4

; 5180 : 			return;

  001ca	eb 21		 jmp	 SHORT $L281802
$L326558:

; 5188 : 	NEXT_VISIBILITYRANGE( pUser )

  001cc	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  001cf	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  001d2	84 c9		 test	 cl, cl
  001d4	75 11		 jne	 SHORT $L326527
$L326526:
  001d6	3b 70 08	 cmp	 esi, DWORD PTR [eax+8]
  001d9	75 0c		 jne	 SHORT $L326527
  001db	8b f0		 mov	 esi, eax
  001dd	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001e0	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  001e3	84 c9		 test	 cl, cl
  001e5	74 ef		 je	 SHORT $L326526
$L326527:
  001e7	8b f0		 mov	 esi, eax
$L326524:

; 5185 : 	
; 5186 : 	FOR_VISIBILITYRANGE( pUser )

  001e9	3b f7		 cmp	 esi, edi
  001eb	75 83		 jne	 SHORT $L281801
$L281802:

; 5189 : }

  001ed	8d 4c 24 10	 lea	 ecx, DWORD PTR _ar$[esp+16436]
  001f1	c7 84 24 30 40
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+16444], -1
  001fc	e8 00 00 00 00	 call	 ??1CAr@@QAE@XZ		; CAr::~CAr
  00201	8b 8c 24 28 40
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+16436]
  00208	5f		 pop	 edi
  00209	5e		 pop	 esi
  0020a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00211	8b 8c 24 1c 40
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+16428]
  00218	5d		 pop	 ebp
  00219	33 cc		 xor	 ecx, esp
  0021b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00220	81 c4 28 40 00
	00		 add	 esp, 16424		; 00004028H
  00226	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L326273:
  00000	8d 8d dc bf ff
	ff		 lea	 ecx, DWORD PTR _ar$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CAr@@QAE@XZ		; CAr::~CAr
__ehhandler$?AddStateMode@CUserMng@@QAEXPAVCUser@@E@Z:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T326555
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?AddStateMode@CUserMng@@QAEXPAVCUser@@E@Z ENDP		; CUserMng::AddStateMode
PUBLIC	?AddSetFame@CUserMng@@QAEXPAVCMover@@H@Z	; CUserMng::AddSetFame
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
xdata$x	SEGMENT
$T326840 DD	0ffffffffH
	DD	FLAT:$L326572
$T326832 DD	019930520H
	DD	01H
	DD	FLAT:$T326840
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
xdata$x	ENDS
;	COMDAT ?AddSetFame@CUserMng@@QAEXPAVCMover@@H@Z
_TEXT	SEGMENT
_nBufSize$ = -16424					; size = 4
_ar$ = -16420						; size = 16404
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_pMover$ = 8						; size = 4
_nFame$ = 12						; size = 4
?AddSetFame@CUserMng@@QAEXPAVCMover@@H@Z PROC NEAR	; CUserMng::AddSetFame, COMDAT
; _this$ = ecx

; 5208 : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?AddSetFame@CUserMng@@QAEXPAVCMover@@H@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	b8 1c 40 00 00	 mov	 eax, 16412		; 0000401cH
  00013	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0001a	e8 00 00 00 00	 call	 __chkstk
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00024	33 c4		 xor	 eax, esp
  00026	55		 push	 ebp
  00027	56		 push	 esi
  00028	8b b4 24 34 40
	00 00		 mov	 esi, DWORD PTR _pMover$[esp+16428]
  0002f	57		 push	 edi

; 5209 : 	CAr ar;

  00030	6a 00		 push	 0
  00032	6a 00		 push	 0
  00034	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  00038	89 84 24 2c 40
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+16444], eax
  0003f	e8 00 00 00 00	 call	 ??0CAr@@QAE@PAXI@Z	; CAr::CAr

; 5210 : 	
; 5211 : 	ar << GETID( pMover ) << SNAPSHOTTYPE_SETFAME;

  00044	85 f6		 test	 esi, esi
  00046	c7 84 24 30 40
	00 00 00 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+16444], 0
  00051	74 08		 je	 SHORT $L326570
  00053	8b be bc 01 00
	00		 mov	 edi, DWORD PTR [esi+444]
  00059	eb 03		 jmp	 SHORT $L326571
$L326570:
  0005b	83 cf ff	 or	 edi, -1
$L326571:
  0005e	6a 04		 push	 4
  00060	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  00064	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00069	8b 44 24 18	 mov	 eax, DWORD PTR _ar$[esp+16444]
  0006d	89 38		 mov	 DWORD PTR [eax], edi
  0006f	8b 54 24 18	 mov	 edx, DWORD PTR _ar$[esp+16444]
  00073	83 c2 04	 add	 edx, 4
  00076	6a 02		 push	 2
  00078	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  0007c	89 54 24 1c	 mov	 DWORD PTR _ar$[esp+16448], edx
  00080	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00085	8b 4c 24 18	 mov	 ecx, DWORD PTR _ar$[esp+16444]
  00089	66 c7 01 40 00	 mov	 WORD PTR [ecx], 64	; 00000040H
  0008e	8b 44 24 18	 mov	 eax, DWORD PTR _ar$[esp+16444]
  00092	83 c0 02	 add	 eax, 2

; 5212 : 	ar << nFame;

  00095	6a 04		 push	 4
  00097	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  0009b	89 44 24 1c	 mov	 DWORD PTR _ar$[esp+16448], eax
  0009f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000a4	8b 54 24 18	 mov	 edx, DWORD PTR _ar$[esp+16444]
  000a8	8b 84 24 3c 40
	00 00		 mov	 eax, DWORD PTR _nFame$[esp+16432]
  000af	89 02		 mov	 DWORD PTR [edx], eax
  000b1	8b 7c 24 18	 mov	 edi, DWORD PTR _ar$[esp+16444]

; 5213 : 	
; 5214 : 	GETBLOCK( ar, lpBuf, nBufSize );

  000b5	8d 4c 24 0c	 lea	 ecx, DWORD PTR _nBufSize$[esp+16436]
  000b9	51		 push	 ecx
  000ba	83 c7 04	 add	 edi, 4
  000bd	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  000c1	89 7c 24 1c	 mov	 DWORD PTR _ar$[esp+16448], edi
  000c5	e8 00 00 00 00	 call	 ?GetBuffer@CAr@@QAEPAEPAH@Z ; CAr::GetBuffer

; 5215 : 	
; 5216 : 	FOR_VISIBILITYRANGE( pMover )

  000ca	8b be 10 02 00
	00		 mov	 edi, DWORD PTR [esi+528]
  000d0	8b 37		 mov	 esi, DWORD PTR [edi]
  000d2	3b f7		 cmp	 esi, edi
  000d4	8b e8		 mov	 ebp, eax
  000d6	74 76		 je	 SHORT $L281828
  000d8	eb 06 8d 9b 00
	00 00 00	 npad	 8
$L281827:

; 5217 : 		USERPTR->AddBlock( lpBuf, nBufSize );

  000e0	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  000e3	f6 40 04 01	 test	 BYTE PTR [eax+4], 1
  000e7	8b 4c 24 0c	 mov	 ecx, DWORD PTR _nBufSize$[esp+16436]
  000eb	75 14		 jne	 SHORT $L326676
  000ed	66 ff 80 0c 57
	00 00		 inc	 WORD PTR [eax+22284]
  000f4	51		 push	 ecx
  000f5	55		 push	 ebp
  000f6	8d 88 f8 16 00
	00		 lea	 ecx, DWORD PTR [eax+5880]
  000fc	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
$L326676:

; 5218 : 	NEXT_VISIBILITYRANGE( pMover )

  00101	8a 46 15	 mov	 al, BYTE PTR [esi+21]
  00104	84 c0		 test	 al, al
  00106	75 42		 jne	 SHORT $L326824
  00108	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0010b	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  0010e	84 c9		 test	 cl, cl
  00110	75 1b		 jne	 SHORT $L326835
  00112	8b f0		 mov	 esi, eax
  00114	8b 06		 mov	 eax, DWORD PTR [esi]
  00116	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00119	84 c9		 test	 cl, cl
  0011b	75 2d		 jne	 SHORT $L326824
  0011d	8d 49 00	 npad	 3
$L326812:
  00120	8b f0		 mov	 esi, eax
  00122	8b 06		 mov	 eax, DWORD PTR [esi]
  00124	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00127	84 c9		 test	 cl, cl
  00129	74 f5		 je	 SHORT $L326812
  0012b	eb 1d		 jmp	 SHORT $L326824
$L326835:
  0012d	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00130	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00133	84 c9		 test	 cl, cl
  00135	75 11		 jne	 SHORT $L326827
$L326826:
  00137	3b 70 08	 cmp	 esi, DWORD PTR [eax+8]
  0013a	75 0c		 jne	 SHORT $L326827
  0013c	8b f0		 mov	 esi, eax
  0013e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00141	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00144	84 c9		 test	 cl, cl
  00146	74 ef		 je	 SHORT $L326826
$L326827:
  00148	8b f0		 mov	 esi, eax
$L326824:

; 5215 : 	
; 5216 : 	FOR_VISIBILITYRANGE( pMover )

  0014a	3b f7		 cmp	 esi, edi
  0014c	75 92		 jne	 SHORT $L281827
$L281828:

; 5219 : }

  0014e	8d 4c 24 10	 lea	 ecx, DWORD PTR _ar$[esp+16436]
  00152	c7 84 24 30 40
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+16444], -1
  0015d	e8 00 00 00 00	 call	 ??1CAr@@QAE@XZ		; CAr::~CAr
  00162	8b 8c 24 28 40
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+16436]
  00169	5f		 pop	 edi
  0016a	5e		 pop	 esi
  0016b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00172	8b 8c 24 1c 40
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+16428]
  00179	5d		 pop	 ebp
  0017a	33 cc		 xor	 ecx, esp
  0017c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00181	81 c4 28 40 00
	00		 add	 esp, 16424		; 00004028H
  00187	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L326572:
  00000	8d 8d dc bf ff
	ff		 lea	 ecx, DWORD PTR _ar$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CAr@@QAE@XZ		; CAr::~CAr
__ehhandler$?AddSetFame@CUserMng@@QAEXPAVCMover@@H@Z:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T326832
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?AddSetFame@CUserMng@@QAEXPAVCMover@@H@Z ENDP		; CUserMng::AddSetFame
PUBLIC	?AddSexChange@CUserMng@@QAEXPAVCMover@@@Z	; CUserMng::AddSexChange
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
xdata$x	SEGMENT
$T327116 DD	0ffffffffH
	DD	FLAT:$L326849
$T327108 DD	019930520H
	DD	01H
	DD	FLAT:$T327116
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
xdata$x	ENDS
;	COMDAT ?AddSexChange@CUserMng@@QAEXPAVCMover@@@Z
_TEXT	SEGMENT
_nBufSize$ = -16424					; size = 4
_ar$ = -16420						; size = 16404
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_pMover$ = 8						; size = 4
?AddSexChange@CUserMng@@QAEXPAVCMover@@@Z PROC NEAR	; CUserMng::AddSexChange, COMDAT
; _this$ = ecx

; 5264 : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?AddSexChange@CUserMng@@QAEXPAVCMover@@@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	b8 1c 40 00 00	 mov	 eax, 16412		; 0000401cH
  00013	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0001a	e8 00 00 00 00	 call	 __chkstk
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00024	33 c4		 xor	 eax, esp
  00026	55		 push	 ebp
  00027	56		 push	 esi
  00028	8b b4 24 34 40
	00 00		 mov	 esi, DWORD PTR _pMover$[esp+16428]
  0002f	57		 push	 edi

; 5265 : 	CAr ar;

  00030	6a 00		 push	 0
  00032	6a 00		 push	 0
  00034	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  00038	89 84 24 2c 40
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+16444], eax
  0003f	e8 00 00 00 00	 call	 ??0CAr@@QAE@PAXI@Z	; CAr::CAr

; 5266 : 	ar << GETID( pMover ) << SNAPSHOTTYPE_SEX_CHANGE;

  00044	85 f6		 test	 esi, esi
  00046	c7 84 24 30 40
	00 00 00 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+16444], 0
  00051	74 08		 je	 SHORT $L326847
  00053	8b be bc 01 00
	00		 mov	 edi, DWORD PTR [esi+444]
  00059	eb 03		 jmp	 SHORT $L326848
$L326847:
  0005b	83 cf ff	 or	 edi, -1
$L326848:
  0005e	6a 04		 push	 4
  00060	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  00064	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00069	8b 44 24 18	 mov	 eax, DWORD PTR _ar$[esp+16444]
  0006d	89 38		 mov	 DWORD PTR [eax], edi
  0006f	8b 54 24 18	 mov	 edx, DWORD PTR _ar$[esp+16444]
  00073	83 c2 04	 add	 edx, 4
  00076	6a 02		 push	 2
  00078	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  0007c	89 54 24 1c	 mov	 DWORD PTR _ar$[esp+16448], edx
  00080	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00085	8b 4c 24 18	 mov	 ecx, DWORD PTR _ar$[esp+16444]
  00089	66 c7 01 dc 00	 mov	 WORD PTR [ecx], 220	; 000000dcH
  0008e	8b 44 24 18	 mov	 eax, DWORD PTR _ar$[esp+16444]

; 5267 : 	ar << (u_short)pMover->GetIndex();

  00092	8b be 74 01 00
	00		 mov	 edi, DWORD PTR [esi+372]
  00098	83 c0 02	 add	 eax, 2
  0009b	6a 02		 push	 2
  0009d	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  000a1	89 44 24 1c	 mov	 DWORD PTR _ar$[esp+16448], eax
  000a5	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000aa	8b 54 24 18	 mov	 edx, DWORD PTR _ar$[esp+16444]
  000ae	66 89 3a	 mov	 WORD PTR [edx], di
  000b1	8b 54 24 18	 mov	 edx, DWORD PTR _ar$[esp+16444]

; 5268 : 	GETBLOCK( ar, lpBuf, nBufSize );

  000b5	8d 44 24 0c	 lea	 eax, DWORD PTR _nBufSize$[esp+16436]
  000b9	83 c2 02	 add	 edx, 2
  000bc	50		 push	 eax
  000bd	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  000c1	89 54 24 1c	 mov	 DWORD PTR _ar$[esp+16448], edx
  000c5	e8 00 00 00 00	 call	 ?GetBuffer@CAr@@QAEPAEPAH@Z ; CAr::GetBuffer

; 5269 : 
; 5270 : 	FOR_VISIBILITYRANGE( pMover )

  000ca	8b be 10 02 00
	00		 mov	 edi, DWORD PTR [esi+528]
  000d0	8b 37		 mov	 esi, DWORD PTR [edi]
  000d2	3b f7		 cmp	 esi, edi
  000d4	8b e8		 mov	 ebp, eax
  000d6	74 76		 je	 SHORT $L281891
  000d8	eb 06 8d 9b 00
	00 00 00	 npad	 8
$L281890:

; 5271 : 		USERPTR->AddBlock( lpBuf, nBufSize );

  000e0	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  000e3	f6 40 04 01	 test	 BYTE PTR [eax+4], 1
  000e7	8b 4c 24 0c	 mov	 ecx, DWORD PTR _nBufSize$[esp+16436]
  000eb	75 14		 jne	 SHORT $L326952
  000ed	66 ff 80 0c 57
	00 00		 inc	 WORD PTR [eax+22284]
  000f4	51		 push	 ecx
  000f5	55		 push	 ebp
  000f6	8d 88 f8 16 00
	00		 lea	 ecx, DWORD PTR [eax+5880]
  000fc	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
$L326952:

; 5272 : 	NEXT_VISIBILITYRANGE( pMover )

  00101	8a 46 15	 mov	 al, BYTE PTR [esi+21]
  00104	84 c0		 test	 al, al
  00106	75 42		 jne	 SHORT $L327100
  00108	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0010b	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  0010e	84 c9		 test	 cl, cl
  00110	75 1b		 jne	 SHORT $L327111
  00112	8b f0		 mov	 esi, eax
  00114	8b 06		 mov	 eax, DWORD PTR [esi]
  00116	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00119	84 c9		 test	 cl, cl
  0011b	75 2d		 jne	 SHORT $L327100
  0011d	8d 49 00	 npad	 3
$L327088:
  00120	8b f0		 mov	 esi, eax
  00122	8b 06		 mov	 eax, DWORD PTR [esi]
  00124	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00127	84 c9		 test	 cl, cl
  00129	74 f5		 je	 SHORT $L327088
  0012b	eb 1d		 jmp	 SHORT $L327100
$L327111:
  0012d	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00130	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00133	84 c9		 test	 cl, cl
  00135	75 11		 jne	 SHORT $L327103
$L327102:
  00137	3b 70 08	 cmp	 esi, DWORD PTR [eax+8]
  0013a	75 0c		 jne	 SHORT $L327103
  0013c	8b f0		 mov	 esi, eax
  0013e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00141	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00144	84 c9		 test	 cl, cl
  00146	74 ef		 je	 SHORT $L327102
$L327103:
  00148	8b f0		 mov	 esi, eax
$L327100:

; 5269 : 
; 5270 : 	FOR_VISIBILITYRANGE( pMover )

  0014a	3b f7		 cmp	 esi, edi
  0014c	75 92		 jne	 SHORT $L281890
$L281891:

; 5273 : }

  0014e	8d 4c 24 10	 lea	 ecx, DWORD PTR _ar$[esp+16436]
  00152	c7 84 24 30 40
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+16444], -1
  0015d	e8 00 00 00 00	 call	 ??1CAr@@QAE@XZ		; CAr::~CAr
  00162	8b 8c 24 28 40
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+16436]
  00169	5f		 pop	 edi
  0016a	5e		 pop	 esi
  0016b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00172	8b 8c 24 1c 40
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+16428]
  00179	5d		 pop	 ebp
  0017a	33 cc		 xor	 ecx, esp
  0017c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00181	81 c4 28 40 00
	00		 add	 esp, 16424		; 00004028H
  00187	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L326849:
  00000	8d 8d dc bf ff
	ff		 lea	 ecx, DWORD PTR _ar$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CAr@@QAE@XZ		; CAr::~CAr
__ehhandler$?AddSexChange@CUserMng@@QAEXPAVCMover@@@Z:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T327108
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?AddSexChange@CUserMng@@QAEXPAVCMover@@@Z ENDP		; CUserMng::AddSexChange
PUBLIC	?AddSetGuild@CUserMng@@QAEXPAVCUser@@K@Z	; CUserMng::AddSetGuild
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
xdata$x	SEGMENT
$T327388 DD	0ffffffffH
	DD	FLAT:$L327125
$T327380 DD	019930520H
	DD	01H
	DD	FLAT:$T327388
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
xdata$x	ENDS
;	COMDAT ?AddSetGuild@CUserMng@@QAEXPAVCUser@@K@Z
_TEXT	SEGMENT
_nBufSize$ = -16424					; size = 4
_ar$ = -16420						; size = 16404
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_pUser$ = 8						; size = 4
_idGuild$ = 12						; size = 4
?AddSetGuild@CUserMng@@QAEXPAVCUser@@K@Z PROC NEAR	; CUserMng::AddSetGuild, COMDAT
; _this$ = ecx

; 5299 : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?AddSetGuild@CUserMng@@QAEXPAVCUser@@K@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	b8 1c 40 00 00	 mov	 eax, 16412		; 0000401cH
  00013	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0001a	e8 00 00 00 00	 call	 __chkstk
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00024	33 c4		 xor	 eax, esp
  00026	55		 push	 ebp
  00027	56		 push	 esi
  00028	8b b4 24 34 40
	00 00		 mov	 esi, DWORD PTR _pUser$[esp+16428]
  0002f	57		 push	 edi

; 5300 : 	CAr ar;

  00030	6a 00		 push	 0
  00032	6a 00		 push	 0
  00034	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  00038	89 84 24 2c 40
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+16444], eax
  0003f	e8 00 00 00 00	 call	 ??0CAr@@QAE@PAXI@Z	; CAr::CAr

; 5301 : 	ar << GETID( pUser ) << SNAPSHOTTYPE_SET_GUILD;

  00044	85 f6		 test	 esi, esi
  00046	c7 84 24 30 40
	00 00 00 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+16444], 0
  00051	74 08		 je	 SHORT $L327123
  00053	8b be bc 01 00
	00		 mov	 edi, DWORD PTR [esi+444]
  00059	eb 03		 jmp	 SHORT $L327124
$L327123:
  0005b	83 cf ff	 or	 edi, -1
$L327124:
  0005e	6a 04		 push	 4
  00060	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  00064	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00069	8b 44 24 18	 mov	 eax, DWORD PTR _ar$[esp+16444]
  0006d	89 38		 mov	 DWORD PTR [eax], edi
  0006f	8b 54 24 18	 mov	 edx, DWORD PTR _ar$[esp+16444]
  00073	83 c2 04	 add	 edx, 4
  00076	6a 02		 push	 2
  00078	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  0007c	89 54 24 1c	 mov	 DWORD PTR _ar$[esp+16448], edx
  00080	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00085	8b 4c 24 18	 mov	 ecx, DWORD PTR _ar$[esp+16444]
  00089	66 c7 01 9b 00	 mov	 WORD PTR [ecx], 155	; 0000009bH
  0008e	8b 44 24 18	 mov	 eax, DWORD PTR _ar$[esp+16444]
  00092	83 c0 02	 add	 eax, 2

; 5302 : 	ar << idGuild;

  00095	6a 04		 push	 4
  00097	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  0009b	89 44 24 1c	 mov	 DWORD PTR _ar$[esp+16448], eax
  0009f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000a4	8b 54 24 18	 mov	 edx, DWORD PTR _ar$[esp+16444]
  000a8	8b 84 24 3c 40
	00 00		 mov	 eax, DWORD PTR _idGuild$[esp+16432]
  000af	89 02		 mov	 DWORD PTR [edx], eax
  000b1	8b 7c 24 18	 mov	 edi, DWORD PTR _ar$[esp+16444]

; 5303 : 	GETBLOCK( ar, lpBuf, nBufSize );

  000b5	8d 4c 24 0c	 lea	 ecx, DWORD PTR _nBufSize$[esp+16436]
  000b9	51		 push	 ecx
  000ba	83 c7 04	 add	 edi, 4
  000bd	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  000c1	89 7c 24 1c	 mov	 DWORD PTR _ar$[esp+16448], edi
  000c5	e8 00 00 00 00	 call	 ?GetBuffer@CAr@@QAEPAEPAH@Z ; CAr::GetBuffer

; 5304 : 
; 5305 : 	FOR_VISIBILITYRANGE( pUser )

  000ca	8b be 10 02 00
	00		 mov	 edi, DWORD PTR [esi+528]
  000d0	8b 37		 mov	 esi, DWORD PTR [edi]
  000d2	3b f7		 cmp	 esi, edi
  000d4	8b e8		 mov	 ebp, eax
  000d6	74 76		 je	 SHORT $L281937
  000d8	eb 06 8d 9b 00
	00 00 00	 npad	 8
$L281936:

; 5306 : 		USERPTR->AddBlock( lpBuf, nBufSize );

  000e0	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  000e3	f6 40 04 01	 test	 BYTE PTR [eax+4], 1
  000e7	8b 4c 24 0c	 mov	 ecx, DWORD PTR _nBufSize$[esp+16436]
  000eb	75 14		 jne	 SHORT $L327221
  000ed	66 ff 80 0c 57
	00 00		 inc	 WORD PTR [eax+22284]
  000f4	51		 push	 ecx
  000f5	55		 push	 ebp
  000f6	8d 88 f8 16 00
	00		 lea	 ecx, DWORD PTR [eax+5880]
  000fc	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
$L327221:

; 5307 : 	NEXT_VISIBILITYRANGE( pUser )

  00101	8a 46 15	 mov	 al, BYTE PTR [esi+21]
  00104	84 c0		 test	 al, al
  00106	75 42		 jne	 SHORT $L327348
  00108	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0010b	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  0010e	84 c9		 test	 cl, cl
  00110	75 1b		 jne	 SHORT $L327383
  00112	8b f0		 mov	 esi, eax
  00114	8b 06		 mov	 eax, DWORD PTR [esi]
  00116	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00119	84 c9		 test	 cl, cl
  0011b	75 2d		 jne	 SHORT $L327348
  0011d	8d 49 00	 npad	 3
$L327369:
  00120	8b f0		 mov	 esi, eax
  00122	8b 06		 mov	 eax, DWORD PTR [esi]
  00124	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00127	84 c9		 test	 cl, cl
  00129	74 f5		 je	 SHORT $L327369
  0012b	eb 1d		 jmp	 SHORT $L327348
$L327383:
  0012d	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00130	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00133	84 c9		 test	 cl, cl
  00135	75 11		 jne	 SHORT $L327351
$L327350:
  00137	3b 70 08	 cmp	 esi, DWORD PTR [eax+8]
  0013a	75 0c		 jne	 SHORT $L327351
  0013c	8b f0		 mov	 esi, eax
  0013e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00141	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00144	84 c9		 test	 cl, cl
  00146	74 ef		 je	 SHORT $L327350
$L327351:
  00148	8b f0		 mov	 esi, eax
$L327348:

; 5304 : 
; 5305 : 	FOR_VISIBILITYRANGE( pUser )

  0014a	3b f7		 cmp	 esi, edi
  0014c	75 92		 jne	 SHORT $L281936
$L281937:

; 5308 : }

  0014e	8d 4c 24 10	 lea	 ecx, DWORD PTR _ar$[esp+16436]
  00152	c7 84 24 30 40
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+16444], -1
  0015d	e8 00 00 00 00	 call	 ??1CAr@@QAE@XZ		; CAr::~CAr
  00162	8b 8c 24 28 40
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+16436]
  00169	5f		 pop	 edi
  0016a	5e		 pop	 esi
  0016b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00172	8b 8c 24 1c 40
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+16428]
  00179	5d		 pop	 ebp
  0017a	33 cc		 xor	 ecx, esp
  0017c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00181	81 c4 28 40 00
	00		 add	 esp, 16424		; 00004028H
  00187	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L327125:
  00000	8d 8d dc bf ff
	ff		 lea	 ecx, DWORD PTR _ar$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CAr@@QAE@XZ		; CAr::~CAr
__ehhandler$?AddSetGuild@CUserMng@@QAEXPAVCUser@@K@Z:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T327380
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?AddSetGuild@CUserMng@@QAEXPAVCUser@@K@Z ENDP		; CUserMng::AddSetGuild
PUBLIC	?AddSetWar@CUserMng@@QAEXPAVCUser@@K@Z		; CUserMng::AddSetWar
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
xdata$x	SEGMENT
$T327660 DD	0ffffffffH
	DD	FLAT:$L327397
$T327652 DD	019930520H
	DD	01H
	DD	FLAT:$T327660
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
xdata$x	ENDS
;	COMDAT ?AddSetWar@CUserMng@@QAEXPAVCUser@@K@Z
_TEXT	SEGMENT
_nBufSize$ = -16424					; size = 4
_ar$ = -16420						; size = 16404
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_pUser$ = 8						; size = 4
_idWar$ = 12						; size = 4
?AddSetWar@CUserMng@@QAEXPAVCUser@@K@Z PROC NEAR	; CUserMng::AddSetWar, COMDAT
; _this$ = ecx

; 5311 : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?AddSetWar@CUserMng@@QAEXPAVCUser@@K@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	b8 1c 40 00 00	 mov	 eax, 16412		; 0000401cH
  00013	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0001a	e8 00 00 00 00	 call	 __chkstk
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00024	33 c4		 xor	 eax, esp
  00026	55		 push	 ebp
  00027	56		 push	 esi
  00028	8b b4 24 34 40
	00 00		 mov	 esi, DWORD PTR _pUser$[esp+16428]
  0002f	57		 push	 edi

; 5312 : 	CAr ar;

  00030	6a 00		 push	 0
  00032	6a 00		 push	 0
  00034	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  00038	89 84 24 2c 40
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+16444], eax
  0003f	e8 00 00 00 00	 call	 ??0CAr@@QAE@PAXI@Z	; CAr::CAr

; 5313 : 	ar << GETID( pUser ) << SNAPSHOTTYPE_SET_WAR;

  00044	85 f6		 test	 esi, esi
  00046	c7 84 24 30 40
	00 00 00 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+16444], 0
  00051	74 08		 je	 SHORT $L327395
  00053	8b be bc 01 00
	00		 mov	 edi, DWORD PTR [esi+444]
  00059	eb 03		 jmp	 SHORT $L327396
$L327395:
  0005b	83 cf ff	 or	 edi, -1
$L327396:
  0005e	6a 04		 push	 4
  00060	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  00064	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00069	8b 44 24 18	 mov	 eax, DWORD PTR _ar$[esp+16444]
  0006d	89 38		 mov	 DWORD PTR [eax], edi
  0006f	8b 54 24 18	 mov	 edx, DWORD PTR _ar$[esp+16444]
  00073	83 c2 04	 add	 edx, 4
  00076	6a 02		 push	 2
  00078	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  0007c	89 54 24 1c	 mov	 DWORD PTR _ar$[esp+16448], edx
  00080	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00085	8b 4c 24 18	 mov	 ecx, DWORD PTR _ar$[esp+16444]
  00089	66 c7 01 7a 00	 mov	 WORD PTR [ecx], 122	; 0000007aH
  0008e	8b 44 24 18	 mov	 eax, DWORD PTR _ar$[esp+16444]
  00092	83 c0 02	 add	 eax, 2

; 5314 : 	ar << idWar;

  00095	6a 04		 push	 4
  00097	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  0009b	89 44 24 1c	 mov	 DWORD PTR _ar$[esp+16448], eax
  0009f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000a4	8b 54 24 18	 mov	 edx, DWORD PTR _ar$[esp+16444]
  000a8	8b 84 24 3c 40
	00 00		 mov	 eax, DWORD PTR _idWar$[esp+16432]
  000af	89 02		 mov	 DWORD PTR [edx], eax
  000b1	8b 7c 24 18	 mov	 edi, DWORD PTR _ar$[esp+16444]

; 5315 : 	GETBLOCK( ar, lpBuf, nBufSize );

  000b5	8d 4c 24 0c	 lea	 ecx, DWORD PTR _nBufSize$[esp+16436]
  000b9	51		 push	 ecx
  000ba	83 c7 04	 add	 edi, 4
  000bd	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  000c1	89 7c 24 1c	 mov	 DWORD PTR _ar$[esp+16448], edi
  000c5	e8 00 00 00 00	 call	 ?GetBuffer@CAr@@QAEPAEPAH@Z ; CAr::GetBuffer

; 5316 : 
; 5317 : 	FOR_VISIBILITYRANGE( pUser )

  000ca	8b be 10 02 00
	00		 mov	 edi, DWORD PTR [esi+528]
  000d0	8b 37		 mov	 esi, DWORD PTR [edi]
  000d2	3b f7		 cmp	 esi, edi
  000d4	8b e8		 mov	 ebp, eax
  000d6	74 76		 je	 SHORT $L281963
  000d8	eb 06 8d 9b 00
	00 00 00	 npad	 8
$L281962:

; 5318 : 		USERPTR->AddBlock( lpBuf, nBufSize );

  000e0	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  000e3	f6 40 04 01	 test	 BYTE PTR [eax+4], 1
  000e7	8b 4c 24 0c	 mov	 ecx, DWORD PTR _nBufSize$[esp+16436]
  000eb	75 14		 jne	 SHORT $L327493
  000ed	66 ff 80 0c 57
	00 00		 inc	 WORD PTR [eax+22284]
  000f4	51		 push	 ecx
  000f5	55		 push	 ebp
  000f6	8d 88 f8 16 00
	00		 lea	 ecx, DWORD PTR [eax+5880]
  000fc	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
$L327493:

; 5319 : 	NEXT_VISIBILITYRANGE( pUser )

  00101	8a 46 15	 mov	 al, BYTE PTR [esi+21]
  00104	84 c0		 test	 al, al
  00106	75 42		 jne	 SHORT $L327621
  00108	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0010b	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  0010e	84 c9		 test	 cl, cl
  00110	75 1b		 jne	 SHORT $L327655
  00112	8b f0		 mov	 esi, eax
  00114	8b 06		 mov	 eax, DWORD PTR [esi]
  00116	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00119	84 c9		 test	 cl, cl
  0011b	75 2d		 jne	 SHORT $L327621
  0011d	8d 49 00	 npad	 3
$L327635:
  00120	8b f0		 mov	 esi, eax
  00122	8b 06		 mov	 eax, DWORD PTR [esi]
  00124	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00127	84 c9		 test	 cl, cl
  00129	74 f5		 je	 SHORT $L327635
  0012b	eb 1d		 jmp	 SHORT $L327621
$L327655:
  0012d	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00130	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00133	84 c9		 test	 cl, cl
  00135	75 11		 jne	 SHORT $L327624
$L327623:
  00137	3b 70 08	 cmp	 esi, DWORD PTR [eax+8]
  0013a	75 0c		 jne	 SHORT $L327624
  0013c	8b f0		 mov	 esi, eax
  0013e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00141	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00144	84 c9		 test	 cl, cl
  00146	74 ef		 je	 SHORT $L327623
$L327624:
  00148	8b f0		 mov	 esi, eax
$L327621:

; 5316 : 
; 5317 : 	FOR_VISIBILITYRANGE( pUser )

  0014a	3b f7		 cmp	 esi, edi
  0014c	75 92		 jne	 SHORT $L281962
$L281963:

; 5320 : }

  0014e	8d 4c 24 10	 lea	 ecx, DWORD PTR _ar$[esp+16436]
  00152	c7 84 24 30 40
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+16444], -1
  0015d	e8 00 00 00 00	 call	 ??1CAr@@QAE@XZ		; CAr::~CAr
  00162	8b 8c 24 28 40
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+16436]
  00169	5f		 pop	 edi
  0016a	5e		 pop	 esi
  0016b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00172	8b 8c 24 1c 40
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+16428]
  00179	5d		 pop	 ebp
  0017a	33 cc		 xor	 ecx, esp
  0017c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00181	81 c4 28 40 00
	00		 add	 esp, 16424		; 00004028H
  00187	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L327397:
  00000	8d 8d dc bf ff
	ff		 lea	 ecx, DWORD PTR _ar$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CAr@@QAE@XZ		; CAr::~CAr
__ehhandler$?AddSetWar@CUserMng@@QAEXPAVCUser@@K@Z:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T327652
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?AddSetWar@CUserMng@@QAEXPAVCUser@@K@Z ENDP		; CUserMng::AddSetWar
PUBLIC	?AddGetItemElem@CUserMng@@QAEXPAVCUser@@PAVCItemElem@@@Z ; CUserMng::AddGetItemElem
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
xdata$x	SEGMENT
$T328005 DD	0ffffffffH
	DD	FLAT:$L327669
$T327997 DD	019930520H
	DD	01H
	DD	FLAT:$T328005
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
xdata$x	ENDS
;	COMDAT ?AddGetItemElem@CUserMng@@QAEXPAVCUser@@PAVCItemElem@@@Z
_TEXT	SEGMENT
_nBufSize$ = -16424					; size = 4
_ar$ = -16420						; size = 16404
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_pUser$ = 8						; size = 4
_pItemElem$ = 12					; size = 4
?AddGetItemElem@CUserMng@@QAEXPAVCUser@@PAVCItemElem@@@Z PROC NEAR ; CUserMng::AddGetItemElem, COMDAT
; _this$ = ecx

; 5334 : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?AddGetItemElem@CUserMng@@QAEXPAVCUser@@PAVCItemElem@@@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	b8 1c 40 00 00	 mov	 eax, 16412		; 0000401cH
  00013	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0001a	e8 00 00 00 00	 call	 __chkstk
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00024	33 c4		 xor	 eax, esp
  00026	53		 push	 ebx
  00027	55		 push	 ebp
  00028	8b ac 24 34 40
	00 00		 mov	 ebp, DWORD PTR _pUser$[esp+16428]
  0002f	56		 push	 esi
  00030	8b b4 24 3c 40
	00 00		 mov	 esi, DWORD PTR _pItemElem$[esp+16432]
  00037	57		 push	 edi

; 5335 : 	CAr ar;

  00038	6a 00		 push	 0
  0003a	6a 00		 push	 0
  0003c	8d 4c 24 1c	 lea	 ecx, DWORD PTR _ar$[esp+16448]
  00040	89 84 24 30 40
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+16448], eax
  00047	e8 00 00 00 00	 call	 ??0CAr@@QAE@PAXI@Z	; CAr::CAr

; 5336 : 
; 5337 : 	ar << GETID( pUser ) << SNAPSHOTTYPE_GETITEMGUILDBANK;

  0004c	85 ed		 test	 ebp, ebp
  0004e	c7 84 24 34 40
	00 00 00 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+16448], 0
  00059	74 08		 je	 SHORT $L327667
  0005b	8b bd bc 01 00
	00		 mov	 edi, DWORD PTR [ebp+444]
  00061	eb 03		 jmp	 SHORT $L327668
$L327667:
  00063	83 cf ff	 or	 edi, -1
$L327668:
  00066	6a 04		 push	 4
  00068	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  0006c	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00071	8b 44 24 1c	 mov	 eax, DWORD PTR _ar$[esp+16448]
  00075	89 38		 mov	 DWORD PTR [eax], edi
  00077	8b 54 24 1c	 mov	 edx, DWORD PTR _ar$[esp+16448]
  0007b	83 c2 04	 add	 edx, 4
  0007e	6a 02		 push	 2
  00080	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  00084	89 54 24 20	 mov	 DWORD PTR _ar$[esp+16452], edx
  00088	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0008d	8b 4c 24 1c	 mov	 ecx, DWORD PTR _ar$[esp+16448]
  00091	66 c7 01 d4 00	 mov	 WORD PTR [ecx], 212	; 000000d4H
  00096	8b 44 24 1c	 mov	 eax, DWORD PTR _ar$[esp+16448]
  0009a	83 c0 02	 add	 eax, 2

; 5338 : 	ar << (BYTE)3;

  0009d	6a 01		 push	 1
  0009f	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  000a3	89 44 24 20	 mov	 DWORD PTR _ar$[esp+16452], eax
  000a7	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000ac	8b 54 24 1c	 mov	 edx, DWORD PTR _ar$[esp+16448]
  000b0	c6 02 03	 mov	 BYTE PTR [edx], 3
  000b3	8b 7c 24 1c	 mov	 edi, DWORD PTR _ar$[esp+16448]

; 5339 : 	pItemElem->Serialize( ar );

  000b7	8b 06		 mov	 eax, DWORD PTR [esi]
  000b9	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  000bd	51		 push	 ecx
  000be	47		 inc	 edi
  000bf	8b ce		 mov	 ecx, esi
  000c1	89 7c 24 20	 mov	 DWORD PTR _ar$[esp+16452], edi
  000c5	ff 50 08	 call	 DWORD PTR [eax+8]

; 5340 : 	GETBLOCK( ar, lpBuf, nBufSize );

  000c8	8d 54 24 10	 lea	 edx, DWORD PTR _nBufSize$[esp+16440]
  000cc	52		 push	 edx
  000cd	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  000d1	e8 00 00 00 00	 call	 ?GetBuffer@CAr@@QAEPAEPAH@Z ; CAr::GetBuffer

; 5341 : 
; 5342 : 	FOR_VISIBILITYRANGE( pUser )

  000d6	8b bd 10 02 00
	00		 mov	 edi, DWORD PTR [ebp+528]
  000dc	8b 37		 mov	 esi, DWORD PTR [edi]
  000de	3b f7		 cmp	 esi, edi
  000e0	8b d8		 mov	 ebx, eax
  000e2	0f 84 8a 00 00
	00		 je	 $L281999
$L281998:

; 5343 : 	if ( USERPTR != pUser && USERPTR->m_bGuildBank == TRUE && USERPTR->m_idGuild == pUser->m_idGuild)

  000e8	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  000eb	3b c5		 cmp	 eax, ebp
  000ed	74 35		 je	 SHORT $L327840
  000ef	83 b8 20 07 00
	00 01		 cmp	 DWORD PTR [eax+1824], 1
  000f6	75 2c		 jne	 SHORT $L327840
  000f8	8b 88 1c 07 00
	00		 mov	 ecx, DWORD PTR [eax+1820]
  000fe	3b 8d 1c 07 00
	00		 cmp	 ecx, DWORD PTR [ebp+1820]
  00104	75 1e		 jne	 SHORT $L327840

; 5344 : 		USERPTR->AddBlock( lpBuf, nBufSize );

  00106	f6 40 04 01	 test	 BYTE PTR [eax+4], 1
  0010a	8b 4c 24 10	 mov	 ecx, DWORD PTR _nBufSize$[esp+16440]
  0010e	75 14		 jne	 SHORT $L327840
  00110	66 ff 80 0c 57
	00 00		 inc	 WORD PTR [eax+22284]
  00117	51		 push	 ecx
  00118	53		 push	 ebx
  00119	8d 88 f8 16 00
	00		 lea	 ecx, DWORD PTR [eax+5880]
  0011f	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
$L327840:

; 5345 : 	NEXT_VISIBILITYRANGE( pUser )

  00124	8a 46 15	 mov	 al, BYTE PTR [esi+21]
  00127	84 c0		 test	 al, al
  00129	75 3f		 jne	 SHORT $L327988
  0012b	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0012e	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00131	84 c9		 test	 cl, cl
  00133	75 18		 jne	 SHORT $L328000
  00135	8b f0		 mov	 esi, eax
  00137	8b 06		 mov	 eax, DWORD PTR [esi]
  00139	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  0013c	84 c9		 test	 cl, cl
  0013e	75 2a		 jne	 SHORT $L327988
$L327976:
  00140	8b f0		 mov	 esi, eax
  00142	8b 06		 mov	 eax, DWORD PTR [esi]
  00144	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00147	84 c9		 test	 cl, cl
  00149	74 f5		 je	 SHORT $L327976
  0014b	eb 1d		 jmp	 SHORT $L327988
$L328000:
  0014d	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00150	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00153	84 c9		 test	 cl, cl
  00155	75 11		 jne	 SHORT $L327991
$L327990:
  00157	3b 70 08	 cmp	 esi, DWORD PTR [eax+8]
  0015a	75 0c		 jne	 SHORT $L327991
  0015c	8b f0		 mov	 esi, eax
  0015e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00161	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00164	84 c9		 test	 cl, cl
  00166	74 ef		 je	 SHORT $L327990
$L327991:
  00168	8b f0		 mov	 esi, eax
$L327988:

; 5341 : 
; 5342 : 	FOR_VISIBILITYRANGE( pUser )

  0016a	3b f7		 cmp	 esi, edi
  0016c	0f 85 76 ff ff
	ff		 jne	 $L281998
$L281999:

; 5346 : }

  00172	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  00176	c7 84 24 34 40
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+16448], -1
  00181	e8 00 00 00 00	 call	 ??1CAr@@QAE@XZ		; CAr::~CAr
  00186	8b 8c 24 2c 40
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+16440]
  0018d	5f		 pop	 edi
  0018e	5e		 pop	 esi
  0018f	5d		 pop	 ebp
  00190	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00197	8b 8c 24 1c 40
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+16428]
  0019e	5b		 pop	 ebx
  0019f	33 cc		 xor	 ecx, esp
  001a1	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001a6	81 c4 28 40 00
	00		 add	 esp, 16424		; 00004028H
  001ac	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L327669:
  00000	8d 8d dc bf ff
	ff		 lea	 ecx, DWORD PTR _ar$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CAr@@QAE@XZ		; CAr::~CAr
__ehhandler$?AddGetItemElem@CUserMng@@QAEXPAVCUser@@PAVCItemElem@@@Z:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T327997
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?AddGetItemElem@CUserMng@@QAEXPAVCUser@@PAVCItemElem@@@Z ENDP ; CUserMng::AddGetItemElem
PUBLIC	?AddPutItemElem@CUserMng@@QAEXPAVCUser@@PAVCItemElem@@@Z ; CUserMng::AddPutItemElem
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
xdata$x	SEGMENT
$T328350 DD	0ffffffffH
	DD	FLAT:$L328014
$T328342 DD	019930520H
	DD	01H
	DD	FLAT:$T328350
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
xdata$x	ENDS
;	COMDAT ?AddPutItemElem@CUserMng@@QAEXPAVCUser@@PAVCItemElem@@@Z
_TEXT	SEGMENT
_nBufSize$ = -16424					; size = 4
_ar$ = -16420						; size = 16404
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_pUser$ = 8						; size = 4
_pItemElem$ = 12					; size = 4
?AddPutItemElem@CUserMng@@QAEXPAVCUser@@PAVCItemElem@@@Z PROC NEAR ; CUserMng::AddPutItemElem, COMDAT
; _this$ = ecx

; 5349 : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?AddPutItemElem@CUserMng@@QAEXPAVCUser@@PAVCItemElem@@@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	b8 1c 40 00 00	 mov	 eax, 16412		; 0000401cH
  00013	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0001a	e8 00 00 00 00	 call	 __chkstk
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00024	33 c4		 xor	 eax, esp
  00026	53		 push	 ebx
  00027	55		 push	 ebp
  00028	8b ac 24 34 40
	00 00		 mov	 ebp, DWORD PTR _pUser$[esp+16428]
  0002f	56		 push	 esi
  00030	8b b4 24 3c 40
	00 00		 mov	 esi, DWORD PTR _pItemElem$[esp+16432]
  00037	57		 push	 edi

; 5350 : 	CAr ar;

  00038	6a 00		 push	 0
  0003a	6a 00		 push	 0
  0003c	8d 4c 24 1c	 lea	 ecx, DWORD PTR _ar$[esp+16448]
  00040	89 84 24 30 40
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+16448], eax
  00047	e8 00 00 00 00	 call	 ??0CAr@@QAE@PAXI@Z	; CAr::CAr

; 5351 : 	
; 5352 : 	ar << GETID( pUser ) << SNAPSHOTTYPE_PUTITEMGUILDBANK;

  0004c	85 ed		 test	 ebp, ebp
  0004e	c7 84 24 34 40
	00 00 00 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+16448], 0
  00059	74 08		 je	 SHORT $L328012
  0005b	8b bd bc 01 00
	00		 mov	 edi, DWORD PTR [ebp+444]
  00061	eb 03		 jmp	 SHORT $L328013
$L328012:
  00063	83 cf ff	 or	 edi, -1
$L328013:
  00066	6a 04		 push	 4
  00068	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  0006c	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00071	8b 44 24 1c	 mov	 eax, DWORD PTR _ar$[esp+16448]
  00075	89 38		 mov	 DWORD PTR [eax], edi
  00077	8b 54 24 1c	 mov	 edx, DWORD PTR _ar$[esp+16448]
  0007b	83 c2 04	 add	 edx, 4
  0007e	6a 02		 push	 2
  00080	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  00084	89 54 24 20	 mov	 DWORD PTR _ar$[esp+16452], edx
  00088	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0008d	8b 4c 24 1c	 mov	 ecx, DWORD PTR _ar$[esp+16448]
  00091	66 c7 01 ef 00	 mov	 WORD PTR [ecx], 239	; 000000efH
  00096	8b 44 24 1c	 mov	 eax, DWORD PTR _ar$[esp+16448]
  0009a	83 c0 02	 add	 eax, 2

; 5353 : 	ar << (BYTE)3;

  0009d	6a 01		 push	 1
  0009f	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  000a3	89 44 24 20	 mov	 DWORD PTR _ar$[esp+16452], eax
  000a7	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000ac	8b 54 24 1c	 mov	 edx, DWORD PTR _ar$[esp+16448]
  000b0	c6 02 03	 mov	 BYTE PTR [edx], 3
  000b3	8b 7c 24 1c	 mov	 edi, DWORD PTR _ar$[esp+16448]

; 5354 : 	pItemElem->Serialize( ar );

  000b7	8b 06		 mov	 eax, DWORD PTR [esi]
  000b9	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  000bd	51		 push	 ecx
  000be	47		 inc	 edi
  000bf	8b ce		 mov	 ecx, esi
  000c1	89 7c 24 20	 mov	 DWORD PTR _ar$[esp+16452], edi
  000c5	ff 50 08	 call	 DWORD PTR [eax+8]

; 5355 : 	GETBLOCK( ar, lpBuf, nBufSize );

  000c8	8d 54 24 10	 lea	 edx, DWORD PTR _nBufSize$[esp+16440]
  000cc	52		 push	 edx
  000cd	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  000d1	e8 00 00 00 00	 call	 ?GetBuffer@CAr@@QAEPAEPAH@Z ; CAr::GetBuffer

; 5356 : 	
; 5357 : 	FOR_VISIBILITYRANGE( pUser )

  000d6	8b bd 10 02 00
	00		 mov	 edi, DWORD PTR [ebp+528]
  000dc	8b 37		 mov	 esi, DWORD PTR [edi]
  000de	3b f7		 cmp	 esi, edi
  000e0	8b d8		 mov	 ebx, eax
  000e2	0f 84 8a 00 00
	00		 je	 $L282027
$L282026:

; 5358 : 		if (  USERPTR != pUser && USERPTR->m_bGuildBank == TRUE && USERPTR->m_idGuild == pUser->m_idGuild)

  000e8	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  000eb	3b c5		 cmp	 eax, ebp
  000ed	74 35		 je	 SHORT $L328185
  000ef	83 b8 20 07 00
	00 01		 cmp	 DWORD PTR [eax+1824], 1
  000f6	75 2c		 jne	 SHORT $L328185
  000f8	8b 88 1c 07 00
	00		 mov	 ecx, DWORD PTR [eax+1820]
  000fe	3b 8d 1c 07 00
	00		 cmp	 ecx, DWORD PTR [ebp+1820]
  00104	75 1e		 jne	 SHORT $L328185

; 5359 : 			USERPTR->AddBlock( lpBuf, nBufSize );

  00106	f6 40 04 01	 test	 BYTE PTR [eax+4], 1
  0010a	8b 4c 24 10	 mov	 ecx, DWORD PTR _nBufSize$[esp+16440]
  0010e	75 14		 jne	 SHORT $L328185
  00110	66 ff 80 0c 57
	00 00		 inc	 WORD PTR [eax+22284]
  00117	51		 push	 ecx
  00118	53		 push	 ebx
  00119	8d 88 f8 16 00
	00		 lea	 ecx, DWORD PTR [eax+5880]
  0011f	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
$L328185:

; 5360 : 	NEXT_VISIBILITYRANGE( pUser )

  00124	8a 46 15	 mov	 al, BYTE PTR [esi+21]
  00127	84 c0		 test	 al, al
  00129	75 3f		 jne	 SHORT $L328309
  0012b	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0012e	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00131	84 c9		 test	 cl, cl
  00133	75 18		 jne	 SHORT $L328345
  00135	8b f0		 mov	 esi, eax
  00137	8b 06		 mov	 eax, DWORD PTR [esi]
  00139	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  0013c	84 c9		 test	 cl, cl
  0013e	75 2a		 jne	 SHORT $L328309
$L328330:
  00140	8b f0		 mov	 esi, eax
  00142	8b 06		 mov	 eax, DWORD PTR [esi]
  00144	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00147	84 c9		 test	 cl, cl
  00149	74 f5		 je	 SHORT $L328330
  0014b	eb 1d		 jmp	 SHORT $L328309
$L328345:
  0014d	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00150	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00153	84 c9		 test	 cl, cl
  00155	75 11		 jne	 SHORT $L328312
$L328311:
  00157	3b 70 08	 cmp	 esi, DWORD PTR [eax+8]
  0015a	75 0c		 jne	 SHORT $L328312
  0015c	8b f0		 mov	 esi, eax
  0015e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00161	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00164	84 c9		 test	 cl, cl
  00166	74 ef		 je	 SHORT $L328311
$L328312:
  00168	8b f0		 mov	 esi, eax
$L328309:

; 5356 : 	
; 5357 : 	FOR_VISIBILITYRANGE( pUser )

  0016a	3b f7		 cmp	 esi, edi
  0016c	0f 85 76 ff ff
	ff		 jne	 $L282026
$L282027:

; 5361 : }

  00172	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  00176	c7 84 24 34 40
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+16448], -1
  00181	e8 00 00 00 00	 call	 ??1CAr@@QAE@XZ		; CAr::~CAr
  00186	8b 8c 24 2c 40
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+16440]
  0018d	5f		 pop	 edi
  0018e	5e		 pop	 esi
  0018f	5d		 pop	 ebp
  00190	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00197	8b 8c 24 1c 40
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+16428]
  0019e	5b		 pop	 ebx
  0019f	33 cc		 xor	 ecx, esp
  001a1	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001a6	81 c4 28 40 00
	00		 add	 esp, 16424		; 00004028H
  001ac	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L328014:
  00000	8d 8d dc bf ff
	ff		 lea	 ecx, DWORD PTR _ar$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CAr@@QAE@XZ		; CAr::~CAr
__ehhandler$?AddPutItemElem@CUserMng@@QAEXPAVCUser@@PAVCItemElem@@@Z:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T328342
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?AddPutItemElem@CUserMng@@QAEXPAVCUser@@PAVCItemElem@@@Z ENDP ; CUserMng::AddPutItemElem
PUBLIC	?AddPutItemElem@CUserMng@@QAEXKPAVCItemElem@@@Z	; CUserMng::AddPutItemElem
;	COMDAT xdata$x
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\obj.h
xdata$x	SEGMENT
$T328496 DD	0ffffffffH
	DD	FLAT:$L328359
$T328492 DD	019930520H
	DD	01H
	DD	FLAT:$T328496
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
xdata$x	ENDS
;	COMDAT ?AddPutItemElem@CUserMng@@QAEXKPAVCItemElem@@@Z
_TEXT	SEGMENT
_it$ = -16428						; size = 4
_nBufSize$ = -16424					; size = 4
_ar$ = -16420						; size = 16404
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_uidGuild$ = 8						; size = 4
_pItemElem$ = 12					; size = 4
?AddPutItemElem@CUserMng@@QAEXKPAVCItemElem@@@Z PROC NEAR ; CUserMng::AddPutItemElem, COMDAT
; _this$ = ecx

; 5365 : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?AddPutItemElem@CUserMng@@QAEXKPAVCItemElem@@@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	b8 20 40 00 00	 mov	 eax, 16416		; 00004020H
  00013	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0001a	e8 00 00 00 00	 call	 __chkstk
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00024	33 c4		 xor	 eax, esp
  00026	56		 push	 esi
  00027	8b b4 24 38 40
	00 00		 mov	 esi, DWORD PTR _pItemElem$[esp+16428]
  0002e	57		 push	 edi

; 5366 : 	CAr ar;

  0002f	6a 00		 push	 0
  00031	8b f9		 mov	 edi, ecx
  00033	6a 00		 push	 0
  00035	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  00039	89 84 24 2c 40
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+16444], eax
  00040	e8 00 00 00 00	 call	 ??0CAr@@QAE@PAXI@Z	; CAr::CAr

; 5367 : 	
; 5368 : 	ar << NULL_ID << SNAPSHOTTYPE_PUTITEMGUILDBANK;

  00045	6a 04		 push	 4
  00047	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  0004b	c7 84 24 34 40
	00 00 00 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+16448], 0
  00056	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0005b	8b 44 24 18	 mov	 eax, DWORD PTR _ar$[esp+16444]
  0005f	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [eax], -1
  00065	8b 44 24 18	 mov	 eax, DWORD PTR _ar$[esp+16444]
  00069	83 c0 04	 add	 eax, 4
  0006c	6a 02		 push	 2
  0006e	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  00072	89 44 24 1c	 mov	 DWORD PTR _ar$[esp+16448], eax
  00076	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0007b	8b 4c 24 18	 mov	 ecx, DWORD PTR _ar$[esp+16444]
  0007f	66 c7 01 ef 00	 mov	 WORD PTR [ecx], 239	; 000000efH
  00084	8b 54 24 18	 mov	 edx, DWORD PTR _ar$[esp+16444]
  00088	83 c2 02	 add	 edx, 2

; 5369 : 	ar << (BYTE)3;

  0008b	6a 01		 push	 1
  0008d	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  00091	89 54 24 1c	 mov	 DWORD PTR _ar$[esp+16448], edx
  00095	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0009a	8b 54 24 18	 mov	 edx, DWORD PTR _ar$[esp+16444]
  0009e	c6 02 03	 mov	 BYTE PTR [edx], 3
  000a1	8b 44 24 18	 mov	 eax, DWORD PTR _ar$[esp+16444]
  000a5	40		 inc	 eax

; 5370 : 	pItemElem->Serialize( ar );

  000a6	8d 4c 24 10	 lea	 ecx, DWORD PTR _ar$[esp+16436]
  000aa	89 44 24 18	 mov	 DWORD PTR _ar$[esp+16444], eax
  000ae	8b 06		 mov	 eax, DWORD PTR [esi]
  000b0	51		 push	 ecx
  000b1	8b ce		 mov	 ecx, esi
  000b3	ff 50 08	 call	 DWORD PTR [eax+8]

; 5371 : 	GETBLOCK( ar, lpBuf, nBufSize );

  000b6	8d 54 24 0c	 lea	 edx, DWORD PTR _nBufSize$[esp+16436]
  000ba	52		 push	 edx
  000bb	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  000bf	e8 00 00 00 00	 call	 ?GetBuffer@CAr@@QAEPAEPAH@Z ; CAr::GetBuffer
  000c4	8b f0		 mov	 esi, eax

; 5372 : 	
; 5373 : 	map<DWORD, CUser*>::iterator it;
; 5374 : 	for( it = m_users.begin(); it != m_users.end(); ++it )

  000c6	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  000c9	8b 08		 mov	 ecx, DWORD PTR [eax]
  000cb	3b c8		 cmp	 ecx, eax
  000cd	89 4c 24 08	 mov	 DWORD PTR _it$[esp+16436], ecx
  000d1	74 55		 je	 SHORT $L282049
  000d3	55		 push	 ebp
  000d4	8b ac 24 3c 40
	00 00		 mov	 ebp, DWORD PTR _uidGuild$[esp+16436]
  000db	eb 03 8d 49 00	 npad	 5
$L328416:

; 5375 : 	{
; 5376 : 		CUser* pUsertmp = it->second;

  000e0	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]

; 5377 : 		if( pUsertmp->IsValid() == FALSE )

  000e3	f6 40 04 01	 test	 BYTE PTR [eax+4], 1
  000e7	75 2a		 jne	 SHORT $L282048
  000e9	8b 88 e8 16 00
	00		 mov	 ecx, DWORD PTR [eax+5864]
  000ef	85 c9		 test	 ecx, ecx
  000f1	74 20		 je	 SHORT $L282048

; 5378 : 			continue;
; 5379 : 		
; 5380 : 		if( pUsertmp->m_idGuild == uidGuild )

  000f3	39 a8 1c 07 00
	00		 cmp	 DWORD PTR [eax+1820], ebp
  000f9	75 18		 jne	 SHORT $L282048

; 5381 : 			pUsertmp->AddBlock( lpBuf, nBufSize );

  000fb	8b 4c 24 10	 mov	 ecx, DWORD PTR _nBufSize$[esp+16440]
  000ff	66 ff 80 0c 57
	00 00		 inc	 WORD PTR [eax+22284]
  00106	51		 push	 ecx
  00107	56		 push	 esi
  00108	8d 88 f8 16 00
	00		 lea	 ecx, DWORD PTR [eax+5880]
  0010e	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
$L282048:
  00113	8d 4c 24 0c	 lea	 ecx, DWORD PTR _it$[esp+16440]
  00117	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::const_iterator::_Inc
  0011c	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  0011f	8b 4c 24 0c	 mov	 ecx, DWORD PTR _it$[esp+16440]
  00123	3b c8		 cmp	 ecx, eax
  00125	75 b9		 jne	 SHORT $L328416
  00127	5d		 pop	 ebp
$L282049:

; 5382 : 	}
; 5383 : }

  00128	8d 4c 24 10	 lea	 ecx, DWORD PTR _ar$[esp+16436]
  0012c	c7 84 24 30 40
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+16444], -1
  00137	e8 00 00 00 00	 call	 ??1CAr@@QAE@XZ		; CAr::~CAr
  0013c	8b 8c 24 28 40
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+16436]
  00143	5f		 pop	 edi
  00144	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0014b	8b 8c 24 20 40
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+16432]
  00152	5e		 pop	 esi
  00153	33 cc		 xor	 ecx, esp
  00155	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0015a	81 c4 2c 40 00
	00		 add	 esp, 16428		; 0000402cH
  00160	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L328359:
  00000	8d 8d dc bf ff
	ff		 lea	 ecx, DWORD PTR _ar$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CAr@@QAE@XZ		; CAr::~CAr
__ehhandler$?AddPutItemElem@CUserMng@@QAEXKPAVCItemElem@@@Z:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T328492
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?AddPutItemElem@CUserMng@@QAEXKPAVCItemElem@@@Z ENDP	; CUserMng::AddPutItemElem
PUBLIC	?AddPVendorOpen@CUserMng@@QAEXPAVCUser@@@Z	; CUserMng::AddPVendorOpen
EXTRN	?GetTitle@CVTInfo@@QAEPBDXZ:NEAR		; CVTInfo::GetTitle
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
xdata$x	SEGMENT
$T328765 DD	0ffffffffH
	DD	FLAT:$L328505
$T328757 DD	019930520H
	DD	01H
	DD	FLAT:$T328765
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
xdata$x	ENDS
;	COMDAT ?AddPVendorOpen@CUserMng@@QAEXPAVCUser@@@Z
_TEXT	SEGMENT
_nBufSize$ = -16424					; size = 4
_ar$ = -16420						; size = 16404
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_pUser$ = 8						; size = 4
?AddPVendorOpen@CUserMng@@QAEXPAVCUser@@@Z PROC NEAR	; CUserMng::AddPVendorOpen, COMDAT
; _this$ = ecx

; 5387 : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?AddPVendorOpen@CUserMng@@QAEXPAVCUser@@@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	b8 1c 40 00 00	 mov	 eax, 16412		; 0000401cH
  00013	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0001a	e8 00 00 00 00	 call	 __chkstk
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00024	33 c4		 xor	 eax, esp
  00026	55		 push	 ebp
  00027	56		 push	 esi
  00028	8b b4 24 34 40
	00 00		 mov	 esi, DWORD PTR _pUser$[esp+16428]
  0002f	57		 push	 edi

; 5388 : 	CAr ar;

  00030	6a 00		 push	 0
  00032	6a 00		 push	 0
  00034	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  00038	89 84 24 2c 40
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+16444], eax
  0003f	e8 00 00 00 00	 call	 ??0CAr@@QAE@PAXI@Z	; CAr::CAr

; 5389 : 	ar << GETID( pUser ) << SNAPSHOTTYPE_PVENDOR_OPEN;

  00044	85 f6		 test	 esi, esi
  00046	c7 84 24 30 40
	00 00 00 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+16444], 0
  00051	74 08		 je	 SHORT $L328503
  00053	8b be bc 01 00
	00		 mov	 edi, DWORD PTR [esi+444]
  00059	eb 03		 jmp	 SHORT $L328504
$L328503:
  0005b	83 cf ff	 or	 edi, -1
$L328504:
  0005e	6a 04		 push	 4
  00060	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  00064	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00069	8b 44 24 18	 mov	 eax, DWORD PTR _ar$[esp+16444]
  0006d	89 38		 mov	 DWORD PTR [eax], edi
  0006f	8b 44 24 18	 mov	 eax, DWORD PTR _ar$[esp+16444]
  00073	83 c0 04	 add	 eax, 4
  00076	6a 02		 push	 2
  00078	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  0007c	89 44 24 1c	 mov	 DWORD PTR _ar$[esp+16448], eax
  00080	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00085	8b 4c 24 18	 mov	 ecx, DWORD PTR _ar$[esp+16444]
  00089	66 c7 01 42 00	 mov	 WORD PTR [ecx], 66	; 00000042H
  0008e	8b 7c 24 18	 mov	 edi, DWORD PTR _ar$[esp+16444]
  00092	83 c7 02	 add	 edi, 2

; 5390 : 	ar.WriteString( pUser->m_vtInfo.GetTitle() );

  00095	8d 8e 7c 0d 00
	00		 lea	 ecx, DWORD PTR [esi+3452]
  0009b	89 7c 24 18	 mov	 DWORD PTR _ar$[esp+16444], edi
  0009f	e8 00 00 00 00	 call	 ?GetTitle@CVTInfo@@QAEPBDXZ ; CVTInfo::GetTitle
  000a4	50		 push	 eax
  000a5	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  000a9	e8 00 00 00 00	 call	 ?WriteString@CAr@@QAEXPBD@Z ; CAr::WriteString

; 5391 : 	GETBLOCK( ar, lpBuf, nBufSize );

  000ae	8d 54 24 0c	 lea	 edx, DWORD PTR _nBufSize$[esp+16436]
  000b2	52		 push	 edx
  000b3	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  000b7	e8 00 00 00 00	 call	 ?GetBuffer@CAr@@QAEPAEPAH@Z ; CAr::GetBuffer

; 5392 : 
; 5393 : 	FOR_VISIBILITYRANGE( pUser )

  000bc	8b be 10 02 00
	00		 mov	 edi, DWORD PTR [esi+528]
  000c2	8b 37		 mov	 esi, DWORD PTR [edi]
  000c4	3b f7		 cmp	 esi, edi
  000c6	8b e8		 mov	 ebp, eax
  000c8	74 74		 je	 SHORT $L282077
  000ca	8d 9b 00 00 00
	00		 npad	 6
$L282076:

; 5394 : 		USERPTR->AddBlock( lpBuf, nBufSize );

  000d0	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  000d3	f6 40 04 01	 test	 BYTE PTR [eax+4], 1
  000d7	8b 4c 24 0c	 mov	 ecx, DWORD PTR _nBufSize$[esp+16436]
  000db	75 14		 jne	 SHORT $L328598
  000dd	66 ff 80 0c 57
	00 00		 inc	 WORD PTR [eax+22284]
  000e4	51		 push	 ecx
  000e5	55		 push	 ebp
  000e6	8d 88 f8 16 00
	00		 lea	 ecx, DWORD PTR [eax+5880]
  000ec	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
$L328598:

; 5395 : 	NEXT_VISIBILITYRANGE( pUser )

  000f1	8a 46 15	 mov	 al, BYTE PTR [esi+21]
  000f4	84 c0		 test	 al, al
  000f6	75 42		 jne	 SHORT $L328740
  000f8	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000fb	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  000fe	84 c9		 test	 cl, cl
  00100	75 1b		 jne	 SHORT $L328760
  00102	8b f0		 mov	 esi, eax
  00104	8b 06		 mov	 eax, DWORD PTR [esi]
  00106	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00109	84 c9		 test	 cl, cl
  0010b	75 2d		 jne	 SHORT $L328740
  0010d	8d 49 00	 npad	 3
$L328754:
  00110	8b f0		 mov	 esi, eax
  00112	8b 06		 mov	 eax, DWORD PTR [esi]
  00114	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00117	84 c9		 test	 cl, cl
  00119	74 f5		 je	 SHORT $L328754
  0011b	eb 1d		 jmp	 SHORT $L328740
$L328760:
  0011d	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00120	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00123	84 c9		 test	 cl, cl
  00125	75 11		 jne	 SHORT $L328743
$L328742:
  00127	3b 70 08	 cmp	 esi, DWORD PTR [eax+8]
  0012a	75 0c		 jne	 SHORT $L328743
  0012c	8b f0		 mov	 esi, eax
  0012e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00131	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00134	84 c9		 test	 cl, cl
  00136	74 ef		 je	 SHORT $L328742
$L328743:
  00138	8b f0		 mov	 esi, eax
$L328740:

; 5392 : 
; 5393 : 	FOR_VISIBILITYRANGE( pUser )

  0013a	3b f7		 cmp	 esi, edi
  0013c	75 92		 jne	 SHORT $L282076
$L282077:

; 5396 : }

  0013e	8d 4c 24 10	 lea	 ecx, DWORD PTR _ar$[esp+16436]
  00142	c7 84 24 30 40
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+16444], -1
  0014d	e8 00 00 00 00	 call	 ??1CAr@@QAE@XZ		; CAr::~CAr
  00152	8b 8c 24 28 40
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+16436]
  00159	5f		 pop	 edi
  0015a	5e		 pop	 esi
  0015b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00162	8b 8c 24 1c 40
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+16428]
  00169	5d		 pop	 ebp
  0016a	33 cc		 xor	 ecx, esp
  0016c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00171	81 c4 28 40 00
	00		 add	 esp, 16424		; 00004028H
  00177	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L328505:
  00000	8d 8d dc bf ff
	ff		 lea	 ecx, DWORD PTR _ar$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CAr@@QAE@XZ		; CAr::~CAr
__ehhandler$?AddPVendorOpen@CUserMng@@QAEXPAVCUser@@@Z:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T328757
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?AddPVendorOpen@CUserMng@@QAEXPAVCUser@@@Z ENDP		; CUserMng::AddPVendorOpen
PUBLIC	?AddPVendorClose@CUserMng@@QAEXPAVCUser@@@Z	; CUserMng::AddPVendorClose
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
xdata$x	SEGMENT
$T329037 DD	0ffffffffH
	DD	FLAT:$L328774
$T329029 DD	019930520H
	DD	01H
	DD	FLAT:$T329037
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
xdata$x	ENDS
;	COMDAT ?AddPVendorClose@CUserMng@@QAEXPAVCUser@@@Z
_TEXT	SEGMENT
_nBufSize$ = -16424					; size = 4
_ar$ = -16420						; size = 16404
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_pUser$ = 8						; size = 4
?AddPVendorClose@CUserMng@@QAEXPAVCUser@@@Z PROC NEAR	; CUserMng::AddPVendorClose, COMDAT
; _this$ = ecx

; 5399 : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?AddPVendorClose@CUserMng@@QAEXPAVCUser@@@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	b8 1c 40 00 00	 mov	 eax, 16412		; 0000401cH
  00013	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0001a	e8 00 00 00 00	 call	 __chkstk
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00024	33 c4		 xor	 eax, esp
  00026	55		 push	 ebp
  00027	56		 push	 esi
  00028	8b b4 24 34 40
	00 00		 mov	 esi, DWORD PTR _pUser$[esp+16428]
  0002f	57		 push	 edi

; 5400 : 	CAr ar;

  00030	6a 00		 push	 0
  00032	6a 00		 push	 0
  00034	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  00038	89 84 24 2c 40
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+16444], eax
  0003f	e8 00 00 00 00	 call	 ??0CAr@@QAE@PAXI@Z	; CAr::CAr

; 5401 : 	ar << GETID( pUser ) << SNAPSHOTTYPE_PVENDOR_CLOSE;

  00044	85 f6		 test	 esi, esi
  00046	c7 84 24 30 40
	00 00 00 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+16444], 0
  00051	74 08		 je	 SHORT $L328772
  00053	8b be bc 01 00
	00		 mov	 edi, DWORD PTR [esi+444]
  00059	eb 03		 jmp	 SHORT $L328773
$L328772:
  0005b	83 cf ff	 or	 edi, -1
$L328773:
  0005e	6a 04		 push	 4
  00060	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  00064	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00069	8b 44 24 18	 mov	 eax, DWORD PTR _ar$[esp+16444]
  0006d	89 38		 mov	 DWORD PTR [eax], edi
  0006f	83 44 24 18 04	 add	 DWORD PTR _ar$[esp+16444], 4
  00074	6a 02		 push	 2
  00076	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  0007a	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0007f	8b 4c 24 18	 mov	 ecx, DWORD PTR _ar$[esp+16444]
  00083	66 c7 01 43 00	 mov	 WORD PTR [ecx], 67	; 00000043H
  00088	8b 6c 24 18	 mov	 ebp, DWORD PTR _ar$[esp+16444]
  0008c	83 c5 02	 add	 ebp, 2

; 5402 : 	ar << (BYTE)1;

  0008f	6a 01		 push	 1
  00091	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  00095	89 6c 24 1c	 mov	 DWORD PTR _ar$[esp+16448], ebp
  00099	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0009e	8b 54 24 18	 mov	 edx, DWORD PTR _ar$[esp+16444]
  000a2	c6 02 01	 mov	 BYTE PTR [edx], 1
  000a5	8b 54 24 18	 mov	 edx, DWORD PTR _ar$[esp+16444]

; 5403 : 	GETBLOCK( ar, lpBuf, nBufSize );

  000a9	8d 44 24 0c	 lea	 eax, DWORD PTR _nBufSize$[esp+16436]
  000ad	42		 inc	 edx
  000ae	50		 push	 eax
  000af	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  000b3	89 54 24 1c	 mov	 DWORD PTR _ar$[esp+16448], edx
  000b7	e8 00 00 00 00	 call	 ?GetBuffer@CAr@@QAEPAEPAH@Z ; CAr::GetBuffer

; 5404 : 
; 5405 : 	FOR_VISIBILITYRANGE( pUser )

  000bc	8b be 10 02 00
	00		 mov	 edi, DWORD PTR [esi+528]
  000c2	8b 37		 mov	 esi, DWORD PTR [edi]
  000c4	3b f7		 cmp	 esi, edi
  000c6	8b e8		 mov	 ebp, eax
  000c8	74 74		 je	 SHORT $L282103
  000ca	8d 9b 00 00 00
	00		 npad	 6
$L282102:

; 5406 : 		USERPTR->AddBlock( lpBuf, nBufSize );

  000d0	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  000d3	f6 40 04 01	 test	 BYTE PTR [eax+4], 1
  000d7	8b 4c 24 0c	 mov	 ecx, DWORD PTR _nBufSize$[esp+16436]
  000db	75 14		 jne	 SHORT $L328873
  000dd	66 ff 80 0c 57
	00 00		 inc	 WORD PTR [eax+22284]
  000e4	51		 push	 ecx
  000e5	55		 push	 ebp
  000e6	8d 88 f8 16 00
	00		 lea	 ecx, DWORD PTR [eax+5880]
  000ec	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
$L328873:

; 5407 : 	NEXT_VISIBILITYRANGE( pUser )

  000f1	8a 46 15	 mov	 al, BYTE PTR [esi+21]
  000f4	84 c0		 test	 al, al
  000f6	75 42		 jne	 SHORT $L329021
  000f8	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000fb	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  000fe	84 c9		 test	 cl, cl
  00100	75 1b		 jne	 SHORT $L329032
  00102	8b f0		 mov	 esi, eax
  00104	8b 06		 mov	 eax, DWORD PTR [esi]
  00106	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00109	84 c9		 test	 cl, cl
  0010b	75 2d		 jne	 SHORT $L329021
  0010d	8d 49 00	 npad	 3
$L329009:
  00110	8b f0		 mov	 esi, eax
  00112	8b 06		 mov	 eax, DWORD PTR [esi]
  00114	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00117	84 c9		 test	 cl, cl
  00119	74 f5		 je	 SHORT $L329009
  0011b	eb 1d		 jmp	 SHORT $L329021
$L329032:
  0011d	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00120	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00123	84 c9		 test	 cl, cl
  00125	75 11		 jne	 SHORT $L329024
$L329023:
  00127	3b 70 08	 cmp	 esi, DWORD PTR [eax+8]
  0012a	75 0c		 jne	 SHORT $L329024
  0012c	8b f0		 mov	 esi, eax
  0012e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00131	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00134	84 c9		 test	 cl, cl
  00136	74 ef		 je	 SHORT $L329023
$L329024:
  00138	8b f0		 mov	 esi, eax
$L329021:

; 5404 : 
; 5405 : 	FOR_VISIBILITYRANGE( pUser )

  0013a	3b f7		 cmp	 esi, edi
  0013c	75 92		 jne	 SHORT $L282102
$L282103:

; 5408 : }

  0013e	8d 4c 24 10	 lea	 ecx, DWORD PTR _ar$[esp+16436]
  00142	c7 84 24 30 40
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+16444], -1
  0014d	e8 00 00 00 00	 call	 ??1CAr@@QAE@XZ		; CAr::~CAr
  00152	8b 8c 24 28 40
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+16436]
  00159	5f		 pop	 edi
  0015a	5e		 pop	 esi
  0015b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00162	8b 8c 24 1c 40
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+16428]
  00169	5d		 pop	 ebp
  0016a	33 cc		 xor	 ecx, esp
  0016c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00171	81 c4 28 40 00
	00		 add	 esp, 16424		; 00004028H
  00177	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L328774:
  00000	8d 8d dc bf ff
	ff		 lea	 ecx, DWORD PTR _ar$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CAr@@QAE@XZ		; CAr::~CAr
__ehhandler$?AddPVendorClose@CUserMng@@QAEXPAVCUser@@@Z:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T329029
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?AddPVendorClose@CUserMng@@QAEXPAVCUser@@@Z ENDP	; CUserMng::AddPVendorClose
PUBLIC	?AddPVendorItemNum@CUserMng@@QAEXPAVCUser@@EFPBD@Z ; CUserMng::AddPVendorItemNum
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
xdata$x	SEGMENT
$T329368 DD	0ffffffffH
	DD	FLAT:$L329046
$T329359 DD	019930520H
	DD	01H
	DD	FLAT:$T329368
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
xdata$x	ENDS
;	COMDAT ?AddPVendorItemNum@CUserMng@@QAEXPAVCUser@@EFPBD@Z
_TEXT	SEGMENT
_nBufSize$ = -16424					; size = 4
_ar$ = -16420						; size = 16404
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_pUser$ = 8						; size = 4
_nItem$ = 12						; size = 1
_nVend$ = 16						; size = 2
_sBuyer$ = 20						; size = 4
?AddPVendorItemNum@CUserMng@@QAEXPAVCUser@@EFPBD@Z PROC NEAR ; CUserMng::AddPVendorItemNum, COMDAT
; _this$ = ecx

; 5415 : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?AddPVendorItemNum@CUserMng@@QAEXPAVCUser@@EFPBD@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	b8 1c 40 00 00	 mov	 eax, 16412		; 0000401cH
  00013	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0001a	e8 00 00 00 00	 call	 __chkstk
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00024	33 c4		 xor	 eax, esp
  00026	53		 push	 ebx
  00027	55		 push	 ebp
  00028	8b ac 24 34 40
	00 00		 mov	 ebp, DWORD PTR _pUser$[esp+16428]
  0002f	56		 push	 esi
  00030	57		 push	 edi
  00031	8b bc 24 48 40
	00 00		 mov	 edi, DWORD PTR _sBuyer$[esp+16436]

; 5416 : 	CAr ar;

  00038	6a 00		 push	 0
  0003a	6a 00		 push	 0
  0003c	8d 4c 24 1c	 lea	 ecx, DWORD PTR _ar$[esp+16448]
  00040	89 84 24 30 40
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+16448], eax
  00047	e8 00 00 00 00	 call	 ??0CAr@@QAE@PAXI@Z	; CAr::CAr

; 5417 : 	ar << GETID( pUser ) << SNAPSHOTTYPE_PVENDOR_ITEM_NUM;

  0004c	85 ed		 test	 ebp, ebp
  0004e	c7 84 24 34 40
	00 00 00 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+16448], 0
  00059	74 08		 je	 SHORT $L329044
  0005b	8b b5 bc 01 00
	00		 mov	 esi, DWORD PTR [ebp+444]
  00061	eb 03		 jmp	 SHORT $L329045
$L329044:
  00063	83 ce ff	 or	 esi, -1
$L329045:
  00066	6a 04		 push	 4
  00068	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  0006c	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00071	8b 44 24 1c	 mov	 eax, DWORD PTR _ar$[esp+16448]
  00075	89 30		 mov	 DWORD PTR [eax], esi
  00077	83 44 24 1c 04	 add	 DWORD PTR _ar$[esp+16448], 4
  0007c	be 02 00 00 00	 mov	 esi, 2
  00081	56		 push	 esi
  00082	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  00086	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0008b	8b 4c 24 1c	 mov	 ecx, DWORD PTR _ar$[esp+16448]
  0008f	66 c7 01 46 00	 mov	 WORD PTR [ecx], 70	; 00000046H
  00094	8b 5c 24 1c	 mov	 ebx, DWORD PTR _ar$[esp+16448]
  00098	03 de		 add	 ebx, esi

; 5418 : 	ar << nItem << nVend;

  0009a	6a 01		 push	 1
  0009c	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  000a0	89 5c 24 20	 mov	 DWORD PTR _ar$[esp+16452], ebx
  000a4	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000a9	8b 54 24 1c	 mov	 edx, DWORD PTR _ar$[esp+16448]
  000ad	8a 84 24 40 40
	00 00		 mov	 al, BYTE PTR _nItem$[esp+16436]
  000b4	88 02		 mov	 BYTE PTR [edx], al
  000b6	ff 44 24 1c	 inc	 DWORD PTR _ar$[esp+16448]
  000ba	56		 push	 esi
  000bb	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  000bf	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000c4	8b 4c 24 1c	 mov	 ecx, DWORD PTR _ar$[esp+16448]
  000c8	66 8b 94 24 44
	40 00 00	 mov	 dx, WORD PTR _nVend$[esp+16436]
  000d0	66 89 11	 mov	 WORD PTR [ecx], dx
  000d3	8b 5c 24 1c	 mov	 ebx, DWORD PTR _ar$[esp+16448]
  000d7	03 de		 add	 ebx, esi

; 5419 : #if __VER >= 11 // __MOD_VENDOR
; 5420 : 	ar.WriteString( sBuyer );

  000d9	57		 push	 edi
  000da	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  000de	89 5c 24 20	 mov	 DWORD PTR _ar$[esp+16452], ebx
  000e2	e8 00 00 00 00	 call	 ?WriteString@CAr@@QAEXPBD@Z ; CAr::WriteString

; 5421 : #endif	// __MOD_VENDOR
; 5422 : 	GETBLOCK( ar, lpBuf, nBufSize );

  000e7	8d 44 24 10	 lea	 eax, DWORD PTR _nBufSize$[esp+16440]
  000eb	50		 push	 eax
  000ec	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  000f0	e8 00 00 00 00	 call	 ?GetBuffer@CAr@@QAEPAEPAH@Z ; CAr::GetBuffer

; 5423 : 
; 5424 : 	FOR_VISIBILITYRANGE( pUser )

  000f5	8b bd 10 02 00
	00		 mov	 edi, DWORD PTR [ebp+528]
  000fb	8b 37		 mov	 esi, DWORD PTR [edi]
  000fd	3b f7		 cmp	 esi, edi
  000ff	8b d8		 mov	 ebx, eax
  00101	0f 84 8b 00 00
	00		 je	 $L282131
$L282130:

; 5425 : 		if( USERPTR == pUser || USERPTR->m_vtInfo.GetOther() == pUser )

  00107	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0010a	3b c5		 cmp	 eax, ebp
  0010c	74 11		 je	 SHORT $L282133
  0010e	8b c8		 mov	 ecx, eax
  00110	81 c1 7c 0d 00
	00		 add	 ecx, 3452		; 00000d7cH
  00116	e8 00 00 00 00	 call	 ?GetOther@CVTInfo@@QAEPAVCMover@@XZ ; CVTInfo::GetOther
  0011b	3b c5		 cmp	 eax, ebp
  0011d	75 21		 jne	 SHORT $L329365
$L282133:

; 5426 : 			USERPTR->AddBlock( lpBuf, nBufSize );

  0011f	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00122	f6 40 04 01	 test	 BYTE PTR [eax+4], 1
  00126	8b 4c 24 10	 mov	 ecx, DWORD PTR _nBufSize$[esp+16440]
  0012a	75 14		 jne	 SHORT $L329365
  0012c	66 ff 80 0c 57
	00 00		 inc	 WORD PTR [eax+22284]
  00133	51		 push	 ecx
  00134	53		 push	 ebx
  00135	8d 88 f8 16 00
	00		 lea	 ecx, DWORD PTR [eax+5880]
  0013b	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
$L329365:

; 5427 : 	NEXT_VISIBILITYRANGE( pUser )

  00140	8a 46 15	 mov	 al, BYTE PTR [esi+21]
  00143	84 c0		 test	 al, al
  00145	75 43		 jne	 SHORT $L329326
  00147	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0014a	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  0014d	84 c9		 test	 cl, cl
  0014f	75 1c		 jne	 SHORT $L329362
  00151	8b f0		 mov	 esi, eax
  00153	8b 06		 mov	 eax, DWORD PTR [esi]
  00155	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00158	84 c9		 test	 cl, cl
  0015a	75 2e		 jne	 SHORT $L329326
  0015c	8d 64 24 00	 npad	 4
$L329347:
  00160	8b f0		 mov	 esi, eax
  00162	8b 06		 mov	 eax, DWORD PTR [esi]
  00164	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00167	84 c9		 test	 cl, cl
  00169	74 f5		 je	 SHORT $L329347
  0016b	eb 1d		 jmp	 SHORT $L329326
$L329362:
  0016d	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00170	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00173	84 c9		 test	 cl, cl
  00175	75 11		 jne	 SHORT $L329329
$L329328:
  00177	3b 70 08	 cmp	 esi, DWORD PTR [eax+8]
  0017a	75 0c		 jne	 SHORT $L329329
  0017c	8b f0		 mov	 esi, eax
  0017e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00181	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00184	84 c9		 test	 cl, cl
  00186	74 ef		 je	 SHORT $L329328
$L329329:
  00188	8b f0		 mov	 esi, eax
$L329326:

; 5423 : 
; 5424 : 	FOR_VISIBILITYRANGE( pUser )

  0018a	3b f7		 cmp	 esi, edi
  0018c	0f 85 75 ff ff
	ff		 jne	 $L282130
$L282131:

; 5428 : }

  00192	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  00196	c7 84 24 34 40
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+16448], -1
  001a1	e8 00 00 00 00	 call	 ??1CAr@@QAE@XZ		; CAr::~CAr
  001a6	8b 8c 24 2c 40
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+16440]
  001ad	5f		 pop	 edi
  001ae	5e		 pop	 esi
  001af	5d		 pop	 ebp
  001b0	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  001b7	8b 8c 24 1c 40
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+16428]
  001be	5b		 pop	 ebx
  001bf	33 cc		 xor	 ecx, esp
  001c1	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001c6	81 c4 28 40 00
	00		 add	 esp, 16424		; 00004028H
  001cc	c2 10 00	 ret	 16			; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L329046:
  00000	8d 8d dc bf ff
	ff		 lea	 ecx, DWORD PTR _ar$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CAr@@QAE@XZ		; CAr::~CAr
__ehhandler$?AddPVendorItemNum@CUserMng@@QAEXPAVCUser@@EFPBD@Z:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T329359
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?AddPVendorItemNum@CUserMng@@QAEXPAVCUser@@EFPBD@Z ENDP	; CUserMng::AddPVendorItemNum
PUBLIC	?AddSetHair@CUserMng@@QAEXPAVCUser@@EEEE@Z	; CUserMng::AddSetHair
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
xdata$x	SEGMENT
$T329649 DD	0ffffffffH
	DD	FLAT:$L329377
$T329641 DD	019930520H
	DD	01H
	DD	FLAT:$T329649
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
xdata$x	ENDS
;	COMDAT ?AddSetHair@CUserMng@@QAEXPAVCUser@@EEEE@Z
_TEXT	SEGMENT
_nBufSize$ = -16424					; size = 4
_ar$ = -16420						; size = 16404
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_pUser$ = 8						; size = 4
_nHair$ = 12						; size = 1
_r$ = 16						; size = 1
_g$ = 20						; size = 1
_b$ = 24						; size = 1
?AddSetHair@CUserMng@@QAEXPAVCUser@@EEEE@Z PROC NEAR	; CUserMng::AddSetHair, COMDAT
; _this$ = ecx

; 5431 : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?AddSetHair@CUserMng@@QAEXPAVCUser@@EEEE@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	b8 1c 40 00 00	 mov	 eax, 16412		; 0000401cH
  00013	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0001a	e8 00 00 00 00	 call	 __chkstk
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00024	33 c4		 xor	 eax, esp
  00026	55		 push	 ebp
  00027	56		 push	 esi
  00028	8b b4 24 34 40
	00 00		 mov	 esi, DWORD PTR _pUser$[esp+16428]
  0002f	57		 push	 edi

; 5432 : 	CAr ar;

  00030	6a 00		 push	 0
  00032	6a 00		 push	 0
  00034	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  00038	89 84 24 2c 40
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+16444], eax
  0003f	e8 00 00 00 00	 call	 ??0CAr@@QAE@PAXI@Z	; CAr::CAr

; 5433 : 	ar << GETID( pUser ) << SNAPSHOTTYPE_SET_HAIR;

  00044	85 f6		 test	 esi, esi
  00046	c7 84 24 30 40
	00 00 00 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+16444], 0
  00051	74 08		 je	 SHORT $L329375
  00053	8b be bc 01 00
	00		 mov	 edi, DWORD PTR [esi+444]
  00059	eb 03		 jmp	 SHORT $L329376
$L329375:
  0005b	83 cf ff	 or	 edi, -1
$L329376:
  0005e	6a 04		 push	 4
  00060	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  00064	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00069	8b 44 24 18	 mov	 eax, DWORD PTR _ar$[esp+16444]
  0006d	89 38		 mov	 DWORD PTR [eax], edi
  0006f	8b 7c 24 18	 mov	 edi, DWORD PTR _ar$[esp+16444]
  00073	83 c7 04	 add	 edi, 4
  00076	6a 02		 push	 2
  00078	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  0007c	89 7c 24 1c	 mov	 DWORD PTR _ar$[esp+16448], edi
  00080	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00085	8b 4c 24 18	 mov	 ecx, DWORD PTR _ar$[esp+16444]
  00089	66 c7 01 48 00	 mov	 WORD PTR [ecx], 72	; 00000048H
  0008e	83 44 24 18 02	 add	 DWORD PTR _ar$[esp+16444], 2

; 5434 : 	ar << nHair << r << g << b;

  00093	6a 01		 push	 1
  00095	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  00099	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0009e	8b 54 24 18	 mov	 edx, DWORD PTR _ar$[esp+16444]
  000a2	8a 84 24 3c 40
	00 00		 mov	 al, BYTE PTR _nHair$[esp+16432]
  000a9	88 02		 mov	 BYTE PTR [edx], al
  000ab	8b 6c 24 18	 mov	 ebp, DWORD PTR _ar$[esp+16444]
  000af	45		 inc	 ebp
  000b0	6a 01		 push	 1
  000b2	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  000b6	89 6c 24 1c	 mov	 DWORD PTR _ar$[esp+16448], ebp
  000ba	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000bf	8b 4c 24 18	 mov	 ecx, DWORD PTR _ar$[esp+16444]
  000c3	8a 94 24 40 40
	00 00		 mov	 dl, BYTE PTR _r$[esp+16432]
  000ca	88 11		 mov	 BYTE PTR [ecx], dl
  000cc	8b 54 24 18	 mov	 edx, DWORD PTR _ar$[esp+16444]
  000d0	42		 inc	 edx
  000d1	6a 01		 push	 1
  000d3	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  000d7	89 54 24 1c	 mov	 DWORD PTR _ar$[esp+16448], edx
  000db	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000e0	8b 44 24 18	 mov	 eax, DWORD PTR _ar$[esp+16444]
  000e4	8a 8c 24 44 40
	00 00		 mov	 cl, BYTE PTR _g$[esp+16432]
  000eb	88 08		 mov	 BYTE PTR [eax], cl
  000ed	8b 44 24 18	 mov	 eax, DWORD PTR _ar$[esp+16444]
  000f1	40		 inc	 eax
  000f2	6a 01		 push	 1
  000f4	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  000f8	89 44 24 1c	 mov	 DWORD PTR _ar$[esp+16448], eax
  000fc	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00101	8b 54 24 18	 mov	 edx, DWORD PTR _ar$[esp+16444]
  00105	8a 84 24 48 40
	00 00		 mov	 al, BYTE PTR _b$[esp+16432]
  0010c	88 02		 mov	 BYTE PTR [edx], al
  0010e	8b 7c 24 18	 mov	 edi, DWORD PTR _ar$[esp+16444]

; 5435 : 	GETBLOCK( ar, lpBuf, nBufSize );

  00112	8d 4c 24 0c	 lea	 ecx, DWORD PTR _nBufSize$[esp+16436]
  00116	51		 push	 ecx
  00117	47		 inc	 edi
  00118	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  0011c	89 7c 24 1c	 mov	 DWORD PTR _ar$[esp+16448], edi
  00120	e8 00 00 00 00	 call	 ?GetBuffer@CAr@@QAEPAEPAH@Z ; CAr::GetBuffer

; 5436 : 
; 5437 : 	FOR_VISIBILITYRANGE( pUser )

  00125	8b be 10 02 00
	00		 mov	 edi, DWORD PTR [esi+528]
  0012b	8b 37		 mov	 esi, DWORD PTR [edi]
  0012d	3b f7		 cmp	 esi, edi
  0012f	8b e8		 mov	 ebp, eax
  00131	74 6b		 je	 SHORT $L282162
$L282161:

; 5438 : 		USERPTR->AddBlock( lpBuf, nBufSize );

  00133	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00136	f6 40 04 01	 test	 BYTE PTR [eax+4], 1
  0013a	8b 4c 24 0c	 mov	 ecx, DWORD PTR _nBufSize$[esp+16436]
  0013e	75 14		 jne	 SHORT $L329482
  00140	66 ff 80 0c 57
	00 00		 inc	 WORD PTR [eax+22284]
  00147	51		 push	 ecx
  00148	55		 push	 ebp
  00149	8d 88 f8 16 00
	00		 lea	 ecx, DWORD PTR [eax+5880]
  0014f	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
$L329482:

; 5439 : 	NEXT_VISIBILITYRANGE( pUser )

  00154	8a 46 15	 mov	 al, BYTE PTR [esi+21]
  00157	84 c0		 test	 al, al
  00159	75 3f		 jne	 SHORT $L329610
  0015b	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0015e	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00161	84 c9		 test	 cl, cl
  00163	75 18		 jne	 SHORT $L329644
  00165	8b f0		 mov	 esi, eax
  00167	8b 06		 mov	 eax, DWORD PTR [esi]
  00169	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  0016c	84 c9		 test	 cl, cl
  0016e	75 2a		 jne	 SHORT $L329610
$L329624:
  00170	8b f0		 mov	 esi, eax
  00172	8b 06		 mov	 eax, DWORD PTR [esi]
  00174	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00177	84 c9		 test	 cl, cl
  00179	74 f5		 je	 SHORT $L329624
  0017b	eb 1d		 jmp	 SHORT $L329610
$L329644:
  0017d	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00180	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00183	84 c9		 test	 cl, cl
  00185	75 11		 jne	 SHORT $L329613
$L329612:
  00187	3b 70 08	 cmp	 esi, DWORD PTR [eax+8]
  0018a	75 0c		 jne	 SHORT $L329613
  0018c	8b f0		 mov	 esi, eax
  0018e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00191	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00194	84 c9		 test	 cl, cl
  00196	74 ef		 je	 SHORT $L329612
$L329613:
  00198	8b f0		 mov	 esi, eax
$L329610:

; 5436 : 
; 5437 : 	FOR_VISIBILITYRANGE( pUser )

  0019a	3b f7		 cmp	 esi, edi
  0019c	75 95		 jne	 SHORT $L282161
$L282162:

; 5440 : }

  0019e	8d 4c 24 10	 lea	 ecx, DWORD PTR _ar$[esp+16436]
  001a2	c7 84 24 30 40
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+16444], -1
  001ad	e8 00 00 00 00	 call	 ??1CAr@@QAE@XZ		; CAr::~CAr
  001b2	8b 8c 24 28 40
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+16436]
  001b9	5f		 pop	 edi
  001ba	5e		 pop	 esi
  001bb	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  001c2	8b 8c 24 1c 40
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+16428]
  001c9	5d		 pop	 ebp
  001ca	33 cc		 xor	 ecx, esp
  001cc	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001d1	81 c4 28 40 00
	00		 add	 esp, 16424		; 00004028H
  001d7	c2 14 00	 ret	 20			; 00000014H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L329377:
  00000	8d 8d dc bf ff
	ff		 lea	 ecx, DWORD PTR _ar$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CAr@@QAE@XZ		; CAr::~CAr
__ehhandler$?AddSetHair@CUserMng@@QAEXPAVCUser@@EEEE@Z:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T329641
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?AddSetHair@CUserMng@@QAEXPAVCUser@@EEEE@Z ENDP		; CUserMng::AddSetHair
PUBLIC	?AddHdr@CUserMng@@QAEXPAVCCtrl@@G@Z		; CUserMng::AddHdr
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
xdata$x	SEGMENT
$T329918 DD	0ffffffffH
	DD	FLAT:$L329658
$T329910 DD	019930520H
	DD	01H
	DD	FLAT:$T329918
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
xdata$x	ENDS
;	COMDAT ?AddHdr@CUserMng@@QAEXPAVCCtrl@@G@Z
_TEXT	SEGMENT
_nBufSize$ = -16424					; size = 4
_ar$ = -16420						; size = 16404
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_pCtrl$ = 8						; size = 4
_wHdr$ = 12						; size = 2
?AddHdr@CUserMng@@QAEXPAVCCtrl@@G@Z PROC NEAR		; CUserMng::AddHdr, COMDAT
; _this$ = ecx

; 5443 : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?AddHdr@CUserMng@@QAEXPAVCCtrl@@G@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	b8 1c 40 00 00	 mov	 eax, 16412		; 0000401cH
  00013	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0001a	e8 00 00 00 00	 call	 __chkstk
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00024	33 c4		 xor	 eax, esp
  00026	55		 push	 ebp
  00027	56		 push	 esi
  00028	8b b4 24 34 40
	00 00		 mov	 esi, DWORD PTR _pCtrl$[esp+16428]
  0002f	57		 push	 edi

; 5444 : 	CAr ar;

  00030	6a 00		 push	 0
  00032	6a 00		 push	 0
  00034	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  00038	89 84 24 2c 40
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+16444], eax
  0003f	e8 00 00 00 00	 call	 ??0CAr@@QAE@PAXI@Z	; CAr::CAr

; 5445 : 	ar << GETID( pCtrl ) << wHdr;

  00044	85 f6		 test	 esi, esi
  00046	c7 84 24 30 40
	00 00 00 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+16444], 0
  00051	74 08		 je	 SHORT $L329656
  00053	8b be bc 01 00
	00		 mov	 edi, DWORD PTR [esi+444]
  00059	eb 03		 jmp	 SHORT $L329657
$L329656:
  0005b	83 cf ff	 or	 edi, -1
$L329657:
  0005e	6a 04		 push	 4
  00060	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  00064	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00069	8b 44 24 18	 mov	 eax, DWORD PTR _ar$[esp+16444]
  0006d	89 38		 mov	 DWORD PTR [eax], edi
  0006f	8b 6c 24 18	 mov	 ebp, DWORD PTR _ar$[esp+16444]
  00073	83 c5 04	 add	 ebp, 4
  00076	6a 02		 push	 2
  00078	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  0007c	89 6c 24 1c	 mov	 DWORD PTR _ar$[esp+16448], ebp
  00080	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00085	8b 4c 24 18	 mov	 ecx, DWORD PTR _ar$[esp+16444]
  00089	66 8b 94 24 3c
	40 00 00	 mov	 dx, WORD PTR _wHdr$[esp+16432]
  00091	66 89 11	 mov	 WORD PTR [ecx], dx
  00094	8b 54 24 18	 mov	 edx, DWORD PTR _ar$[esp+16444]

; 5446 : 
; 5447 : 	GETBLOCK( ar, lpBuf, nBufSize );

  00098	8d 44 24 0c	 lea	 eax, DWORD PTR _nBufSize$[esp+16436]
  0009c	83 c2 02	 add	 edx, 2
  0009f	50		 push	 eax
  000a0	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  000a4	89 54 24 1c	 mov	 DWORD PTR _ar$[esp+16448], edx
  000a8	e8 00 00 00 00	 call	 ?GetBuffer@CAr@@QAEPAEPAH@Z ; CAr::GetBuffer

; 5448 : 
; 5449 : 	FOR_VISIBILITYRANGE( pCtrl )

  000ad	8b be 10 02 00
	00		 mov	 edi, DWORD PTR [esi+528]
  000b3	8b 37		 mov	 esi, DWORD PTR [edi]
  000b5	3b f7		 cmp	 esi, edi
  000b7	8b e8		 mov	 ebp, eax
  000b9	74 73		 je	 SHORT $L282187
  000bb	eb 03 8d 49 00	 npad	 5
$L282186:

; 5450 : 		USERPTR->AddBlock( lpBuf, nBufSize );

  000c0	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  000c3	f6 40 04 01	 test	 BYTE PTR [eax+4], 1
  000c7	8b 4c 24 0c	 mov	 ecx, DWORD PTR _nBufSize$[esp+16436]
  000cb	75 14		 jne	 SHORT $L329754
  000cd	66 ff 80 0c 57
	00 00		 inc	 WORD PTR [eax+22284]
  000d4	51		 push	 ecx
  000d5	55		 push	 ebp
  000d6	8d 88 f8 16 00
	00		 lea	 ecx, DWORD PTR [eax+5880]
  000dc	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
$L329754:

; 5451 : 	NEXT_VISIBILITYRANGE( pCtrl )

  000e1	8a 46 15	 mov	 al, BYTE PTR [esi+21]
  000e4	84 c0		 test	 al, al
  000e6	75 42		 jne	 SHORT $L329902
  000e8	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000eb	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  000ee	84 c9		 test	 cl, cl
  000f0	75 1b		 jne	 SHORT $L329913
  000f2	8b f0		 mov	 esi, eax
  000f4	8b 06		 mov	 eax, DWORD PTR [esi]
  000f6	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  000f9	84 c9		 test	 cl, cl
  000fb	75 2d		 jne	 SHORT $L329902
  000fd	8d 49 00	 npad	 3
$L329890:
  00100	8b f0		 mov	 esi, eax
  00102	8b 06		 mov	 eax, DWORD PTR [esi]
  00104	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00107	84 c9		 test	 cl, cl
  00109	74 f5		 je	 SHORT $L329890
  0010b	eb 1d		 jmp	 SHORT $L329902
$L329913:
  0010d	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00110	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00113	84 c9		 test	 cl, cl
  00115	75 11		 jne	 SHORT $L329905
$L329904:
  00117	3b 70 08	 cmp	 esi, DWORD PTR [eax+8]
  0011a	75 0c		 jne	 SHORT $L329905
  0011c	8b f0		 mov	 esi, eax
  0011e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00121	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00124	84 c9		 test	 cl, cl
  00126	74 ef		 je	 SHORT $L329904
$L329905:
  00128	8b f0		 mov	 esi, eax
$L329902:

; 5448 : 
; 5449 : 	FOR_VISIBILITYRANGE( pCtrl )

  0012a	3b f7		 cmp	 esi, edi
  0012c	75 92		 jne	 SHORT $L282186
$L282187:

; 5452 : }

  0012e	8d 4c 24 10	 lea	 ecx, DWORD PTR _ar$[esp+16436]
  00132	c7 84 24 30 40
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+16444], -1
  0013d	e8 00 00 00 00	 call	 ??1CAr@@QAE@XZ		; CAr::~CAr
  00142	8b 8c 24 28 40
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+16436]
  00149	5f		 pop	 edi
  0014a	5e		 pop	 esi
  0014b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00152	8b 8c 24 1c 40
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+16428]
  00159	5d		 pop	 ebp
  0015a	33 cc		 xor	 ecx, esp
  0015c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00161	81 c4 28 40 00
	00		 add	 esp, 16424		; 00004028H
  00167	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L329658:
  00000	8d 8d dc bf ff
	ff		 lea	 ecx, DWORD PTR _ar$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CAr@@QAE@XZ		; CAr::~CAr
__ehhandler$?AddHdr@CUserMng@@QAEXPAVCCtrl@@G@Z:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T329910
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?AddHdr@CUserMng@@QAEXPAVCCtrl@@G@Z ENDP		; CUserMng::AddHdr
PUBLIC	?AddBlock@CUserMng@@QAEXPAEK@Z			; CUserMng::AddBlock
; Function compile flags: /Ogty
;	COMDAT ?AddBlock@CUserMng@@QAEXPAEK@Z
_TEXT	SEGMENT
_it$ = -4						; size = 4
_lpBlock$ = 8						; size = 4
_uBlockSize$ = 12					; size = 4
?AddBlock@CUserMng@@QAEXPAEK@Z PROC NEAR		; CUserMng::AddBlock, COMDAT
; _this$ = ecx

; 5455 : {

  00000	51		 push	 ecx
  00001	56		 push	 esi
  00002	8b f1		 mov	 esi, ecx

; 5456 : 	map<DWORD, CUser*>::iterator it;
; 5457 : 	for( it = m_users.begin(); it != m_users.end(); ++it )

  00004	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  00007	8b 01		 mov	 eax, DWORD PTR [ecx]
  00009	3b c1		 cmp	 eax, ecx
  0000b	89 44 24 04	 mov	 DWORD PTR _it$[esp+8], eax
  0000f	74 54		 je	 SHORT $L282203
  00011	55		 push	 ebp
  00012	8b 6c 24 10	 mov	 ebp, DWORD PTR _lpBlock$[esp+8]
  00016	57		 push	 edi
  00017	8b 7c 24 18	 mov	 edi, DWORD PTR _uBlockSize$[esp+12]
  0001b	eb 03 8d 49 00	 npad	 5
$L329970:

; 5458 : 	{
; 5459 : 		CUser* pUser = it->second;

  00020	8b 40 10	 mov	 eax, DWORD PTR [eax+16]

; 5460 : 		if( pUser->IsValid() == FALSE )

  00023	f6 40 04 01	 test	 BYTE PTR [eax+4], 1
  00027	75 28		 jne	 SHORT $L282202
  00029	8b 88 e8 16 00
	00		 mov	 ecx, DWORD PTR [eax+5864]
  0002f	85 c9		 test	 ecx, ecx
  00031	74 1e		 je	 SHORT $L282202

; 5461 : 			continue;
; 5462 : 
; 5463 : 		if( pUser->GetWorld() )

  00033	8b 88 6c 01 00
	00		 mov	 ecx, DWORD PTR [eax+364]
  00039	85 c9		 test	 ecx, ecx
  0003b	74 14		 je	 SHORT $L282202

; 5464 : 			pUser->AddBlock( lpBlock, uBlockSize );

  0003d	66 ff 80 0c 57
	00 00		 inc	 WORD PTR [eax+22284]
  00044	57		 push	 edi
  00045	55		 push	 ebp
  00046	8d 88 f8 16 00
	00		 lea	 ecx, DWORD PTR [eax+5880]
  0004c	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
$L282202:
  00051	8d 4c 24 0c	 lea	 ecx, DWORD PTR _it$[esp+16]
  00055	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::const_iterator::_Inc
  0005a	8b 44 24 0c	 mov	 eax, DWORD PTR _it$[esp+16]
  0005e	3b 46 0c	 cmp	 eax, DWORD PTR [esi+12]
  00061	75 bd		 jne	 SHORT $L329970
  00063	5f		 pop	 edi
  00064	5d		 pop	 ebp
$L282203:
  00065	5e		 pop	 esi

; 5465 : 	}
; 5466 : 
; 5467 : }

  00066	59		 pop	 ecx
  00067	c2 08 00	 ret	 8
?AddBlock@CUserMng@@QAEXPAEK@Z ENDP			; CUserMng::AddBlock
_TEXT	ENDS
PUBLIC	?AddBlock@CUserMng@@QAEXPAEKPAVCWorld@@@Z	; CUserMng::AddBlock
; Function compile flags: /Ogty
;	COMDAT ?AddBlock@CUserMng@@QAEXPAEKPAVCWorld@@@Z
_TEXT	SEGMENT
_lpBlock$ = 8						; size = 4
_uBlockSize$ = 12					; size = 4
_it$ = 16						; size = 4
_pWorld$ = 16						; size = 4
?AddBlock@CUserMng@@QAEXPAEKPAVCWorld@@@Z PROC NEAR	; CUserMng::AddBlock, COMDAT
; _this$ = ecx

; 5470 : {

  00000	53		 push	 ebx

; 5471 : 	if( !pWorld )

  00001	8b 5c 24 10	 mov	 ebx, DWORD PTR _pWorld$[esp]
  00005	85 db		 test	 ebx, ebx
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	74 5a		 je	 SHORT $L282224

; 5472 : 		return;
; 5473 : 
; 5474 : 	map<DWORD, CUser*>::iterator it;
; 5475 : 	for( it = m_users.begin(); it != m_users.end(); ++it )

  0000c	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  0000f	8b 01		 mov	 eax, DWORD PTR [ecx]
  00011	3b c1		 cmp	 eax, ecx
  00013	89 44 24 14	 mov	 DWORD PTR _it$[esp+4], eax
  00017	74 4d		 je	 SHORT $L282224
  00019	55		 push	 ebp
  0001a	8b 6c 24 10	 mov	 ebp, DWORD PTR _lpBlock$[esp+8]
  0001e	57		 push	 edi
  0001f	8b 7c 24 18	 mov	 edi, DWORD PTR _uBlockSize$[esp+12]
$L330167:

; 5476 : 	{
; 5477 : 		CUser* pUser = it->second;

  00023	8b 40 10	 mov	 eax, DWORD PTR [eax+16]

; 5478 : 		if( pUser->IsValid() == FALSE )

  00026	f6 40 04 01	 test	 BYTE PTR [eax+4], 1
  0002a	75 26		 jne	 SHORT $L282223
  0002c	8b 88 e8 16 00
	00		 mov	 ecx, DWORD PTR [eax+5864]
  00032	85 c9		 test	 ecx, ecx
  00034	74 1c		 je	 SHORT $L282223

; 5479 : 			continue;
; 5480 : 
; 5481 : 		if( pUser->GetWorld() == pWorld )

  00036	39 98 6c 01 00
	00		 cmp	 DWORD PTR [eax+364], ebx
  0003c	75 14		 jne	 SHORT $L282223

; 5482 : 			pUser->AddBlock( lpBlock, uBlockSize );

  0003e	66 ff 80 0c 57
	00 00		 inc	 WORD PTR [eax+22284]
  00045	57		 push	 edi
  00046	55		 push	 ebp
  00047	8d 88 f8 16 00
	00		 lea	 ecx, DWORD PTR [eax+5880]
  0004d	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
$L282223:
  00052	8d 4c 24 1c	 lea	 ecx, DWORD PTR _it$[esp+12]
  00056	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::const_iterator::_Inc
  0005b	8b 44 24 1c	 mov	 eax, DWORD PTR _it$[esp+12]
  0005f	3b 46 0c	 cmp	 eax, DWORD PTR [esi+12]
  00062	75 bf		 jne	 SHORT $L330167
  00064	5f		 pop	 edi
  00065	5d		 pop	 ebp
$L282224:
  00066	5e		 pop	 esi
  00067	5b		 pop	 ebx

; 5483 : 	}
; 5484 : }

  00068	c2 0c 00	 ret	 12			; 0000000cH
?AddBlock@CUserMng@@QAEXPAEKPAVCWorld@@@Z ENDP		; CUserMng::AddBlock
_TEXT	ENDS
PUBLIC	?AddBlockNoLock@CUserMng@@QAEXPAEK@Z		; CUserMng::AddBlockNoLock
; Function compile flags: /Ogty
;	COMDAT ?AddBlockNoLock@CUserMng@@QAEXPAEK@Z
_TEXT	SEGMENT
_it$ = -4						; size = 4
_lpBlock$ = 8						; size = 4
_uBlockSize$ = 12					; size = 4
?AddBlockNoLock@CUserMng@@QAEXPAEK@Z PROC NEAR		; CUserMng::AddBlockNoLock, COMDAT
; _this$ = ecx

; 5487 : {

  00000	51		 push	 ecx
  00001	56		 push	 esi
  00002	8b f1		 mov	 esi, ecx

; 5488 : 	map<DWORD, CUser*>::iterator it;
; 5489 : 	for( it = m_users.begin(); it != m_users.end(); ++it )

  00004	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  00007	8b 01		 mov	 eax, DWORD PTR [ecx]
  00009	3b c1		 cmp	 eax, ecx
  0000b	89 44 24 04	 mov	 DWORD PTR _it$[esp+8], eax
  0000f	74 54		 je	 SHORT $L282243
  00011	55		 push	 ebp
  00012	8b 6c 24 10	 mov	 ebp, DWORD PTR _lpBlock$[esp+8]
  00016	57		 push	 edi
  00017	8b 7c 24 18	 mov	 edi, DWORD PTR _uBlockSize$[esp+12]
  0001b	eb 03 8d 49 00	 npad	 5
$L330214:

; 5490 : 	{
; 5491 : 		CUser* pUser = it->second;

  00020	8b 40 10	 mov	 eax, DWORD PTR [eax+16]

; 5492 : 		if( pUser->IsValid() == FALSE )

  00023	f6 40 04 01	 test	 BYTE PTR [eax+4], 1
  00027	75 28		 jne	 SHORT $L282242
  00029	8b 88 e8 16 00
	00		 mov	 ecx, DWORD PTR [eax+5864]
  0002f	85 c9		 test	 ecx, ecx
  00031	74 1e		 je	 SHORT $L282242

; 5493 : 			continue;
; 5494 : 
; 5495 : 		if( pUser->GetWorld() )

  00033	8b 88 6c 01 00
	00		 mov	 ecx, DWORD PTR [eax+364]
  00039	85 c9		 test	 ecx, ecx
  0003b	74 14		 je	 SHORT $L282242

; 5496 : 			pUser->AddBlock( lpBlock, uBlockSize );

  0003d	66 ff 80 0c 57
	00 00		 inc	 WORD PTR [eax+22284]
  00044	57		 push	 edi
  00045	55		 push	 ebp
  00046	8d 88 f8 16 00
	00		 lea	 ecx, DWORD PTR [eax+5880]
  0004c	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
$L282242:
  00051	8d 4c 24 0c	 lea	 ecx, DWORD PTR _it$[esp+16]
  00055	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::const_iterator::_Inc
  0005a	8b 44 24 0c	 mov	 eax, DWORD PTR _it$[esp+16]
  0005e	3b 46 0c	 cmp	 eax, DWORD PTR [esi+12]
  00061	75 bd		 jne	 SHORT $L330214
  00063	5f		 pop	 edi
  00064	5d		 pop	 ebp
$L282243:
  00065	5e		 pop	 esi

; 5497 : 	}
; 5498 : }

  00066	59		 pop	 ecx
  00067	c2 08 00	 ret	 8
?AddBlockNoLock@CUserMng@@QAEXPAEK@Z ENDP		; CUserMng::AddBlockNoLock
_TEXT	ENDS
PUBLIC	?AddBlockNoLock@CUserMng@@QAEXPAEKPAVCWorld@@@Z	; CUserMng::AddBlockNoLock
; Function compile flags: /Ogty
;	COMDAT ?AddBlockNoLock@CUserMng@@QAEXPAEKPAVCWorld@@@Z
_TEXT	SEGMENT
_lpBlock$ = 8						; size = 4
_uBlockSize$ = 12					; size = 4
_it$ = 16						; size = 4
_pWorld$ = 16						; size = 4
?AddBlockNoLock@CUserMng@@QAEXPAEKPAVCWorld@@@Z PROC NEAR ; CUserMng::AddBlockNoLock, COMDAT
; _this$ = ecx

; 5501 : {

  00000	53		 push	 ebx

; 5502 : 	if( !pWorld )

  00001	8b 5c 24 10	 mov	 ebx, DWORD PTR _pWorld$[esp]
  00005	85 db		 test	 ebx, ebx
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	74 5a		 je	 SHORT $L282264

; 5503 : 		return;
; 5504 : 
; 5505 : 	map<DWORD, CUser*>::iterator it;
; 5506 : 	for( it = m_users.begin(); it != m_users.end(); ++it )

  0000c	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  0000f	8b 01		 mov	 eax, DWORD PTR [ecx]
  00011	3b c1		 cmp	 eax, ecx
  00013	89 44 24 14	 mov	 DWORD PTR _it$[esp+4], eax
  00017	74 4d		 je	 SHORT $L282264
  00019	55		 push	 ebp
  0001a	8b 6c 24 10	 mov	 ebp, DWORD PTR _lpBlock$[esp+8]
  0001e	57		 push	 edi
  0001f	8b 7c 24 18	 mov	 edi, DWORD PTR _uBlockSize$[esp+12]
$L330414:

; 5507 : 	{
; 5508 : 		CUser* pUser = it->second;

  00023	8b 40 10	 mov	 eax, DWORD PTR [eax+16]

; 5509 : 		if( pUser->IsValid() == FALSE )

  00026	f6 40 04 01	 test	 BYTE PTR [eax+4], 1
  0002a	75 26		 jne	 SHORT $L282263
  0002c	8b 88 e8 16 00
	00		 mov	 ecx, DWORD PTR [eax+5864]
  00032	85 c9		 test	 ecx, ecx
  00034	74 1c		 je	 SHORT $L282263

; 5510 : 			continue;
; 5511 : 
; 5512 : 		if( pUser->GetWorld() == pWorld )

  00036	39 98 6c 01 00
	00		 cmp	 DWORD PTR [eax+364], ebx
  0003c	75 14		 jne	 SHORT $L282263

; 5513 : 			pUser->AddBlock( lpBlock, uBlockSize );

  0003e	66 ff 80 0c 57
	00 00		 inc	 WORD PTR [eax+22284]
  00045	57		 push	 edi
  00046	55		 push	 ebp
  00047	8d 88 f8 16 00
	00		 lea	 ecx, DWORD PTR [eax+5880]
  0004d	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
$L282263:
  00052	8d 4c 24 1c	 lea	 ecx, DWORD PTR _it$[esp+12]
  00056	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::const_iterator::_Inc
  0005b	8b 44 24 1c	 mov	 eax, DWORD PTR _it$[esp+12]
  0005f	3b 46 0c	 cmp	 eax, DWORD PTR [esi+12]
  00062	75 bf		 jne	 SHORT $L330414
  00064	5f		 pop	 edi
  00065	5d		 pop	 ebp
$L282264:
  00066	5e		 pop	 esi
  00067	5b		 pop	 ebx

; 5514 : 	}
; 5515 : }

  00068	c2 0c 00	 ret	 12			; 0000000cH
?AddBlockNoLock@CUserMng@@QAEXPAEKPAVCWorld@@@Z ENDP	; CUserMng::AddBlockNoLock
_TEXT	ENDS
PUBLIC	?AddBlock@CUserMng@@QAEXPAVCWorld@@ABUD3DXVECTOR3@@HPAEK@Z ; CUserMng::AddBlock
; Function compile flags: /Ogty
;	COMDAT ?AddBlock@CUserMng@@QAEXPAVCWorld@@ABUD3DXVECTOR3@@HPAEK@Z
_TEXT	SEGMENT
_d$ = -40						; size = 4
_vtmp$ = -36						; size = 12
$T330420 = -24						; size = 12
$T330421 = -12						; size = 12
_pWorld$ = 8						; size = 4
_vPos$ = 12						; size = 4
tv320 = 16						; size = 4
_it$ = 16						; size = 4
_nRange$ = 16						; size = 4
_lpBlock$ = 20						; size = 4
_uBlockSize$ = 24					; size = 4
?AddBlock@CUserMng@@QAEXPAVCWorld@@ABUD3DXVECTOR3@@HPAEK@Z PROC NEAR ; CUserMng::AddBlock, COMDAT
; _this$ = ecx

; 5519 : 	if( !pWorld )

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _pWorld$[esp-4]
  00004	83 ec 28	 sub	 esp, 40			; 00000028H
  00007	85 c0		 test	 eax, eax
  00009	57		 push	 edi
  0000a	8b f9		 mov	 edi, ecx
  0000c	0f 84 0b 01 00
	00		 je	 $L282290

; 5520 : 		return;
; 5521 : 
; 5522 : 	float d	= (float)( nRange * nRange );

  00012	8b 44 24 38	 mov	 eax, DWORD PTR _nRange$[esp+40]
  00016	8b c8		 mov	 ecx, eax
  00018	0f af c8	 imul	 ecx, eax
  0001b	89 4c 24 38	 mov	 DWORD PTR tv320[esp+40], ecx

; 5523 : 	D3DXVECTOR3 vtmp;
; 5524 : 
; 5525 : 	map<DWORD, CUser*>::iterator it;
; 5526 : 	for( it = m_users.begin(); it != m_users.end(); ++it )

  0001f	8b 4f 0c	 mov	 ecx, DWORD PTR [edi+12]
  00022	db 44 24 38	 fild	 DWORD PTR tv320[esp+40]
  00026	8b 01		 mov	 eax, DWORD PTR [ecx]
  00028	3b c1		 cmp	 eax, ecx
  0002a	89 44 24 38	 mov	 DWORD PTR _it$[esp+40], eax
  0002e	d9 5c 24 04	 fstp	 DWORD PTR _d$[esp+44]
  00032	0f 84 e5 00 00
	00		 je	 $L282290
  00038	53		 push	 ebx
  00039	8b 5c 24 40	 mov	 ebx, DWORD PTR _lpBlock$[esp+44]
  0003d	55		 push	 ebp
  0003e	8b 6c 24 48	 mov	 ebp, DWORD PTR _uBlockSize$[esp+48]
  00042	56		 push	 esi
  00043	8b 74 24 40	 mov	 esi, DWORD PTR _vPos$[esp+52]
  00047	eb 07 8d a4 24
	00 00 00 00	 npad	 9
$L330560:

; 5527 : 	{
; 5528 : 		CUser* pUser = it->second;

  00050	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]

; 5529 : 		if( pUser->IsValid() == FALSE )

  00053	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00057	0f 85 a7 00 00
	00		 jne	 $L282289
  0005d	8b 81 e8 16 00
	00		 mov	 eax, DWORD PTR [ecx+5864]
  00063	85 c0		 test	 eax, eax
  00065	0f 84 99 00 00
	00		 je	 $L282289

; 5530 : 			continue;
; 5531 : 
; 5532 : 		vtmp = vPos - pUser->GetPos();

  0006b	d9 06		 fld	 DWORD PTR [esi]
  0006d	8d 91 60 01 00
	00		 lea	 edx, DWORD PTR [ecx+352]
  00073	8b 02		 mov	 eax, DWORD PTR [edx]
  00075	89 44 24 20	 mov	 DWORD PTR $T330420[esp+56], eax
  00079	d8 64 24 20	 fsub	 DWORD PTR $T330420[esp+56]
  0007d	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00080	8b 52 08	 mov	 edx, DWORD PTR [edx+8]
  00083	d9 5c 24 2c	 fstp	 DWORD PTR $T330421[esp+56]
  00087	89 44 24 24	 mov	 DWORD PTR $T330420[esp+60], eax
  0008b	d9 46 04	 fld	 DWORD PTR [esi+4]
  0008e	8b 44 24 2c	 mov	 eax, DWORD PTR $T330421[esp+56]
  00092	d8 64 24 24	 fsub	 DWORD PTR $T330420[esp+60]
  00096	89 54 24 28	 mov	 DWORD PTR $T330420[esp+64], edx
  0009a	89 44 24 14	 mov	 DWORD PTR _vtmp$[esp+56], eax
  0009e	d9 5c 24 30	 fstp	 DWORD PTR $T330421[esp+60]
  000a2	8b 54 24 30	 mov	 edx, DWORD PTR $T330421[esp+60]
  000a6	d9 46 08	 fld	 DWORD PTR [esi+8]
  000a9	89 54 24 18	 mov	 DWORD PTR _vtmp$[esp+60], edx
  000ad	d8 64 24 28	 fsub	 DWORD PTR $T330420[esp+64]

; 5533 : 		if( pUser->GetWorld() == pWorld && D3DXVec3LengthSq( &vtmp ) < d )

  000b1	8b 54 24 3c	 mov	 edx, DWORD PTR _pWorld$[esp+52]
  000b5	d9 5c 24 34	 fstp	 DWORD PTR $T330421[esp+64]
  000b9	8b 44 24 34	 mov	 eax, DWORD PTR $T330421[esp+64]
  000bd	89 44 24 1c	 mov	 DWORD PTR _vtmp$[esp+64], eax
  000c1	39 91 6c 01 00
	00		 cmp	 DWORD PTR [ecx+364], edx
  000c7	75 3b		 jne	 SHORT $L282289
  000c9	d9 44 24 1c	 fld	 DWORD PTR _vtmp$[esp+64]
  000cd	d8 4c 24 1c	 fmul	 DWORD PTR _vtmp$[esp+64]
  000d1	d9 44 24 18	 fld	 DWORD PTR _vtmp$[esp+60]
  000d5	d8 4c 24 18	 fmul	 DWORD PTR _vtmp$[esp+60]
  000d9	de c1		 faddp	 ST(1), ST(0)
  000db	d9 44 24 14	 fld	 DWORD PTR _vtmp$[esp+56]
  000df	d8 4c 24 14	 fmul	 DWORD PTR _vtmp$[esp+56]
  000e3	de c1		 faddp	 ST(1), ST(0)
  000e5	d8 5c 24 10	 fcomp	 DWORD PTR _d$[esp+56]
  000e9	df e0		 fnstsw	 ax
  000eb	f6 c4 05	 test	 ah, 5
  000ee	7a 14		 jp	 SHORT $L282289

; 5534 : 			pUser->AddBlock( lpBlock, uBlockSize );

  000f0	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  000f7	55		 push	 ebp
  000f8	53		 push	 ebx
  000f9	81 c1 f8 16 00
	00		 add	 ecx, 5880		; 000016f8H
  000ff	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
$L282289:
  00104	8d 4c 24 44	 lea	 ecx, DWORD PTR _it$[esp+52]
  00108	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::const_iterator::_Inc
  0010d	8b 44 24 44	 mov	 eax, DWORD PTR _it$[esp+52]
  00111	3b 47 0c	 cmp	 eax, DWORD PTR [edi+12]
  00114	0f 85 36 ff ff
	ff		 jne	 $L330560
  0011a	5e		 pop	 esi
  0011b	5d		 pop	 ebp
  0011c	5b		 pop	 ebx
$L282290:
  0011d	5f		 pop	 edi

; 5535 : 	}
; 5536 : }

  0011e	83 c4 28	 add	 esp, 40			; 00000028H
  00121	c2 14 00	 ret	 20			; 00000014H
?AddBlock@CUserMng@@QAEXPAVCWorld@@ABUD3DXVECTOR3@@HPAEK@Z ENDP ; CUserMng::AddBlock
_TEXT	ENDS
PUBLIC	?AddGameSetting@CUserMng@@QAEXXZ		; CUserMng::AddGameSetting
; Function compile flags: /Ogty
;	COMDAT ?AddGameSetting@CUserMng@@QAEXXZ
_TEXT	SEGMENT
_it$ = -4						; size = 4
?AddGameSetting@CUserMng@@QAEXXZ PROC NEAR		; CUserMng::AddGameSetting, COMDAT
; _this$ = ecx

; 5539 : {

  00000	51		 push	 ecx
  00001	56		 push	 esi
  00002	8b f1		 mov	 esi, ecx

; 5540 : 	map<DWORD, CUser*>::iterator it;
; 5541 : 	for( it = m_users.begin(); it != m_users.end(); ++it )

  00004	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  00007	8b 01		 mov	 eax, DWORD PTR [ecx]
  00009	3b c1		 cmp	 eax, ecx
  0000b	89 44 24 04	 mov	 DWORD PTR _it$[esp+8], eax
  0000f	74 2a		 je	 SHORT $L282310
$L330607:

; 5542 : 	{
; 5543 : 		CUser* pUser = it->second;

  00011	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]

; 5544 : 		if( pUser->IsValid() == FALSE )

  00014	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00018	75 0f		 jne	 SHORT $L282309
  0001a	8b 81 e8 16 00
	00		 mov	 eax, DWORD PTR [ecx+5864]
  00020	85 c0		 test	 eax, eax
  00022	74 05		 je	 SHORT $L282309

; 5545 : 			continue;
; 5546 : 		
; 5547 : 		pUser->AddGameSetting();

  00024	e8 00 00 00 00	 call	 ?AddGameSetting@CUser@@QAEXXZ ; CUser::AddGameSetting
$L282309:

; 5540 : 	map<DWORD, CUser*>::iterator it;
; 5541 : 	for( it = m_users.begin(); it != m_users.end(); ++it )

  00029	8d 4c 24 04	 lea	 ecx, DWORD PTR _it$[esp+8]
  0002d	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::const_iterator::_Inc
  00032	8b 44 24 04	 mov	 eax, DWORD PTR _it$[esp+8]
  00036	3b 46 0c	 cmp	 eax, DWORD PTR [esi+12]
  00039	75 d6		 jne	 SHORT $L330607
$L282310:
  0003b	5e		 pop	 esi

; 5548 : 	}
; 5549 : }

  0003c	59		 pop	 ecx
  0003d	c3		 ret	 0
?AddGameSetting@CUserMng@@QAEXXZ ENDP			; CUserMng::AddGameSetting
_TEXT	ENDS
PUBLIC	?AddShout@CUserMng@@QAEXPAVCUser@@HPAEK@Z	; CUserMng::AddShout
; Function compile flags: /Ogty
;	COMDAT ?AddShout@CUserMng@@QAEXPAVCUser@@HPAEK@Z
_TEXT	SEGMENT
_fRange$ = -52						; size = 4
_v$ = -48						; size = 12
$T330676 = -36						; size = 12
$T330677 = -24						; size = 12
$T330678 = -12						; size = 12
_pUserSrc$ = 8						; size = 4
tv328 = 12						; size = 4
_it$ = 12						; size = 4
_nRange$ = 12						; size = 4
_lpBlock$ = 16						; size = 4
_uBlockSize$ = 20					; size = 4
?AddShout@CUserMng@@QAEXPAVCUser@@HPAEK@Z PROC NEAR	; CUserMng::AddShout, COMDAT
; _this$ = ecx

; 5555 : {

  00000	83 ec 34	 sub	 esp, 52			; 00000034H
  00003	55		 push	 ebp

; 5556 : 	float fRange = (float)( nRange * nRange );

  00004	8b 6c 24 40	 mov	 ebp, DWORD PTR _nRange$[esp+52]
  00008	8b c5		 mov	 eax, ebp
  0000a	0f af c5	 imul	 eax, ebp
  0000d	57		 push	 edi
  0000e	8b f9		 mov	 edi, ecx

; 5557 : 	D3DXVECTOR3 v;
; 5558 : 	
; 5559 : 	map<DWORD, CUser*>::iterator it;
; 5560 : 	for( it = m_users.begin(); it != m_users.end(); ++it )

  00010	8b 4f 0c	 mov	 ecx, DWORD PTR [edi+12]
  00013	89 44 24 44	 mov	 DWORD PTR tv328[esp+56], eax
  00017	8b 01		 mov	 eax, DWORD PTR [ecx]
  00019	3b c1		 cmp	 eax, ecx
  0001b	db 44 24 44	 fild	 DWORD PTR tv328[esp+56]
  0001f	89 44 24 44	 mov	 DWORD PTR _it$[esp+56], eax
  00023	d9 5c 24 08	 fstp	 DWORD PTR _fRange$[esp+60]
  00027	0f 84 18 01 00
	00		 je	 $L282333
  0002d	53		 push	 ebx
  0002e	56		 push	 esi
  0002f	8b 74 24 48	 mov	 esi, DWORD PTR _pUserSrc$[esp+64]
$L330836:

; 5561 : 	{
; 5562 : 		CUser* pUser = it->second;

  00033	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]

; 5563 : 		if( pUser->IsValid() == FALSE )

  00036	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  0003a	0f 85 ed 00 00
	00		 jne	 $L282332
  00040	8b 81 e8 16 00
	00		 mov	 eax, DWORD PTR [ecx+5864]
  00046	85 c0		 test	 eax, eax
  00048	0f 84 df 00 00
	00		 je	 $L282332

; 5564 : 			continue;
; 5565 : 		if( pUser->GetWorld() == NULL )

  0004e	8b 81 6c 01 00
	00		 mov	 eax, DWORD PTR [ecx+364]
  00054	85 c0		 test	 eax, eax
  00056	0f 84 d1 00 00
	00		 je	 $L282332

; 5566 : 			continue;
; 5567 : #if __VER >= 13
; 5568 : 		if( nRange > 0  )

  0005c	85 ed		 test	 ebp, ebp
  0005e	0f 8e ad 00 00
	00		 jle	 $L282341

; 5569 : 		{
; 5570 : 			v = pUserSrc->GetPos() - pUser->GetPos();

  00064	8d 91 60 01 00
	00		 lea	 edx, DWORD PTR [ecx+352]
  0006a	8b 1a		 mov	 ebx, DWORD PTR [edx]
  0006c	89 5c 24 2c	 mov	 DWORD PTR $T330677[esp+68], ebx
  00070	8b 5a 04	 mov	 ebx, DWORD PTR [edx+4]
  00073	8b 52 08	 mov	 edx, DWORD PTR [edx+8]
  00076	89 54 24 34	 mov	 DWORD PTR $T330677[esp+76], edx
  0007a	89 5c 24 30	 mov	 DWORD PTR $T330677[esp+72], ebx
  0007e	8d 96 60 01 00
	00		 lea	 edx, DWORD PTR [esi+352]
  00084	8b 1a		 mov	 ebx, DWORD PTR [edx]
  00086	89 5c 24 20	 mov	 DWORD PTR $T330676[esp+68], ebx
  0008a	d9 44 24 20	 fld	 DWORD PTR $T330676[esp+68]
  0008e	d8 64 24 2c	 fsub	 DWORD PTR $T330677[esp+68]
  00092	8b 5a 04	 mov	 ebx, DWORD PTR [edx+4]
  00095	8b 52 08	 mov	 edx, DWORD PTR [edx+8]
  00098	89 5c 24 24	 mov	 DWORD PTR $T330676[esp+72], ebx
  0009c	d9 5c 24 38	 fstp	 DWORD PTR $T330678[esp+68]
  000a0	89 54 24 28	 mov	 DWORD PTR $T330676[esp+76], edx
  000a4	d9 44 24 24	 fld	 DWORD PTR $T330676[esp+72]
  000a8	8b 54 24 38	 mov	 edx, DWORD PTR $T330678[esp+68]
  000ac	d8 64 24 30	 fsub	 DWORD PTR $T330677[esp+72]
  000b0	89 54 24 14	 mov	 DWORD PTR _v$[esp+68], edx
  000b4	d9 5c 24 3c	 fstp	 DWORD PTR $T330678[esp+72]
  000b8	8b 54 24 3c	 mov	 edx, DWORD PTR $T330678[esp+72]
  000bc	d9 44 24 28	 fld	 DWORD PTR $T330676[esp+76]
  000c0	89 54 24 18	 mov	 DWORD PTR _v$[esp+72], edx
  000c4	d8 64 24 34	 fsub	 DWORD PTR $T330677[esp+76]
  000c8	d9 5c 24 40	 fstp	 DWORD PTR $T330678[esp+76]
  000cc	8b 54 24 40	 mov	 edx, DWORD PTR $T330678[esp+76]
  000d0	89 54 24 1c	 mov	 DWORD PTR _v$[esp+76], edx

; 5571 : 			if(	pUser->GetWorld() != pUserSrc->GetWorld() || pUser->GetLayer() != pUserSrc->GetLayer()
; 5572 : 				|| D3DXVec3LengthSq( &v ) > fRange
; 5573 : 				)

  000d4	3b 86 6c 01 00
	00		 cmp	 eax, DWORD PTR [esi+364]
  000da	75 51		 jne	 SHORT $L282332
  000dc	8b 81 b8 01 00
	00		 mov	 eax, DWORD PTR [ecx+440]
  000e2	3b 86 b8 01 00
	00		 cmp	 eax, DWORD PTR [esi+440]
  000e8	75 43		 jne	 SHORT $L282332
  000ea	d9 44 24 1c	 fld	 DWORD PTR _v$[esp+76]
  000ee	d8 4c 24 1c	 fmul	 DWORD PTR _v$[esp+76]
  000f2	d9 44 24 18	 fld	 DWORD PTR _v$[esp+72]
  000f6	d8 4c 24 18	 fmul	 DWORD PTR _v$[esp+72]
  000fa	de c1		 faddp	 ST(1), ST(0)
  000fc	d9 44 24 14	 fld	 DWORD PTR _v$[esp+68]
  00100	d8 4c 24 14	 fmul	 DWORD PTR _v$[esp+68]
  00104	de c1		 faddp	 ST(1), ST(0)
  00106	d8 5c 24 10	 fcomp	 DWORD PTR _fRange$[esp+68]
  0010a	df e0		 fnstsw	 ax
  0010c	f6 c4 41	 test	 ah, 65			; 00000041H

; 5574 : 				continue;

  0010f	74 1c		 je	 SHORT $L282332
$L282341:

; 5575 : 		}
; 5576 : 
; 5577 : 		pUser->AddBlock( lpBlock, uBlockSize );

  00111	8b 54 24 54	 mov	 edx, DWORD PTR _uBlockSize$[esp+64]
  00115	8b 44 24 50	 mov	 eax, DWORD PTR _lpBlock$[esp+64]
  00119	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  00120	52		 push	 edx
  00121	50		 push	 eax
  00122	81 c1 f8 16 00
	00		 add	 ecx, 5880		; 000016f8H
  00128	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
$L282332:
  0012d	8d 4c 24 4c	 lea	 ecx, DWORD PTR _it$[esp+64]
  00131	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::const_iterator::_Inc
  00136	8b 44 24 4c	 mov	 eax, DWORD PTR _it$[esp+64]
  0013a	3b 47 0c	 cmp	 eax, DWORD PTR [edi+12]
  0013d	0f 85 f0 fe ff
	ff		 jne	 $L330836
  00143	5e		 pop	 esi
  00144	5b		 pop	 ebx
$L282333:
  00145	5f		 pop	 edi
  00146	5d		 pop	 ebp

; 5578 : #else // __VER >= 13
; 5579 : 		v = vPos - pUser->GetPos();
; 5580 : 		if( nRange == 0 || D3DXVec3LengthSq( &v ) < fRange )
; 5581 : 		{
; 5582 : 			pUser->AddBlock( lpBlock, uBlockSize );
; 5583 : 		}
; 5584 : #endif // __VER >= 13
; 5585 : 	}
; 5586 : }

  00147	83 c4 34	 add	 esp, 52			; 00000034H
  0014a	c2 10 00	 ret	 16			; 00000010H
?AddShout@CUserMng@@QAEXPAVCUser@@HPAEK@Z ENDP		; CUserMng::AddShout
_TEXT	ENDS
PUBLIC	?AddWorldMsg@CUserMng@@QAEXPBVCRect@@PBD@Z	; CUserMng::AddWorldMsg
;	COMDAT xdata$x
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\obj.h
xdata$x	SEGMENT
$T331014 DD	0ffffffffH
	DD	FLAT:$L330847
$T331006 DD	019930520H
	DD	01H
	DD	FLAT:$T331014
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
xdata$x	ENDS
;	COMDAT ?AddWorldMsg@CUserMng@@QAEXPBVCRect@@PBD@Z
_TEXT	SEGMENT
_it$ = -16444						; size = 4
$T331003 = -16440					; size = 4
_uBlockSize$ = -16436					; size = 4
_vtmp$ = -16432						; size = 12
_arBlock$ = -16420					; size = 16404
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_pRect$ = 8						; size = 4
_lpszString$ = 12					; size = 4
?AddWorldMsg@CUserMng@@QAEXPBVCRect@@PBD@Z PROC NEAR	; CUserMng::AddWorldMsg, COMDAT
; _this$ = ecx

; 5590 : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?AddWorldMsg@CUserMng@@QAEXPBVCRect@@PBD@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	b8 30 40 00 00	 mov	 eax, 16432		; 00004030H
  00013	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0001a	e8 00 00 00 00	 call	 __chkstk
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00024	33 c4		 xor	 eax, esp
  00026	53		 push	 ebx
  00027	55		 push	 ebp
  00028	56		 push	 esi
  00029	8b b4 24 50 40
	00 00		 mov	 esi, DWORD PTR _lpszString$[esp+16452]
  00030	89 84 24 38 40
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+16456], eax

; 5607 : 		{
; 5608 : 			if( pRect == NULL )

  00037	8b 84 24 4c 40
	00 00		 mov	 eax, DWORD PTR _pRect$[esp+16452]
  0003e	6a 00		 push	 0
  00040	8b d9		 mov	 ebx, ecx
  00042	6a 00		 push	 0
  00044	8d 4c 24 2c	 lea	 ecx, DWORD PTR _arBlock$[esp+16464]
  00048	89 44 24 18	 mov	 DWORD PTR $T331003[esp+16464], eax
  0004c	e8 00 00 00 00	 call	 ??0CAr@@QAE@PAXI@Z	; CAr::CAr
  00051	6a 04		 push	 4
  00053	8d 4c 24 28	 lea	 ecx, DWORD PTR _arBlock$[esp+16460]
  00057	c7 84 24 48 40
	00 00 00 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+16468], 0
  00062	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00067	8b 4c 24 2c	 mov	 ecx, DWORD PTR _arBlock$[esp+16464]
  0006b	c7 01 ff ff ff
	ff		 mov	 DWORD PTR [ecx], -1
  00071	83 44 24 2c 04	 add	 DWORD PTR _arBlock$[esp+16464], 4
  00076	6a 02		 push	 2
  00078	8d 4c 24 28	 lea	 ecx, DWORD PTR _arBlock$[esp+16460]
  0007c	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00081	8b 54 24 2c	 mov	 edx, DWORD PTR _arBlock$[esp+16464]
  00085	66 c7 02 de 00	 mov	 WORD PTR [edx], 222	; 000000deH
  0008a	8b 6c 24 2c	 mov	 ebp, DWORD PTR _arBlock$[esp+16464]
  0008e	83 c5 02	 add	 ebp, 2
  00091	56		 push	 esi
  00092	8d 4c 24 28	 lea	 ecx, DWORD PTR _arBlock$[esp+16460]
  00096	89 6c 24 30	 mov	 DWORD PTR _arBlock$[esp+16468], ebp
  0009a	e8 00 00 00 00	 call	 ?WriteString@CAr@@QAEXPBD@Z ; CAr::WriteString
  0009f	8d 44 24 14	 lea	 eax, DWORD PTR _uBlockSize$[esp+16456]
  000a3	50		 push	 eax
  000a4	8d 4c 24 28	 lea	 ecx, DWORD PTR _arBlock$[esp+16460]
  000a8	e8 00 00 00 00	 call	 ?GetBuffer@CAr@@QAEPAEPAH@Z ; CAr::GetBuffer
  000ad	8b e8		 mov	 ebp, eax
  000af	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]
  000b2	8b 08		 mov	 ecx, DWORD PTR [eax]
  000b4	3b c8		 cmp	 ecx, eax
  000b6	89 4c 24 0c	 mov	 DWORD PTR _it$[esp+16456], ecx
  000ba	0f 84 a6 00 00
	00		 je	 $L282363
  000c0	57		 push	 edi
$L331010:

; 5591 : 	CAr arBlock;
; 5592 : 	arBlock << NULL_ID << SNAPSHOTTYPE_WORLDMSG;
; 5593 : 	arBlock.WriteString( lpszString );
; 5594 : 	GETBLOCK( arBlock, lpBlock, uBlockSize );
; 5595 : 
; 5596 : 	D3DXVECTOR3 vtmp;
; 5597 : 	
; 5598 : 	map<DWORD, CUser*>::iterator it;
; 5599 : 	for( it = m_users.begin(); it != m_users.end(); ++it )
; 5600 : 	{
; 5601 : 		CUser* pUser = it->second;

  000c1	8b 71 10	 mov	 esi, DWORD PTR [ecx+16]

; 5602 : 		if( pUser->IsValid() == FALSE )

  000c4	f6 46 04 01	 test	 BYTE PTR [esi+4], 1
  000c8	0f 85 7f 00 00
	00		 jne	 $L282362
  000ce	8b 86 e8 16 00
	00		 mov	 eax, DWORD PTR [esi+5864]
  000d4	85 c0		 test	 eax, eax
  000d6	74 75		 je	 SHORT $L282362

; 5603 : 			continue;
; 5604 : 
; 5605 : 		vtmp = pUser->GetPos();

  000d8	8d 8e 60 01 00
	00		 lea	 ecx, DWORD PTR [esi+352]
  000de	8b 11		 mov	 edx, DWORD PTR [ecx]
  000e0	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  000e3	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  000e6	89 44 24 20	 mov	 DWORD PTR _vtmp$[esp+16464], eax

; 5606 : 		if( pUser->GetWorld() )

  000ea	8b 86 6c 01 00
	00		 mov	 eax, DWORD PTR [esi+364]
  000f0	85 c0		 test	 eax, eax
  000f2	89 54 24 1c	 mov	 DWORD PTR _vtmp$[esp+16460], edx
  000f6	89 4c 24 24	 mov	 DWORD PTR _vtmp$[esp+16468], ecx
  000fa	74 51		 je	 SHORT $L282362

; 5607 : 		{
; 5608 : 			if( pRect == NULL )

  000fc	8b 44 24 14	 mov	 eax, DWORD PTR $T331003[esp+16460]
  00100	85 c0		 test	 eax, eax
  00102	75 06		 jne	 SHORT $L282368

; 5609 : 				pUser->AddBlock( lpBlock, uBlockSize );

  00104	8b 44 24 18	 mov	 eax, DWORD PTR _uBlockSize$[esp+16460]

; 5610 : 			else if( pRect->PtInRect( CPoint( (int) vtmp.x, (int) vtmp.y ) ) )

  00108	eb 2f		 jmp	 SHORT $L331013
$L282368:
  0010a	d9 44 24 20	 fld	 DWORD PTR _vtmp$[esp+16464]
  0010e	e8 00 00 00 00	 call	 __ftol2
  00113	d9 44 24 1c	 fld	 DWORD PTR _vtmp$[esp+16460]
  00117	8b f8		 mov	 edi, eax
  00119	e8 00 00 00 00	 call	 __ftol2
  0011e	8b 54 24 14	 mov	 edx, DWORD PTR $T331003[esp+16460]
  00122	57		 push	 edi
  00123	50		 push	 eax
  00124	52		 push	 edx
  00125	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PtInRect@12
  0012b	85 c0		 test	 eax, eax
  0012d	74 1e		 je	 SHORT $L282362

; 5611 : 				pUser->AddBlock( lpBlock, uBlockSize );

  0012f	f6 46 04 01	 test	 BYTE PTR [esi+4], 1
  00133	8b 44 24 18	 mov	 eax, DWORD PTR _uBlockSize$[esp+16460]
  00137	75 14		 jne	 SHORT $L282362
$L331013:
  00139	66 ff 86 0c 57
	00 00		 inc	 WORD PTR [esi+22284]
  00140	50		 push	 eax
  00141	8d 8e f8 16 00
	00		 lea	 ecx, DWORD PTR [esi+5880]
  00147	55		 push	 ebp
  00148	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
$L282362:
  0014d	8d 4c 24 10	 lea	 ecx, DWORD PTR _it$[esp+16460]
  00151	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::const_iterator::_Inc
  00156	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]
  00159	8b 4c 24 10	 mov	 ecx, DWORD PTR _it$[esp+16460]
  0015d	3b c8		 cmp	 ecx, eax
  0015f	0f 85 5c ff ff
	ff		 jne	 $L331010
  00165	5f		 pop	 edi
$L282363:

; 5612 : 		}
; 5613 : 	}
; 5614 : }

  00166	8d 4c 24 24	 lea	 ecx, DWORD PTR _arBlock$[esp+16456]
  0016a	c7 84 24 44 40
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+16464], -1
  00175	e8 00 00 00 00	 call	 ??1CAr@@QAE@XZ		; CAr::~CAr
  0017a	8b 8c 24 3c 40
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+16456]
  00181	5e		 pop	 esi
  00182	5d		 pop	 ebp
  00183	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0018a	8b 8c 24 30 40
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+16448]
  00191	5b		 pop	 ebx
  00192	33 cc		 xor	 ecx, esp
  00194	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00199	81 c4 3c 40 00
	00		 add	 esp, 16444		; 0000403cH
  0019f	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L330847:
  00000	8d 8d dc bf ff
	ff		 lea	 ecx, DWORD PTR _arBlock$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CAr@@QAE@XZ		; CAr::~CAr
__ehhandler$?AddWorldMsg@CUserMng@@QAEXPBVCRect@@PBD@Z:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T331006
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?AddWorldMsg@CUserMng@@QAEXPBVCRect@@PBD@Z ENDP		; CUserMng::AddWorldMsg
PUBLIC	?AddSetScale@CUserMng@@QAEXPAVCMover@@M@Z	; CUserMng::AddSetScale
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
xdata$x	SEGMENT
$T331286 DD	0ffffffffH
	DD	FLAT:$L331023
$T331278 DD	019930520H
	DD	01H
	DD	FLAT:$T331286
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
xdata$x	ENDS
;	COMDAT ?AddSetScale@CUserMng@@QAEXPAVCMover@@M@Z
_TEXT	SEGMENT
_nBufSize$ = -16424					; size = 4
_ar$ = -16420						; size = 16404
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_pMover$ = 8						; size = 4
_fScalePercent$ = 12					; size = 4
?AddSetScale@CUserMng@@QAEXPAVCMover@@M@Z PROC NEAR	; CUserMng::AddSetScale, COMDAT
; _this$ = ecx

; 5622 : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?AddSetScale@CUserMng@@QAEXPAVCMover@@M@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	b8 1c 40 00 00	 mov	 eax, 16412		; 0000401cH
  00013	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0001a	e8 00 00 00 00	 call	 __chkstk
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00024	33 c4		 xor	 eax, esp
  00026	55		 push	 ebp
  00027	56		 push	 esi
  00028	8b b4 24 34 40
	00 00		 mov	 esi, DWORD PTR _pMover$[esp+16428]
  0002f	57		 push	 edi

; 5623 : 	CAr ar;

  00030	6a 00		 push	 0
  00032	6a 00		 push	 0
  00034	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  00038	89 84 24 2c 40
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+16444], eax
  0003f	e8 00 00 00 00	 call	 ??0CAr@@QAE@PAXI@Z	; CAr::CAr

; 5624 : 	
; 5625 : 	ar << GETID( pMover );

  00044	85 f6		 test	 esi, esi
  00046	c7 84 24 30 40
	00 00 00 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+16444], 0
  00051	74 08		 je	 SHORT $L331021
  00053	8b be bc 01 00
	00		 mov	 edi, DWORD PTR [esi+444]
  00059	eb 03		 jmp	 SHORT $L331022
$L331021:
  0005b	83 cf ff	 or	 edi, -1
$L331022:
  0005e	6a 04		 push	 4
  00060	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  00064	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00069	8b 44 24 18	 mov	 eax, DWORD PTR _ar$[esp+16444]
  0006d	89 38		 mov	 DWORD PTR [eax], edi
  0006f	83 44 24 18 04	 add	 DWORD PTR _ar$[esp+16444], 4

; 5626 : 	ar << SNAPSHOTTYPE_SETSCALE;	

  00074	6a 02		 push	 2
  00076	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  0007a	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0007f	8b 4c 24 18	 mov	 ecx, DWORD PTR _ar$[esp+16444]
  00083	66 c7 01 39 00	 mov	 WORD PTR [ecx], 57	; 00000039H
  00088	8b 6c 24 18	 mov	 ebp, DWORD PTR _ar$[esp+16444]
  0008c	83 c5 02	 add	 ebp, 2

; 5627 : 	ar << fScalePercent;

  0008f	6a 04		 push	 4
  00091	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  00095	89 6c 24 1c	 mov	 DWORD PTR _ar$[esp+16448], ebp
  00099	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0009e	d9 84 24 3c 40
	00 00		 fld	 DWORD PTR _fScalePercent$[esp+16432]
  000a5	8b 54 24 18	 mov	 edx, DWORD PTR _ar$[esp+16444]
  000a9	d9 1a		 fstp	 DWORD PTR [edx]
  000ab	8b 54 24 18	 mov	 edx, DWORD PTR _ar$[esp+16444]

; 5628 : 	
; 5629 : 	GETBLOCK( ar, lpBuf, nBufSize );

  000af	8d 44 24 0c	 lea	 eax, DWORD PTR _nBufSize$[esp+16436]
  000b3	83 c2 04	 add	 edx, 4
  000b6	50		 push	 eax
  000b7	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  000bb	89 54 24 1c	 mov	 DWORD PTR _ar$[esp+16448], edx
  000bf	e8 00 00 00 00	 call	 ?GetBuffer@CAr@@QAEPAEPAH@Z ; CAr::GetBuffer

; 5630 : 	
; 5631 : 	FOR_VISIBILITYRANGE( pMover )

  000c4	8b be 10 02 00
	00		 mov	 edi, DWORD PTR [esi+528]
  000ca	8b 37		 mov	 esi, DWORD PTR [edi]
  000cc	3b f7		 cmp	 esi, edi
  000ce	8b e8		 mov	 ebp, eax
  000d0	74 6c		 je	 SHORT $L282400
$L282399:

; 5632 : 		USERPTR->AddBlock( lpBuf, nBufSize );

  000d2	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  000d5	f6 40 04 01	 test	 BYTE PTR [eax+4], 1
  000d9	8b 4c 24 0c	 mov	 ecx, DWORD PTR _nBufSize$[esp+16436]
  000dd	75 14		 jne	 SHORT $L331122
  000df	66 ff 80 0c 57
	00 00		 inc	 WORD PTR [eax+22284]
  000e6	51		 push	 ecx
  000e7	55		 push	 ebp
  000e8	8d 88 f8 16 00
	00		 lea	 ecx, DWORD PTR [eax+5880]
  000ee	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
$L331122:

; 5633 : 	NEXT_VISIBILITYRANGE( pMover )

  000f3	8a 46 15	 mov	 al, BYTE PTR [esi+21]
  000f6	84 c0		 test	 al, al
  000f8	75 40		 jne	 SHORT $L331255
  000fa	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000fd	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00100	84 c9		 test	 cl, cl
  00102	75 19		 jne	 SHORT $L331281
  00104	8b f0		 mov	 esi, eax
  00106	8b 06		 mov	 eax, DWORD PTR [esi]
  00108	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  0010b	84 c9		 test	 cl, cl
  0010d	75 2b		 jne	 SHORT $L331255
  0010f	90		 npad	 1
$L331267:
  00110	8b f0		 mov	 esi, eax
  00112	8b 06		 mov	 eax, DWORD PTR [esi]
  00114	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00117	84 c9		 test	 cl, cl
  00119	74 f5		 je	 SHORT $L331267
  0011b	eb 1d		 jmp	 SHORT $L331255
$L331281:
  0011d	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00120	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00123	84 c9		 test	 cl, cl
  00125	75 11		 jne	 SHORT $L331262
$L331260:
  00127	3b 70 08	 cmp	 esi, DWORD PTR [eax+8]
  0012a	75 0c		 jne	 SHORT $L331262
  0012c	8b f0		 mov	 esi, eax
  0012e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00131	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00134	84 c9		 test	 cl, cl
  00136	74 ef		 je	 SHORT $L331260
$L331262:
  00138	8b f0		 mov	 esi, eax
$L331255:

; 5630 : 	
; 5631 : 	FOR_VISIBILITYRANGE( pMover )

  0013a	3b f7		 cmp	 esi, edi
  0013c	75 94		 jne	 SHORT $L282399
$L282400:

; 5634 : }

  0013e	8d 4c 24 10	 lea	 ecx, DWORD PTR _ar$[esp+16436]
  00142	c7 84 24 30 40
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+16444], -1
  0014d	e8 00 00 00 00	 call	 ??1CAr@@QAE@XZ		; CAr::~CAr
  00152	8b 8c 24 28 40
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+16436]
  00159	5f		 pop	 edi
  0015a	5e		 pop	 esi
  0015b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00162	8b 8c 24 1c 40
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+16428]
  00169	5d		 pop	 ebp
  0016a	33 cc		 xor	 ecx, esp
  0016c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00171	81 c4 28 40 00
	00		 add	 esp, 16424		; 00004028H
  00177	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L331023:
  00000	8d 8d dc bf ff
	ff		 lea	 ecx, DWORD PTR _ar$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CAr@@QAE@XZ		; CAr::~CAr
__ehhandler$?AddSetScale@CUserMng@@QAEXPAVCMover@@M@Z:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T331278
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?AddSetScale@CUserMng@@QAEXPAVCMover@@M@Z ENDP		; CUserMng::AddSetScale
PUBLIC	?AddSetSkillState@CUserMng@@QAEXPAVCMover@@0GGKK@Z ; CUserMng::AddSetSkillState
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
xdata$x	SEGMENT
$T331581 DD	0ffffffffH
	DD	FLAT:$L331295
$T331572 DD	019930520H
	DD	01H
	DD	FLAT:$T331581
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
xdata$x	ENDS
;	COMDAT ?AddSetSkillState@CUserMng@@QAEXPAVCMover@@0GGKK@Z
_TEXT	SEGMENT
_nBufSize$ = -16424					; size = 4
_ar$ = -16420						; size = 16404
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_pCenter$ = 8						; size = 4
_pTarget$ = 12						; size = 4
_wType$ = 16						; size = 2
_wID$ = 20						; size = 2
_dwLevel$ = 24						; size = 4
_dwTime$ = 28						; size = 4
?AddSetSkillState@CUserMng@@QAEXPAVCMover@@0GGKK@Z PROC NEAR ; CUserMng::AddSetSkillState, COMDAT
; _this$ = ecx

; 5639 : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?AddSetSkillState@CUserMng@@QAEXPAVCMover@@0GGKK@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	b8 1c 40 00 00	 mov	 eax, 16412		; 0000401cH
  00013	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0001a	e8 00 00 00 00	 call	 __chkstk
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00024	33 c4		 xor	 eax, esp
  00026	53		 push	 ebx
  00027	55		 push	 ebp
  00028	56		 push	 esi
  00029	57		 push	 edi
  0002a	8b bc 24 3c 40
	00 00		 mov	 edi, DWORD PTR _pCenter$[esp+16436]

; 5640 : 	CAr ar;

  00031	6a 00		 push	 0
  00033	6a 00		 push	 0
  00035	8d 4c 24 1c	 lea	 ecx, DWORD PTR _ar$[esp+16448]
  00039	89 84 24 30 40
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+16448], eax
  00040	e8 00 00 00 00	 call	 ??0CAr@@QAE@PAXI@Z	; CAr::CAr

; 5641 : 	
; 5642 : 	ar << GETID( pCenter );

  00045	85 ff		 test	 edi, edi
  00047	c7 84 24 34 40
	00 00 00 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+16448], 0
  00052	74 08		 je	 SHORT $L331293
  00054	8b b7 bc 01 00
	00		 mov	 esi, DWORD PTR [edi+444]
  0005a	eb 03		 jmp	 SHORT $L331294
$L331293:
  0005c	83 ce ff	 or	 esi, -1
$L331294:
  0005f	bd 04 00 00 00	 mov	 ebp, 4
  00064	55		 push	 ebp
  00065	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  00069	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0006e	8b 44 24 1c	 mov	 eax, DWORD PTR _ar$[esp+16448]
  00072	89 30		 mov	 DWORD PTR [eax], esi
  00074	8b 74 24 1c	 mov	 esi, DWORD PTR _ar$[esp+16448]

; 5643 : 	ar << SNAPSHOTTYPE_SETSKILLSTATE;	

  00078	bb 02 00 00 00	 mov	 ebx, 2
  0007d	03 f5		 add	 esi, ebp
  0007f	53		 push	 ebx
  00080	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  00084	89 74 24 20	 mov	 DWORD PTR _ar$[esp+16452], esi
  00088	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0008d	8b 4c 24 1c	 mov	 ecx, DWORD PTR _ar$[esp+16448]

; 5644 : 	ar << pTarget->GetId() << wType << wID;

  00091	8b 94 24 40 40
	00 00		 mov	 edx, DWORD PTR _pTarget$[esp+16436]
  00098	66 c7 01 4c 00	 mov	 WORD PTR [ecx], 76	; 0000004cH
  0009d	8b 4c 24 1c	 mov	 ecx, DWORD PTR _ar$[esp+16448]
  000a1	8b b2 bc 01 00
	00		 mov	 esi, DWORD PTR [edx+444]
  000a7	03 cb		 add	 ecx, ebx
  000a9	89 4c 24 1c	 mov	 DWORD PTR _ar$[esp+16448], ecx
  000ad	55		 push	 ebp
  000ae	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  000b2	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000b7	8b 44 24 1c	 mov	 eax, DWORD PTR _ar$[esp+16448]
  000bb	89 30		 mov	 DWORD PTR [eax], esi
  000bd	8b 54 24 1c	 mov	 edx, DWORD PTR _ar$[esp+16448]
  000c1	03 d5		 add	 edx, ebp
  000c3	53		 push	 ebx
  000c4	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  000c8	89 54 24 20	 mov	 DWORD PTR _ar$[esp+16452], edx
  000cc	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000d1	8b 4c 24 1c	 mov	 ecx, DWORD PTR _ar$[esp+16448]
  000d5	66 8b b4 24 44
	40 00 00	 mov	 si, WORD PTR _wType$[esp+16436]
  000dd	66 89 31	 mov	 WORD PTR [ecx], si
  000e0	8b 44 24 1c	 mov	 eax, DWORD PTR _ar$[esp+16448]
  000e4	03 c3		 add	 eax, ebx
  000e6	53		 push	 ebx
  000e7	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  000eb	89 44 24 20	 mov	 DWORD PTR _ar$[esp+16452], eax
  000ef	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000f4	8b 54 24 1c	 mov	 edx, DWORD PTR _ar$[esp+16448]
  000f8	66 8b 84 24 48
	40 00 00	 mov	 ax, WORD PTR _wID$[esp+16436]
  00100	66 89 02	 mov	 WORD PTR [edx], ax
  00103	8b 4c 24 1c	 mov	 ecx, DWORD PTR _ar$[esp+16448]
  00107	03 cb		 add	 ecx, ebx

; 5645 : #if __VER >= 11 // __SYS_COLLECTING
; 5646 : 	if( wType == BUFF_ITEM2 )

  00109	66 83 fe 03	 cmp	 si, 3
  0010d	89 4c 24 1c	 mov	 DWORD PTR _ar$[esp+16448], ecx

; 5647 : 	{
; 5648 : 		time_t t	= (time_t)dwLevel - time_null();
; 5649 : 		ar << t;

  00111	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  00115	55		 push	 ebp
  00116	75 1c		 jne	 SHORT $L282412
  00118	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?g_tCurrent@@3JA ; g_tCurrent
  0011e	8b b4 24 50 40
	00 00		 mov	 esi, DWORD PTR _dwLevel$[esp+16440]
  00125	2b f2		 sub	 esi, edx
  00127	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0012c	8b 4c 24 1c	 mov	 ecx, DWORD PTR _ar$[esp+16448]
  00130	89 31		 mov	 DWORD PTR [ecx], esi

; 5650 : 	}
; 5651 : 	else

  00132	eb 12		 jmp	 SHORT $L331580
$L282412:

; 5652 : 		ar << dwLevel;

  00134	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00139	8b 54 24 1c	 mov	 edx, DWORD PTR _ar$[esp+16448]
  0013d	8b 84 24 4c 40
	00 00		 mov	 eax, DWORD PTR _dwLevel$[esp+16436]
  00144	89 02		 mov	 DWORD PTR [edx], eax
$L331580:
  00146	8b 44 24 1c	 mov	 eax, DWORD PTR _ar$[esp+16448]
  0014a	03 c5		 add	 eax, ebp

; 5653 : #else	// __SYS_COLLECTING
; 5654 : 	ar << dwLevel;
; 5655 : #endif	// __SYS_COLLECTING
; 5656 : 	ar << dwTime;

  0014c	55		 push	 ebp
  0014d	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  00151	89 44 24 20	 mov	 DWORD PTR _ar$[esp+16452], eax
  00155	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0015a	8b 4c 24 1c	 mov	 ecx, DWORD PTR _ar$[esp+16448]
  0015e	8b 94 24 50 40
	00 00		 mov	 edx, DWORD PTR _dwTime$[esp+16436]
  00165	89 11		 mov	 DWORD PTR [ecx], edx
  00167	8b 54 24 1c	 mov	 edx, DWORD PTR _ar$[esp+16448]

; 5657 : 	
; 5658 : 	GETBLOCK( ar, lpBuf, nBufSize );

  0016b	8d 44 24 10	 lea	 eax, DWORD PTR _nBufSize$[esp+16440]
  0016f	03 d5		 add	 edx, ebp
  00171	50		 push	 eax
  00172	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  00176	89 54 24 20	 mov	 DWORD PTR _ar$[esp+16452], edx
  0017a	e8 00 00 00 00	 call	 ?GetBuffer@CAr@@QAEPAEPAH@Z ; CAr::GetBuffer

; 5659 : 	
; 5660 : 	FOR_VISIBILITYRANGE( pCenter )

  0017f	8b bf 10 02 00
	00		 mov	 edi, DWORD PTR [edi+528]
  00185	8b 37		 mov	 esi, DWORD PTR [edi]
  00187	3b f7		 cmp	 esi, edi
  00189	8b e8		 mov	 ebp, eax
  0018b	74 71		 je	 SHORT $L282434
  0018d	b3 01		 mov	 bl, 1
  0018f	90		 npad	 1
$L282433:

; 5661 : 		USERPTR->AddBlock( lpBuf, nBufSize );

  00190	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00193	84 58 04	 test	 BYTE PTR [eax+4], bl
  00196	8b 4c 24 10	 mov	 ecx, DWORD PTR _nBufSize$[esp+16440]
  0019a	75 14		 jne	 SHORT $L331413
  0019c	66 ff 80 0c 57
	00 00		 inc	 WORD PTR [eax+22284]
  001a3	51		 push	 ecx
  001a4	55		 push	 ebp
  001a5	8d 88 f8 16 00
	00		 lea	 ecx, DWORD PTR [eax+5880]
  001ab	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
$L331413:

; 5662 : 	NEXT_VISIBILITYRANGE( pCenter )

  001b0	8a 46 15	 mov	 al, BYTE PTR [esi+21]
  001b3	84 c0		 test	 al, al
  001b5	75 43		 jne	 SHORT $L331541
  001b7	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  001ba	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  001bd	84 c9		 test	 cl, cl
  001bf	75 1c		 jne	 SHORT $L331575
  001c1	8b f0		 mov	 esi, eax
  001c3	8b 06		 mov	 eax, DWORD PTR [esi]
  001c5	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  001c8	84 c9		 test	 cl, cl
  001ca	75 2e		 jne	 SHORT $L331541
  001cc	8d 64 24 00	 npad	 4
$L331555:
  001d0	8b f0		 mov	 esi, eax
  001d2	8b 06		 mov	 eax, DWORD PTR [esi]
  001d4	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  001d7	84 c9		 test	 cl, cl
  001d9	74 f5		 je	 SHORT $L331555
  001db	eb 1d		 jmp	 SHORT $L331541
$L331575:
  001dd	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  001e0	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  001e3	84 c9		 test	 cl, cl
  001e5	75 11		 jne	 SHORT $L331544
$L331543:
  001e7	3b 70 08	 cmp	 esi, DWORD PTR [eax+8]
  001ea	75 0c		 jne	 SHORT $L331544
  001ec	8b f0		 mov	 esi, eax
  001ee	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001f1	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  001f4	84 c9		 test	 cl, cl
  001f6	74 ef		 je	 SHORT $L331543
$L331544:
  001f8	8b f0		 mov	 esi, eax
$L331541:

; 5659 : 	
; 5660 : 	FOR_VISIBILITYRANGE( pCenter )

  001fa	3b f7		 cmp	 esi, edi
  001fc	75 92		 jne	 SHORT $L282433
$L282434:

; 5663 : }

  001fe	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  00202	c7 84 24 34 40
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+16448], -1
  0020d	e8 00 00 00 00	 call	 ??1CAr@@QAE@XZ		; CAr::~CAr
  00212	8b 8c 24 2c 40
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+16440]
  00219	5f		 pop	 edi
  0021a	5e		 pop	 esi
  0021b	5d		 pop	 ebp
  0021c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00223	8b 8c 24 1c 40
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+16428]
  0022a	5b		 pop	 ebx
  0022b	33 cc		 xor	 ecx, esp
  0022d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00232	81 c4 28 40 00
	00		 add	 esp, 16424		; 00004028H
  00238	c2 18 00	 ret	 24			; 00000018H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L331295:
  00000	8d 8d dc bf ff
	ff		 lea	 ecx, DWORD PTR _ar$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CAr@@QAE@XZ		; CAr::~CAr
__ehhandler$?AddSetSkillState@CUserMng@@QAEXPAVCMover@@0GGKK@Z:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T331572
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?AddSetSkillState@CUserMng@@QAEXPAVCMover@@0GGKK@Z ENDP	; CUserMng::AddSetSkillState
PUBLIC	?AddMonsterProp@CUserMng@@QAEXXZ		; CUserMng::AddMonsterProp
;	COMDAT xdata$x
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_network\misc\include\ar.h
xdata$x	SEGMENT
$T331682 DD	0ffffffffH
	DD	FLAT:$L331588
$T331675 DD	019930520H
	DD	01H
	DD	FLAT:$T331682
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
xdata$x	ENDS
;	COMDAT ?AddMonsterProp@CUserMng@@QAEXXZ
_TEXT	SEGMENT
_uBufSize$ = -16424					; size = 4
_ar$ = -16420						; size = 16404
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
?AddMonsterProp@CUserMng@@QAEXXZ PROC NEAR		; CUserMng::AddMonsterProp, COMDAT
; _this$ = ecx

; 5667 : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?AddMonsterProp@CUserMng@@QAEXXZ
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	b8 1c 40 00 00	 mov	 eax, 16412		; 0000401cH
  00013	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0001a	e8 00 00 00 00	 call	 __chkstk
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00024	33 c4		 xor	 eax, esp
  00026	53		 push	 ebx
  00027	55		 push	 ebp
  00028	56		 push	 esi
  00029	57		 push	 edi

; 5668 : 	CAr ar;

  0002a	33 ff		 xor	 edi, edi
  0002c	57		 push	 edi
  0002d	8b e9		 mov	 ebp, ecx
  0002f	57		 push	 edi
  00030	8d 4c 24 1c	 lea	 ecx, DWORD PTR _ar$[esp+16448]
  00034	89 84 24 30 40
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+16448], eax
  0003b	e8 00 00 00 00	 call	 ??0CAr@@QAE@PAXI@Z	; CAr::CAr

; 5669 : 	ar << NULL_ID << SNAPSHOTTYPE_MONSTERPROP;

  00040	bb 04 00 00 00	 mov	 ebx, 4
  00045	53		 push	 ebx
  00046	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  0004a	89 bc 24 38 40
	00 00		 mov	 DWORD PTR __$EHRec$[esp+16452], edi
  00051	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00056	8b 44 24 1c	 mov	 eax, DWORD PTR _ar$[esp+16448]
  0005a	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [eax], -1
  00060	01 5c 24 1c	 add	 DWORD PTR _ar$[esp+16448], ebx
  00064	6a 02		 push	 2
  00066	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  0006a	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0006f	8b 4c 24 1c	 mov	 ecx, DWORD PTR _ar$[esp+16448]
  00073	66 c7 01 4e 00	 mov	 WORD PTR [ecx], 78	; 0000004eH
  00078	83 44 24 1c 02	 add	 DWORD PTR _ar$[esp+16448], 2

; 5670 : 
; 5671 : 	ar << prj.m_nAddMonsterPropSize;

  0007d	8b 35 c4 86 11
	00		 mov	 esi, DWORD PTR ?prj@@3VCProject@@A+1148612
  00083	53		 push	 ebx
  00084	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  00088	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0008d	8b 54 24 1c	 mov	 edx, DWORD PTR _ar$[esp+16448]
  00091	89 32		 mov	 DWORD PTR [edx], esi
  00093	8b 4c 24 1c	 mov	 ecx, DWORD PTR _ar$[esp+16448]

; 5672 : 	for( int i = 0 ; i < prj.m_nAddMonsterPropSize ; ++i )

  00097	a1 c4 86 11 00	 mov	 eax, DWORD PTR ?prj@@3VCProject@@A+1148612
  0009c	03 cb		 add	 ecx, ebx
  0009e	3b c7		 cmp	 eax, edi
  000a0	89 4c 24 1c	 mov	 DWORD PTR _ar$[esp+16448], ecx
  000a4	0f 8e d6 00 00
	00		 jle	 $L282443
  000aa	be e4 26 10 00	 mov	 esi, OFFSET FLAT:?prj@@3VCProject@@A+1058532
  000af	90		 npad	 1
$L282441:

; 5673 : 	{
; 5674 : 		ar.WriteString( prj.m_aAddProp[ i ].szMonsterName );

  000b0	8d 46 e0	 lea	 eax, DWORD PTR [esi-32]
  000b3	50		 push	 eax
  000b4	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  000b8	e8 00 00 00 00	 call	 ?WriteString@CAr@@QAEXPBD@Z ; CAr::WriteString

; 5675 : 		ar << prj.m_aAddProp[ i ].nHitPoint;

  000bd	8b 1e		 mov	 ebx, DWORD PTR [esi]
  000bf	6a 04		 push	 4
  000c1	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  000c5	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000ca	8b 4c 24 1c	 mov	 ecx, DWORD PTR _ar$[esp+16448]
  000ce	89 19		 mov	 DWORD PTR [ecx], ebx
  000d0	8b 4c 24 1c	 mov	 ecx, DWORD PTR _ar$[esp+16448]

; 5676 : 		ar << prj.m_aAddProp[ i ].nAttackPower;

  000d4	8b 5e 04	 mov	 ebx, DWORD PTR [esi+4]
  000d7	83 c1 04	 add	 ecx, 4
  000da	89 4c 24 1c	 mov	 DWORD PTR _ar$[esp+16448], ecx
  000de	6a 04		 push	 4
  000e0	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  000e4	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000e9	8b 54 24 1c	 mov	 edx, DWORD PTR _ar$[esp+16448]
  000ed	89 1a		 mov	 DWORD PTR [edx], ebx
  000ef	83 44 24 1c 04	 add	 DWORD PTR _ar$[esp+16448], 4

; 5677 : 		ar << prj.m_aAddProp[ i ].nDefence;

  000f4	8b 5e 08	 mov	 ebx, DWORD PTR [esi+8]
  000f7	6a 04		 push	 4
  000f9	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  000fd	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00102	8b 44 24 1c	 mov	 eax, DWORD PTR _ar$[esp+16448]
  00106	89 18		 mov	 DWORD PTR [eax], ebx
  00108	8b 4c 24 1c	 mov	 ecx, DWORD PTR _ar$[esp+16448]

; 5678 : 		ar << prj.m_aAddProp[ i ].nExp;

  0010c	8b 5e 0c	 mov	 ebx, DWORD PTR [esi+12]
  0010f	83 c1 04	 add	 ecx, 4
  00112	89 4c 24 1c	 mov	 DWORD PTR _ar$[esp+16448], ecx
  00116	6a 04		 push	 4
  00118	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  0011c	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00121	8b 4c 24 1c	 mov	 ecx, DWORD PTR _ar$[esp+16448]
  00125	89 19		 mov	 DWORD PTR [ecx], ebx
  00127	83 44 24 1c 04	 add	 DWORD PTR _ar$[esp+16448], 4

; 5679 : 		ar << prj.m_aAddProp[ i ].nItemDrop;

  0012c	8b 5e 10	 mov	 ebx, DWORD PTR [esi+16]
  0012f	6a 04		 push	 4
  00131	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  00135	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0013a	8b 54 24 1c	 mov	 edx, DWORD PTR _ar$[esp+16448]
  0013e	89 1a		 mov	 DWORD PTR [edx], ebx
  00140	8b 4c 24 1c	 mov	 ecx, DWORD PTR _ar$[esp+16448]

; 5680 : 		ar << prj.m_aAddProp[ i ].nPenya;

  00144	8b 5e 14	 mov	 ebx, DWORD PTR [esi+20]
  00147	83 c1 04	 add	 ecx, 4
  0014a	89 4c 24 1c	 mov	 DWORD PTR _ar$[esp+16448], ecx
  0014e	6a 04		 push	 4
  00150	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  00154	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00159	8b 44 24 1c	 mov	 eax, DWORD PTR _ar$[esp+16448]
  0015d	89 18		 mov	 DWORD PTR [eax], ebx
  0015f	8b 5c 24 1c	 mov	 ebx, DWORD PTR _ar$[esp+16448]
  00163	a1 c4 86 11 00	 mov	 eax, DWORD PTR ?prj@@3VCProject@@A+1148612
  00168	83 c3 04	 add	 ebx, 4
  0016b	47		 inc	 edi
  0016c	83 c6 38	 add	 esi, 56			; 00000038H
  0016f	3b f8		 cmp	 edi, eax
  00171	89 5c 24 1c	 mov	 DWORD PTR _ar$[esp+16448], ebx
  00175	0f 8c 35 ff ff
	ff		 jl	 $L282441

; 5672 : 	for( int i = 0 ; i < prj.m_nAddMonsterPropSize ; ++i )

  0017b	bb 04 00 00 00	 mov	 ebx, 4
$L282443:

; 5681 : 	}
; 5682 : 	
; 5683 : 	ar << prj.m_nRemoveMonsterPropSize;

  00180	8b 35 c8 86 11
	00		 mov	 esi, DWORD PTR ?prj@@3VCProject@@A+1148616
  00186	53		 push	 ebx
  00187	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  0018b	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00190	8b 4c 24 1c	 mov	 ecx, DWORD PTR _ar$[esp+16448]
  00194	89 31		 mov	 DWORD PTR [ecx], esi
  00196	8b 4c 24 1c	 mov	 ecx, DWORD PTR _ar$[esp+16448]

; 5684 : 	for( i = 0 ; i < prj.m_nRemoveMonsterPropSize ; ++i )

  0019a	a1 c8 86 11 00	 mov	 eax, DWORD PTR ?prj@@3VCProject@@A+1148616
  0019f	03 cb		 add	 ecx, ebx
  001a1	33 f6		 xor	 esi, esi
  001a3	85 c0		 test	 eax, eax
  001a5	89 4c 24 1c	 mov	 DWORD PTR _ar$[esp+16448], ecx
  001a9	7e 1c		 jle	 SHORT $L282446

; 5681 : 	}
; 5682 : 	
; 5683 : 	ar << prj.m_nRemoveMonsterPropSize;

  001ab	bf c4 06 11 00	 mov	 edi, OFFSET FLAT:?prj@@3VCProject@@A+1115844
$L282444:

; 5685 : 	{
; 5686 : 		ar.WriteString( prj.m_aRemoveProp[i] );

  001b0	57		 push	 edi
  001b1	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  001b5	e8 00 00 00 00	 call	 ?WriteString@CAr@@QAEXPBD@Z ; CAr::WriteString
  001ba	a1 c8 86 11 00	 mov	 eax, DWORD PTR ?prj@@3VCProject@@A+1148616
  001bf	46		 inc	 esi
  001c0	83 c7 20	 add	 edi, 32			; 00000020H
  001c3	3b f0		 cmp	 esi, eax
  001c5	7c e9		 jl	 SHORT $L282444
$L282446:

; 5687 : 	}
; 5688 : 
; 5689 : 	GETBLOCK( ar, lpBuf, uBufSize );

  001c7	8d 54 24 10	 lea	 edx, DWORD PTR _uBufSize$[esp+16440]
  001cb	52		 push	 edx
  001cc	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  001d0	e8 00 00 00 00	 call	 ?GetBuffer@CAr@@QAEPAEPAH@Z ; CAr::GetBuffer

; 5690 : 	AddBlock( lpBuf, uBufSize );	// all

  001d5	8b 4c 24 10	 mov	 ecx, DWORD PTR _uBufSize$[esp+16440]
  001d9	51		 push	 ecx
  001da	50		 push	 eax
  001db	8b cd		 mov	 ecx, ebp
  001dd	e8 00 00 00 00	 call	 ?AddBlock@CUserMng@@QAEXPAEK@Z ; CUserMng::AddBlock

; 5691 : }

  001e2	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  001e6	c7 84 24 34 40
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+16448], -1
  001f1	e8 00 00 00 00	 call	 ??1CAr@@QAE@XZ		; CAr::~CAr
  001f6	8b 8c 24 2c 40
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+16440]
  001fd	5f		 pop	 edi
  001fe	5e		 pop	 esi
  001ff	5d		 pop	 ebp
  00200	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00207	8b 8c 24 1c 40
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+16428]
  0020e	5b		 pop	 ebx
  0020f	33 cc		 xor	 ecx, esp
  00211	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00216	81 c4 28 40 00
	00		 add	 esp, 16424		; 00004028H
  0021c	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L331588:
  00000	8d 8d dc bf ff
	ff		 lea	 ecx, DWORD PTR _ar$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CAr@@QAE@XZ		; CAr::~CAr
__ehhandler$?AddMonsterProp@CUserMng@@QAEXXZ:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T331675
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?AddMonsterProp@CUserMng@@QAEXXZ ENDP			; CUserMng::AddMonsterProp
PUBLIC	?AddGMChat@CUserMng@@QAEXH@Z			; CUserMng::AddGMChat
;	COMDAT xdata$x
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_network\misc\include\ar.h
xdata$x	SEGMENT
$T331717 DD	0ffffffffH
	DD	FLAT:$L331689
$T331712 DD	019930520H
	DD	01H
	DD	FLAT:$T331717
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
xdata$x	ENDS
;	COMDAT ?AddGMChat@CUserMng@@QAEXH@Z
_TEXT	SEGMENT
_uBufSize$ = -16424					; size = 4
_ar$ = -16420						; size = 16404
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_nSize$ = 8						; size = 4
?AddGMChat@CUserMng@@QAEXH@Z PROC NEAR			; CUserMng::AddGMChat, COMDAT
; _this$ = ecx

; 5694 : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?AddGMChat@CUserMng@@QAEXH@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	b8 1c 40 00 00	 mov	 eax, 16412		; 0000401cH
  00013	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0001a	e8 00 00 00 00	 call	 __chkstk
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00024	33 c4		 xor	 eax, esp
  00026	53		 push	 ebx
  00027	56		 push	 esi

; 5695 : 	CAr ar;

  00028	6a 00		 push	 0
  0002a	8b d9		 mov	 ebx, ecx
  0002c	6a 00		 push	 0
  0002e	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  00032	89 84 24 28 40
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+16440], eax
  00039	e8 00 00 00 00	 call	 ??0CAr@@QAE@PAXI@Z	; CAr::CAr

; 5696 : 	ar << NULL_ID << SNAPSHOTTYPE_GMCHAT;

  0003e	be 04 00 00 00	 mov	 esi, 4
  00043	56		 push	 esi
  00044	8d 4c 24 10	 lea	 ecx, DWORD PTR _ar$[esp+16436]
  00048	c7 84 24 30 40
	00 00 00 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+16444], 0
  00053	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00058	8b 44 24 14	 mov	 eax, DWORD PTR _ar$[esp+16440]
  0005c	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [eax], -1
  00062	8b 54 24 14	 mov	 edx, DWORD PTR _ar$[esp+16440]
  00066	03 d6		 add	 edx, esi
  00068	6a 02		 push	 2
  0006a	8d 4c 24 10	 lea	 ecx, DWORD PTR _ar$[esp+16436]
  0006e	89 54 24 18	 mov	 DWORD PTR _ar$[esp+16444], edx
  00072	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00077	8b 4c 24 14	 mov	 ecx, DWORD PTR _ar$[esp+16440]
  0007b	66 c7 01 4f 00	 mov	 WORD PTR [ecx], 79	; 0000004fH
  00080	8b 44 24 14	 mov	 eax, DWORD PTR _ar$[esp+16440]
  00084	83 c0 02	 add	 eax, 2

; 5697 : 	ar << nSize;

  00087	56		 push	 esi
  00088	8d 4c 24 10	 lea	 ecx, DWORD PTR _ar$[esp+16436]
  0008c	89 44 24 18	 mov	 DWORD PTR _ar$[esp+16444], eax
  00090	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00095	8b 54 24 14	 mov	 edx, DWORD PTR _ar$[esp+16440]
  00099	8b 84 24 34 40
	00 00		 mov	 eax, DWORD PTR _nSize$[esp+16428]
  000a0	89 02		 mov	 DWORD PTR [edx], eax
  000a2	8b 54 24 14	 mov	 edx, DWORD PTR _ar$[esp+16440]
  000a6	03 d6		 add	 edx, esi

; 5698 : 	for( int i = 0 ; i < nSize ; ++i )

  000a8	85 c0		 test	 eax, eax
  000aa	89 54 24 14	 mov	 DWORD PTR _ar$[esp+16440], edx
  000ae	7e 24		 jle	 SHORT $L282458
  000b0	57		 push	 edi

; 5699 : 	{
; 5700 : 		ar.WriteString( prj.m_chGMChat[i] );

  000b1	be d0 86 11 00	 mov	 esi, OFFSET FLAT:?prj@@3VCProject@@A+1148624
  000b6	8b f8		 mov	 edi, eax
  000b8	eb 06 8d 9b 00
	00 00 00	 npad	 8
$L282456:
  000c0	56		 push	 esi
  000c1	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  000c5	e8 00 00 00 00	 call	 ?WriteString@CAr@@QAEXPBD@Z ; CAr::WriteString
  000ca	81 c6 00 01 00
	00		 add	 esi, 256		; 00000100H
  000d0	4f		 dec	 edi
  000d1	75 ed		 jne	 SHORT $L282456
  000d3	5f		 pop	 edi
$L282458:

; 5701 : 	}
; 5702 : 
; 5703 : 	GETBLOCK( ar, lpBuf, uBufSize );

  000d4	8d 44 24 08	 lea	 eax, DWORD PTR _uBufSize$[esp+16432]
  000d8	50		 push	 eax
  000d9	8d 4c 24 10	 lea	 ecx, DWORD PTR _ar$[esp+16436]
  000dd	e8 00 00 00 00	 call	 ?GetBuffer@CAr@@QAEPAEPAH@Z ; CAr::GetBuffer

; 5704 : 	AddBlock( lpBuf, uBufSize );	// all

  000e2	8b 4c 24 08	 mov	 ecx, DWORD PTR _uBufSize$[esp+16432]
  000e6	51		 push	 ecx
  000e7	50		 push	 eax
  000e8	8b cb		 mov	 ecx, ebx
  000ea	e8 00 00 00 00	 call	 ?AddBlock@CUserMng@@QAEXPAEK@Z ; CUserMng::AddBlock

; 5705 : }

  000ef	8d 4c 24 0c	 lea	 ecx, DWORD PTR _ar$[esp+16432]
  000f3	c7 84 24 2c 40
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+16440], -1
  000fe	e8 00 00 00 00	 call	 ??1CAr@@QAE@XZ		; CAr::~CAr
  00103	8b 8c 24 24 40
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+16432]
  0010a	5e		 pop	 esi
  0010b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00112	8b 8c 24 1c 40
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+16428]
  00119	5b		 pop	 ebx
  0011a	33 cc		 xor	 ecx, esp
  0011c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00121	81 c4 28 40 00
	00		 add	 esp, 16424		; 00004028H
  00127	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L331689:
  00000	8d 8d dc bf ff
	ff		 lea	 ecx, DWORD PTR _ar$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CAr@@QAE@XZ		; CAr::~CAr
__ehhandler$?AddGMChat@CUserMng@@QAEXH@Z:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T331712
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?AddGMChat@CUserMng@@QAEXH@Z ENDP			; CUserMng::AddGMChat
PUBLIC	?AddGuildCombatUserState@CUserMng@@QAEXPAVCMover@@@Z ; CUserMng::AddGuildCombatUserState
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
xdata$x	SEGMENT
$T332005 DD	0ffffffffH
	DD	FLAT:$L331726
$T331997 DD	019930520H
	DD	01H
	DD	FLAT:$T332005
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
xdata$x	ENDS
;	COMDAT ?AddGuildCombatUserState@CUserMng@@QAEXPAVCMover@@@Z
_TEXT	SEGMENT
_nBufSize$ = -16424					; size = 4
_ar$ = -16420						; size = 16404
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_pMover$ = 8						; size = 4
?AddGuildCombatUserState@CUserMng@@QAEXPAVCMover@@@Z PROC NEAR ; CUserMng::AddGuildCombatUserState, COMDAT
; _this$ = ecx

; 5709 : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?AddGuildCombatUserState@CUserMng@@QAEXPAVCMover@@@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	b8 1c 40 00 00	 mov	 eax, 16412		; 0000401cH
  00013	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0001a	e8 00 00 00 00	 call	 __chkstk
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00024	33 c4		 xor	 eax, esp
  00026	55		 push	 ebp
  00027	56		 push	 esi
  00028	8b b4 24 34 40
	00 00		 mov	 esi, DWORD PTR _pMover$[esp+16428]
  0002f	57		 push	 edi

; 5710 : 	CAr ar;

  00030	6a 00		 push	 0
  00032	6a 00		 push	 0
  00034	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  00038	89 84 24 2c 40
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+16444], eax
  0003f	e8 00 00 00 00	 call	 ??0CAr@@QAE@PAXI@Z	; CAr::CAr

; 5711 : 	ar << GETID( pMover );

  00044	85 f6		 test	 esi, esi
  00046	c7 84 24 30 40
	00 00 00 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+16444], 0
  00051	74 08		 je	 SHORT $L331724
  00053	8b be bc 01 00
	00		 mov	 edi, DWORD PTR [esi+444]
  00059	eb 03		 jmp	 SHORT $L331725
$L331724:
  0005b	83 cf ff	 or	 edi, -1
$L331725:
  0005e	bd 04 00 00 00	 mov	 ebp, 4
  00063	55		 push	 ebp
  00064	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  00068	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0006d	8b 44 24 18	 mov	 eax, DWORD PTR _ar$[esp+16444]
  00071	89 38		 mov	 DWORD PTR [eax], edi
  00073	8b 7c 24 18	 mov	 edi, DWORD PTR _ar$[esp+16444]
  00077	03 fd		 add	 edi, ebp

; 5712 : 	ar << SNAPSHOTTYPE_GUILDCOMBAT;

  00079	6a 02		 push	 2
  0007b	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  0007f	89 7c 24 1c	 mov	 DWORD PTR _ar$[esp+16448], edi
  00083	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00088	8b 4c 24 18	 mov	 ecx, DWORD PTR _ar$[esp+16444]
  0008c	66 c7 01 b8 00	 mov	 WORD PTR [ecx], 184	; 000000b8H
  00091	83 44 24 18 02	 add	 DWORD PTR _ar$[esp+16444], 2

; 5713 : 	ar << GC_USERSTATE;

  00096	6a 01		 push	 1
  00098	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  0009c	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000a1	8b 54 24 18	 mov	 edx, DWORD PTR _ar$[esp+16444]
  000a5	c6 02 10	 mov	 BYTE PTR [edx], 16	; 00000010H
  000a8	ff 44 24 18	 inc	 DWORD PTR _ar$[esp+16444]

; 5714 : 	ar << pMover->GetId() << pMover->m_nGuildCombatState;

  000ac	8b be bc 01 00
	00		 mov	 edi, DWORD PTR [esi+444]
  000b2	55		 push	 ebp
  000b3	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  000b7	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000bc	8b 44 24 18	 mov	 eax, DWORD PTR _ar$[esp+16444]
  000c0	89 38		 mov	 DWORD PTR [eax], edi
  000c2	8b 4c 24 18	 mov	 ecx, DWORD PTR _ar$[esp+16444]
  000c6	8b be 98 0e 00
	00		 mov	 edi, DWORD PTR [esi+3736]
  000cc	03 cd		 add	 ecx, ebp
  000ce	89 4c 24 18	 mov	 DWORD PTR _ar$[esp+16444], ecx
  000d2	55		 push	 ebp
  000d3	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  000d7	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000dc	8b 4c 24 18	 mov	 ecx, DWORD PTR _ar$[esp+16444]
  000e0	89 39		 mov	 DWORD PTR [ecx], edi
  000e2	01 6c 24 18	 add	 DWORD PTR _ar$[esp+16444], ebp

; 5715 : 	
; 5716 : 	GETBLOCK( ar, lpBuf, nBufSize );

  000e6	8d 54 24 0c	 lea	 edx, DWORD PTR _nBufSize$[esp+16436]
  000ea	52		 push	 edx
  000eb	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  000ef	e8 00 00 00 00	 call	 ?GetBuffer@CAr@@QAEPAEPAH@Z ; CAr::GetBuffer

; 5717 : 
; 5718 : 	FOR_VISIBILITYRANGE( pMover )

  000f4	8b be 10 02 00
	00		 mov	 edi, DWORD PTR [esi+528]
  000fa	8b 37		 mov	 esi, DWORD PTR [edi]
  000fc	3b f7		 cmp	 esi, edi
  000fe	8b e8		 mov	 ebp, eax
  00100	74 6c		 je	 SHORT $L282485
$L282484:

; 5719 : 		USERPTR->AddBlock( lpBuf, nBufSize );

  00102	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00105	f6 40 04 01	 test	 BYTE PTR [eax+4], 1
  00109	8b 4c 24 0c	 mov	 ecx, DWORD PTR _nBufSize$[esp+16436]
  0010d	75 14		 jne	 SHORT $L331841
  0010f	66 ff 80 0c 57
	00 00		 inc	 WORD PTR [eax+22284]
  00116	51		 push	 ecx
  00117	55		 push	 ebp
  00118	8d 88 f8 16 00
	00		 lea	 ecx, DWORD PTR [eax+5880]
  0011e	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
$L331841:

; 5720 : 	NEXT_VISIBILITYRANGE( pMover )

  00123	8a 46 15	 mov	 al, BYTE PTR [esi+21]
  00126	84 c0		 test	 al, al
  00128	75 40		 jne	 SHORT $L331989
  0012a	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0012d	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00130	84 c9		 test	 cl, cl
  00132	75 19		 jne	 SHORT $L332000
  00134	8b f0		 mov	 esi, eax
  00136	8b 06		 mov	 eax, DWORD PTR [esi]
  00138	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  0013b	84 c9		 test	 cl, cl
  0013d	75 2b		 jne	 SHORT $L331989
  0013f	90		 npad	 1
$L331977:
  00140	8b f0		 mov	 esi, eax
  00142	8b 06		 mov	 eax, DWORD PTR [esi]
  00144	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00147	84 c9		 test	 cl, cl
  00149	74 f5		 je	 SHORT $L331977
  0014b	eb 1d		 jmp	 SHORT $L331989
$L332000:
  0014d	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00150	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00153	84 c9		 test	 cl, cl
  00155	75 11		 jne	 SHORT $L331992
$L331991:
  00157	3b 70 08	 cmp	 esi, DWORD PTR [eax+8]
  0015a	75 0c		 jne	 SHORT $L331992
  0015c	8b f0		 mov	 esi, eax
  0015e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00161	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00164	84 c9		 test	 cl, cl
  00166	74 ef		 je	 SHORT $L331991
$L331992:
  00168	8b f0		 mov	 esi, eax
$L331989:

; 5717 : 
; 5718 : 	FOR_VISIBILITYRANGE( pMover )

  0016a	3b f7		 cmp	 esi, edi
  0016c	75 94		 jne	 SHORT $L282484
$L282485:

; 5721 : }

  0016e	8d 4c 24 10	 lea	 ecx, DWORD PTR _ar$[esp+16436]
  00172	c7 84 24 30 40
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+16444], -1
  0017d	e8 00 00 00 00	 call	 ??1CAr@@QAE@XZ		; CAr::~CAr
  00182	8b 8c 24 28 40
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+16436]
  00189	5f		 pop	 edi
  0018a	5e		 pop	 esi
  0018b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00192	8b 8c 24 1c 40
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+16428]
  00199	5d		 pop	 ebp
  0019a	33 cc		 xor	 ecx, esp
  0019c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001a1	81 c4 28 40 00
	00		 add	 esp, 16424		; 00004028H
  001a7	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L331726:
  00000	8d 8d dc bf ff
	ff		 lea	 ecx, DWORD PTR _ar$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CAr@@QAE@XZ		; CAr::~CAr
__ehhandler$?AddGuildCombatUserState@CUserMng@@QAEXPAVCMover@@@Z:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T331997
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?AddGuildCombatUserState@CUserMng@@QAEXPAVCMover@@@Z ENDP ; CUserMng::AddGuildCombatUserState
PUBLIC	?AddGCWinGuild@CUserMng@@QAEXXZ			; CUserMng::AddGCWinGuild
;	COMDAT xdata$x
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_network\misc\include\ar.h
xdata$x	SEGMENT
$T332055 DD	0ffffffffH
	DD	FLAT:$L332012
$T332052 DD	019930520H
	DD	01H
	DD	FLAT:$T332055
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
xdata$x	ENDS
;	COMDAT ?AddGCWinGuild@CUserMng@@QAEXXZ
_TEXT	SEGMENT
_uBufSize$ = -16424					; size = 4
_ar$ = -16420						; size = 16404
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
?AddGCWinGuild@CUserMng@@QAEXXZ PROC NEAR		; CUserMng::AddGCWinGuild, COMDAT
; _this$ = ecx

; 5724 : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?AddGCWinGuild@CUserMng@@QAEXXZ
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	b8 1c 40 00 00	 mov	 eax, 16412		; 0000401cH
  00013	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0001a	e8 00 00 00 00	 call	 __chkstk
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00024	33 c4		 xor	 eax, esp
  00026	53		 push	 ebx
  00027	56		 push	 esi
  00028	57		 push	 edi

; 5725 : 	CAr ar;

  00029	6a 00		 push	 0
  0002b	8b f1		 mov	 esi, ecx
  0002d	6a 00		 push	 0
  0002f	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  00033	89 84 24 2c 40
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+16444], eax
  0003a	e8 00 00 00 00	 call	 ??0CAr@@QAE@PAXI@Z	; CAr::CAr

; 5726 : 	ar << NULL_ID << SNAPSHOTTYPE_GUILDCOMBAT << GC_WINGUILD;

  0003f	bb 04 00 00 00	 mov	 ebx, 4
  00044	53		 push	 ebx
  00045	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  00049	c7 84 24 34 40
	00 00 00 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+16448], 0
  00054	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00059	8b 44 24 18	 mov	 eax, DWORD PTR _ar$[esp+16444]
  0005d	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [eax], -1
  00063	8b 7c 24 18	 mov	 edi, DWORD PTR _ar$[esp+16444]
  00067	03 fb		 add	 edi, ebx
  00069	6a 02		 push	 2
  0006b	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  0006f	89 7c 24 1c	 mov	 DWORD PTR _ar$[esp+16448], edi
  00073	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00078	8b 4c 24 18	 mov	 ecx, DWORD PTR _ar$[esp+16444]
  0007c	66 c7 01 b8 00	 mov	 WORD PTR [ecx], 184	; 000000b8H
  00081	83 44 24 18 02	 add	 DWORD PTR _ar$[esp+16444], 2
  00086	6a 01		 push	 1
  00088	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  0008c	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00091	8b 54 24 18	 mov	 edx, DWORD PTR _ar$[esp+16444]
  00095	c6 02 00	 mov	 BYTE PTR [edx], 0
  00098	ff 44 24 18	 inc	 DWORD PTR _ar$[esp+16444]

; 5727 : 	ar << g_GuildCombatMng.m_nGuildCombatIndex << g_GuildCombatMng.m_uWinGuildId << g_GuildCombatMng.m_nWinGuildCount;

  0009c	8b 3d 40 00 00
	00		 mov	 edi, DWORD PTR ?g_GuildCombatMng@@3VCGuildCombat@@A+64
  000a2	53		 push	 ebx
  000a3	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  000a7	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000ac	8b 44 24 18	 mov	 eax, DWORD PTR _ar$[esp+16444]
  000b0	89 38		 mov	 DWORD PTR [eax], edi
  000b2	8b 4c 24 18	 mov	 ecx, DWORD PTR _ar$[esp+16444]
  000b6	8b 3d 44 00 00
	00		 mov	 edi, DWORD PTR ?g_GuildCombatMng@@3VCGuildCombat@@A+68
  000bc	03 cb		 add	 ecx, ebx
  000be	89 4c 24 18	 mov	 DWORD PTR _ar$[esp+16444], ecx
  000c2	53		 push	 ebx
  000c3	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  000c7	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000cc	8b 4c 24 18	 mov	 ecx, DWORD PTR _ar$[esp+16444]
  000d0	89 39		 mov	 DWORD PTR [ecx], edi
  000d2	8b 54 24 18	 mov	 edx, DWORD PTR _ar$[esp+16444]
  000d6	8b 3d 48 00 00
	00		 mov	 edi, DWORD PTR ?g_GuildCombatMng@@3VCGuildCombat@@A+72
  000dc	03 d3		 add	 edx, ebx
  000de	53		 push	 ebx
  000df	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  000e3	89 54 24 1c	 mov	 DWORD PTR _ar$[esp+16448], edx
  000e7	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000ec	8b 54 24 18	 mov	 edx, DWORD PTR _ar$[esp+16444]
  000f0	89 3a		 mov	 DWORD PTR [edx], edi
  000f2	01 5c 24 18	 add	 DWORD PTR _ar$[esp+16444], ebx

; 5728 : 	
; 5729 : 	GETBLOCK( ar, lpBuf, uBufSize );

  000f6	8d 44 24 0c	 lea	 eax, DWORD PTR _uBufSize$[esp+16436]
  000fa	50		 push	 eax
  000fb	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  000ff	e8 00 00 00 00	 call	 ?GetBuffer@CAr@@QAEPAEPAH@Z ; CAr::GetBuffer

; 5730 : 	AddBlockNoLock( lpBuf, uBufSize );	// all

  00104	8b 4c 24 0c	 mov	 ecx, DWORD PTR _uBufSize$[esp+16436]
  00108	51		 push	 ecx
  00109	50		 push	 eax
  0010a	8b ce		 mov	 ecx, esi
  0010c	e8 00 00 00 00	 call	 ?AddBlockNoLock@CUserMng@@QAEXPAEK@Z ; CUserMng::AddBlockNoLock

; 5731 : }

  00111	8d 4c 24 10	 lea	 ecx, DWORD PTR _ar$[esp+16436]
  00115	c7 84 24 30 40
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+16444], -1
  00120	e8 00 00 00 00	 call	 ??1CAr@@QAE@XZ		; CAr::~CAr
  00125	8b 8c 24 28 40
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+16436]
  0012c	5f		 pop	 edi
  0012d	5e		 pop	 esi
  0012e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00135	8b 8c 24 1c 40
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+16428]
  0013c	5b		 pop	 ebx
  0013d	33 cc		 xor	 ecx, esp
  0013f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00144	81 c4 28 40 00
	00		 add	 esp, 16424		; 00004028H
  0014a	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L332012:
  00000	8d 8d dc bf ff
	ff		 lea	 ecx, DWORD PTR _ar$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CAr@@QAE@XZ		; CAr::~CAr
__ehhandler$?AddGCWinGuild@CUserMng@@QAEXXZ:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T332052
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?AddGCWinGuild@CUserMng@@QAEXXZ ENDP			; CUserMng::AddGCWinGuild
PUBLIC	?AddGCBestPlayer@CUserMng@@QAEXXZ		; CUserMng::AddGCBestPlayer
;	COMDAT xdata$x
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_network\misc\include\ar.h
xdata$x	SEGMENT
$T332087 DD	0ffffffffH
	DD	FLAT:$L332062
$T332084 DD	019930520H
	DD	01H
	DD	FLAT:$T332087
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
xdata$x	ENDS
;	COMDAT ?AddGCBestPlayer@CUserMng@@QAEXXZ
_TEXT	SEGMENT
_uBufSize$ = -16424					; size = 4
_ar$ = -16420						; size = 16404
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
?AddGCBestPlayer@CUserMng@@QAEXXZ PROC NEAR		; CUserMng::AddGCBestPlayer, COMDAT
; _this$ = ecx

; 5733 : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?AddGCBestPlayer@CUserMng@@QAEXXZ
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	b8 1c 40 00 00	 mov	 eax, 16412		; 0000401cH
  00013	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0001a	e8 00 00 00 00	 call	 __chkstk
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00024	33 c4		 xor	 eax, esp
  00026	56		 push	 esi
  00027	57		 push	 edi

; 5734 : 	CAr ar;

  00028	6a 00		 push	 0
  0002a	8b f1		 mov	 esi, ecx
  0002c	89 84 24 24 40
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+16436], eax
  00033	6a 00		 push	 0
  00035	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  00039	e8 00 00 00 00	 call	 ??0CAr@@QAE@PAXI@Z	; CAr::CAr

; 5735 : 	ar << NULL_ID << SNAPSHOTTYPE_GUILDCOMBAT << GC_BESTPLAYER;

  0003e	6a 04		 push	 4
  00040	8d 4c 24 10	 lea	 ecx, DWORD PTR _ar$[esp+16436]
  00044	c7 84 24 30 40
	00 00 00 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+16444], 0
  0004f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00054	8b 44 24 14	 mov	 eax, DWORD PTR _ar$[esp+16440]
  00058	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [eax], -1
  0005e	8b 7c 24 14	 mov	 edi, DWORD PTR _ar$[esp+16440]
  00062	83 c7 04	 add	 edi, 4
  00065	6a 02		 push	 2
  00067	8d 4c 24 10	 lea	 ecx, DWORD PTR _ar$[esp+16436]
  0006b	89 7c 24 18	 mov	 DWORD PTR _ar$[esp+16444], edi
  0006f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00074	8b 4c 24 14	 mov	 ecx, DWORD PTR _ar$[esp+16440]
  00078	66 c7 01 b8 00	 mov	 WORD PTR [ecx], 184	; 000000b8H
  0007d	83 44 24 14 02	 add	 DWORD PTR _ar$[esp+16440], 2
  00082	6a 01		 push	 1
  00084	8d 4c 24 10	 lea	 ecx, DWORD PTR _ar$[esp+16436]
  00088	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0008d	8b 54 24 14	 mov	 edx, DWORD PTR _ar$[esp+16440]
  00091	c6 02 07	 mov	 BYTE PTR [edx], 7
  00094	ff 44 24 14	 inc	 DWORD PTR _ar$[esp+16440]

; 5736 : 	ar << g_GuildCombatMng.m_uBestPlayer;

  00098	8b 3d 4c 00 00
	00		 mov	 edi, DWORD PTR ?g_GuildCombatMng@@3VCGuildCombat@@A+76
  0009e	6a 04		 push	 4
  000a0	8d 4c 24 10	 lea	 ecx, DWORD PTR _ar$[esp+16436]
  000a4	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000a9	8b 44 24 14	 mov	 eax, DWORD PTR _ar$[esp+16440]
  000ad	89 38		 mov	 DWORD PTR [eax], edi
  000af	83 44 24 14 04	 add	 DWORD PTR _ar$[esp+16440], 4

; 5737 : 	
; 5738 : 	GETBLOCK( ar, lpBuf, uBufSize );

  000b4	8d 4c 24 08	 lea	 ecx, DWORD PTR _uBufSize$[esp+16432]
  000b8	51		 push	 ecx
  000b9	8d 4c 24 10	 lea	 ecx, DWORD PTR _ar$[esp+16436]
  000bd	e8 00 00 00 00	 call	 ?GetBuffer@CAr@@QAEPAEPAH@Z ; CAr::GetBuffer

; 5739 : 	AddBlockNoLock( lpBuf, uBufSize );	// all

  000c2	8b 54 24 08	 mov	 edx, DWORD PTR _uBufSize$[esp+16432]
  000c6	52		 push	 edx
  000c7	50		 push	 eax
  000c8	8b ce		 mov	 ecx, esi
  000ca	e8 00 00 00 00	 call	 ?AddBlockNoLock@CUserMng@@QAEXPAEK@Z ; CUserMng::AddBlockNoLock

; 5740 : }

  000cf	8d 4c 24 0c	 lea	 ecx, DWORD PTR _ar$[esp+16432]
  000d3	c7 84 24 2c 40
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+16440], -1
  000de	e8 00 00 00 00	 call	 ??1CAr@@QAE@XZ		; CAr::~CAr
  000e3	8b 8c 24 24 40
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+16432]
  000ea	5f		 pop	 edi
  000eb	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  000f2	8b 8c 24 1c 40
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+16428]
  000f9	5e		 pop	 esi
  000fa	33 cc		 xor	 ecx, esp
  000fc	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00101	81 c4 28 40 00
	00		 add	 esp, 16424		; 00004028H
  00107	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L332062:
  00000	8d 8d dc bf ff
	ff		 lea	 ecx, DWORD PTR _ar$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CAr@@QAE@XZ		; CAr::~CAr
__ehhandler$?AddGCBestPlayer@CUserMng@@QAEXXZ:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T332084
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?AddGCBestPlayer@CUserMng@@QAEXXZ ENDP			; CUserMng::AddGCBestPlayer
PUBLIC	?AddGuildCombatState@CUserMng@@QAEXXZ		; CUserMng::AddGuildCombatState
;	COMDAT xdata$x
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_network\misc\include\ar.h
xdata$x	SEGMENT
$T332133 DD	0ffffffffH
	DD	FLAT:$L332094
$T332130 DD	019930520H
	DD	01H
	DD	FLAT:$T332133
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
xdata$x	ENDS
;	COMDAT ?AddGuildCombatState@CUserMng@@QAEXXZ
_TEXT	SEGMENT
_uBufSize$ = -16424					; size = 4
_ar$ = -16420						; size = 16404
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
?AddGuildCombatState@CUserMng@@QAEXXZ PROC NEAR		; CUserMng::AddGuildCombatState, COMDAT
; _this$ = ecx

; 5743 : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?AddGuildCombatState@CUserMng@@QAEXXZ
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	b8 1c 40 00 00	 mov	 eax, 16412		; 0000401cH
  00013	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0001a	e8 00 00 00 00	 call	 __chkstk
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00024	33 c4		 xor	 eax, esp
  00026	56		 push	 esi
  00027	57		 push	 edi

; 5744 : 	CAr ar;

  00028	6a 00		 push	 0
  0002a	8b f1		 mov	 esi, ecx
  0002c	89 84 24 24 40
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+16436], eax
  00033	6a 00		 push	 0
  00035	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  00039	e8 00 00 00 00	 call	 ??0CAr@@QAE@PAXI@Z	; CAr::CAr

; 5745 : 	ar << NULL_ID << SNAPSHOTTYPE_GUILDCOMBAT;

  0003e	6a 04		 push	 4
  00040	8d 4c 24 10	 lea	 ecx, DWORD PTR _ar$[esp+16436]
  00044	c7 84 24 30 40
	00 00 00 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+16444], 0
  0004f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00054	8b 44 24 14	 mov	 eax, DWORD PTR _ar$[esp+16440]
  00058	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [eax], -1
  0005e	83 44 24 14 04	 add	 DWORD PTR _ar$[esp+16440], 4
  00063	6a 02		 push	 2
  00065	8d 4c 24 10	 lea	 ecx, DWORD PTR _ar$[esp+16436]
  00069	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0006e	8b 4c 24 14	 mov	 ecx, DWORD PTR _ar$[esp+16440]
  00072	66 c7 01 b8 00	 mov	 WORD PTR [ecx], 184	; 000000b8H
  00077	8b 7c 24 14	 mov	 edi, DWORD PTR _ar$[esp+16440]
  0007b	83 c7 02	 add	 edi, 2

; 5746 : 	ar << GC_GCSTATE;

  0007e	6a 01		 push	 1
  00080	8d 4c 24 10	 lea	 ecx, DWORD PTR _ar$[esp+16436]
  00084	89 7c 24 18	 mov	 DWORD PTR _ar$[esp+16444], edi
  00088	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0008d	8b 54 24 14	 mov	 edx, DWORD PTR _ar$[esp+16440]
  00091	c6 02 30	 mov	 BYTE PTR [edx], 48	; 00000030H
  00094	8b 4c 24 14	 mov	 ecx, DWORD PTR _ar$[esp+16440]

; 5747 : 	ar << g_GuildCombatMng.m_nState << g_GuildCombatMng.m_nGCState;

  00098	8b 3d 40 11 00
	00		 mov	 edi, DWORD PTR ?g_GuildCombatMng@@3VCGuildCombat@@A+4416
  0009e	41		 inc	 ecx
  0009f	89 4c 24 14	 mov	 DWORD PTR _ar$[esp+16440], ecx
  000a3	6a 04		 push	 4
  000a5	8d 4c 24 10	 lea	 ecx, DWORD PTR _ar$[esp+16436]
  000a9	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000ae	8b 44 24 14	 mov	 eax, DWORD PTR _ar$[esp+16440]
  000b2	89 38		 mov	 DWORD PTR [eax], edi
  000b4	8b 54 24 14	 mov	 edx, DWORD PTR _ar$[esp+16440]
  000b8	8b 3d 44 11 00
	00		 mov	 edi, DWORD PTR ?g_GuildCombatMng@@3VCGuildCombat@@A+4420
  000be	83 c2 04	 add	 edx, 4
  000c1	6a 04		 push	 4
  000c3	8d 4c 24 10	 lea	 ecx, DWORD PTR _ar$[esp+16436]
  000c7	89 54 24 18	 mov	 DWORD PTR _ar$[esp+16444], edx
  000cb	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000d0	8b 4c 24 14	 mov	 ecx, DWORD PTR _ar$[esp+16440]
  000d4	89 39		 mov	 DWORD PTR [ecx], edi
  000d6	8b 44 24 14	 mov	 eax, DWORD PTR _ar$[esp+16440]

; 5748 : 	
; 5749 : 	GETBLOCK( ar, lpBuf, uBufSize );

  000da	8d 54 24 08	 lea	 edx, DWORD PTR _uBufSize$[esp+16432]
  000de	83 c0 04	 add	 eax, 4
  000e1	52		 push	 edx
  000e2	8d 4c 24 10	 lea	 ecx, DWORD PTR _ar$[esp+16436]
  000e6	89 44 24 18	 mov	 DWORD PTR _ar$[esp+16444], eax
  000ea	e8 00 00 00 00	 call	 ?GetBuffer@CAr@@QAEPAEPAH@Z ; CAr::GetBuffer

; 5750 : 	AddBlockNoLock( lpBuf, uBufSize );	// all

  000ef	8b 4c 24 08	 mov	 ecx, DWORD PTR _uBufSize$[esp+16432]
  000f3	51		 push	 ecx
  000f4	50		 push	 eax
  000f5	8b ce		 mov	 ecx, esi
  000f7	e8 00 00 00 00	 call	 ?AddBlockNoLock@CUserMng@@QAEXPAEK@Z ; CUserMng::AddBlockNoLock

; 5751 : }

  000fc	8d 4c 24 0c	 lea	 ecx, DWORD PTR _ar$[esp+16432]
  00100	c7 84 24 2c 40
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+16440], -1
  0010b	e8 00 00 00 00	 call	 ??1CAr@@QAE@XZ		; CAr::~CAr
  00110	8b 8c 24 24 40
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+16432]
  00117	5f		 pop	 edi
  00118	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0011f	8b 8c 24 1c 40
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+16428]
  00126	5e		 pop	 esi
  00127	33 cc		 xor	 ecx, esp
  00129	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0012e	81 c4 28 40 00
	00		 add	 esp, 16424		; 00004028H
  00134	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L332094:
  00000	8d 8d dc bf ff
	ff		 lea	 ecx, DWORD PTR _ar$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CAr@@QAE@XZ		; CAr::~CAr
__ehhandler$?AddGuildCombatState@CUserMng@@QAEXXZ:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T332130
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?AddGuildCombatState@CUserMng@@QAEXXZ ENDP		; CUserMng::AddGuildCombatState
PUBLIC	?AddGuildCombatNextTimeWorld@CUserMng@@QAEXKK@Z	; CUserMng::AddGuildCombatNextTimeWorld
;	COMDAT xdata$x
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\obj.h
xdata$x	SEGMENT
$T332284 DD	0ffffffffH
	DD	FLAT:$L332142
$T332280 DD	019930520H
	DD	01H
	DD	FLAT:$T332284
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
xdata$x	ENDS
;	COMDAT ?AddGuildCombatNextTimeWorld@CUserMng@@QAEXKK@Z
_TEXT	SEGMENT
_it$ = -16428						; size = 4
_uBlockSize$ = -16424					; size = 4
_arBlock$ = -16420					; size = 16404
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_dwTime$ = 8						; size = 4
_dwState$ = 12						; size = 4
?AddGuildCombatNextTimeWorld@CUserMng@@QAEXKK@Z PROC NEAR ; CUserMng::AddGuildCombatNextTimeWorld, COMDAT
; _this$ = ecx

; 5754 : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?AddGuildCombatNextTimeWorld@CUserMng@@QAEXKK@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	b8 20 40 00 00	 mov	 eax, 16416		; 00004020H
  00013	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0001a	e8 00 00 00 00	 call	 __chkstk
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00024	33 c4		 xor	 eax, esp
  00026	56		 push	 esi
  00027	57		 push	 edi

; 5755 : 	CAr arBlock;

  00028	6a 00		 push	 0
  0002a	8b f1		 mov	 esi, ecx
  0002c	6a 00		 push	 0
  0002e	8d 4c 24 18	 lea	 ecx, DWORD PTR _arBlock$[esp+16444]
  00032	89 84 24 2c 40
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+16444], eax
  00039	e8 00 00 00 00	 call	 ??0CAr@@QAE@PAXI@Z	; CAr::CAr

; 5756 : 	arBlock << NULL_ID << SNAPSHOTTYPE_GUILDCOMBAT;

  0003e	bf 04 00 00 00	 mov	 edi, 4
  00043	57		 push	 edi
  00044	8d 4c 24 14	 lea	 ecx, DWORD PTR _arBlock$[esp+16440]
  00048	c7 84 24 34 40
	00 00 00 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+16448], 0
  00053	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00058	8b 44 24 18	 mov	 eax, DWORD PTR _arBlock$[esp+16444]
  0005c	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [eax], -1
  00062	8b 54 24 18	 mov	 edx, DWORD PTR _arBlock$[esp+16444]
  00066	03 d7		 add	 edx, edi
  00068	6a 02		 push	 2
  0006a	8d 4c 24 14	 lea	 ecx, DWORD PTR _arBlock$[esp+16440]
  0006e	89 54 24 1c	 mov	 DWORD PTR _arBlock$[esp+16448], edx
  00072	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00077	8b 4c 24 18	 mov	 ecx, DWORD PTR _arBlock$[esp+16444]
  0007b	66 c7 01 b8 00	 mov	 WORD PTR [ecx], 184	; 000000b8H
  00080	8b 44 24 18	 mov	 eax, DWORD PTR _arBlock$[esp+16444]
  00084	83 c0 02	 add	 eax, 2

; 5757 : 	arBlock << GC_NEXTTIMESTATE;

  00087	6a 01		 push	 1
  00089	8d 4c 24 14	 lea	 ecx, DWORD PTR _arBlock$[esp+16440]
  0008d	89 44 24 1c	 mov	 DWORD PTR _arBlock$[esp+16448], eax
  00091	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00096	8b 54 24 18	 mov	 edx, DWORD PTR _arBlock$[esp+16444]
  0009a	c6 02 31	 mov	 BYTE PTR [edx], 49	; 00000031H
  0009d	ff 44 24 18	 inc	 DWORD PTR _arBlock$[esp+16444]

; 5758 : 	arBlock << dwTime << dwState;

  000a1	57		 push	 edi
  000a2	8d 4c 24 14	 lea	 ecx, DWORD PTR _arBlock$[esp+16440]
  000a6	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000ab	8b 44 24 18	 mov	 eax, DWORD PTR _arBlock$[esp+16444]
  000af	8b 8c 24 38 40
	00 00		 mov	 ecx, DWORD PTR _dwTime$[esp+16432]
  000b6	89 08		 mov	 DWORD PTR [eax], ecx
  000b8	8b 54 24 18	 mov	 edx, DWORD PTR _arBlock$[esp+16444]
  000bc	03 d7		 add	 edx, edi
  000be	57		 push	 edi
  000bf	8d 4c 24 14	 lea	 ecx, DWORD PTR _arBlock$[esp+16440]
  000c3	89 54 24 1c	 mov	 DWORD PTR _arBlock$[esp+16448], edx
  000c7	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000cc	8b 54 24 18	 mov	 edx, DWORD PTR _arBlock$[esp+16444]
  000d0	8b 84 24 3c 40
	00 00		 mov	 eax, DWORD PTR _dwState$[esp+16432]
  000d7	89 02		 mov	 DWORD PTR [edx], eax
  000d9	8b 44 24 18	 mov	 eax, DWORD PTR _arBlock$[esp+16444]

; 5759 : 	GETBLOCK( arBlock, lpBlock, uBlockSize );

  000dd	8d 4c 24 0c	 lea	 ecx, DWORD PTR _uBlockSize$[esp+16436]
  000e1	03 c7		 add	 eax, edi
  000e3	51		 push	 ecx
  000e4	8d 4c 24 14	 lea	 ecx, DWORD PTR _arBlock$[esp+16440]
  000e8	89 44 24 1c	 mov	 DWORD PTR _arBlock$[esp+16448], eax
  000ec	e8 00 00 00 00	 call	 ?GetBuffer@CAr@@QAEPAEPAH@Z ; CAr::GetBuffer
  000f1	8b f8		 mov	 edi, eax

; 5760 : 	
; 5761 : 	map<DWORD, CUser*>::iterator it;
; 5762 : 	for( it = m_users.begin(); it != m_users.end(); ++it )

  000f3	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  000f6	8b 08		 mov	 ecx, DWORD PTR [eax]
  000f8	3b c8		 cmp	 ecx, eax
  000fa	89 4c 24 08	 mov	 DWORD PTR _it$[esp+16436], ecx
  000fe	74 3f		 je	 SHORT $L282529
$L332208:

; 5763 : 	{
; 5764 : 		CUser* pUser = it->second;

  00100	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]

; 5765 : 		if( pUser->IsValid() == FALSE )

  00103	f6 40 04 01	 test	 BYTE PTR [eax+4], 1
  00107	75 22		 jne	 SHORT $L282528
  00109	8b 88 e8 16 00
	00		 mov	 ecx, DWORD PTR [eax+5864]
  0010f	85 c9		 test	 ecx, ecx
  00111	74 18		 je	 SHORT $L282528

; 5766 : 			continue;
; 5767 : 		
; 5768 : 		pUser->AddBlock( lpBlock, uBlockSize );

  00113	8b 4c 24 0c	 mov	 ecx, DWORD PTR _uBlockSize$[esp+16436]
  00117	66 ff 80 0c 57
	00 00		 inc	 WORD PTR [eax+22284]
  0011e	51		 push	 ecx
  0011f	57		 push	 edi
  00120	8d 88 f8 16 00
	00		 lea	 ecx, DWORD PTR [eax+5880]
  00126	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
$L282528:
  0012b	8d 4c 24 08	 lea	 ecx, DWORD PTR _it$[esp+16436]
  0012f	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::const_iterator::_Inc
  00134	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00137	8b 4c 24 08	 mov	 ecx, DWORD PTR _it$[esp+16436]
  0013b	3b c8		 cmp	 ecx, eax
  0013d	75 c1		 jne	 SHORT $L332208
$L282529:

; 5769 : 	}
; 5770 : }

  0013f	8d 4c 24 10	 lea	 ecx, DWORD PTR _arBlock$[esp+16436]
  00143	c7 84 24 30 40
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+16444], -1
  0014e	e8 00 00 00 00	 call	 ??1CAr@@QAE@XZ		; CAr::~CAr
  00153	8b 8c 24 28 40
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+16436]
  0015a	5f		 pop	 edi
  0015b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00162	8b 8c 24 20 40
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+16432]
  00169	5e		 pop	 esi
  0016a	33 cc		 xor	 ecx, esp
  0016c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00171	81 c4 2c 40 00
	00		 add	 esp, 16428		; 0000402cH
  00177	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L332142:
  00000	8d 8d dc bf ff
	ff		 lea	 ecx, DWORD PTR _arBlock$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CAr@@QAE@XZ		; CAr::~CAr
__ehhandler$?AddGuildCombatNextTimeWorld@CUserMng@@QAEXKK@Z:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T332280
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?AddGuildCombatNextTimeWorld@CUserMng@@QAEXKK@Z ENDP	; CUserMng::AddGuildCombatNextTimeWorld
PUBLIC	?AddGuildCombatEnterTime@CUserMng@@QAEXK@Z	; CUserMng::AddGuildCombatEnterTime
;	COMDAT xdata$x
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\obj.h
xdata$x	SEGMENT
$T332432 DD	0ffffffffH
	DD	FLAT:$L332293
$T332428 DD	019930520H
	DD	01H
	DD	FLAT:$T332432
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
xdata$x	ENDS
;	COMDAT ?AddGuildCombatEnterTime@CUserMng@@QAEXK@Z
_TEXT	SEGMENT
_it$ = -16428						; size = 4
_uBlockSize$ = -16424					; size = 4
_arBlock$ = -16420					; size = 16404
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_dwTime$ = 8						; size = 4
?AddGuildCombatEnterTime@CUserMng@@QAEXK@Z PROC NEAR	; CUserMng::AddGuildCombatEnterTime, COMDAT
; _this$ = ecx

; 5772 : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?AddGuildCombatEnterTime@CUserMng@@QAEXK@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	b8 20 40 00 00	 mov	 eax, 16416		; 00004020H
  00013	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0001a	e8 00 00 00 00	 call	 __chkstk
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00024	33 c4		 xor	 eax, esp
  00026	56		 push	 esi
  00027	57		 push	 edi

; 5773 : 	CAr arBlock;

  00028	6a 00		 push	 0
  0002a	8b f1		 mov	 esi, ecx
  0002c	6a 00		 push	 0
  0002e	8d 4c 24 18	 lea	 ecx, DWORD PTR _arBlock$[esp+16444]
  00032	89 84 24 2c 40
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+16444], eax
  00039	e8 00 00 00 00	 call	 ??0CAr@@QAE@PAXI@Z	; CAr::CAr

; 5774 : 	arBlock << NULL_ID << SNAPSHOTTYPE_GUILDCOMBAT;

  0003e	bf 04 00 00 00	 mov	 edi, 4
  00043	57		 push	 edi
  00044	8d 4c 24 14	 lea	 ecx, DWORD PTR _arBlock$[esp+16440]
  00048	c7 84 24 34 40
	00 00 00 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+16448], 0
  00053	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00058	8b 44 24 18	 mov	 eax, DWORD PTR _arBlock$[esp+16444]
  0005c	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [eax], -1
  00062	8b 44 24 18	 mov	 eax, DWORD PTR _arBlock$[esp+16444]
  00066	03 c7		 add	 eax, edi
  00068	6a 02		 push	 2
  0006a	8d 4c 24 14	 lea	 ecx, DWORD PTR _arBlock$[esp+16440]
  0006e	89 44 24 1c	 mov	 DWORD PTR _arBlock$[esp+16448], eax
  00072	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00077	8b 4c 24 18	 mov	 ecx, DWORD PTR _arBlock$[esp+16444]
  0007b	66 c7 01 b8 00	 mov	 WORD PTR [ecx], 184	; 000000b8H
  00080	83 44 24 18 02	 add	 DWORD PTR _arBlock$[esp+16444], 2

; 5775 : 	arBlock << GC_ENTERTIME;

  00085	6a 01		 push	 1
  00087	8d 4c 24 14	 lea	 ecx, DWORD PTR _arBlock$[esp+16440]
  0008b	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00090	8b 54 24 18	 mov	 edx, DWORD PTR _arBlock$[esp+16444]
  00094	c6 02 32	 mov	 BYTE PTR [edx], 50	; 00000032H
  00097	8b 54 24 18	 mov	 edx, DWORD PTR _arBlock$[esp+16444]
  0009b	42		 inc	 edx

; 5776 : 	arBlock << dwTime ;

  0009c	57		 push	 edi
  0009d	8d 4c 24 14	 lea	 ecx, DWORD PTR _arBlock$[esp+16440]
  000a1	89 54 24 1c	 mov	 DWORD PTR _arBlock$[esp+16448], edx
  000a5	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000aa	8b 44 24 18	 mov	 eax, DWORD PTR _arBlock$[esp+16444]
  000ae	8b 8c 24 38 40
	00 00		 mov	 ecx, DWORD PTR _dwTime$[esp+16432]
  000b5	89 08		 mov	 DWORD PTR [eax], ecx
  000b7	8b 44 24 18	 mov	 eax, DWORD PTR _arBlock$[esp+16444]

; 5777 : 	GETBLOCK( arBlock, lpBlock, uBlockSize );

  000bb	8d 54 24 0c	 lea	 edx, DWORD PTR _uBlockSize$[esp+16436]
  000bf	03 c7		 add	 eax, edi
  000c1	52		 push	 edx
  000c2	8d 4c 24 14	 lea	 ecx, DWORD PTR _arBlock$[esp+16440]
  000c6	89 44 24 1c	 mov	 DWORD PTR _arBlock$[esp+16448], eax
  000ca	e8 00 00 00 00	 call	 ?GetBuffer@CAr@@QAEPAEPAH@Z ; CAr::GetBuffer
  000cf	8b f8		 mov	 edi, eax

; 5778 : 	
; 5779 : 	map<DWORD, CUser*>::iterator it;
; 5780 : 	for( it = m_users.begin(); it != m_users.end(); ++it )

  000d1	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  000d4	8b 08		 mov	 ecx, DWORD PTR [eax]
  000d6	3b c8		 cmp	 ecx, eax
  000d8	89 4c 24 08	 mov	 DWORD PTR _it$[esp+16436], ecx
  000dc	74 41		 je	 SHORT $L282550
  000de	8b ff		 npad	 2
$L332353:

; 5781 : 	{
; 5782 : 		CUser* pUser = it->second;

  000e0	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]

; 5783 : 		if( pUser->IsValid() == FALSE )

  000e3	f6 40 04 01	 test	 BYTE PTR [eax+4], 1
  000e7	75 22		 jne	 SHORT $L282549
  000e9	8b 88 e8 16 00
	00		 mov	 ecx, DWORD PTR [eax+5864]
  000ef	85 c9		 test	 ecx, ecx
  000f1	74 18		 je	 SHORT $L282549

; 5784 : 			continue;
; 5785 : 
; 5786 : 		pUser->AddBlock( lpBlock, uBlockSize );

  000f3	8b 4c 24 0c	 mov	 ecx, DWORD PTR _uBlockSize$[esp+16436]
  000f7	66 ff 80 0c 57
	00 00		 inc	 WORD PTR [eax+22284]
  000fe	51		 push	 ecx
  000ff	57		 push	 edi
  00100	8d 88 f8 16 00
	00		 lea	 ecx, DWORD PTR [eax+5880]
  00106	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
$L282549:
  0010b	8d 4c 24 08	 lea	 ecx, DWORD PTR _it$[esp+16436]
  0010f	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::const_iterator::_Inc
  00114	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00117	8b 4c 24 08	 mov	 ecx, DWORD PTR _it$[esp+16436]
  0011b	3b c8		 cmp	 ecx, eax
  0011d	75 c1		 jne	 SHORT $L332353
$L282550:

; 5787 : 	}
; 5788 : }

  0011f	8d 4c 24 10	 lea	 ecx, DWORD PTR _arBlock$[esp+16436]
  00123	c7 84 24 30 40
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+16444], -1
  0012e	e8 00 00 00 00	 call	 ??1CAr@@QAE@XZ		; CAr::~CAr
  00133	8b 8c 24 28 40
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+16436]
  0013a	5f		 pop	 edi
  0013b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00142	8b 8c 24 20 40
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+16432]
  00149	5e		 pop	 esi
  0014a	33 cc		 xor	 ecx, esp
  0014c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00151	81 c4 2c 40 00
	00		 add	 esp, 16428		; 0000402cH
  00157	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L332293:
  00000	8d 8d dc bf ff
	ff		 lea	 ecx, DWORD PTR _arBlock$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CAr@@QAE@XZ		; CAr::~CAr
__ehhandler$?AddGuildCombatEnterTime@CUserMng@@QAEXK@Z:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T332428
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?AddGuildCombatEnterTime@CUserMng@@QAEXK@Z ENDP		; CUserMng::AddGuildCombatEnterTime
PUBLIC	?AddGCWarPlayerlist@CUserMng@@QAEXKPAVCUser@@@Z	; CUserMng::AddGCWarPlayerlist
;	COMDAT xdata$x
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\obj.h
xdata$x	SEGMENT
$T332608 DD	0ffffffffH
	DD	FLAT:$L332441
$T332602 DD	019930520H
	DD	01H
	DD	FLAT:$T332608
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
xdata$x	ENDS
;	COMDAT ?AddGCWarPlayerlist@CUserMng@@QAEXKPAVCUser@@@Z
_TEXT	SEGMENT
_uBlockSize$ = -16428					; size = 4
_it$282568 = -16424					; size = 4
_arBlock$ = -16420					; size = 16404
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_uidGuild$ = 8						; size = 4
_pSendUser$ = 12					; size = 4
?AddGCWarPlayerlist@CUserMng@@QAEXKPAVCUser@@@Z PROC NEAR ; CUserMng::AddGCWarPlayerlist, COMDAT
; _this$ = ecx

; 5791 : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?AddGCWarPlayerlist@CUserMng@@QAEXKPAVCUser@@@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	b8 20 40 00 00	 mov	 eax, 16416		; 00004020H
  00013	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0001a	e8 00 00 00 00	 call	 __chkstk
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00024	33 c4		 xor	 eax, esp
  00026	55		 push	 ebp
  00027	56		 push	 esi
  00028	8b b4 24 3c 40
	00 00		 mov	 esi, DWORD PTR _pSendUser$[esp+16432]
  0002f	57		 push	 edi

; 5792 : 	CAr arBlock;

  00030	6a 00		 push	 0
  00032	8b e9		 mov	 ebp, ecx
  00034	6a 00		 push	 0
  00036	8d 4c 24 1c	 lea	 ecx, DWORD PTR _arBlock$[esp+16448]
  0003a	89 84 24 30 40
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+16448], eax
  00041	e8 00 00 00 00	 call	 ??0CAr@@QAE@PAXI@Z	; CAr::CAr

; 5793 : 	arBlock << NULL_ID << SNAPSHOTTYPE_GUILDCOMBAT;

  00046	6a 04		 push	 4
  00048	8d 4c 24 18	 lea	 ecx, DWORD PTR _arBlock$[esp+16444]
  0004c	c7 84 24 38 40
	00 00 00 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+16452], 0
  00057	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0005c	8b 44 24 1c	 mov	 eax, DWORD PTR _arBlock$[esp+16448]
  00060	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [eax], -1
  00066	8b 44 24 1c	 mov	 eax, DWORD PTR _arBlock$[esp+16448]
  0006a	83 c0 04	 add	 eax, 4
  0006d	6a 02		 push	 2
  0006f	8d 4c 24 18	 lea	 ecx, DWORD PTR _arBlock$[esp+16444]
  00073	89 44 24 20	 mov	 DWORD PTR _arBlock$[esp+16452], eax
  00077	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0007c	8b 4c 24 1c	 mov	 ecx, DWORD PTR _arBlock$[esp+16448]
  00080	66 c7 01 b8 00	 mov	 WORD PTR [ecx], 184	; 000000b8H
  00085	8b 54 24 1c	 mov	 edx, DWORD PTR _arBlock$[esp+16448]
  00089	83 c2 02	 add	 edx, 2

; 5794 : 	arBlock << GC_WARPLAYERLIST;

  0008c	6a 01		 push	 1
  0008e	8d 4c 24 18	 lea	 ecx, DWORD PTR _arBlock$[esp+16444]
  00092	89 54 24 20	 mov	 DWORD PTR _arBlock$[esp+16452], edx
  00096	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0009b	8b 54 24 1c	 mov	 edx, DWORD PTR _arBlock$[esp+16448]
  0009f	c6 02 11	 mov	 BYTE PTR [edx], 17	; 00000011H
  000a2	ff 44 24 1c	 inc	 DWORD PTR _arBlock$[esp+16448]

; 5795 : 	g_GuildCombatMng.SerializeGCWarPlayerList( arBlock );

  000a6	8d 44 24 14	 lea	 eax, DWORD PTR _arBlock$[esp+16440]
  000aa	50		 push	 eax
  000ab	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_GuildCombatMng@@3VCGuildCombat@@A
  000b0	e8 00 00 00 00	 call	 ?SerializeGCWarPlayerList@CGuildCombat@@QAEXAAVCAr@@@Z ; CGuildCombat::SerializeGCWarPlayerList

; 5796 : 	GETBLOCK( arBlock, lpBlock, uBlockSize );

  000b5	8d 4c 24 0c	 lea	 ecx, DWORD PTR _uBlockSize$[esp+16440]
  000b9	51		 push	 ecx
  000ba	8d 4c 24 18	 lea	 ecx, DWORD PTR _arBlock$[esp+16444]
  000be	e8 00 00 00 00	 call	 ?GetBuffer@CAr@@QAEPAEPAH@Z ; CAr::GetBuffer

; 5797 : 	
; 5798 : 	if( pSendUser == NULL )

  000c3	85 f6		 test	 esi, esi
  000c5	8b f8		 mov	 edi, eax
  000c7	75 73		 jne	 SHORT $L282562

; 5799 : 	{
; 5800 : 		map<DWORD, CUser*>::iterator it;
; 5801 : 		for( it = m_users.begin(); it != m_users.end(); ++it )

  000c9	8b 4d 0c	 mov	 ecx, DWORD PTR [ebp+12]
  000cc	8b 01		 mov	 eax, DWORD PTR [ecx]
  000ce	3b c1		 cmp	 eax, ecx
  000d0	89 44 24 10	 mov	 DWORD PTR _it$282568[esp+16440], eax
  000d4	0f 84 80 00 00
	00		 je	 $L332593
  000da	8b b4 24 3c 40
	00 00		 mov	 esi, DWORD PTR _uidGuild$[esp+16436]
$L332604:

; 5802 : 		{
; 5803 : 			CUser* pUser = it->second;

  000e1	8b 40 10	 mov	 eax, DWORD PTR [eax+16]

; 5804 : 			if( pUser->IsValid() == FALSE )

  000e4	f6 40 04 01	 test	 BYTE PTR [eax+4], 1
  000e8	75 3c		 jne	 SHORT $L282572
  000ea	8b 88 e8 16 00
	00		 mov	 ecx, DWORD PTR [eax+5864]
  000f0	85 c9		 test	 ecx, ecx
  000f2	74 32		 je	 SHORT $L282572

; 5805 : 				continue;
; 5806 : 			
; 5807 : 			if( uidGuild )

  000f4	85 f6		 test	 esi, esi
  000f6	74 08		 je	 SHORT $L282576

; 5808 : 			{
; 5809 : 				if( uidGuild == pUser->m_idGuild )

  000f8	3b b0 1c 07 00
	00		 cmp	 esi, DWORD PTR [eax+1820]

; 5810 : 				{
; 5811 : 					pUser->AddBlock( lpBlock, uBlockSize );
; 5812 : 				}			
; 5813 : 			}
; 5814 : 			else if( pUser->GetWorld()->GetID() == WI_WORLD_GUILDWAR )

  000fe	eb 0c		 jmp	 SHORT $L332607
$L282576:
  00100	8b 88 6c 01 00
	00		 mov	 ecx, DWORD PTR [eax+364]
  00106	81 39 ca 00 00
	00		 cmp	 DWORD PTR [ecx], 202	; 000000caH
$L332607:
  0010c	75 18		 jne	 SHORT $L282572

; 5815 : 			{
; 5816 : 				pUser->AddBlock( lpBlock, uBlockSize );

  0010e	8b 4c 24 0c	 mov	 ecx, DWORD PTR _uBlockSize$[esp+16440]
  00112	66 ff 80 0c 57
	00 00		 inc	 WORD PTR [eax+22284]
  00119	51		 push	 ecx
  0011a	8d 88 f8 16 00
	00		 lea	 ecx, DWORD PTR [eax+5880]
  00120	57		 push	 edi
  00121	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
$L282572:
  00126	8d 4c 24 10	 lea	 ecx, DWORD PTR _it$282568[esp+16440]
  0012a	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::const_iterator::_Inc
  0012f	8b 4d 0c	 mov	 ecx, DWORD PTR [ebp+12]
  00132	8b 44 24 10	 mov	 eax, DWORD PTR _it$282568[esp+16440]
  00136	3b c1		 cmp	 eax, ecx
  00138	75 a7		 jne	 SHORT $L332604

; 5817 : 			}
; 5818 : 		}
; 5819 : 	}
; 5820 : 	else

  0013a	eb 1e		 jmp	 SHORT $L332593
$L282562:

; 5821 : 	{
; 5822 : 		pSendUser->AddBlock( lpBlock, uBlockSize );

  0013c	f6 46 04 01	 test	 BYTE PTR [esi+4], 1
  00140	75 18		 jne	 SHORT $L332593
  00142	8b 54 24 0c	 mov	 edx, DWORD PTR _uBlockSize$[esp+16440]
  00146	66 ff 86 0c 57
	00 00		 inc	 WORD PTR [esi+22284]
  0014d	52		 push	 edx
  0014e	57		 push	 edi
  0014f	8d 8e f8 16 00
	00		 lea	 ecx, DWORD PTR [esi+5880]
  00155	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
$L332593:

; 5823 : 	}
; 5824 : }

  0015a	8d 4c 24 14	 lea	 ecx, DWORD PTR _arBlock$[esp+16440]
  0015e	c7 84 24 34 40
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+16448], -1
  00169	e8 00 00 00 00	 call	 ??1CAr@@QAE@XZ		; CAr::~CAr
  0016e	8b 8c 24 2c 40
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+16440]
  00175	5f		 pop	 edi
  00176	5e		 pop	 esi
  00177	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0017e	8b 8c 24 20 40
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+16432]
  00185	5d		 pop	 ebp
  00186	33 cc		 xor	 ecx, esp
  00188	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0018d	81 c4 2c 40 00
	00		 add	 esp, 16428		; 0000402cH
  00193	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L332441:
  00000	8d 8d dc bf ff
	ff		 lea	 ecx, DWORD PTR _arBlock$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CAr@@QAE@XZ		; CAr::~CAr
__ehhandler$?AddGCWarPlayerlist@CUserMng@@QAEXKPAVCUser@@@Z:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T332602
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?AddGCWarPlayerlist@CUserMng@@QAEXKPAVCUser@@@Z ENDP	; CUserMng::AddGCWarPlayerlist
PUBLIC	?AddGCLogRealTimeWorld@CUserMng@@QAEXU__GCGETPOINT@CGuildCombat@@@Z ; CUserMng::AddGCLogRealTimeWorld
;	COMDAT xdata$x
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\obj.h
xdata$x	SEGMENT
$T332813 DD	0ffffffffH
	DD	FLAT:$L332617
$T332809 DD	019930520H
	DD	01H
	DD	FLAT:$T332813
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
xdata$x	ENDS
;	COMDAT ?AddGCLogRealTimeWorld@CUserMng@@QAEXU__GCGETPOINT@CGuildCombat@@@Z
_TEXT	SEGMENT
$T332807 = -16428					; size = 4
_it$ = -16428						; size = 4
_uBlockSize$ = -16424					; size = 4
_arBlock$ = -16420					; size = 16404
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_GCGetPoint$ = 8					; size = 36
?AddGCLogRealTimeWorld@CUserMng@@QAEXU__GCGETPOINT@CGuildCombat@@@Z PROC NEAR ; CUserMng::AddGCLogRealTimeWorld, COMDAT
; _this$ = ecx

; 5858 : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?AddGCLogRealTimeWorld@CUserMng@@QAEXU__GCGETPOINT@CGuildCombat@@@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	b8 20 40 00 00	 mov	 eax, 16416		; 00004020H
  00013	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0001a	e8 00 00 00 00	 call	 __chkstk
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00024	33 c4		 xor	 eax, esp
  00026	53		 push	 ebx
  00027	55		 push	 ebp

; 5859 : 	LPCSTR szAttacker, szDefender;
; 5860 : #if __VER >= 11 // __SYS_PLAYER_DATA
; 5861 : 	szAttacker	= CPlayerDataCenter::GetInstance()->GetPlayerString( GCGetPoint.uidPlayerAttack );

  00028	8b ac 24 40 40
	00 00		 mov	 ebp, DWORD PTR _GCGetPoint$[esp+16440]
  0002f	56		 push	 esi
  00030	57		 push	 edi
  00031	55		 push	 ebp
  00032	89 84 24 30 40
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+16448], eax
  00039	89 4c 24 14	 mov	 DWORD PTR $T332807[esp+16448], ecx
  0003d	e8 00 00 00 00	 call	 ?GetInstance@CPlayerDataCenter@@SAPAV1@XZ ; CPlayerDataCenter::GetInstance
  00042	8b c8		 mov	 ecx, eax
  00044	e8 00 00 00 00	 call	 ?GetPlayerString@CPlayerDataCenter@@QAEPBDK@Z ; CPlayerDataCenter::GetPlayerString

; 5862 : 	szDefender	= CPlayerDataCenter::GetInstance()->GetPlayerString( GCGetPoint.uidPlayerDefence );

  00049	8b 9c 24 4c 40
	00 00		 mov	 ebx, DWORD PTR _GCGetPoint$[esp+16452]
  00050	53		 push	 ebx
  00051	8b f0		 mov	 esi, eax
  00053	e8 00 00 00 00	 call	 ?GetInstance@CPlayerDataCenter@@SAPAV1@XZ ; CPlayerDataCenter::GetInstance
  00058	8b c8		 mov	 ecx, eax
  0005a	e8 00 00 00 00	 call	 ?GetPlayerString@CPlayerDataCenter@@QAEPBDK@Z ; CPlayerDataCenter::GetPlayerString

; 5863 : #else	// __SYS_PLAYER_DATA
; 5864 : 	szAttacker = prj.GetPlayerString( GCGetPoint.uidPlayerAttack );
; 5865 : 	szDefender = prj.GetPlayerString( GCGetPoint.uidPlayerDefence );
; 5866 : #endif	// __SYS_PLAYER_DATA
; 5867 : 	if( szAttacker == NULL || szDefender == NULL )

  0005f	85 f6		 test	 esi, esi
  00061	8b f8		 mov	 edi, eax
  00063	0f 84 1d 02 00
	00		 je	 $L282617
  00069	85 ff		 test	 edi, edi
  0006b	0f 84 15 02 00
	00		 je	 $L282617

; 5868 : 		return;
; 5869 : 
; 5870 : 	CAr arBlock;

  00071	6a 00		 push	 0
  00073	6a 00		 push	 0
  00075	8d 4c 24 20	 lea	 ecx, DWORD PTR _arBlock$[esp+16452]
  00079	e8 00 00 00 00	 call	 ??0CAr@@QAE@PAXI@Z	; CAr::CAr

; 5871 : 	arBlock << NULL_ID << SNAPSHOTTYPE_GUILDCOMBAT;

  0007e	6a 04		 push	 4
  00080	8d 4c 24 1c	 lea	 ecx, DWORD PTR _arBlock$[esp+16448]
  00084	c7 84 24 3c 40
	00 00 00 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+16456], 0
  0008f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00094	8b 44 24 20	 mov	 eax, DWORD PTR _arBlock$[esp+16452]
  00098	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [eax], -1
  0009e	8b 54 24 20	 mov	 edx, DWORD PTR _arBlock$[esp+16452]
  000a2	83 c2 04	 add	 edx, 4
  000a5	6a 02		 push	 2
  000a7	8d 4c 24 1c	 lea	 ecx, DWORD PTR _arBlock$[esp+16448]
  000ab	89 54 24 24	 mov	 DWORD PTR _arBlock$[esp+16456], edx
  000af	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000b4	8b 4c 24 20	 mov	 ecx, DWORD PTR _arBlock$[esp+16452]
  000b8	66 c7 01 b8 00	 mov	 WORD PTR [ecx], 184	; 000000b8H
  000bd	8b 44 24 20	 mov	 eax, DWORD PTR _arBlock$[esp+16452]
  000c1	83 c0 02	 add	 eax, 2

; 5872 : 	arBlock << GC_LOG_REALTIME;

  000c4	6a 01		 push	 1
  000c6	8d 4c 24 1c	 lea	 ecx, DWORD PTR _arBlock$[esp+16448]
  000ca	89 44 24 24	 mov	 DWORD PTR _arBlock$[esp+16456], eax
  000ce	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000d3	8b 54 24 20	 mov	 edx, DWORD PTR _arBlock$[esp+16452]
  000d7	c6 02 36	 mov	 BYTE PTR [edx], 54	; 00000036H
  000da	ff 44 24 20	 inc	 DWORD PTR _arBlock$[esp+16452]

; 5873 : 	arBlock << GCGetPoint.uidGuildAttack;

  000de	6a 04		 push	 4
  000e0	8d 4c 24 1c	 lea	 ecx, DWORD PTR _arBlock$[esp+16448]
  000e4	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000e9	8b 44 24 20	 mov	 eax, DWORD PTR _arBlock$[esp+16452]
  000ed	8b 8c 24 40 40
	00 00		 mov	 ecx, DWORD PTR _GCGetPoint$[esp+16440]
  000f4	89 08		 mov	 DWORD PTR [eax], ecx
  000f6	8b 54 24 20	 mov	 edx, DWORD PTR _arBlock$[esp+16452]
  000fa	83 c2 04	 add	 edx, 4

; 5874 : 	arBlock << GCGetPoint.uidGuildDefence;

  000fd	6a 04		 push	 4
  000ff	8d 4c 24 1c	 lea	 ecx, DWORD PTR _arBlock$[esp+16448]
  00103	89 54 24 24	 mov	 DWORD PTR _arBlock$[esp+16456], edx
  00107	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0010c	8b 54 24 20	 mov	 edx, DWORD PTR _arBlock$[esp+16452]
  00110	8b 84 24 44 40
	00 00		 mov	 eax, DWORD PTR _GCGetPoint$[esp+16444]
  00117	89 02		 mov	 DWORD PTR [edx], eax
  00119	8b 44 24 20	 mov	 eax, DWORD PTR _arBlock$[esp+16452]
  0011d	83 c0 04	 add	 eax, 4

; 5875 : 	arBlock.WriteString( szAttacker );

  00120	56		 push	 esi
  00121	8d 4c 24 1c	 lea	 ecx, DWORD PTR _arBlock$[esp+16448]
  00125	89 44 24 24	 mov	 DWORD PTR _arBlock$[esp+16456], eax
  00129	e8 00 00 00 00	 call	 ?WriteString@CAr@@QAEXPBD@Z ; CAr::WriteString

; 5876 : 	arBlock.WriteString( szDefender );

  0012e	57		 push	 edi
  0012f	8d 4c 24 1c	 lea	 ecx, DWORD PTR _arBlock$[esp+16448]
  00133	e8 00 00 00 00	 call	 ?WriteString@CAr@@QAEXPBD@Z ; CAr::WriteString

; 5877 : 	arBlock << GCGetPoint.uidPlayerAttack;

  00138	be 04 00 00 00	 mov	 esi, 4
  0013d	56		 push	 esi
  0013e	8d 4c 24 1c	 lea	 ecx, DWORD PTR _arBlock$[esp+16448]
  00142	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00147	8b 4c 24 20	 mov	 ecx, DWORD PTR _arBlock$[esp+16452]
  0014b	89 29		 mov	 DWORD PTR [ecx], ebp
  0014d	8b 7c 24 20	 mov	 edi, DWORD PTR _arBlock$[esp+16452]
  00151	03 fe		 add	 edi, esi

; 5878 : 	arBlock << GCGetPoint.uidPlayerDefence;

  00153	56		 push	 esi
  00154	8d 4c 24 1c	 lea	 ecx, DWORD PTR _arBlock$[esp+16448]
  00158	89 7c 24 24	 mov	 DWORD PTR _arBlock$[esp+16456], edi
  0015c	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00161	8b 54 24 20	 mov	 edx, DWORD PTR _arBlock$[esp+16452]
  00165	89 1a		 mov	 DWORD PTR [edx], ebx
  00167	01 74 24 20	 add	 DWORD PTR _arBlock$[esp+16452], esi

; 5879 : 	arBlock << GCGetPoint.nPoint;

  0016b	56		 push	 esi
  0016c	8d 4c 24 1c	 lea	 ecx, DWORD PTR _arBlock$[esp+16448]
  00170	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00175	8b 44 24 20	 mov	 eax, DWORD PTR _arBlock$[esp+16452]
  00179	8b 8c 24 50 40
	00 00		 mov	 ecx, DWORD PTR _GCGetPoint$[esp+16456]
  00180	89 08		 mov	 DWORD PTR [eax], ecx
  00182	01 74 24 20	 add	 DWORD PTR _arBlock$[esp+16452], esi

; 5880 : 	arBlock << GCGetPoint.bKillDiffernceGuild;

  00186	56		 push	 esi
  00187	8d 4c 24 1c	 lea	 ecx, DWORD PTR _arBlock$[esp+16448]
  0018b	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00190	8b 54 24 20	 mov	 edx, DWORD PTR _arBlock$[esp+16452]
  00194	8b 84 24 54 40
	00 00		 mov	 eax, DWORD PTR _GCGetPoint$[esp+16460]
  0019b	89 02		 mov	 DWORD PTR [edx], eax
  0019d	8b 7c 24 20	 mov	 edi, DWORD PTR _arBlock$[esp+16452]
  001a1	03 fe		 add	 edi, esi

; 5881 : 	arBlock << GCGetPoint.bMaster;

  001a3	56		 push	 esi
  001a4	8d 4c 24 1c	 lea	 ecx, DWORD PTR _arBlock$[esp+16448]
  001a8	89 7c 24 24	 mov	 DWORD PTR _arBlock$[esp+16456], edi
  001ac	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  001b1	8b 4c 24 20	 mov	 ecx, DWORD PTR _arBlock$[esp+16452]
  001b5	8b 94 24 58 40
	00 00		 mov	 edx, DWORD PTR _GCGetPoint$[esp+16464]
  001bc	89 11		 mov	 DWORD PTR [ecx], edx
  001be	01 74 24 20	 add	 DWORD PTR _arBlock$[esp+16452], esi

; 5882 : 	arBlock << GCGetPoint.bDefender;

  001c2	56		 push	 esi
  001c3	8d 4c 24 1c	 lea	 ecx, DWORD PTR _arBlock$[esp+16448]
  001c7	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  001cc	8b 44 24 20	 mov	 eax, DWORD PTR _arBlock$[esp+16452]
  001d0	8b 8c 24 5c 40
	00 00		 mov	 ecx, DWORD PTR _GCGetPoint$[esp+16468]
  001d7	89 08		 mov	 DWORD PTR [eax], ecx
  001d9	8b 6c 24 20	 mov	 ebp, DWORD PTR _arBlock$[esp+16452]
  001dd	03 ee		 add	 ebp, esi

; 5883 : 	arBlock << GCGetPoint.bLastLife;

  001df	56		 push	 esi
  001e0	8d 4c 24 1c	 lea	 ecx, DWORD PTR _arBlock$[esp+16448]
  001e4	89 6c 24 24	 mov	 DWORD PTR _arBlock$[esp+16456], ebp
  001e8	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  001ed	8b 54 24 20	 mov	 edx, DWORD PTR _arBlock$[esp+16452]
  001f1	8b 84 24 60 40
	00 00		 mov	 eax, DWORD PTR _GCGetPoint$[esp+16472]
  001f8	89 02		 mov	 DWORD PTR [edx], eax
  001fa	8b 7c 24 20	 mov	 edi, DWORD PTR _arBlock$[esp+16452]

; 5884 : 	GETBLOCK( arBlock, lpBlock, uBlockSize );

  001fe	8d 4c 24 14	 lea	 ecx, DWORD PTR _uBlockSize$[esp+16444]
  00202	51		 push	 ecx
  00203	03 fe		 add	 edi, esi
  00205	8d 4c 24 1c	 lea	 ecx, DWORD PTR _arBlock$[esp+16448]
  00209	89 7c 24 24	 mov	 DWORD PTR _arBlock$[esp+16456], edi
  0020d	e8 00 00 00 00	 call	 ?GetBuffer@CAr@@QAEPAEPAH@Z ; CAr::GetBuffer

; 5885 : 	
; 5886 : 	map<DWORD, CUser*>::iterator it;
; 5887 : 	for( it = m_users.begin(); it != m_users.end(); ++it )

  00212	8b 74 24 10	 mov	 esi, DWORD PTR $T332807[esp+16444]
  00216	8b f8		 mov	 edi, eax
  00218	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  0021b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0021d	3b c8		 cmp	 ecx, eax
  0021f	89 4c 24 10	 mov	 DWORD PTR _it$[esp+16444], ecx
  00223	74 4d		 je	 SHORT $L282632
$L332726:

; 5888 : 	{
; 5889 : 		CUser* pUser = it->second;

  00225	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]

; 5890 : 		if( pUser->IsValid() == FALSE )

  00228	f6 40 04 01	 test	 BYTE PTR [eax+4], 1
  0022c	75 30		 jne	 SHORT $L282631
  0022e	8b 88 e8 16 00
	00		 mov	 ecx, DWORD PTR [eax+5864]
  00234	85 c9		 test	 ecx, ecx
  00236	74 26		 je	 SHORT $L282631

; 5891 : 			continue;
; 5892 : 		
; 5893 : 		if( pUser->GetWorld()->GetID() == WI_WORLD_GUILDWAR )

  00238	8b 88 6c 01 00
	00		 mov	 ecx, DWORD PTR [eax+364]
  0023e	81 39 ca 00 00
	00		 cmp	 DWORD PTR [ecx], 202	; 000000caH
  00244	75 18		 jne	 SHORT $L282631

; 5894 : 			pUser->AddBlock( lpBlock, uBlockSize );

  00246	8b 4c 24 14	 mov	 ecx, DWORD PTR _uBlockSize$[esp+16444]
  0024a	66 ff 80 0c 57
	00 00		 inc	 WORD PTR [eax+22284]
  00251	51		 push	 ecx
  00252	57		 push	 edi
  00253	8d 88 f8 16 00
	00		 lea	 ecx, DWORD PTR [eax+5880]
  00259	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
$L282631:
  0025e	8d 4c 24 10	 lea	 ecx, DWORD PTR _it$[esp+16444]
  00262	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::const_iterator::_Inc
  00267	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  0026a	8b 4c 24 10	 mov	 ecx, DWORD PTR _it$[esp+16444]
  0026e	3b c8		 cmp	 ecx, eax
  00270	75 b3		 jne	 SHORT $L332726
$L282632:

; 5895 : 	}
; 5896 : }

  00272	8d 4c 24 18	 lea	 ecx, DWORD PTR _arBlock$[esp+16444]
  00276	c7 84 24 38 40
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+16452], -1
  00281	e8 00 00 00 00	 call	 ??1CAr@@QAE@XZ		; CAr::~CAr
$L282617:
  00286	8b 8c 24 30 40
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+16444]
  0028d	5f		 pop	 edi
  0028e	5e		 pop	 esi
  0028f	5d		 pop	 ebp
  00290	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00297	8b 8c 24 20 40
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+16432]
  0029e	5b		 pop	 ebx
  0029f	33 cc		 xor	 ecx, esp
  002a1	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002a6	81 c4 2c 40 00
	00		 add	 esp, 16428		; 0000402cH
  002ac	c2 24 00	 ret	 36			; 00000024H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L332617:
  00000	8d 8d dc bf ff
	ff		 lea	 ecx, DWORD PTR _arBlock$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CAr@@QAE@XZ		; CAr::~CAr
__ehhandler$?AddGCLogRealTimeWorld@CUserMng@@QAEXU__GCGETPOINT@CGuildCombat@@@Z:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T332809
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?AddGCLogRealTimeWorld@CUserMng@@QAEXU__GCGETPOINT@CGuildCombat@@@Z ENDP ; CUserMng::AddGCLogRealTimeWorld
PUBLIC	?ReplaceWorld@CUserMng@@QAEXKKMMH@Z		; CUserMng::ReplaceWorld
EXTRN	?SetOther@CVTInfo@@QAEXPAVCMover@@@Z:NEAR	; CVTInfo::SetOther
; Function compile flags: /Ogty
;	COMDAT ?ReplaceWorld@CUserMng@@QAEXKKMMH@Z
_TEXT	SEGMENT
_pWorld$ = -16						; size = 4
$T332821 = -12						; size = 12
_it$282651 = 8						; size = 4
_dwWorldId$ = 8						; size = 4
_dwReplaceWorldId$ = 12					; size = 4
_fReplaceX$ = 16					; size = 4
_fReplaceZ$ = 20					; size = 4
_nLayer$ = 24						; size = 4
?ReplaceWorld@CUserMng@@QAEXKKMMH@Z PROC NEAR		; CUserMng::ReplaceWorld, COMDAT
; _this$ = ecx

; 5903 : {

  00000	83 ec 10	 sub	 esp, 16			; 00000010H

; 5904 : 	CWorld* pWorld	= g_WorldMng.GetWorld( dwWorldId );

  00003	8b 44 24 14	 mov	 eax, DWORD PTR _dwWorldId$[esp+12]
  00007	55		 push	 ebp
  00008	57		 push	 edi
  00009	8b e9		 mov	 ebp, ecx
  0000b	50		 push	 eax
  0000c	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_WorldMng@@3VCWorldMng@@A
  00011	e8 00 00 00 00	 call	 ?GetWorld@CWorldMng@@QAEPAVCWorld@@K@Z ; CWorldMng::GetWorld
  00016	8b f8		 mov	 edi, eax

; 5905 : 	if( pWorld )

  00018	85 ff		 test	 edi, edi
  0001a	89 7c 24 08	 mov	 DWORD PTR _pWorld$[esp+24], edi
  0001e	0f 84 d4 00 00
	00		 je	 $L282656

; 5906 : 	{
; 5907 : 		map<DWORD, CUser*>::iterator it;
; 5908 : 		for( it = m_users.begin(); it != m_users.end(); ++it )

  00024	8b 4d 0c	 mov	 ecx, DWORD PTR [ebp+12]
  00027	8b 01		 mov	 eax, DWORD PTR [ecx]
  00029	3b c1		 cmp	 eax, ecx
  0002b	89 44 24 1c	 mov	 DWORD PTR _it$282651[esp+20], eax
  0002f	0f 84 c3 00 00
	00		 je	 $L282656
  00035	53		 push	 ebx
  00036	8b 5c 24 30	 mov	 ebx, DWORD PTR _nLayer$[esp+24]
  0003a	56		 push	 esi
  0003b	eb 03 8d 49 00	 npad	 5
$L332937:

; 5909 : 		{
; 5910 : 			CUser* pUser = it->second;

  00040	8b 70 10	 mov	 esi, DWORD PTR [eax+16]

; 5911 : 			if( pUser->IsValid() == FALSE )

  00043	f6 46 04 01	 test	 BYTE PTR [esi+4], 1
  00047	0f 85 93 00 00
	00		 jne	 $L282655
  0004d	8b 86 e8 16 00
	00		 mov	 eax, DWORD PTR [esi+5864]
  00053	85 c0		 test	 eax, eax
  00055	0f 84 85 00 00
	00		 je	 $L282655

; 5912 : 				continue;
; 5913 : 			
; 5914 : 			if( pUser->GetWorld() == pWorld )

  0005b	39 be 6c 01 00
	00		 cmp	 DWORD PTR [esi+364], edi
  00061	75 7d		 jne	 SHORT $L282655

; 5915 : 			{
; 5916 : 				D3DXVECTOR3 v3Pos = pUser->GetPos();

  00063	8d 8e 60 01 00
	00		 lea	 ecx, DWORD PTR [esi+352]
  00069	8b 01		 mov	 eax, DWORD PTR [ecx]
  0006b	8b 79 04	 mov	 edi, DWORD PTR [ecx+4]
  0006e	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]

; 5917 : 				AddCreateSfxObj( (CMover*)pUser, XI_GEN_WEARF, v3Pos.x, v3Pos.y, v3Pos.z );

  00071	6a 00		 push	 0
  00073	51		 push	 ecx
  00074	57		 push	 edi
  00075	50		 push	 eax
  00076	68 d4 06 00 00	 push	 1748			; 000006d4H
  0007b	56		 push	 esi
  0007c	8b cd		 mov	 ecx, ebp
  0007e	e8 00 00 00 00	 call	 ?AddCreateSfxObj@CUserMng@@QAEXPAVCCtrl@@KMMMH@Z ; CUserMng::AddCreateSfxObj

; 5918 : 				( (CMover*)pUser)->REPLACE( g_uIdofMulti, dwReplaceWorldId, D3DXVECTOR3( fReplaceX, 0.0f, fReplaceZ ), REPLACE_NORMAL, nLayer );

  00083	8b 54 24 2c	 mov	 edx, DWORD PTR _fReplaceX$[esp+28]
  00087	8b 44 24 30	 mov	 eax, DWORD PTR _fReplaceZ$[esp+28]
  0008b	53		 push	 ebx
  0008c	6a 00		 push	 0
  0008e	8d 4c 24 1c	 lea	 ecx, DWORD PTR $T332821[esp+40]
  00092	51		 push	 ecx
  00093	89 54 24 20	 mov	 DWORD PTR $T332821[esp+44], edx
  00097	8b 54 24 34	 mov	 edx, DWORD PTR _dwReplaceWorldId$[esp+40]
  0009b	89 44 24 28	 mov	 DWORD PTR $T332821[esp+52], eax
  0009f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_uIdofMulti@@3KA ; g_uIdofMulti
  000a4	52		 push	 edx
  000a5	50		 push	 eax
  000a6	8b ce		 mov	 ecx, esi
  000a8	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR $T332821[esp+56], 0
  000b0	e8 00 00 00 00	 call	 ?Replace@CMover@@QAEHKKAAUD3DXVECTOR3@@W4REPLACE_TYPE@@H@Z ; CMover::Replace

; 5919 : 				pUser->m_vtInfo.SetOther( NULL );

  000b5	6a 00		 push	 0
  000b7	8d 8e 7c 0d 00
	00		 lea	 ecx, DWORD PTR [esi+3452]
  000bd	e8 00 00 00 00	 call	 ?SetOther@CVTInfo@@QAEXPAVCMover@@@Z ; CVTInfo::SetOther

; 5920 : 				AddCreateSfxObj( (CMover*)pUser, XI_GEN_WEARF, fReplaceX, v3Pos.y, fReplaceZ );				

  000c2	8b 4c 24 30	 mov	 ecx, DWORD PTR _fReplaceZ$[esp+28]
  000c6	8b 54 24 2c	 mov	 edx, DWORD PTR _fReplaceX$[esp+28]
  000ca	6a 00		 push	 0
  000cc	51		 push	 ecx
  000cd	57		 push	 edi
  000ce	52		 push	 edx
  000cf	68 d4 06 00 00	 push	 1748			; 000006d4H
  000d4	56		 push	 esi
  000d5	8b cd		 mov	 ecx, ebp
  000d7	e8 00 00 00 00	 call	 ?AddCreateSfxObj@CUserMng@@QAEXPAVCCtrl@@KMMMH@Z ; CUserMng::AddCreateSfxObj
  000dc	8b 7c 24 10	 mov	 edi, DWORD PTR _pWorld$[esp+32]
$L282655:
  000e0	8d 4c 24 24	 lea	 ecx, DWORD PTR _it$282651[esp+28]
  000e4	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::const_iterator::_Inc
  000e9	8b 44 24 24	 mov	 eax, DWORD PTR _it$282651[esp+28]
  000ed	3b 45 0c	 cmp	 eax, DWORD PTR [ebp+12]
  000f0	0f 85 4a ff ff
	ff		 jne	 $L332937
  000f6	5e		 pop	 esi
  000f7	5b		 pop	 ebx
$L282656:
  000f8	5f		 pop	 edi
  000f9	5d		 pop	 ebp

; 5921 : 			}
; 5922 : 		}
; 5923 : 	}
; 5924 : }

  000fa	83 c4 10	 add	 esp, 16			; 00000010H
  000fd	c2 14 00	 ret	 20			; 00000014H
?ReplaceWorld@CUserMng@@QAEXKKMMH@Z ENDP		; CUserMng::ReplaceWorld
_TEXT	ENDS
PUBLIC	?ReplaceWorldArea@CUserMng@@QAEXKKKMMMHH@Z	; CUserMng::ReplaceWorldArea
EXTRN	?xRandomF@@YAMM@Z:NEAR				; xRandomF
; Function compile flags: /Ogty
;	COMDAT ?ReplaceWorldArea@CUserMng@@QAEXKKKMMMHH@Z
_TEXT	SEGMENT
tv226 = -28						; size = 4
_i$282679 = -24						; size = 4
_fNewArea$282694 = -20					; size = 4
_pWorld$ = -16						; size = 4
$T332941 = -12						; size = 12
_idParty$ = 8						; size = 4
tv289 = 12						; size = 4
_dwWorldId$ = 12					; size = 4
_dwReplaceWorldId$ = 16					; size = 4
_fReplaceX$ = 20					; size = 4
_fReplaceZ$ = 24					; size = 4
_fArea$ = 28						; size = 4
_bDieFlag$ = 32						; size = 4
_nLayer$ = 36						; size = 4
?ReplaceWorldArea@CUserMng@@QAEXKKKMMMHH@Z PROC NEAR	; CUserMng::ReplaceWorldArea, COMDAT
; _this$ = ecx

; 5931 : {

  00000	83 ec 1c	 sub	 esp, 28			; 0000001cH

; 5932 : 	CWorld* pWorld	= g_WorldMng.GetWorld( dwWorldId );

  00003	8b 44 24 24	 mov	 eax, DWORD PTR _dwWorldId$[esp+24]
  00007	53		 push	 ebx
  00008	57		 push	 edi
  00009	8b d9		 mov	 ebx, ecx
  0000b	50		 push	 eax
  0000c	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_WorldMng@@3VCWorldMng@@A
  00011	e8 00 00 00 00	 call	 ?GetWorld@CWorldMng@@QAEPAVCWorld@@K@Z ; CWorldMng::GetWorld
  00016	8b f8		 mov	 edi, eax

; 5933 : 	if( pWorld )

  00018	85 ff		 test	 edi, edi
  0001a	89 7c 24 14	 mov	 DWORD PTR _pWorld$[esp+36], edi
  0001e	0f 84 46 01 00
	00		 je	 $L282683

; 5934 : 	{
; 5935 : 		for( int i = 0; i < (int)( pWorld->m_dwObjNum ); i++ )

  00024	8b 47 44	 mov	 eax, DWORD PTR [edi+68]
  00027	85 c0		 test	 eax, eax
  00029	c7 44 24 0c 00
	00 00 00	 mov	 DWORD PTR _i$282679[esp+36], 0
  00031	0f 8e 33 01 00
	00		 jle	 $L282683
  00037	8d 4f 48	 lea	 ecx, DWORD PTR [edi+72]
  0003a	55		 push	 ebp
  0003b	89 4c 24 30	 mov	 DWORD PTR tv289[esp+36], ecx
  0003f	56		 push	 esi
$L332973:

; 5936 : 		{
; 5937 : 			CObj* pObj	= pWorld->m_apObject[i];

  00040	8b 54 24 34	 mov	 edx, DWORD PTR tv289[esp+40]
  00044	8b 32		 mov	 esi, DWORD PTR [edx]

; 5938 : 			if( IsValidObj( pObj ) && pObj->GetType() == OT_MOVER && ( (CMover*)pObj )->IsPlayer() && ( (CMover*)pObj )->m_idparty == idParty )

  00046	85 f6		 test	 esi, esi
  00048	0f 84 fb 00 00
	00		 je	 $L282682
  0004e	f6 46 04 01	 test	 BYTE PTR [esi+4], 1
  00052	0f 85 f1 00 00
	00		 jne	 $L282682
  00058	83 be 70 01 00
	00 05		 cmp	 DWORD PTR [esi+368], 5
  0005f	0f 85 e4 00 00
	00		 jne	 $L282682
  00065	8b 86 34 02 00
	00		 mov	 eax, DWORD PTR [esi+564]
  0006b	85 c0		 test	 eax, eax
  0006d	0f 84 d6 00 00
	00		 je	 $L282682
  00073	8b 44 24 30	 mov	 eax, DWORD PTR _idParty$[esp+40]
  00077	39 86 18 07 00
	00		 cmp	 DWORD PTR [esi+1816], eax
  0007d	0f 85 c6 00 00
	00		 jne	 $L282682

; 5939 : 			{
; 5940 : 				CUser* pUser	= (CUser*)pObj;
; 5941 : 				if( bDieFlag )

  00083	8b 44 24 48	 mov	 eax, DWORD PTR _bDieFlag$[esp+40]
  00087	85 c0		 test	 eax, eax
  00089	74 0f		 je	 SHORT $L282691

; 5942 : 				{
; 5943 : 					if( pUser->IsDie() )

  0008b	8b ce		 mov	 ecx, esi
  0008d	e8 00 00 00 00	 call	 ?IsDie@CMover@@QAEHXZ	; CMover::IsDie
  00092	85 c0		 test	 eax, eax
  00094	0f 85 af 00 00
	00		 jne	 $L282682
$L282691:

; 5944 : 						continue;
; 5945 : 				}
; 5946 : 
; 5947 : 				D3DXVECTOR3 vPos	= pUser->GetPos();

  0009a	8d 8e 60 01 00
	00		 lea	 ecx, DWORD PTR [esi+352]
  000a0	8b 01		 mov	 eax, DWORD PTR [ecx]
  000a2	8b 79 04	 mov	 edi, DWORD PTR [ecx+4]
  000a5	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]

; 5948 : 				AddCreateSfxObj( pUser, XI_GEN_WEARF, vPos.x, vPos.y, vPos.z );

  000a8	6a 00		 push	 0
  000aa	51		 push	 ecx
  000ab	57		 push	 edi
  000ac	50		 push	 eax
  000ad	68 d4 06 00 00	 push	 1748			; 000006d4H
  000b2	56		 push	 esi
  000b3	8b cb		 mov	 ecx, ebx
  000b5	e8 00 00 00 00	 call	 ?AddCreateSfxObj@CUserMng@@QAEXPAVCCtrl@@KMMMH@Z ; CUserMng::AddCreateSfxObj

; 5949 : 				float fNewArea	= fArea * 2.0f;

  000ba	d9 44 24 44	 fld	 DWORD PTR _fArea$[esp+40]
  000be	dc c0		 fadd	 ST(0), ST(0)
  000c0	d9 5c 24 18	 fstp	 DWORD PTR _fNewArea$282694[esp+44]

; 5950 : 				fReplaceX += (-fArea) + xRandomF( fNewArea );

  000c4	d9 44 24 44	 fld	 DWORD PTR _fArea$[esp+40]
  000c8	8b 6c 24 18	 mov	 ebp, DWORD PTR _fNewArea$282694[esp+44]
  000cc	d9 e0		 fchs
  000ce	55		 push	 ebp
  000cf	d9 5c 24 14	 fstp	 DWORD PTR tv226[esp+48]
  000d3	e8 00 00 00 00	 call	 ?xRandomF@@YAMM@Z	; xRandomF
  000d8	d8 44 24 14	 fadd	 DWORD PTR tv226[esp+48]

; 5951 : 				fReplaceZ += (-fArea) + xRandomF( fNewArea );

  000dc	55		 push	 ebp
  000dd	d8 44 24 44	 fadd	 DWORD PTR _fReplaceX$[esp+48]
  000e1	d9 5c 24 44	 fstp	 DWORD PTR _fReplaceX$[esp+48]
  000e5	e8 00 00 00 00	 call	 ?xRandomF@@YAMM@Z	; xRandomF

; 5952 : 				pUser->REPLACE( g_uIdofMulti, dwReplaceWorldId, D3DXVECTOR3( fReplaceX, 0.0f, fReplaceZ ), REPLACE_NORMAL, nLayer );

  000ea	8b 44 24 54	 mov	 eax, DWORD PTR _nLayer$[esp+48]
  000ee	d8 44 24 18	 fadd	 DWORD PTR tv226[esp+52]
  000f2	8b 54 24 44	 mov	 edx, DWORD PTR _fReplaceX$[esp+48]
  000f6	83 c4 08	 add	 esp, 8
  000f9	d8 44 24 40	 fadd	 DWORD PTR _fReplaceZ$[esp+40]
  000fd	50		 push	 eax
  000fe	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_uIdofMulti@@3KA ; g_uIdofMulti
  00103	6a 00		 push	 0
  00105	8d 4c 24 28	 lea	 ecx, DWORD PTR $T332941[esp+52]
  00109	d9 54 24 48	 fst	 DWORD PTR _fReplaceZ$[esp+48]
  0010d	51		 push	 ecx
  0010e	d9 5c 24 34	 fstp	 DWORD PTR $T332941[esp+64]
  00112	89 54 24 2c	 mov	 DWORD PTR $T332941[esp+56], edx
  00116	8b 54 24 44	 mov	 edx, DWORD PTR _dwReplaceWorldId$[esp+52]
  0011a	52		 push	 edx
  0011b	50		 push	 eax
  0011c	8b ce		 mov	 ecx, esi
  0011e	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR $T332941[esp+68], 0
  00126	e8 00 00 00 00	 call	 ?Replace@CMover@@QAEHKKAAUD3DXVECTOR3@@W4REPLACE_TYPE@@H@Z ; CMover::Replace

; 5953 : 				AddCreateSfxObj( (CMover*)pUser, XI_GEN_WEARF, fReplaceX, vPos.y, fReplaceZ );

  0012b	8b 4c 24 40	 mov	 ecx, DWORD PTR _fReplaceZ$[esp+40]
  0012f	8b 54 24 3c	 mov	 edx, DWORD PTR _fReplaceX$[esp+40]
  00133	6a 00		 push	 0
  00135	51		 push	 ecx
  00136	57		 push	 edi
  00137	52		 push	 edx
  00138	68 d4 06 00 00	 push	 1748			; 000006d4H
  0013d	56		 push	 esi
  0013e	8b cb		 mov	 ecx, ebx
  00140	e8 00 00 00 00	 call	 ?AddCreateSfxObj@CUserMng@@QAEXPAVCCtrl@@KMMMH@Z ; CUserMng::AddCreateSfxObj
  00145	8b 7c 24 1c	 mov	 edi, DWORD PTR _pWorld$[esp+44]
$L282682:
  00149	8b 44 24 14	 mov	 eax, DWORD PTR _i$282679[esp+44]
  0014d	8b 54 24 34	 mov	 edx, DWORD PTR tv289[esp+40]
  00151	8b 4f 44	 mov	 ecx, DWORD PTR [edi+68]
  00154	40		 inc	 eax
  00155	83 c2 04	 add	 edx, 4
  00158	3b c1		 cmp	 eax, ecx
  0015a	89 44 24 14	 mov	 DWORD PTR _i$282679[esp+44], eax
  0015e	89 54 24 34	 mov	 DWORD PTR tv289[esp+40], edx
  00162	0f 8c d8 fe ff
	ff		 jl	 $L332973
  00168	5e		 pop	 esi
  00169	5d		 pop	 ebp
$L282683:
  0016a	5f		 pop	 edi
  0016b	5b		 pop	 ebx

; 5954 : 			}
; 5955 : 		}
; 5956 : 	}
; 5957 : }

  0016c	83 c4 1c	 add	 esp, 28			; 0000001cH
  0016f	c2 20 00	 ret	 32			; 00000020H
?ReplaceWorldArea@CUserMng@@QAEXKKKMMMHH@Z ENDP		; CUserMng::ReplaceWorldArea
_TEXT	ENDS
PUBLIC	?AddWorldMsg@CUserMng@@QAEXKPBD@Z		; CUserMng::AddWorldMsg
;	COMDAT xdata$x
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\obj.h
xdata$x	SEGMENT
$T333122 DD	0ffffffffH
	DD	FLAT:$L332980
$T333118 DD	019930520H
	DD	01H
	DD	FLAT:$T333122
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
xdata$x	ENDS
;	COMDAT ?AddWorldMsg@CUserMng@@QAEXKPBD@Z
_TEXT	SEGMENT
_it$ = -16428						; size = 4
_uBlockSize$ = -16424					; size = 4
_arBlock$ = -16420					; size = 16404
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_dwWorldId$ = 8						; size = 4
_lpszString$ = 12					; size = 4
?AddWorldMsg@CUserMng@@QAEXKPBD@Z PROC NEAR		; CUserMng::AddWorldMsg, COMDAT
; _this$ = ecx

; 5960 : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?AddWorldMsg@CUserMng@@QAEXKPBD@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	b8 20 40 00 00	 mov	 eax, 16416		; 00004020H
  00013	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0001a	e8 00 00 00 00	 call	 __chkstk
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00024	33 c4		 xor	 eax, esp
  00026	56		 push	 esi
  00027	8b b4 24 38 40
	00 00		 mov	 esi, DWORD PTR _lpszString$[esp+16428]
  0002e	57		 push	 edi

; 5961 : 	CAr arBlock;

  0002f	6a 00		 push	 0
  00031	8b f9		 mov	 edi, ecx
  00033	6a 00		 push	 0
  00035	8d 4c 24 18	 lea	 ecx, DWORD PTR _arBlock$[esp+16444]
  00039	89 84 24 2c 40
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+16444], eax
  00040	e8 00 00 00 00	 call	 ??0CAr@@QAE@PAXI@Z	; CAr::CAr

; 5962 : 	arBlock << NULL_ID << SNAPSHOTTYPE_WORLDMSG;

  00045	6a 04		 push	 4
  00047	8d 4c 24 14	 lea	 ecx, DWORD PTR _arBlock$[esp+16440]
  0004b	c7 84 24 34 40
	00 00 00 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+16448], 0
  00056	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0005b	8b 44 24 18	 mov	 eax, DWORD PTR _arBlock$[esp+16444]
  0005f	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [eax], -1
  00065	8b 54 24 18	 mov	 edx, DWORD PTR _arBlock$[esp+16444]
  00069	83 c2 04	 add	 edx, 4
  0006c	6a 02		 push	 2
  0006e	8d 4c 24 14	 lea	 ecx, DWORD PTR _arBlock$[esp+16440]
  00072	89 54 24 1c	 mov	 DWORD PTR _arBlock$[esp+16448], edx
  00076	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0007b	8b 4c 24 18	 mov	 ecx, DWORD PTR _arBlock$[esp+16444]
  0007f	66 c7 01 de 00	 mov	 WORD PTR [ecx], 222	; 000000deH
  00084	8b 44 24 18	 mov	 eax, DWORD PTR _arBlock$[esp+16444]
  00088	83 c0 02	 add	 eax, 2

; 5963 : 	arBlock.WriteString( lpszString );

  0008b	56		 push	 esi
  0008c	8d 4c 24 14	 lea	 ecx, DWORD PTR _arBlock$[esp+16440]
  00090	89 44 24 1c	 mov	 DWORD PTR _arBlock$[esp+16448], eax
  00094	e8 00 00 00 00	 call	 ?WriteString@CAr@@QAEXPBD@Z ; CAr::WriteString

; 5964 : 	GETBLOCK( arBlock, lpBlock, uBlockSize );

  00099	8d 54 24 0c	 lea	 edx, DWORD PTR _uBlockSize$[esp+16436]
  0009d	52		 push	 edx
  0009e	8d 4c 24 14	 lea	 ecx, DWORD PTR _arBlock$[esp+16440]
  000a2	e8 00 00 00 00	 call	 ?GetBuffer@CAr@@QAEPAEPAH@Z ; CAr::GetBuffer
  000a7	8b f0		 mov	 esi, eax

; 5965 : 	
; 5966 : 	map<DWORD, CUser*>::iterator it;
; 5967 : 	for( it = m_users.begin(); it != m_users.end(); ++it )

  000a9	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  000ac	8b 08		 mov	 ecx, DWORD PTR [eax]
  000ae	3b c8		 cmp	 ecx, eax
  000b0	89 4c 24 08	 mov	 DWORD PTR _it$[esp+16436], ecx
  000b4	74 54		 je	 SHORT $L282716
  000b6	55		 push	 ebp
  000b7	8b ac 24 3c 40
	00 00		 mov	 ebp, DWORD PTR _dwWorldId$[esp+16436]
  000be	8b ff		 npad	 2
$L333037:

; 5968 : 	{
; 5969 : 		CUser* pUser = it->second;

  000c0	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]

; 5970 : 		if( pUser->IsValid() == FALSE )

  000c3	f6 40 04 01	 test	 BYTE PTR [eax+4], 1
  000c7	75 2c		 jne	 SHORT $L282715
  000c9	8b 88 e8 16 00
	00		 mov	 ecx, DWORD PTR [eax+5864]
  000cf	85 c9		 test	 ecx, ecx
  000d1	74 22		 je	 SHORT $L282715

; 5971 : 			continue;
; 5972 : 		if( pUser->GetWorld()->GetID() == dwWorldId )

  000d3	8b 88 6c 01 00
	00		 mov	 ecx, DWORD PTR [eax+364]
  000d9	39 29		 cmp	 DWORD PTR [ecx], ebp
  000db	75 18		 jne	 SHORT $L282715

; 5973 : 			pUser->AddBlock( lpBlock, uBlockSize );

  000dd	8b 4c 24 10	 mov	 ecx, DWORD PTR _uBlockSize$[esp+16440]
  000e1	66 ff 80 0c 57
	00 00		 inc	 WORD PTR [eax+22284]
  000e8	51		 push	 ecx
  000e9	56		 push	 esi
  000ea	8d 88 f8 16 00
	00		 lea	 ecx, DWORD PTR [eax+5880]
  000f0	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
$L282715:
  000f5	8d 4c 24 0c	 lea	 ecx, DWORD PTR _it$[esp+16440]
  000f9	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::const_iterator::_Inc
  000fe	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  00101	8b 4c 24 0c	 mov	 ecx, DWORD PTR _it$[esp+16440]
  00105	3b c8		 cmp	 ecx, eax
  00107	75 b7		 jne	 SHORT $L333037
  00109	5d		 pop	 ebp
$L282716:

; 5974 : 	}
; 5975 : }

  0010a	8d 4c 24 10	 lea	 ecx, DWORD PTR _arBlock$[esp+16436]
  0010e	c7 84 24 30 40
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+16444], -1
  00119	e8 00 00 00 00	 call	 ??1CAr@@QAE@XZ		; CAr::~CAr
  0011e	8b 8c 24 28 40
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+16436]
  00125	5f		 pop	 edi
  00126	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0012d	8b 8c 24 20 40
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+16432]
  00134	5e		 pop	 esi
  00135	33 cc		 xor	 ecx, esp
  00137	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0013c	81 c4 2c 40 00
	00		 add	 esp, 16428		; 0000402cH
  00142	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L332980:
  00000	8d 8d dc bf ff
	ff		 lea	 ecx, DWORD PTR _arBlock$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CAr@@QAE@XZ		; CAr::~CAr
__ehhandler$?AddWorldMsg@CUserMng@@QAEXKPBD@Z:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T333118
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?AddWorldMsg@CUserMng@@QAEXKPBD@Z ENDP			; CUserMng::AddWorldMsg
PUBLIC	?AddGCIsRequest@CUserMng@@QAEXKH@Z		; CUserMng::AddGCIsRequest
;	COMDAT xdata$x
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\obj.h
xdata$x	SEGMENT
$T333275 DD	0ffffffffH
	DD	FLAT:$L333131
$T333271 DD	019930520H
	DD	01H
	DD	FLAT:$T333275
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
xdata$x	ENDS
;	COMDAT ?AddGCIsRequest@CUserMng@@QAEXKH@Z
_TEXT	SEGMENT
_it$ = -16428						; size = 4
_uBlockSize$ = -16424					; size = 4
_arBlock$ = -16420					; size = 16404
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_uidGuild$ = 8						; size = 4
_bRequest$ = 12						; size = 4
?AddGCIsRequest@CUserMng@@QAEXKH@Z PROC NEAR		; CUserMng::AddGCIsRequest, COMDAT
; _this$ = ecx

; 6000 : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?AddGCIsRequest@CUserMng@@QAEXKH@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	b8 20 40 00 00	 mov	 eax, 16416		; 00004020H
  00013	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0001a	e8 00 00 00 00	 call	 __chkstk
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00024	33 c4		 xor	 eax, esp
  00026	55		 push	 ebp
  00027	56		 push	 esi
  00028	57		 push	 edi

; 6001 : 	CAr arBlock;

  00029	6a 00		 push	 0
  0002b	8b f1		 mov	 esi, ecx
  0002d	6a 00		 push	 0
  0002f	8d 4c 24 1c	 lea	 ecx, DWORD PTR _arBlock$[esp+16448]
  00033	89 84 24 30 40
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+16448], eax
  0003a	e8 00 00 00 00	 call	 ??0CAr@@QAE@PAXI@Z	; CAr::CAr

; 6002 : 	arBlock << NULL_ID << SNAPSHOTTYPE_GUILDCOMBAT;

  0003f	bf 04 00 00 00	 mov	 edi, 4
  00044	57		 push	 edi
  00045	8d 4c 24 18	 lea	 ecx, DWORD PTR _arBlock$[esp+16444]
  00049	c7 84 24 38 40
	00 00 00 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+16452], 0
  00054	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00059	8b 44 24 1c	 mov	 eax, DWORD PTR _arBlock$[esp+16448]
  0005d	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [eax], -1
  00063	01 7c 24 1c	 add	 DWORD PTR _arBlock$[esp+16448], edi
  00067	6a 02		 push	 2
  00069	8d 4c 24 18	 lea	 ecx, DWORD PTR _arBlock$[esp+16444]
  0006d	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00072	8b 4c 24 1c	 mov	 ecx, DWORD PTR _arBlock$[esp+16448]
  00076	66 c7 01 b8 00	 mov	 WORD PTR [ecx], 184	; 000000b8H
  0007b	8b 6c 24 1c	 mov	 ebp, DWORD PTR _arBlock$[esp+16448]
  0007f	83 c5 02	 add	 ebp, 2

; 6003 : 	arBlock << GC_ISREQUEST;

  00082	6a 01		 push	 1
  00084	8d 4c 24 18	 lea	 ecx, DWORD PTR _arBlock$[esp+16444]
  00088	89 6c 24 20	 mov	 DWORD PTR _arBlock$[esp+16452], ebp
  0008c	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00091	8b 54 24 1c	 mov	 edx, DWORD PTR _arBlock$[esp+16448]
  00095	c6 02 08	 mov	 BYTE PTR [edx], 8
  00098	ff 44 24 1c	 inc	 DWORD PTR _arBlock$[esp+16448]

; 6004 : 	arBlock << bRequest;

  0009c	57		 push	 edi
  0009d	8d 4c 24 18	 lea	 ecx, DWORD PTR _arBlock$[esp+16444]
  000a1	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000a6	8b 44 24 1c	 mov	 eax, DWORD PTR _arBlock$[esp+16448]
  000aa	8b 8c 24 40 40
	00 00		 mov	 ecx, DWORD PTR _bRequest$[esp+16436]
  000b1	89 08		 mov	 DWORD PTR [eax], ecx
  000b3	8b 6c 24 1c	 mov	 ebp, DWORD PTR _arBlock$[esp+16448]

; 6005 : 
; 6006 : 	GETBLOCK( arBlock, lpBlock, uBlockSize );

  000b7	8d 54 24 10	 lea	 edx, DWORD PTR _uBlockSize$[esp+16440]
  000bb	03 ef		 add	 ebp, edi
  000bd	52		 push	 edx
  000be	8d 4c 24 18	 lea	 ecx, DWORD PTR _arBlock$[esp+16444]
  000c2	89 6c 24 20	 mov	 DWORD PTR _arBlock$[esp+16452], ebp
  000c6	e8 00 00 00 00	 call	 ?GetBuffer@CAr@@QAEPAEPAH@Z ; CAr::GetBuffer
  000cb	8b f8		 mov	 edi, eax

; 6007 : 	map<DWORD, CUser*>::iterator it;
; 6008 : 	for( it = m_users.begin(); it != m_users.end(); ++it )

  000cd	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  000d0	8b 08		 mov	 ecx, DWORD PTR [eax]
  000d2	3b c8		 cmp	 ecx, eax
  000d4	89 4c 24 0c	 mov	 DWORD PTR _it$[esp+16440], ecx
  000d8	74 4e		 je	 SHORT $L282766
  000da	8b ac 24 3c 40
	00 00		 mov	 ebp, DWORD PTR _uidGuild$[esp+16436]
$L333199:

; 6009 : 	{
; 6010 : 		CUser* pUsertmp = it->second;

  000e1	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]

; 6011 : 		if( pUsertmp->IsValid() == FALSE )

  000e4	f6 40 04 01	 test	 BYTE PTR [eax+4], 1
  000e8	75 2a		 jne	 SHORT $L282765
  000ea	8b 88 e8 16 00
	00		 mov	 ecx, DWORD PTR [eax+5864]
  000f0	85 c9		 test	 ecx, ecx
  000f2	74 20		 je	 SHORT $L282765

; 6012 : 			continue;
; 6013 : 		
; 6014 : 		if( pUsertmp->m_idGuild == uidGuild )

  000f4	39 a8 1c 07 00
	00		 cmp	 DWORD PTR [eax+1820], ebp
  000fa	75 18		 jne	 SHORT $L282765

; 6015 : 			pUsertmp->AddBlock( lpBlock, uBlockSize );

  000fc	8b 4c 24 10	 mov	 ecx, DWORD PTR _uBlockSize$[esp+16440]
  00100	66 ff 80 0c 57
	00 00		 inc	 WORD PTR [eax+22284]
  00107	51		 push	 ecx
  00108	57		 push	 edi
  00109	8d 88 f8 16 00
	00		 lea	 ecx, DWORD PTR [eax+5880]
  0010f	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
$L282765:
  00114	8d 4c 24 0c	 lea	 ecx, DWORD PTR _it$[esp+16440]
  00118	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::const_iterator::_Inc
  0011d	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00120	8b 4c 24 0c	 mov	 ecx, DWORD PTR _it$[esp+16440]
  00124	3b c8		 cmp	 ecx, eax
  00126	75 b9		 jne	 SHORT $L333199
$L282766:

; 6016 : 	}
; 6017 : }

  00128	8d 4c 24 14	 lea	 ecx, DWORD PTR _arBlock$[esp+16440]
  0012c	c7 84 24 34 40
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+16448], -1
  00137	e8 00 00 00 00	 call	 ??1CAr@@QAE@XZ		; CAr::~CAr
  0013c	8b 8c 24 2c 40
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+16440]
  00143	5f		 pop	 edi
  00144	5e		 pop	 esi
  00145	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0014c	8b 8c 24 20 40
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+16432]
  00153	5d		 pop	 ebp
  00154	33 cc		 xor	 ecx, esp
  00156	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0015b	81 c4 2c 40 00
	00		 add	 esp, 16428		; 0000402cH
  00161	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L333131:
  00000	8d 8d dc bf ff
	ff		 lea	 ecx, DWORD PTR _arBlock$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CAr@@QAE@XZ		; CAr::~CAr
__ehhandler$?AddGCIsRequest@CUserMng@@QAEXKH@Z:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T333271
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?AddGCIsRequest@CUserMng@@QAEXKH@Z ENDP			; CUserMng::AddGCIsRequest
PUBLIC	?AddCommonPlace@CUserMng@@QAEXPAVCCtrl@@E@Z	; CUserMng::AddCommonPlace
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
xdata$x	SEGMENT
$T333547 DD	0ffffffffH
	DD	FLAT:$L333284
$T333539 DD	019930520H
	DD	01H
	DD	FLAT:$T333547
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
xdata$x	ENDS
;	COMDAT ?AddCommonPlace@CUserMng@@QAEXPAVCCtrl@@E@Z
_TEXT	SEGMENT
_nBufSize$ = -16424					; size = 4
_ar$ = -16420						; size = 16404
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_pCtrl$ = 8						; size = 4
_nType$ = 12						; size = 1
?AddCommonPlace@CUserMng@@QAEXPAVCCtrl@@E@Z PROC NEAR	; CUserMng::AddCommonPlace, COMDAT
; _this$ = ecx

; 6603 : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?AddCommonPlace@CUserMng@@QAEXPAVCCtrl@@E@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	b8 1c 40 00 00	 mov	 eax, 16412		; 0000401cH
  00013	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0001a	e8 00 00 00 00	 call	 __chkstk
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00024	33 c4		 xor	 eax, esp
  00026	55		 push	 ebp
  00027	56		 push	 esi
  00028	8b b4 24 34 40
	00 00		 mov	 esi, DWORD PTR _pCtrl$[esp+16428]
  0002f	57		 push	 edi

; 6604 : 	CAr ar;

  00030	6a 00		 push	 0
  00032	6a 00		 push	 0
  00034	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  00038	89 84 24 2c 40
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+16444], eax
  0003f	e8 00 00 00 00	 call	 ??0CAr@@QAE@PAXI@Z	; CAr::CAr

; 6605 : 	
; 6606 : 	ar << GETID( pCtrl ) << SNAPSHOTTYPE_COMMONPlACE;

  00044	85 f6		 test	 esi, esi
  00046	c7 84 24 30 40
	00 00 00 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+16444], 0
  00051	74 08		 je	 SHORT $L333282
  00053	8b be bc 01 00
	00		 mov	 edi, DWORD PTR [esi+444]
  00059	eb 03		 jmp	 SHORT $L333283
$L333282:
  0005b	83 cf ff	 or	 edi, -1
$L333283:
  0005e	6a 04		 push	 4
  00060	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  00064	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00069	8b 44 24 18	 mov	 eax, DWORD PTR _ar$[esp+16444]
  0006d	89 38		 mov	 DWORD PTR [eax], edi
  0006f	8b 54 24 18	 mov	 edx, DWORD PTR _ar$[esp+16444]
  00073	83 c2 04	 add	 edx, 4
  00076	6a 02		 push	 2
  00078	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  0007c	89 54 24 1c	 mov	 DWORD PTR _ar$[esp+16448], edx
  00080	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00085	8b 4c 24 18	 mov	 ecx, DWORD PTR _ar$[esp+16444]
  00089	66 c7 01 7e 00	 mov	 WORD PTR [ecx], 126	; 0000007eH
  0008e	8b 44 24 18	 mov	 eax, DWORD PTR _ar$[esp+16444]
  00092	83 c0 02	 add	 eax, 2

; 6607 : 	ar << nType;

  00095	6a 01		 push	 1
  00097	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  0009b	89 44 24 1c	 mov	 DWORD PTR _ar$[esp+16448], eax
  0009f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000a4	8b 54 24 18	 mov	 edx, DWORD PTR _ar$[esp+16444]
  000a8	8a 84 24 3c 40
	00 00		 mov	 al, BYTE PTR _nType$[esp+16432]
  000af	88 02		 mov	 BYTE PTR [edx], al
  000b1	8b 7c 24 18	 mov	 edi, DWORD PTR _ar$[esp+16444]

; 6608 : 	
; 6609 : 	GETBLOCK( ar, lpBuf, nBufSize );

  000b5	8d 4c 24 0c	 lea	 ecx, DWORD PTR _nBufSize$[esp+16436]
  000b9	51		 push	 ecx
  000ba	47		 inc	 edi
  000bb	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  000bf	89 7c 24 1c	 mov	 DWORD PTR _ar$[esp+16448], edi
  000c3	e8 00 00 00 00	 call	 ?GetBuffer@CAr@@QAEPAEPAH@Z ; CAr::GetBuffer

; 6610 : 	
; 6611 : 	FOR_VISIBILITYRANGE( pCtrl )

  000c8	8b be 10 02 00
	00		 mov	 edi, DWORD PTR [esi+528]
  000ce	8b 37		 mov	 esi, DWORD PTR [edi]
  000d0	3b f7		 cmp	 esi, edi
  000d2	8b e8		 mov	 ebp, eax
  000d4	74 78		 je	 SHORT $L283167
  000d6	eb 08 8d a4 24
	00 00 00 00 90	 npad	 10
$L283166:

; 6612 : 		USERPTR->AddBlock( lpBuf, nBufSize );

  000e0	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  000e3	f6 40 04 01	 test	 BYTE PTR [eax+4], 1
  000e7	8b 4c 24 0c	 mov	 ecx, DWORD PTR _nBufSize$[esp+16436]
  000eb	75 14		 jne	 SHORT $L333380
  000ed	66 ff 80 0c 57
	00 00		 inc	 WORD PTR [eax+22284]
  000f4	51		 push	 ecx
  000f5	55		 push	 ebp
  000f6	8d 88 f8 16 00
	00		 lea	 ecx, DWORD PTR [eax+5880]
  000fc	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
$L333380:

; 6613 : 	NEXT_VISIBILITYRANGE( pCtrl )

  00101	8a 46 15	 mov	 al, BYTE PTR [esi+21]
  00104	84 c0		 test	 al, al
  00106	75 42		 jne	 SHORT $L333507
  00108	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0010b	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  0010e	84 c9		 test	 cl, cl
  00110	75 1b		 jne	 SHORT $L333542
  00112	8b f0		 mov	 esi, eax
  00114	8b 06		 mov	 eax, DWORD PTR [esi]
  00116	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00119	84 c9		 test	 cl, cl
  0011b	75 2d		 jne	 SHORT $L333507
  0011d	8d 49 00	 npad	 3
$L333528:
  00120	8b f0		 mov	 esi, eax
  00122	8b 06		 mov	 eax, DWORD PTR [esi]
  00124	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00127	84 c9		 test	 cl, cl
  00129	74 f5		 je	 SHORT $L333528
  0012b	eb 1d		 jmp	 SHORT $L333507
$L333542:
  0012d	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00130	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00133	84 c9		 test	 cl, cl
  00135	75 11		 jne	 SHORT $L333510
$L333509:
  00137	3b 70 08	 cmp	 esi, DWORD PTR [eax+8]
  0013a	75 0c		 jne	 SHORT $L333510
  0013c	8b f0		 mov	 esi, eax
  0013e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00141	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00144	84 c9		 test	 cl, cl
  00146	74 ef		 je	 SHORT $L333509
$L333510:
  00148	8b f0		 mov	 esi, eax
$L333507:

; 6610 : 	
; 6611 : 	FOR_VISIBILITYRANGE( pCtrl )

  0014a	3b f7		 cmp	 esi, edi
  0014c	75 92		 jne	 SHORT $L283166
$L283167:

; 6614 : }

  0014e	8d 4c 24 10	 lea	 ecx, DWORD PTR _ar$[esp+16436]
  00152	c7 84 24 30 40
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+16444], -1
  0015d	e8 00 00 00 00	 call	 ??1CAr@@QAE@XZ		; CAr::~CAr
  00162	8b 8c 24 28 40
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+16436]
  00169	5f		 pop	 edi
  0016a	5e		 pop	 esi
  0016b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00172	8b 8c 24 1c 40
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+16428]
  00179	5d		 pop	 ebp
  0017a	33 cc		 xor	 ecx, esp
  0017c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00181	81 c4 28 40 00
	00		 add	 esp, 16424		; 00004028H
  00187	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L333284:
  00000	8d 8d dc bf ff
	ff		 lea	 ecx, DWORD PTR _ar$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CAr@@QAE@XZ		; CAr::~CAr
__ehhandler$?AddCommonPlace@CUserMng@@QAEXPAVCCtrl@@E@Z:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T333539
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?AddCommonPlace@CUserMng@@QAEXPAVCCtrl@@E@Z ENDP	; CUserMng::AddCommonPlace
PUBLIC	?OnMsgArrival@CUser@@QAEXK@Z			; CUser::OnMsgArrival
EXTRN	?RemoveItem@CMover@@QAEXEF@Z:NEAR		; CMover::RemoveItem
EXTRN	?IsLoot@CMover@@QAEHPAVCItem@@H@Z:NEAR		; CMover::IsLoot
EXTRN	?GetQuest@CMover@@QAEPAUtagQuest@@H@Z:NEAR	; CMover::GetQuest
EXTRN	?SetQuest@CMover@@QAEHHHPAUtagQuest@@@Z:NEAR	; CMover::SetQuest
EXTRN	?GetJob@CMover@@QAEHXZ:NEAR			; CMover::GetJob
EXTRN	?GetCtrl@CProject@@QAEPAVCCtrl@@K@Z:NEAR	; CProject::GetCtrl
EXTRN	?DoLoot@CMover@@QAEHPAVCItem@@@Z:NEAR		; CMover::DoLoot
EXTRN	?SetActionPlay@CCommonCtrl@@QAEXXZ:NEAR		; CCommonCtrl::SetActionPlay
; Function compile flags: /Ogty
;	COMDAT ?OnMsgArrival@CUser@@QAEXK@Z
_TEXT	SEGMENT
tv888 = -24						; size = 4
tv886 = -24						; size = 4
tv884 = -24						; size = 4
_i$283756 = -24						; size = 4
_quest$283752 = -20					; size = 14
_quest$283747 = -20					; size = 14
_vPos$283741 = -20					; size = 12
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
_dwParam$ = 8						; size = 4
?OnMsgArrival@CUser@@QAEXK@Z PROC NEAR			; CUser::OnMsgArrival, COMDAT
; _this$ = ecx

; 7083 : {

  00000	83 ec 18	 sub	 esp, 24			; 00000018H
  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00008	33 c4		 xor	 eax, esp
  0000a	56		 push	 esi
  0000b	89 44 24 18	 mov	 DWORD PTR __$ArrayPad$[esp+28], eax

; 7084 : 	CCtrl* pObj = prj.GetCtrl( dwParam );

  0000f	8b 44 24 20	 mov	 eax, DWORD PTR _dwParam$[esp+24]
  00013	57		 push	 edi
  00014	8b f9		 mov	 edi, ecx
  00016	50		 push	 eax
  00017	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?prj@@3VCProject@@A
  0001c	e8 00 00 00 00	 call	 ?GetCtrl@CProject@@QAEPAVCCtrl@@K@Z ; CProject::GetCtrl
  00021	8b f0		 mov	 esi, eax

; 7085 : 	if( NULL == pObj )

  00023	85 f6		 test	 esi, esi
  00025	0f 84 51 04 00
	00		 je	 $L283699

; 7086 : 		return;
; 7087 : 
; 7088 : 	if( pObj->GetType() == OT_ITEM )

  0002b	8b 86 70 01 00
	00		 mov	 eax, DWORD PTR [esi+368]
  00031	83 f8 04	 cmp	 eax, 4
  00034	0f 85 8d 00 00
	00		 jne	 $L283686

; 7089 : 	{
; 7090 : 		if( IsFly() )

  0003a	8b 8f 3c 02 00
	00		 mov	 ecx, DWORD PTR [edi+572]
  00040	f6 41 08 08	 test	 BYTE PTR [ecx+8], 8
  00044	0f 85 32 04 00
	00		 jne	 $L283699

; 7091 : 			return;
; 7092 : 
; 7093 : 		if( IsMode( ITEM_MODE ) )

  0004a	8a 87 44 02 00
	00		 mov	 al, BYTE PTR [edi+580]
  00050	84 c0		 test	 al, al
  00052	0f 88 24 04 00
	00		 js	 $L283699

; 7094 : 			return;
; 7095 : 
; 7096 : 		CItem* pItem = (CItem*)pObj;
; 7097 : 
; 7098 : 		//pItem    .
; 7099 : 		if( IsLoot( pItem ) == FALSE )	//    

  00058	6a 00		 push	 0
  0005a	56		 push	 esi
  0005b	8b cf		 mov	 ecx, edi
  0005d	e8 00 00 00 00	 call	 ?IsLoot@CMover@@QAEHPAVCItem@@H@Z ; CMover::IsLoot
  00062	85 c0		 test	 eax, eax
  00064	75 31		 jne	 SHORT $L283692

; 7100 : 		{
; 7101 : 			AddDefinedText( TID_GAME_PRIORITYITEMPER, "\"%s\"", pItem->GetProp()->szName );	// %  .

  00066	8b ce		 mov	 ecx, esi
  00068	e8 00 00 00 00	 call	 ?GetPropA@CItem@@QAEPAUItemProp@@XZ ; CItem::GetPropA
  0006d	83 c0 04	 add	 eax, 4
  00070	50		 push	 eax
  00071	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_04OEDFLLKD@?$CC?$CFs?$CC?$AA@
  00076	68 90 02 00 00	 push	 656			; 00000290H
  0007b	57		 push	 edi
  0007c	e8 00 00 00 00	 call	 ?AddDefinedText@CUser@@QAAXHPBDZZ ; CUser::AddDefinedText
  00081	83 c4 10	 add	 esp, 16			; 00000010H
  00084	5f		 pop	 edi
  00085	5e		 pop	 esi

; 7300 : 		}
; 7301 : 	}
; 7302 : }

  00086	8b 4c 24 14	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+24]
  0008a	33 cc		 xor	 ecx, esp
  0008c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00091	83 c4 18	 add	 esp, 24			; 00000018H
  00094	c2 04 00	 ret	 4
$L283692:

; 7102 : 			return;
; 7103 : 		}
; 7104 : 		//pItem .
; 7105 : 		if( DoLoot( pItem ) == FALSE )

  00097	56		 push	 esi
  00098	8b cf		 mov	 ecx, edi
  0009a	e8 00 00 00 00	 call	 ?DoLoot@CMover@@QAEHPAVCItem@@@Z ; CMover::DoLoot
  0009f	85 c0		 test	 eax, eax
  000a1	0f 84 d5 03 00
	00		 je	 $L283699

; 7106 : 		{
; 7107 : 			return;
; 7108 : 		}
; 7109 : 		g_UserMng.AddMotion( this, OBJMSG_PICKUP );		//  

  000a7	6a 0b		 push	 11			; 0000000bH
  000a9	57		 push	 edi
  000aa	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_UserMng@@3VCUserMng@@A
  000af	e8 00 00 00 00	 call	 ?AddMotion@CUserMng@@QAEXPAVCMover@@K@Z ; CUserMng::AddMotion
  000b4	5f		 pop	 edi
  000b5	5e		 pop	 esi

; 7300 : 		}
; 7301 : 	}
; 7302 : }

  000b6	8b 4c 24 14	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+24]
  000ba	33 cc		 xor	 ecx, esp
  000bc	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000c1	83 c4 18	 add	 esp, 24			; 00000018H
  000c4	c2 04 00	 ret	 4
$L283686:

; 7110 : 	}
; 7111 : 	else
; 7112 : 	if( pObj->GetType() == OT_MOVER )

  000c7	83 f8 05	 cmp	 eax, 5
  000ca	0f 84 ac 03 00
	00		 je	 $L283699

; 7113 : 	{
; 7114 : 	}
; 7115 : 	else if( pObj->GetType() == OT_CTRL )

  000d0	83 f8 02	 cmp	 eax, 2
  000d3	0f 85 a3 03 00
	00		 jne	 $L283699

; 7116 : 	{
; 7117 : 		if( IsValidObj( (CObj*)pObj ) )

  000d9	f6 46 04 01	 test	 BYTE PTR [esi+4], 1
  000dd	0f 85 99 03 00
	00		 jne	 $L283699

; 7118 : 		{
; 7119 : 			CCommonCtrl*  pCommonCtrl = (CCommonCtrl*)pObj;
; 7120 : 			if( !pCommonCtrl )
; 7121 : 				return;
; 7122 : 
; 7123 : 			CItemElem* pKey = NULL;
; 7124 : 
; 7125 : 			//    
; 7126 : 			if( pCommonCtrl->m_CtrlElem.m_dwSet & UA_PLAYER_ID )

  000e3	8a 86 38 02 00
	00		 mov	 al, BYTE PTR [esi+568]
  000e9	84 c0		 test	 al, al
  000eb	53		 push	 ebx
  000ec	55		 push	 ebp
  000ed	79 7e		 jns	 SHORT $L283704

; 7127 : 			{
; 7128 : 				if( m_idPlayer != pCommonCtrl->m_idExpPlayer )

  000ef	8b 97 38 02 00
	00		 mov	 edx, DWORD PTR [edi+568]
  000f5	3b 96 40 04 00
	00		 cmp	 edx, DWORD PTR [esi+1088]
  000fb	74 11		 je	 SHORT $L283705

; 7129 : 				{
; 7130 : 					AddDefinedText( TID_GAME_NOT_EXPBOX );

  000fd	68 f6 0b 00 00	 push	 3062			; 00000bf6H
  00102	8b cf		 mov	 ecx, edi
  00104	e8 00 00 00 00	 call	 ?AddDefinedText@CUser@@QAEXH@Z ; CUser::AddDefinedText

; 7131 : 					AddClearTarget(); //Focus Ctrl  .
; 7132 : 					return;

  00109	e9 65 03 00 00	 jmp	 $L333639
$L283705:

; 7133 : 				}
; 7134 : 
; 7135 : 				if( pCommonCtrl->m_bAction == TRUE )

  0010e	83 be 28 04 00
	00 01		 cmp	 DWORD PTR [esi+1064], 1

; 7136 : 				{
; 7137 : 					AddClearTarget(); //Focus Ctrl  .
; 7138 : 					return;

  00115	0f 84 58 03 00
	00		 je	 $L333639

; 7139 : 				}		
; 7140 : 				
; 7141 : 				if( pCommonCtrl->m_dwCtrlReadyTime != 0xffffffff )

  0011b	83 be 2c 04 00
	00 ff		 cmp	 DWORD PTR [esi+1068], -1

; 7142 : 				{
; 7143 : 					AddClearTarget(); //Focus Ctrl  .
; 7144 : 					return;

  00122	0f 85 4b 03 00
	00		 jne	 $L333639

; 7145 : 				}
; 7146 : 				
; 7147 : 				pCommonCtrl->m_dwCtrlReadyTime = timeGetTime() + OPEN_COOLTIME;

  00128	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR __imp__timeGetTime@0
  0012e	ff d5		 call	 ebp
  00130	05 10 27 00 00	 add	 eax, 10000		; 00002710H
  00135	89 86 2c 04 00
	00		 mov	 DWORD PTR [esi+1068], eax

; 7148 : 				m_dwCtrlReadyTime        = timeGetTime() + OPEN_COOLTIME;

  0013b	ff d5		 call	 ebp
  0013d	05 10 27 00 00	 add	 eax, 10000		; 00002710H
  00142	89 87 94 06 00
	00		 mov	 DWORD PTR [edi+1684], eax

; 7149 : 				m_dwCtrlReadyId  = pCommonCtrl->GetId();						

  00148	8b 86 bc 01 00
	00		 mov	 eax, DWORD PTR [esi+444]
  0014e	89 87 98 06 00
	00		 mov	 DWORD PTR [edi+1688], eax

; 7150 : 				
; 7151 : 				AddExpBoxCoolTime( pCommonCtrl->GetId(), pCommonCtrl->m_dwCtrlReadyTime - timeGetTime() );

  00154	8b 9e bc 01 00
	00		 mov	 ebx, DWORD PTR [esi+444]
  0015a	ff d5		 call	 ebp
  0015c	8b 8e 2c 04 00
	00		 mov	 ecx, DWORD PTR [esi+1068]
  00162	2b c8		 sub	 ecx, eax
  00164	51		 push	 ecx
  00165	53		 push	 ebx
  00166	8b cf		 mov	 ecx, edi
  00168	e8 00 00 00 00	 call	 ?AddExpBoxCoolTime@CUser@@QAEXKK@Z ; CUser::AddExpBoxCoolTime
$L283704:

; 7152 : 			}
; 7153 : 
; 7154 : 			if( pCommonCtrl->m_CtrlElem.m_dwSet & UA_ITEM )

  0016d	f6 86 38 02 00
	00 01		 test	 BYTE PTR [esi+568], 1
  00174	74 6e		 je	 SHORT $L333632

; 7155 : 			{
; 7156 : 				//        
; 7157 : 				BOOL bResult = FALSE;
; 7158 : 				pKey = m_Inventory.GetAtItemId( pCommonCtrl->m_CtrlElem.m_dwSetItem );

  00176	8b 96 3c 02 00
	00		 mov	 edx, DWORD PTR [esi+572]
  0017c	8d af 90 0b 00
	00		 lea	 ebp, DWORD PTR [edi+2960]
  00182	52		 push	 edx
  00183	8b cd		 mov	 ecx, ebp
  00185	e8 00 00 00 00	 call	 ?GetAtItemId@?$CItemContainer@VCItemElem@@@@QAEPAVCItemElem@@K@Z ; CItemContainer<CItemElem>::GetAtItemId

; 7159 : 				if( IsUsableItem( pKey ) )

  0018a	50		 push	 eax
  0018b	e8 00 00 00 00	 call	 ?IsUsableItem@@YAHPAVCItemBase@@@Z ; IsUsableItem
  00190	83 c4 04	 add	 esp, 4
  00193	85 c0		 test	 eax, eax
  00195	74 16		 je	 SHORT $L283712

; 7160 : 				{
; 7161 : 					int nItemCount = m_Inventory.GetAtItemNum( pCommonCtrl->m_CtrlElem.m_dwSetItem );	//   						

  00197	8b 86 3c 02 00
	00		 mov	 eax, DWORD PTR [esi+572]
  0019d	50		 push	 eax
  0019e	8b cd		 mov	 ecx, ebp
  001a0	e8 00 00 00 00	 call	 ?GetAtItemNum@?$CItemContainer@VCItemElem@@@@QAEHK@Z ; CItemContainer<CItemElem>::GetAtItemNum

; 7162 : 					if( nItemCount < (int)( pCommonCtrl->m_CtrlElem.m_dwSetItemCount ) && pCommonCtrl->m_CtrlElem.m_dwSetEndu == 0 )	

  001a5	3b 86 d4 03 00
	00		 cmp	 eax, DWORD PTR [esi+980]
  001ab	7d 37		 jge	 SHORT $L333632
$L283712:

; 7163 : 						bResult = TRUE;
; 7164 : 				}
; 7165 : 				else
; 7166 : 				{
; 7167 : 					if( pCommonCtrl->m_CtrlElem.m_dwSetEndu == 0 )

  001ad	8b 86 d0 02 00
	00		 mov	 eax, DWORD PTR [esi+720]
  001b3	85 c0		 test	 eax, eax
  001b5	75 2d		 jne	 SHORT $L333632

; 7168 : 						bResult = TRUE;
; 7169 : 				}
; 7170 : 				
; 7171 : 				if( bResult )
; 7172 : 				{
; 7173 : 					AddDefinedText( TID_ITEMBOX_MESSAGE1, "\"%s\"", prj.GetItemProp(pCommonCtrl->m_CtrlElem.m_dwSetItem)->szName );

  001b7	8b 8e 3c 02 00
	00		 mov	 ecx, DWORD PTR [esi+572]
  001bd	51		 push	 ecx
  001be	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?prj@@3VCProject@@A
  001c3	e8 00 00 00 00	 call	 ?GetItemProp@CProject@@QAEPAUItemProp@@H@Z ; CProject::GetItemProp
  001c8	83 c0 04	 add	 eax, 4
  001cb	50		 push	 eax
  001cc	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_04OEDFLLKD@?$CC?$CFs?$CC?$AA@
  001d1	68 66 09 00 00	 push	 2406			; 00000966H

; 7207 : 							AddDefinedText( TID_ITEMBOX_MESSAGE4, "\"%s\"", pQuestPorp->m_szTitle );

  001d6	57		 push	 edi
  001d7	e8 00 00 00 00	 call	 ?AddDefinedText@CUser@@QAAXHPBDZZ ; CUser::AddDefinedText
  001dc	83 c4 10	 add	 esp, 16			; 00000010H

; 7208 : 
; 7209 : 						AddClearTarget(); //Focus Ctrl  .
; 7210 : 						return;

  001df	e9 8f 02 00 00	 jmp	 $L333639
$L333632:

; 7174 : 					AddClearTarget(); //Focus Ctrl  .
; 7175 : 					return;
; 7176 : 				}							
; 7177 : 			}
; 7178 : 			if( pCommonCtrl->m_CtrlElem.m_dwSet & UA_LEVEL )

  001e4	8b 86 38 02 00
	00		 mov	 eax, DWORD PTR [esi+568]
  001ea	a8 02		 test	 al, 2
  001ec	74 1f		 je	 SHORT $L283721

; 7179 : 			{
; 7180 : 				if( GetLevel() < (int)( pCommonCtrl->m_CtrlElem.m_dwSetLevel ) )

  001ee	8b 97 e0 05 00
	00		 mov	 edx, DWORD PTR [edi+1504]
  001f4	3b 96 40 02 00
	00		 cmp	 edx, DWORD PTR [esi+576]
  001fa	7d 11		 jge	 SHORT $L283721

; 7181 : 				{
; 7182 : 					AddDefinedText( TID_ITEMBOX_MESSAGE2 );

  001fc	68 67 09 00 00	 push	 2407			; 00000967H
  00201	8b cf		 mov	 ecx, edi
  00203	e8 00 00 00 00	 call	 ?AddDefinedText@CUser@@QAEXH@Z ; CUser::AddDefinedText

; 7183 : 					AddClearTarget(); //Focus Ctrl  .
; 7184 : 					return;

  00208	e9 66 02 00 00	 jmp	 $L333639
$L283721:

; 7185 : 				}
; 7186 : 			}
; 7187 : 			if( pCommonCtrl->m_CtrlElem.m_dwSet & UA_QUEST )

  0020d	a8 04		 test	 al, 4
  0020f	74 59		 je	 SHORT $L283728

; 7188 : 			{
; 7189 : 				LPQUEST pQuest = GetQuest( pCommonCtrl->m_CtrlElem.m_dwSetQuestNum );

  00211	8b 86 44 02 00
	00		 mov	 eax, DWORD PTR [esi+580]
  00217	50		 push	 eax
  00218	8b cf		 mov	 ecx, edi
  0021a	e8 00 00 00 00	 call	 ?GetQuest@CMover@@QAEPAUtagQuest@@H@Z ; CMover::GetQuest

; 7190 : 
; 7191 : 				if( pQuest )

  0021f	85 c0		 test	 eax, eax
  00221	74 12		 je	 SHORT $L283724

; 7192 : 				{
; 7193 : 					if( pQuest->m_nState != pCommonCtrl->m_CtrlElem.m_dwSetFlagNum )

  00223	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00226	3b 8e 48 02 00
	00		 cmp	 ecx, DWORD PTR [esi+584]
  0022c	74 3c		 je	 SHORT $L283728

; 7194 : 					{
; 7195 : 						QuestProp * pQuestPorp = prj.m_aPropQuest.GetAt( pQuest->m_wId );

  0022e	0f b7 50 04	 movzx	 edx, WORD PTR [eax+4]
  00232	52		 push	 edx

; 7196 : 						if( pQuestPorp )
; 7197 : 							AddDefinedText( TID_ITEMBOX_MESSAGE4, "\"%s\"", pQuestPorp->m_szTitle );
; 7198 : 
; 7199 : 						AddClearTarget(); //Focus Ctrl  .
; 7200 : 						return;

  00233	eb 07		 jmp	 SHORT $L333641
$L283724:

; 7201 : 					}
; 7202 : 				}
; 7203 : 				else
; 7204 : 				{
; 7205 : 						QuestProp * pQuestPorp = prj.m_aPropQuest.GetAt( pCommonCtrl->m_CtrlElem.m_dwSetQuestNum );

  00235	8b 86 44 02 00
	00		 mov	 eax, DWORD PTR [esi+580]
  0023b	50		 push	 eax
$L333641:
  0023c	b9 f8 02 00 00	 mov	 ecx, OFFSET FLAT:?prj@@3VCProject@@A+760
  00241	e8 00 00 00 00	 call	 ?GetAt@?$CFixedArray@UQuestProp@@@@QAEPAUQuestProp@@K@Z ; CFixedArray<QuestProp>::GetAt

; 7206 : 						if( pQuestPorp )

  00246	85 c0		 test	 eax, eax
  00248	0f 84 25 02 00
	00		 je	 $L333639

; 7207 : 							AddDefinedText( TID_ITEMBOX_MESSAGE4, "\"%s\"", pQuestPorp->m_szTitle );

  0024e	83 c0 02	 add	 eax, 2
  00251	50		 push	 eax
  00252	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_04OEDFLLKD@?$CC?$CFs?$CC?$AA@
  00257	68 69 09 00 00	 push	 2409			; 00000969H
  0025c	57		 push	 edi
  0025d	e8 00 00 00 00	 call	 ?AddDefinedText@CUser@@QAAXHPBDZZ ; CUser::AddDefinedText
  00262	83 c4 10	 add	 esp, 16			; 00000010H

; 7208 : 
; 7209 : 						AddClearTarget(); //Focus Ctrl  .
; 7210 : 						return;

  00265	e9 09 02 00 00	 jmp	 $L333639
$L283728:

; 7211 : 				}
; 7212 : 			}
; 7213 : 			if( pCommonCtrl->m_CtrlElem.m_dwSet & UA_CLASS )

  0026a	8a 86 38 02 00
	00		 mov	 al, BYTE PTR [esi+568]
  00270	b3 08		 mov	 bl, 8
  00272	84 c3		 test	 al, bl
  00274	74 2a		 je	 SHORT $L283732

; 7214 : 			{
; 7215 : 				if( GetJob() != pCommonCtrl->m_CtrlElem.m_bSetJob[GetJob()] )

  00276	8b cf		 mov	 ecx, edi
  00278	e8 00 00 00 00	 call	 ?GetJob@CMover@@QAEHXZ	; CMover::GetJob
  0027d	8b cf		 mov	 ecx, edi
  0027f	8b e8		 mov	 ebp, eax
  00281	e8 00 00 00 00	 call	 ?GetJob@CMover@@QAEHXZ	; CMover::GetJob
  00286	3b 84 ae 50 02
	00 00		 cmp	 eax, DWORD PTR [esi+ebp*4+592]
  0028d	74 11		 je	 SHORT $L283732

; 7216 : 				{
; 7217 : 					AddDefinedText( TID_ITEMBOX_MESSAGE5 );

  0028f	68 6a 09 00 00	 push	 2410			; 0000096aH
  00294	8b cf		 mov	 ecx, edi
  00296	e8 00 00 00 00	 call	 ?AddDefinedText@CUser@@QAEXH@Z ; CUser::AddDefinedText

; 7218 : 					AddClearTarget(); //Focus Ctrl  .
; 7219 : 					return;

  0029b	e9 d3 01 00 00	 jmp	 $L333639
$L283732:

; 7220 : 				}
; 7221 : 			}
; 7222 : 			if( pCommonCtrl->m_CtrlElem.m_dwSet & UA_GENDER )

  002a0	8b 86 38 02 00
	00		 mov	 eax, DWORD PTR [esi+568]
  002a6	a8 10		 test	 al, 16			; 00000010H
  002a8	74 20		 je	 SHORT $L283734

; 7223 : 			{
; 7224 : 				if( GetSex() != pCommonCtrl->m_CtrlElem.m_dwSetGender )

  002aa	0f b6 8f 20 06
	00 00		 movzx	 ecx, BYTE PTR [edi+1568]
  002b1	3b 8e 4c 02 00
	00		 cmp	 ecx, DWORD PTR [esi+588]
  002b7	74 11		 je	 SHORT $L283734

; 7225 : 				{
; 7226 : 					AddDefinedText( TID_ITEMBOX_MESSAGE3 );

  002b9	68 68 09 00 00	 push	 2408			; 00000968H
  002be	8b cf		 mov	 ecx, edi
  002c0	e8 00 00 00 00	 call	 ?AddDefinedText@CUser@@QAEXH@Z ; CUser::AddDefinedText

; 7227 : 					AddClearTarget(); //Focus Ctrl  .
; 7228 : 					return;

  002c5	e9 a9 01 00 00	 jmp	 $L333639
$L283734:

; 7229 : 				}
; 7230 : 			}
; 7231 : 
; 7232 : 			if( this )	// ??

  002ca	85 ff		 test	 edi, edi
  002cc	74 0c		 je	 SHORT $L283735

; 7233 : 				pCommonCtrl->m_nMoverID = GetId();

  002ce	8b 97 bc 01 00
	00		 mov	 edx, DWORD PTR [edi+444]
  002d4	89 96 34 02 00
	00		 mov	 DWORD PTR [esi+564], edx
$L283735:

; 7234 : 		
; 7235 : 			if( pCommonCtrl->m_CtrlElem.m_dwSet & UA_TELEPORT )

  002da	a8 20		 test	 al, 32			; 00000020H
  002dc	0f 84 84 00 00
	00		 je	 $L283742

; 7236 : 			{
; 7237 : 				if( IsFly() == FALSE )

  002e2	8b 87 3c 02 00
	00		 mov	 eax, DWORD PTR [edi+572]
  002e8	84 58 08	 test	 BYTE PTR [eax+8], bl
  002eb	75 6d		 jne	 SHORT $L283737

; 7238 : 				{
; 7239 : 					D3DXVECTOR3 vPos( (float)( pCommonCtrl->m_CtrlElem.m_dwTeleX ), (float)( pCommonCtrl->m_CtrlElem.m_dwTeleY ), (float)( pCommonCtrl->m_CtrlElem.m_dwTeleZ ) );

  002ed	8b 8e dc 03 00
	00		 mov	 ecx, DWORD PTR [esi+988]
  002f3	db 86 dc 03 00
	00		 fild	 DWORD PTR [esi+988]
  002f9	85 c9		 test	 ecx, ecx
  002fb	7d 06		 jge	 SHORT $L333636
  002fd	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$L333636:
  00303	8b 96 e0 03 00
	00		 mov	 edx, DWORD PTR [esi+992]
  00309	d9 5c 24 14	 fstp	 DWORD PTR _vPos$283741[esp+40]
  0030d	85 d2		 test	 edx, edx
  0030f	db 86 e0 03 00
	00		 fild	 DWORD PTR [esi+992]
  00315	7d 06		 jge	 SHORT $L333637
  00317	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$L333637:
  0031d	8b 86 e4 03 00
	00		 mov	 eax, DWORD PTR [esi+996]
  00323	d9 5c 24 18	 fstp	 DWORD PTR _vPos$283741[esp+44]
  00327	85 c0		 test	 eax, eax
  00329	db 86 e4 03 00
	00		 fild	 DWORD PTR [esi+996]
  0032f	7d 06		 jge	 SHORT $L333638
  00331	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$L333638:

; 7240 : 					REPLACE( g_uIdofMulti, pCommonCtrl->m_CtrlElem.m_dwTeleWorldId, vPos, REPLACE_NORMAL, nTempLayer );

  00337	8b 96 d8 03 00
	00		 mov	 edx, DWORD PTR [esi+984]
  0033d	d9 5c 24 1c	 fstp	 DWORD PTR _vPos$283741[esp+48]
  00341	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_uIdofMulti@@3KA ; g_uIdofMulti
  00346	6a 00		 push	 0
  00348	6a 00		 push	 0
  0034a	8d 4c 24 1c	 lea	 ecx, DWORD PTR _vPos$283741[esp+48]
  0034e	51		 push	 ecx
  0034f	52		 push	 edx
  00350	50		 push	 eax
  00351	8b cf		 mov	 ecx, edi
  00353	e8 00 00 00 00	 call	 ?Replace@CMover@@QAEHKKAAUD3DXVECTOR3@@W4REPLACE_TYPE@@H@Z ; CMover::Replace

; 7241 : 				}
; 7242 : 				else

  00358	eb 0c		 jmp	 SHORT $L283742
$L283737:

; 7243 : 				{
; 7244 : 					AddDefinedText( TID_PK_NO_FLIGHTAREA );

  0035a	68 ba 09 00 00	 push	 2490			; 000009baH
  0035f	8b cf		 mov	 ecx, edi
  00361	e8 00 00 00 00	 call	 ?AddDefinedText@CUser@@QAEXH@Z ; CUser::AddDefinedText
$L283742:

; 7245 : 				}
; 7246 : 			}
; 7247 : 			// 
; 7248 : 			if( pCommonCtrl->m_CtrlElem.m_dwSet & UA_QUEST_END )

  00366	f6 86 38 02 00
	00 40		 test	 BYTE PTR [esi+568], 64	; 00000040H
  0036d	74 7c		 je	 SHORT $L283753

; 7249 : 			{
; 7250 : 				if( pCommonCtrl->m_CtrlElem.m_dwSetQuestNum1 != 0 )

  0036f	8b 86 c4 03 00
	00		 mov	 eax, DWORD PTR [esi+964]
  00375	85 c0		 test	 eax, eax
  00377	74 34		 je	 SHORT $L283748

; 7251 : 				{
; 7252 : 					LPQUEST pQuest = GetQuest( pCommonCtrl->m_CtrlElem.m_dwSetQuestNum1 );

  00379	50		 push	 eax
  0037a	8b cf		 mov	 ecx, edi
  0037c	e8 00 00 00 00	 call	 ?GetQuest@CMover@@QAEPAUtagQuest@@H@Z ; CMover::GetQuest

; 7253 : 					if( pQuest )

  00381	85 c0		 test	 eax, eax
  00383	74 28		 je	 SHORT $L283748

; 7254 : 					{
; 7255 : 						QUEST quest;
; 7256 : 						if( SetQuest( pQuest->m_wId, pCommonCtrl->m_CtrlElem.m_dwSetFlagNum1, &quest ) )

  00385	8b 96 c8 03 00
	00		 mov	 edx, DWORD PTR [esi+968]
  0038b	0f b7 40 04	 movzx	 eax, WORD PTR [eax+4]
  0038f	8d 4c 24 14	 lea	 ecx, DWORD PTR _quest$283747[esp+40]
  00393	51		 push	 ecx
  00394	52		 push	 edx
  00395	50		 push	 eax
  00396	8b cf		 mov	 ecx, edi
  00398	e8 00 00 00 00	 call	 ?SetQuest@CMover@@QAEHHHPAUtagQuest@@@Z ; CMover::SetQuest
  0039d	85 c0		 test	 eax, eax
  0039f	74 0c		 je	 SHORT $L283748

; 7257 : 						{
; 7258 : 							AddSetQuest( &quest );

  003a1	8d 4c 24 14	 lea	 ecx, DWORD PTR _quest$283747[esp+40]
  003a5	51		 push	 ecx
  003a6	8b cf		 mov	 ecx, edi
  003a8	e8 00 00 00 00	 call	 ?AddSetQuest@CUser@@QAEXPAUtagQuest@@@Z ; CUser::AddSetQuest
$L283748:

; 7259 : 						}
; 7260 : 					}
; 7261 : 				}
; 7262 : 				if( pCommonCtrl->m_CtrlElem.m_dwSetQuestNum2 != 0 )

  003ad	8b 86 cc 03 00
	00		 mov	 eax, DWORD PTR [esi+972]
  003b3	85 c0		 test	 eax, eax
  003b5	74 34		 je	 SHORT $L283753

; 7263 : 				{
; 7264 : 					LPQUEST pQuest = GetQuest( pCommonCtrl->m_CtrlElem.m_dwSetQuestNum2 );

  003b7	50		 push	 eax
  003b8	8b cf		 mov	 ecx, edi
  003ba	e8 00 00 00 00	 call	 ?GetQuest@CMover@@QAEPAUtagQuest@@H@Z ; CMover::GetQuest

; 7265 : 					if( pQuest )

  003bf	85 c0		 test	 eax, eax
  003c1	74 28		 je	 SHORT $L283753

; 7266 : 					{
; 7267 : 						QUEST quest;
; 7268 : 						if( SetQuest( pQuest->m_wId, pCommonCtrl->m_CtrlElem.m_dwSetFlagNum2, &quest ) )

  003c3	8b 8e d0 03 00
	00		 mov	 ecx, DWORD PTR [esi+976]
  003c9	8d 54 24 14	 lea	 edx, DWORD PTR _quest$283752[esp+40]
  003cd	52		 push	 edx
  003ce	0f b7 50 04	 movzx	 edx, WORD PTR [eax+4]
  003d2	51		 push	 ecx
  003d3	52		 push	 edx
  003d4	8b cf		 mov	 ecx, edi
  003d6	e8 00 00 00 00	 call	 ?SetQuest@CMover@@QAEHHHPAUtagQuest@@@Z ; CMover::SetQuest
  003db	85 c0		 test	 eax, eax
  003dd	74 0c		 je	 SHORT $L283753

; 7269 : 						{
; 7270 : 							AddSetQuest( &quest );

  003df	8d 44 24 14	 lea	 eax, DWORD PTR _quest$283752[esp+40]
  003e3	50		 push	 eax
  003e4	8b cf		 mov	 ecx, edi
  003e6	e8 00 00 00 00	 call	 ?AddSetQuest@CUser@@QAEXPAUtagQuest@@@Z ; CUser::AddSetQuest
$L283753:

; 7271 : 						}
; 7272 : 					}
; 7273 : 				}
; 7274 : 			}
; 7275 : 
; 7276 : 			//  
; 7277 : 			if( pCommonCtrl->m_CtrlElem.m_dwSet & UA_ITEM )

  003eb	f6 86 38 02 00
	00 01		 test	 BYTE PTR [esi+568], 1
  003f2	74 78		 je	 SHORT $L283759

; 7278 : 			{
; 7279 : 				int nItemCount = pCommonCtrl->m_CtrlElem.m_dwSetItemCount;

  003f4	8b ae d4 03 00
	00		 mov	 ebp, DWORD PTR [esi+980]

; 7280 : 				for( int i = 0; i < 10 && nItemCount > 0; ++i )

  003fa	c7 44 24 10 00
	00 00 00	 mov	 DWORD PTR _i$283756[esp+40], 0
$L333631:
  00402	85 ed		 test	 ebp, ebp
  00404	7e 66		 jle	 SHORT $L283759

; 7281 : 				{
; 7282 : 					pKey = m_Inventory.GetAtItemId( pCommonCtrl->m_CtrlElem.m_dwSetItem );

  00406	8b 8e 3c 02 00
	00		 mov	 ecx, DWORD PTR [esi+572]
  0040c	51		 push	 ecx
  0040d	8d 8f 90 0b 00
	00		 lea	 ecx, DWORD PTR [edi+2960]
  00413	e8 00 00 00 00	 call	 ?GetAtItemId@?$CItemContainer@VCItemElem@@@@QAEPAVCItemElem@@K@Z ; CItemContainer<CItemElem>::GetAtItemId
  00418	8b d8		 mov	 ebx, eax

; 7283 : 					if( IsUsableItem( pKey ) )

  0041a	53		 push	 ebx
  0041b	e8 00 00 00 00	 call	 ?IsUsableItem@@YAHPAVCItemBase@@@Z ; IsUsableItem
  00420	83 c4 04	 add	 esp, 4
  00423	85 c0		 test	 eax, eax
  00425	74 37		 je	 SHORT $L283758

; 7284 : 					{
; 7285 : 						if( nItemCount <= pKey->m_nItemNum )

  00427	66 8b 83 80 00
	00 00		 mov	 ax, WORD PTR [ebx+128]
  0042e	0f bf d0	 movsx	 edx, ax
  00431	3b ea		 cmp	 ebp, edx
  00433	7f 12		 jg	 SHORT $L283761

; 7286 : 						{
; 7287 : 							RemoveItem( (BYTE)pKey->m_dwObjId, (short)nItemCount );

  00435	33 c0		 xor	 eax, eax
  00437	8a 43 04	 mov	 al, BYTE PTR [ebx+4]
  0043a	55		 push	 ebp
  0043b	8b cf		 mov	 ecx, edi
  0043d	50		 push	 eax
  0043e	e8 00 00 00 00	 call	 ?RemoveItem@CMover@@QAEXEF@Z ; CMover::RemoveItem

; 7288 : 							nItemCount = 0;

  00443	33 ed		 xor	 ebp, ebp

; 7289 : 						}
; 7290 : 						else

  00445	eb 17		 jmp	 SHORT $L283758
$L283761:

; 7291 : 						{
; 7292 : 							RemoveItem( (BYTE)pKey->m_dwObjId, (short)pKey->m_nItemNum );

  00447	33 c9		 xor	 ecx, ecx
  00449	8a 4b 04	 mov	 cl, BYTE PTR [ebx+4]
  0044c	50		 push	 eax
  0044d	51		 push	 ecx
  0044e	8b cf		 mov	 ecx, edi
  00450	e8 00 00 00 00	 call	 ?RemoveItem@CMover@@QAEXEF@Z ; CMover::RemoveItem

; 7293 : 							nItemCount -= pKey->m_nItemNum;

  00455	0f bf 93 80 00
	00 00		 movsx	 edx, WORD PTR [ebx+128]
  0045c	2b ea		 sub	 ebp, edx
$L283758:
  0045e	8b 44 24 10	 mov	 eax, DWORD PTR _i$283756[esp+40]
  00462	40		 inc	 eax
  00463	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  00466	89 44 24 10	 mov	 DWORD PTR _i$283756[esp+40], eax
  0046a	7c 96		 jl	 SHORT $L333631
$L283759:

; 7294 : 						}							
; 7295 : 					}
; 7296 : 				}
; 7297 : 			}
; 7298 : 			pCommonCtrl->SetActionPlay();

  0046c	8b ce		 mov	 ecx, esi
  0046e	e8 00 00 00 00	 call	 ?SetActionPlay@CCommonCtrl@@QAEXXZ ; CCommonCtrl::SetActionPlay
$L333639:

; 7299 : 			AddClearTarget();

  00473	8b cf		 mov	 ecx, edi
  00475	e8 00 00 00 00	 call	 ?AddClearTarget@CUser@@QAEXXZ ; CUser::AddClearTarget
  0047a	5d		 pop	 ebp
  0047b	5b		 pop	 ebx
$L283699:

; 7300 : 		}
; 7301 : 	}
; 7302 : }

  0047c	8b 4c 24 1c	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+32]
  00480	5f		 pop	 edi
  00481	5e		 pop	 esi
  00482	33 cc		 xor	 ecx, esp
  00484	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00489	83 c4 18	 add	 esp, 24			; 00000018H
  0048c	c2 04 00	 ret	 4
?OnMsgArrival@CUser@@QAEXK@Z ENDP			; CUser::OnMsgArrival
_TEXT	ENDS
PUBLIC	?CheckFiniteItem@CUser@@QAEXXZ			; CUser::CheckFiniteItem
EXTRN	?ResetDestParamEquip@CMover@@QAEXPAUItemProp@@PAVCItemElem@@@Z:NEAR ; CMover::ResetDestParamEquip
EXTRN	?InactivateEatPet@CMover@@QAEXXZ:NEAR		; CMover::InactivateEatPet
EXTRN	?IsUsingEatPet@CMover@@QAEHPAVCItemElem@@@Z:NEAR ; CMover::IsUsingEatPet
; Function compile flags: /Ogty
;	COMDAT ?CheckFiniteItem@CUser@@QAEXXZ
_TEXT	SEGMENT
?CheckFiniteItem@CUser@@QAEXXZ PROC NEAR		; CUser::CheckFiniteItem, COMDAT
; _this$ = ecx

; 7306 : {

  00000	55		 push	 ebp
  00001	57		 push	 edi
  00002	8b f9		 mov	 edi, ecx

; 7307 : 	for( int i = 0; i < m_Inventory.GetMax(); i++ )

  00004	8b 87 9c 0b 00
	00		 mov	 eax, DWORD PTR [edi+2972]
  0000a	33 ed		 xor	 ebp, ebp
  0000c	85 c0		 test	 eax, eax
  0000e	0f 8e 41 01 00
	00		 jle	 $L283773
  00014	53		 push	 ebx
  00015	33 db		 xor	 ebx, ebx
  00017	56		 push	 esi

; 7308 : 	{
; 7309 : 		CItemElem* pItemElem	= m_Inventory.GetAtId( i );

  00018	3b e8		 cmp	 ebp, eax
$L333759:
  0001a	0f 83 1e 01 00
	00		 jae	 $L283772
  00020	8b b7 a0 0b 00
	00		 mov	 esi, DWORD PTR [edi+2976]
  00026	8b 44 1e 0c	 mov	 eax, DWORD PTR [esi+ebx+12]
  0002a	03 f3		 add	 esi, ebx
  0002c	85 c0		 test	 eax, eax
  0002e	0f 84 0a 01 00
	00		 je	 $L283772

; 7310 : 		if( pItemElem && pItemElem->IsExpiring() && !pItemElem->IsFlag( CItemElem::expired ) )

  00034	8b 86 b0 00 00
	00		 mov	 eax, DWORD PTR [esi+176]
  0003a	85 c0		 test	 eax, eax
  0003c	0f 84 fc 00 00
	00		 je	 $L283772
  00042	39 05 00 00 00
	00		 cmp	 DWORD PTR ?g_tCurrent@@3JA, eax ; g_tCurrent
  00048	0f 8e f0 00 00
	00		 jle	 $L283772
  0004e	f6 86 82 00 00
	00 01		 test	 BYTE PTR [esi+130], 1
  00055	0f 85 e3 00 00
	00		 jne	 $L283772

; 7311 : 		{
; 7312 : 			if( pItemElem->IsEatPet() )

  0005b	8b ce		 mov	 ecx, esi
  0005d	e8 00 00 00 00	 call	 ?IsEatPet@CItemElem@@QAEHXZ ; CItemElem::IsEatPet
  00062	85 c0		 test	 eax, eax
  00064	74 2b		 je	 SHORT $L283776

; 7313 : 			{
; 7314 : 				if( IsUsingEatPet( pItemElem ) )

  00066	56		 push	 esi
  00067	8b cf		 mov	 ecx, edi
  00069	e8 00 00 00 00	 call	 ?IsUsingEatPet@CMover@@QAEHPAVCItemElem@@@Z ; CMover::IsUsingEatPet
  0006e	85 c0		 test	 eax, eax
  00070	74 07		 je	 SHORT $L283777

; 7315 : 					InactivateEatPet();

  00072	8b cf		 mov	 ecx, edi
  00074	e8 00 00 00 00	 call	 ?InactivateEatPet@CMover@@QAEXXZ ; CMover::InactivateEatPet
$L283777:

; 7316 : 				UpdateItem( (BYTE)( pItemElem->m_dwObjId ), UI_NUM, 0 );

  00079	33 c0		 xor	 eax, eax
  0007b	8a 46 04	 mov	 al, BYTE PTR [esi+4]
  0007e	6a 00		 push	 0
  00080	6a 00		 push	 0
  00082	6a 00		 push	 0
  00084	8b cf		 mov	 ecx, edi
  00086	50		 push	 eax
  00087	e8 00 00 00 00	 call	 ?UpdateItem@CMover@@QAEXEDKK@Z ; CMover::UpdateItem

; 7317 : 			}
; 7318 : 			else

  0008c	e9 ad 00 00 00	 jmp	 $L283772
$L283776:

; 7319 : 			{
; 7320 : 				ItemProp* pItemProp		= pItemElem->GetProp();

  00091	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00094	85 c0		 test	 eax, eax
  00096	8b 0d 5c 02 00
	00		 mov	 ecx, DWORD PTR ?prj@@3VCProject@@A+604
  0009c	7c 11		 jl	 SHORT $L333733
  0009e	3b c1		 cmp	 eax, ecx
  000a0	7d 0d		 jge	 SHORT $L333733
  000a2	73 21		 jae	 SHORT $L333760
  000a4	8b 0d 4c 02 00
	00		 mov	 ecx, DWORD PTR ?prj@@3VCProject@@A+588
  000aa	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  000ad	eb 18		 jmp	 SHORT $L333728
$L333733:
  000af	50		 push	 eax
  000b0	51		 push	 ecx
  000b1	6a 00		 push	 0
  000b3	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BI@BEIFNGEL@GetItemProp?5range_error?$AA@
  000b8	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@HMFGHCP@?$CFs?5min?3?$CFd?0?5max?3?$CFd?0?5index?3?$CFd?$AA@
  000bd	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  000c2	83 c4 14	 add	 esp, 20			; 00000014H
$L333760:
  000c5	33 c0		 xor	 eax, eax
$L333728:

; 7321 : #ifdef 	__BLADELWEAPON0608	//	9th               
; 7322 : 				if( pItemElem->m_dwObjIndex >= m_Inventory.GetSize() &&
; 7323 : 					(pItemElem->m_dwObjIndex - m_Inventory.GetSize() ) != PARTS_LWEAPON  )	// equiped item
; 7324 : 					ResetDestParamEquip( pItemProp, pItemElem );
; 7325 : #else //__BLADELWEAPON0608	//	9th               
; 7326 : 				if( (int)( pItemElem->m_dwObjIndex ) >= (int)( m_Inventory.GetSize() ) )	// equiped item

  000c7	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  000ca	3b 97 98 0b 00
	00		 cmp	 edx, DWORD PTR [edi+2968]
  000d0	7c 09		 jl	 SHORT $L283783

; 7327 : 					ResetDestParamEquip( pItemProp, pItemElem );

  000d2	56		 push	 esi
  000d3	50		 push	 eax
  000d4	8b cf		 mov	 ecx, edi
  000d6	e8 00 00 00 00	 call	 ?ResetDestParamEquip@CMover@@QAEXPAUItemProp@@PAVCItemElem@@@Z ; CMover::ResetDestParamEquip
$L283783:

; 7328 : #endif	//__BLADELWEAPON0608	//	9th               
; 7329 : 
; 7330 : 				pItemElem->SetFlag( CItemElem::expired );

  000db	8a 86 82 00 00
	00		 mov	 al, BYTE PTR [esi+130]

; 7331 : 				UpdateItem( (BYTE)( pItemElem->m_dwObjId ), UI_FLAG, MAKELONG( pItemElem->m_dwObjIndex, pItemElem->m_byFlag ) );

  000e1	0f b7 4e 08	 movzx	 ecx, WORD PTR [esi+8]
  000e5	0c 01		 or	 al, 1
  000e7	88 86 82 00 00
	00		 mov	 BYTE PTR [esi+130], al
  000ed	0f b6 c0	 movzx	 eax, al
  000f0	33 d2		 xor	 edx, edx
  000f2	8a 56 04	 mov	 dl, BYTE PTR [esi+4]
  000f5	6a 00		 push	 0
  000f7	c1 e0 10	 shl	 eax, 16			; 00000010H
  000fa	0b c1		 or	 eax, ecx
  000fc	50		 push	 eax
  000fd	6a 09		 push	 9
  000ff	8b cf		 mov	 ecx, edi
  00101	52		 push	 edx
  00102	e8 00 00 00 00	 call	 ?UpdateItem@CMover@@QAEXEDKK@Z ; CMover::UpdateItem

; 7332 : #if __VER >= 9	// __PET_0410
; 7333 : 				//    ,      .
; 7334 : 				if( pItemElem->m_dwItemId == II_SYS_SYS_SCR_PET_FEED_POCKET && pItemElem->m_dwKeepTime > 0 && HasBuff( BUFF_ITEM, (WORD)( pItemElem->m_dwItemId ) ) )

  00107	81 7e 0c 2b 52
	00 00		 cmp	 DWORD PTR [esi+12], 21035 ; 0000522bH
  0010e	75 2e		 jne	 SHORT $L283772
  00110	8b 86 b0 00 00
	00		 mov	 eax, DWORD PTR [esi+176]
  00116	85 c0		 test	 eax, eax
  00118	76 24		 jbe	 SHORT $L283772
  0011a	33 c0		 xor	 eax, eax
  0011c	66 8b 46 0c	 mov	 ax, WORD PTR [esi+12]
  00120	8b cf		 mov	 ecx, edi
  00122	50		 push	 eax
  00123	6a 00		 push	 0
  00125	e8 00 00 00 00	 call	 ?HasBuff@CMover@@QAEHGG@Z ; CMover::HasBuff
  0012a	85 c0		 test	 eax, eax
  0012c	74 10		 je	 SHORT $L283772

; 7335 : 					RemoveBuff( BUFF_ITEM, (WORD)( pItemElem->m_dwItemId ) );

  0012e	33 c9		 xor	 ecx, ecx
  00130	66 8b 4e 0c	 mov	 cx, WORD PTR [esi+12]
  00134	51		 push	 ecx
  00135	6a 00		 push	 0
  00137	8b cf		 mov	 ecx, edi
  00139	e8 00 00 00 00	 call	 ?RemoveBuff@CMover@@QAEXGG@Z ; CMover::RemoveBuff
$L283772:
  0013e	8b 87 9c 0b 00
	00		 mov	 eax, DWORD PTR [edi+2972]
  00144	45		 inc	 ebp
  00145	81 c3 b8 00 00
	00		 add	 ebx, 184		; 000000b8H
  0014b	3b e8		 cmp	 ebp, eax
  0014d	0f 8c c7 fe ff
	ff		 jl	 $L333759
  00153	5e		 pop	 esi
  00154	5b		 pop	 ebx
$L283773:
  00155	5f		 pop	 edi
  00156	5d		 pop	 ebp

; 7336 : #endif	// __PET_0410
; 7337 : 			}
; 7338 : 		}
; 7339 : 	}
; 7340 : }

  00157	c3		 ret	 0
?CheckFiniteItem@CUser@@QAEXXZ ENDP			; CUser::CheckFiniteItem
_TEXT	ENDS
PUBLIC	?AddAlphabetOpenWnd@CUser@@QAEXHHDV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z ; CUser::AddAlphabetOpenWnd
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlsimpstr.h
xdata$x	SEGMENT
$T333873 DD	0ffffffffH
	DD	FLAT:$L333764
$T333869 DD	019930520H
	DD	01H
	DD	FLAT:$T333873
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
xdata$x	ENDS
;	COMDAT ?AddAlphabetOpenWnd@CUser@@QAEXHHDV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_nQuestionID$ = 8					; size = 4
_nPublicAlphabet$ = 12					; size = 4
_chPublicChar$ = 16					; size = 1
_strQuestion$ = 20					; size = 4
?AddAlphabetOpenWnd@CUser@@QAEXHHDV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z PROC NEAR ; CUser::AddAlphabetOpenWnd, COMDAT
; _this$ = ecx

; 7715 : {

  00000	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00006	6a ff		 push	 -1
  00008	68 00 00 00 00	 push	 __ehhandler$?AddAlphabetOpenWnd@CUser@@QAEXHHDV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	56		 push	 esi
  00016	57		 push	 edi

; 7716 : 	if( IsDelete() )	return;

  00017	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  0001b	c7 44 24 10 00
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+28], 0
  00023	74 0c		 je	 SHORT $L284820
  00025	8b 44 24 24	 mov	 eax, DWORD PTR _strQuestion$[esp+16]
  00029	83 c0 f0	 add	 eax, -16		; fffffff0H
  0002c	e9 a6 00 00 00	 jmp	 $L333872
$L284820:

; 7717 : 	
; 7718 : 	m_Snapshot.cb++;

  00031	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]

; 7719 : 	m_Snapshot.ar << GetId();

  00038	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  0003e	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  00044	6a 04		 push	 4
  00046	8b ce		 mov	 ecx, esi
  00048	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0004d	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00050	89 38		 mov	 DWORD PTR [eax], edi
  00052	83 46 08 04	 add	 DWORD PTR [esi+8], 4

; 7720 : 	m_Snapshot.ar << SNAPSHOTTYPE_MINIGAME;

  00056	6a 02		 push	 2
  00058	8b ce		 mov	 ecx, esi
  0005a	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0005f	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00062	66 c7 01 e8 00	 mov	 WORD PTR [ecx], 232	; 000000e8H
  00067	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  0006a	83 c7 02	 add	 edi, 2

; 7721 : 	m_Snapshot.ar << MINIGAME_ALPHABET_OPENWND;

  0006d	6a 01		 push	 1
  0006f	8b ce		 mov	 ecx, esi
  00071	89 7e 08	 mov	 DWORD PTR [esi+8], edi
  00074	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00079	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0007c	c6 02 04	 mov	 BYTE PTR [edx], 4
  0007f	ff 46 08	 inc	 DWORD PTR [esi+8]

; 7722 : 
; 7723 : 	m_Snapshot.ar << nQuestionID;

  00082	6a 04		 push	 4
  00084	8b ce		 mov	 ecx, esi
  00086	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0008b	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0008e	8b 4c 24 18	 mov	 ecx, DWORD PTR _nQuestionID$[esp+16]
  00092	89 08		 mov	 DWORD PTR [eax], ecx
  00094	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  00097	83 c7 04	 add	 edi, 4

; 7724 : 	m_Snapshot.ar << nPublicAlphabet;

  0009a	6a 04		 push	 4
  0009c	8b ce		 mov	 ecx, esi
  0009e	89 7e 08	 mov	 DWORD PTR [esi+8], edi
  000a1	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000a6	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  000a9	8b 44 24 1c	 mov	 eax, DWORD PTR _nPublicAlphabet$[esp+16]
  000ad	89 02		 mov	 DWORD PTR [edx], eax
  000af	83 46 08 04	 add	 DWORD PTR [esi+8], 4

; 7725 : 	m_Snapshot.ar << chPublicChar;

  000b3	6a 01		 push	 1
  000b5	8b ce		 mov	 ecx, esi
  000b7	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000bc	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  000bf	8a 54 24 20	 mov	 dl, BYTE PTR _chPublicChar$[esp+16]
  000c3	88 11		 mov	 BYTE PTR [ecx], dl
  000c5	ff 46 08	 inc	 DWORD PTR [esi+8]

; 7726 : 	m_Snapshot.ar.WriteString( strQuestion );

  000c8	8b 7c 24 24	 mov	 edi, DWORD PTR _strQuestion$[esp+16]
  000cc	57		 push	 edi
  000cd	8b ce		 mov	 ecx, esi
  000cf	e8 00 00 00 00	 call	 ?WriteString@CAr@@QAEXPBD@Z ; CAr::WriteString

; 7727 : }

  000d4	8d 47 f0	 lea	 eax, DWORD PTR [edi-16]
$L333872:
  000d7	c7 44 24 10 ff
	ff ff ff	 mov	 DWORD PTR __$EHRec$[esp+28], -1
  000df	8d 48 0c	 lea	 ecx, DWORD PTR [eax+12]
  000e2	83 ca ff	 or	 edx, -1
  000e5	f0 0f c1 11	 lock	  xadd	 DWORD PTR [ecx], edx
  000e9	4a		 dec	 edx
  000ea	85 d2		 test	 edx, edx
  000ec	7f 08		 jg	 SHORT $L333864
  000ee	8b 08		 mov	 ecx, DWORD PTR [eax]
  000f0	8b 11		 mov	 edx, DWORD PTR [ecx]
  000f2	50		 push	 eax
  000f3	ff 52 04	 call	 DWORD PTR [edx+4]
$L333864:
  000f6	8b 4c 24 08	 mov	 ecx, DWORD PTR __$EHRec$[esp+20]
  000fa	5f		 pop	 edi
  000fb	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00102	5e		 pop	 esi
  00103	83 c4 0c	 add	 esp, 12			; 0000000cH
  00106	c2 10 00	 ret	 16			; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L333764:
  00000	8d 4d 10	 lea	 ecx, DWORD PTR _strQuestion$[ebp-4]
  00003	e9 00 00 00 00	 jmp	 ??1?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::~CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >
__ehhandler$?AddAlphabetOpenWnd@CUser@@QAEXHHDV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T333869
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?AddAlphabetOpenWnd@CUser@@QAEXHHDV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z ENDP ; CUser::AddAlphabetOpenWnd
PUBLIC	?AddSetPetName@CUserMng@@QAEXPAVCUser@@PBD@Z	; CUserMng::AddSetPetName
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
xdata$x	SEGMENT
$T334143 DD	0ffffffffH
	DD	FLAT:$L333882
$T334135 DD	019930520H
	DD	01H
	DD	FLAT:$T334143
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
xdata$x	ENDS
;	COMDAT ?AddSetPetName@CUserMng@@QAEXPAVCUser@@PBD@Z
_TEXT	SEGMENT
_nBufSize$ = -16424					; size = 4
_ar$ = -16420						; size = 16404
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_pUser$ = 8						; size = 4
_szPetName$ = 12					; size = 4
?AddSetPetName@CUserMng@@QAEXPAVCUser@@PBD@Z PROC NEAR	; CUserMng::AddSetPetName, COMDAT
; _this$ = ecx

; 7845 : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?AddSetPetName@CUserMng@@QAEXPAVCUser@@PBD@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	b8 1c 40 00 00	 mov	 eax, 16412		; 0000401cH
  00013	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0001a	e8 00 00 00 00	 call	 __chkstk
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00024	33 c4		 xor	 eax, esp
  00026	53		 push	 ebx
  00027	8b 9c 24 34 40
	00 00		 mov	 ebx, DWORD PTR _szPetName$[esp+16424]
  0002e	55		 push	 ebp
  0002f	56		 push	 esi
  00030	8b b4 24 38 40
	00 00		 mov	 esi, DWORD PTR _pUser$[esp+16432]
  00037	57		 push	 edi

; 7846 : 	CAr ar;

  00038	6a 00		 push	 0
  0003a	6a 00		 push	 0
  0003c	8d 4c 24 1c	 lea	 ecx, DWORD PTR _ar$[esp+16448]
  00040	89 84 24 30 40
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+16448], eax
  00047	e8 00 00 00 00	 call	 ??0CAr@@QAE@PAXI@Z	; CAr::CAr

; 7847 : 	
; 7848 : 	ar << GETID( pUser ) << SNAPSHOTTYPE_SET_PET_NAME;

  0004c	85 f6		 test	 esi, esi
  0004e	c7 84 24 34 40
	00 00 00 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+16448], 0
  00059	74 08		 je	 SHORT $L333880
  0005b	8b be bc 01 00
	00		 mov	 edi, DWORD PTR [esi+444]
  00061	eb 03		 jmp	 SHORT $L333881
$L333880:
  00063	83 cf ff	 or	 edi, -1
$L333881:
  00066	6a 04		 push	 4
  00068	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  0006c	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00071	8b 44 24 1c	 mov	 eax, DWORD PTR _ar$[esp+16448]
  00075	89 38		 mov	 DWORD PTR [eax], edi
  00077	8b 44 24 1c	 mov	 eax, DWORD PTR _ar$[esp+16448]
  0007b	83 c0 04	 add	 eax, 4
  0007e	6a 02		 push	 2
  00080	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  00084	89 44 24 20	 mov	 DWORD PTR _ar$[esp+16452], eax
  00088	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0008d	8b 4c 24 1c	 mov	 ecx, DWORD PTR _ar$[esp+16448]
  00091	66 c7 01 00 91	 mov	 WORD PTR [ecx], 37120	; 00009100H
  00096	8b 7c 24 1c	 mov	 edi, DWORD PTR _ar$[esp+16448]
  0009a	83 c7 02	 add	 edi, 2

; 7849 : 	ar.WriteString( szPetName );

  0009d	53		 push	 ebx
  0009e	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  000a2	89 7c 24 20	 mov	 DWORD PTR _ar$[esp+16452], edi
  000a6	e8 00 00 00 00	 call	 ?WriteString@CAr@@QAEXPBD@Z ; CAr::WriteString

; 7850 : 
; 7851 : 	GETBLOCK( ar, lpBuf, nBufSize );

  000ab	8d 54 24 10	 lea	 edx, DWORD PTR _nBufSize$[esp+16440]
  000af	52		 push	 edx
  000b0	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  000b4	e8 00 00 00 00	 call	 ?GetBuffer@CAr@@QAEPAEPAH@Z ; CAr::GetBuffer

; 7852 : 	
; 7853 : 	FOR_VISIBILITYRANGE( pUser )

  000b9	8b be 10 02 00
	00		 mov	 edi, DWORD PTR [esi+528]
  000bf	8b 37		 mov	 esi, DWORD PTR [edi]
  000c1	3b f7		 cmp	 esi, edi
  000c3	8b e8		 mov	 ebp, eax
  000c5	74 77		 je	 SHORT $L284907
  000c7	b3 01		 mov	 bl, 1
  000c9	8d a4 24 00 00
	00 00		 npad	 7
$L284906:

; 7854 : 		USERPTR->AddBlock( lpBuf, nBufSize );

  000d0	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  000d3	84 58 04	 test	 BYTE PTR [eax+4], bl
  000d6	8b 4c 24 10	 mov	 ecx, DWORD PTR _nBufSize$[esp+16440]
  000da	75 14		 jne	 SHORT $L333978
  000dc	66 ff 80 0c 57
	00 00		 inc	 WORD PTR [eax+22284]
  000e3	51		 push	 ecx
  000e4	55		 push	 ebp
  000e5	8d 88 f8 16 00
	00		 lea	 ecx, DWORD PTR [eax+5880]
  000eb	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
$L333978:

; 7855 : 	NEXT_VISIBILITYRANGE( pUser )

  000f0	8a 46 15	 mov	 al, BYTE PTR [esi+21]
  000f3	84 c0		 test	 al, al
  000f5	75 43		 jne	 SHORT $L334126
  000f7	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000fa	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  000fd	84 c9		 test	 cl, cl
  000ff	75 1c		 jne	 SHORT $L334138
  00101	8b f0		 mov	 esi, eax
  00103	8b 06		 mov	 eax, DWORD PTR [esi]
  00105	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00108	84 c9		 test	 cl, cl
  0010a	75 2e		 jne	 SHORT $L334126
  0010c	8d 64 24 00	 npad	 4
$L334114:
  00110	8b f0		 mov	 esi, eax
  00112	8b 06		 mov	 eax, DWORD PTR [esi]
  00114	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00117	84 c9		 test	 cl, cl
  00119	74 f5		 je	 SHORT $L334114
  0011b	eb 1d		 jmp	 SHORT $L334126
$L334138:
  0011d	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00120	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00123	84 c9		 test	 cl, cl
  00125	75 11		 jne	 SHORT $L334129
$L334128:
  00127	3b 70 08	 cmp	 esi, DWORD PTR [eax+8]
  0012a	75 0c		 jne	 SHORT $L334129
  0012c	8b f0		 mov	 esi, eax
  0012e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00131	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00134	84 c9		 test	 cl, cl
  00136	74 ef		 je	 SHORT $L334128
$L334129:
  00138	8b f0		 mov	 esi, eax
$L334126:

; 7852 : 	
; 7853 : 	FOR_VISIBILITYRANGE( pUser )

  0013a	3b f7		 cmp	 esi, edi
  0013c	75 92		 jne	 SHORT $L284906
$L284907:

; 7856 : }

  0013e	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  00142	c7 84 24 34 40
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+16448], -1
  0014d	e8 00 00 00 00	 call	 ??1CAr@@QAE@XZ		; CAr::~CAr
  00152	8b 8c 24 2c 40
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+16440]
  00159	5f		 pop	 edi
  0015a	5e		 pop	 esi
  0015b	5d		 pop	 ebp
  0015c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00163	8b 8c 24 1c 40
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+16428]
  0016a	5b		 pop	 ebx
  0016b	33 cc		 xor	 ecx, esp
  0016d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00172	81 c4 28 40 00
	00		 add	 esp, 16424		; 00004028H
  00178	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L333882:
  00000	8d 8d dc bf ff
	ff		 lea	 ecx, DWORD PTR _ar$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CAr@@QAE@XZ		; CAr::~CAr
__ehhandler$?AddSetPetName@CUserMng@@QAEXPAVCUser@@PBD@Z:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T334135
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?AddSetPetName@CUserMng@@QAEXPAVCUser@@PBD@Z ENDP	; CUserMng::AddSetPetName
PUBLIC	?AddPetCall@CUserMng@@QAEXPAVCMover@@KKEPBD@Z	; CUserMng::AddPetCall
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
xdata$x	SEGMENT
$T334422 DD	0ffffffffH
	DD	FLAT:$L334152
$T334414 DD	019930520H
	DD	01H
	DD	FLAT:$T334422
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
xdata$x	ENDS
;	COMDAT ?AddPetCall@CUserMng@@QAEXPAVCMover@@KKEPBD@Z
_TEXT	SEGMENT
_nBufSize$ = -16424					; size = 4
_ar$ = -16420						; size = 16404
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_pMover$ = 8						; size = 4
_dwPetId$ = 12						; size = 4
_dwIndex$ = 16						; size = 4
_nPetLevel$ = 20					; size = 1
_szPetName$ = 24					; size = 4
?AddPetCall@CUserMng@@QAEXPAVCMover@@KKEPBD@Z PROC NEAR	; CUserMng::AddPetCall, COMDAT
; _this$ = ecx

; 7864 : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?AddPetCall@CUserMng@@QAEXPAVCMover@@KKEPBD@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	b8 1c 40 00 00	 mov	 eax, 16412		; 0000401cH
  00013	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0001a	e8 00 00 00 00	 call	 __chkstk
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00024	33 c4		 xor	 eax, esp
  00026	53		 push	 ebx
  00027	55		 push	 ebp
  00028	8b ac 24 44 40
	00 00		 mov	 ebp, DWORD PTR _szPetName$[esp+16428]
  0002f	56		 push	 esi
  00030	8b b4 24 38 40
	00 00		 mov	 esi, DWORD PTR _pMover$[esp+16432]
  00037	57		 push	 edi

; 7865 : 	CAr ar;

  00038	6a 00		 push	 0
  0003a	6a 00		 push	 0
  0003c	8d 4c 24 1c	 lea	 ecx, DWORD PTR _ar$[esp+16448]
  00040	89 84 24 30 40
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+16448], eax
  00047	e8 00 00 00 00	 call	 ??0CAr@@QAE@PAXI@Z	; CAr::CAr

; 7866 : 	
; 7867 : 	ar << GETID( pMover ) << SNAPSHOTTYPE_PET_CALL;

  0004c	85 f6		 test	 esi, esi
  0004e	c7 84 24 34 40
	00 00 00 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+16448], 0
  00059	74 08		 je	 SHORT $L334150
  0005b	8b be bc 01 00
	00		 mov	 edi, DWORD PTR [esi+444]
  00061	eb 03		 jmp	 SHORT $L334151
$L334150:
  00063	83 cf ff	 or	 edi, -1
$L334151:
  00066	bb 04 00 00 00	 mov	 ebx, 4
  0006b	53		 push	 ebx
  0006c	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  00070	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00075	8b 44 24 1c	 mov	 eax, DWORD PTR _ar$[esp+16448]
  00079	89 38		 mov	 DWORD PTR [eax], edi
  0007b	8b 7c 24 1c	 mov	 edi, DWORD PTR _ar$[esp+16448]
  0007f	03 fb		 add	 edi, ebx
  00081	6a 02		 push	 2
  00083	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  00087	89 7c 24 20	 mov	 DWORD PTR _ar$[esp+16452], edi
  0008b	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00090	8b 4c 24 1c	 mov	 ecx, DWORD PTR _ar$[esp+16448]
  00094	66 c7 01 10 01	 mov	 WORD PTR [ecx], 272	; 00000110H
  00099	83 44 24 1c 02	 add	 DWORD PTR _ar$[esp+16448], 2

; 7868 : 	ar << dwPetId << dwIndex << nPetLevel;

  0009e	53		 push	 ebx
  0009f	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  000a3	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000a8	8b 54 24 1c	 mov	 edx, DWORD PTR _ar$[esp+16448]
  000ac	8b 84 24 40 40
	00 00		 mov	 eax, DWORD PTR _dwPetId$[esp+16436]
  000b3	89 02		 mov	 DWORD PTR [edx], eax
  000b5	8b 7c 24 1c	 mov	 edi, DWORD PTR _ar$[esp+16448]
  000b9	03 fb		 add	 edi, ebx
  000bb	53		 push	 ebx
  000bc	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  000c0	89 7c 24 20	 mov	 DWORD PTR _ar$[esp+16452], edi
  000c4	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000c9	8b 4c 24 1c	 mov	 ecx, DWORD PTR _ar$[esp+16448]
  000cd	8b 94 24 44 40
	00 00		 mov	 edx, DWORD PTR _dwIndex$[esp+16436]
  000d4	89 11		 mov	 DWORD PTR [ecx], edx
  000d6	01 5c 24 1c	 add	 DWORD PTR _ar$[esp+16448], ebx
  000da	bb 01 00 00 00	 mov	 ebx, 1
  000df	53		 push	 ebx
  000e0	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  000e4	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000e9	8b 44 24 1c	 mov	 eax, DWORD PTR _ar$[esp+16448]
  000ed	8a 8c 24 48 40
	00 00		 mov	 cl, BYTE PTR _nPetLevel$[esp+16436]
  000f4	88 08		 mov	 BYTE PTR [eax], cl
  000f6	8b 7c 24 1c	 mov	 edi, DWORD PTR _ar$[esp+16448]
  000fa	47		 inc	 edi

; 7869 : #ifdef __PET_1024
; 7870 : 	ar.WriteString( szPetName );

  000fb	55		 push	 ebp
  000fc	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  00100	89 7c 24 20	 mov	 DWORD PTR _ar$[esp+16452], edi
  00104	e8 00 00 00 00	 call	 ?WriteString@CAr@@QAEXPBD@Z ; CAr::WriteString

; 7871 : #endif	// __PET_1024
; 7872 : 	
; 7873 : 	GETBLOCK( ar, lpBuf, nBufSize );

  00109	8d 54 24 10	 lea	 edx, DWORD PTR _nBufSize$[esp+16440]
  0010d	52		 push	 edx
  0010e	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  00112	e8 00 00 00 00	 call	 ?GetBuffer@CAr@@QAEPAEPAH@Z ; CAr::GetBuffer

; 7874 : 	
; 7875 : 	FOR_VISIBILITYRANGE( pMover )

  00117	8b be 10 02 00
	00		 mov	 edi, DWORD PTR [esi+528]
  0011d	8b 37		 mov	 esi, DWORD PTR [edi]
  0011f	3b f7		 cmp	 esi, edi
  00121	8b e8		 mov	 ebp, eax
  00123	74 6a		 je	 SHORT $L284936
$L284935:

; 7876 : 		USERPTR->AddBlock( lpBuf, nBufSize );

  00125	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00128	84 58 04	 test	 BYTE PTR [eax+4], bl
  0012b	8b 4c 24 10	 mov	 ecx, DWORD PTR _nBufSize$[esp+16440]
  0012f	75 14		 jne	 SHORT $L334257
  00131	66 ff 80 0c 57
	00 00		 inc	 WORD PTR [eax+22284]
  00138	51		 push	 ecx
  00139	55		 push	 ebp
  0013a	8d 88 f8 16 00
	00		 lea	 ecx, DWORD PTR [eax+5880]
  00140	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
$L334257:

; 7877 : 	NEXT_VISIBILITYRANGE( pMover )

  00145	8a 46 15	 mov	 al, BYTE PTR [esi+21]
  00148	84 c0		 test	 al, al
  0014a	75 3f		 jne	 SHORT $L334381
  0014c	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0014f	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00152	84 c9		 test	 cl, cl
  00154	75 18		 jne	 SHORT $L334417
  00156	8b f0		 mov	 esi, eax
  00158	8b 06		 mov	 eax, DWORD PTR [esi]
  0015a	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  0015d	84 c9		 test	 cl, cl
  0015f	75 2a		 jne	 SHORT $L334381
$L334402:
  00161	8b f0		 mov	 esi, eax
  00163	8b 06		 mov	 eax, DWORD PTR [esi]
  00165	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00168	84 c9		 test	 cl, cl
  0016a	74 f5		 je	 SHORT $L334402
  0016c	eb 1d		 jmp	 SHORT $L334381
$L334417:
  0016e	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00171	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00174	84 c9		 test	 cl, cl
  00176	75 11		 jne	 SHORT $L334384
$L334383:
  00178	3b 70 08	 cmp	 esi, DWORD PTR [eax+8]
  0017b	75 0c		 jne	 SHORT $L334384
  0017d	8b f0		 mov	 esi, eax
  0017f	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00182	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00185	84 c9		 test	 cl, cl
  00187	74 ef		 je	 SHORT $L334383
$L334384:
  00189	8b f0		 mov	 esi, eax
$L334381:

; 7874 : 	
; 7875 : 	FOR_VISIBILITYRANGE( pMover )

  0018b	3b f7		 cmp	 esi, edi
  0018d	75 96		 jne	 SHORT $L284935
$L284936:

; 7878 : }

  0018f	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  00193	c7 84 24 34 40
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+16448], -1
  0019e	e8 00 00 00 00	 call	 ??1CAr@@QAE@XZ		; CAr::~CAr
  001a3	8b 8c 24 2c 40
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+16440]
  001aa	5f		 pop	 edi
  001ab	5e		 pop	 esi
  001ac	5d		 pop	 ebp
  001ad	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  001b4	8b 8c 24 1c 40
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+16428]
  001bb	5b		 pop	 ebx
  001bc	33 cc		 xor	 ecx, esp
  001be	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001c3	81 c4 28 40 00
	00		 add	 esp, 16424		; 00004028H
  001c9	c2 14 00	 ret	 20			; 00000014H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L334152:
  00000	8d 8d dc bf ff
	ff		 lea	 ecx, DWORD PTR _ar$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CAr@@QAE@XZ		; CAr::~CAr
__ehhandler$?AddPetCall@CUserMng@@QAEXPAVCMover@@KKEPBD@Z:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T334414
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?AddPetCall@CUserMng@@QAEXPAVCMover@@KKEPBD@Z ENDP	; CUserMng::AddPetCall
PUBLIC	?AddPetRelease@CUserMng@@QAEXPAVCMover@@@Z	; CUserMng::AddPetRelease
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
xdata$x	SEGMENT
$T334691 DD	0ffffffffH
	DD	FLAT:$L334431
$T334683 DD	019930520H
	DD	01H
	DD	FLAT:$T334691
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
xdata$x	ENDS
;	COMDAT ?AddPetRelease@CUserMng@@QAEXPAVCMover@@@Z
_TEXT	SEGMENT
_nBufSize$ = -16424					; size = 4
_ar$ = -16420						; size = 16404
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_pMover$ = 8						; size = 4
?AddPetRelease@CUserMng@@QAEXPAVCMover@@@Z PROC NEAR	; CUserMng::AddPetRelease, COMDAT
; _this$ = ecx

; 7881 : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?AddPetRelease@CUserMng@@QAEXPAVCMover@@@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	b8 1c 40 00 00	 mov	 eax, 16412		; 0000401cH
  00013	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0001a	e8 00 00 00 00	 call	 __chkstk
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00024	33 c4		 xor	 eax, esp
  00026	55		 push	 ebp
  00027	56		 push	 esi
  00028	8b b4 24 34 40
	00 00		 mov	 esi, DWORD PTR _pMover$[esp+16428]
  0002f	57		 push	 edi

; 7882 : 	CAr ar;

  00030	6a 00		 push	 0
  00032	6a 00		 push	 0
  00034	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  00038	89 84 24 2c 40
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+16444], eax
  0003f	e8 00 00 00 00	 call	 ??0CAr@@QAE@PAXI@Z	; CAr::CAr

; 7883 : 	
; 7884 : 	ar << GETID( pMover ) << SNAPSHOTTYPE_PET_RELEASE;

  00044	85 f6		 test	 esi, esi
  00046	c7 84 24 30 40
	00 00 00 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+16444], 0
  00051	74 08		 je	 SHORT $L334429
  00053	8b be bc 01 00
	00		 mov	 edi, DWORD PTR [esi+444]
  00059	eb 03		 jmp	 SHORT $L334430
$L334429:
  0005b	83 cf ff	 or	 edi, -1
$L334430:
  0005e	6a 04		 push	 4
  00060	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  00064	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00069	8b 44 24 18	 mov	 eax, DWORD PTR _ar$[esp+16444]
  0006d	89 38		 mov	 DWORD PTR [eax], edi
  0006f	8b 6c 24 18	 mov	 ebp, DWORD PTR _ar$[esp+16444]
  00073	83 c5 04	 add	 ebp, 4
  00076	6a 02		 push	 2
  00078	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  0007c	89 6c 24 1c	 mov	 DWORD PTR _ar$[esp+16448], ebp
  00080	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00085	8b 4c 24 18	 mov	 ecx, DWORD PTR _ar$[esp+16444]
  00089	66 c7 01 11 01	 mov	 WORD PTR [ecx], 273	; 00000111H
  0008e	83 44 24 18 02	 add	 DWORD PTR _ar$[esp+16444], 2

; 7885 : 	GETBLOCK( ar, lpBuf, nBufSize );

  00093	8d 54 24 0c	 lea	 edx, DWORD PTR _nBufSize$[esp+16436]
  00097	52		 push	 edx
  00098	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  0009c	e8 00 00 00 00	 call	 ?GetBuffer@CAr@@QAEPAEPAH@Z ; CAr::GetBuffer

; 7886 : 	
; 7887 : 	FOR_VISIBILITYRANGE( pMover )

  000a1	8b be 10 02 00
	00		 mov	 edi, DWORD PTR [esi+528]
  000a7	8b 37		 mov	 esi, DWORD PTR [edi]
  000a9	3b f7		 cmp	 esi, edi
  000ab	8b e8		 mov	 ebp, eax
  000ad	74 6f		 je	 SHORT $L284961
  000af	90		 npad	 1
$L284960:

; 7888 : 		USERPTR->AddBlock( lpBuf, nBufSize );

  000b0	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  000b3	f6 40 04 01	 test	 BYTE PTR [eax+4], 1
  000b7	8b 4c 24 0c	 mov	 ecx, DWORD PTR _nBufSize$[esp+16436]
  000bb	75 14		 jne	 SHORT $L334524
  000bd	66 ff 80 0c 57
	00 00		 inc	 WORD PTR [eax+22284]
  000c4	51		 push	 ecx
  000c5	55		 push	 ebp
  000c6	8d 88 f8 16 00
	00		 lea	 ecx, DWORD PTR [eax+5880]
  000cc	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
$L334524:

; 7889 : 	NEXT_VISIBILITYRANGE( pMover )

  000d1	8a 46 15	 mov	 al, BYTE PTR [esi+21]
  000d4	84 c0		 test	 al, al
  000d6	75 42		 jne	 SHORT $L334652
  000d8	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000db	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  000de	84 c9		 test	 cl, cl
  000e0	75 1b		 jne	 SHORT $L334686
  000e2	8b f0		 mov	 esi, eax
  000e4	8b 06		 mov	 eax, DWORD PTR [esi]
  000e6	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  000e9	84 c9		 test	 cl, cl
  000eb	75 2d		 jne	 SHORT $L334652
  000ed	8d 49 00	 npad	 3
$L334666:
  000f0	8b f0		 mov	 esi, eax
  000f2	8b 06		 mov	 eax, DWORD PTR [esi]
  000f4	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  000f7	84 c9		 test	 cl, cl
  000f9	74 f5		 je	 SHORT $L334666
  000fb	eb 1d		 jmp	 SHORT $L334652
$L334686:
  000fd	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00100	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00103	84 c9		 test	 cl, cl
  00105	75 11		 jne	 SHORT $L334655
$L334654:
  00107	3b 70 08	 cmp	 esi, DWORD PTR [eax+8]
  0010a	75 0c		 jne	 SHORT $L334655
  0010c	8b f0		 mov	 esi, eax
  0010e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00111	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00114	84 c9		 test	 cl, cl
  00116	74 ef		 je	 SHORT $L334654
$L334655:
  00118	8b f0		 mov	 esi, eax
$L334652:

; 7886 : 	
; 7887 : 	FOR_VISIBILITYRANGE( pMover )

  0011a	3b f7		 cmp	 esi, edi
  0011c	75 92		 jne	 SHORT $L284960
$L284961:

; 7890 : }

  0011e	8d 4c 24 10	 lea	 ecx, DWORD PTR _ar$[esp+16436]
  00122	c7 84 24 30 40
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+16444], -1
  0012d	e8 00 00 00 00	 call	 ??1CAr@@QAE@XZ		; CAr::~CAr
  00132	8b 8c 24 28 40
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+16436]
  00139	5f		 pop	 edi
  0013a	5e		 pop	 esi
  0013b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00142	8b 8c 24 1c 40
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+16428]
  00149	5d		 pop	 ebp
  0014a	33 cc		 xor	 ecx, esp
  0014c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00151	81 c4 28 40 00
	00		 add	 esp, 16424		; 00004028H
  00157	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L334431:
  00000	8d 8d dc bf ff
	ff		 lea	 ecx, DWORD PTR _ar$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CAr@@QAE@XZ		; CAr::~CAr
__ehhandler$?AddPetRelease@CUserMng@@QAEXPAVCMover@@@Z:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T334683
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?AddPetRelease@CUserMng@@QAEXPAVCMover@@@Z ENDP		; CUserMng::AddPetRelease
PUBLIC	?AddPetLevelup@CUserMng@@QAEXPAVCMover@@K@Z	; CUserMng::AddPetLevelup
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
xdata$x	SEGMENT
$T334987 DD	0ffffffffH
	DD	FLAT:$L334700
$T334979 DD	019930520H
	DD	01H
	DD	FLAT:$T334987
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
xdata$x	ENDS
;	COMDAT ?AddPetLevelup@CUserMng@@QAEXPAVCMover@@K@Z
_TEXT	SEGMENT
_nBufSize$ = -16424					; size = 4
_ar$ = -16420						; size = 16404
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_pMover$ = 8						; size = 4
_dwPetId$ = 12						; size = 4
?AddPetLevelup@CUserMng@@QAEXPAVCMover@@K@Z PROC NEAR	; CUserMng::AddPetLevelup, COMDAT
; _this$ = ecx

; 7893 : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?AddPetLevelup@CUserMng@@QAEXPAVCMover@@K@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	b8 1c 40 00 00	 mov	 eax, 16412		; 0000401cH
  00013	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0001a	e8 00 00 00 00	 call	 __chkstk
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00024	33 c4		 xor	 eax, esp
  00026	53		 push	 ebx
  00027	55		 push	 ebp
  00028	8b ac 24 34 40
	00 00		 mov	 ebp, DWORD PTR _pMover$[esp+16428]
  0002f	56		 push	 esi
  00030	57		 push	 edi

; 7894 : 	CAr ar;

  00031	6a 00		 push	 0
  00033	6a 00		 push	 0
  00035	8d 4c 24 1c	 lea	 ecx, DWORD PTR _ar$[esp+16448]
  00039	89 84 24 30 40
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+16448], eax
  00040	e8 00 00 00 00	 call	 ??0CAr@@QAE@PAXI@Z	; CAr::CAr

; 7895 : 	
; 7896 : 	ar << GETID( pMover ) << SNAPSHOTTYPE_PET_LEVELUP;

  00045	85 ed		 test	 ebp, ebp
  00047	c7 84 24 34 40
	00 00 00 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+16448], 0
  00052	74 08		 je	 SHORT $L334698
  00054	8b b5 bc 01 00
	00		 mov	 esi, DWORD PTR [ebp+444]
  0005a	eb 03		 jmp	 SHORT $L334699
$L334698:
  0005c	83 ce ff	 or	 esi, -1
$L334699:
  0005f	bf 04 00 00 00	 mov	 edi, 4
  00064	57		 push	 edi
  00065	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  00069	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0006e	8b 44 24 1c	 mov	 eax, DWORD PTR _ar$[esp+16448]
  00072	89 30		 mov	 DWORD PTR [eax], esi
  00074	8b 54 24 1c	 mov	 edx, DWORD PTR _ar$[esp+16448]
  00078	03 d7		 add	 edx, edi
  0007a	6a 02		 push	 2
  0007c	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  00080	89 54 24 20	 mov	 DWORD PTR _ar$[esp+16452], edx
  00084	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00089	8b 4c 24 1c	 mov	 ecx, DWORD PTR _ar$[esp+16448]
  0008d	66 c7 01 12 01	 mov	 WORD PTR [ecx], 274	; 00000112H
  00092	8b 44 24 1c	 mov	 eax, DWORD PTR _ar$[esp+16448]
  00096	83 c0 02	 add	 eax, 2

; 7897 : 	ar << dwPetId;

  00099	57		 push	 edi
  0009a	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  0009e	89 44 24 20	 mov	 DWORD PTR _ar$[esp+16452], eax
  000a2	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000a7	8b 54 24 1c	 mov	 edx, DWORD PTR _ar$[esp+16448]
  000ab	8b 84 24 40 40
	00 00		 mov	 eax, DWORD PTR _dwPetId$[esp+16436]
  000b2	89 02		 mov	 DWORD PTR [edx], eax
  000b4	8b 74 24 1c	 mov	 esi, DWORD PTR _ar$[esp+16448]

; 7898 : 
; 7899 : 	GETBLOCK( ar, lpBuf, nBufSize );

  000b8	8d 4c 24 10	 lea	 ecx, DWORD PTR _nBufSize$[esp+16440]
  000bc	51		 push	 ecx
  000bd	03 f7		 add	 esi, edi
  000bf	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  000c3	89 74 24 20	 mov	 DWORD PTR _ar$[esp+16452], esi
  000c7	e8 00 00 00 00	 call	 ?GetBuffer@CAr@@QAEPAEPAH@Z ; CAr::GetBuffer

; 7900 : 	
; 7901 : 	FOR_VISIBILITYRANGE( pMover )

  000cc	8b bd 10 02 00
	00		 mov	 edi, DWORD PTR [ebp+528]
  000d2	8b 37		 mov	 esi, DWORD PTR [edi]
  000d4	3b f7		 cmp	 esi, edi
  000d6	8b d8		 mov	 ebx, eax
  000d8	74 75		 je	 SHORT $L284987
  000da	8d 9b 00 00 00
	00		 npad	 6
$L284986:

; 7902 : 		if( USERPTR != pMover )

  000e0	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  000e3	3b c5		 cmp	 eax, ebp
  000e5	74 1e		 je	 SHORT $L334820

; 7903 : 			USERPTR->AddBlock( lpBuf, nBufSize );

  000e7	f6 40 04 01	 test	 BYTE PTR [eax+4], 1
  000eb	8b 4c 24 10	 mov	 ecx, DWORD PTR _nBufSize$[esp+16440]
  000ef	75 14		 jne	 SHORT $L334820
  000f1	66 ff 80 0c 57
	00 00		 inc	 WORD PTR [eax+22284]
  000f8	51		 push	 ecx
  000f9	53		 push	 ebx
  000fa	8d 88 f8 16 00
	00		 lea	 ecx, DWORD PTR [eax+5880]
  00100	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
$L334820:

; 7904 : 	NEXT_VISIBILITYRANGE( pMover )

  00105	8a 46 15	 mov	 al, BYTE PTR [esi+21]
  00108	84 c0		 test	 al, al
  0010a	75 3f		 jne	 SHORT $L334960
  0010c	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0010f	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00112	84 c9		 test	 cl, cl
  00114	75 18		 jne	 SHORT $L334982
  00116	8b f0		 mov	 esi, eax
  00118	8b 06		 mov	 eax, DWORD PTR [esi]
  0011a	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  0011d	84 c9		 test	 cl, cl
  0011f	75 2a		 jne	 SHORT $L334960
$L334944:
  00121	8b f0		 mov	 esi, eax
  00123	8b 06		 mov	 eax, DWORD PTR [esi]
  00125	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00128	84 c9		 test	 cl, cl
  0012a	74 f5		 je	 SHORT $L334944
  0012c	eb 1d		 jmp	 SHORT $L334960
$L334982:
  0012e	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00131	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00134	84 c9		 test	 cl, cl
  00136	75 11		 jne	 SHORT $L334963
$L334962:
  00138	3b 70 08	 cmp	 esi, DWORD PTR [eax+8]
  0013b	75 0c		 jne	 SHORT $L334963
  0013d	8b f0		 mov	 esi, eax
  0013f	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00142	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00145	84 c9		 test	 cl, cl
  00147	74 ef		 je	 SHORT $L334962
$L334963:
  00149	8b f0		 mov	 esi, eax
$L334960:

; 7900 : 	
; 7901 : 	FOR_VISIBILITYRANGE( pMover )

  0014b	3b f7		 cmp	 esi, edi
  0014d	75 91		 jne	 SHORT $L284986
$L284987:

; 7905 : }

  0014f	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  00153	c7 84 24 34 40
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+16448], -1
  0015e	e8 00 00 00 00	 call	 ??1CAr@@QAE@XZ		; CAr::~CAr
  00163	8b 8c 24 2c 40
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+16440]
  0016a	5f		 pop	 edi
  0016b	5e		 pop	 esi
  0016c	5d		 pop	 ebp
  0016d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00174	8b 8c 24 1c 40
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+16428]
  0017b	5b		 pop	 ebx
  0017c	33 cc		 xor	 ecx, esp
  0017e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00183	81 c4 28 40 00
	00		 add	 esp, 16424		; 00004028H
  00189	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L334700:
  00000	8d 8d dc bf ff
	ff		 lea	 ecx, DWORD PTR _ar$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CAr@@QAE@XZ		; CAr::~CAr
__ehhandler$?AddPetLevelup@CUserMng@@QAEXPAVCMover@@K@Z:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T334979
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?AddPetLevelup@CUserMng@@QAEXPAVCMover@@K@Z ENDP	; CUserMng::AddPetLevelup
PUBLIC	?AddPetFeed@CUserMng@@QAEXPAVCMover@@G@Z	; CUserMng::AddPetFeed
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
xdata$x	SEGMENT
$T335259 DD	0ffffffffH
	DD	FLAT:$L334996
$T335251 DD	019930520H
	DD	01H
	DD	FLAT:$T335259
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
xdata$x	ENDS
;	COMDAT ?AddPetFeed@CUserMng@@QAEXPAVCMover@@G@Z
_TEXT	SEGMENT
_nBufSize$ = -16424					; size = 4
_ar$ = -16420						; size = 16404
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_pMover$ = 8						; size = 4
_wEnergy$ = 12						; size = 2
?AddPetFeed@CUserMng@@QAEXPAVCMover@@G@Z PROC NEAR	; CUserMng::AddPetFeed, COMDAT
; _this$ = ecx

; 7908 : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?AddPetFeed@CUserMng@@QAEXPAVCMover@@G@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	b8 1c 40 00 00	 mov	 eax, 16412		; 0000401cH
  00013	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0001a	e8 00 00 00 00	 call	 __chkstk
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00024	33 c4		 xor	 eax, esp
  00026	55		 push	 ebp
  00027	56		 push	 esi
  00028	8b b4 24 34 40
	00 00		 mov	 esi, DWORD PTR _pMover$[esp+16428]
  0002f	57		 push	 edi

; 7909 : 	// 
; 7910 : 	CAr ar;

  00030	6a 00		 push	 0
  00032	6a 00		 push	 0
  00034	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  00038	89 84 24 2c 40
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+16444], eax
  0003f	e8 00 00 00 00	 call	 ??0CAr@@QAE@PAXI@Z	; CAr::CAr

; 7911 : 	
; 7912 : 	ar << GETID( pMover ) << SNAPSHOTTYPE_PET_FEED;

  00044	85 f6		 test	 esi, esi
  00046	c7 84 24 30 40
	00 00 00 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+16444], 0
  00051	74 08		 je	 SHORT $L334994
  00053	8b be bc 01 00
	00		 mov	 edi, DWORD PTR [esi+444]
  00059	eb 03		 jmp	 SHORT $L334995
$L334994:
  0005b	83 cf ff	 or	 edi, -1
$L334995:
  0005e	6a 04		 push	 4
  00060	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  00064	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00069	8b 44 24 18	 mov	 eax, DWORD PTR _ar$[esp+16444]
  0006d	89 38		 mov	 DWORD PTR [eax], edi
  0006f	83 44 24 18 04	 add	 DWORD PTR _ar$[esp+16444], 4
  00074	bf 02 00 00 00	 mov	 edi, 2
  00079	57		 push	 edi
  0007a	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  0007e	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00083	8b 4c 24 18	 mov	 ecx, DWORD PTR _ar$[esp+16444]
  00087	66 c7 01 16 01	 mov	 WORD PTR [ecx], 278	; 00000116H
  0008c	01 7c 24 18	 add	 DWORD PTR _ar$[esp+16444], edi

; 7913 : 	ar << wEnergy;

  00090	57		 push	 edi
  00091	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  00095	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0009a	8b 54 24 18	 mov	 edx, DWORD PTR _ar$[esp+16444]
  0009e	66 8b 84 24 3c
	40 00 00	 mov	 ax, WORD PTR _wEnergy$[esp+16432]
  000a6	66 89 02	 mov	 WORD PTR [edx], ax
  000a9	8b 6c 24 18	 mov	 ebp, DWORD PTR _ar$[esp+16444]

; 7914 : 
; 7915 : 	GETBLOCK( ar, lpBuf, nBufSize );

  000ad	8d 4c 24 0c	 lea	 ecx, DWORD PTR _nBufSize$[esp+16436]
  000b1	51		 push	 ecx
  000b2	03 ef		 add	 ebp, edi
  000b4	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  000b8	89 6c 24 1c	 mov	 DWORD PTR _ar$[esp+16448], ebp
  000bc	e8 00 00 00 00	 call	 ?GetBuffer@CAr@@QAEPAEPAH@Z ; CAr::GetBuffer

; 7916 : 	
; 7917 : 	FOR_VISIBILITYRANGE( pMover )

  000c1	8b be 10 02 00
	00		 mov	 edi, DWORD PTR [esi+528]
  000c7	8b 37		 mov	 esi, DWORD PTR [edi]
  000c9	3b f7		 cmp	 esi, edi
  000cb	8b e8		 mov	 ebp, eax
  000cd	74 6f		 je	 SHORT $L285014
  000cf	90		 npad	 1
$L285013:

; 7918 : 			USERPTR->AddBlock( lpBuf, nBufSize );

  000d0	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  000d3	f6 40 04 01	 test	 BYTE PTR [eax+4], 1
  000d7	8b 4c 24 0c	 mov	 ecx, DWORD PTR _nBufSize$[esp+16436]
  000db	75 14		 jne	 SHORT $L335095
  000dd	66 ff 80 0c 57
	00 00		 inc	 WORD PTR [eax+22284]
  000e4	51		 push	 ecx
  000e5	55		 push	 ebp
  000e6	8d 88 f8 16 00
	00		 lea	 ecx, DWORD PTR [eax+5880]
  000ec	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
$L335095:

; 7919 : 	NEXT_VISIBILITYRANGE( pMover )

  000f1	8a 46 15	 mov	 al, BYTE PTR [esi+21]
  000f4	84 c0		 test	 al, al
  000f6	75 42		 jne	 SHORT $L335243
  000f8	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000fb	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  000fe	84 c9		 test	 cl, cl
  00100	75 1b		 jne	 SHORT $L335254
  00102	8b f0		 mov	 esi, eax
  00104	8b 06		 mov	 eax, DWORD PTR [esi]
  00106	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00109	84 c9		 test	 cl, cl
  0010b	75 2d		 jne	 SHORT $L335243
  0010d	8d 49 00	 npad	 3
$L335231:
  00110	8b f0		 mov	 esi, eax
  00112	8b 06		 mov	 eax, DWORD PTR [esi]
  00114	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00117	84 c9		 test	 cl, cl
  00119	74 f5		 je	 SHORT $L335231
  0011b	eb 1d		 jmp	 SHORT $L335243
$L335254:
  0011d	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00120	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00123	84 c9		 test	 cl, cl
  00125	75 11		 jne	 SHORT $L335246
$L335245:
  00127	3b 70 08	 cmp	 esi, DWORD PTR [eax+8]
  0012a	75 0c		 jne	 SHORT $L335246
  0012c	8b f0		 mov	 esi, eax
  0012e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00131	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00134	84 c9		 test	 cl, cl
  00136	74 ef		 je	 SHORT $L335245
$L335246:
  00138	8b f0		 mov	 esi, eax
$L335243:

; 7916 : 	
; 7917 : 	FOR_VISIBILITYRANGE( pMover )

  0013a	3b f7		 cmp	 esi, edi
  0013c	75 92		 jne	 SHORT $L285013
$L285014:

; 7920 : }

  0013e	8d 4c 24 10	 lea	 ecx, DWORD PTR _ar$[esp+16436]
  00142	c7 84 24 30 40
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+16444], -1
  0014d	e8 00 00 00 00	 call	 ??1CAr@@QAE@XZ		; CAr::~CAr
  00152	8b 8c 24 28 40
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+16436]
  00159	5f		 pop	 edi
  0015a	5e		 pop	 esi
  0015b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00162	8b 8c 24 1c 40
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+16428]
  00169	5d		 pop	 ebp
  0016a	33 cc		 xor	 ecx, esp
  0016c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00171	81 c4 28 40 00
	00		 add	 esp, 16424		; 00004028H
  00177	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L334996:
  00000	8d 8d dc bf ff
	ff		 lea	 ecx, DWORD PTR _ar$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CAr@@QAE@XZ		; CAr::~CAr
__ehhandler$?AddPetFeed@CUserMng@@QAEXPAVCMover@@G@Z:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T335251
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?AddPetFeed@CUserMng@@QAEXPAVCMover@@G@Z ENDP		; CUserMng::AddPetFeed
PUBLIC	?AddHonorTitleChange@CUserMng@@QAEXPAVCMover@@H@Z ; CUserMng::AddHonorTitleChange
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
xdata$x	SEGMENT
$T335536 DD	0ffffffffH
	DD	FLAT:$L335268
$T335528 DD	019930520H
	DD	01H
	DD	FLAT:$T335536
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
xdata$x	ENDS
;	COMDAT ?AddHonorTitleChange@CUserMng@@QAEXPAVCMover@@H@Z
_TEXT	SEGMENT
_nBufSize$ = -16424					; size = 4
_ar$ = -16420						; size = 16404
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_pMover$ = 8						; size = 4
_nChange$ = 12						; size = 4
?AddHonorTitleChange@CUserMng@@QAEXPAVCMover@@H@Z PROC NEAR ; CUserMng::AddHonorTitleChange, COMDAT
; _this$ = ecx

; 7925 : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?AddHonorTitleChange@CUserMng@@QAEXPAVCMover@@H@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	b8 1c 40 00 00	 mov	 eax, 16412		; 0000401cH
  00013	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0001a	e8 00 00 00 00	 call	 __chkstk
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00024	33 c4		 xor	 eax, esp
  00026	55		 push	 ebp
  00027	56		 push	 esi
  00028	8b b4 24 34 40
	00 00		 mov	 esi, DWORD PTR _pMover$[esp+16428]
  0002f	57		 push	 edi

; 7926 : 	// 
; 7927 : 	CAr ar;

  00030	6a 00		 push	 0
  00032	6a 00		 push	 0
  00034	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  00038	89 84 24 2c 40
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+16444], eax
  0003f	e8 00 00 00 00	 call	 ??0CAr@@QAE@PAXI@Z	; CAr::CAr

; 7928 : 	
; 7929 : 	ar << GETID( pMover ) << SNAPSHOTTYPE_HONOR_CHANGE_ACK;

  00044	85 f6		 test	 esi, esi
  00046	c7 84 24 30 40
	00 00 00 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+16444], 0
  00051	74 08		 je	 SHORT $L335266
  00053	8b be bc 01 00
	00		 mov	 edi, DWORD PTR [esi+444]
  00059	eb 03		 jmp	 SHORT $L335267
$L335266:
  0005b	83 cf ff	 or	 edi, -1
$L335267:
  0005e	6a 04		 push	 4
  00060	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  00064	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00069	8b 44 24 18	 mov	 eax, DWORD PTR _ar$[esp+16444]
  0006d	89 38		 mov	 DWORD PTR [eax], edi
  0006f	8b 54 24 18	 mov	 edx, DWORD PTR _ar$[esp+16444]
  00073	83 c2 04	 add	 edx, 4
  00076	6a 02		 push	 2
  00078	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  0007c	89 54 24 1c	 mov	 DWORD PTR _ar$[esp+16448], edx
  00080	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00085	8b 4c 24 18	 mov	 ecx, DWORD PTR _ar$[esp+16444]
  00089	66 c7 01 01 93	 mov	 WORD PTR [ecx], 37633	; 00009301H
  0008e	8b 44 24 18	 mov	 eax, DWORD PTR _ar$[esp+16444]
  00092	83 c0 02	 add	 eax, 2

; 7930 : 	ar << nChange;

  00095	6a 04		 push	 4
  00097	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  0009b	89 44 24 1c	 mov	 DWORD PTR _ar$[esp+16448], eax
  0009f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000a4	8b 54 24 18	 mov	 edx, DWORD PTR _ar$[esp+16444]
  000a8	8b 84 24 3c 40
	00 00		 mov	 eax, DWORD PTR _nChange$[esp+16432]
  000af	89 02		 mov	 DWORD PTR [edx], eax
  000b1	8b 7c 24 18	 mov	 edi, DWORD PTR _ar$[esp+16444]

; 7931 : 
; 7932 : 	GETBLOCK( ar, lpBuf, nBufSize );

  000b5	8d 4c 24 0c	 lea	 ecx, DWORD PTR _nBufSize$[esp+16436]
  000b9	51		 push	 ecx
  000ba	83 c7 04	 add	 edi, 4
  000bd	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  000c1	89 7c 24 1c	 mov	 DWORD PTR _ar$[esp+16448], edi
  000c5	e8 00 00 00 00	 call	 ?GetBuffer@CAr@@QAEPAEPAH@Z ; CAr::GetBuffer

; 7933 : 	
; 7934 : 	FOR_VISIBILITYRANGE( pMover )

  000ca	8b be 10 02 00
	00		 mov	 edi, DWORD PTR [esi+528]
  000d0	8b 37		 mov	 esi, DWORD PTR [edi]
  000d2	3b f7		 cmp	 esi, edi
  000d4	8b e8		 mov	 ebp, eax
  000d6	74 76		 je	 SHORT $L285040
  000d8	eb 06 8d 9b 00
	00 00 00	 npad	 8
$L285039:

; 7935 : 			USERPTR->AddBlock( lpBuf, nBufSize );

  000e0	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  000e3	f6 40 04 01	 test	 BYTE PTR [eax+4], 1
  000e7	8b 4c 24 0c	 mov	 ecx, DWORD PTR _nBufSize$[esp+16436]
  000eb	75 14		 jne	 SHORT $L335372
  000ed	66 ff 80 0c 57
	00 00		 inc	 WORD PTR [eax+22284]
  000f4	51		 push	 ecx
  000f5	55		 push	 ebp
  000f6	8d 88 f8 16 00
	00		 lea	 ecx, DWORD PTR [eax+5880]
  000fc	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
$L335372:

; 7936 : 	NEXT_VISIBILITYRANGE( pMover )

  00101	8a 46 15	 mov	 al, BYTE PTR [esi+21]
  00104	84 c0		 test	 al, al
  00106	75 42		 jne	 SHORT $L335496
  00108	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0010b	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  0010e	84 c9		 test	 cl, cl
  00110	75 1b		 jne	 SHORT $L335531
  00112	8b f0		 mov	 esi, eax
  00114	8b 06		 mov	 eax, DWORD PTR [esi]
  00116	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00119	84 c9		 test	 cl, cl
  0011b	75 2d		 jne	 SHORT $L335496
  0011d	8d 49 00	 npad	 3
$L335517:
  00120	8b f0		 mov	 esi, eax
  00122	8b 06		 mov	 eax, DWORD PTR [esi]
  00124	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00127	84 c9		 test	 cl, cl
  00129	74 f5		 je	 SHORT $L335517
  0012b	eb 1d		 jmp	 SHORT $L335496
$L335531:
  0012d	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00130	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00133	84 c9		 test	 cl, cl
  00135	75 11		 jne	 SHORT $L335499
$L335498:
  00137	3b 70 08	 cmp	 esi, DWORD PTR [eax+8]
  0013a	75 0c		 jne	 SHORT $L335499
  0013c	8b f0		 mov	 esi, eax
  0013e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00141	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00144	84 c9		 test	 cl, cl
  00146	74 ef		 je	 SHORT $L335498
$L335499:
  00148	8b f0		 mov	 esi, eax
$L335496:

; 7933 : 	
; 7934 : 	FOR_VISIBILITYRANGE( pMover )

  0014a	3b f7		 cmp	 esi, edi
  0014c	75 92		 jne	 SHORT $L285039
$L285040:

; 7937 : }

  0014e	8d 4c 24 10	 lea	 ecx, DWORD PTR _ar$[esp+16436]
  00152	c7 84 24 30 40
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+16444], -1
  0015d	e8 00 00 00 00	 call	 ??1CAr@@QAE@XZ		; CAr::~CAr
  00162	8b 8c 24 28 40
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+16436]
  00169	5f		 pop	 edi
  0016a	5e		 pop	 esi
  0016b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00172	8b 8c 24 1c 40
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+16428]
  00179	5d		 pop	 ebp
  0017a	33 cc		 xor	 ecx, esp
  0017c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00181	81 c4 28 40 00
	00		 add	 esp, 16424		; 00004028H
  00187	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L335268:
  00000	8d 8d dc bf ff
	ff		 lea	 ecx, DWORD PTR _ar$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CAr@@QAE@XZ		; CAr::~CAr
__ehhandler$?AddHonorTitleChange@CUserMng@@QAEXPAVCMover@@H@Z:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T335528
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?AddHonorTitleChange@CUserMng@@QAEXPAVCMover@@H@Z ENDP	; CUserMng::AddHonorTitleChange
PUBLIC	?AddSetSpeedFactor@CUserMng@@QAEXPAVCMover@@M@Z	; CUserMng::AddSetSpeedFactor
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
xdata$x	SEGMENT
$T335808 DD	0ffffffffH
	DD	FLAT:$L335545
$T335800 DD	019930520H
	DD	01H
	DD	FLAT:$T335808
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
xdata$x	ENDS
;	COMDAT ?AddSetSpeedFactor@CUserMng@@QAEXPAVCMover@@M@Z
_TEXT	SEGMENT
_nBufSize$ = -16424					; size = 4
_ar$ = -16420						; size = 16404
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_pMover$ = 8						; size = 4
_fSpeedFactor$ = 12					; size = 4
?AddSetSpeedFactor@CUserMng@@QAEXPAVCMover@@M@Z PROC NEAR ; CUserMng::AddSetSpeedFactor, COMDAT
; _this$ = ecx

; 7943 : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?AddSetSpeedFactor@CUserMng@@QAEXPAVCMover@@M@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	b8 1c 40 00 00	 mov	 eax, 16412		; 0000401cH
  00013	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0001a	e8 00 00 00 00	 call	 __chkstk
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00024	33 c4		 xor	 eax, esp
  00026	55		 push	 ebp
  00027	56		 push	 esi
  00028	8b b4 24 34 40
	00 00		 mov	 esi, DWORD PTR _pMover$[esp+16428]
  0002f	57		 push	 edi

; 7944 : 	CAr ar;

  00030	6a 00		 push	 0
  00032	6a 00		 push	 0
  00034	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  00038	89 84 24 2c 40
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+16444], eax
  0003f	e8 00 00 00 00	 call	 ??0CAr@@QAE@PAXI@Z	; CAr::CAr

; 7945 : 	
; 7946 : 	ar << GETID( pMover ) << SNAPSHOTTYPE_SET_SPEED_FACTOR;

  00044	85 f6		 test	 esi, esi
  00046	c7 84 24 30 40
	00 00 00 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+16444], 0
  00051	74 08		 je	 SHORT $L335543
  00053	8b be bc 01 00
	00		 mov	 edi, DWORD PTR [esi+444]
  00059	eb 03		 jmp	 SHORT $L335544
$L335543:
  0005b	83 cf ff	 or	 edi, -1
$L335544:
  0005e	6a 04		 push	 4
  00060	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  00064	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00069	8b 44 24 18	 mov	 eax, DWORD PTR _ar$[esp+16444]
  0006d	89 38		 mov	 DWORD PTR [eax], edi
  0006f	83 44 24 18 04	 add	 DWORD PTR _ar$[esp+16444], 4
  00074	6a 02		 push	 2
  00076	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  0007a	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0007f	8b 4c 24 18	 mov	 ecx, DWORD PTR _ar$[esp+16444]
  00083	66 c7 01 18 01	 mov	 WORD PTR [ecx], 280	; 00000118H
  00088	8b 6c 24 18	 mov	 ebp, DWORD PTR _ar$[esp+16444]
  0008c	83 c5 02	 add	 ebp, 2

; 7947 : 	ar << fSpeedFactor;

  0008f	6a 04		 push	 4
  00091	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  00095	89 6c 24 1c	 mov	 DWORD PTR _ar$[esp+16448], ebp
  00099	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0009e	d9 84 24 3c 40
	00 00		 fld	 DWORD PTR _fSpeedFactor$[esp+16432]
  000a5	8b 54 24 18	 mov	 edx, DWORD PTR _ar$[esp+16444]
  000a9	d9 1a		 fstp	 DWORD PTR [edx]
  000ab	8b 54 24 18	 mov	 edx, DWORD PTR _ar$[esp+16444]

; 7948 : 
; 7949 : 	GETBLOCK( ar, lpBuf, nBufSize );

  000af	8d 44 24 0c	 lea	 eax, DWORD PTR _nBufSize$[esp+16436]
  000b3	83 c2 04	 add	 edx, 4
  000b6	50		 push	 eax
  000b7	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  000bb	89 54 24 1c	 mov	 DWORD PTR _ar$[esp+16448], edx
  000bf	e8 00 00 00 00	 call	 ?GetBuffer@CAr@@QAEPAEPAH@Z ; CAr::GetBuffer

; 7950 : 	
; 7951 : 	FOR_VISIBILITYRANGE( pMover )

  000c4	8b be 10 02 00
	00		 mov	 edi, DWORD PTR [esi+528]
  000ca	8b 37		 mov	 esi, DWORD PTR [edi]
  000cc	3b f7		 cmp	 esi, edi
  000ce	8b e8		 mov	 ebp, eax
  000d0	74 6c		 je	 SHORT $L285066
$L285065:

; 7952 : 			USERPTR->AddBlock( lpBuf, nBufSize );

  000d2	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  000d5	f6 40 04 01	 test	 BYTE PTR [eax+4], 1
  000d9	8b 4c 24 0c	 mov	 ecx, DWORD PTR _nBufSize$[esp+16436]
  000dd	75 14		 jne	 SHORT $L335641
  000df	66 ff 80 0c 57
	00 00		 inc	 WORD PTR [eax+22284]
  000e6	51		 push	 ecx
  000e7	55		 push	 ebp
  000e8	8d 88 f8 16 00
	00		 lea	 ecx, DWORD PTR [eax+5880]
  000ee	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
$L335641:

; 7953 : 	NEXT_VISIBILITYRANGE( pMover )

  000f3	8a 46 15	 mov	 al, BYTE PTR [esi+21]
  000f6	84 c0		 test	 al, al
  000f8	75 40		 jne	 SHORT $L335769
  000fa	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000fd	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00100	84 c9		 test	 cl, cl
  00102	75 19		 jne	 SHORT $L335803
  00104	8b f0		 mov	 esi, eax
  00106	8b 06		 mov	 eax, DWORD PTR [esi]
  00108	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  0010b	84 c9		 test	 cl, cl
  0010d	75 2b		 jne	 SHORT $L335769
  0010f	90		 npad	 1
$L335783:
  00110	8b f0		 mov	 esi, eax
  00112	8b 06		 mov	 eax, DWORD PTR [esi]
  00114	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00117	84 c9		 test	 cl, cl
  00119	74 f5		 je	 SHORT $L335783
  0011b	eb 1d		 jmp	 SHORT $L335769
$L335803:
  0011d	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00120	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00123	84 c9		 test	 cl, cl
  00125	75 11		 jne	 SHORT $L335772
$L335771:
  00127	3b 70 08	 cmp	 esi, DWORD PTR [eax+8]
  0012a	75 0c		 jne	 SHORT $L335772
  0012c	8b f0		 mov	 esi, eax
  0012e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00131	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00134	84 c9		 test	 cl, cl
  00136	74 ef		 je	 SHORT $L335771
$L335772:
  00138	8b f0		 mov	 esi, eax
$L335769:

; 7950 : 	
; 7951 : 	FOR_VISIBILITYRANGE( pMover )

  0013a	3b f7		 cmp	 esi, edi
  0013c	75 94		 jne	 SHORT $L285065
$L285066:

; 7954 : }

  0013e	8d 4c 24 10	 lea	 ecx, DWORD PTR _ar$[esp+16436]
  00142	c7 84 24 30 40
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+16444], -1
  0014d	e8 00 00 00 00	 call	 ??1CAr@@QAE@XZ		; CAr::~CAr
  00152	8b 8c 24 28 40
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+16436]
  00159	5f		 pop	 edi
  0015a	5e		 pop	 esi
  0015b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00162	8b 8c 24 1c 40
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+16428]
  00169	5d		 pop	 ebp
  0016a	33 cc		 xor	 ecx, esp
  0016c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00171	81 c4 28 40 00
	00		 add	 esp, 16424		; 00004028H
  00177	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L335545:
  00000	8d 8d dc bf ff
	ff		 lea	 ecx, DWORD PTR _ar$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CAr@@QAE@XZ		; CAr::~CAr
__ehhandler$?AddSetSpeedFactor@CUserMng@@QAEXPAVCMover@@M@Z:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T335800
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?AddSetSpeedFactor@CUserMng@@QAEXPAVCMover@@M@Z ENDP	; CUserMng::AddSetSpeedFactor
PUBLIC	?AddElectionBeginCandidacy@CUserMng@@QAEXXZ	; CUserMng::AddElectionBeginCandidacy
;	COMDAT xdata$x
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_network\misc\include\ar.h
xdata$x	SEGMENT
$T335833 DD	0ffffffffH
	DD	FLAT:$L335815
$T335830 DD	019930520H
	DD	01H
	DD	FLAT:$T335833
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
xdata$x	ENDS
;	COMDAT ?AddElectionBeginCandidacy@CUserMng@@QAEXXZ
_TEXT	SEGMENT
_uBufSize$ = -16424					; size = 4
_ar$ = -16420						; size = 16404
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
?AddElectionBeginCandidacy@CUserMng@@QAEXXZ PROC NEAR	; CUserMng::AddElectionBeginCandidacy, COMDAT
; _this$ = ecx

; 8246 : {

  00000	6a ff		 push	 -1
  00002	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00008	68 00 00 00 00	 push	 __ehhandler$?AddElectionBeginCandidacy@CUserMng@@QAEXXZ
  0000d	50		 push	 eax
  0000e	b8 1c 40 00 00	 mov	 eax, 16412		; 0000401cH
  00013	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0001a	e8 00 00 00 00	 call	 __chkstk
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00024	33 c4		 xor	 eax, esp
  00026	56		 push	 esi

; 8247 : 	CAr ar;

  00027	6a 00		 push	 0
  00029	8b f1		 mov	 esi, ecx
  0002b	89 84 24 20 40
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+16432], eax
  00032	6a 00		 push	 0
  00034	8d 4c 24 10	 lea	 ecx, DWORD PTR _ar$[esp+16436]
  00038	e8 00 00 00 00	 call	 ??0CAr@@QAE@PAXI@Z	; CAr::CAr

; 8248 : 	ar << NULL_ID << SNAPSHOTTYPE_ELECTION_BEGIN_CANDIDACY;

  0003d	6a 04		 push	 4
  0003f	8d 4c 24 0c	 lea	 ecx, DWORD PTR _ar$[esp+16432]
  00043	c7 84 24 2c 40
	00 00 00 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+16440], 0
  0004e	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00053	8b 44 24 10	 mov	 eax, DWORD PTR _ar$[esp+16436]
  00057	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [eax], -1
  0005d	8b 44 24 10	 mov	 eax, DWORD PTR _ar$[esp+16436]
  00061	83 c0 04	 add	 eax, 4
  00064	6a 02		 push	 2
  00066	8d 4c 24 0c	 lea	 ecx, DWORD PTR _ar$[esp+16432]
  0006a	89 44 24 14	 mov	 DWORD PTR _ar$[esp+16440], eax
  0006e	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00073	8b 4c 24 10	 mov	 ecx, DWORD PTR _ar$[esp+16436]
  00077	66 c7 01 03 8f	 mov	 WORD PTR [ecx], 36611	; 00008f03H
  0007c	8b 4c 24 10	 mov	 ecx, DWORD PTR _ar$[esp+16436]
  00080	83 c1 02	 add	 ecx, 2

; 8249 : 	GETBLOCK( ar, lpBuf, uBufSize );

  00083	8d 54 24 04	 lea	 edx, DWORD PTR _uBufSize$[esp+16428]
  00087	89 4c 24 10	 mov	 DWORD PTR _ar$[esp+16436], ecx
  0008b	52		 push	 edx
  0008c	8d 4c 24 0c	 lea	 ecx, DWORD PTR _ar$[esp+16432]
  00090	e8 00 00 00 00	 call	 ?GetBuffer@CAr@@QAEPAEPAH@Z ; CAr::GetBuffer

; 8250 : 	AddBlock( lpBuf, uBufSize );

  00095	8b 4c 24 04	 mov	 ecx, DWORD PTR _uBufSize$[esp+16428]
  00099	51		 push	 ecx
  0009a	50		 push	 eax
  0009b	8b ce		 mov	 ecx, esi
  0009d	e8 00 00 00 00	 call	 ?AddBlock@CUserMng@@QAEXPAEK@Z ; CUserMng::AddBlock

; 8251 : }

  000a2	8d 4c 24 08	 lea	 ecx, DWORD PTR _ar$[esp+16428]
  000a6	c7 84 24 28 40
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+16436], -1
  000b1	e8 00 00 00 00	 call	 ??1CAr@@QAE@XZ		; CAr::~CAr
  000b6	8b 8c 24 20 40
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+16428]
  000bd	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  000c4	8b 8c 24 1c 40
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+16428]
  000cb	5e		 pop	 esi
  000cc	33 cc		 xor	 ecx, esp
  000ce	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000d3	81 c4 28 40 00
	00		 add	 esp, 16424		; 00004028H
  000d9	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L335815:
  00000	8d 8d dc bf ff
	ff		 lea	 ecx, DWORD PTR _ar$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CAr@@QAE@XZ		; CAr::~CAr
__ehhandler$?AddElectionBeginCandidacy@CUserMng@@QAEXXZ:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T335830
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?AddElectionBeginCandidacy@CUserMng@@QAEXXZ ENDP	; CUserMng::AddElectionBeginCandidacy
PUBLIC	?AddElectionBeginVote@CUserMng@@QAEXH@Z		; CUserMng::AddElectionBeginVote
;	COMDAT xdata$x
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_network\misc\include\ar.h
xdata$x	SEGMENT
$T335866 DD	0ffffffffH
	DD	FLAT:$L335840
$T335863 DD	019930520H
	DD	01H
	DD	FLAT:$T335866
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
xdata$x	ENDS
;	COMDAT ?AddElectionBeginVote@CUserMng@@QAEXH@Z
_TEXT	SEGMENT
_uBufSize$ = -16424					; size = 4
_ar$ = -16420						; size = 16404
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_nRequirement$ = 8					; size = 4
?AddElectionBeginVote@CUserMng@@QAEXH@Z PROC NEAR	; CUserMng::AddElectionBeginVote, COMDAT
; _this$ = ecx

; 8254 : {

  00000	6a ff		 push	 -1
  00002	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00008	68 00 00 00 00	 push	 __ehhandler$?AddElectionBeginVote@CUserMng@@QAEXH@Z
  0000d	50		 push	 eax
  0000e	b8 1c 40 00 00	 mov	 eax, 16412		; 0000401cH
  00013	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0001a	e8 00 00 00 00	 call	 __chkstk
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00024	33 c4		 xor	 eax, esp
  00026	56		 push	 esi

; 8255 : 	CAr ar;

  00027	6a 00		 push	 0
  00029	8b f1		 mov	 esi, ecx
  0002b	89 84 24 20 40
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+16432], eax
  00032	6a 00		 push	 0
  00034	8d 4c 24 10	 lea	 ecx, DWORD PTR _ar$[esp+16436]
  00038	e8 00 00 00 00	 call	 ??0CAr@@QAE@PAXI@Z	; CAr::CAr

; 8256 : 	ar << NULL_ID << SNAPSHOTTYPE_ELECTION_BEGIN_VOTE;

  0003d	6a 04		 push	 4
  0003f	8d 4c 24 0c	 lea	 ecx, DWORD PTR _ar$[esp+16432]
  00043	c7 84 24 2c 40
	00 00 00 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+16440], 0
  0004e	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00053	8b 44 24 10	 mov	 eax, DWORD PTR _ar$[esp+16436]
  00057	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [eax], -1
  0005d	83 44 24 10 04	 add	 DWORD PTR _ar$[esp+16436], 4
  00062	6a 02		 push	 2
  00064	8d 4c 24 0c	 lea	 ecx, DWORD PTR _ar$[esp+16432]
  00068	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0006d	8b 4c 24 10	 mov	 ecx, DWORD PTR _ar$[esp+16436]
  00071	66 c7 01 04 8f	 mov	 WORD PTR [ecx], 36612	; 00008f04H
  00076	8b 54 24 10	 mov	 edx, DWORD PTR _ar$[esp+16436]
  0007a	83 c2 02	 add	 edx, 2

; 8257 : 	ar << nRequirement;

  0007d	6a 04		 push	 4
  0007f	8d 4c 24 0c	 lea	 ecx, DWORD PTR _ar$[esp+16432]
  00083	89 54 24 14	 mov	 DWORD PTR _ar$[esp+16440], edx
  00087	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0008c	8b 54 24 10	 mov	 edx, DWORD PTR _ar$[esp+16436]
  00090	8b 84 24 30 40
	00 00		 mov	 eax, DWORD PTR _nRequirement$[esp+16424]
  00097	89 02		 mov	 DWORD PTR [edx], eax
  00099	8b 44 24 10	 mov	 eax, DWORD PTR _ar$[esp+16436]

; 8258 : 	GETBLOCK( ar, lpBuf, uBufSize );

  0009d	8d 4c 24 04	 lea	 ecx, DWORD PTR _uBufSize$[esp+16428]
  000a1	83 c0 04	 add	 eax, 4
  000a4	51		 push	 ecx
  000a5	8d 4c 24 0c	 lea	 ecx, DWORD PTR _ar$[esp+16432]
  000a9	89 44 24 14	 mov	 DWORD PTR _ar$[esp+16440], eax
  000ad	e8 00 00 00 00	 call	 ?GetBuffer@CAr@@QAEPAEPAH@Z ; CAr::GetBuffer

; 8259 : 	AddBlock( lpBuf, uBufSize );

  000b2	8b 54 24 04	 mov	 edx, DWORD PTR _uBufSize$[esp+16428]
  000b6	52		 push	 edx
  000b7	50		 push	 eax
  000b8	8b ce		 mov	 ecx, esi
  000ba	e8 00 00 00 00	 call	 ?AddBlock@CUserMng@@QAEXPAEK@Z ; CUserMng::AddBlock

; 8260 : }

  000bf	8d 4c 24 08	 lea	 ecx, DWORD PTR _ar$[esp+16428]
  000c3	c7 84 24 28 40
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+16436], -1
  000ce	e8 00 00 00 00	 call	 ??1CAr@@QAE@XZ		; CAr::~CAr
  000d3	8b 8c 24 20 40
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+16428]
  000da	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  000e1	8b 8c 24 1c 40
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+16428]
  000e8	5e		 pop	 esi
  000e9	33 cc		 xor	 ecx, esp
  000eb	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000f0	81 c4 28 40 00
	00		 add	 esp, 16424		; 00004028H
  000f6	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L335840:
  00000	8d 8d dc bf ff
	ff		 lea	 ecx, DWORD PTR _ar$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CAr@@QAE@XZ		; CAr::~CAr
__ehhandler$?AddElectionBeginVote@CUserMng@@QAEXH@Z:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T335863
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?AddElectionBeginVote@CUserMng@@QAEXH@Z ENDP		; CUserMng::AddElectionBeginVote
PUBLIC	?AddElectionEndVote@CUserMng@@QAEXK@Z		; CUserMng::AddElectionEndVote
;	COMDAT xdata$x
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_network\misc\include\ar.h
xdata$x	SEGMENT
$T335894 DD	0ffffffffH
	DD	FLAT:$L335873
$T335891 DD	019930520H
	DD	01H
	DD	FLAT:$T335894
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
xdata$x	ENDS
;	COMDAT ?AddElectionEndVote@CUserMng@@QAEXK@Z
_TEXT	SEGMENT
_uBufSize$ = -16424					; size = 4
_ar$ = -16420						; size = 16404
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_idPlayer$ = 8						; size = 4
?AddElectionEndVote@CUserMng@@QAEXK@Z PROC NEAR		; CUserMng::AddElectionEndVote, COMDAT
; _this$ = ecx

; 8263 : {

  00000	6a ff		 push	 -1
  00002	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00008	68 00 00 00 00	 push	 __ehhandler$?AddElectionEndVote@CUserMng@@QAEXK@Z
  0000d	50		 push	 eax
  0000e	b8 1c 40 00 00	 mov	 eax, 16412		; 0000401cH
  00013	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0001a	e8 00 00 00 00	 call	 __chkstk
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00024	33 c4		 xor	 eax, esp
  00026	56		 push	 esi

; 8264 : 	CAr ar;

  00027	6a 00		 push	 0
  00029	8b f1		 mov	 esi, ecx
  0002b	89 84 24 20 40
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+16432], eax
  00032	6a 00		 push	 0
  00034	8d 4c 24 10	 lea	 ecx, DWORD PTR _ar$[esp+16436]
  00038	e8 00 00 00 00	 call	 ??0CAr@@QAE@PAXI@Z	; CAr::CAr

; 8265 : 	ar << NULL_ID << SNAPSHOTTYPE_ELECTION_END_VOTE;

  0003d	6a 04		 push	 4
  0003f	8d 4c 24 0c	 lea	 ecx, DWORD PTR _ar$[esp+16432]
  00043	c7 84 24 2c 40
	00 00 00 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+16440], 0
  0004e	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00053	8b 44 24 10	 mov	 eax, DWORD PTR _ar$[esp+16436]
  00057	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [eax], -1
  0005d	83 44 24 10 04	 add	 DWORD PTR _ar$[esp+16436], 4
  00062	6a 02		 push	 2
  00064	8d 4c 24 0c	 lea	 ecx, DWORD PTR _ar$[esp+16432]
  00068	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0006d	8b 4c 24 10	 mov	 ecx, DWORD PTR _ar$[esp+16436]
  00071	66 c7 01 05 8f	 mov	 WORD PTR [ecx], 36613	; 00008f05H
  00076	8b 54 24 10	 mov	 edx, DWORD PTR _ar$[esp+16436]
  0007a	83 c2 02	 add	 edx, 2

; 8266 : 	ar << idPlayer;

  0007d	6a 04		 push	 4
  0007f	8d 4c 24 0c	 lea	 ecx, DWORD PTR _ar$[esp+16432]
  00083	89 54 24 14	 mov	 DWORD PTR _ar$[esp+16440], edx
  00087	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0008c	8b 54 24 10	 mov	 edx, DWORD PTR _ar$[esp+16436]
  00090	8b 84 24 30 40
	00 00		 mov	 eax, DWORD PTR _idPlayer$[esp+16424]
  00097	89 02		 mov	 DWORD PTR [edx], eax
  00099	8b 44 24 10	 mov	 eax, DWORD PTR _ar$[esp+16436]

; 8267 : 	GETBLOCK( ar, lpBuf, uBufSize );

  0009d	8d 4c 24 04	 lea	 ecx, DWORD PTR _uBufSize$[esp+16428]
  000a1	83 c0 04	 add	 eax, 4
  000a4	51		 push	 ecx
  000a5	8d 4c 24 0c	 lea	 ecx, DWORD PTR _ar$[esp+16432]
  000a9	89 44 24 14	 mov	 DWORD PTR _ar$[esp+16440], eax
  000ad	e8 00 00 00 00	 call	 ?GetBuffer@CAr@@QAEPAEPAH@Z ; CAr::GetBuffer

; 8268 : 	AddBlock( lpBuf, uBufSize );

  000b2	8b 54 24 04	 mov	 edx, DWORD PTR _uBufSize$[esp+16428]
  000b6	52		 push	 edx
  000b7	50		 push	 eax
  000b8	8b ce		 mov	 ecx, esi
  000ba	e8 00 00 00 00	 call	 ?AddBlock@CUserMng@@QAEXPAEK@Z ; CUserMng::AddBlock

; 8269 : }

  000bf	8d 4c 24 08	 lea	 ecx, DWORD PTR _ar$[esp+16428]
  000c3	c7 84 24 28 40
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+16436], -1
  000ce	e8 00 00 00 00	 call	 ??1CAr@@QAE@XZ		; CAr::~CAr
  000d3	8b 8c 24 20 40
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+16428]
  000da	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  000e1	8b 8c 24 1c 40
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+16428]
  000e8	5e		 pop	 esi
  000e9	33 cc		 xor	 ecx, esp
  000eb	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000f0	81 c4 28 40 00
	00		 add	 esp, 16424		; 00004028H
  000f6	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L335873:
  00000	8d 8d dc bf ff
	ff		 lea	 ecx, DWORD PTR _ar$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CAr@@QAE@XZ		; CAr::~CAr
__ehhandler$?AddElectionEndVote@CUserMng@@QAEXK@Z:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T335891
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?AddElectionEndVote@CUserMng@@QAEXK@Z ENDP		; CUserMng::AddElectionEndVote
PUBLIC	?AddElectionAddDeposit@CUserMng@@QAEXK_JJ@Z	; CUserMng::AddElectionAddDeposit
;	COMDAT xdata$x
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_network\misc\include\ar.h
xdata$x	SEGMENT
$T335929 DD	0ffffffffH
	DD	FLAT:$L335901
$T335926 DD	019930520H
	DD	01H
	DD	FLAT:$T335929
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
xdata$x	ENDS
;	COMDAT ?AddElectionAddDeposit@CUserMng@@QAEXK_JJ@Z
_TEXT	SEGMENT
_uBufSize$ = -16432					; size = 4
$T335920 = -16428					; size = 8
_ar$ = -16420						; size = 16404
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_idPlayer$ = 8						; size = 4
_iDeposit$ = 12						; size = 8
_tCreate$ = 20						; size = 4
?AddElectionAddDeposit@CUserMng@@QAEXK_JJ@Z PROC NEAR	; CUserMng::AddElectionAddDeposit, COMDAT
; _this$ = ecx

; 8272 : {

  00000	6a ff		 push	 -1
  00002	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00008	68 00 00 00 00	 push	 __ehhandler$?AddElectionAddDeposit@CUserMng@@QAEXK_JJ@Z
  0000d	50		 push	 eax
  0000e	b8 24 40 00 00	 mov	 eax, 16420		; 00004024H
  00013	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0001a	e8 00 00 00 00	 call	 __chkstk
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00024	33 c4		 xor	 eax, esp
  00026	56		 push	 esi

; 8273 : 	CAr ar;

  00027	6a 00		 push	 0
  00029	8b f1		 mov	 esi, ecx
  0002b	89 84 24 28 40
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+16440], eax
  00032	6a 00		 push	 0
  00034	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  00038	e8 00 00 00 00	 call	 ??0CAr@@QAE@PAXI@Z	; CAr::CAr

; 8274 : 	ar << NULL_ID << SNAPSHOTTYPE_ELECTION_ADD_DEPOSIT;

  0003d	6a 04		 push	 4
  0003f	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  00043	c7 84 24 34 40
	00 00 00 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+16448], 0
  0004e	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00053	8b 44 24 18	 mov	 eax, DWORD PTR _ar$[esp+16444]
  00057	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [eax], -1
  0005d	83 44 24 18 04	 add	 DWORD PTR _ar$[esp+16444], 4
  00062	6a 02		 push	 2
  00064	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  00068	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0006d	8b 4c 24 18	 mov	 ecx, DWORD PTR _ar$[esp+16444]
  00071	66 c7 01 00 8f	 mov	 WORD PTR [ecx], 36608	; 00008f00H
  00076	8b 54 24 18	 mov	 edx, DWORD PTR _ar$[esp+16444]
  0007a	83 c2 02	 add	 edx, 2

; 8275 : 	ar << idPlayer << iDeposit << tCreate;

  0007d	6a 04		 push	 4
  0007f	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  00083	89 54 24 1c	 mov	 DWORD PTR _ar$[esp+16448], edx
  00087	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0008c	8b 54 24 18	 mov	 edx, DWORD PTR _ar$[esp+16444]
  00090	8b 84 24 38 40
	00 00		 mov	 eax, DWORD PTR _idPlayer$[esp+16432]
  00097	8b 8c 24 3c 40
	00 00		 mov	 ecx, DWORD PTR _iDeposit$[esp+16432]
  0009e	89 02		 mov	 DWORD PTR [edx], eax
  000a0	8b 44 24 18	 mov	 eax, DWORD PTR _ar$[esp+16444]
  000a4	8b 94 24 40 40
	00 00		 mov	 edx, DWORD PTR _iDeposit$[esp+16436]
  000ab	83 c0 04	 add	 eax, 4
  000ae	89 44 24 18	 mov	 DWORD PTR _ar$[esp+16444], eax
  000b2	6a 08		 push	 8
  000b4	8d 44 24 0c	 lea	 eax, DWORD PTR $T335920[esp+16440]
  000b8	89 4c 24 0c	 mov	 DWORD PTR $T335920[esp+16440], ecx
  000bc	50		 push	 eax
  000bd	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  000c1	89 54 24 14	 mov	 DWORD PTR $T335920[esp+16448], edx
  000c5	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
  000ca	6a 04		 push	 4
  000cc	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  000d0	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000d5	8b 4c 24 18	 mov	 ecx, DWORD PTR _ar$[esp+16444]
  000d9	8b 94 24 44 40
	00 00		 mov	 edx, DWORD PTR _tCreate$[esp+16432]
  000e0	89 11		 mov	 DWORD PTR [ecx], edx
  000e2	8b 54 24 18	 mov	 edx, DWORD PTR _ar$[esp+16444]

; 8276 : 	GETBLOCK( ar, lpBuf, uBufSize );

  000e6	8d 44 24 04	 lea	 eax, DWORD PTR _uBufSize$[esp+16436]
  000ea	83 c2 04	 add	 edx, 4
  000ed	50		 push	 eax
  000ee	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  000f2	89 54 24 1c	 mov	 DWORD PTR _ar$[esp+16448], edx
  000f6	e8 00 00 00 00	 call	 ?GetBuffer@CAr@@QAEPAEPAH@Z ; CAr::GetBuffer

; 8277 : 	AddBlock( lpBuf, uBufSize );

  000fb	8b 4c 24 04	 mov	 ecx, DWORD PTR _uBufSize$[esp+16436]
  000ff	51		 push	 ecx
  00100	50		 push	 eax
  00101	8b ce		 mov	 ecx, esi
  00103	e8 00 00 00 00	 call	 ?AddBlock@CUserMng@@QAEXPAEK@Z ; CUserMng::AddBlock

; 8278 : }

  00108	8d 4c 24 10	 lea	 ecx, DWORD PTR _ar$[esp+16436]
  0010c	c7 84 24 30 40
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+16444], -1
  00117	e8 00 00 00 00	 call	 ??1CAr@@QAE@XZ		; CAr::~CAr
  0011c	8b 8c 24 28 40
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+16436]
  00123	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0012a	8b 8c 24 24 40
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+16436]
  00131	5e		 pop	 esi
  00132	33 cc		 xor	 ecx, esp
  00134	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00139	81 c4 30 40 00
	00		 add	 esp, 16432		; 00004030H
  0013f	c2 10 00	 ret	 16			; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L335901:
  00000	8d 8d dc bf ff
	ff		 lea	 ecx, DWORD PTR _ar$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CAr@@QAE@XZ		; CAr::~CAr
__ehhandler$?AddElectionAddDeposit@CUserMng@@QAEXK_JJ@Z:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T335926
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?AddElectionAddDeposit@CUserMng@@QAEXK_JJ@Z ENDP	; CUserMng::AddElectionAddDeposit
PUBLIC	?AddElectionSetPledge@CUserMng@@QAEXKPBD@Z	; CUserMng::AddElectionSetPledge
;	COMDAT xdata$x
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_network\misc\include\ar.h
xdata$x	SEGMENT
$T335958 DD	0ffffffffH
	DD	FLAT:$L335936
$T335955 DD	019930520H
	DD	01H
	DD	FLAT:$T335958
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
xdata$x	ENDS
;	COMDAT ?AddElectionSetPledge@CUserMng@@QAEXKPBD@Z
_TEXT	SEGMENT
_uBufSize$ = -16424					; size = 4
_ar$ = -16420						; size = 16404
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_idPlayer$ = 8						; size = 4
_szPledge$ = 12						; size = 4
?AddElectionSetPledge@CUserMng@@QAEXKPBD@Z PROC NEAR	; CUserMng::AddElectionSetPledge, COMDAT
; _this$ = ecx

; 8281 : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?AddElectionSetPledge@CUserMng@@QAEXKPBD@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	b8 1c 40 00 00	 mov	 eax, 16412		; 0000401cH
  00013	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0001a	e8 00 00 00 00	 call	 __chkstk
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00024	33 c4		 xor	 eax, esp
  00026	56		 push	 esi
  00027	57		 push	 edi
  00028	8b bc 24 38 40
	00 00		 mov	 edi, DWORD PTR _szPledge$[esp+16428]

; 8282 : 	CAr ar;

  0002f	6a 00		 push	 0
  00031	8b f1		 mov	 esi, ecx
  00033	89 84 24 24 40
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+16436], eax
  0003a	6a 00		 push	 0
  0003c	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  00040	e8 00 00 00 00	 call	 ??0CAr@@QAE@PAXI@Z	; CAr::CAr

; 8283 : 	ar << NULL_ID << SNAPSHOTTYPE_ELECTION_SET_PLEDGE;

  00045	6a 04		 push	 4
  00047	8d 4c 24 10	 lea	 ecx, DWORD PTR _ar$[esp+16436]
  0004b	c7 84 24 30 40
	00 00 00 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+16444], 0
  00056	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0005b	8b 44 24 14	 mov	 eax, DWORD PTR _ar$[esp+16440]
  0005f	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [eax], -1
  00065	8b 44 24 14	 mov	 eax, DWORD PTR _ar$[esp+16440]
  00069	83 c0 04	 add	 eax, 4
  0006c	6a 02		 push	 2
  0006e	8d 4c 24 10	 lea	 ecx, DWORD PTR _ar$[esp+16436]
  00072	89 44 24 18	 mov	 DWORD PTR _ar$[esp+16444], eax
  00076	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0007b	8b 4c 24 14	 mov	 ecx, DWORD PTR _ar$[esp+16440]
  0007f	66 c7 01 01 8f	 mov	 WORD PTR [ecx], 36609	; 00008f01H
  00084	83 44 24 14 02	 add	 DWORD PTR _ar$[esp+16440], 2

; 8284 : 	ar << idPlayer;

  00089	6a 04		 push	 4
  0008b	8d 4c 24 10	 lea	 ecx, DWORD PTR _ar$[esp+16436]
  0008f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00094	8b 54 24 14	 mov	 edx, DWORD PTR _ar$[esp+16440]
  00098	8b 84 24 34 40
	00 00		 mov	 eax, DWORD PTR _idPlayer$[esp+16428]
  0009f	89 02		 mov	 DWORD PTR [edx], eax
  000a1	8b 54 24 14	 mov	 edx, DWORD PTR _ar$[esp+16440]
  000a5	83 c2 04	 add	 edx, 4

; 8285 : 	ar.WriteString( szPledge );

  000a8	57		 push	 edi
  000a9	8d 4c 24 10	 lea	 ecx, DWORD PTR _ar$[esp+16436]
  000ad	89 54 24 18	 mov	 DWORD PTR _ar$[esp+16444], edx
  000b1	e8 00 00 00 00	 call	 ?WriteString@CAr@@QAEXPBD@Z ; CAr::WriteString

; 8286 : 	GETBLOCK( ar, lpBuf, uBufSize );

  000b6	8d 4c 24 08	 lea	 ecx, DWORD PTR _uBufSize$[esp+16432]
  000ba	51		 push	 ecx
  000bb	8d 4c 24 10	 lea	 ecx, DWORD PTR _ar$[esp+16436]
  000bf	e8 00 00 00 00	 call	 ?GetBuffer@CAr@@QAEPAEPAH@Z ; CAr::GetBuffer

; 8287 : 	AddBlock( lpBuf, uBufSize );

  000c4	8b 54 24 08	 mov	 edx, DWORD PTR _uBufSize$[esp+16432]
  000c8	52		 push	 edx
  000c9	50		 push	 eax
  000ca	8b ce		 mov	 ecx, esi
  000cc	e8 00 00 00 00	 call	 ?AddBlock@CUserMng@@QAEXPAEK@Z ; CUserMng::AddBlock

; 8288 : }

  000d1	8d 4c 24 0c	 lea	 ecx, DWORD PTR _ar$[esp+16432]
  000d5	c7 84 24 2c 40
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+16440], -1
  000e0	e8 00 00 00 00	 call	 ??1CAr@@QAE@XZ		; CAr::~CAr
  000e5	8b 8c 24 24 40
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+16432]
  000ec	5f		 pop	 edi
  000ed	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  000f4	8b 8c 24 1c 40
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+16428]
  000fb	5e		 pop	 esi
  000fc	33 cc		 xor	 ecx, esp
  000fe	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00103	81 c4 28 40 00
	00		 add	 esp, 16424		; 00004028H
  00109	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L335936:
  00000	8d 8d dc bf ff
	ff		 lea	 ecx, DWORD PTR _ar$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CAr@@QAE@XZ		; CAr::~CAr
__ehhandler$?AddElectionSetPledge@CUserMng@@QAEXKPBD@Z:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T335955
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?AddElectionSetPledge@CUserMng@@QAEXKPBD@Z ENDP		; CUserMng::AddElectionSetPledge
PUBLIC	?AddElectionIncVote@CUserMng@@QAEXKK@Z		; CUserMng::AddElectionIncVote
;	COMDAT xdata$x
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_network\misc\include\ar.h
xdata$x	SEGMENT
$T335989 DD	0ffffffffH
	DD	FLAT:$L335965
$T335986 DD	019930520H
	DD	01H
	DD	FLAT:$T335989
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
xdata$x	ENDS
;	COMDAT ?AddElectionIncVote@CUserMng@@QAEXKK@Z
_TEXT	SEGMENT
_uBufSize$ = -16424					; size = 4
_ar$ = -16420						; size = 16404
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_idPlayer$ = 8						; size = 4
_idElector$ = 12					; size = 4
?AddElectionIncVote@CUserMng@@QAEXKK@Z PROC NEAR	; CUserMng::AddElectionIncVote, COMDAT
; _this$ = ecx

; 8291 : {

  00000	6a ff		 push	 -1
  00002	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00008	68 00 00 00 00	 push	 __ehhandler$?AddElectionIncVote@CUserMng@@QAEXKK@Z
  0000d	50		 push	 eax
  0000e	b8 1c 40 00 00	 mov	 eax, 16412		; 0000401cH
  00013	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0001a	e8 00 00 00 00	 call	 __chkstk
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00024	33 c4		 xor	 eax, esp
  00026	56		 push	 esi

; 8292 : 	CAr ar;

  00027	6a 00		 push	 0
  00029	8b f1		 mov	 esi, ecx
  0002b	89 84 24 20 40
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+16432], eax
  00032	6a 00		 push	 0
  00034	8d 4c 24 10	 lea	 ecx, DWORD PTR _ar$[esp+16436]
  00038	e8 00 00 00 00	 call	 ??0CAr@@QAE@PAXI@Z	; CAr::CAr

; 8293 : 	ar << NULL_ID << SNAPSHOTTYPE_ELECTION_INC_VOTE;

  0003d	6a 04		 push	 4
  0003f	8d 4c 24 0c	 lea	 ecx, DWORD PTR _ar$[esp+16432]
  00043	c7 84 24 2c 40
	00 00 00 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+16440], 0
  0004e	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00053	8b 44 24 10	 mov	 eax, DWORD PTR _ar$[esp+16436]
  00057	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [eax], -1
  0005d	8b 54 24 10	 mov	 edx, DWORD PTR _ar$[esp+16436]
  00061	83 c2 04	 add	 edx, 4
  00064	6a 02		 push	 2
  00066	8d 4c 24 0c	 lea	 ecx, DWORD PTR _ar$[esp+16432]
  0006a	89 54 24 14	 mov	 DWORD PTR _ar$[esp+16440], edx
  0006e	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00073	8b 4c 24 10	 mov	 ecx, DWORD PTR _ar$[esp+16436]
  00077	66 c7 01 02 8f	 mov	 WORD PTR [ecx], 36610	; 00008f02H
  0007c	8b 44 24 10	 mov	 eax, DWORD PTR _ar$[esp+16436]
  00080	83 c0 02	 add	 eax, 2

; 8294 : 	ar << idPlayer << idElector;

  00083	6a 04		 push	 4
  00085	8d 4c 24 0c	 lea	 ecx, DWORD PTR _ar$[esp+16432]
  00089	89 44 24 14	 mov	 DWORD PTR _ar$[esp+16440], eax
  0008d	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00092	8b 54 24 10	 mov	 edx, DWORD PTR _ar$[esp+16436]
  00096	8b 84 24 30 40
	00 00		 mov	 eax, DWORD PTR _idPlayer$[esp+16424]
  0009d	89 02		 mov	 DWORD PTR [edx], eax
  0009f	83 44 24 10 04	 add	 DWORD PTR _ar$[esp+16436], 4
  000a4	6a 04		 push	 4
  000a6	8d 4c 24 0c	 lea	 ecx, DWORD PTR _ar$[esp+16432]
  000aa	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000af	8b 4c 24 10	 mov	 ecx, DWORD PTR _ar$[esp+16436]
  000b3	8b 94 24 34 40
	00 00		 mov	 edx, DWORD PTR _idElector$[esp+16424]
  000ba	89 11		 mov	 DWORD PTR [ecx], edx
  000bc	8b 54 24 10	 mov	 edx, DWORD PTR _ar$[esp+16436]

; 8295 : 	GETBLOCK( ar, lpBuf, uBufSize );

  000c0	8d 44 24 04	 lea	 eax, DWORD PTR _uBufSize$[esp+16428]
  000c4	83 c2 04	 add	 edx, 4
  000c7	50		 push	 eax
  000c8	8d 4c 24 0c	 lea	 ecx, DWORD PTR _ar$[esp+16432]
  000cc	89 54 24 14	 mov	 DWORD PTR _ar$[esp+16440], edx
  000d0	e8 00 00 00 00	 call	 ?GetBuffer@CAr@@QAEPAEPAH@Z ; CAr::GetBuffer

; 8296 : 	AddBlock( lpBuf, uBufSize );

  000d5	8b 4c 24 04	 mov	 ecx, DWORD PTR _uBufSize$[esp+16428]
  000d9	51		 push	 ecx
  000da	50		 push	 eax
  000db	8b ce		 mov	 ecx, esi
  000dd	e8 00 00 00 00	 call	 ?AddBlock@CUserMng@@QAEXPAEK@Z ; CUserMng::AddBlock

; 8297 : }

  000e2	8d 4c 24 08	 lea	 ecx, DWORD PTR _ar$[esp+16428]
  000e6	c7 84 24 28 40
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+16436], -1
  000f1	e8 00 00 00 00	 call	 ??1CAr@@QAE@XZ		; CAr::~CAr
  000f6	8b 8c 24 20 40
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+16428]
  000fd	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00104	8b 8c 24 1c 40
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+16428]
  0010b	5e		 pop	 esi
  0010c	33 cc		 xor	 ecx, esp
  0010e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00113	81 c4 28 40 00
	00		 add	 esp, 16424		; 00004028H
  00119	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L335965:
  00000	8d 8d dc bf ff
	ff		 lea	 ecx, DWORD PTR _ar$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CAr@@QAE@XZ		; CAr::~CAr
__ehhandler$?AddElectionIncVote@CUserMng@@QAEXKK@Z:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T335986
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?AddElectionIncVote@CUserMng@@QAEXKK@Z ENDP		; CUserMng::AddElectionIncVote
PUBLIC	?AddLEventCreate@CUserMng@@QAEXPAVCLEComponent@@@Z ; CUserMng::AddLEventCreate
EXTRN	?Serialize@CLEComponent@@QAEXAAVCAr@@@Z:NEAR	; CLEComponent::Serialize
;	COMDAT xdata$x
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_network\misc\include\ar.h
xdata$x	SEGMENT
$T336015 DD	0ffffffffH
	DD	FLAT:$L335996
$T336012 DD	019930520H
	DD	01H
	DD	FLAT:$T336015
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
xdata$x	ENDS
;	COMDAT ?AddLEventCreate@CUserMng@@QAEXPAVCLEComponent@@@Z
_TEXT	SEGMENT
_uBufSize$ = -16424					; size = 4
_ar$ = -16420						; size = 16404
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_pComponent$ = 8					; size = 4
?AddLEventCreate@CUserMng@@QAEXPAVCLEComponent@@@Z PROC NEAR ; CUserMng::AddLEventCreate, COMDAT
; _this$ = ecx

; 8300 : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?AddLEventCreate@CUserMng@@QAEXPAVCLEComponent@@@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	b8 1c 40 00 00	 mov	 eax, 16412		; 0000401cH
  00013	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0001a	e8 00 00 00 00	 call	 __chkstk
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00024	33 c4		 xor	 eax, esp
  00026	56		 push	 esi
  00027	57		 push	 edi
  00028	8b bc 24 34 40
	00 00		 mov	 edi, DWORD PTR _pComponent$[esp+16428]

; 8301 : 	CAr ar;

  0002f	6a 00		 push	 0
  00031	8b f1		 mov	 esi, ecx
  00033	89 84 24 24 40
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+16436], eax
  0003a	6a 00		 push	 0
  0003c	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  00040	e8 00 00 00 00	 call	 ??0CAr@@QAE@PAXI@Z	; CAr::CAr

; 8302 : 	ar << NULL_ID << SNAPSHOTTYPE_L_EVENT_CREATE;

  00045	6a 04		 push	 4
  00047	8d 4c 24 10	 lea	 ecx, DWORD PTR _ar$[esp+16436]
  0004b	c7 84 24 30 40
	00 00 00 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+16444], 0
  00056	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0005b	8b 44 24 14	 mov	 eax, DWORD PTR _ar$[esp+16440]
  0005f	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [eax], -1
  00065	8b 44 24 14	 mov	 eax, DWORD PTR _ar$[esp+16440]
  00069	83 c0 04	 add	 eax, 4
  0006c	6a 02		 push	 2
  0006e	8d 4c 24 10	 lea	 ecx, DWORD PTR _ar$[esp+16436]
  00072	89 44 24 18	 mov	 DWORD PTR _ar$[esp+16444], eax
  00076	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0007b	8b 4c 24 14	 mov	 ecx, DWORD PTR _ar$[esp+16440]
  0007f	66 c7 01 08 8f	 mov	 WORD PTR [ecx], 36616	; 00008f08H
  00084	8b 4c 24 14	 mov	 ecx, DWORD PTR _ar$[esp+16440]
  00088	83 c1 02	 add	 ecx, 2

; 8303 : 	pComponent->Serialize( ar );

  0008b	8d 54 24 0c	 lea	 edx, DWORD PTR _ar$[esp+16432]
  0008f	89 4c 24 14	 mov	 DWORD PTR _ar$[esp+16440], ecx
  00093	52		 push	 edx
  00094	8b cf		 mov	 ecx, edi
  00096	e8 00 00 00 00	 call	 ?Serialize@CLEComponent@@QAEXAAVCAr@@@Z ; CLEComponent::Serialize

; 8304 : 	GETBLOCK( ar, lpBuf, uBufSize );

  0009b	8d 44 24 08	 lea	 eax, DWORD PTR _uBufSize$[esp+16432]
  0009f	50		 push	 eax
  000a0	8d 4c 24 10	 lea	 ecx, DWORD PTR _ar$[esp+16436]
  000a4	e8 00 00 00 00	 call	 ?GetBuffer@CAr@@QAEPAEPAH@Z ; CAr::GetBuffer

; 8305 : 	AddBlock( lpBuf, uBufSize );

  000a9	8b 4c 24 08	 mov	 ecx, DWORD PTR _uBufSize$[esp+16432]
  000ad	51		 push	 ecx
  000ae	50		 push	 eax
  000af	8b ce		 mov	 ecx, esi
  000b1	e8 00 00 00 00	 call	 ?AddBlock@CUserMng@@QAEXPAEK@Z ; CUserMng::AddBlock

; 8306 : }

  000b6	8d 4c 24 0c	 lea	 ecx, DWORD PTR _ar$[esp+16432]
  000ba	c7 84 24 2c 40
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+16440], -1
  000c5	e8 00 00 00 00	 call	 ??1CAr@@QAE@XZ		; CAr::~CAr
  000ca	8b 8c 24 24 40
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+16432]
  000d1	5f		 pop	 edi
  000d2	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  000d9	8b 8c 24 1c 40
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+16428]
  000e0	5e		 pop	 esi
  000e1	33 cc		 xor	 ecx, esp
  000e3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e8	81 c4 28 40 00
	00		 add	 esp, 16424		; 00004028H
  000ee	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L335996:
  00000	8d 8d dc bf ff
	ff		 lea	 ecx, DWORD PTR _ar$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CAr@@QAE@XZ		; CAr::~CAr
__ehhandler$?AddLEventCreate@CUserMng@@QAEXPAVCLEComponent@@@Z:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T336012
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?AddLEventCreate@CUserMng@@QAEXPAVCLEComponent@@@Z ENDP	; CUserMng::AddLEventCreate
PUBLIC	?AddLEventInitialize@CUserMng@@QAEXXZ		; CUserMng::AddLEventInitialize
;	COMDAT xdata$x
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_network\misc\include\ar.h
xdata$x	SEGMENT
$T336040 DD	0ffffffffH
	DD	FLAT:$L336022
$T336037 DD	019930520H
	DD	01H
	DD	FLAT:$T336040
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
xdata$x	ENDS
;	COMDAT ?AddLEventInitialize@CUserMng@@QAEXXZ
_TEXT	SEGMENT
_uBufSize$ = -16424					; size = 4
_ar$ = -16420						; size = 16404
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
?AddLEventInitialize@CUserMng@@QAEXXZ PROC NEAR		; CUserMng::AddLEventInitialize, COMDAT
; _this$ = ecx

; 8309 : {

  00000	6a ff		 push	 -1
  00002	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00008	68 00 00 00 00	 push	 __ehhandler$?AddLEventInitialize@CUserMng@@QAEXXZ
  0000d	50		 push	 eax
  0000e	b8 1c 40 00 00	 mov	 eax, 16412		; 0000401cH
  00013	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0001a	e8 00 00 00 00	 call	 __chkstk
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00024	33 c4		 xor	 eax, esp
  00026	56		 push	 esi

; 8310 : 	CAr ar;

  00027	6a 00		 push	 0
  00029	8b f1		 mov	 esi, ecx
  0002b	89 84 24 20 40
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+16432], eax
  00032	6a 00		 push	 0
  00034	8d 4c 24 10	 lea	 ecx, DWORD PTR _ar$[esp+16436]
  00038	e8 00 00 00 00	 call	 ??0CAr@@QAE@PAXI@Z	; CAr::CAr

; 8311 : 	ar << NULL_ID << SNAPSHOTTYPE_L_EVENT_INITIALIZE;

  0003d	6a 04		 push	 4
  0003f	8d 4c 24 0c	 lea	 ecx, DWORD PTR _ar$[esp+16432]
  00043	c7 84 24 2c 40
	00 00 00 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+16440], 0
  0004e	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00053	8b 44 24 10	 mov	 eax, DWORD PTR _ar$[esp+16436]
  00057	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [eax], -1
  0005d	8b 44 24 10	 mov	 eax, DWORD PTR _ar$[esp+16436]
  00061	83 c0 04	 add	 eax, 4
  00064	6a 02		 push	 2
  00066	8d 4c 24 0c	 lea	 ecx, DWORD PTR _ar$[esp+16432]
  0006a	89 44 24 14	 mov	 DWORD PTR _ar$[esp+16440], eax
  0006e	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00073	8b 4c 24 10	 mov	 ecx, DWORD PTR _ar$[esp+16436]
  00077	66 c7 01 09 8f	 mov	 WORD PTR [ecx], 36617	; 00008f09H
  0007c	8b 4c 24 10	 mov	 ecx, DWORD PTR _ar$[esp+16436]
  00080	83 c1 02	 add	 ecx, 2

; 8312 : 	GETBLOCK( ar, lpBuf, uBufSize );

  00083	8d 54 24 04	 lea	 edx, DWORD PTR _uBufSize$[esp+16428]
  00087	89 4c 24 10	 mov	 DWORD PTR _ar$[esp+16436], ecx
  0008b	52		 push	 edx
  0008c	8d 4c 24 0c	 lea	 ecx, DWORD PTR _ar$[esp+16432]
  00090	e8 00 00 00 00	 call	 ?GetBuffer@CAr@@QAEPAEPAH@Z ; CAr::GetBuffer

; 8313 : 	AddBlock( lpBuf, uBufSize );

  00095	8b 4c 24 04	 mov	 ecx, DWORD PTR _uBufSize$[esp+16428]
  00099	51		 push	 ecx
  0009a	50		 push	 eax
  0009b	8b ce		 mov	 ecx, esi
  0009d	e8 00 00 00 00	 call	 ?AddBlock@CUserMng@@QAEXPAEK@Z ; CUserMng::AddBlock

; 8314 : }

  000a2	8d 4c 24 08	 lea	 ecx, DWORD PTR _ar$[esp+16428]
  000a6	c7 84 24 28 40
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+16436], -1
  000b1	e8 00 00 00 00	 call	 ??1CAr@@QAE@XZ		; CAr::~CAr
  000b6	8b 8c 24 20 40
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+16428]
  000bd	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  000c4	8b 8c 24 1c 40
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+16428]
  000cb	5e		 pop	 esi
  000cc	33 cc		 xor	 ecx, esp
  000ce	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000d3	81 c4 28 40 00
	00		 add	 esp, 16424		; 00004028H
  000d9	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L336022:
  00000	8d 8d dc bf ff
	ff		 lea	 ecx, DWORD PTR _ar$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CAr@@QAE@XZ		; CAr::~CAr
__ehhandler$?AddLEventInitialize@CUserMng@@QAEXXZ:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T336037
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?AddLEventInitialize@CUserMng@@QAEXXZ ENDP		; CUserMng::AddLEventInitialize
PUBLIC	?AddLEventTick@CUserMng@@QAEXPAVILordEvent@@@Z	; CUserMng::AddLEventTick
EXTRN	?SerializeTick@ILordEvent@@QAEXAAVCAr@@@Z:NEAR	; ILordEvent::SerializeTick
;	COMDAT xdata$x
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_network\misc\include\ar.h
xdata$x	SEGMENT
$T336066 DD	0ffffffffH
	DD	FLAT:$L336047
$T336063 DD	019930520H
	DD	01H
	DD	FLAT:$T336066
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
xdata$x	ENDS
;	COMDAT ?AddLEventTick@CUserMng@@QAEXPAVILordEvent@@@Z
_TEXT	SEGMENT
_uBufSize$ = -16424					; size = 4
_ar$ = -16420						; size = 16404
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_pEvent$ = 8						; size = 4
?AddLEventTick@CUserMng@@QAEXPAVILordEvent@@@Z PROC NEAR ; CUserMng::AddLEventTick, COMDAT
; _this$ = ecx

; 8317 : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?AddLEventTick@CUserMng@@QAEXPAVILordEvent@@@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	b8 1c 40 00 00	 mov	 eax, 16412		; 0000401cH
  00013	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0001a	e8 00 00 00 00	 call	 __chkstk
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00024	33 c4		 xor	 eax, esp
  00026	56		 push	 esi
  00027	57		 push	 edi
  00028	8b bc 24 34 40
	00 00		 mov	 edi, DWORD PTR _pEvent$[esp+16428]

; 8318 : 	CAr ar;

  0002f	6a 00		 push	 0
  00031	8b f1		 mov	 esi, ecx
  00033	89 84 24 24 40
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+16436], eax
  0003a	6a 00		 push	 0
  0003c	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  00040	e8 00 00 00 00	 call	 ??0CAr@@QAE@PAXI@Z	; CAr::CAr

; 8319 : 	ar << NULL_ID << SNAPSHOTTYPE_L_EVENT_TICK;

  00045	6a 04		 push	 4
  00047	8d 4c 24 10	 lea	 ecx, DWORD PTR _ar$[esp+16436]
  0004b	c7 84 24 30 40
	00 00 00 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+16444], 0
  00056	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0005b	8b 44 24 14	 mov	 eax, DWORD PTR _ar$[esp+16440]
  0005f	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [eax], -1
  00065	8b 44 24 14	 mov	 eax, DWORD PTR _ar$[esp+16440]
  00069	83 c0 04	 add	 eax, 4
  0006c	6a 02		 push	 2
  0006e	8d 4c 24 10	 lea	 ecx, DWORD PTR _ar$[esp+16436]
  00072	89 44 24 18	 mov	 DWORD PTR _ar$[esp+16444], eax
  00076	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0007b	8b 4c 24 14	 mov	 ecx, DWORD PTR _ar$[esp+16440]
  0007f	66 c7 01 0b 8f	 mov	 WORD PTR [ecx], 36619	; 00008f0bH
  00084	8b 4c 24 14	 mov	 ecx, DWORD PTR _ar$[esp+16440]
  00088	83 c1 02	 add	 ecx, 2

; 8320 : 	pEvent->SerializeTick( ar );

  0008b	8d 54 24 0c	 lea	 edx, DWORD PTR _ar$[esp+16432]
  0008f	89 4c 24 14	 mov	 DWORD PTR _ar$[esp+16440], ecx
  00093	52		 push	 edx
  00094	8b cf		 mov	 ecx, edi
  00096	e8 00 00 00 00	 call	 ?SerializeTick@ILordEvent@@QAEXAAVCAr@@@Z ; ILordEvent::SerializeTick

; 8321 : 	GETBLOCK( ar, lpBuf, uBufSize );

  0009b	8d 44 24 08	 lea	 eax, DWORD PTR _uBufSize$[esp+16432]
  0009f	50		 push	 eax
  000a0	8d 4c 24 10	 lea	 ecx, DWORD PTR _ar$[esp+16436]
  000a4	e8 00 00 00 00	 call	 ?GetBuffer@CAr@@QAEPAEPAH@Z ; CAr::GetBuffer

; 8322 : 	AddBlock( lpBuf, uBufSize );

  000a9	8b 4c 24 08	 mov	 ecx, DWORD PTR _uBufSize$[esp+16432]
  000ad	51		 push	 ecx
  000ae	50		 push	 eax
  000af	8b ce		 mov	 ecx, esi
  000b1	e8 00 00 00 00	 call	 ?AddBlock@CUserMng@@QAEXPAEK@Z ; CUserMng::AddBlock

; 8323 : }

  000b6	8d 4c 24 0c	 lea	 ecx, DWORD PTR _ar$[esp+16432]
  000ba	c7 84 24 2c 40
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+16440], -1
  000c5	e8 00 00 00 00	 call	 ??1CAr@@QAE@XZ		; CAr::~CAr
  000ca	8b 8c 24 24 40
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+16432]
  000d1	5f		 pop	 edi
  000d2	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  000d9	8b 8c 24 1c 40
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+16428]
  000e0	5e		 pop	 esi
  000e1	33 cc		 xor	 ecx, esp
  000e3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e8	81 c4 28 40 00
	00		 add	 esp, 16424		; 00004028H
  000ee	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L336047:
  00000	8d 8d dc bf ff
	ff		 lea	 ecx, DWORD PTR _ar$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CAr@@QAE@XZ		; CAr::~CAr
__ehhandler$?AddLEventTick@CUserMng@@QAEXPAVILordEvent@@@Z:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T336063
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?AddLEventTick@CUserMng@@QAEXPAVILordEvent@@@Z ENDP	; CUserMng::AddLEventTick
PUBLIC	?AddLordSkillUse@CUserMng@@QAEXPAVCUser@@KH@Z	; CUserMng::AddLordSkillUse
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
xdata$x	SEGMENT
$T336346 DD	0ffffffffH
	DD	FLAT:$L336075
$T336338 DD	019930520H
	DD	01H
	DD	FLAT:$T336346
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
xdata$x	ENDS
;	COMDAT ?AddLordSkillUse@CUserMng@@QAEXPAVCUser@@KH@Z
_TEXT	SEGMENT
_nBufSize$ = -16424					; size = 4
_ar$ = -16420						; size = 16404
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_pUser$ = 8						; size = 4
_idTarget$ = 12						; size = 4
_nSkill$ = 16						; size = 4
?AddLordSkillUse@CUserMng@@QAEXPAVCUser@@KH@Z PROC NEAR	; CUserMng::AddLordSkillUse, COMDAT
; _this$ = ecx

; 8326 : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?AddLordSkillUse@CUserMng@@QAEXPAVCUser@@KH@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	b8 1c 40 00 00	 mov	 eax, 16412		; 0000401cH
  00013	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0001a	e8 00 00 00 00	 call	 __chkstk
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00024	33 c4		 xor	 eax, esp
  00026	53		 push	 ebx
  00027	55		 push	 ebp
  00028	56		 push	 esi
  00029	8b b4 24 38 40
	00 00		 mov	 esi, DWORD PTR _pUser$[esp+16432]
  00030	57		 push	 edi

; 8327 : 	CAr ar;

  00031	6a 00		 push	 0
  00033	6a 00		 push	 0
  00035	8d 4c 24 1c	 lea	 ecx, DWORD PTR _ar$[esp+16448]
  00039	89 84 24 30 40
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+16448], eax
  00040	e8 00 00 00 00	 call	 ??0CAr@@QAE@PAXI@Z	; CAr::CAr

; 8328 : 	ar << GETID( pUser ) << SNAPSHOTTYPE_LORD_SKILL_USE << idTarget << nSkill;

  00045	85 f6		 test	 esi, esi
  00047	c7 84 24 34 40
	00 00 00 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+16448], 0
  00052	74 08		 je	 SHORT $L336073
  00054	8b be bc 01 00
	00		 mov	 edi, DWORD PTR [esi+444]
  0005a	eb 03		 jmp	 SHORT $L336074
$L336073:
  0005c	83 cf ff	 or	 edi, -1
$L336074:
  0005f	bb 04 00 00 00	 mov	 ebx, 4
  00064	53		 push	 ebx
  00065	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  00069	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0006e	8b 44 24 1c	 mov	 eax, DWORD PTR _ar$[esp+16448]
  00072	89 38		 mov	 DWORD PTR [eax], edi
  00074	8b 7c 24 1c	 mov	 edi, DWORD PTR _ar$[esp+16448]
  00078	03 fb		 add	 edi, ebx
  0007a	6a 02		 push	 2
  0007c	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  00080	89 7c 24 20	 mov	 DWORD PTR _ar$[esp+16452], edi
  00084	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00089	8b 4c 24 1c	 mov	 ecx, DWORD PTR _ar$[esp+16448]
  0008d	66 c7 01 0d 8f	 mov	 WORD PTR [ecx], 36621	; 00008f0dH
  00092	83 44 24 1c 02	 add	 DWORD PTR _ar$[esp+16448], 2
  00097	53		 push	 ebx
  00098	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  0009c	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000a1	8b 54 24 1c	 mov	 edx, DWORD PTR _ar$[esp+16448]
  000a5	8b 84 24 40 40
	00 00		 mov	 eax, DWORD PTR _idTarget$[esp+16436]
  000ac	89 02		 mov	 DWORD PTR [edx], eax
  000ae	8b 6c 24 1c	 mov	 ebp, DWORD PTR _ar$[esp+16448]
  000b2	03 eb		 add	 ebp, ebx
  000b4	53		 push	 ebx
  000b5	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  000b9	89 6c 24 20	 mov	 DWORD PTR _ar$[esp+16452], ebp
  000bd	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000c2	8b 4c 24 1c	 mov	 ecx, DWORD PTR _ar$[esp+16448]
  000c6	8b 94 24 44 40
	00 00		 mov	 edx, DWORD PTR _nSkill$[esp+16436]
  000cd	89 11		 mov	 DWORD PTR [ecx], edx
  000cf	8b 54 24 1c	 mov	 edx, DWORD PTR _ar$[esp+16448]

; 8329 : 	GETBLOCK( ar, lpBuf, nBufSize );

  000d3	8d 44 24 10	 lea	 eax, DWORD PTR _nBufSize$[esp+16440]
  000d7	03 d3		 add	 edx, ebx
  000d9	50		 push	 eax
  000da	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  000de	89 54 24 20	 mov	 DWORD PTR _ar$[esp+16452], edx
  000e2	e8 00 00 00 00	 call	 ?GetBuffer@CAr@@QAEPAEPAH@Z ; CAr::GetBuffer

; 8330 : 
; 8331 : 	FOR_VISIBILITYRANGE( pUser )

  000e7	8b be 10 02 00
	00		 mov	 edi, DWORD PTR [esi+528]
  000ed	8b 37		 mov	 esi, DWORD PTR [edi]
  000ef	3b f7		 cmp	 esi, edi
  000f1	8b e8		 mov	 ebp, eax
  000f3	74 79		 je	 SHORT $L285366
  000f5	b3 01		 mov	 bl, 1
  000f7	eb 07 8d a4 24
	00 00 00 00	 npad	 9
$L285365:

; 8332 : 	{
; 8333 : 		USERPTR->AddBlock( lpBuf, nBufSize );

  00100	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00103	84 58 04	 test	 BYTE PTR [eax+4], bl
  00106	8b 4c 24 10	 mov	 ecx, DWORD PTR _nBufSize$[esp+16440]
  0010a	75 14		 jne	 SHORT $L336182
  0010c	66 ff 80 0c 57
	00 00		 inc	 WORD PTR [eax+22284]
  00113	51		 push	 ecx
  00114	55		 push	 ebp
  00115	8d 88 f8 16 00
	00		 lea	 ecx, DWORD PTR [eax+5880]
  0011b	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
$L336182:

; 8334 : 	}
; 8335 : 	NEXT_VISIBILITYRANGE( pUser )

  00120	8a 46 15	 mov	 al, BYTE PTR [esi+21]
  00123	84 c0		 test	 al, al
  00125	75 43		 jne	 SHORT $L336330
  00127	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0012a	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  0012d	84 c9		 test	 cl, cl
  0012f	75 1c		 jne	 SHORT $L336341
  00131	8b f0		 mov	 esi, eax
  00133	8b 06		 mov	 eax, DWORD PTR [esi]
  00135	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00138	84 c9		 test	 cl, cl
  0013a	75 2e		 jne	 SHORT $L336330
  0013c	8d 64 24 00	 npad	 4
$L336318:
  00140	8b f0		 mov	 esi, eax
  00142	8b 06		 mov	 eax, DWORD PTR [esi]
  00144	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00147	84 c9		 test	 cl, cl
  00149	74 f5		 je	 SHORT $L336318
  0014b	eb 1d		 jmp	 SHORT $L336330
$L336341:
  0014d	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00150	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00153	84 c9		 test	 cl, cl
  00155	75 11		 jne	 SHORT $L336333
$L336332:
  00157	3b 70 08	 cmp	 esi, DWORD PTR [eax+8]
  0015a	75 0c		 jne	 SHORT $L336333
  0015c	8b f0		 mov	 esi, eax
  0015e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00161	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00164	84 c9		 test	 cl, cl
  00166	74 ef		 je	 SHORT $L336332
$L336333:
  00168	8b f0		 mov	 esi, eax
$L336330:

; 8330 : 
; 8331 : 	FOR_VISIBILITYRANGE( pUser )

  0016a	3b f7		 cmp	 esi, edi
  0016c	75 92		 jne	 SHORT $L285365
$L285366:

; 8336 : }

  0016e	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  00172	c7 84 24 34 40
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+16448], -1
  0017d	e8 00 00 00 00	 call	 ??1CAr@@QAE@XZ		; CAr::~CAr
  00182	8b 8c 24 2c 40
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+16440]
  00189	5f		 pop	 edi
  0018a	5e		 pop	 esi
  0018b	5d		 pop	 ebp
  0018c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00193	8b 8c 24 1c 40
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+16428]
  0019a	5b		 pop	 ebx
  0019b	33 cc		 xor	 ecx, esp
  0019d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001a2	81 c4 28 40 00
	00		 add	 esp, 16424		; 00004028H
  001a8	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L336075:
  00000	8d 8d dc bf ff
	ff		 lea	 ecx, DWORD PTR _ar$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CAr@@QAE@XZ		; CAr::~CAr
__ehhandler$?AddLordSkillUse@CUserMng@@QAEXPAVCUser@@KH@Z:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T336338
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?AddLordSkillUse@CUserMng@@QAEXPAVCUser@@KH@Z ENDP	; CUserMng::AddLordSkillUse
PUBLIC	?AddQueryPlayerData@CUserMng@@QAEXK@Z		; CUserMng::AddQueryPlayerData
EXTRN	?GetPlayerData@CPlayerDataCenter@@QAEPAU_PlayerData@@K@Z:NEAR ; CPlayerDataCenter::GetPlayerData
;	COMDAT xdata$x
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_network\misc\include\ar.h
xdata$x	SEGMENT
$T336375 DD	0ffffffffH
	DD	FLAT:$L336353
$T336371 DD	019930520H
	DD	01H
	DD	FLAT:$T336375
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
xdata$x	ENDS
;	COMDAT ?AddQueryPlayerData@CUserMng@@QAEXK@Z
_TEXT	SEGMENT
_uBufSize$ = -16424					; size = 4
_ar$ = -16420						; size = 16404
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_idPlayer$ = 8						; size = 4
?AddQueryPlayerData@CUserMng@@QAEXK@Z PROC NEAR		; CUserMng::AddQueryPlayerData, COMDAT
; _this$ = ecx

; 8339 : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?AddQueryPlayerData@CUserMng@@QAEXK@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	b8 1c 40 00 00	 mov	 eax, 16412		; 0000401cH
  00013	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0001a	e8 00 00 00 00	 call	 __chkstk
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00024	33 c4		 xor	 eax, esp
  00026	53		 push	 ebx
  00027	57		 push	 edi

; 8340 : 	if( idPlayer == NULL_ID )

  00028	8b bc 24 34 40
	00 00		 mov	 edi, DWORD PTR _idPlayer$[esp+16428]
  0002f	83 ff ff	 cmp	 edi, -1
  00032	89 84 24 20 40
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+16432], eax
  00039	8b d9		 mov	 ebx, ecx
  0003b	0f 84 ce 00 00
	00		 je	 $L285370
  00041	56		 push	 esi

; 8341 : 		return;
; 8342 : 	PlayerData* pData	= CPlayerDataCenter::GetInstance()->GetPlayerData( idPlayer );

  00042	57		 push	 edi
  00043	e8 00 00 00 00	 call	 ?GetInstance@CPlayerDataCenter@@SAPAV1@XZ ; CPlayerDataCenter::GetInstance
  00048	8b c8		 mov	 ecx, eax
  0004a	e8 00 00 00 00	 call	 ?GetPlayerData@CPlayerDataCenter@@QAEPAU_PlayerData@@K@Z ; CPlayerDataCenter::GetPlayerData
  0004f	8b f0		 mov	 esi, eax

; 8343 : 	if( !pData )

  00051	85 f6		 test	 esi, esi
  00053	0f 84 b5 00 00
	00		 je	 $L336374

; 8344 : 		return;
; 8345 : 	CAr ar;

  00059	6a 00		 push	 0
  0005b	6a 00		 push	 0
  0005d	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  00061	e8 00 00 00 00	 call	 ??0CAr@@QAE@PAXI@Z	; CAr::CAr

; 8346 : 	ar << NULL_ID << SNAPSHOTTYPE_QUERY_PLAYER_DATA;

  00066	6a 04		 push	 4
  00068	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  0006c	c7 84 24 34 40
	00 00 00 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+16448], 0
  00077	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0007c	8b 44 24 18	 mov	 eax, DWORD PTR _ar$[esp+16444]
  00080	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [eax], -1
  00086	8b 44 24 18	 mov	 eax, DWORD PTR _ar$[esp+16444]
  0008a	83 c0 04	 add	 eax, 4
  0008d	6a 02		 push	 2
  0008f	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  00093	89 44 24 1c	 mov	 DWORD PTR _ar$[esp+16448], eax
  00097	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0009c	8b 4c 24 18	 mov	 ecx, DWORD PTR _ar$[esp+16444]
  000a0	66 c7 01 41 01	 mov	 WORD PTR [ecx], 321	; 00000141H
  000a5	83 44 24 18 02	 add	 DWORD PTR _ar$[esp+16444], 2

; 8347 : 	ar << idPlayer;

  000aa	6a 04		 push	 4
  000ac	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  000b0	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000b5	8b 54 24 18	 mov	 edx, DWORD PTR _ar$[esp+16444]
  000b9	89 3a		 mov	 DWORD PTR [edx], edi
  000bb	8b 7c 24 18	 mov	 edi, DWORD PTR _ar$[esp+16444]

; 8348 : 	ar.WriteString( pData->szPlayer );

  000bf	8d 46 0c	 lea	 eax, DWORD PTR [esi+12]
  000c2	83 c7 04	 add	 edi, 4
  000c5	50		 push	 eax
  000c6	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  000ca	89 7c 24 1c	 mov	 DWORD PTR _ar$[esp+16448], edi
  000ce	e8 00 00 00 00	 call	 ?WriteString@CAr@@QAEXPBD@Z ; CAr::WriteString

; 8349 : 	ar.Write( &pData->data, sizeof(sPlayerData) );

  000d3	6a 0c		 push	 12			; 0000000cH
  000d5	56		 push	 esi
  000d6	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  000da	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write

; 8350 : 	GETBLOCK( ar, lpBuf, uBufSize );

  000df	8d 4c 24 0c	 lea	 ecx, DWORD PTR _uBufSize$[esp+16436]
  000e3	51		 push	 ecx
  000e4	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  000e8	e8 00 00 00 00	 call	 ?GetBuffer@CAr@@QAEPAEPAH@Z ; CAr::GetBuffer

; 8351 : 	AddBlock( lpBuf, uBufSize );

  000ed	8b 54 24 0c	 mov	 edx, DWORD PTR _uBufSize$[esp+16436]
  000f1	52		 push	 edx
  000f2	50		 push	 eax
  000f3	8b cb		 mov	 ecx, ebx
  000f5	e8 00 00 00 00	 call	 ?AddBlock@CUserMng@@QAEXPAEK@Z ; CUserMng::AddBlock

; 8352 : }

  000fa	8d 4c 24 10	 lea	 ecx, DWORD PTR _ar$[esp+16436]
  000fe	c7 84 24 30 40
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+16444], -1
  00109	e8 00 00 00 00	 call	 ??1CAr@@QAE@XZ		; CAr::~CAr
$L336374:
  0010e	5e		 pop	 esi
$L285370:
  0010f	8b 8c 24 24 40
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+16432]
  00116	5f		 pop	 edi
  00117	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0011e	8b 8c 24 1c 40
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+16428]
  00125	5b		 pop	 ebx
  00126	33 cc		 xor	 ecx, esp
  00128	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0012d	81 c4 28 40 00
	00		 add	 esp, 16424		; 00004028H
  00133	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L336353:
  00000	8d 8d dc bf ff
	ff		 lea	 ecx, DWORD PTR _ar$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CAr@@QAE@XZ		; CAr::~CAr
__ehhandler$?AddQueryPlayerData@CUserMng@@QAEXK@Z:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T336371
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?AddQueryPlayerData@CUserMng@@QAEXK@Z ENDP		; CUserMng::AddQueryPlayerData
PUBLIC	?AddTaxInfo@CUserMng@@QAEXXZ			; CUserMng::AddTaxInfo
; Function compile flags: /Ogty
;	COMDAT ?AddTaxInfo@CUserMng@@QAEXXZ
_TEXT	SEGMENT
_it$ = -8						; size = 4
_this$ = -4						; size = 4
?AddTaxInfo@CUserMng@@QAEXXZ PROC NEAR			; CUserMng::AddTaxInfo, COMDAT
; _this$ = ecx

; 8376 : {

  00000	83 ec 08	 sub	 esp, 8
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 8377 : 	map<DWORD, CUser*>::iterator it;
; 8378 : 	for( it = m_users.begin(); it != m_users.end(); ++it )

  00006	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  00009	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000b	3b c1		 cmp	 eax, ecx
  0000d	89 74 24 08	 mov	 DWORD PTR _this$[esp+12], esi
  00011	89 44 24 04	 mov	 DWORD PTR _it$[esp+12], eax
  00015	0f 84 80 00 00
	00		 je	 $L285405
  0001b	57		 push	 edi
  0001c	8d 64 24 00	 npad	 4
$L336424:

; 8379 : 	{
; 8380 : 		CUser* pUser = it->second;

  00020	8b 40 10	 mov	 eax, DWORD PTR [eax+16]

; 8381 : 		if( pUser->IsValid() == FALSE )

  00023	f6 40 04 01	 test	 BYTE PTR [eax+4], 1
  00027	75 5f		 jne	 SHORT $L285404
  00029	8b 88 e8 16 00
	00		 mov	 ecx, DWORD PTR [eax+5864]
  0002f	85 c9		 test	 ecx, ecx
  00031	74 55		 je	 SHORT $L285404

; 8382 : 			continue;
; 8383 : 		pUser->AddTaxInfo();

  00033	66 ff 80 0c 57
	00 00		 inc	 WORD PTR [eax+22284]
  0003a	8b b8 bc 01 00
	00		 mov	 edi, DWORD PTR [eax+444]
  00040	8d b0 f8 16 00
	00		 lea	 esi, DWORD PTR [eax+5880]
  00046	6a 04		 push	 4
  00048	8b ce		 mov	 ecx, esi
  0004a	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0004f	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00052	89 38		 mov	 DWORD PTR [eax], edi
  00054	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  00057	83 c7 04	 add	 edi, 4
  0005a	6a 02		 push	 2
  0005c	8b ce		 mov	 ecx, esi
  0005e	89 7e 08	 mov	 DWORD PTR [esi+8], edi
  00061	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00066	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00069	66 c7 01 00 04	 mov	 WORD PTR [ecx], 1024	; 00000400H
  0006e	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00071	83 c1 02	 add	 ecx, 2
  00074	56		 push	 esi
  00075	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  00078	e8 00 00 00 00	 call	 ?GetInstance@CTax@@SAPAV1@XZ ; CTax::GetInstance
  0007d	8b c8		 mov	 ecx, eax
  0007f	e8 00 00 00 00	 call	 ?Serialize@CTax@@QAEXAAVCAr@@@Z ; CTax::Serialize
  00084	8b 74 24 0c	 mov	 esi, DWORD PTR _this$[esp+16]
$L285404:
  00088	8d 4c 24 08	 lea	 ecx, DWORD PTR _it$[esp+16]
  0008c	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::const_iterator::_Inc
  00091	8b 44 24 08	 mov	 eax, DWORD PTR _it$[esp+16]
  00095	3b 46 0c	 cmp	 eax, DWORD PTR [esi+12]
  00098	75 86		 jne	 SHORT $L336424
  0009a	5f		 pop	 edi
$L285405:
  0009b	5e		 pop	 esi

; 8384 : 	}
; 8385 : }

  0009c	83 c4 08	 add	 esp, 8
  0009f	c3		 ret	 0
?AddTaxInfo@CUserMng@@QAEXXZ ENDP			; CUserMng::AddTaxInfo
_TEXT	ENDS
PUBLIC	?AddHousingPaperingInfo@CUserMng@@QAEXKHK@Z	; CUserMng::AddHousingPaperingInfo
; Function compile flags: /Ogty
;	COMDAT ?AddHousingPaperingInfo@CUserMng@@QAEXKHK@Z
_TEXT	SEGMENT
_it$285483 = -4						; size = 4
_dwItemId$ = 8						; size = 4
_bSetup$ = 12						; size = 4
_dwMasterId$ = 16					; size = 4
?AddHousingPaperingInfo@CUserMng@@QAEXKHK@Z PROC NEAR	; CUserMng::AddHousingPaperingInfo, COMDAT
; _this$ = ecx

; 8479 : {

  00000	51		 push	 ecx
  00001	55		 push	 ebp
  00002	8b e9		 mov	 ebp, ecx

; 8480 : 	for( map<DWORD, CUser*>::iterator it=m_users.begin(); it!=m_users.end(); ++it )

  00004	8b 4d 0c	 mov	 ecx, DWORD PTR [ebp+12]
  00007	8b 01		 mov	 eax, DWORD PTR [ecx]
  00009	3b c1		 cmp	 eax, ecx
  0000b	89 44 24 04	 mov	 DWORD PTR _it$285483[esp+8], eax
  0000f	74 58		 je	 SHORT $L285488
  00011	53		 push	 ebx
  00012	8b 5c 24 18	 mov	 ebx, DWORD PTR _dwMasterId$[esp+8]
  00016	56		 push	 esi
  00017	8b 74 24 18	 mov	 esi, DWORD PTR _bSetup$[esp+12]
  0001b	57		 push	 edi
  0001c	8b 7c 24 18	 mov	 edi, DWORD PTR _dwItemId$[esp+16]
$L336552:

; 8481 : 	{
; 8482 : 		CUser* pUser = it->second;

  00020	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]

; 8483 : 		if( pUser->IsValid() && pUser->GetWorld() && pUser->GetWorld()->GetID() == WI_WORLD_MINIROOM  )

  00023	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00027	75 2b		 jne	 SHORT $L285487
  00029	8b 81 e8 16 00
	00		 mov	 eax, DWORD PTR [ecx+5864]
  0002f	85 c0		 test	 eax, eax
  00031	74 21		 je	 SHORT $L285487
  00033	8b 81 6c 01 00
	00		 mov	 eax, DWORD PTR [ecx+364]
  00039	85 c0		 test	 eax, eax
  0003b	74 17		 je	 SHORT $L285487
  0003d	81 38 d1 00 00
	00		 cmp	 DWORD PTR [eax], 209	; 000000d1H
  00043	75 0f		 jne	 SHORT $L285487

; 8484 : 		{
; 8485 : 			if( pUser->GetLayer() == static_cast<int>( dwMasterId ) )

  00045	39 99 b8 01 00
	00		 cmp	 DWORD PTR [ecx+440], ebx
  0004b	75 07		 jne	 SHORT $L285487

; 8486 : 				pUser->AddHousingPaperingInfo( dwItemId, bSetup );

  0004d	56		 push	 esi
  0004e	57		 push	 edi
  0004f	e8 00 00 00 00	 call	 ?AddHousingPaperingInfo@CUser@@QAEXKH@Z ; CUser::AddHousingPaperingInfo
$L285487:
  00054	8d 4c 24 10	 lea	 ecx, DWORD PTR _it$285483[esp+20]
  00058	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::const_iterator::_Inc
  0005d	8b 44 24 10	 mov	 eax, DWORD PTR _it$285483[esp+20]
  00061	3b 45 0c	 cmp	 eax, DWORD PTR [ebp+12]
  00064	75 ba		 jne	 SHORT $L336552
  00066	5f		 pop	 edi
  00067	5e		 pop	 esi
  00068	5b		 pop	 ebx
$L285488:
  00069	5d		 pop	 ebp

; 8487 : 		}
; 8488 : 	}
; 8489 : }

  0006a	59		 pop	 ecx
  0006b	c2 0c 00	 ret	 12			; 0000000cH
?AddHousingPaperingInfo@CUserMng@@QAEXKHK@Z ENDP	; CUserMng::AddHousingPaperingInfo
_TEXT	ENDS
PUBLIC	?DoUseItemPetNaming@CUser@@QAEHXZ		; CUser::DoUseItemPetNaming
EXTRN	?IsAllowedLetter@CProject@@QAEHPBDH@Z:NEAR	; CProject::IsAllowedLetter
EXTRN	?SetName@CPet@@QAEXPBD@Z:NEAR			; CPet::SetName
EXTRN	?GetPet@CMover@@QAEPAVCPet@@XZ:NEAR		; CMover::GetPet
EXTRN	?IsInvalidName@CProject@@QAEHPBD@Z:NEAR		; CProject::IsInvalidName
; Function compile flags: /Ogty
;	COMDAT ?DoUseItemPetNaming@CUser@@QAEHXZ
_TEXT	SEGMENT
?DoUseItemPetNaming@CUser@@QAEHXZ PROC NEAR		; CUser::DoUseItemPetNaming, COMDAT
; _this$ = ecx

; 8564 : {

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	8b f1		 mov	 esi, ecx

; 8565 : 	CPet* pPet	= GetPet();

  00004	e8 00 00 00 00	 call	 ?GetPet@CMover@@QAEPAVCPet@@XZ ; CMover::GetPet
  00009	8b d8		 mov	 ebx, eax

; 8566 : 	if( !pPet )

  0000b	85 db		 test	 ebx, ebx
  0000d	75 14		 jne	 SHORT $L285548

; 8567 : 	{
; 8568 : 		AddDefinedText( TID_GAME_NAME_PET_E00 );

  0000f	68 be 0f 00 00	 push	 4030			; 00000fbeH
  00014	8b ce		 mov	 ecx, esi
  00016	e8 00 00 00 00	 call	 ?AddDefinedText@CUser@@QAEXH@Z ; CUser::AddDefinedText
  0001b	5e		 pop	 esi

; 8569 : 		return 1;

  0001c	b8 01 00 00 00	 mov	 eax, 1
  00021	5b		 pop	 ebx

; 8579 : }

  00022	c3		 ret	 0
$L285548:
  00023	57		 push	 edi

; 8570 : 	}
; 8571 : 	if( prj.IsInvalidName( GetInput() ) || !prj.IsAllowedLetter( GetInput() ) )

  00024	8d be 44 96 00
	00		 lea	 edi, DWORD PTR [esi+38468]
  0002a	57		 push	 edi
  0002b	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?prj@@3VCProject@@A
  00030	e8 00 00 00 00	 call	 ?IsInvalidName@CProject@@QAEHPBD@Z ; CProject::IsInvalidName
  00035	85 c0		 test	 eax, eax
  00037	75 2d		 jne	 SHORT $L285550
  00039	50		 push	 eax
  0003a	57		 push	 edi
  0003b	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?prj@@3VCProject@@A
  00040	e8 00 00 00 00	 call	 ?IsAllowedLetter@CProject@@QAEHPBDH@Z ; CProject::IsAllowedLetter
  00045	85 c0		 test	 eax, eax
  00047	74 1d		 je	 SHORT $L285550

; 8575 : 	}
; 8576 : 	pPet->SetName( GetInput() );

  00049	57		 push	 edi
  0004a	8b cb		 mov	 ecx, ebx
  0004c	e8 00 00 00 00	 call	 ?SetName@CPet@@QAEXPBD@Z ; CPet::SetName

; 8577 : 	g_UserMng.AddSetPetName( this, pPet->GetName() );

  00051	83 c3 16	 add	 ebx, 22			; 00000016H
  00054	53		 push	 ebx
  00055	56		 push	 esi
  00056	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_UserMng@@3VCUserMng@@A
  0005b	e8 00 00 00 00	 call	 ?AddSetPetName@CUserMng@@QAEXPAVCUser@@PBD@Z ; CUserMng::AddSetPetName
  00060	5f		 pop	 edi
  00061	5e		 pop	 esi

; 8578 : 	return 0;

  00062	33 c0		 xor	 eax, eax
  00064	5b		 pop	 ebx

; 8579 : }

  00065	c3		 ret	 0
$L285550:

; 8572 : 	{
; 8573 : 		AddDefinedText( TID_GAME_NAME_PET_E01 );

  00066	68 bf 0f 00 00	 push	 4031			; 00000fbfH
  0006b	8b ce		 mov	 ecx, esi
  0006d	e8 00 00 00 00	 call	 ?AddDefinedText@CUser@@QAEXH@Z ; CUser::AddDefinedText
  00072	5f		 pop	 edi
  00073	5e		 pop	 esi

; 8574 : 		return 1;

  00074	b8 01 00 00 00	 mov	 eax, 1
  00079	5b		 pop	 ebx

; 8579 : }

  0007a	c3		 ret	 0
?DoUseItemPetNaming@CUser@@QAEHXZ ENDP			; CUser::DoUseItemPetNaming
_TEXT	ENDS
PUBLIC	?AddChangeMoverSfxId@CUserMng@@QAEXPAVCMover@@@Z ; CUserMng::AddChangeMoverSfxId
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
xdata$x	SEGMENT
$T336918 DD	0ffffffffH
	DD	FLAT:$L336654
$T336910 DD	019930520H
	DD	01H
	DD	FLAT:$T336918
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
xdata$x	ENDS
;	COMDAT ?AddChangeMoverSfxId@CUserMng@@QAEXPAVCMover@@@Z
_TEXT	SEGMENT
_nBufSize$ = -16424					; size = 4
_ar$ = -16420						; size = 16404
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_pMover$ = 8						; size = 4
?AddChangeMoverSfxId@CUserMng@@QAEXPAVCMover@@@Z PROC NEAR ; CUserMng::AddChangeMoverSfxId, COMDAT
; _this$ = ecx

; 8691 : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?AddChangeMoverSfxId@CUserMng@@QAEXPAVCMover@@@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	b8 1c 40 00 00	 mov	 eax, 16412		; 0000401cH
  00013	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0001a	e8 00 00 00 00	 call	 __chkstk
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00024	33 c4		 xor	 eax, esp
  00026	55		 push	 ebp
  00027	56		 push	 esi
  00028	8b b4 24 34 40
	00 00		 mov	 esi, DWORD PTR _pMover$[esp+16428]
  0002f	57		 push	 edi

; 8692 : 	CAr ar;

  00030	6a 00		 push	 0
  00032	6a 00		 push	 0
  00034	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  00038	89 84 24 2c 40
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+16444], eax
  0003f	e8 00 00 00 00	 call	 ??0CAr@@QAE@PAXI@Z	; CAr::CAr

; 8693 : 	ar << GETID( pMover ) << SNAPSHOTTYPE_MOVER_CHANGESFX;

  00044	85 f6		 test	 esi, esi
  00046	c7 84 24 30 40
	00 00 00 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+16444], 0
  00051	74 08		 je	 SHORT $L336652
  00053	8b be bc 01 00
	00		 mov	 edi, DWORD PTR [esi+444]
  00059	eb 03		 jmp	 SHORT $L336653
$L336652:
  0005b	83 cf ff	 or	 edi, -1
$L336653:
  0005e	6a 04		 push	 4
  00060	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  00064	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00069	8b 44 24 18	 mov	 eax, DWORD PTR _ar$[esp+16444]
  0006d	89 38		 mov	 DWORD PTR [eax], edi
  0006f	8b 54 24 18	 mov	 edx, DWORD PTR _ar$[esp+16444]
  00073	83 c2 04	 add	 edx, 4
  00076	6a 02		 push	 2
  00078	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  0007c	89 54 24 1c	 mov	 DWORD PTR _ar$[esp+16448], edx
  00080	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00085	8b 4c 24 18	 mov	 ecx, DWORD PTR _ar$[esp+16444]
  00089	66 c7 01 00 88	 mov	 WORD PTR [ecx], 34816	; 00008800H
  0008e	8b 44 24 18	 mov	 eax, DWORD PTR _ar$[esp+16444]

; 8694 : 	ar << pMover->m_dwMoverSfxId;

  00092	8b be 90 11 00
	00		 mov	 edi, DWORD PTR [esi+4496]
  00098	83 c0 02	 add	 eax, 2
  0009b	6a 04		 push	 4
  0009d	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  000a1	89 44 24 1c	 mov	 DWORD PTR _ar$[esp+16448], eax
  000a5	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000aa	8b 54 24 18	 mov	 edx, DWORD PTR _ar$[esp+16444]
  000ae	89 3a		 mov	 DWORD PTR [edx], edi
  000b0	8b 54 24 18	 mov	 edx, DWORD PTR _ar$[esp+16444]

; 8695 : 
; 8696 : 	GETBLOCK( ar, lpBuf, nBufSize );

  000b4	8d 44 24 0c	 lea	 eax, DWORD PTR _nBufSize$[esp+16436]
  000b8	83 c2 04	 add	 edx, 4
  000bb	50		 push	 eax
  000bc	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  000c0	89 54 24 1c	 mov	 DWORD PTR _ar$[esp+16448], edx
  000c4	e8 00 00 00 00	 call	 ?GetBuffer@CAr@@QAEPAEPAH@Z ; CAr::GetBuffer

; 8697 : 	
; 8698 : 	FOR_VISIBILITYRANGE( pMover )

  000c9	8b be 10 02 00
	00		 mov	 edi, DWORD PTR [esi+528]
  000cf	8b 37		 mov	 esi, DWORD PTR [edi]
  000d1	3b f7		 cmp	 esi, edi
  000d3	8b e8		 mov	 ebp, eax
  000d5	74 77		 je	 SHORT $L285625
  000d7	eb 07 8d a4 24
	00 00 00 00	 npad	 9
$L285624:

; 8699 : 		USERPTR->AddBlock( lpBuf, nBufSize );

  000e0	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  000e3	f6 40 04 01	 test	 BYTE PTR [eax+4], 1
  000e7	8b 4c 24 0c	 mov	 ecx, DWORD PTR _nBufSize$[esp+16436]
  000eb	75 14		 jne	 SHORT $L336751
  000ed	66 ff 80 0c 57
	00 00		 inc	 WORD PTR [eax+22284]
  000f4	51		 push	 ecx
  000f5	55		 push	 ebp
  000f6	8d 88 f8 16 00
	00		 lea	 ecx, DWORD PTR [eax+5880]
  000fc	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
$L336751:

; 8700 : 	NEXT_VISIBILITYRANGE( pMover )

  00101	8a 46 15	 mov	 al, BYTE PTR [esi+21]
  00104	84 c0		 test	 al, al
  00106	75 42		 jne	 SHORT $L336879
  00108	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0010b	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  0010e	84 c9		 test	 cl, cl
  00110	75 1b		 jne	 SHORT $L336913
  00112	8b f0		 mov	 esi, eax
  00114	8b 06		 mov	 eax, DWORD PTR [esi]
  00116	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00119	84 c9		 test	 cl, cl
  0011b	75 2d		 jne	 SHORT $L336879
  0011d	8d 49 00	 npad	 3
$L336893:
  00120	8b f0		 mov	 esi, eax
  00122	8b 06		 mov	 eax, DWORD PTR [esi]
  00124	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00127	84 c9		 test	 cl, cl
  00129	74 f5		 je	 SHORT $L336893
  0012b	eb 1d		 jmp	 SHORT $L336879
$L336913:
  0012d	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00130	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00133	84 c9		 test	 cl, cl
  00135	75 11		 jne	 SHORT $L336882
$L336881:
  00137	3b 70 08	 cmp	 esi, DWORD PTR [eax+8]
  0013a	75 0c		 jne	 SHORT $L336882
  0013c	8b f0		 mov	 esi, eax
  0013e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00141	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00144	84 c9		 test	 cl, cl
  00146	74 ef		 je	 SHORT $L336881
$L336882:
  00148	8b f0		 mov	 esi, eax
$L336879:

; 8697 : 	
; 8698 : 	FOR_VISIBILITYRANGE( pMover )

  0014a	3b f7		 cmp	 esi, edi
  0014c	75 92		 jne	 SHORT $L285624
$L285625:

; 8701 : }

  0014e	8d 4c 24 10	 lea	 ecx, DWORD PTR _ar$[esp+16436]
  00152	c7 84 24 30 40
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+16444], -1
  0015d	e8 00 00 00 00	 call	 ??1CAr@@QAE@XZ		; CAr::~CAr
  00162	8b 8c 24 28 40
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+16436]
  00169	5f		 pop	 edi
  0016a	5e		 pop	 esi
  0016b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00172	8b 8c 24 1c 40
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+16428]
  00179	5d		 pop	 ebp
  0017a	33 cc		 xor	 ecx, esp
  0017c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00181	81 c4 28 40 00
	00		 add	 esp, 16424		; 00004028H
  00187	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L336654:
  00000	8d 8d dc bf ff
	ff		 lea	 ecx, DWORD PTR _ar$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CAr@@QAE@XZ		; CAr::~CAr
__ehhandler$?AddChangeMoverSfxId@CUserMng@@QAEXPAVCMover@@@Z:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T336910
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?AddChangeMoverSfxId@CUserMng@@QAEXPAVCMover@@@Z ENDP	; CUserMng::AddChangeMoverSfxId
PUBLIC	?HasUserSameWorldnLayer@CUserMng@@QAEHPAVCUser@@@Z ; CUserMng::HasUserSameWorldnLayer
; Function compile flags: /Ogty
;	COMDAT ?HasUserSameWorldnLayer@CUserMng@@QAEHPAVCUser@@@Z
_TEXT	SEGMENT
_it$285690 = 8						; size = 4
_pUserSrc$ = 8						; size = 4
?HasUserSameWorldnLayer@CUserMng@@QAEHPAVCUser@@@Z PROC NEAR ; CUserMng::HasUserSameWorldnLayer, COMDAT
; _this$ = ecx

; 8784 : {

  00000	53		 push	 ebx
  00001	56		 push	 esi

; 8785 : 	if( !IsValidObj( pUserSrc ) || !pUserSrc->GetWorld() )

  00002	8b 74 24 0c	 mov	 esi, DWORD PTR _pUserSrc$[esp+4]
  00006	85 f6		 test	 esi, esi
  00008	74 6d		 je	 SHORT $L285684
  0000a	f6 46 04 01	 test	 BYTE PTR [esi+4], 1
  0000e	75 67		 jne	 SHORT $L285684
  00010	8b 9e 6c 01 00
	00		 mov	 ebx, DWORD PTR [esi+364]
  00016	85 db		 test	 ebx, ebx
  00018	74 5d		 je	 SHORT $L285684
  0001a	57		 push	 edi

; 8787 : 
; 8788 : 	for( map<DWORD, CUser*>::iterator it=m_users.begin(); it!=m_users.end(); it++ )

  0001b	8b 79 0c	 mov	 edi, DWORD PTR [ecx+12]
  0001e	8b 07		 mov	 eax, DWORD PTR [edi]
  00020	3b c7		 cmp	 eax, edi
  00022	89 44 24 10	 mov	 DWORD PTR _it$285690[esp+8], eax
  00026	74 3c		 je	 SHORT $L285696
$L336985:

; 8789 : 	{
; 8790 : 		if( ( pUserSrc != it->second ) && ( pUserSrc->GetWorld() && it->second->GetWorld() )
; 8791 : 			&& ( pUserSrc->GetWorld()->GetID() == it->second->GetWorld()->GetID() ) && ( pUserSrc->GetLayer() && it->second->GetLayer() ) )

  00028	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  0002b	3b f0		 cmp	 esi, eax
  0002d	74 24		 je	 SHORT $L285695
  0002f	8b 88 6c 01 00
	00		 mov	 ecx, DWORD PTR [eax+364]
  00035	85 c9		 test	 ecx, ecx
  00037	74 1a		 je	 SHORT $L285695
  00039	8b 13		 mov	 edx, DWORD PTR [ebx]
  0003b	3b 11		 cmp	 edx, DWORD PTR [ecx]
  0003d	75 14		 jne	 SHORT $L285695
  0003f	8b 8e b8 01 00
	00		 mov	 ecx, DWORD PTR [esi+440]
  00045	85 c9		 test	 ecx, ecx
  00047	74 0a		 je	 SHORT $L285695
  00049	8b 88 b8 01 00
	00		 mov	 ecx, DWORD PTR [eax+440]
  0004f	85 c9		 test	 ecx, ecx
  00051	75 19		 jne	 SHORT $L337140
$L285695:

; 8787 : 
; 8788 : 	for( map<DWORD, CUser*>::iterator it=m_users.begin(); it!=m_users.end(); it++ )

  00053	8d 4c 24 10	 lea	 ecx, DWORD PTR _it$285690[esp+8]
  00057	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::const_iterator::_Inc
  0005c	8b 44 24 10	 mov	 eax, DWORD PTR _it$285690[esp+8]
  00060	3b c7		 cmp	 eax, edi
  00062	75 c4		 jne	 SHORT $L336985
$L285696:
  00064	5f		 pop	 edi
  00065	5e		 pop	 esi

; 8793 : 	}
; 8794 : 
; 8795 : 	return FALSE;

  00066	33 c0		 xor	 eax, eax
  00068	5b		 pop	 ebx

; 8796 : }

  00069	c2 04 00	 ret	 4
$L337140:
  0006c	5f		 pop	 edi
  0006d	5e		 pop	 esi

; 8792 : 			return TRUE;

  0006e	b8 01 00 00 00	 mov	 eax, 1
  00073	5b		 pop	 ebx

; 8796 : }

  00074	c2 04 00	 ret	 4
$L285684:
  00077	5e		 pop	 esi

; 8786 : 		return FALSE;

  00078	33 c0		 xor	 eax, eax
  0007a	5b		 pop	 ebx

; 8796 : }

  0007b	c2 04 00	 ret	 4
?HasUserSameWorldnLayer@CUserMng@@QAEHPAVCUser@@@Z ENDP	; CUserMng::HasUserSameWorldnLayer
_TEXT	ENDS
PUBLIC	?ProcessCampus@CUser@@QAEXXZ			; CUser::ProcessCampus
EXTRN	?IsMember@CCampus@@QAEHK@Z:NEAR			; CCampus::IsMember
EXTRN	?IsChangeBuffLevel@CCampus@@QAEHK@Z:NEAR	; CCampus::IsChangeBuffLevel
EXTRN	?GetBuffLevel@CCampus@@QAEHK@Z:NEAR		; CCampus::GetBuffLevel
; Function compile flags: /Ogty
;	COMDAT ?ProcessCampus@CUser@@QAEXXZ
_TEXT	SEGMENT
?ProcessCampus@CUser@@QAEXXZ PROC NEAR			; CUser::ProcessCampus, COMDAT
; _this$ = ecx

; 8857 : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	57		 push	 edi

; 8858 : 	CCampus* pCampus = CCampusHelper::GetInstance()->GetCampus( GetCampusId() );

  00004	8b be 70 16 00
	00		 mov	 edi, DWORD PTR [esi+5744]
  0000a	e8 00 00 00 00	 call	 ?GetInstance@CCampusHelper@@SAPAV1@XZ ; CCampusHelper::GetInstance
  0000f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00011	57		 push	 edi
  00012	e8 00 00 00 00	 call	 ?GetCampus@CCampusMng@@QAEPAVCCampus@@K@Z ; CCampusMng::GetCampus
  00017	8b f8		 mov	 edi, eax

; 8859 : 	if( pCampus && pCampus->IsMember( m_idPlayer ) )

  00019	85 ff		 test	 edi, edi
  0001b	74 76		 je	 SHORT $L285735
  0001d	8b 86 38 02 00
	00		 mov	 eax, DWORD PTR [esi+568]
  00023	50		 push	 eax
  00024	8b cf		 mov	 ecx, edi
  00026	e8 00 00 00 00	 call	 ?IsMember@CCampus@@QAEHK@Z ; CCampus::IsMember
  0002b	85 c0		 test	 eax, eax
  0002d	74 64		 je	 SHORT $L285735

; 8860 : 	{
; 8861 : 		int nBuffLevel = pCampus->GetBuffLevel( m_idPlayer );

  0002f	8b 8e 38 02 00
	00		 mov	 ecx, DWORD PTR [esi+568]
  00035	53		 push	 ebx
  00036	51		 push	 ecx
  00037	8b cf		 mov	 ecx, edi
  00039	e8 00 00 00 00	 call	 ?GetBuffLevel@CCampus@@QAEHK@Z ; CCampus::GetBuffLevel
  0003e	8b d8		 mov	 ebx, eax

; 8862 : 		if( nBuffLevel )

  00040	85 db		 test	 ebx, ebx
  00042	74 3f		 je	 SHORT $L285737

; 8863 : 		{
; 8864 : 			if( pCampus->IsMaster( m_idPlayer ) )

  00044	8b 86 38 02 00
	00		 mov	 eax, DWORD PTR [esi+568]
  0004a	3b 47 04	 cmp	 eax, DWORD PTR [edi+4]
  0004d	75 18		 jne	 SHORT $L285739

; 8865 : 			{
; 8866 : 				if( pCampus->IsChangeBuffLevel( m_idPlayer ) )

  0004f	50		 push	 eax
  00050	8b cf		 mov	 ecx, edi
  00052	e8 00 00 00 00	 call	 ?IsChangeBuffLevel@CCampus@@QAEHK@Z ; CCampus::IsChangeBuffLevel
  00057	85 c0		 test	 eax, eax
  00059	74 0c		 je	 SHORT $L285739

; 8867 : 					RemoveIk3Buffs( IK3_TS_BUFF );

  0005b	68 8b 00 00 00	 push	 139			; 0000008bH
  00060	8b ce		 mov	 ecx, esi
  00062	e8 00 00 00 00	 call	 ?RemoveIk3Buffs@CMover@@QAEXK@Z ; CMover::RemoveIk3Buffs
$L285739:

; 8868 : 			}
; 8869 : 			if( !HasBuffByIk3( IK3_TS_BUFF ) )

  00067	68 8b 00 00 00	 push	 139			; 0000008bH
  0006c	8b ce		 mov	 ecx, esi
  0006e	e8 00 00 00 00	 call	 ?HasBuffByIk3@CMover@@QAEHK@Z ; CMover::HasBuffByIk3
  00073	85 c0		 test	 eax, eax
  00075	75 08		 jne	 SHORT $L337160

; 8870 : 				ActiveCampusBuff( nBuffLevel );

  00077	53		 push	 ebx
  00078	8b ce		 mov	 ecx, esi
  0007a	e8 00 00 00 00	 call	 ?ActiveCampusBuff@CUser@@QAEXH@Z ; CUser::ActiveCampusBuff
$L337160:
  0007f	5b		 pop	 ebx
  00080	5f		 pop	 edi
  00081	5e		 pop	 esi

; 8877 : }

  00082	c3		 ret	 0
$L285737:

; 8871 : 		}
; 8872 : 		else
; 8873 : 			RemoveIk3Buffs( IK3_TS_BUFF );

  00083	68 8b 00 00 00	 push	 139			; 0000008bH
  00088	8b ce		 mov	 ecx, esi
  0008a	e8 00 00 00 00	 call	 ?RemoveIk3Buffs@CMover@@QAEXK@Z ; CMover::RemoveIk3Buffs
  0008f	5b		 pop	 ebx
  00090	5f		 pop	 edi
  00091	5e		 pop	 esi

; 8877 : }

  00092	c3		 ret	 0
$L285735:

; 8874 : 	}
; 8875 : 	else
; 8876 : 		RemoveIk3Buffs( IK3_TS_BUFF );

  00093	68 8b 00 00 00	 push	 139			; 0000008bH
  00098	8b ce		 mov	 ecx, esi
  0009a	e8 00 00 00 00	 call	 ?RemoveIk3Buffs@CMover@@QAEXK@Z ; CMover::RemoveIk3Buffs
  0009f	5f		 pop	 edi
  000a0	5e		 pop	 esi

; 8877 : }

  000a1	c3		 ret	 0
?ProcessCampus@CUser@@QAEXXZ ENDP			; CUser::ProcessCampus
_TEXT	ENDS
PUBLIC	?find@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::find
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ?find@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z
_TEXT	SEGMENT
$T337167 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Keyval$ = 12						; size = 4
?find@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::find, COMDAT
; _this$ = ecx

; 787  : 		{	// find an element in mutable sequence that matches _Keyval

  00000	51		 push	 ecx

; 788  : 		iterator _Where = lower_bound(_Keyval);

  00001	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00004	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00007	53		 push	 ebx
  00008	8a 58 15	 mov	 bl, BYTE PTR [eax+21]
  0000b	84 db		 test	 bl, bl
  0000d	56		 push	 esi
  0000e	57		 push	 edi
  0000f	8b 7c 24 18	 mov	 edi, DWORD PTR __Keyval$[esp+12]
  00013	75 17		 jne	 SHORT $L337263
  00015	8b 37		 mov	 esi, DWORD PTR [edi]
$L337262:
  00017	39 70 0c	 cmp	 DWORD PTR [eax+12], esi
  0001a	73 05		 jae	 SHORT $L337264
  0001c	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0001f	eb 04		 jmp	 SHORT $L337265
$L337264:
  00021	8b d0		 mov	 edx, eax
  00023	8b 00		 mov	 eax, DWORD PTR [eax]
$L337265:
  00025	8a 58 15	 mov	 bl, BYTE PTR [eax+21]
  00028	84 db		 test	 bl, bl
  0002a	74 eb		 je	 SHORT $L337262
$L337263:

; 789  : 		return (_Where == end() || this->comp(_Keyval, _Key(_Where._Mynode()))
; 790  : 			? end() : _Where);

  0002c	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0002f	3b d0		 cmp	 edx, eax
  00031	89 54 24 18	 mov	 DWORD PTR __Where$[esp+12], edx
  00035	74 1a		 je	 SHORT $L337166
  00037	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00039	3b 4a 0c	 cmp	 ecx, DWORD PTR [edx+12]
  0003c	72 13		 jb	 SHORT $L337166
  0003e	8d 44 24 18	 lea	 eax, DWORD PTR __Where$[esp+12]
  00042	8b 10		 mov	 edx, DWORD PTR [eax]
  00044	8b 44 24 14	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp+12]
  00048	5f		 pop	 edi
  00049	5e		 pop	 esi
  0004a	89 10		 mov	 DWORD PTR [eax], edx
  0004c	5b		 pop	 ebx

; 791  : 		}

  0004d	59		 pop	 ecx
  0004e	c2 08 00	 ret	 8
$L337166:

; 789  : 		return (_Where == end() || this->comp(_Keyval, _Key(_Where._Mynode()))
; 790  : 			? end() : _Where);

  00051	89 44 24 0c	 mov	 DWORD PTR $T337167[esp+16], eax
  00055	8d 44 24 0c	 lea	 eax, DWORD PTR $T337167[esp+16]
  00059	8b 10		 mov	 edx, DWORD PTR [eax]
  0005b	8b 44 24 14	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp+12]
  0005f	5f		 pop	 edi
  00060	5e		 pop	 esi
  00061	89 10		 mov	 DWORD PTR [eax], edx
  00063	5b		 pop	 ebx

; 791  : 		}

  00064	59		 pop	 ecx
  00065	c2 08 00	 ret	 8
?find@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::find
_TEXT	ENDS
PUBLIC	??A?$vector@KV?$allocator@K@std@@@std@@QAEAAKI@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::operator[]
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ??A?$vector@KV?$allocator@K@std@@@std@@QAEAAKI@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@KV?$allocator@K@std@@@std@@QAEAAKI@Z PROC NEAR ; std::vector<unsigned long,std::allocator<unsigned long> >::operator[], COMDAT
; _this$ = ecx

; 555  : 		return (*(begin() + _Pos));

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	8b 4c 24 04	 mov	 ecx, DWORD PTR __Pos$[esp-4]
  00007	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]

; 556  : 		}

  0000a	c2 04 00	 ret	 4
??A?$vector@KV?$allocator@K@std@@@std@@QAEAAKI@Z ENDP	; std::vector<unsigned long,std::allocator<unsigned long> >::operator[]
_TEXT	ENDS
PUBLIC	??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z ; std::vector<int,std::allocator<int> >::operator[]
; Function compile flags: /Ogty
;	COMDAT ??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z PROC NEAR ; std::vector<int,std::allocator<int> >::operator[], COMDAT
; _this$ = ecx

; 555  : 		return (*(begin() + _Pos));

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	8b 4c 24 04	 mov	 ecx, DWORD PTR __Pos$[esp-4]
  00007	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]

; 556  : 		}

  0000a	c2 04 00	 ret	 4
??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z ENDP	; std::vector<int,std::allocator<int> >::operator[]
_TEXT	ENDS
PUBLIC	??A?$vector@EV?$allocator@E@std@@@std@@QAEAAEI@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::operator[]
; Function compile flags: /Ogty
;	COMDAT ??A?$vector@EV?$allocator@E@std@@@std@@QAEAAEI@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@EV?$allocator@E@std@@@std@@QAEAAEI@Z PROC NEAR ; std::vector<unsigned char,std::allocator<unsigned char> >::operator[], COMDAT
; _this$ = ecx

; 555  : 		return (*(begin() + _Pos));

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	03 44 24 04	 add	 eax, DWORD PTR __Pos$[esp-4]

; 556  : 		}

  00007	c2 04 00	 ret	 4
??A?$vector@EV?$allocator@E@std@@@std@@QAEAAEI@Z ENDP	; std::vector<unsigned char,std::allocator<unsigned char> >::operator[]
_TEXT	ENDS
PUBLIC	??A?$vector@VCGuildCombat1to1@@V?$allocator@VCGuildCombat1to1@@@std@@@std@@QAEAAVCGuildCombat1to1@@I@Z ; std::vector<CGuildCombat1to1,std::allocator<CGuildCombat1to1> >::operator[]
; Function compile flags: /Ogty
;	COMDAT ??A?$vector@VCGuildCombat1to1@@V?$allocator@VCGuildCombat1to1@@@std@@@std@@QAEAAVCGuildCombat1to1@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@VCGuildCombat1to1@@V?$allocator@VCGuildCombat1to1@@@std@@@std@@QAEAAVCGuildCombat1to1@@I@Z PROC NEAR ; std::vector<CGuildCombat1to1,std::allocator<CGuildCombat1to1> >::operator[], COMDAT
; _this$ = ecx

; 555  : 		return (*(begin() + _Pos));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pos$[esp-4]
  00004	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00007	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  0000a	c1 e0 04	 shl	 eax, 4
  0000d	03 c2		 add	 eax, edx

; 556  : 		}

  0000f	c2 04 00	 ret	 4
??A?$vector@VCGuildCombat1to1@@V?$allocator@VCGuildCombat1to1@@@std@@@std@@QAEAAVCGuildCombat1to1@@I@Z ENDP ; std::vector<CGuildCombat1to1,std::allocator<CGuildCombat1to1> >::operator[]
_TEXT	ENDS
PUBLIC	??A?$vector@U__GC1TO1TENDER@CGuildCombat1to1Mng@@V?$allocator@U__GC1TO1TENDER@CGuildCombat1to1Mng@@@std@@@std@@QAEAAU__GC1TO1TENDER@CGuildCombat1to1Mng@@I@Z ; std::vector<CGuildCombat1to1Mng::__GC1TO1TENDER,std::allocator<CGuildCombat1to1Mng::__GC1TO1TENDER> >::operator[]
; Function compile flags: /Ogty
;	COMDAT ??A?$vector@U__GC1TO1TENDER@CGuildCombat1to1Mng@@V?$allocator@U__GC1TO1TENDER@CGuildCombat1to1Mng@@@std@@@std@@QAEAAU__GC1TO1TENDER@CGuildCombat1to1Mng@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@U__GC1TO1TENDER@CGuildCombat1to1Mng@@V?$allocator@U__GC1TO1TENDER@CGuildCombat1to1Mng@@@std@@@std@@QAEAAU__GC1TO1TENDER@CGuildCombat1to1Mng@@I@Z PROC NEAR ; std::vector<CGuildCombat1to1Mng::__GC1TO1TENDER,std::allocator<CGuildCombat1to1Mng::__GC1TO1TENDER> >::operator[], COMDAT
; _this$ = ecx

; 555  : 		return (*(begin() + _Pos));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pos$[esp-4]
  00004	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00007	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  0000a	c1 e0 04	 shl	 eax, 4
  0000d	03 c2		 add	 eax, edx

; 556  : 		}

  0000f	c2 04 00	 ret	 4
??A?$vector@U__GC1TO1TENDER@CGuildCombat1to1Mng@@V?$allocator@U__GC1TO1TENDER@CGuildCombat1to1Mng@@@std@@@std@@QAEAAU__GC1TO1TENDER@CGuildCombat1to1Mng@@I@Z ENDP ; std::vector<CGuildCombat1to1Mng::__GC1TO1TENDER,std::allocator<CGuildCombat1to1Mng::__GC1TO1TENDER> >::operator[]
_TEXT	ENDS
PUBLIC	??Citerator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBEPAU?$pair@$$CBHH@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::iterator::operator->
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ??Citerator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBEPAU?$pair@$$CBHH@2@XZ
_TEXT	SEGMENT
??Citerator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBEPAU?$pair@$$CBHH@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::iterator::operator->, COMDAT
; _this$ = ecx

; 322  : 			return (&**this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 0c	 add	 eax, 12			; 0000000cH

; 323  : 			}

  00005	c3		 ret	 0
??Citerator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBEPAU?$pair@$$CBHH@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::iterator::operator->
_TEXT	ENDS
PUBLIC	??Citerator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QBEPAU?$pair@$$CBKU_Friend@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,_Friend,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,_Friend> >,0> >::iterator::operator->
; Function compile flags: /Ogty
;	COMDAT ??Citerator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QBEPAU?$pair@$$CBKU_Friend@@@2@XZ
_TEXT	SEGMENT
??Citerator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QBEPAU?$pair@$$CBKU_Friend@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,_Friend,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,_Friend> >,0> >::iterator::operator->, COMDAT
; _this$ = ecx

; 322  : 			return (&**this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 0c	 add	 eax, 12			; 0000000cH

; 323  : 			}

  00005	c3		 ret	 0
??Citerator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QBEPAU?$pair@$$CBKU_Friend@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,_Friend,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,_Friend> >,0> >::iterator::operator->
_TEXT	ENDS
PUBLIC	??Eiterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,_Friend,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,_Friend> >,0> >::iterator::operator++
; Function compile flags: /Ogty
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??Eiterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,_Friend,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,_Friend> >,0> >::iterator::operator++, COMDAT
; _this$ = ecx

; 326  : 			{	// preincrement

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 327  : 			++(*(const_iterator *)this);

  00003	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned long,_Friend,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,_Friend> >,0> >::const_iterator::_Inc

; 328  : 			return (*this);

  00008	8b c6		 mov	 eax, esi
  0000a	5e		 pop	 esi

; 329  : 			}

  0000b	c3		 ret	 0
??Eiterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,_Friend,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,_Friend> >,0> >::iterator::operator++
_TEXT	ENDS
PUBLIC	??A?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAEAAPAU__JOINPLAYER@CGuildCombat@@I@Z ; std::vector<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::operator[]
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ??A?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAEAAPAU__JOINPLAYER@CGuildCombat@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAEAAPAU__JOINPLAYER@CGuildCombat@@I@Z PROC NEAR ; std::vector<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::operator[], COMDAT
; _this$ = ecx

; 555  : 		return (*(begin() + _Pos));

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	8b 4c 24 04	 mov	 ecx, DWORD PTR __Pos$[esp-4]
  00007	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]

; 556  : 		}

  0000a	c2 04 00	 ret	 4
??A?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAEAAPAU__JOINPLAYER@CGuildCombat@@I@Z ENDP ; std::vector<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::operator[]
_TEXT	ENDS
PUBLIC	??1?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE@XZ ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::~list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\list
;	COMDAT ??1?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE@XZ PROC NEAR ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::~list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >, COMDAT
; _this$ = ecx

; 364  : 		{	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 365  : 		_Tidy();

  00003	e8 00 00 00 00	 call	 ?clear@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAEXXZ ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::clear
  00008	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00011	83 c4 04	 add	 esp, 4
  00014	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  0001b	5e		 pop	 esi

; 366  : 		}

  0001c	c3		 ret	 0
??1?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE@XZ ENDP ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::~list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >
_TEXT	ENDS
PUBLIC	??A?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@QAEAAU__GCGETPOINT@CGuildCombat@@I@Z ; std::vector<CGuildCombat::__GCGETPOINT,std::allocator<CGuildCombat::__GCGETPOINT> >::operator[]
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ??A?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@QAEAAU__GCGETPOINT@CGuildCombat@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@QAEAAU__GCGETPOINT@CGuildCombat@@I@Z PROC NEAR ; std::vector<CGuildCombat::__GCGETPOINT,std::allocator<CGuildCombat::__GCGETPOINT> >::operator[], COMDAT
; _this$ = ecx

; 555  : 		return (*(begin() + _Pos));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pos$[esp-4]
  00004	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00007	8d 04 c0	 lea	 eax, DWORD PTR [eax+eax*8]
  0000a	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]

; 556  : 		}

  0000d	c2 04 00	 ret	 4
??A?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@QAEAAU__GCGETPOINT@CGuildCombat@@I@Z ENDP ; std::vector<CGuildCombat::__GCGETPOINT,std::allocator<CGuildCombat::__GCGETPOINT> >::operator[]
_TEXT	ENDS
PUBLIC	??A?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@QAEAAU__GCPLAYERPOINT@CGuildCombat@@I@Z ; std::vector<CGuildCombat::__GCPLAYERPOINT,std::allocator<CGuildCombat::__GCPLAYERPOINT> >::operator[]
; Function compile flags: /Ogty
;	COMDAT ??A?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@QAEAAU__GCPLAYERPOINT@CGuildCombat@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@QAEAAU__GCPLAYERPOINT@CGuildCombat@@I@Z PROC NEAR ; std::vector<CGuildCombat::__GCPLAYERPOINT,std::allocator<CGuildCombat::__GCPLAYERPOINT> >::operator[], COMDAT
; _this$ = ecx

; 555  : 		return (*(begin() + _Pos));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pos$[esp-4]
  00004	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00007	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  0000a	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]

; 556  : 		}

  0000d	c2 04 00	 ret	 4
??A?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@QAEAAU__GCPLAYERPOINT@CGuildCombat@@I@Z ENDP ; std::vector<CGuildCombat::__GCPLAYERPOINT,std::allocator<CGuildCombat::__GCPLAYERPOINT> >::operator[]
_TEXT	ENDS
PUBLIC	??A?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QAEAAPAU__GuildCombatMember@CGuildCombat@@I@Z ; std::vector<CGuildCombat::__GuildCombatMember *,std::allocator<CGuildCombat::__GuildCombatMember *> >::operator[]
; Function compile flags: /Ogty
;	COMDAT ??A?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QAEAAPAU__GuildCombatMember@CGuildCombat@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QAEAAPAU__GuildCombatMember@CGuildCombat@@I@Z PROC NEAR ; std::vector<CGuildCombat::__GuildCombatMember *,std::allocator<CGuildCombat::__GuildCombatMember *> >::operator[], COMDAT
; _this$ = ecx

; 555  : 		return (*(begin() + _Pos));

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	8b 4c 24 04	 mov	 ecx, DWORD PTR __Pos$[esp-4]
  00007	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]

; 556  : 		}

  0000a	c2 04 00	 ret	 4
??A?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QAEAAPAU__GuildCombatMember@CGuildCombat@@I@Z ENDP ; std::vector<CGuildCombat::__GuildCombatMember *,std::allocator<CGuildCombat::__GuildCombatMember *> >::operator[]
_TEXT	ENDS
PUBLIC	??A?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QAEAAU__REQUESTGUILD@CGuildCombat@@I@Z ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::operator[]
; Function compile flags: /Ogty
;	COMDAT ??A?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QAEAAU__REQUESTGUILD@CGuildCombat@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QAEAAU__REQUESTGUILD@CGuildCombat@@I@Z PROC NEAR ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::operator[], COMDAT
; _this$ = ecx

; 555  : 		return (*(begin() + _Pos));

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	8b 4c 24 04	 mov	 ecx, DWORD PTR __Pos$[esp-4]
  00007	8d 04 c8	 lea	 eax, DWORD PTR [eax+ecx*8]

; 556  : 		}

  0000a	c2 04 00	 ret	 4
??A?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QAEAAU__REQUESTGUILD@CGuildCombat@@I@Z ENDP ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::operator[]
_TEXT	ENDS
PUBLIC	??A?$vector@U__SECRETROOM_TENDER@@V?$allocator@U__SECRETROOM_TENDER@@@std@@@std@@QAEAAU__SECRETROOM_TENDER@@I@Z ; std::vector<__SECRETROOM_TENDER,std::allocator<__SECRETROOM_TENDER> >::operator[]
; Function compile flags: /Ogty
;	COMDAT ??A?$vector@U__SECRETROOM_TENDER@@V?$allocator@U__SECRETROOM_TENDER@@@std@@@std@@QAEAAU__SECRETROOM_TENDER@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@U__SECRETROOM_TENDER@@V?$allocator@U__SECRETROOM_TENDER@@@std@@@std@@QAEAAU__SECRETROOM_TENDER@@I@Z PROC NEAR ; std::vector<__SECRETROOM_TENDER,std::allocator<__SECRETROOM_TENDER> >::operator[], COMDAT
; _this$ = ecx

; 555  : 		return (*(begin() + _Pos));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pos$[esp-4]
  00004	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00007	6b c0 34	 imul	 eax, 52			; 00000034H
  0000a	03 c2		 add	 eax, edx

; 556  : 		}

  0000c	c2 04 00	 ret	 4
??A?$vector@U__SECRETROOM_TENDER@@V?$allocator@U__SECRETROOM_TENDER@@@std@@@std@@QAEAAU__SECRETROOM_TENDER@@I@Z ENDP ; std::vector<__SECRETROOM_TENDER,std::allocator<__SECRETROOM_TENDER> >::operator[]
_TEXT	ENDS
PUBLIC	??A?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@I@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator[]
; Function compile flags: /Ogty
;	COMDAT ??A?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@I@Z PROC NEAR ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator[], COMDAT
; _this$ = ecx

; 555  : 		return (*(begin() + _Pos));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pos$[esp-4]
  00004	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00007	6b c0 1c	 imul	 eax, 28			; 0000001cH
  0000a	03 c2		 add	 eax, edx

; 556  : 		}

  0000c	c2 04 00	 ret	 4
??A?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@I@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator[]
_TEXT	ENDS
PUBLIC	??Citerator@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@QBEPAU?$pair@$$CBKPAVCGuildMember@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,CGuildMember *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuildMember *> >,0> >::iterator::operator->
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ??Citerator@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@QBEPAU?$pair@$$CBKPAVCGuildMember@@@2@XZ
_TEXT	SEGMENT
??Citerator@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@QBEPAU?$pair@$$CBKPAVCGuildMember@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CGuildMember *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuildMember *> >,0> >::iterator::operator->, COMDAT
; _this$ = ecx

; 322  : 			return (&**this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 0c	 add	 eax, 12			; 0000000cH

; 323  : 			}

  00005	c3		 ret	 0
??Citerator@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@QBEPAU?$pair@$$CBKPAVCGuildMember@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CGuildMember *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuildMember *> >,0> >::iterator::operator->
_TEXT	ENDS
PUBLIC	??Eiterator@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,CGuildMember *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuildMember *> >,0> >::iterator::operator++
; Function compile flags: /Ogty
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??Eiterator@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CGuildMember *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuildMember *> >,0> >::iterator::operator++, COMDAT
; _this$ = ecx

; 326  : 			{	// preincrement

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 327  : 			++(*(const_iterator *)this);

  00003	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned long,CGuildMember *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuildMember *> >,0> >::const_iterator::_Inc

; 328  : 			return (*this);

  00008	8b c6		 mov	 eax, esi
  0000a	5e		 pop	 esi

; 329  : 			}

  0000b	c3		 ret	 0
??Eiterator@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CGuildMember *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuildMember *> >,0> >::iterator::operator++
_TEXT	ENDS
PUBLIC	??Citerator@?$_Tree@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@std@@QBEPAU?$pair@$$CBKPAVCParty@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,CParty *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CParty *> >,0> >::iterator::operator->
; Function compile flags: /Ogty
;	COMDAT ??Citerator@?$_Tree@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@std@@QBEPAU?$pair@$$CBKPAVCParty@@@2@XZ
_TEXT	SEGMENT
??Citerator@?$_Tree@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@std@@QBEPAU?$pair@$$CBKPAVCParty@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CParty *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CParty *> >,0> >::iterator::operator->, COMDAT
; _this$ = ecx

; 322  : 			return (&**this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 0c	 add	 eax, 12			; 0000000cH

; 323  : 			}

  00005	c3		 ret	 0
??Citerator@?$_Tree@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@std@@QBEPAU?$pair@$$CBKPAVCParty@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CParty *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CParty *> >,0> >::iterator::operator->
_TEXT	ENDS
PUBLIC	??Eiterator@?$_Tree@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,CParty *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CParty *> >,0> >::iterator::operator++
; Function compile flags: /Ogty
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??Eiterator@?$_Tree@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CParty *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CParty *> >,0> >::iterator::operator++, COMDAT
; _this$ = ecx

; 326  : 			{	// preincrement

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 327  : 			++(*(const_iterator *)this);

  00003	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned long,CParty *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CParty *> >,0> >::const_iterator::_Inc

; 328  : 			return (*this);

  00008	8b c6		 mov	 eax, esi
  0000a	5e		 pop	 esi

; 329  : 			}

  0000b	c3		 ret	 0
??Eiterator@?$_Tree@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CParty *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CParty *> >,0> >::iterator::operator++
_TEXT	ENDS
PUBLIC	??A?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@QAEAAU__JOINPLAYER@CGuildCombat@@I@Z ; std::vector<CGuildCombat::__JOINPLAYER,std::allocator<CGuildCombat::__JOINPLAYER> >::operator[]
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ??A?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@QAEAAU__JOINPLAYER@CGuildCombat@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@QAEAAU__JOINPLAYER@CGuildCombat@@I@Z PROC NEAR ; std::vector<CGuildCombat::__JOINPLAYER,std::allocator<CGuildCombat::__JOINPLAYER> >::operator[], COMDAT
; _this$ = ecx

; 555  : 		return (*(begin() + _Pos));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pos$[esp-4]
  00004	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00007	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  0000a	8d 04 c1	 lea	 eax, DWORD PTR [ecx+eax*8]

; 556  : 		}

  0000d	c2 04 00	 ret	 4
??A?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@QAEAAU__JOINPLAYER@CGuildCombat@@I@Z ENDP ; std::vector<CGuildCombat::__JOINPLAYER,std::allocator<CGuildCombat::__JOINPLAYER> >::operator[]
_TEXT	ENDS
PUBLIC	??1?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@QAE@XZ ; std::list<CUser *,std::allocator<CUser *> >::~list<CUser *,std::allocator<CUser *> >
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\list
;	COMDAT ??1?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@QAE@XZ PROC NEAR ; std::list<CUser *,std::allocator<CUser *> >::~list<CUser *,std::allocator<CUser *> >, COMDAT
; _this$ = ecx

; 364  : 		{	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 365  : 		_Tidy();

  00003	e8 00 00 00 00	 call	 ?clear@?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@QAEXXZ ; std::list<CUser *,std::allocator<CUser *> >::clear
  00008	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00011	83 c4 04	 add	 esp, 4
  00014	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  0001b	5e		 pop	 esi

; 366  : 		}

  0001c	c3		 ret	 0
??1?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@QAE@XZ ENDP ; std::list<CUser *,std::allocator<CUser *> >::~list<CUser *,std::allocator<CUser *> >
_TEXT	ENDS
PUBLIC	??A?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@QAEAAU__ITEMINFO@@I@Z ; std::vector<__ITEMINFO,std::allocator<__ITEMINFO> >::operator[]
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ??A?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@QAEAAU__ITEMINFO@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@QAEAAU__ITEMINFO@@I@Z PROC NEAR ; std::vector<__ITEMINFO,std::allocator<__ITEMINFO> >::operator[], COMDAT
; _this$ = ecx

; 555  : 		return (*(begin() + _Pos));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pos$[esp-4]
  00004	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00007	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  0000a	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]

; 556  : 		}

  0000d	c2 04 00	 ret	 4
??A?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@QAEAAU__ITEMINFO@@I@Z ENDP ; std::vector<__ITEMINFO,std::allocator<__ITEMINFO> >::operator[]
_TEXT	ENDS
PUBLIC	?clear@?$vector@KV?$allocator@K@std@@@std@@QAEXXZ ; std::vector<unsigned long,std::allocator<unsigned long> >::clear
; Function compile flags: /Ogty
;	COMDAT ?clear@?$vector@KV?$allocator@K@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@KV?$allocator@K@std@@@std@@QAEXXZ PROC NEAR ; std::vector<unsigned long,std::allocator<unsigned long> >::clear, COMDAT
; _this$ = ecx

; 743  : 		{	// erase all

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 744  : 		_Tidy();

  00003	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00006	85 c0		 test	 eax, eax
  00008	74 09		 je	 SHORT $L338004
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00010	83 c4 04	 add	 esp, 4
$L338004:
  00013	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  0001a	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00021	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
  00028	5e		 pop	 esi

; 745  : 		}

  00029	c3		 ret	 0
?clear@?$vector@KV?$allocator@K@std@@@std@@QAEXXZ ENDP	; std::vector<unsigned long,std::allocator<unsigned long> >::clear
_TEXT	ENDS
PUBLIC	?_Ufill@?$vector@KV?$allocator@K@std@@@std@@IAEPAKPAKIABK@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::_Ufill
; Function compile flags: /Ogty
;	COMDAT ?_Ufill@?$vector@KV?$allocator@K@std@@@std@@IAEPAKPAKIABK@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Ufill@?$vector@KV?$allocator@K@std@@@std@@IAEPAKPAKIABK@Z PROC NEAR ; std::vector<unsigned long,std::allocator<unsigned long> >::_Ufill, COMDAT
; _this$ = ecx

; 877  : 		{	// copy initializing _Count * _Val, using allocator

  00000	56		 push	 esi

; 878  : 		_Uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

  00001	8b 74 24 0c	 mov	 esi, DWORD PTR __Count$[esp]
  00005	85 f6		 test	 esi, esi
  00007	57		 push	 edi
  00008	8b 7c 24 0c	 mov	 edi, DWORD PTR __Ptr$[esp+4]
  0000c	8b c7		 mov	 eax, edi
  0000e	76 12		 jbe	 SHORT $L338047
  00010	8b 54 24 14	 mov	 edx, DWORD PTR __Val$[esp+4]
  00014	8b ce		 mov	 ecx, esi
  00016	53		 push	 ebx
$L338040:
  00017	8b 1a		 mov	 ebx, DWORD PTR [edx]
  00019	89 18		 mov	 DWORD PTR [eax], ebx
  0001b	83 c0 04	 add	 eax, 4
  0001e	49		 dec	 ecx
  0001f	75 f6		 jne	 SHORT $L338040
  00021	5b		 pop	 ebx
$L338047:

; 879  : 		return (_Ptr + _Count);

  00022	8d 04 b7	 lea	 eax, DWORD PTR [edi+esi*4]
  00025	5f		 pop	 edi
  00026	5e		 pop	 esi

; 880  : 		}

  00027	c2 0c 00	 ret	 12			; 0000000cH
?_Ufill@?$vector@KV?$allocator@K@std@@@std@@IAEPAKPAKIABK@Z ENDP ; std::vector<unsigned long,std::allocator<unsigned long> >::_Ufill
_TEXT	ENDS
PUBLIC	?_Init@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Init
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ?_Init@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Init@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXXZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Init, COMDAT
; _this$ = ecx

; 901  : 		{	// create head/nil node and make tree empty

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 902  : 		_Myhead = _Buynode();

  00003	e8 00 00 00 00	 call	 ?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Buynode
  00008	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 903  : 		_Isnil(_Myhead) = true;

  0000b	c6 40 15 01	 mov	 BYTE PTR [eax+21], 1

; 904  : 		_Root() = _Myhead;

  0000f	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00012	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 905  : 		_Lmost() = _Myhead, _Rmost() = _Myhead;

  00015	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00018	89 00		 mov	 DWORD PTR [eax], eax
  0001a	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0001d	89 40 08	 mov	 DWORD PTR [eax+8], eax

; 906  : 		_Mysize = 0;

  00020	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00027	5e		 pop	 esi

; 907  : 		}

  00028	c3		 ret	 0
?_Init@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Init
_TEXT	ENDS
PUBLIC	??0?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >
; Function compile flags: /Ogty
;	COMDAT ??0?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 1
??0?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z PROC NEAR ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >, COMDAT
; _this$ = ecx

; 95   : 		{	// construct base, and allocator from _Al

  00000	8b c1		 mov	 eax, ecx

; 96   : 		}

  00002	c2 08 00	 ret	 8
??0?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >
_TEXT	ENDS
PUBLIC	??0?$_List_val@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAE@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@1@@Z ; std::_List_val<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_List_val<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\list
;	COMDAT ??0?$_List_val@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAE@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_List_val@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAE@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@1@@Z PROC NEAR ; std::_List_val<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_List_val<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >, COMDAT
; _this$ = ecx

; 82   : 		{	// construct base, and allocator from _Al

  00000	8b c1		 mov	 eax, ecx

; 83   : 		}

  00002	c2 04 00	 ret	 4
??0?$_List_val@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAE@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@1@@Z ENDP ; std::_List_val<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_List_val<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >
_TEXT	ENDS
PUBLIC	??0?$_List_val@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@IAE@V?$allocator@PAVCUser@@@1@@Z ; std::_List_val<CUser *,std::allocator<CUser *> >::_List_val<CUser *,std::allocator<CUser *> >
; Function compile flags: /Ogty
;	COMDAT ??0?$_List_val@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@IAE@V?$allocator@PAVCUser@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_List_val@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@IAE@V?$allocator@PAVCUser@@@1@@Z PROC NEAR ; std::_List_val<CUser *,std::allocator<CUser *> >::_List_val<CUser *,std::allocator<CUser *> >, COMDAT
; _this$ = ecx

; 82   : 		{	// construct base, and allocator from _Al

  00000	8b c1		 mov	 eax, ecx

; 83   : 		}

  00002	c2 04 00	 ret	 4
??0?$_List_val@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@IAE@V?$allocator@PAVCUser@@@1@@Z ENDP ; std::_List_val<CUser *,std::allocator<CUser *> >::_List_val<CUser *,std::allocator<CUser *> >
_TEXT	ENDS
PUBLIC	?_Init@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Init
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ?_Init@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Init@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@IAEXXZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Init, COMDAT
; _this$ = ecx

; 901  : 		{	// create head/nil node and make tree empty

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 902  : 		_Myhead = _Buynode();

  00003	e8 00 00 00 00	 call	 ?_Buynode@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Buynode
  00008	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 903  : 		_Isnil(_Myhead) = true;

  0000b	c6 40 15 01	 mov	 BYTE PTR [eax+21], 1

; 904  : 		_Root() = _Myhead;

  0000f	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00012	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 905  : 		_Lmost() = _Myhead, _Rmost() = _Myhead;

  00015	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00018	89 00		 mov	 DWORD PTR [eax], eax
  0001a	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0001d	89 40 08	 mov	 DWORD PTR [eax+8], eax

; 906  : 		_Mysize = 0;

  00020	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00027	5e		 pop	 esi

; 907  : 		}

  00028	c3		 ret	 0
?_Init@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Init
_TEXT	ENDS
PUBLIC	??0?$_Tree_val@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@K@1@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Tree_val<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >
; Function compile flags: /Ogty
;	COMDAT ??0?$_Tree_val@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@K@1@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 1
??0?$_Tree_val@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@K@1@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@1@@Z PROC NEAR ; std::_Tree_val<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Tree_val<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >, COMDAT
; _this$ = ecx

; 95   : 		{	// construct base, and allocator from _Al

  00000	8b c1		 mov	 eax, ecx

; 96   : 		}

  00002	c2 08 00	 ret	 8
??0?$_Tree_val@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@K@1@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@1@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Tree_val<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >
_TEXT	ENDS
PUBLIC	?_Init@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::_Init
; Function compile flags: /Ogty
;	COMDAT ?_Init@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Init@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@IAEXXZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::_Init, COMDAT
; _this$ = ecx

; 901  : 		{	// create head/nil node and make tree empty

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 902  : 		_Myhead = _Buynode();

  00003	e8 00 00 00 00	 call	 ?_Buynode@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::_Buynode
  00008	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 903  : 		_Isnil(_Myhead) = true;

  0000b	c6 40 15 01	 mov	 BYTE PTR [eax+21], 1

; 904  : 		_Root() = _Myhead;

  0000f	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00012	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 905  : 		_Lmost() = _Myhead, _Rmost() = _Myhead;

  00015	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00018	89 00		 mov	 DWORD PTR [eax], eax
  0001a	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0001d	89 40 08	 mov	 DWORD PTR [eax+8], eax

; 906  : 		_Mysize = 0;

  00020	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00027	5e		 pop	 esi

; 907  : 		}

  00028	c3		 ret	 0
?_Init@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::_Init
_TEXT	ENDS
PUBLIC	??0?$_Tree_val@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@K@1@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::_Tree_val<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >
; Function compile flags: /Ogty
;	COMDAT ??0?$_Tree_val@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@K@1@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 1
??0?$_Tree_val@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@K@1@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@1@@Z PROC NEAR ; std::_Tree_val<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::_Tree_val<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >, COMDAT
; _this$ = ecx

; 95   : 		{	// construct base, and allocator from _Al

  00000	8b c1		 mov	 eax, ecx

; 96   : 		}

  00002	c2 08 00	 ret	 8
??0?$_Tree_val@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@K@1@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@1@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::_Tree_val<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >
_TEXT	ENDS
PUBLIC	?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@0@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Copy
;	COMDAT xdata$x
xdata$x	SEGMENT
$T338400 DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
$T338402 DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L338371
$T338401 DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:$T338402
$T338397 DD	019930520H
	DD	02H
	DD	FLAT:$T338400
	DD	01H
	DD	FLAT:$T338401
	DD	2 DUP(00H)
; Function compile flags: /Ogty
xdata$x	ENDS
;	COMDAT ?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@0@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
__Newroot$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Rootnode$ = 8						; size = 4
__Wherenode$ = 12					; size = 4
?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@0@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Copy, COMDAT
; _this$ = ecx

; 867  : 		{	// copy entire subtree, recursively

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@0@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 0c	 sub	 esp, 12			; 0000000cH
  0001b	53		 push	 ebx

; 868  : 		_Nodeptr _Newroot = _Myhead;	// point at nil node
; 869  : 
; 870  : 		if (!_Isnil(_Rootnode))

  0001c	8b 5d 08	 mov	 ebx, DWORD PTR __Rootnode$[ebp]
  0001f	56		 push	 esi
  00020	8b f1		 mov	 esi, ecx
  00022	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00025	89 45 ec	 mov	 DWORD PTR __Newroot$[ebp], eax
  00028	8a 43 15	 mov	 al, BYTE PTR [ebx+21]
  0002b	84 c0		 test	 al, al
  0002d	57		 push	 edi
  0002e	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00031	89 75 e8	 mov	 DWORD PTR _this$[ebp], esi
  00034	75 4c		 jne	 SHORT $L289541

; 871  : 			{	// copy a node, then any subtrees
; 872  : 			_Nodeptr _Pnode = _Buynode(_Myhead, _Wherenode, _Myhead,
; 873  : 				_Myval(_Rootnode), _Color(_Rootnode));

  00036	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00039	33 c9		 xor	 ecx, ecx
  0003b	8a 4b 14	 mov	 cl, BYTE PTR [ebx+20]
  0003e	8d 53 0c	 lea	 edx, DWORD PTR [ebx+12]
  00041	51		 push	 ecx
  00042	8b 4d 0c	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  00045	52		 push	 edx
  00046	50		 push	 eax
  00047	51		 push	 ecx
  00048	50		 push	 eax
  00049	8b ce		 mov	 ecx, esi
  0004b	e8 00 00 00 00	 call	 ?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHH@2@D@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Buynode

; 874  : 			if (_Isnil(_Newroot))

  00050	8b 55 ec	 mov	 edx, DWORD PTR __Newroot$[ebp]
  00053	8b f8		 mov	 edi, eax
  00055	8a 42 15	 mov	 al, BYTE PTR [edx+21]
  00058	84 c0		 test	 al, al
  0005a	74 03		 je	 SHORT $L289540

; 875  : 				_Newroot = _Pnode;	// memorize new root

  0005c	89 7d ec	 mov	 DWORD PTR __Newroot$[ebp], edi
$L289540:

; 876  : 
; 877  : 			_TRY_BEGIN
; 878  : 			_Left(_Pnode) = _Copy(_Left(_Rootnode), _Pnode);

  0005f	8b 03		 mov	 eax, DWORD PTR [ebx]
  00061	57		 push	 edi
  00062	50		 push	 eax
  00063	8b ce		 mov	 ecx, esi
  00065	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  0006c	e8 00 00 00 00	 call	 ?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@0@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Copy
  00071	89 07		 mov	 DWORD PTR [edi], eax

; 879  : 			_Right(_Pnode) = _Copy(_Right(_Rootnode), _Pnode);

  00073	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  00076	57		 push	 edi
  00077	51		 push	 ecx
  00078	8b ce		 mov	 ecx, esi
  0007a	e8 00 00 00 00	 call	 ?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@0@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Copy
  0007f	89 47 08	 mov	 DWORD PTR [edi+8], eax
$L289541:

; 883  : 			_CATCH_END
; 884  : 			}
; 885  : 
; 886  : 		return (_Newroot);	// return newly constructed tree
; 887  : 		}

  00082	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00085	8b 45 ec	 mov	 eax, DWORD PTR __Newroot$[ebp]
  00088	5f		 pop	 edi
  00089	5e		 pop	 esi
  0008a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00091	5b		 pop	 ebx
  00092	8b e5		 mov	 esp, ebp
  00094	5d		 pop	 ebp
  00095	c2 08 00	 ret	 8
$L338371:

; 880  : 			_CATCH_ALL
; 881  : 			_Erase(_Newroot);	// subtree copy failed, bail out

  00098	8b 55 ec	 mov	 edx, DWORD PTR __Newroot$[ebp]
  0009b	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0009e	52		 push	 edx
  0009f	e8 00 00 00 00	 call	 ?_Erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Erase

; 882  : 			_RERAISE;

  000a4	6a 00		 push	 0
  000a6	6a 00		 push	 0
  000a8	e8 00 00 00 00	 call	 __CxxThrowException@8
$L338403:
$L338399:
  000ad	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@0@Z:
  00000	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T338397
  00005	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@0@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Copy
PUBLIC	??$_Distance2@Viterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@I@std@@YAXViterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@0@0AAIUbidirectional_iterator_tag@0@@Z ; std::_Distance2<std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::iterator,unsigned int>
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xutility
;	COMDAT ??$_Distance2@Viterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@I@std@@YAXViterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@0@0AAIUbidirectional_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Off$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Distance2@Viterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@I@std@@YAXViterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@0@0AAIUbidirectional_iterator_tag@0@@Z PROC NEAR ; std::_Distance2<std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::iterator,unsigned int>, COMDAT

; 470  : 	for (; _First != _Last; ++_First)

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __First$[esp-4]
  00004	57		 push	 edi
  00005	8b 7c 24 0c	 mov	 edi, DWORD PTR __Last$[esp]
  00009	3b c7		 cmp	 eax, edi
  0000b	74 17		 je	 SHORT $L291796
  0000d	56		 push	 esi
  0000e	8b 74 24 14	 mov	 esi, DWORD PTR __Off$[esp+4]
$L338412:

; 471  : 		++_Off;

  00012	ff 06		 inc	 DWORD PTR [esi]
  00014	8d 4c 24 0c	 lea	 ecx, DWORD PTR __First$[esp+4]
  00018	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::const_iterator::_Inc
  0001d	39 7c 24 0c	 cmp	 DWORD PTR __First$[esp+4], edi
  00021	75 ef		 jne	 SHORT $L338412
  00023	5e		 pop	 esi
$L291796:
  00024	5f		 pop	 edi

; 472  : 	}

  00025	c3		 ret	 0
??$_Distance2@Viterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@I@std@@YAXViterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@0@0AAIUbidirectional_iterator_tag@0@@Z ENDP ; std::_Distance2<std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::iterator,unsigned int>
_TEXT	ENDS
PUBLIC	??$_Uninitialized_fill_n@PAU__ITEMINFO@@IU1@V?$allocator@U__ITEMINFO@@@std@@@std@@YAXPAU__ITEMINFO@@IABU1@AAV?$allocator@U__ITEMINFO@@@0@@Z ; std::_Uninitialized_fill_n<__ITEMINFO *,unsigned int,__ITEMINFO,std::allocator<__ITEMINFO> >
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\memory
;	COMDAT ??$_Uninitialized_fill_n@PAU__ITEMINFO@@IU1@V?$allocator@U__ITEMINFO@@@std@@@std@@YAXPAU__ITEMINFO@@IABU1@AAV?$allocator@U__ITEMINFO@@@0@@Z
_TEXT	SEGMENT
__Cat$338431 = -4					; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_fill_n@PAU__ITEMINFO@@IU1@V?$allocator@U__ITEMINFO@@@std@@@std@@YAXPAU__ITEMINFO@@IABU1@AAV?$allocator@U__ITEMINFO@@@0@@Z PROC NEAR ; std::_Uninitialized_fill_n<__ITEMINFO *,unsigned int,__ITEMINFO,std::allocator<__ITEMINFO> >, COMDAT

; 255  : 	{	// copy _Count *_Val to raw _First, using _Al

  00000	51		 push	 ecx

; 256  : 	_Uninit_fill_n(_First, _Count, _Val, _Al,
; 257  : 		_Ptr_cat(_First, _First));

  00001	8b 04 24	 mov	 eax, DWORD PTR __Cat$338431[esp+4]
  00004	8b 4c 24 14	 mov	 ecx, DWORD PTR __Al$[esp]
  00008	8b 54 24 10	 mov	 edx, DWORD PTR __Val$[esp]
  0000c	50		 push	 eax
  0000d	8b 44 24 10	 mov	 eax, DWORD PTR __Count$[esp+4]
  00011	51		 push	 ecx
  00012	8b 4c 24 10	 mov	 ecx, DWORD PTR __First$[esp+8]
  00016	52		 push	 edx
  00017	50		 push	 eax
  00018	51		 push	 ecx
  00019	e8 00 00 00 00	 call	 ??$_Uninit_fill_n@PAU__ITEMINFO@@IU1@V?$allocator@U__ITEMINFO@@@std@@@std@@YAXPAU__ITEMINFO@@IABU1@AAV?$allocator@U__ITEMINFO@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<__ITEMINFO *,unsigned int,__ITEMINFO,std::allocator<__ITEMINFO> >

; 258  : 	}

  0001e	83 c4 18	 add	 esp, 24			; 00000018H
  00021	c3		 ret	 0
??$_Uninitialized_fill_n@PAU__ITEMINFO@@IU1@V?$allocator@U__ITEMINFO@@@std@@@std@@YAXPAU__ITEMINFO@@IABU1@AAV?$allocator@U__ITEMINFO@@@0@@Z ENDP ; std::_Uninitialized_fill_n<__ITEMINFO *,unsigned int,__ITEMINFO,std::allocator<__ITEMINFO> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@YAXPAU__REQUESTGUILD@CGuildCombat@@0AAV?$allocator@U__REQUESTGUILD@CGuildCombat@@@0@@Z ; std::_Destroy_range<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??$_Destroy_range@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@YAXPAU__REQUESTGUILD@CGuildCombat@@0AAV?$allocator@U__REQUESTGUILD@CGuildCombat@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@YAXPAU__REQUESTGUILD@CGuildCombat@@0AAV?$allocator@U__REQUESTGUILD@CGuildCombat@@@0@@Z PROC NEAR ; std::_Destroy_range<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >, COMDAT

; 217  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 218  : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@YAXPAU__REQUESTGUILD@CGuildCombat@@0AAV?$allocator@U__REQUESTGUILD@CGuildCombat@@@0@@Z ENDP ; std::_Destroy_range<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@YAXPAU__ITEMINFO@@0AAV?$allocator@U__ITEMINFO@@@0@@Z ; std::_Destroy_range<__ITEMINFO,std::allocator<__ITEMINFO> >
; Function compile flags: /Ogty
;	COMDAT ??$_Destroy_range@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@YAXPAU__ITEMINFO@@0AAV?$allocator@U__ITEMINFO@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@YAXPAU__ITEMINFO@@0AAV?$allocator@U__ITEMINFO@@@0@@Z PROC NEAR ; std::_Destroy_range<__ITEMINFO,std::allocator<__ITEMINFO> >, COMDAT

; 217  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 218  : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@YAXPAU__ITEMINFO@@0AAV?$allocator@U__ITEMINFO@@@0@@Z ENDP ; std::_Destroy_range<__ITEMINFO,std::allocator<__ITEMINFO> >
_TEXT	ENDS
PUBLIC	??$_Ucopy@PAU__ITEMINFO@@@?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@IAEPAU__ITEMINFO@@PAU2@00@Z ; std::vector<__ITEMINFO,std::allocator<__ITEMINFO> >::_Ucopy<__ITEMINFO *>
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ??$_Ucopy@PAU__ITEMINFO@@@?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@IAEPAU__ITEMINFO@@PAU2@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$338462 = 16					; size = 1
__Ptr$ = 16						; size = 4
??$_Ucopy@PAU__ITEMINFO@@@?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@IAEPAU__ITEMINFO@@PAU2@00@Z PROC NEAR ; std::vector<__ITEMINFO,std::allocator<__ITEMINFO> >::_Ucopy<__ITEMINFO *>, COMDAT
; _this$ = ecx

; 802  : 		{	// copy initializing [_First, _Last), using allocator
; 803  : 		return (_Uninitialized_copy(_First, _Last,
; 804  : 			_Ptr, this->_Alval));

  00000	8b 44 24 0c	 mov	 eax, DWORD PTR __Cat$338462[esp-4]
  00004	8b 54 24 08	 mov	 edx, DWORD PTR __Last$[esp-4]
  00008	50		 push	 eax
  00009	8b 44 24 08	 mov	 eax, DWORD PTR __First$[esp]
  0000d	51		 push	 ecx
  0000e	8b 4c 24 14	 mov	 ecx, DWORD PTR __Ptr$[esp+4]
  00012	51		 push	 ecx
  00013	52		 push	 edx
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 ??$_Uninit_copy@PAU__ITEMINFO@@PAU1@V?$allocator@U__ITEMINFO@@@std@@@std@@YAPAU__ITEMINFO@@PAU1@00AAV?$allocator@U__ITEMINFO@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<__ITEMINFO *,__ITEMINFO *,std::allocator<__ITEMINFO> >
  0001a	83 c4 14	 add	 esp, 20			; 00000014H

; 805  : 		}

  0001d	c2 0c 00	 ret	 12			; 0000000cH
??$_Ucopy@PAU__ITEMINFO@@@?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@IAEPAU__ITEMINFO@@PAU2@00@Z ENDP ; std::vector<__ITEMINFO,std::allocator<__ITEMINFO> >::_Ucopy<__ITEMINFO *>
_TEXT	ENDS
PUBLIC	?GetBuffer@?$CSimpleStringT@D$0A@@ATL@@QAEPADH@Z ; ATL::CSimpleStringT<char,0>::GetBuffer
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlsimpstr.h
;	COMDAT ?GetBuffer@?$CSimpleStringT@D$0A@@ATL@@QAEPADH@Z
_TEXT	SEGMENT
_nMinBufferLength$ = 8					; size = 4
?GetBuffer@?$CSimpleStringT@D$0A@@ATL@@QAEPADH@Z PROC NEAR ; ATL::CSimpleStringT<char,0>::GetBuffer, COMDAT
; _this$ = ecx

; 489  : 	{

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 490  : 		return( PrepareWrite( nMinBufferLength ) );

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00008	83 e8 10	 sub	 eax, 16			; 00000010H
  0000b	b9 01 00 00 00	 mov	 ecx, 1
  00010	2b ca		 sub	 ecx, edx
  00012	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00015	8b 44 24 08	 mov	 eax, DWORD PTR _nMinBufferLength$[esp]
  00019	2b d0		 sub	 edx, eax
  0001b	0b ca		 or	 ecx, edx
  0001d	7d 08		 jge	 SHORT $L338482
  0001f	50		 push	 eax
  00020	8b ce		 mov	 ecx, esi
  00022	e8 00 00 00 00	 call	 ?PrepareWrite2@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z ; ATL::CSimpleStringT<char,0>::PrepareWrite2
$L338482:
  00027	8b 06		 mov	 eax, DWORD PTR [esi]
  00029	5e		 pop	 esi

; 491  : 	}

  0002a	c2 04 00	 ret	 4
?GetBuffer@?$CSimpleStringT@D$0A@@ATL@@QAEPADH@Z ENDP	; ATL::CSimpleStringT<char,0>::GetBuffer
_TEXT	ENDS
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 456  : 		{	// destroy the string

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 457  : 		_Tidy(true);

  00003	83 7e 18 10	 cmp	 DWORD PTR [esi+24], 16	; 00000010H
  00007	72 0c		 jb	 SHORT $L338519
  00009	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00012	83 c4 04	 add	 esp, 4
$L338519:
  00015	33 c0		 xor	 eax, eax
  00017	c7 46 18 0f 00
	00 00		 mov	 DWORD PTR [esi+24], 15	; 0000000fH
  0001e	89 46 14	 mov	 DWORD PTR [esi+20], eax
  00021	88 46 04	 mov	 BYTE PTR [esi+4], al
  00024	5e		 pop	 esi

; 458  : 		}

  00025	c3		 ret	 0
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
PUBLIC	??1?$vector@KV?$allocator@K@std@@@std@@QAE@XZ	; std::vector<unsigned long,std::allocator<unsigned long> >::~vector<unsigned long,std::allocator<unsigned long> >
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ??1?$vector@KV?$allocator@K@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@KV?$allocator@K@std@@@std@@QAE@XZ PROC NEAR	; std::vector<unsigned long,std::allocator<unsigned long> >::~vector<unsigned long,std::allocator<unsigned long> >, COMDAT
; _this$ = ecx

; 387  : 		{	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 388  : 		_Tidy();

  00003	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00006	85 c0		 test	 eax, eax
  00008	74 09		 je	 SHORT $L338548
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00010	83 c4 04	 add	 esp, 4
$L338548:
  00013	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  0001a	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00021	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
  00028	5e		 pop	 esi

; 389  : 		}

  00029	c3		 ret	 0
??1?$vector@KV?$allocator@K@std@@@std@@QAE@XZ ENDP	; std::vector<unsigned long,std::allocator<unsigned long> >::~vector<unsigned long,std::allocator<unsigned long> >
_TEXT	ENDS
PUBLIC	??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ	; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
; Function compile flags: /Ogty
;	COMDAT ??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ PROC NEAR	; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >, COMDAT
; _this$ = ecx

; 387  : 		{	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 388  : 		_Tidy();

  00003	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00006	85 c0		 test	 eax, eax
  00008	74 09		 je	 SHORT $L338563
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00010	83 c4 04	 add	 esp, 4
$L338563:
  00013	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  0001a	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00021	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
  00028	5e		 pop	 esi

; 389  : 		}

  00029	c3		 ret	 0
??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ ENDP	; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
_TEXT	ENDS
PUBLIC	?LoadStringA@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEHPAUHINSTANCE__@@I@Z ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::LoadStringA
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\cstringt.h
;	COMDAT ?LoadStringA@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEHPAUHINSTANCE__@@I@Z
_TEXT	SEGMENT
_hInstance$ = 8						; size = 4
_nID$ = 12						; size = 4
?LoadStringA@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEHPAUHINSTANCE__@@I@Z PROC NEAR ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::LoadStringA, COMDAT
; _this$ = ecx

; 1981 : 	{

  00000	53		 push	 ebx
  00001	56		 push	 esi

; 1982 : 		const ATLSTRINGRESOURCEIMAGE* pImage = AtlGetStringResourceImage( hInstance, nID );

  00002	8b 74 24 10	 mov	 esi, DWORD PTR _nID$[esp+4]
  00006	8b c6		 mov	 eax, esi
  00008	c1 e8 04	 shr	 eax, 4
  0000b	57		 push	 edi
  0000c	8b 7c 24 10	 mov	 edi, DWORD PTR _hInstance$[esp+8]
  00010	40		 inc	 eax
  00011	8b d9		 mov	 ebx, ecx
  00013	0f b7 c8	 movzx	 ecx, ax
  00016	6a 06		 push	 6
  00018	51		 push	 ecx
  00019	57		 push	 edi
  0001a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FindResourceA@12
  00020	85 c0		 test	 eax, eax
  00022	74 11		 je	 SHORT $L338643
  00024	56		 push	 esi
  00025	50		 push	 eax
  00026	57		 push	 edi
  00027	e8 00 00 00 00	 call	 ?_AtlGetStringResourceImage@ATL@@YAPBUATLSTRINGRESOURCEIMAGE@1@PAUHINSTANCE__@@PAUHRSRC__@@I@Z ; ATL::_AtlGetStringResourceImage
  0002c	8b f8		 mov	 edi, eax
  0002e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1983 : 		if( pImage == NULL )

  00031	85 ff		 test	 edi, edi
  00033	75 08		 jne	 SHORT $L219928
$L338643:
  00035	5f		 pop	 edi
  00036	5e		 pop	 esi

; 1984 : 		{
; 1985 : 			return( FALSE );

  00037	33 c0		 xor	 eax, eax
  00039	5b		 pop	 ebx

; 1994 : 	}

  0003a	c2 08 00	 ret	 8
$L219928:

; 1986 : 		}
; 1987 : 
; 1988 : 		int nLength = StringTraits::GetBaseTypeLength( pImage->achString, pImage->nLength );

  0003d	0f b7 37	 movzx	 esi, WORD PTR [edi]
  00040	55		 push	 ebp
  00041	ff 15 00 00 00
	00		 call	 DWORD PTR ?g_pfnGetThreadACP@ATL@@3P6GIXZA ; ATL::g_pfnGetThreadACP
  00047	6a 00		 push	 0
  00049	6a 00		 push	 0
  0004b	6a 00		 push	 0
  0004d	6a 00		 push	 0
  0004f	56		 push	 esi
  00050	8d 6f 02	 lea	 ebp, DWORD PTR [edi+2]
  00053	55		 push	 ebp
  00054	6a 00		 push	 0
  00056	50		 push	 eax
  00057	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WideCharToMultiByte@32
  0005d	8b f0		 mov	 esi, eax

; 1989 : 		PXSTR pszBuffer = GetBuffer( nLength );

  0005f	8b 03		 mov	 eax, DWORD PTR [ebx]
  00061	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  00064	83 e8 10	 sub	 eax, 16			; 00000010H
  00067	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0006a	ba 01 00 00 00	 mov	 edx, 1
  0006f	2b d1		 sub	 edx, ecx
  00071	2b c6		 sub	 eax, esi
  00073	0b d0		 or	 edx, eax
  00075	7d 08		 jge	 SHORT $L338605
  00077	56		 push	 esi
  00078	8b cb		 mov	 ecx, ebx
  0007a	e8 00 00 00 00	 call	 ?PrepareWrite2@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z ; ATL::CSimpleStringT<char,0>::PrepareWrite2
$L338605:
  0007f	8b 03		 mov	 eax, DWORD PTR [ebx]

; 1990 : 		StringTraits::ConvertToBaseType( pszBuffer, nLength, pImage->achString, pImage->nLength );

  00081	0f b7 0f	 movzx	 ecx, WORD PTR [edi]
  00084	6a 00		 push	 0
  00086	6a 00		 push	 0
  00088	56		 push	 esi
  00089	50		 push	 eax
  0008a	51		 push	 ecx
  0008b	55		 push	 ebp
  0008c	6a 00		 push	 0
  0008e	ff 15 00 00 00
	00		 call	 DWORD PTR ?g_pfnGetThreadACP@ATL@@3P6GIXZA ; ATL::g_pfnGetThreadACP
  00094	50		 push	 eax
  00095	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WideCharToMultiByte@32

; 1991 : 		ReleaseBufferSetLength( nLength );

  0009b	85 f6		 test	 esi, esi
  0009d	5d		 pop	 ebp
  0009e	7c 1b		 jl	 SHORT $L338640
  000a0	8b 03		 mov	 eax, DWORD PTR [ebx]
  000a2	3b 70 f8	 cmp	 esi, DWORD PTR [eax-8]
  000a5	7f 14		 jg	 SHORT $L338640
  000a7	89 70 f4	 mov	 DWORD PTR [eax-12], esi
  000aa	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  000ac	5f		 pop	 edi
  000ad	c6 04 0e 00	 mov	 BYTE PTR [esi+ecx], 0
  000b1	5e		 pop	 esi

; 1992 : 
; 1993 : 		return( TRUE );

  000b2	b8 01 00 00 00	 mov	 eax, 1
  000b7	5b		 pop	 ebx

; 1994 : 	}

  000b8	c2 08 00	 ret	 8
$L338640:
  000bb	68 57 00 07 80	 push	 -2147024809		; 80070057H
  000c0	e8 00 00 00 00	 call	 ?AtlThrow@ATL@@YGXJ@Z	; ATL::AtlThrow
$L338645:
$L338644:
  000c5	cc		 int	 3
?LoadStringA@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEHPAUHINSTANCE__@@I@Z ENDP ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::LoadStringA
_TEXT	ENDS
PUBLIC	?equal_range@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@V123@@2@ABK@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::equal_range
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ?equal_range@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@V123@@2@ABK@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
?equal_range@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@V123@@2@ABK@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::equal_range, COMDAT
; _this$ = ecx

; 830  : 		return (_Pairii(lower_bound(_Keyval), upper_bound(_Keyval)));

  00000	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00003	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00006	53		 push	 ebx
  00007	8a 58 15	 mov	 bl, BYTE PTR [eax+21]
  0000a	84 db		 test	 bl, bl
  0000c	56		 push	 esi
  0000d	57		 push	 edi
  0000e	8b 7c 24 14	 mov	 edi, DWORD PTR __Keyval$[esp+8]
  00012	75 17		 jne	 SHORT $L338726
  00014	8b 37		 mov	 esi, DWORD PTR [edi]
$L338725:
  00016	3b 70 0c	 cmp	 esi, DWORD PTR [eax+12]
  00019	73 06		 jae	 SHORT $L338727
  0001b	8b d0		 mov	 edx, eax
  0001d	8b 00		 mov	 eax, DWORD PTR [eax]
  0001f	eb 03		 jmp	 SHORT $L338728
$L338727:
  00021	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
$L338728:
  00024	8a 58 15	 mov	 bl, BYTE PTR [eax+21]
  00027	84 db		 test	 bl, bl
  00029	74 eb		 je	 SHORT $L338725
$L338726:
  0002b	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0002e	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00031	8a 58 15	 mov	 bl, BYTE PTR [eax+21]
  00034	84 db		 test	 bl, bl
  00036	75 1d		 jne	 SHORT $L338827
  00038	8b 37		 mov	 esi, DWORD PTR [edi]
  0003a	8d 9b 00 00 00
	00		 npad	 6
$L338826:
  00040	39 70 0c	 cmp	 DWORD PTR [eax+12], esi
  00043	73 05		 jae	 SHORT $L338828
  00045	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00048	eb 04		 jmp	 SHORT $L338829
$L338828:
  0004a	8b c8		 mov	 ecx, eax
  0004c	8b 00		 mov	 eax, DWORD PTR [eax]
$L338829:
  0004e	8a 58 15	 mov	 bl, BYTE PTR [eax+21]
  00051	84 db		 test	 bl, bl
  00053	74 eb		 je	 SHORT $L338826
$L338827:
  00055	8b 44 24 10	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp+8]
  00059	5f		 pop	 edi
  0005a	5e		 pop	 esi
  0005b	89 08		 mov	 DWORD PTR [eax], ecx
  0005d	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00060	5b		 pop	 ebx

; 831  : 		}

  00061	c2 08 00	 ret	 8
?equal_range@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@V123@@2@ABK@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::equal_range
_TEXT	ENDS
PUBLIC	?lower_bound@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::lower_bound
; Function compile flags: /Ogty
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
?lower_bound@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::lower_bound, COMDAT
; _this$ = ecx

; 810  : 		return (_TREE_ITERATOR(_Lbound(_Keyval)));

  00000	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00003	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00006	8a 50 15	 mov	 dl, BYTE PTR [eax+21]
  00009	84 d2		 test	 dl, dl
  0000b	75 1d		 jne	 SHORT $L338930
  0000d	8b 54 24 08	 mov	 edx, DWORD PTR __Keyval$[esp-4]
  00011	8b 12		 mov	 edx, DWORD PTR [edx]
  00013	53		 push	 ebx
$L338898:
  00014	39 50 0c	 cmp	 DWORD PTR [eax+12], edx
  00017	73 05		 jae	 SHORT $L338900
  00019	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0001c	eb 04		 jmp	 SHORT $L338901
$L338900:
  0001e	8b c8		 mov	 ecx, eax
  00020	8b 00		 mov	 eax, DWORD PTR [eax]
$L338901:
  00022	8a 58 15	 mov	 bl, BYTE PTR [eax+21]
  00025	84 db		 test	 bl, bl
  00027	74 eb		 je	 SHORT $L338898
  00029	5b		 pop	 ebx
$L338930:
  0002a	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  0002e	89 08		 mov	 DWORD PTR [eax], ecx

; 811  : 		}

  00030	c2 08 00	 ret	 8
?lower_bound@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::lower_bound
_TEXT	ENDS
PUBLIC	?SetString@?$CSimpleStringT@D$0A@@ATL@@QAEXPBDH@Z ; ATL::CSimpleStringT<char,0>::SetString
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlsimpstr.h
;	COMDAT ?SetString@?$CSimpleStringT@D$0A@@ATL@@QAEXPBDH@Z
_TEXT	SEGMENT
_pszSrc$ = 8						; size = 4
_nLength$ = 12						; size = 4
?SetString@?$CSimpleStringT@D$0A@@ATL@@QAEXPBDH@Z PROC NEAR ; ATL::CSimpleStringT<char,0>::SetString, COMDAT
; _this$ = ecx

; 583  : 	{

  00000	53		 push	 ebx

; 584  : 		if( nLength == 0 )

  00001	8b 5c 24 0c	 mov	 ebx, DWORD PTR _nLength$[esp]
  00005	85 db		 test	 ebx, ebx
  00007	55		 push	 ebp
  00008	8b e9		 mov	 ebp, ecx
  0000a	75 0a		 jne	 SHORT $L221330

; 585  : 		{
; 586  : 			Empty();

  0000c	e8 00 00 00 00	 call	 ?Empty@?$CSimpleStringT@D$0A@@ATL@@QAEXXZ ; ATL::CSimpleStringT<char,0>::Empty
  00011	5d		 pop	 ebp
  00012	5b		 pop	 ebx

; 614  : 		}
; 615  : 	}

  00013	c2 08 00	 ret	 8
$L221330:

; 587  : 		}
; 588  : 		else
; 589  : 		{
; 590  : 			// It is possible that pszSrc points to a location inside of our 
; 591  : 			// buffer.  GetBuffer() might change m_pszData if (1) the buffer 
; 592  : 			// is shared or (2) the buffer is too small to hold the new 
; 593  : 			// string.  We detect this aliasing, and modify pszSrc to point
; 594  : 			// into the newly allocated buffer instead.
; 595  : 			
; 596  : 			if(pszSrc == NULL)

  00016	8b 54 24 0c	 mov	 edx, DWORD PTR _pszSrc$[esp+4]
  0001a	85 d2		 test	 edx, edx
  0001c	75 0a		 jne	 SHORT $L221332

; 612  : 			}
; 613  : 			ReleaseBufferSetLength( nLength );

$L339002:
  0001e	68 57 00 07 80	 push	 -2147024809		; 80070057H
  00023	e8 00 00 00 00	 call	 ?AtlThrow@ATL@@YGXJ@Z	; ATL::AtlThrow
$L339006:
$L221332:

; 597  : 				AtlThrow(E_INVALIDARG);			
; 598  : 				
; 599  : 			UINT nOldLength = GetLength();

  00028	8b 45 00	 mov	 eax, DWORD PTR [ebp]
  0002b	56		 push	 esi

; 600  : 			UINT_PTR nOffset = pszSrc-GetString();

  0002c	8b f2		 mov	 esi, edx
  0002e	2b f0		 sub	 esi, eax

; 601  : 			// If 0 <= nOffset <= nOldLength, then pszSrc points into our 
; 602  : 			// buffer
; 603  : 
; 604  : 			PXSTR pszBuffer = GetBuffer( nLength );

  00030	b9 01 00 00 00	 mov	 ecx, 1
  00035	2b 48 fc	 sub	 ecx, DWORD PTR [eax-4]
  00038	57		 push	 edi
  00039	8b 78 f4	 mov	 edi, DWORD PTR [eax-12]
  0003c	8b 40 f8	 mov	 eax, DWORD PTR [eax-8]
  0003f	2b c3		 sub	 eax, ebx
  00041	0b c8		 or	 ecx, eax
  00043	7d 0c		 jge	 SHORT $L338969
  00045	53		 push	 ebx
  00046	8b cd		 mov	 ecx, ebp
  00048	e8 00 00 00 00	 call	 ?PrepareWrite2@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z ; ATL::CSimpleStringT<char,0>::PrepareWrite2
  0004d	8b 54 24 14	 mov	 edx, DWORD PTR _pszSrc$[esp+12]
$L338969:

; 605  : 			if( nOffset <= nOldLength )

  00051	3b f7		 cmp	 esi, edi
  00053	8b 45 00	 mov	 eax, DWORD PTR [ebp]
  00056	77 10		 ja	 SHORT $L221337

; 606  : 			{
; 607  : 				CopyCharsOverlapped( pszBuffer, pszBuffer+nOffset, nLength );

  00058	53		 push	 ebx
  00059	8d 0c 30	 lea	 ecx, DWORD PTR [eax+esi]
  0005c	51		 push	 ecx
  0005d	50		 push	 eax
  0005e	e8 00 00 00 00	 call	 _memmove
  00063	83 c4 0c	 add	 esp, 12			; 0000000cH

; 608  : 			}
; 609  : 			else

  00066	eb 14		 jmp	 SHORT $L338976
$L221337:

; 610  : 			{
; 611  : 				CopyChars( pszBuffer, pszSrc, nLength );

  00068	8b cb		 mov	 ecx, ebx
  0006a	8b f2		 mov	 esi, edx
  0006c	8b d1		 mov	 edx, ecx
  0006e	c1 e9 02	 shr	 ecx, 2
  00071	8b f8		 mov	 edi, eax
  00073	f3 a5		 rep movsd
  00075	8b ca		 mov	 ecx, edx
  00077	83 e1 03	 and	 ecx, 3
  0007a	f3 a4		 rep movsb
$L338976:

; 612  : 			}
; 613  : 			ReleaseBufferSetLength( nLength );

  0007c	85 db		 test	 ebx, ebx
  0007e	5f		 pop	 edi
  0007f	5e		 pop	 esi
  00080	7c 9c		 jl	 SHORT $L339002
  00082	8b 45 00	 mov	 eax, DWORD PTR [ebp]
  00085	3b 58 f8	 cmp	 ebx, DWORD PTR [eax-8]
  00088	7f 94		 jg	 SHORT $L339002
  0008a	89 58 f4	 mov	 DWORD PTR [eax-12], ebx
  0008d	8b 45 00	 mov	 eax, DWORD PTR [ebp]
  00090	5d		 pop	 ebp
  00091	c6 04 03 00	 mov	 BYTE PTR [ebx+eax], 0
  00095	5b		 pop	 ebx

; 614  : 		}
; 615  : 	}

  00096	c2 08 00	 ret	 8
$L339005:
?SetString@?$CSimpleStringT@D$0A@@ATL@@QAEXPBDH@Z ENDP	; ATL::CSimpleStringT<char,0>::SetString
_TEXT	ENDS
PUBLIC	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
EXTRN	?_Xlen@_String_base@std@@QBEXXZ:NEAR		; std::_String_base::_Xlen
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
__Trim$ = 12						; size = 1
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow, COMDAT
; _this$ = ecx

; 1480 : 		{	// ensure buffer is big enough, trim to size if _Trim is true

  00000	55		 push	 ebp
  00001	56		 push	 esi

; 1481 : 		if (max_size() < _Newsize)

  00002	8b 74 24 0c	 mov	 esi, DWORD PTR __Newsize$[esp+4]
  00006	83 fe fe	 cmp	 esi, -2			; fffffffeH
  00009	8b e9		 mov	 ebp, ecx
  0000b	76 05		 jbe	 SHORT $L221380

; 1482 : 			_String_base::_Xlen();	// result too long

  0000d	e8 00 00 00 00	 call	 ?_Xlen@_String_base@std@@QBEXXZ ; std::_String_base::_Xlen
$L221380:

; 1483 : 		if (_Myres < _Newsize)

  00012	8b 45 18	 mov	 eax, DWORD PTR [ebp+24]
  00015	3b c6		 cmp	 eax, esi
  00017	73 19		 jae	 SHORT $L221381

; 1484 : 			_Copy(_Newsize, _Mysize);	// reallocate to grow

  00019	8b 45 14	 mov	 eax, DWORD PTR [ebp+20]
  0001c	50		 push	 eax
  0001d	56		 push	 esi
  0001e	8b cd		 mov	 ecx, ebp
  00020	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy

; 1490 : 		return (0 < _Newsize);	// return true only if more work to do

  00025	33 c0		 xor	 eax, eax
  00027	3b c6		 cmp	 eax, esi
  00029	1b c0		 sbb	 eax, eax
  0002b	5e		 pop	 esi
  0002c	f7 d8		 neg	 eax
  0002e	5d		 pop	 ebp

; 1491 : 		}

  0002f	c2 08 00	 ret	 8
$L221381:

; 1485 : 		else if (_Trim && _Newsize < _BUF_SIZE)

  00032	8a 4c 24 10	 mov	 cl, BYTE PTR __Trim$[esp+4]
  00036	84 c9		 test	 cl, cl
  00038	74 5c		 je	 SHORT $L221383
  0003a	83 fe 10	 cmp	 esi, 16			; 00000010H
  0003d	73 57		 jae	 SHORT $L221383
  0003f	53		 push	 ebx

; 1486 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 1487 : 				_Newsize < _Mysize ? _Newsize : _Mysize);

  00040	8b 5d 14	 mov	 ebx, DWORD PTR [ebp+20]
  00043	3b f3		 cmp	 esi, ebx
  00045	73 02		 jae	 SHORT $L339011
  00047	8b de		 mov	 ebx, esi
$L339011:
  00049	83 f8 10	 cmp	 eax, 16			; 00000010H
  0004c	72 2b		 jb	 SHORT $L339066
  0004e	85 db		 test	 ebx, ebx
  00050	8b 45 04	 mov	 eax, DWORD PTR [ebp+4]
  00053	57		 push	 edi
  00054	8d 7d 04	 lea	 edi, DWORD PTR [ebp+4]
  00057	76 16		 jbe	 SHORT $L339063
  00059	8b cb		 mov	 ecx, ebx
  0005b	8b d1		 mov	 edx, ecx
  0005d	c1 e9 02	 shr	 ecx, 2
  00060	8b f0		 mov	 esi, eax
  00062	f3 a5		 rep movsd
  00064	8b ca		 mov	 ecx, edx
  00066	83 e1 03	 and	 ecx, 3
  00069	f3 a4		 rep movsb
  0006b	8b 74 24 14	 mov	 esi, DWORD PTR __Newsize$[esp+12]
$L339063:
  0006f	50		 push	 eax
  00070	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00075	83 c4 04	 add	 esp, 4
  00078	5f		 pop	 edi
$L339066:
  00079	89 5d 14	 mov	 DWORD PTR [ebp+20], ebx

; 1490 : 		return (0 < _Newsize);	// return true only if more work to do

  0007c	33 c0		 xor	 eax, eax
  0007e	c7 45 18 0f 00
	00 00		 mov	 DWORD PTR [ebp+24], 15	; 0000000fH
  00085	c6 44 2b 04 00	 mov	 BYTE PTR [ebx+ebp+4], 0
  0008a	3b c6		 cmp	 eax, esi
  0008c	5b		 pop	 ebx
  0008d	1b c0		 sbb	 eax, eax
  0008f	5e		 pop	 esi
  00090	f7 d8		 neg	 eax
  00092	5d		 pop	 ebp

; 1491 : 		}

  00093	c2 08 00	 ret	 8
$L221383:

; 1488 : 		else if (_Newsize == 0)

  00096	85 f6		 test	 esi, esi
  00098	75 23		 jne	 SHORT $L339101

; 1489 : 			_Eos(0);	// new size is zero, just null terminate

  0009a	83 f8 10	 cmp	 eax, 16			; 00000010H
  0009d	89 75 14	 mov	 DWORD PTR [ebp+20], esi
  000a0	72 14		 jb	 SHORT $L339098
  000a2	8b 6d 04	 mov	 ebp, DWORD PTR [ebp+4]

; 1490 : 		return (0 < _Newsize);	// return true only if more work to do

  000a5	33 c0		 xor	 eax, eax
  000a7	3b c6		 cmp	 eax, esi
  000a9	1b c0		 sbb	 eax, eax
  000ab	5e		 pop	 esi
  000ac	c6 45 00 00	 mov	 BYTE PTR [ebp], 0
  000b0	f7 d8		 neg	 eax
  000b2	5d		 pop	 ebp

; 1491 : 		}

  000b3	c2 08 00	 ret	 8

; 1489 : 			_Eos(0);	// new size is zero, just null terminate

$L339098:
  000b6	83 c5 04	 add	 ebp, 4
  000b9	c6 45 00 00	 mov	 BYTE PTR [ebp], 0
$L339101:

; 1490 : 		return (0 < _Newsize);	// return true only if more work to do

  000bd	33 c0		 xor	 eax, eax
  000bf	3b c6		 cmp	 eax, esi
  000c1	1b c0		 sbb	 eax, eax
  000c3	5e		 pop	 esi
  000c4	f7 d8		 neg	 eax
  000c6	5d		 pop	 ebp

; 1491 : 		}

  000c7	c2 08 00	 ret	 8
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
_TEXT	ENDS
PUBLIC	?clear@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::clear
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ?clear@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAEXXZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::clear, COMDAT
; _this$ = ecx

; 780  : 		{	// erase all

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 781  : 		_Erase(_Root());

  00003	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00006	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00009	51		 push	 ecx
  0000a	8b ce		 mov	 ecx, esi
  0000c	e8 00 00 00 00	 call	 ?_Erase@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Erase

; 782  : 		_Root() = _Myhead, _Mysize = 0;

  00011	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00014	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 783  : 		_Lmost() = _Myhead, _Rmost() = _Myhead;

  00017	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0001a	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00021	89 00		 mov	 DWORD PTR [eax], eax
  00023	8b 76 04	 mov	 esi, DWORD PTR [esi+4]
  00026	89 76 08	 mov	 DWORD PTR [esi+8], esi
  00029	5e		 pop	 esi

; 784  : 		}

  0002a	c3		 ret	 0
?clear@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::clear
_TEXT	ENDS
PUBLIC	?clear@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::clear
; Function compile flags: /Ogty
;	COMDAT ?clear@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAEXXZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::clear, COMDAT
; _this$ = ecx

; 780  : 		{	// erase all

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 781  : 		_Erase(_Root());

  00003	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00006	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00009	51		 push	 ecx
  0000a	8b ce		 mov	 ecx, esi
  0000c	e8 00 00 00 00	 call	 ?_Erase@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::_Erase

; 782  : 		_Root() = _Myhead, _Mysize = 0;

  00011	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00014	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 783  : 		_Lmost() = _Myhead, _Rmost() = _Myhead;

  00017	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0001a	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00021	89 00		 mov	 DWORD PTR [eax], eax
  00023	8b 76 04	 mov	 esi, DWORD PTR [esi+4]
  00026	89 76 08	 mov	 DWORD PTR [esi+8], esi
  00029	5e		 pop	 esi

; 784  : 		}

  0002a	c3		 ret	 0
?clear@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::clear
_TEXT	ENDS
PUBLIC	??Eiterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAE?AV012@H@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::iterator::operator++
; Function compile flags: /Ogty
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAE?AV012@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??Eiterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAE?AV012@H@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::iterator::operator++, COMDAT
; _this$ = ecx

; 332  : 			{	// postincrement

  00000	56		 push	 esi

; 333  : 			iterator _Tmp = *this;

  00001	8b 31		 mov	 esi, DWORD PTR [ecx]

; 334  : 			++*this;

  00003	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::const_iterator::_Inc

; 335  : 			return (_Tmp);

  00008	8b 44 24 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp]
  0000c	89 30		 mov	 DWORD PTR [eax], esi
  0000e	5e		 pop	 esi

; 336  : 			}

  0000f	c2 08 00	 ret	 8
??Eiterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAE?AV012@H@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::iterator::operator++
_TEXT	ENDS
PUBLIC	?clear@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::clear
; Function compile flags: /Ogty
;	COMDAT ?clear@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEXXZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::clear, COMDAT
; _this$ = ecx

; 780  : 		{	// erase all

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 781  : 		_Erase(_Root());

  00003	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00006	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00009	51		 push	 ecx
  0000a	8b ce		 mov	 ecx, esi
  0000c	e8 00 00 00 00	 call	 ?_Erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Erase

; 782  : 		_Root() = _Myhead, _Mysize = 0;

  00011	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00014	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 783  : 		_Lmost() = _Myhead, _Rmost() = _Myhead;

  00017	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0001a	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00021	89 00		 mov	 DWORD PTR [eax], eax
  00023	8b 76 04	 mov	 esi, DWORD PTR [esi+4]
  00026	89 76 08	 mov	 DWORD PTR [esi+8], esi
  00029	5e		 pop	 esi

; 784  : 		}

  0002a	c3		 ret	 0
?clear@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::clear
_TEXT	ENDS
PUBLIC	??Eiterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AV012@H@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::iterator::operator++
; Function compile flags: /Ogty
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AV012@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??Eiterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AV012@H@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::iterator::operator++, COMDAT
; _this$ = ecx

; 332  : 			{	// postincrement

  00000	56		 push	 esi

; 333  : 			iterator _Tmp = *this;

  00001	8b 31		 mov	 esi, DWORD PTR [ecx]

; 334  : 			++*this;

  00003	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::const_iterator::_Inc

; 335  : 			return (_Tmp);

  00008	8b 44 24 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp]
  0000c	89 30		 mov	 DWORD PTR [eax], esi
  0000e	5e		 pop	 esi

; 336  : 			}

  0000f	c2 08 00	 ret	 8
??Eiterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AV012@H@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::iterator::operator++
_TEXT	ENDS
PUBLIC	??$_Distance@Viterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@I@std@@YAXViterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@0@0AAI@Z ; std::_Distance<std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::iterator,unsigned int>
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xutility
;	COMDAT ??$_Distance@Viterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@I@std@@YAXViterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@0@0AAI@Z
_TEXT	SEGMENT
$T339275 = 8						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Off$ = 16						; size = 4
??$_Distance@Viterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@I@std@@YAXViterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@0@0AAI@Z PROC NEAR ; std::_Distance<std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::iterator,unsigned int>, COMDAT

; 498  : 	_Distance2(_First, _Last, _Off, _Iter_cat(_First));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __First$[esp-4]
  00004	57		 push	 edi
  00005	8b 7c 24 0c	 mov	 edi, DWORD PTR __Last$[esp]
  00009	3b c7		 cmp	 eax, edi
  0000b	89 44 24 08	 mov	 DWORD PTR $T339275[esp], eax
  0000f	74 21		 je	 SHORT $L339272
  00011	56		 push	 esi
  00012	8b 74 24 14	 mov	 esi, DWORD PTR __Off$[esp+4]
  00016	eb 08 8d a4 24
	00 00 00 00 90	 npad	 10
$L339264:
  00020	ff 06		 inc	 DWORD PTR [esi]
  00022	8d 4c 24 0c	 lea	 ecx, DWORD PTR $T339275[esp+4]
  00026	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::const_iterator::_Inc
  0002b	39 7c 24 0c	 cmp	 DWORD PTR $T339275[esp+4], edi
  0002f	75 ef		 jne	 SHORT $L339264
  00031	5e		 pop	 esi
$L339272:
  00032	5f		 pop	 edi

; 499  : 	}

  00033	c3		 ret	 0
??$_Distance@Viterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@I@std@@YAXViterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@0@0AAI@Z ENDP ; std::_Distance<std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::iterator,unsigned int>
_TEXT	ENDS
PUBLIC	?LevelUpSetting@CUser@@QAEXXZ			; CUser::LevelUpSetting
EXTRN	?SendUpdatePlayerData@CDPDatabaseClient@@QAEXPAVCUser@@@Z:NEAR ; CDPDatabaseClient::SendUpdatePlayerData
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
;	COMDAT ?LevelUpSetting@CUser@@QAEXXZ
_TEXT	SEGMENT
?LevelUpSetting@CUser@@QAEXXZ PROC NEAR			; CUser::LevelUpSetting, COMDAT
; _this$ = ecx

; 253  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 254  : 	g_UserMng.AddSetLevel( this, (short)GetLevel() );

  00003	33 c0		 xor	 eax, eax
  00005	66 8b 86 e0 05
	00 00		 mov	 ax, WORD PTR [esi+1504]
  0000c	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_UserMng@@3VCUserMng@@A
  00011	50		 push	 eax
  00012	56		 push	 esi
  00013	e8 00 00 00 00	 call	 ?AddSetLevel@CUserMng@@QAEXPAVCMover@@G@Z ; CUserMng::AddSetLevel

; 255  : 	AddSetGrowthLearningPoint( m_nRemainGP );

  00018	8b 8e 0c 06 00
	00		 mov	 ecx, DWORD PTR [esi+1548]
  0001e	51		 push	 ecx
  0001f	8b ce		 mov	 ecx, esi
  00021	e8 00 00 00 00	 call	 ?AddSetGrowthLearningPoint@CUser@@QAEXJ@Z ; CUser::AddSetGrowthLearningPoint

; 256  : 	g_dpDBClient.SendLogLevelUp( this, 1 );	//  

  00026	6a 01		 push	 1
  00028	56		 push	 esi
  00029	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_dpDBClient@@3VCDPDatabaseClient@@A
  0002e	e8 00 00 00 00	 call	 ?SendLogLevelUp@CDPDatabaseClient@@QAEXPAVCMover@@H@Z ; CDPDatabaseClient::SendLogLevelUp

; 257  : #if __VER >= 11 // __SYS_PLAYER_DATA
; 258  : 	g_dpDBClient.SendUpdatePlayerData( this );

  00033	56		 push	 esi
  00034	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_dpDBClient@@3VCDPDatabaseClient@@A
  00039	e8 00 00 00 00	 call	 ?SendUpdatePlayerData@CDPDatabaseClient@@QAEXPAVCUser@@@Z ; CDPDatabaseClient::SendUpdatePlayerData
  0003e	5e		 pop	 esi

; 259  : #else	// __SYS_PLAYER_DATA
; 260  : 	if( 0 < GetPartyId() )
; 261  : 		g_DPCoreClient.SendPartyMemberLevel( this );
; 262  : 	if( m_idGuild != 0 )
; 263  : 		g_DPCoreClient.SendGuildChangeJobLevel( this );
; 264  : #endif	// __SYS_PLAYER_DATA
; 265  : }

  0003f	c3		 ret	 0
?LevelUpSetting@CUser@@QAEXXZ ENDP			; CUser::LevelUpSetting
_TEXT	ENDS
PUBLIC	?AddEnvironment@CUser@@QAEXXZ			; CUser::AddEnvironment
EXTRN	?Serialize@CEnvironment@@QAEXAAVCAr@@@Z:NEAR	; CEnvironment::Serialize
EXTRN	?GetWeatherEventTitle@CEventLua@@QAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ:NEAR ; CEventLua::GetWeatherEventTitle
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\iosfwd
xdata$x	SEGMENT
$T339402 DD	0ffffffffH
	DD	FLAT:$L339288
$T339398 DD	019930520H
	DD	01H
	DD	FLAT:$T339402
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
xdata$x	ENDS
;	COMDAT ?AddEnvironment@CUser@@QAEXXZ
_TEXT	SEGMENT
$T339287 = -40						; size = 28
__$EHRec$ = -12						; size = 12
?AddEnvironment@CUser@@QAEXXZ PROC NEAR			; CUser::AddEnvironment, COMDAT
; _this$ = ecx

; 1574 : {

  00000	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00006	6a ff		 push	 -1
  00008	68 00 00 00 00	 push	 __ehhandler$?AddEnvironment@CUser@@QAEXXZ
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp

; 1575 : 	if( IsDelete() )	return;

  00015	8a 41 04	 mov	 al, BYTE PTR [ecx+4]
  00018	83 ec 1c	 sub	 esp, 28			; 0000001cH
  0001b	a8 01		 test	 al, 1
  0001d	0f 85 a4 00 00
	00		 jne	 $L339379

; 1576 : 	
; 1577 : 	m_Snapshot.cb++;

  00023	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  0002a	56		 push	 esi
  0002b	57		 push	 edi

; 1578 : 	m_Snapshot.ar << GetId();

  0002c	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  00032	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  00038	6a 04		 push	 4
  0003a	8b ce		 mov	 ecx, esi
  0003c	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00041	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00044	89 38		 mov	 DWORD PTR [eax], edi
  00046	83 46 08 04	 add	 DWORD PTR [esi+8], 4

; 1579 : 	m_Snapshot.ar << SNAPSHOTTYPE_ENVIRONMENT;

  0004a	6a 02		 push	 2
  0004c	8b ce		 mov	 ecx, esi
  0004e	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00053	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00056	66 c7 01 60 00	 mov	 WORD PTR [ecx], 96	; 00000060H
  0005b	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  0005e	83 c7 02	 add	 edi, 2

; 1580 : 
; 1581 : #ifdef __ENVIRONMENT_EFFECT
; 1582 : 
; 1583 : 	CEnvironment::GetInstance()->Serialize( m_Snapshot.ar );

  00061	56		 push	 esi
  00062	89 7e 08	 mov	 DWORD PTR [esi+8], edi
  00065	e8 00 00 00 00	 call	 ?GetInstance@CEnvironment@@SAPAV1@XZ ; CEnvironment::GetInstance
  0006a	8b c8		 mov	 ecx, eax
  0006c	e8 00 00 00 00	 call	 ?Serialize@CEnvironment@@QAEXAAVCAr@@@Z ; CEnvironment::Serialize

; 1584 : 	
; 1585 : 	if( CEnvironment::GetInstance()->GetEnvironmentEffect() == TRUE )

  00071	e8 00 00 00 00	 call	 ?GetInstance@CEnvironment@@SAPAV1@XZ ; CEnvironment::GetInstance
  00076	83 b8 d0 02 00
	00 01		 cmp	 DWORD PTR [eax+720], 1
  0007d	75 46		 jne	 SHORT $L339400

; 1586 : 	{
; 1587 : 		m_Snapshot.ar.WriteString( prj.m_EventLua.GetWeatherEventTitle().c_str() );

  0007f	8d 54 24 08	 lea	 edx, DWORD PTR $T339287[esp+48]
  00083	52		 push	 edx
  00084	b9 f8 91 11 00	 mov	 ecx, OFFSET FLAT:?prj@@3VCProject@@A+1151480
  00089	e8 00 00 00 00	 call	 ?GetWeatherEventTitle@CEventLua@@QAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ; CEventLua::GetWeatherEventTitle
  0008e	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00091	bf 10 00 00 00	 mov	 edi, 16			; 00000010H
  00096	3b cf		 cmp	 ecx, edi
  00098	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+56], 0
  000a0	72 05		 jb	 SHORT $L339319
  000a2	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000a5	eb 03		 jmp	 SHORT $L339320
$L339319:
  000a7	83 c0 04	 add	 eax, 4
$L339320:
  000aa	50		 push	 eax
  000ab	8b ce		 mov	 ecx, esi
  000ad	e8 00 00 00 00	 call	 ?WriteString@CAr@@QAEXPBD@Z ; CAr::WriteString
  000b2	39 7c 24 20	 cmp	 DWORD PTR $T339287[esp+72], edi
  000b6	72 0d		 jb	 SHORT $L339400
  000b8	8b 44 24 0c	 mov	 eax, DWORD PTR $T339287[esp+52]
  000bc	50		 push	 eax
  000bd	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000c2	83 c4 04	 add	 esp, 4
$L339400:
  000c5	5f		 pop	 edi
  000c6	5e		 pop	 esi
$L339379:

; 1588 : 	}
; 1589 : 
; 1590 : #else // __ENVIRONMENT_EFFECT
; 1591 : 
; 1592 : 	g_Environment.Serialize( m_Snapshot.ar );
; 1593 : #ifdef __EVENTLUA_RAIN
; 1594 : 	if( g_Environment.m_bRain )
; 1595 : 		m_Snapshot.ar.WriteString( prj.m_EventLua.GetRainEventTitle().c_str() );
; 1596 : #endif // __EVENTLUA_RAIN
; 1597 : #ifdef __EVENTLUA_SNOW
; 1598 : 	if( g_Environment.m_bSnow )
; 1599 : 		m_Snapshot.ar.WriteString( prj.m_EventLua.GetSnowEventTitle().c_str() );
; 1600 : #endif // __EVENTLUA_SNOW
; 1601 : 
; 1602 : #endif // __ENVIRONMENT_EFFECT
; 1603 : }

  000c7	8b 4c 24 1c	 mov	 ecx, DWORD PTR __$EHRec$[esp+40]
  000cb	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  000d2	83 c4 28	 add	 esp, 40			; 00000028H
  000d5	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L339288:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR $T339287[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?AddEnvironment@CUser@@QAEXXZ:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T339398
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?AddEnvironment@CUser@@QAEXXZ ENDP			; CUser::AddEnvironment
PUBLIC	?SendPartyList@CUser@@QAEXXZ			; CUser::SendPartyList
EXTRN	?GetLeader@CParty@@QAEPAVCMover@@XZ:NEAR	; CParty::GetLeader
EXTRN	?g_PartyMng@@3VCPartyMng@@A:BYTE		; g_PartyMng
; Function compile flags: /Ogty
;	COMDAT ?SendPartyList@CUser@@QAEXXZ
_TEXT	SEGMENT
_nPartyCount$ = -16					; size = 4
_it$ = -12						; size = 4
_uOffset$ = -8						; size = 4
_nBlockSize$ = -4					; size = 4
?SendPartyList@CUser@@QAEXXZ PROC NEAR			; CUser::SendPartyList, COMDAT
; _this$ = ecx

; 2055 : if( IsDelete() )	return;

  00000	8a 41 04	 mov	 al, BYTE PTR [ecx+4]
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	a8 01		 test	 al, 1
  00008	0f 85 61 01 00
	00		 jne	 $L278961

; 2056 : 
; 2057 : m_Snapshot.cb++;

  0000e	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  00015	53		 push	 ebx
  00016	55		 push	 ebp
  00017	56		 push	 esi
  00018	57		 push	 edi

; 2058 : m_Snapshot.ar << NULL_ID;

  00019	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  0001f	bb 04 00 00 00	 mov	 ebx, 4
  00024	53		 push	 ebx
  00025	8b ce		 mov	 ecx, esi
  00027	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0002c	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0002f	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [eax], -1
  00035	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  00038	03 fb		 add	 edi, ebx

; 2059 : m_Snapshot.ar << SNAPSHOTTYPE_PARTYLIST;

  0003a	6a 02		 push	 2
  0003c	8b ce		 mov	 ecx, esi
  0003e	89 7e 08	 mov	 DWORD PTR [esi+8], edi
  00041	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00046	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00049	66 c7 01 88 88	 mov	 WORD PTR [ecx], 34952	; 00008888H
  0004e	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00051	83 c1 02	 add	 ecx, 2
  00054	89 4e 08	 mov	 DWORD PTR [esi+8], ecx

; 2060 : 
; 2061 : u_long uOffset	= m_Snapshot.ar.GetOffset();

  00057	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0005a	8b e9		 mov	 ebp, ecx
  0005c	2b e8		 sub	 ebp, eax

; 2062 : int nPartyCount = 0;
; 2063 : 
; 2064 : m_Snapshot.ar << (int)0;	// nPartyCount

  0005e	53		 push	 ebx
  0005f	8b ce		 mov	 ecx, esi
  00061	89 6c 24 1c	 mov	 DWORD PTR _uOffset$[esp+36], ebp
  00065	c7 44 24 14 00
	00 00 00	 mov	 DWORD PTR _nPartyCount$[esp+36], 0
  0006d	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00072	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00075	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0
  0007b	01 5e 08	 add	 DWORD PTR [esi+8], ebx

; 2065 : 
; 2066 : map<DWORD, CParty*>::iterator it;
; 2067 : 
; 2068 : for( it = g_PartyMng.m_2PartyPtr.begin(); it != g_PartyMng.m_2PartyPtr.end(); ++it )

  0007e	a1 24 00 00 00	 mov	 eax, DWORD PTR ?g_PartyMng@@3VCPartyMng@@A+36
  00083	8b 38		 mov	 edi, DWORD PTR [eax]
  00085	3b f8		 cmp	 edi, eax
  00087	89 7c 24 14	 mov	 DWORD PTR _it$[esp+32], edi
  0008b	0f 84 c7 00 00
	00		 je	 $L279054
$L339481:

; 2069 : {
; 2070 : if(it->second->m_bAllowEnter && it->second->m_nSizeofMember < 8)

  00091	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  00094	8b 88 08 02 00
	00		 mov	 ecx, DWORD PTR [eax+520]
  0009a	85 c9		 test	 ecx, ecx
  0009c	0f 84 9d 00 00
	00		 je	 $L279053
  000a2	83 b8 cc 01 00
	00 08		 cmp	 DWORD PTR [eax+460], 8
  000a9	0f 8d 90 00 00
	00		 jge	 $L279053

; 2071 : {
; 2072 : m_Snapshot.ar << it->second->m_nLevel;

  000af	8b a8 d0 01 00
	00		 mov	 ebp, DWORD PTR [eax+464]
  000b5	53		 push	 ebx
  000b6	8b ce		 mov	 ecx, esi
  000b8	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000bd	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000c0	89 28		 mov	 DWORD PTR [eax], ebp
  000c2	01 5e 08	 add	 DWORD PTR [esi+8], ebx

; 2073 : m_Snapshot.ar << it->second->m_nPoint;

  000c5	8b 4f 10	 mov	 ecx, DWORD PTR [edi+16]
  000c8	8b a9 d8 01 00
	00		 mov	 ebp, DWORD PTR [ecx+472]
  000ce	53		 push	 ebx
  000cf	8b ce		 mov	 ecx, esi
  000d1	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000d6	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  000d9	89 2a		 mov	 DWORD PTR [edx], ebp
  000db	01 5e 08	 add	 DWORD PTR [esi+8], ebx

; 2074 : m_Snapshot.ar << it->second->m_nSizeofMember;

  000de	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  000e1	8b a8 cc 01 00
	00		 mov	 ebp, DWORD PTR [eax+460]
  000e7	53		 push	 ebx
  000e8	8b ce		 mov	 ecx, esi
  000ea	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000ef	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  000f2	89 29		 mov	 DWORD PTR [ecx], ebp
  000f4	01 5e 08	 add	 DWORD PTR [esi+8], ebx

; 2075 : m_Snapshot.ar << it->second->m_uPartyId;

  000f7	8b 57 10	 mov	 edx, DWORD PTR [edi+16]
  000fa	8b 2a		 mov	 ebp, DWORD PTR [edx]
  000fc	53		 push	 ebx
  000fd	8b ce		 mov	 ecx, esi
  000ff	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00104	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00107	89 28		 mov	 DWORD PTR [eax], ebp
  00109	01 5e 08	 add	 DWORD PTR [esi+8], ebx

; 2076 : m_Snapshot.ar.WriteString(it->second->m_sParty);

  0010c	8b 4f 10	 mov	 ecx, DWORD PTR [edi+16]
  0010f	03 cb		 add	 ecx, ebx
  00111	51		 push	 ecx
  00112	8b ce		 mov	 ecx, esi
  00114	e8 00 00 00 00	 call	 ?WriteString@CAr@@QAEXPBD@Z ; CAr::WriteString

; 2077 : m_Snapshot.ar.WriteString(it->second->GetLeader()->GetName());

  00119	8b 4f 10	 mov	 ecx, DWORD PTR [edi+16]
  0011c	6a 00		 push	 0
  0011e	e8 00 00 00 00	 call	 ?GetLeader@CParty@@QAEPAVCMover@@XZ ; CParty::GetLeader
  00123	8b c8		 mov	 ecx, eax
  00125	e8 00 00 00 00	 call	 ?GetName@CMover@@QAEPBDH@Z ; CMover::GetName
  0012a	50		 push	 eax
  0012b	8b ce		 mov	 ecx, esi
  0012d	e8 00 00 00 00	 call	 ?WriteString@CAr@@QAEXPBD@Z ; CAr::WriteString

; 2078 : 
; 2079 : nPartyCount++;

  00132	8b 44 24 10	 mov	 eax, DWORD PTR _nPartyCount$[esp+32]
  00136	8b 6c 24 18	 mov	 ebp, DWORD PTR _uOffset$[esp+32]
  0013a	40		 inc	 eax
  0013b	89 44 24 10	 mov	 DWORD PTR _nPartyCount$[esp+32], eax
$L279053:
  0013f	8d 4c 24 14	 lea	 ecx, DWORD PTR _it$[esp+32]
  00143	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCParty@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCParty@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned long,CParty *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CParty *> >,0> >::const_iterator::_Inc
  00148	8b 7c 24 14	 mov	 edi, DWORD PTR _it$[esp+32]
  0014c	3b 3d 24 00 00
	00		 cmp	 edi, DWORD PTR ?g_PartyMng@@3VCPartyMng@@A+36
  00152	0f 85 39 ff ff
	ff		 jne	 $L339481
$L279054:

; 2080 : }
; 2081 : }
; 2082 : 
; 2083 : GETBLOCK( m_Snapshot.ar, lpBlock, nBlockSize );

  00158	8d 54 24 1c	 lea	 edx, DWORD PTR _nBlockSize$[esp+32]
  0015c	52		 push	 edx
  0015d	8b ce		 mov	 ecx, esi
  0015f	e8 00 00 00 00	 call	 ?GetBuffer@CAr@@QAEPAEPAH@Z ; CAr::GetBuffer

; 2084 : *(UNALIGNED int*)( lpBlock + uOffset )	= nPartyCount;

  00164	8b 4c 24 10	 mov	 ecx, DWORD PTR _nPartyCount$[esp+32]
  00168	5f		 pop	 edi
  00169	5e		 pop	 esi
  0016a	89 0c 28	 mov	 DWORD PTR [eax+ebp], ecx
  0016d	5d		 pop	 ebp
  0016e	5b		 pop	 ebx
$L278961:

; 2085 : }

  0016f	83 c4 10	 add	 esp, 16			; 00000010H
  00172	c3		 ret	 0
?SendPartyList@CUser@@QAEXXZ ENDP			; CUser::SendPartyList
_TEXT	ENDS
PUBLIC	?AddEventLuaDesc@CUser@@QAEXHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CUser::AddEventLuaDesc
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\iosfwd
xdata$x	SEGMENT
$T340001 DD	0ffffffffH
	DD	FLAT:$L339732
$T339996 DD	019930520H
	DD	01H
	DD	FLAT:$T340001
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
xdata$x	ENDS
;	COMDAT ?AddEventLuaDesc@CUser@@QAEXHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_nState$ = 8						; size = 4
_strDesc$ = 12						; size = 28
?AddEventLuaDesc@CUser@@QAEXHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC NEAR ; CUser::AddEventLuaDesc, COMDAT
; _this$ = ecx

; 2201 : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?AddEventLuaDesc@CUser@@QAEXHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	51		 push	 ecx
  00016	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001b	33 c4		 xor	 eax, esp
  0001d	89 04 24	 mov	 DWORD PTR __$ArrayPad$[esp+16], eax
  00020	8b c1		 mov	 eax, ecx

; 2202 : 	if( strDesc.length() == 0 ) return;

  00022	8b 4c 24 2c	 mov	 ecx, DWORD PTR _strDesc$[esp+32]
  00026	85 c9		 test	 ecx, ecx
  00028	c7 44 24 0c 00
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+24], 0
  00030	75 0a		 jne	 SHORT $L279149
  00032	83 7c 24 30 10	 cmp	 DWORD PTR _strDesc$[esp+36], 16 ; 00000010H
  00037	e9 9a 00 00 00	 jmp	 $L339999
$L279149:

; 2203 : 	if( IsDelete() )	return;

  0003c	f6 40 04 01	 test	 BYTE PTR [eax+4], 1
  00040	74 15		 je	 SHORT $L279150
  00042	83 7c 24 30 10	 cmp	 DWORD PTR _strDesc$[esp+36], 16 ; 00000010H
  00047	0f 82 98 00 00
	00		 jb	 $L339981
  0004d	8b 4c 24 1c	 mov	 ecx, DWORD PTR _strDesc$[esp+16]
  00051	51		 push	 ecx
  00052	e9 86 00 00 00	 jmp	 $L340000
$L279150:

; 2204 : 	
; 2205 : 	m_Snapshot.cb++;

  00057	66 ff 80 0c 57
	00 00		 inc	 WORD PTR [eax+22284]
  0005e	56		 push	 esi
  0005f	57		 push	 edi

; 2206 : 	m_Snapshot.ar << GetId();

  00060	8b b8 bc 01 00
	00		 mov	 edi, DWORD PTR [eax+444]
  00066	8d b0 f8 16 00
	00		 lea	 esi, DWORD PTR [eax+5880]
  0006c	6a 04		 push	 4
  0006e	8b ce		 mov	 ecx, esi
  00070	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00075	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00078	89 3a		 mov	 DWORD PTR [edx], edi
  0007a	83 46 08 04	 add	 DWORD PTR [esi+8], 4

; 2207 : 	m_Snapshot.ar << SNAPSHOTTYPE_EVENTLUA_DESC;

  0007e	6a 02		 push	 2
  00080	8b ce		 mov	 ecx, esi
  00082	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00087	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0008a	66 c7 00 21 01	 mov	 WORD PTR [eax], 289	; 00000121H
  0008f	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  00092	83 c7 02	 add	 edi, 2

; 2208 : 	m_Snapshot.ar << nState;

  00095	6a 04		 push	 4
  00097	8b ce		 mov	 ecx, esi
  00099	89 7e 08	 mov	 DWORD PTR [esi+8], edi
  0009c	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000a1	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  000a4	8b 54 24 1c	 mov	 edx, DWORD PTR _nState$[esp+20]
  000a8	89 11		 mov	 DWORD PTR [ecx], edx
  000aa	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]

; 2209 : 	m_Snapshot.ar.WriteString( strDesc.c_str() );	

  000ad	8b 44 24 38	 mov	 eax, DWORD PTR _strDesc$[esp+44]
  000b1	83 c1 04	 add	 ecx, 4
  000b4	bf 10 00 00 00	 mov	 edi, 16			; 00000010H
  000b9	3b c7		 cmp	 eax, edi
  000bb	8b 44 24 24	 mov	 eax, DWORD PTR _strDesc$[esp+24]
  000bf	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  000c2	73 04		 jae	 SHORT $L339919
  000c4	8d 44 24 24	 lea	 eax, DWORD PTR _strDesc$[esp+24]
$L339919:
  000c8	50		 push	 eax
  000c9	8b ce		 mov	 ecx, esi
  000cb	e8 00 00 00 00	 call	 ?WriteString@CAr@@QAEXPBD@Z ; CAr::WriteString

; 2210 : }

  000d0	39 7c 24 38	 cmp	 DWORD PTR _strDesc$[esp+44], edi
  000d4	5f		 pop	 edi
  000d5	5e		 pop	 esi
$L339999:
  000d6	72 0d		 jb	 SHORT $L339981
  000d8	8b 44 24 1c	 mov	 eax, DWORD PTR _strDesc$[esp+16]
  000dc	50		 push	 eax
$L340000:
  000dd	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000e2	83 c4 04	 add	 esp, 4
$L339981:
  000e5	8b 4c 24 04	 mov	 ecx, DWORD PTR __$EHRec$[esp+16]
  000e9	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  000f0	8b 0c 24	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+16]
  000f3	33 cc		 xor	 ecx, esp
  000f5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000fa	83 c4 10	 add	 esp, 16			; 00000010H
  000fd	c2 20 00	 ret	 32			; 00000020H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L339732:
  00000	8d 4d 08	 lea	 ecx, DWORD PTR _strDesc$[ebp-4]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?AddEventLuaDesc@CUser@@QAEXHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T339996
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?AddEventLuaDesc@CUser@@QAEXHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; CUser::AddEventLuaDesc
PUBLIC	??_C@_0BA@LFPBHGMF@StartCollecting?$AA@		; `string'
PUBLIC	?StartCollecting@CUser@@UAEXXZ			; CUser::StartCollecting
EXTRN	?StartCollecting@CMover@@UAEXXZ:NEAR		; CMover::StartCollecting
;	COMDAT ??_C@_0BA@LFPBHGMF@StartCollecting?$AA@
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\mover.h
CONST	SEGMENT
??_C@_0BA@LFPBHGMF@StartCollecting?$AA@ DB 'StartCollecting', 00H ; `string'
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
CONST	ENDS
;	COMDAT ?StartCollecting@CUser@@UAEXXZ
_TEXT	SEGMENT
_log$ = -204						; size = 200
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
?StartCollecting@CUser@@UAEXXZ PROC NEAR		; CUser::StartCollecting, COMDAT
; _this$ = ecx

; 3165 : {

  00000	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c4		 xor	 eax, esp
  0000d	56		 push	 esi
  0000e	8b f1		 mov	 esi, ecx
  00010	89 84 24 cc 00
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+208], eax

; 3166 : //#ifdef _DEBUG
; 3167 : //	if( !IsRegionAttr( RA_SAFETY ) )
; 3168 : //#else	// _DEBUG
; 3169 : 	if( !IsRegionAttr( RA_COLLECTING ) )

  00017	f7 86 d4 02 00
	00 00 00 80 00	 test	 DWORD PTR [esi+724], 8388608 ; 00800000H
  00021	75 20		 jne	 SHORT $L279679

; 3170 : //#endif	// _DEBUG
; 3171 : 	{
; 3172 : 		AddDefinedText( TID_GAME_COLLECTING_REGION );		

  00023	68 2f 0d 00 00	 push	 3375			; 00000d2fH
  00028	e8 00 00 00 00	 call	 ?AddDefinedText@CUser@@QAEXH@Z ; CUser::AddDefinedText
  0002d	5e		 pop	 esi

; 3192 : #endif	// __HONORABLE_TITLE			// 
; 3193 : }

  0002e	8b 8c 24 c8 00
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+204]
  00035	33 cc		 xor	 ecx, esp
  00037	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003c	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00042	c3		 ret	 0
$L279679:

; 3173 : 		return;
; 3174 : 	}
; 3175 : 	// state
; 3176 : 	if( GetCollector() == NULL )

  00043	e8 00 00 00 00	 call	 ?GetCollector@CMover@@QAEPAVCItemElem@@XZ ; CMover::GetCollector
  00048	85 c0		 test	 eax, eax
  0004a	74 7f		 je	 SHORT $L279678

; 3177 : 		return;
; 3178 : 	CMover::StartCollecting();

  0004c	8b ce		 mov	 ecx, esi
  0004e	e8 00 00 00 00	 call	 ?StartCollecting@CMover@@UAEXXZ ; CMover::StartCollecting

; 3179 : 	g_UserMng.AddStartCollecting( this );

  00053	56		 push	 esi
  00054	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_UserMng@@3VCUserMng@@A
  00059	e8 00 00 00 00	 call	 ?AddStartCollecting@CUserMng@@QAEXPAVCUser@@@Z ; CUserMng::AddStartCollecting

; 3180 : 	// log
; 3181 : 	LogItemInfo	log;

  0005e	8d 4c 24 04	 lea	 ecx, DWORD PTR _log$[esp+208]
  00062	e8 00 00 00 00	 call	 ??0_LogItemInfo@@QAE@XZ	; _LogItemInfo::_LogItemInfo

; 3182 : 	log.Action	= "c";
; 3183 : 	log.SendName	= GetName();

  00067	6a 00		 push	 0
  00069	8b ce		 mov	 ecx, esi
  0006b	c7 44 24 08 00
	00 00 00	 mov	 DWORD PTR _log$[esp+212], OFFSET FLAT:??_C@_01PAPGNFGE@c?$AA@
  00073	e8 00 00 00 00	 call	 ?GetName@CMover@@QAEPBDH@Z ; CMover::GetName
  00078	89 44 24 08	 mov	 DWORD PTR _log$[esp+212], eax

; 3184 : 	log.RecvName	= "StartCollecting";
; 3185 : 	log.WorldId		= GetWorld()->GetID();

  0007c	8b 86 6c 01 00
	00		 mov	 eax, DWORD PTR [esi+364]
  00082	c7 44 24 0c 00
	00 00 00	 mov	 DWORD PTR _log$[esp+216], OFFSET FLAT:??_C@_0BA@LFPBHGMF@StartCollecting?$AA@
  0008a	8b 08		 mov	 ecx, DWORD PTR [eax]

; 3186 : 	log.Gold	= GetGold();

  0008c	8b 86 84 16 00
	00		 mov	 eax, DWORD PTR [esi+5764]
  00092	89 4c 24 10	 mov	 DWORD PTR _log$[esp+220], ecx

; 3187 : 	log.Gold2	= GetGold();
; 3188 : 	log.Gold_1	= GetCollector()->m_nHitPoint;

  00096	8b ce		 mov	 ecx, esi
  00098	89 44 24 14	 mov	 DWORD PTR _log$[esp+224], eax
  0009c	89 44 24 18	 mov	 DWORD PTR _log$[esp+228], eax
  000a0	e8 00 00 00 00	 call	 ?GetCollector@CMover@@QAEPAVCItemElem@@XZ ; CMover::GetCollector
  000a5	8b 50 7c	 mov	 edx, DWORD PTR [eax+124]

; 3189 : 	g_DPSrvr.OnLogItem( log );

  000a8	6a 00		 push	 0
  000aa	6a 00		 push	 0
  000ac	8d 44 24 0c	 lea	 eax, DWORD PTR _log$[esp+216]
  000b0	50		 push	 eax
  000b1	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_DPSrvr@@3VCDPSrvr@@A
  000b6	89 54 24 5c	 mov	 DWORD PTR _log$[esp+296], edx
  000ba	e8 00 00 00 00	 call	 ?OnLogItem@CDPSrvr@@QAEXAAU_LogItemInfo@@PAVCItemElem@@H@Z ; CDPSrvr::OnLogItem

; 3190 : #if __VER >= 13 // __HONORABLE_TITLE			// 
; 3191 : 	m_dwHonorCheckTime = GetTickCount();

  000bf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  000c5	89 86 08 09 00
	00		 mov	 DWORD PTR [esi+2312], eax
$L279678:

; 3192 : #endif	// __HONORABLE_TITLE			// 
; 3193 : }

  000cb	8b 8c 24 cc 00
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+208]
  000d2	5e		 pop	 esi
  000d3	33 cc		 xor	 ecx, esp
  000d5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000da	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  000e0	c3		 ret	 0
?StartCollecting@CUser@@UAEXXZ ENDP			; CUser::StartCollecting
_TEXT	ENDS
PUBLIC	??_C@_0P@GOPANMLP@StopCollecting?$AA@		; `string'
PUBLIC	?StopCollecting@CUser@@UAEXXZ			; CUser::StopCollecting
EXTRN	?StopCollecting@CMover@@UAEXXZ:NEAR		; CMover::StopCollecting
;	COMDAT ??_C@_0P@GOPANMLP@StopCollecting?$AA@
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\world.h
CONST	SEGMENT
??_C@_0P@GOPANMLP@StopCollecting?$AA@ DB 'StopCollecting', 00H ; `string'
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
CONST	ENDS
;	COMDAT ?StopCollecting@CUser@@UAEXXZ
_TEXT	SEGMENT
_log$ = -204						; size = 200
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
?StopCollecting@CUser@@UAEXXZ PROC NEAR			; CUser::StopCollecting, COMDAT
; _this$ = ecx

; 3196 : {

  00000	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c4		 xor	 eax, esp
  0000d	56		 push	 esi
  0000e	89 84 24 cc 00
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+208], eax
  00015	8b f1		 mov	 esi, ecx

; 3197 : 	// state
; 3198 : 	CMover::StopCollecting();

  00017	e8 00 00 00 00	 call	 ?StopCollecting@CMover@@UAEXXZ ; CMover::StopCollecting

; 3199 : 	m_nCollecting	= 0;
; 3200 : 	g_UserMng.AddStopCollecting( this );

  0001c	56		 push	 esi
  0001d	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_UserMng@@3VCUserMng@@A
  00022	c7 86 38 96 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+38456], 0
  0002c	e8 00 00 00 00	 call	 ?AddStopCollecting@CUserMng@@QAEXPAVCUser@@@Z ; CUserMng::AddStopCollecting

; 3201 : 	// log
; 3202 : 	LogItemInfo	log;

  00031	8d 4c 24 04	 lea	 ecx, DWORD PTR _log$[esp+208]
  00035	e8 00 00 00 00	 call	 ??0_LogItemInfo@@QAE@XZ	; _LogItemInfo::_LogItemInfo

; 3203 : 	log.Action	= "c";
; 3204 : 	log.SendName	= GetName();

  0003a	6a 00		 push	 0
  0003c	8b ce		 mov	 ecx, esi
  0003e	c7 44 24 08 00
	00 00 00	 mov	 DWORD PTR _log$[esp+212], OFFSET FLAT:??_C@_01PAPGNFGE@c?$AA@
  00046	e8 00 00 00 00	 call	 ?GetName@CMover@@QAEPBDH@Z ; CMover::GetName
  0004b	89 44 24 08	 mov	 DWORD PTR _log$[esp+212], eax

; 3205 : 	log.RecvName	= "StopCollecting";
; 3206 : 	log.WorldId		= GetWorld()->GetID();

  0004f	8b 86 6c 01 00
	00		 mov	 eax, DWORD PTR [esi+364]

; 3207 : 	g_DPSrvr.OnLogItem( log );

  00055	6a 00		 push	 0
  00057	c7 44 24 10 00
	00 00 00	 mov	 DWORD PTR _log$[esp+220], OFFSET FLAT:??_C@_0P@GOPANMLP@StopCollecting?$AA@
  0005f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00061	6a 00		 push	 0
  00063	8d 54 24 0c	 lea	 edx, DWORD PTR _log$[esp+216]
  00067	89 4c 24 18	 mov	 DWORD PTR _log$[esp+228], ecx
  0006b	52		 push	 edx
  0006c	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_DPSrvr@@3VCDPSrvr@@A
  00071	e8 00 00 00 00	 call	 ?OnLogItem@CDPSrvr@@QAEXAAU_LogItemInfo@@PAVCItemElem@@H@Z ; CDPSrvr::OnLogItem

; 3208 : }

  00076	8b 8c 24 cc 00
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+208]
  0007d	5e		 pop	 esi
  0007e	33 cc		 xor	 ecx, esp
  00080	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00085	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0008b	c3		 ret	 0
?StopCollecting@CUser@@UAEXXZ ENDP			; CUser::StopCollecting
_TEXT	ENDS
PUBLIC	?AddGC1to1TenderGuildView@CUser@@QAEXHHJAAV?$vector@U__GC1TO1TENDER@CGuildCombat1to1Mng@@V?$allocator@U__GC1TO1TENDER@CGuildCombat1to1Mng@@@std@@@std@@@Z ; CUser::AddGC1to1TenderGuildView
; Function compile flags: /Ogty
;	COMDAT ?AddGC1to1TenderGuildView@CUser@@QAEXHHJAAV?$vector@U__GC1TO1TENDER@CGuildCombat1to1Mng@@V?$allocator@U__GC1TO1TENDER@CGuildCombat1to1Mng@@@std@@@std@@@Z
_TEXT	SEGMENT
_i$279763 = 8						; size = 4
_nPenya$ = 8						; size = 4
_nRanking$ = 12						; size = 4
_t$ = 16						; size = 4
_vecTenderGuild$ = 20					; size = 4
?AddGC1to1TenderGuildView@CUser@@QAEXHHJAAV?$vector@U__GC1TO1TENDER@CGuildCombat1to1Mng@@V?$allocator@U__GC1TO1TENDER@CGuildCombat1to1Mng@@@std@@@std@@@Z PROC NEAR ; CUser::AddGC1to1TenderGuildView, COMDAT
; _this$ = ecx

; 3488 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	0f 85 1d 01 00
	00		 jne	 $L279767

; 3489 : 	m_Snapshot.cb++;

  0000a	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  00011	53		 push	 ebx
  00012	55		 push	 ebp
  00013	56		 push	 esi
  00014	57		 push	 edi

; 3490 : 	m_Snapshot.ar << NULL_ID;

  00015	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  0001b	bb 04 00 00 00	 mov	 ebx, 4
  00020	53		 push	 ebx
  00021	8b ce		 mov	 ecx, esi
  00023	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00028	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0002b	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [eax], -1
  00031	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00034	03 c3		 add	 eax, ebx

; 3491 : 	m_Snapshot.ar << SNAPSHOTTYPE_GC1TO1_TENDERVIEW;

  00036	6a 02		 push	 2
  00038	8b ce		 mov	 ecx, esi
  0003a	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0003d	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00042	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00045	66 c7 01 27 01	 mov	 WORD PTR [ecx], 295	; 00000127H
  0004a	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  0004d	83 c7 02	 add	 edi, 2

; 3492 : 	m_Snapshot.ar << nPenya;

  00050	53		 push	 ebx
  00051	8b ce		 mov	 ecx, esi
  00053	89 7e 08	 mov	 DWORD PTR [esi+8], edi
  00056	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0005b	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0005e	8b 44 24 14	 mov	 eax, DWORD PTR _nPenya$[esp+12]
  00062	89 02		 mov	 DWORD PTR [edx], eax
  00064	01 5e 08	 add	 DWORD PTR [esi+8], ebx

; 3493 : 	m_Snapshot.ar << nRanking;

  00067	53		 push	 ebx
  00068	8b ce		 mov	 ecx, esi
  0006a	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0006f	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00072	8b 54 24 18	 mov	 edx, DWORD PTR _nRanking$[esp+12]
  00076	89 11		 mov	 DWORD PTR [ecx], edx
  00078	8b 6e 08	 mov	 ebp, DWORD PTR [esi+8]
  0007b	03 eb		 add	 ebp, ebx

; 3494 : 	m_Snapshot.ar << t;

  0007d	53		 push	 ebx
  0007e	8b ce		 mov	 ecx, esi
  00080	89 6e 08	 mov	 DWORD PTR [esi+8], ebp
  00083	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00088	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0008b	8b 4c 24 1c	 mov	 ecx, DWORD PTR _t$[esp+12]

; 3495 : 	m_Snapshot.ar << vecTenderGuild.size();

  0008f	8b 6c 24 20	 mov	 ebp, DWORD PTR _vecTenderGuild$[esp+12]
  00093	89 08		 mov	 DWORD PTR [eax], ecx
  00095	01 5e 08	 add	 DWORD PTR [esi+8], ebx
  00098	8b 45 04	 mov	 eax, DWORD PTR [ebp+4]
  0009b	85 c0		 test	 eax, eax
  0009d	75 04		 jne	 SHORT $L340089
  0009f	33 ff		 xor	 edi, edi
  000a1	eb 16		 jmp	 SHORT $L340090
$L340089:
  000a3	8b 4d 08	 mov	 ecx, DWORD PTR [ebp+8]
  000a6	2b c8		 sub	 ecx, eax
  000a8	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  000ad	f7 e9		 imul	 ecx
  000af	c1 fa 03	 sar	 edx, 3
  000b2	8b fa		 mov	 edi, edx
  000b4	c1 ef 1f	 shr	 edi, 31			; 0000001fH
  000b7	03 fa		 add	 edi, edx
$L340090:
  000b9	53		 push	 ebx
  000ba	8b ce		 mov	 ecx, esi
  000bc	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000c1	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  000c4	89 3a		 mov	 DWORD PTR [edx], edi
  000c6	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000c9	03 c3		 add	 eax, ebx

; 3496 : 	for( int i=0; i<(int)( vecTenderGuild.size() ); i++ )

  000cb	33 db		 xor	 ebx, ebx
  000cd	89 46 08	 mov	 DWORD PTR [esi+8], eax
  000d0	89 5c 24 14	 mov	 DWORD PTR _i$279763[esp+12], ebx
$L279765:
  000d4	8b 7d 04	 mov	 edi, DWORD PTR [ebp+4]
  000d7	85 ff		 test	 edi, edi
  000d9	75 04		 jne	 SHORT $L340106
  000db	33 c0		 xor	 eax, eax
  000dd	eb 16		 jmp	 SHORT $L340107
$L340106:
  000df	8b 4d 08	 mov	 ecx, DWORD PTR [ebp+8]
  000e2	2b cf		 sub	 ecx, edi
  000e4	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  000e9	f7 e9		 imul	 ecx
  000eb	c1 fa 03	 sar	 edx, 3
  000ee	8b c2		 mov	 eax, edx
  000f0	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  000f3	03 c2		 add	 eax, edx
$L340107:
  000f5	39 44 24 14	 cmp	 DWORD PTR _i$279763[esp+12], eax
  000f9	7d 28		 jge	 SHORT $L340170

; 3497 : 		m_Snapshot.ar << vecTenderGuild[i].ulGuildId;

  000fb	8b 3c 3b	 mov	 edi, DWORD PTR [ebx+edi]
  000fe	6a 04		 push	 4
  00100	8b ce		 mov	 ecx, esi
  00102	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00107	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0010a	8b 4c 24 14	 mov	 ecx, DWORD PTR _i$279763[esp+12]
  0010e	89 38		 mov	 DWORD PTR [eax], edi
  00110	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00113	83 c2 04	 add	 edx, 4
  00116	41		 inc	 ecx
  00117	89 56 08	 mov	 DWORD PTR [esi+8], edx
  0011a	89 4c 24 14	 mov	 DWORD PTR _i$279763[esp+12], ecx
  0011e	83 c3 30	 add	 ebx, 48			; 00000030H
  00121	eb b1		 jmp	 SHORT $L279765
$L340170:
  00123	5f		 pop	 edi
  00124	5e		 pop	 esi
  00125	5d		 pop	 ebp
  00126	5b		 pop	 ebx
$L279767:

; 3498 : }

  00127	c2 10 00	 ret	 16			; 00000010H
?AddGC1to1TenderGuildView@CUser@@QAEXHHJAAV?$vector@U__GC1TO1TENDER@CGuildCombat1to1Mng@@V?$allocator@U__GC1TO1TENDER@CGuildCombat1to1Mng@@@std@@@std@@@Z ENDP ; CUser::AddGC1to1TenderGuildView
_TEXT	ENDS
PUBLIC	?AddGC1to1NowState@CUser@@QAEXHHH@Z		; CUser::AddGC1to1NowState
EXTRN	?GetTenderGuildIndexByUser@CGuildCombat1to1Mng@@QAEHPAVCUser@@@Z:NEAR ; CGuildCombat1to1Mng::GetTenderGuildIndexByUser
EXTRN	?GetTargetTenderGuildIndexByUser@CGuildCombat1to1Mng@@QAEHPAVCUser@@@Z:NEAR ; CGuildCombat1to1Mng::GetTargetTenderGuildIndexByUser
; Function compile flags: /Ogty
;	COMDAT ?AddGC1to1NowState@CUser@@QAEXHHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
$T340396 = 8						; size = 4
_nState$ = 8						; size = 4
_nTime$ = 12						; size = 4
_nProgCount$ = 16					; size = 4
?AddGC1to1NowState@CUser@@QAEXHHH@Z PROC NEAR		; CUser::AddGC1to1NowState, COMDAT
; _this$ = ecx

; 3501 : {

  00000	51		 push	 ecx
  00001	53		 push	 ebx
  00002	8b d9		 mov	 ebx, ecx

; 3502 : 	if( IsDelete() )	return;

  00004	f6 43 04 01	 test	 BYTE PTR [ebx+4], 1
  00008	89 5c 24 04	 mov	 DWORD PTR _this$[esp+8], ebx
  0000c	0f 85 5c 01 00
	00		 jne	 $L340465

; 3503 : 	m_Snapshot.cb++;

  00012	66 ff 83 0c 57
	00 00		 inc	 WORD PTR [ebx+22284]
  00019	55		 push	 ebp
  0001a	56		 push	 esi
  0001b	57		 push	 edi

; 3504 : 	m_Snapshot.ar << NULL_ID;

  0001c	8d b3 f8 16 00
	00		 lea	 esi, DWORD PTR [ebx+5880]
  00022	bf 04 00 00 00	 mov	 edi, 4
  00027	57		 push	 edi
  00028	8b ce		 mov	 ecx, esi
  0002a	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0002f	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00032	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [eax], -1
  00038	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0003b	03 c7		 add	 eax, edi

; 3505 : 	m_Snapshot.ar << SNAPSHOTTYPE_GC1TO1_NOWSTATE;

  0003d	6a 02		 push	 2
  0003f	8b ce		 mov	 ecx, esi
  00041	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00044	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00049	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0004c	66 c7 01 25 01	 mov	 WORD PTR [ecx], 293	; 00000125H
  00051	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00054	83 c2 02	 add	 edx, 2

; 3506 : 	m_Snapshot.ar << nState << nTime;

  00057	57		 push	 edi
  00058	8b ce		 mov	 ecx, esi
  0005a	89 56 08	 mov	 DWORD PTR [esi+8], edx
  0005d	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00062	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00065	8b 6c 24 18	 mov	 ebp, DWORD PTR _nState$[esp+16]
  00069	89 2a		 mov	 DWORD PTR [edx], ebp
  0006b	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0006e	03 c7		 add	 eax, edi
  00070	57		 push	 edi
  00071	8b ce		 mov	 ecx, esi
  00073	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00076	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0007b	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0007e	8b 4c 24 1c	 mov	 ecx, DWORD PTR _nTime$[esp+16]
  00082	89 08		 mov	 DWORD PTR [eax], ecx
  00084	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00087	03 cf		 add	 ecx, edi

; 3507 : 
; 3508 : 	if( nState == g_GuildCombat1to1Mng.GC1TO1_ENTRANCE )

  00089	83 fd 02	 cmp	 ebp, 2
  0008c	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  0008f	0f 85 bd 00 00
	00		 jne	 $L340455

; 3509 : 	{
; 3510 : 		//   ID
; 3511 : 		int nIndex = g_GuildCombat1to1Mng.GetTenderGuildIndexByUser( this );

  00095	53		 push	 ebx
  00096	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_GuildCombat1to1Mng@@3VCGuildCombat1to1Mng@@A
  0009b	e8 00 00 00 00	 call	 ?GetTenderGuildIndexByUser@CGuildCombat1to1Mng@@QAEHPAVCUser@@@Z ; CGuildCombat1to1Mng::GetTenderGuildIndexByUser

; 3512 : 		int nSize = g_GuildCombat1to1Mng.m_vecTenderGuild[nIndex].vecMemberId.size();

  000a0	8b 0d 54 00 00
	00		 mov	 ecx, DWORD PTR ?g_GuildCombat1to1Mng@@3VCGuildCombat1to1Mng@@A+84
  000a6	8d 1c 40	 lea	 ebx, DWORD PTR [eax+eax*2]
  000a9	c1 e3 04	 shl	 ebx, 4
  000ac	8b 44 0b 24	 mov	 eax, DWORD PTR [ebx+ecx+36]
  000b0	85 c0		 test	 eax, eax
  000b2	75 04		 jne	 SHORT $L340271
  000b4	33 ed		 xor	 ebp, ebp
  000b6	eb 09		 jmp	 SHORT $L340272
$L340271:
  000b8	8b 6c 0b 28	 mov	 ebp, DWORD PTR [ebx+ecx+40]
  000bc	2b e8		 sub	 ebp, eax
  000be	c1 fd 02	 sar	 ebp, 2
$L340272:

; 3513 : 		m_Snapshot.ar << nSize;

  000c1	57		 push	 edi
  000c2	8b ce		 mov	 ecx, esi
  000c4	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000c9	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  000cc	89 2a		 mov	 DWORD PTR [edx], ebp
  000ce	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  000d1	03 cf		 add	 ecx, edi

; 3514 : 		for( int i=0; i<nSize; i++ )

  000d3	33 ff		 xor	 edi, edi
  000d5	85 ed		 test	 ebp, ebp
  000d7	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  000da	7e 37		 jle	 SHORT $L279782
  000dc	8d 64 24 00	 npad	 4
$L279780:
  000e0	a1 54 00 00 00	 mov	 eax, DWORD PTR ?g_GuildCombat1to1Mng@@3VCGuildCombat1to1Mng@@A+84
  000e5	8b 4c 03 24	 mov	 ecx, DWORD PTR [ebx+eax+36]

; 3515 : 			m_Snapshot.ar << g_GuildCombat1to1Mng.m_vecTenderGuild[nIndex].vecMemberId[i];

  000e9	8b 14 b9	 mov	 edx, DWORD PTR [ecx+edi*4]
  000ec	8d 04 b9	 lea	 eax, DWORD PTR [ecx+edi*4]
  000ef	6a 04		 push	 4
  000f1	8b ce		 mov	 ecx, esi
  000f3	89 54 24 1c	 mov	 DWORD PTR $T340396[esp+20], edx
  000f7	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000fc	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000ff	8b 4c 24 18	 mov	 ecx, DWORD PTR $T340396[esp+16]
  00103	89 08		 mov	 DWORD PTR [eax], ecx
  00105	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00108	83 c2 04	 add	 edx, 4
  0010b	47		 inc	 edi
  0010c	3b fd		 cmp	 edi, ebp
  0010e	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00111	7c cd		 jl	 SHORT $L279780
$L279782:

; 3516 : 		//   ID
; 3517 : 		nIndex = g_GuildCombat1to1Mng.GetTargetTenderGuildIndexByUser( this );

  00113	8b 54 24 10	 mov	 edx, DWORD PTR _this$[esp+20]
  00117	52		 push	 edx
  00118	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_GuildCombat1to1Mng@@3VCGuildCombat1to1Mng@@A
  0011d	e8 00 00 00 00	 call	 ?GetTargetTenderGuildIndexByUser@CGuildCombat1to1Mng@@QAEHPAVCUser@@@Z ; CGuildCombat1to1Mng::GetTargetTenderGuildIndexByUser

; 3518 : 		m_Snapshot.ar << g_GuildCombat1to1Mng.m_vecTenderGuild[nIndex].ulGuildId;

  00122	8b 15 54 00 00
	00		 mov	 edx, DWORD PTR ?g_GuildCombat1to1Mng@@3VCGuildCombat1to1Mng@@A+84
  00128	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  0012b	c1 e0 04	 shl	 eax, 4
  0012e	8b 3c 10	 mov	 edi, DWORD PTR [eax+edx]
  00131	03 c2		 add	 eax, edx
  00133	6a 04		 push	 4
  00135	8b ce		 mov	 ecx, esi
  00137	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0013c	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0013f	89 38		 mov	 DWORD PTR [eax], edi
  00141	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00144	5f		 pop	 edi
  00145	83 c0 04	 add	 eax, 4

; 3522 : 		m_Snapshot.ar << nProgCount;

  00148	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0014b	5e		 pop	 esi
  0014c	5d		 pop	 ebp
  0014d	5b		 pop	 ebx

; 3523 : }

  0014e	59		 pop	 ecx
  0014f	c2 0c 00	 ret	 12			; 0000000cH

; 3518 : 		m_Snapshot.ar << g_GuildCombat1to1Mng.m_vecTenderGuild[nIndex].ulGuildId;

$L340455:

; 3519 : 	}
; 3520 : 
; 3521 : 	if( nState == CGuildCombat1to1::GC1TO1WAR_WAIT )

  00152	83 fd 65	 cmp	 ebp, 101		; 00000065H
  00155	75 14		 jne	 SHORT $L340469

; 3522 : 		m_Snapshot.ar << nProgCount;

  00157	57		 push	 edi
  00158	8b ce		 mov	 ecx, esi
  0015a	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0015f	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00162	8b 54 24 20	 mov	 edx, DWORD PTR _nProgCount$[esp+16]
  00166	89 11		 mov	 DWORD PTR [ecx], edx
  00168	01 7e 08	 add	 DWORD PTR [esi+8], edi
$L340469:
  0016b	5f		 pop	 edi
  0016c	5e		 pop	 esi
  0016d	5d		 pop	 ebp
$L340465:
  0016e	5b		 pop	 ebx

; 3523 : }

  0016f	59		 pop	 ecx
  00170	c2 0c 00	 ret	 12			; 0000000cH
?AddGC1to1NowState@CUser@@QAEXHHH@Z ENDP		; CUser::AddGC1to1NowState
_TEXT	ENDS
PUBLIC	?AddGC1to1MemberLineUpOpenWnd@CUser@@QAEXAAV?$vector@KV?$allocator@K@std@@@std@@@Z ; CUser::AddGC1to1MemberLineUpOpenWnd
; Function compile flags: /Ogty
;	COMDAT ?AddGC1to1MemberLineUpOpenWnd@CUser@@QAEXAAV?$vector@KV?$allocator@K@std@@@std@@@Z
_TEXT	SEGMENT
_vecMemberId$ = 8					; size = 4
?AddGC1to1MemberLineUpOpenWnd@CUser@@QAEXAAV?$vector@KV?$allocator@K@std@@@std@@@Z PROC NEAR ; CUser::AddGC1to1MemberLineUpOpenWnd, COMDAT
; _this$ = ecx

; 3527 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	0f 85 f0 00 00
	00		 jne	 $L279795

; 3528 : 	m_Snapshot.cb++;

  0000a	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  00011	53		 push	 ebx
  00012	55		 push	 ebp
  00013	56		 push	 esi
  00014	57		 push	 edi

; 3529 : 	m_Snapshot.ar << NULL_ID;

  00015	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  0001b	bd 04 00 00 00	 mov	 ebp, 4
  00020	55		 push	 ebp
  00021	8b ce		 mov	 ecx, esi
  00023	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00028	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0002b	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [eax], -1
  00031	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00034	03 d5		 add	 edx, ebp

; 3530 : 	m_Snapshot.ar << SNAPSHOTTYPE_GC1TO1_MEMBERLINEUPOPENWND;

  00036	6a 02		 push	 2
  00038	8b ce		 mov	 ecx, esi
  0003a	89 56 08	 mov	 DWORD PTR [esi+8], edx
  0003d	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00042	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00045	66 c7 01 28 01	 mov	 WORD PTR [ecx], 296	; 00000128H
  0004a	83 46 08 02	 add	 DWORD PTR [esi+8], 2

; 3531 : 	m_Snapshot.ar << g_GuildCombat1to1Mng.m_nMinJoinPlayerLevel;

  0004e	8b 3d 14 00 00
	00		 mov	 edi, DWORD PTR ?g_GuildCombat1to1Mng@@3VCGuildCombat1to1Mng@@A+20
  00054	55		 push	 ebp
  00055	8b ce		 mov	 ecx, esi
  00057	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0005c	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0005f	89 3a		 mov	 DWORD PTR [edx], edi
  00061	01 6e 08	 add	 DWORD PTR [esi+8], ebp

; 3532 : 	m_Snapshot.ar << g_GuildCombat1to1Mng.m_nMinJoinPlayer;

  00064	8b 3d 10 00 00
	00		 mov	 edi, DWORD PTR ?g_GuildCombat1to1Mng@@3VCGuildCombat1to1Mng@@A+16
  0006a	55		 push	 ebp
  0006b	8b ce		 mov	 ecx, esi
  0006d	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00072	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00075	89 38		 mov	 DWORD PTR [eax], edi
  00077	01 6e 08	 add	 DWORD PTR [esi+8], ebp

; 3533 : 	m_Snapshot.ar << g_GuildCombat1to1Mng.m_nMaxJoinPlayer;

  0007a	8b 3d 0c 00 00
	00		 mov	 edi, DWORD PTR ?g_GuildCombat1to1Mng@@3VCGuildCombat1to1Mng@@A+12
  00080	55		 push	 ebp
  00081	8b ce		 mov	 ecx, esi
  00083	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00088	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]

; 3534 : 	m_Snapshot.ar << vecMemberId.size();

  0008b	8b 5c 24 14	 mov	 ebx, DWORD PTR _vecMemberId$[esp+12]
  0008f	89 39		 mov	 DWORD PTR [ecx], edi
  00091	01 6e 08	 add	 DWORD PTR [esi+8], ebp
  00094	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  00097	85 c0		 test	 eax, eax
  00099	75 04		 jne	 SHORT $L340528
  0009b	33 ff		 xor	 edi, edi
  0009d	eb 08		 jmp	 SHORT $L340529
$L340528:
  0009f	8b 7b 08	 mov	 edi, DWORD PTR [ebx+8]
  000a2	2b f8		 sub	 edi, eax
  000a4	c1 ff 02	 sar	 edi, 2
$L340529:
  000a7	55		 push	 ebp
  000a8	8b ce		 mov	 ecx, esi
  000aa	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000af	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  000b2	89 3a		 mov	 DWORD PTR [edx], edi
  000b4	01 6e 08	 add	 DWORD PTR [esi+8], ebp

; 3535 : 	for( int i=0; i<(int)( vecMemberId.size() ); i++ )

  000b7	33 ff		 xor	 edi, edi
  000b9	8d a4 24 00 00
	00 00		 npad	 7
$L279793:
  000c0	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  000c3	85 c9		 test	 ecx, ecx
  000c5	75 04		 jne	 SHORT $L340545
  000c7	33 c0		 xor	 eax, eax
  000c9	eb 08		 jmp	 SHORT $L340546
$L340545:
  000cb	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  000ce	2b c1		 sub	 eax, ecx
  000d0	c1 f8 02	 sar	 eax, 2
$L340546:
  000d3	3b f8		 cmp	 edi, eax
  000d5	7d 1f		 jge	 SHORT $L340608

; 3536 : 		m_Snapshot.ar << vecMemberId[i];

  000d7	8b 1c b9	 mov	 ebx, DWORD PTR [ecx+edi*4]
  000da	55		 push	 ebp
  000db	8b ce		 mov	 ecx, esi
  000dd	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000e2	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000e5	89 18		 mov	 DWORD PTR [eax], ebx
  000e7	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  000ea	8b 5c 24 14	 mov	 ebx, DWORD PTR _vecMemberId$[esp+12]
  000ee	03 cd		 add	 ecx, ebp
  000f0	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  000f3	47		 inc	 edi
  000f4	eb ca		 jmp	 SHORT $L279793
$L340608:
  000f6	5f		 pop	 edi
  000f7	5e		 pop	 esi
  000f8	5d		 pop	 ebp
  000f9	5b		 pop	 ebx
$L279795:

; 3537 : }

  000fa	c2 04 00	 ret	 4
?AddGC1to1MemberLineUpOpenWnd@CUser@@QAEXAAV?$vector@KV?$allocator@K@std@@@std@@@Z ENDP ; CUser::AddGC1to1MemberLineUpOpenWnd
_TEXT	ENDS
PUBLIC	?AddEventLuaDesc@CUser@@QAEXXZ			; CUser::AddEventLuaDesc
EXTRN	?GetEventList@CEventLua@@QAE?AV?$vector@EV?$allocator@E@std@@@std@@H@Z:NEAR ; CEventLua::GetEventList
EXTRN	?GetDesc@CEventLua@@QAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@E@Z:NEAR ; CEventLua::GetDesc
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
xdata$x	SEGMENT
$T340704 DD	0ffffffffH
	DD	FLAT:$L340616
$T340701 DD	019930520H
	DD	01H
	DD	FLAT:$T340704
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
xdata$x	ENDS
;	COMDAT ?AddEventLuaDesc@CUser@@QAEXXZ
_TEXT	SEGMENT
$T340615 = -32						; size = 4
_vecList$ = -28						; size = 16
__$EHRec$ = -12						; size = 12
?AddEventLuaDesc@CUser@@QAEXXZ PROC NEAR		; CUser::AddEventLuaDesc, COMDAT
; _this$ = ecx

; 3732 : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?AddEventLuaDesc@CUser@@QAEXXZ
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	83 ec 14	 sub	 esp, 20			; 00000014H
  00018	56		 push	 esi
  00019	57		 push	 edi

; 3733 : 	vector<BYTE> vecList	= prj.m_EventLua.GetEventList();

  0001a	6a 01		 push	 1
  0001c	8d 44 24 10	 lea	 eax, DWORD PTR _vecList$[esp+44]
  00020	8b f9		 mov	 edi, ecx
  00022	50		 push	 eax
  00023	b9 f8 91 11 00	 mov	 ecx, OFFSET FLAT:?prj@@3VCProject@@A+1151480
  00028	e8 00 00 00 00	 call	 ?GetEventList@CEventLua@@QAE?AV?$vector@EV?$allocator@E@std@@@std@@H@Z ; CEventLua::GetEventList
  0002d	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+48], 0

; 3734 : 	for( int it = 0; it < (int)( vecList.size() ); it++ )

  00035	33 f6		 xor	 esi, esi
$L279927:
  00037	8b 4c 24 10	 mov	 ecx, DWORD PTR _vecList$[esp+44]
  0003b	85 c9		 test	 ecx, ecx
  0003d	75 04		 jne	 SHORT $L340623
  0003f	33 c0		 xor	 eax, eax
  00041	eb 06		 jmp	 SHORT $L340624
$L340623:
  00043	8b 44 24 14	 mov	 eax, DWORD PTR _vecList$[esp+48]
  00047	2b c1		 sub	 eax, ecx
$L340624:
  00049	3b f0		 cmp	 esi, eax
  0004b	7d 26		 jge	 SHORT $L279929

; 3735 : 		AddEventLuaDesc( 2, prj.m_EventLua.GetDesc( vecList[it] ) );

  0004d	33 c0		 xor	 eax, eax
  0004f	8a 04 31	 mov	 al, BYTE PTR [ecx+esi]
  00052	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00055	8b d4		 mov	 edx, esp
  00057	89 64 24 24	 mov	 DWORD PTR $T340615[esp+68], esp
  0005b	b9 f8 91 11 00	 mov	 ecx, OFFSET FLAT:?prj@@3VCProject@@A+1151480
  00060	50		 push	 eax
  00061	52		 push	 edx
  00062	e8 00 00 00 00	 call	 ?GetDesc@CEventLua@@QAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@E@Z ; CEventLua::GetDesc
  00067	6a 02		 push	 2
  00069	8b cf		 mov	 ecx, edi
  0006b	e8 00 00 00 00	 call	 ?AddEventLuaDesc@CUser@@QAEXHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CUser::AddEventLuaDesc
  00070	46		 inc	 esi
  00071	eb c4		 jmp	 SHORT $L279927
$L279929:

; 3736 : }

  00073	85 c9		 test	 ecx, ecx
  00075	74 09		 je	 SHORT $L340699
  00077	51		 push	 ecx
  00078	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0007d	83 c4 04	 add	 esp, 4
$L340699:
  00080	8b 4c 24 1c	 mov	 ecx, DWORD PTR __$EHRec$[esp+40]
  00084	5f		 pop	 edi
  00085	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0008c	5e		 pop	 esi
  0008d	83 c4 20	 add	 esp, 32			; 00000020H
  00090	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L340616:
  00000	8d 4d e4	 lea	 ecx, DWORD PTR _vecList$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
__ehhandler$?AddEventLuaDesc@CUser@@QAEXXZ:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T340701
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?AddEventLuaDesc@CUser@@QAEXXZ ENDP			; CUser::AddEventLuaDesc
PUBLIC	?ActiveCoupleBuff@CUser@@QAEXH@Z		; CUser::ActiveCoupleBuff
EXTRN	?Instance@CCoupleProperty@@SAPAV1@XZ:NEAR	; CCoupleProperty::Instance
EXTRN	?GetSkill@CCoupleProperty@@QAEAAV?$vector@HV?$allocator@H@std@@@std@@H@Z:NEAR ; CCoupleProperty::GetSkill
; Function compile flags: /Ogty
;	COMDAT ?ActiveCoupleBuff@CUser@@QAEXH@Z
_TEXT	SEGMENT
_nLevel$ = 8						; size = 4
?ActiveCoupleBuff@CUser@@QAEXH@Z PROC NEAR		; CUser::ActiveCoupleBuff, COMDAT
; _this$ = ecx

; 3834 : 	VS& vSkills	= CCoupleProperty::Instance()->GetSkill( nLevel );

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _nLevel$[esp-4]
  00004	53		 push	 ebx
  00005	56		 push	 esi
  00006	57		 push	 edi
  00007	50		 push	 eax
  00008	8b f1		 mov	 esi, ecx
  0000a	e8 00 00 00 00	 call	 ?Instance@CCoupleProperty@@SAPAV1@XZ ; CCoupleProperty::Instance
  0000f	8b c8		 mov	 ecx, eax
  00011	e8 00 00 00 00	 call	 ?GetSkill@CCoupleProperty@@QAEAAV?$vector@HV?$allocator@H@std@@@std@@H@Z ; CCoupleProperty::GetSkill

; 3835 : 	for( int i = 0; i < (int)( vSkills.size() ); i++ )

  00016	8b 15 5c 02 00
	00		 mov	 edx, DWORD PTR ?prj@@3VCProject@@A+604
  0001c	8b d8		 mov	 ebx, eax
  0001e	33 ff		 xor	 edi, edi
$L279994:
  00020	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  00023	85 c9		 test	 ecx, ecx
  00025	75 04		 jne	 SHORT $L340715
  00027	33 c0		 xor	 eax, eax
  00029	eb 08		 jmp	 SHORT $L340716
$L340715:
  0002b	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  0002e	2b c1		 sub	 eax, ecx
  00030	c1 f8 02	 sar	 eax, 2
$L340716:
  00033	3b f8		 cmp	 edi, eax
  00035	7d 55		 jge	 SHORT $L279996

; 3836 : 	{
; 3837 : 		ItemProp* pProp	= prj.GetItemProp( vSkills[i] );

  00037	8b 04 b9	 mov	 eax, DWORD PTR [ecx+edi*4]
  0003a	85 c0		 test	 eax, eax
  0003c	7c 2f		 jl	 SHORT $L340799
  0003e	3b c2		 cmp	 eax, edx
  00040	7d 2b		 jge	 SHORT $L340799
  00042	73 26		 jae	 SHORT $L279995
  00044	8b 0d 4c 02 00
	00		 mov	 ecx, DWORD PTR ?prj@@3VCProject@@A+588
  0004a	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]

; 3838 : 		if( pProp )

  0004d	85 c0		 test	 eax, eax
  0004f	74 19		 je	 SHORT $L279995

; 3839 : 			DoApplySkill( this, pProp, NULL );

  00051	6a 00		 push	 0
  00053	6a 00		 push	 0
  00055	6a 00		 push	 0
  00057	6a 00		 push	 0
  00059	6a 00		 push	 0
  0005b	50		 push	 eax
  0005c	56		 push	 esi
  0005d	8b ce		 mov	 ecx, esi
  0005f	e8 00 00 00 00	 call	 ?DoApplySkill@CCtrl@@QAEHPAV1@PAUItemProp@@PAUAddSkillProp@@_NHHH@Z ; CCtrl::DoApplySkill
  00064	8b 15 5c 02 00
	00		 mov	 edx, DWORD PTR ?prj@@3VCProject@@A+604
$L279995:

; 3835 : 	for( int i = 0; i < (int)( vSkills.size() ); i++ )

  0006a	47		 inc	 edi
  0006b	eb b3		 jmp	 SHORT $L279994

; 3836 : 	{
; 3837 : 		ItemProp* pProp	= prj.GetItemProp( vSkills[i] );

$L340799:
  0006d	50		 push	 eax
  0006e	52		 push	 edx
  0006f	6a 00		 push	 0
  00071	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BI@BEIFNGEL@GetItemProp?5range_error?$AA@
  00076	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@HMFGHCP@?$CFs?5min?3?$CFd?0?5max?3?$CFd?0?5index?3?$CFd?$AA@
  0007b	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error

; 3839 : 			DoApplySkill( this, pProp, NULL );

  00080	8b 15 5c 02 00
	00		 mov	 edx, DWORD PTR ?prj@@3VCProject@@A+604
  00086	83 c4 14	 add	 esp, 20			; 00000014H
  00089	47		 inc	 edi
  0008a	eb 94		 jmp	 SHORT $L279994
$L279996:
  0008c	5f		 pop	 edi
  0008d	5e		 pop	 esi
  0008e	5b		 pop	 ebx

; 3840 : 	}
; 3841 : }

  0008f	c2 04 00	 ret	 4
?ActiveCoupleBuff@CUser@@QAEXH@Z ENDP			; CUser::ActiveCoupleBuff
_TEXT	ENDS
PUBLIC	?GetUser@CUserMng@@QAEPAVCUser@@KK@Z		; CUserMng::GetUser
; Function compile flags: /Ogty
;	COMDAT ?GetUser@CUserMng@@QAEPAVCUser@@KK@Z
_TEXT	SEGMENT
_it$ = -4						; size = 4
_dpidCache$ = 8						; size = 4
_dpidUser$ = 12						; size = 4
?GetUser@CUserMng@@QAEPAVCUser@@KK@Z PROC NEAR		; CUserMng::GetUser, COMDAT
; _this$ = ecx

; 3957 : {

  00000	51		 push	 ecx
  00001	56		 push	 esi
  00002	8b f1		 mov	 esi, ecx

; 3958 : 	UNUSED_ALWAYS(dpidCache);
; 3959 : 
; 3960 : 	map<DWORD, CUser*>::iterator it = m_users.find( dpidUser );

  00004	8d 44 24 10	 lea	 eax, DWORD PTR _dpidUser$[esp+4]
  00008	50		 push	 eax
  00009	8d 4c 24 08	 lea	 ecx, DWORD PTR _it$[esp+12]
  0000d	51		 push	 ecx
  0000e	8d 4e 08	 lea	 ecx, DWORD PTR [esi+8]
  00011	e8 00 00 00 00	 call	 ?find@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::find

; 3961 : 	if( it != m_users.end() )

  00016	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  00019	8b 44 24 04	 mov	 eax, DWORD PTR _it$[esp+8]
  0001d	3b c1		 cmp	 eax, ecx
  0001f	5e		 pop	 esi
  00020	74 07		 je	 SHORT $L280124

; 3962 : 		return it->second;

  00022	8b 40 10	 mov	 eax, DWORD PTR [eax+16]

; 3965 : }

  00025	59		 pop	 ecx
  00026	c2 08 00	 ret	 8
$L280124:

; 3963 : 	else
; 3964 : 		return NULL;

  00029	33 c0		 xor	 eax, eax

; 3965 : }

  0002b	59		 pop	 ecx
  0002c	c2 08 00	 ret	 8
?GetUser@CUserMng@@QAEPAVCUser@@KK@Z ENDP		; CUserMng::GetUser
_TEXT	ENDS
PUBLIC	?ModifyMode@CUserMng@@QAEXK@Z			; CUserMng::ModifyMode
; Function compile flags: /Ogty
;	COMDAT ?ModifyMode@CUserMng@@QAEXK@Z
_TEXT	SEGMENT
_it$ = -4						; size = 4
_dwMode$ = 8						; size = 4
?ModifyMode@CUserMng@@QAEXK@Z PROC NEAR			; CUserMng::ModifyMode, COMDAT
; _this$ = ecx

; 4278 : {

  00000	51		 push	 ecx
  00001	56		 push	 esi
  00002	8b f1		 mov	 esi, ecx

; 4279 : 	map<DWORD, CUser*>::iterator it;
; 4280 : 	for( it = m_users.begin(); it != m_users.end(); ++it )

  00004	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  00007	8b 01		 mov	 eax, DWORD PTR [ecx]
  00009	3b c1		 cmp	 eax, ecx
  0000b	89 44 24 04	 mov	 DWORD PTR _it$[esp+8], eax
  0000f	74 4a		 je	 SHORT $L280237
  00011	57		 push	 edi
  00012	8b 7c 24 10	 mov	 edi, DWORD PTR _dwMode$[esp+8]
$L340914:

; 4281 : 	{
; 4282 : 		CUser* pUser = it->second;

  00016	8b 40 10	 mov	 eax, DWORD PTR [eax+16]

; 4283 : 		if( pUser->IsValid() == FALSE )

  00019	f6 40 04 01	 test	 BYTE PTR [eax+4], 1
  0001d	75 29		 jne	 SHORT $L280236
  0001f	8b 88 e8 16 00
	00		 mov	 ecx, DWORD PTR [eax+5864]
  00025	85 c9		 test	 ecx, ecx
  00027	74 1f		 je	 SHORT $L280236

; 4284 : 			continue;
; 4285 : 
; 4286 : 		if( pUser->m_dwAuthorization < AUTH_GAMEMASTER )

  00029	83 b8 48 06 00
	00 4c		 cmp	 DWORD PTR [eax+1608], 76 ; 0000004cH
  00030	73 16		 jae	 SHORT $L280236

; 4287 : 		{
; 4288 : 			pUser->SetMode( dwMode );

  00032	8b 90 44 02 00
	00		 mov	 edx, DWORD PTR [eax+580]
  00038	0b d7		 or	 edx, edi

; 4289 : 			AddModifyMode( pUser );

  0003a	50		 push	 eax
  0003b	8b ce		 mov	 ecx, esi
  0003d	89 90 44 02 00
	00		 mov	 DWORD PTR [eax+580], edx
  00043	e8 00 00 00 00	 call	 ?AddModifyMode@CUserMng@@QAEXPAVCUser@@@Z ; CUserMng::AddModifyMode
$L280236:
  00048	8d 4c 24 08	 lea	 ecx, DWORD PTR _it$[esp+12]
  0004c	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::const_iterator::_Inc
  00051	8b 44 24 08	 mov	 eax, DWORD PTR _it$[esp+12]
  00055	3b 46 0c	 cmp	 eax, DWORD PTR [esi+12]
  00058	75 bc		 jne	 SHORT $L340914
  0005a	5f		 pop	 edi
$L280237:
  0005b	5e		 pop	 esi

; 4290 : 		}
; 4291 : 	}
; 4292 : }

  0005c	59		 pop	 ecx
  0005d	c2 04 00	 ret	 4
?ModifyMode@CUserMng@@QAEXK@Z ENDP			; CUserMng::ModifyMode
_TEXT	ENDS
PUBLIC	?AddDlgEmoticon@CUserMng@@QAEXPAVCCtrl@@H@Z	; CUserMng::AddDlgEmoticon
EXTRN	_itoa:NEAR
; Function compile flags: /Ogty
;	COMDAT ?AddDlgEmoticon@CUserMng@@QAEXPAVCCtrl@@H@Z
_TEXT	SEGMENT
_szString$ = -68					; size = 32
_szNum$ = -36						; size = 32
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
_pCtrl$ = 8						; size = 4
_nIdx$ = 12						; size = 4
?AddDlgEmoticon@CUserMng@@QAEXPAVCCtrl@@H@Z PROC NEAR	; CUserMng::AddDlgEmoticon, COMDAT
; _this$ = ecx

; 4311 : {

  00000	83 ec 44	 sub	 esp, 68			; 00000044H
  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie

; 4312 : 	CHAR szString[32] = "!";
; 4313 : 	CHAR szNum[32];
; 4314 : 	itoa( nIdx, szNum, 10 );

  00008	8b 54 24 4c	 mov	 edx, DWORD PTR _nIdx$[esp+64]
  0000c	33 c4		 xor	 eax, esp
  0000e	89 44 24 40	 mov	 DWORD PTR __$ArrayPad$[esp+68], eax
  00012	33 c0		 xor	 eax, eax
  00014	89 44 24 02	 mov	 DWORD PTR _szString$[esp+70], eax
  00018	53		 push	 ebx
  00019	89 44 24 0a	 mov	 DWORD PTR _szString$[esp+78], eax
  0001d	55		 push	 ebp
  0001e	8b 6c 24 50	 mov	 ebp, DWORD PTR _pCtrl$[esp+72]
  00022	89 44 24 12	 mov	 DWORD PTR _szString$[esp+86], eax
  00026	56		 push	 esi
  00027	89 44 24 1a	 mov	 DWORD PTR _szString$[esp+94], eax
  0002b	57		 push	 edi
  0002c	89 44 24 22	 mov	 DWORD PTR _szString$[esp+102], eax
  00030	8b d9		 mov	 ebx, ecx
  00032	6a 0a		 push	 10			; 0000000aH
  00034	8d 4c 24 34	 lea	 ecx, DWORD PTR _szNum$[esp+88]
  00038	89 44 24 2a	 mov	 DWORD PTR _szString$[esp+110], eax
  0003c	51		 push	 ecx
  0003d	89 44 24 32	 mov	 DWORD PTR _szString$[esp+118], eax
  00041	52		 push	 edx
  00042	66 c7 44 24 1c
	21 00		 mov	 WORD PTR _szString$[esp+96], 33 ; 00000021H
  00049	66 89 44 24 3a	 mov	 WORD PTR _szString$[esp+126], ax
  0004e	e8 00 00 00 00	 call	 _itoa

; 4315 : 	strcat( szString, szNum );

  00053	8d 44 24 3c	 lea	 eax, DWORD PTR _szNum$[esp+96]
  00057	83 c4 0c	 add	 esp, 12			; 0000000cH
  0005a	8b d0		 mov	 edx, eax
  0005c	8d 64 24 00	 npad	 4
$L340987:
  00060	8a 08		 mov	 cl, BYTE PTR [eax]
  00062	40		 inc	 eax
  00063	84 c9		 test	 cl, cl
  00065	75 f9		 jne	 SHORT $L340987
  00067	8d 7c 24 10	 lea	 edi, DWORD PTR _szString$[esp+84]
  0006b	2b c2		 sub	 eax, edx
  0006d	4f		 dec	 edi
  0006e	8b ff		 npad	 2
$L340988:
  00070	8a 4f 01	 mov	 cl, BYTE PTR [edi+1]
  00073	47		 inc	 edi
  00074	84 c9		 test	 cl, cl
  00076	75 f8		 jne	 SHORT $L340988
  00078	8b c8		 mov	 ecx, eax
  0007a	c1 e9 02	 shr	 ecx, 2
  0007d	8b f2		 mov	 esi, edx
  0007f	f3 a5		 rep movsd
  00081	8b c8		 mov	 ecx, eax
  00083	83 e1 03	 and	 ecx, 3

; 4316 : 	AddChat( pCtrl, szString );

  00086	8d 44 24 10	 lea	 eax, DWORD PTR _szString$[esp+84]
  0008a	50		 push	 eax
  0008b	f3 a4		 rep movsb
  0008d	55		 push	 ebp
  0008e	8b cb		 mov	 ecx, ebx
  00090	e8 00 00 00 00	 call	 ?AddChat@CUserMng@@QAEXPAVCCtrl@@PBD@Z ; CUserMng::AddChat

; 4317 : }

  00095	8b 4c 24 50	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+84]
  00099	5f		 pop	 edi
  0009a	5e		 pop	 esi
  0009b	5d		 pop	 ebp
  0009c	5b		 pop	 ebx
  0009d	33 cc		 xor	 ecx, esp
  0009f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000a4	83 c4 44	 add	 esp, 68			; 00000044H
  000a7	c2 08 00	 ret	 8
?AddDlgEmoticon@CUserMng@@QAEXPAVCCtrl@@H@Z ENDP	; CUserMng::AddDlgEmoticon
_TEXT	ENDS
PUBLIC	?AddWorldShout@CUserMng@@QAEXPBD0UD3DXVECTOR3@@PAVCWorld@@@Z ; CUserMng::AddWorldShout
;	COMDAT xdata$x
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_network\misc\include\ar.h
xdata$x	SEGMENT
$T341027 DD	0ffffffffH
	DD	FLAT:$L340994
$T341024 DD	019930520H
	DD	01H
	DD	FLAT:$T341027
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
xdata$x	ENDS
;	COMDAT ?AddWorldShout@CUserMng@@QAEXPBD0UD3DXVECTOR3@@PAVCWorld@@@Z
_TEXT	SEGMENT
_uBlockSize$280501 = -16424				; size = 4
_arBlock$280498 = -16420				; size = 16404
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_szName$ = 8						; size = 4
_szShout$ = 12						; size = 4
_vPos$ = 16						; size = 12
_pWorld$ = 28						; size = 4
?AddWorldShout@CUserMng@@QAEXPBD0UD3DXVECTOR3@@PAVCWorld@@@Z PROC NEAR ; CUserMng::AddWorldShout, COMDAT
; _this$ = ecx

; 4460 : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?AddWorldShout@CUserMng@@QAEXPBD0UD3DXVECTOR3@@PAVCWorld@@@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	b8 1c 40 00 00	 mov	 eax, 16412		; 0000401cH
  00013	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0001a	e8 00 00 00 00	 call	 __chkstk
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00024	33 c4		 xor	 eax, esp
  00026	53		 push	 ebx
  00027	8b 9c 24 30 40
	00 00		 mov	 ebx, DWORD PTR _szName$[esp+16424]
  0002e	55		 push	 ebp
  0002f	8b ac 24 38 40
	00 00		 mov	 ebp, DWORD PTR _szShout$[esp+16428]
  00036	56		 push	 esi
  00037	8b b4 24 4c 40
	00 00		 mov	 esi, DWORD PTR _pWorld$[esp+16432]

; 4461 : 	if( pWorld )

  0003e	85 f6		 test	 esi, esi
  00040	57		 push	 edi
  00041	89 84 24 28 40
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+16440], eax
  00048	8b f9		 mov	 edi, ecx
  0004a	0f 84 dc 00 00
	00		 je	 $L280497

; 4462 : 	{
; 4463 : 		CAr arBlock;

  00050	6a 00		 push	 0
  00052	6a 00		 push	 0
  00054	8d 4c 24 1c	 lea	 ecx, DWORD PTR _arBlock$280498[esp+16448]
  00058	e8 00 00 00 00	 call	 ??0CAr@@QAE@PAXI@Z	; CAr::CAr

; 4464 : 		arBlock << NULL_ID << SNAPSHOTTYPE_SHOUT;

  0005d	6a 04		 push	 4
  0005f	8d 4c 24 18	 lea	 ecx, DWORD PTR _arBlock$280498[esp+16444]
  00063	c7 84 24 38 40
	00 00 00 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+16452], 0
  0006e	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00073	8b 44 24 1c	 mov	 eax, DWORD PTR _arBlock$280498[esp+16448]
  00077	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [eax], -1
  0007d	8b 54 24 1c	 mov	 edx, DWORD PTR _arBlock$280498[esp+16448]
  00081	83 c2 04	 add	 edx, 4
  00084	6a 02		 push	 2
  00086	8d 4c 24 18	 lea	 ecx, DWORD PTR _arBlock$280498[esp+16444]
  0008a	89 54 24 20	 mov	 DWORD PTR _arBlock$280498[esp+16452], edx
  0008e	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00093	8b 4c 24 1c	 mov	 ecx, DWORD PTR _arBlock$280498[esp+16448]
  00097	66 c7 01 d0 00	 mov	 WORD PTR [ecx], 208	; 000000d0H
  0009c	8b 44 24 1c	 mov	 eax, DWORD PTR _arBlock$280498[esp+16448]
  000a0	83 c0 02	 add	 eax, 2

; 4465 : 		arBlock << NULL_ID;

  000a3	6a 04		 push	 4
  000a5	8d 4c 24 18	 lea	 ecx, DWORD PTR _arBlock$280498[esp+16444]
  000a9	89 44 24 20	 mov	 DWORD PTR _arBlock$280498[esp+16452], eax
  000ad	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000b2	8b 54 24 1c	 mov	 edx, DWORD PTR _arBlock$280498[esp+16448]
  000b6	c7 02 ff ff ff
	ff		 mov	 DWORD PTR [edx], -1
  000bc	83 44 24 1c 04	 add	 DWORD PTR _arBlock$280498[esp+16448], 4

; 4466 : 		arBlock.WriteString( szName );

  000c1	53		 push	 ebx
  000c2	8d 4c 24 18	 lea	 ecx, DWORD PTR _arBlock$280498[esp+16444]
  000c6	e8 00 00 00 00	 call	 ?WriteString@CAr@@QAEXPBD@Z ; CAr::WriteString

; 4467 : 		arBlock.WriteString( szShout );

  000cb	55		 push	 ebp
  000cc	8d 4c 24 18	 lea	 ecx, DWORD PTR _arBlock$280498[esp+16444]
  000d0	e8 00 00 00 00	 call	 ?WriteString@CAr@@QAEXPBD@Z ; CAr::WriteString

; 4468 : #if __VER >= 12 // __LORD
; 4469 : 		arBlock << (DWORD)0xffff99cc;

  000d5	6a 04		 push	 4
  000d7	8d 4c 24 18	 lea	 ecx, DWORD PTR _arBlock$280498[esp+16444]
  000db	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000e0	8b 44 24 1c	 mov	 eax, DWORD PTR _arBlock$280498[esp+16448]
  000e4	c7 00 cc 99 ff
	ff		 mov	 DWORD PTR [eax], -26164	; ffff99ccH
  000ea	83 44 24 1c 04	 add	 DWORD PTR _arBlock$280498[esp+16448], 4

; 4470 : #endif	// __LORD
; 4471 : 		GETBLOCK( arBlock, lpBlock, uBlockSize );

  000ef	8d 4c 24 10	 lea	 ecx, DWORD PTR _uBlockSize$280501[esp+16440]
  000f3	51		 push	 ecx
  000f4	8d 4c 24 18	 lea	 ecx, DWORD PTR _arBlock$280498[esp+16444]
  000f8	e8 00 00 00 00	 call	 ?GetBuffer@CAr@@QAEPAEPAH@Z ; CAr::GetBuffer

; 4472 : 		
; 4473 : 		AddBlock( pWorld, vPos, 0xff, lpBlock, uBlockSize );

  000fd	8b 54 24 10	 mov	 edx, DWORD PTR _uBlockSize$280501[esp+16440]
  00101	52		 push	 edx
  00102	50		 push	 eax
  00103	68 ff 00 00 00	 push	 255			; 000000ffH
  00108	8d 84 24 50 40
	00 00		 lea	 eax, DWORD PTR _vPos$[esp+16448]
  0010f	50		 push	 eax
  00110	56		 push	 esi
  00111	8b cf		 mov	 ecx, edi
  00113	e8 00 00 00 00	 call	 ?AddBlock@CUserMng@@QAEXPAVCWorld@@ABUD3DXVECTOR3@@HPAEK@Z ; CUserMng::AddBlock

; 4474 : 	}		

  00118	8d 4c 24 14	 lea	 ecx, DWORD PTR _arBlock$280498[esp+16440]
  0011c	c7 84 24 34 40
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+16448], -1
  00127	e8 00 00 00 00	 call	 ??1CAr@@QAE@XZ		; CAr::~CAr
$L280497:

; 4475 : }

  0012c	8b 8c 24 2c 40
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+16440]
  00133	5f		 pop	 edi
  00134	5e		 pop	 esi
  00135	5d		 pop	 ebp
  00136	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0013d	8b 8c 24 1c 40
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+16428]
  00144	5b		 pop	 ebx
  00145	33 cc		 xor	 ecx, esp
  00147	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0014c	81 c4 28 40 00
	00		 add	 esp, 16424		; 00004028H
  00152	c2 18 00	 ret	 24			; 00000018H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L340994:
  00000	8d 8d dc bf ff
	ff		 lea	 ecx, DWORD PTR _arBlock$280498[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CAr@@QAE@XZ		; CAr::~CAr
__ehhandler$?AddWorldShout@CUserMng@@QAEXPBD0UD3DXVECTOR3@@PAVCWorld@@@Z:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T341024
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?AddWorldShout@CUserMng@@QAEXPBD0UD3DXVECTOR3@@PAVCWorld@@@Z ENDP ; CUserMng::AddWorldShout
PUBLIC	?AddWorldCreateSfxObj@CUserMng@@QAEXKMMMHK@Z	; CUserMng::AddWorldCreateSfxObj
;	COMDAT xdata$x
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_network\misc\include\ar.h
xdata$x	SEGMENT
$T341072 DD	0ffffffffH
	DD	FLAT:$L341034
$T341069 DD	019930520H
	DD	01H
	DD	FLAT:$T341072
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
xdata$x	ENDS
;	COMDAT ?AddWorldCreateSfxObj@CUserMng@@QAEXKMMMHK@Z
_TEXT	SEGMENT
_uBlockSize$ = -16424					; size = 4
_arBlock$ = -16420					; size = 16404
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_dwSfxObj$ = 8						; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_z$ = 20						; size = 4
_bFlag$ = 24						; size = 4
_dwWorldId$ = 28					; size = 4
?AddWorldCreateSfxObj@CUserMng@@QAEXKMMMHK@Z PROC NEAR	; CUserMng::AddWorldCreateSfxObj, COMDAT
; _this$ = ecx

; 5093 : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?AddWorldCreateSfxObj@CUserMng@@QAEXKMMMHK@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	b8 1c 40 00 00	 mov	 eax, 16412		; 0000401cH
  00013	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0001a	e8 00 00 00 00	 call	 __chkstk
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00024	33 c4		 xor	 eax, esp
  00026	56		 push	 esi
  00027	57		 push	 edi

; 5094 : 	CAr arBlock;

  00028	6a 00		 push	 0
  0002a	8b f1		 mov	 esi, ecx
  0002c	6a 00		 push	 0
  0002e	8d 4c 24 14	 lea	 ecx, DWORD PTR _arBlock$[esp+16440]
  00032	89 84 24 28 40
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+16440], eax
  00039	e8 00 00 00 00	 call	 ??0CAr@@QAE@PAXI@Z	; CAr::CAr

; 5095 : 	arBlock << NULL_ID << SNAPSHOTTYPE_CREATESFXOBJ << dwSfxObj << x << y << z << bFlag ;

  0003e	bf 04 00 00 00	 mov	 edi, 4
  00043	57		 push	 edi
  00044	8d 4c 24 10	 lea	 ecx, DWORD PTR _arBlock$[esp+16436]
  00048	c7 84 24 30 40
	00 00 00 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+16444], 0
  00053	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00058	8b 44 24 14	 mov	 eax, DWORD PTR _arBlock$[esp+16440]
  0005c	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [eax], -1
  00062	8b 54 24 14	 mov	 edx, DWORD PTR _arBlock$[esp+16440]
  00066	03 d7		 add	 edx, edi
  00068	6a 02		 push	 2
  0006a	8d 4c 24 10	 lea	 ecx, DWORD PTR _arBlock$[esp+16436]
  0006e	89 54 24 18	 mov	 DWORD PTR _arBlock$[esp+16444], edx
  00072	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00077	8b 4c 24 14	 mov	 ecx, DWORD PTR _arBlock$[esp+16440]
  0007b	66 c7 01 0f 00	 mov	 WORD PTR [ecx], 15	; 0000000fH
  00080	8b 44 24 14	 mov	 eax, DWORD PTR _arBlock$[esp+16440]
  00084	83 c0 02	 add	 eax, 2
  00087	57		 push	 edi
  00088	8d 4c 24 10	 lea	 ecx, DWORD PTR _arBlock$[esp+16436]
  0008c	89 44 24 18	 mov	 DWORD PTR _arBlock$[esp+16444], eax
  00090	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00095	8b 54 24 14	 mov	 edx, DWORD PTR _arBlock$[esp+16440]
  00099	8b 84 24 34 40
	00 00		 mov	 eax, DWORD PTR _dwSfxObj$[esp+16428]
  000a0	89 02		 mov	 DWORD PTR [edx], eax
  000a2	01 7c 24 14	 add	 DWORD PTR _arBlock$[esp+16440], edi
  000a6	57		 push	 edi
  000a7	8d 4c 24 10	 lea	 ecx, DWORD PTR _arBlock$[esp+16436]
  000ab	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000b0	d9 84 24 38 40
	00 00		 fld	 DWORD PTR _x$[esp+16428]
  000b7	8b 4c 24 14	 mov	 ecx, DWORD PTR _arBlock$[esp+16440]
  000bb	d9 19		 fstp	 DWORD PTR [ecx]
  000bd	8b 54 24 14	 mov	 edx, DWORD PTR _arBlock$[esp+16440]
  000c1	03 d7		 add	 edx, edi
  000c3	57		 push	 edi
  000c4	8d 4c 24 10	 lea	 ecx, DWORD PTR _arBlock$[esp+16436]
  000c8	89 54 24 18	 mov	 DWORD PTR _arBlock$[esp+16444], edx
  000cc	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000d1	d9 84 24 3c 40
	00 00		 fld	 DWORD PTR _y$[esp+16428]
  000d8	8b 54 24 14	 mov	 edx, DWORD PTR _arBlock$[esp+16440]
  000dc	d9 1a		 fstp	 DWORD PTR [edx]
  000de	8b 44 24 14	 mov	 eax, DWORD PTR _arBlock$[esp+16440]
  000e2	03 c7		 add	 eax, edi
  000e4	57		 push	 edi
  000e5	8d 4c 24 10	 lea	 ecx, DWORD PTR _arBlock$[esp+16436]
  000e9	89 44 24 18	 mov	 DWORD PTR _arBlock$[esp+16444], eax
  000ed	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000f2	d9 84 24 40 40
	00 00		 fld	 DWORD PTR _z$[esp+16428]
  000f9	8b 44 24 14	 mov	 eax, DWORD PTR _arBlock$[esp+16440]
  000fd	d9 18		 fstp	 DWORD PTR [eax]
  000ff	8b 4c 24 14	 mov	 ecx, DWORD PTR _arBlock$[esp+16440]
  00103	03 cf		 add	 ecx, edi
  00105	89 4c 24 14	 mov	 DWORD PTR _arBlock$[esp+16440], ecx
  00109	57		 push	 edi
  0010a	8d 4c 24 10	 lea	 ecx, DWORD PTR _arBlock$[esp+16436]
  0010e	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00113	8b 4c 24 14	 mov	 ecx, DWORD PTR _arBlock$[esp+16440]
  00117	8b 94 24 44 40
	00 00		 mov	 edx, DWORD PTR _bFlag$[esp+16428]
  0011e	89 11		 mov	 DWORD PTR [ecx], edx
  00120	8b 54 24 14	 mov	 edx, DWORD PTR _arBlock$[esp+16440]
  00124	03 d7		 add	 edx, edi

; 5096 : 	GETBLOCK( arBlock, lpBlock, uBlockSize );

  00126	8d 44 24 08	 lea	 eax, DWORD PTR _uBlockSize$[esp+16432]
  0012a	89 54 24 14	 mov	 DWORD PTR _arBlock$[esp+16440], edx
  0012e	50		 push	 eax
  0012f	8d 4c 24 10	 lea	 ecx, DWORD PTR _arBlock$[esp+16436]
  00133	e8 00 00 00 00	 call	 ?GetBuffer@CAr@@QAEPAEPAH@Z ; CAr::GetBuffer

; 5097 : 	CWorld* pWorld	= g_WorldMng.GetWorld( dwWorldId );

  00138	8b 8c 24 48 40
	00 00		 mov	 ecx, DWORD PTR _dwWorldId$[esp+16428]
  0013f	51		 push	 ecx
  00140	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_WorldMng@@3VCWorldMng@@A
  00145	8b f8		 mov	 edi, eax
  00147	e8 00 00 00 00	 call	 ?GetWorld@CWorldMng@@QAEPAVCWorld@@K@Z ; CWorldMng::GetWorld

; 5098 : 	AddBlockNoLock( lpBlock, uBlockSize, pWorld );

  0014c	8b 54 24 08	 mov	 edx, DWORD PTR _uBlockSize$[esp+16432]
  00150	50		 push	 eax
  00151	52		 push	 edx
  00152	57		 push	 edi
  00153	8b ce		 mov	 ecx, esi
  00155	e8 00 00 00 00	 call	 ?AddBlockNoLock@CUserMng@@QAEXPAEKPAVCWorld@@@Z ; CUserMng::AddBlockNoLock

; 5099 : }

  0015a	8d 4c 24 0c	 lea	 ecx, DWORD PTR _arBlock$[esp+16432]
  0015e	c7 84 24 2c 40
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+16440], -1
  00169	e8 00 00 00 00	 call	 ??1CAr@@QAE@XZ		; CAr::~CAr
  0016e	8b 8c 24 24 40
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+16432]
  00175	5f		 pop	 edi
  00176	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0017d	8b 8c 24 1c 40
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+16428]
  00184	5e		 pop	 esi
  00185	33 cc		 xor	 ecx, esp
  00187	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0018c	81 c4 28 40 00
	00		 add	 esp, 16424		; 00004028H
  00192	c2 18 00	 ret	 24			; 00000018H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L341034:
  00000	8d 8d dc bf ff
	ff		 lea	 ecx, DWORD PTR _arBlock$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CAr@@QAE@XZ		; CAr::~CAr
__ehhandler$?AddWorldCreateSfxObj@CUserMng@@QAEXKMMMHK@Z:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T341069
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?AddWorldCreateSfxObj@CUserMng@@QAEXKMMMHK@Z ENDP	; CUserMng::AddWorldCreateSfxObj
PUBLIC	?AddSetLocalEvent@CUserMng@@QAEXFE@Z		; CUserMng::AddSetLocalEvent
;	COMDAT xdata$x
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_network\misc\include\ar.h
xdata$x	SEGMENT
$T341108 DD	0ffffffffH
	DD	FLAT:$L341079
$T341105 DD	019930520H
	DD	01H
	DD	FLAT:$T341108
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
xdata$x	ENDS
;	COMDAT ?AddSetLocalEvent@CUserMng@@QAEXFE@Z
_TEXT	SEGMENT
_uBufSize$ = -16424					; size = 4
_ar$ = -16420						; size = 16404
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_id$ = 8						; size = 2
_nState$ = 12						; size = 1
?AddSetLocalEvent@CUserMng@@QAEXFE@Z PROC NEAR		; CUserMng::AddSetLocalEvent, COMDAT
; _this$ = ecx

; 5222 : {

  00000	6a ff		 push	 -1
  00002	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00008	68 00 00 00 00	 push	 __ehhandler$?AddSetLocalEvent@CUserMng@@QAEXFE@Z
  0000d	50		 push	 eax
  0000e	b8 1c 40 00 00	 mov	 eax, 16412		; 0000401cH
  00013	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0001a	e8 00 00 00 00	 call	 __chkstk
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00024	33 c4		 xor	 eax, esp
  00026	56		 push	 esi

; 5223 : 	CAr ar;

  00027	6a 00		 push	 0
  00029	8b f1		 mov	 esi, ecx
  0002b	89 84 24 20 40
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+16432], eax
  00032	6a 00		 push	 0
  00034	8d 4c 24 10	 lea	 ecx, DWORD PTR _ar$[esp+16436]
  00038	e8 00 00 00 00	 call	 ??0CAr@@QAE@PAXI@Z	; CAr::CAr

; 5224 : 	ar << NULL_ID << SNAPSHOTTYPE_SET_LOCAL_EVENT;

  0003d	6a 04		 push	 4
  0003f	8d 4c 24 0c	 lea	 ecx, DWORD PTR _ar$[esp+16432]
  00043	c7 84 24 2c 40
	00 00 00 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+16440], 0
  0004e	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00053	8b 44 24 10	 mov	 eax, DWORD PTR _ar$[esp+16436]
  00057	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [eax], -1
  0005d	8b 54 24 10	 mov	 edx, DWORD PTR _ar$[esp+16436]
  00061	83 c2 04	 add	 edx, 4
  00064	6a 02		 push	 2
  00066	8d 4c 24 0c	 lea	 ecx, DWORD PTR _ar$[esp+16432]
  0006a	89 54 24 14	 mov	 DWORD PTR _ar$[esp+16440], edx
  0006e	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00073	8b 4c 24 10	 mov	 ecx, DWORD PTR _ar$[esp+16436]
  00077	66 c7 01 b3 00	 mov	 WORD PTR [ecx], 179	; 000000b3H
  0007c	8b 44 24 10	 mov	 eax, DWORD PTR _ar$[esp+16436]
  00080	83 c0 02	 add	 eax, 2

; 5225 : 	ar << id << nState;

  00083	6a 02		 push	 2
  00085	8d 4c 24 0c	 lea	 ecx, DWORD PTR _ar$[esp+16432]
  00089	89 44 24 14	 mov	 DWORD PTR _ar$[esp+16440], eax
  0008d	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00092	8b 54 24 10	 mov	 edx, DWORD PTR _ar$[esp+16436]
  00096	66 8b 84 24 30
	40 00 00	 mov	 ax, WORD PTR _id$[esp+16424]
  0009e	66 89 02	 mov	 WORD PTR [edx], ax
  000a1	83 44 24 10 02	 add	 DWORD PTR _ar$[esp+16436], 2
  000a6	6a 01		 push	 1
  000a8	8d 4c 24 0c	 lea	 ecx, DWORD PTR _ar$[esp+16432]
  000ac	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000b1	8b 4c 24 10	 mov	 ecx, DWORD PTR _ar$[esp+16436]
  000b5	8a 94 24 34 40
	00 00		 mov	 dl, BYTE PTR _nState$[esp+16424]
  000bc	88 11		 mov	 BYTE PTR [ecx], dl
  000be	8b 54 24 10	 mov	 edx, DWORD PTR _ar$[esp+16436]

; 5226 : 	GETBLOCK( ar, lpBuf, uBufSize );

  000c2	8d 44 24 04	 lea	 eax, DWORD PTR _uBufSize$[esp+16428]
  000c6	42		 inc	 edx
  000c7	50		 push	 eax
  000c8	8d 4c 24 0c	 lea	 ecx, DWORD PTR _ar$[esp+16432]
  000cc	89 54 24 14	 mov	 DWORD PTR _ar$[esp+16440], edx
  000d0	e8 00 00 00 00	 call	 ?GetBuffer@CAr@@QAEPAEPAH@Z ; CAr::GetBuffer

; 5227 : 
; 5228 : 	AddBlock( lpBuf, uBufSize );	// all

  000d5	8b 4c 24 04	 mov	 ecx, DWORD PTR _uBufSize$[esp+16428]
  000d9	51		 push	 ecx
  000da	50		 push	 eax
  000db	8b ce		 mov	 ecx, esi
  000dd	e8 00 00 00 00	 call	 ?AddBlock@CUserMng@@QAEXPAEK@Z ; CUserMng::AddBlock

; 5229 : }

  000e2	8d 4c 24 08	 lea	 ecx, DWORD PTR _ar$[esp+16428]
  000e6	c7 84 24 28 40
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+16436], -1
  000f1	e8 00 00 00 00	 call	 ??1CAr@@QAE@XZ		; CAr::~CAr
  000f6	8b 8c 24 20 40
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+16428]
  000fd	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00104	8b 8c 24 1c 40
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+16428]
  0010b	5e		 pop	 esi
  0010c	33 cc		 xor	 ecx, esp
  0010e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00113	81 c4 28 40 00
	00		 add	 esp, 16424		; 00004028H
  00119	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L341079:
  00000	8d 8d dc bf ff
	ff		 lea	 ecx, DWORD PTR _ar$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CAr@@QAE@XZ		; CAr::~CAr
__ehhandler$?AddSetLocalEvent@CUserMng@@QAEXFE@Z:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T341105
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?AddSetLocalEvent@CUserMng@@QAEXFE@Z ENDP		; CUserMng::AddSetLocalEvent
PUBLIC	?AddGameRate@CUserMng@@QAEXME@Z			; CUserMng::AddGameRate
;	COMDAT xdata$x
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_network\misc\include\ar.h
xdata$x	SEGMENT
$T341139 DD	0ffffffffH
	DD	FLAT:$L341115
$T341136 DD	019930520H
	DD	01H
	DD	FLAT:$T341139
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
xdata$x	ENDS
;	COMDAT ?AddGameRate@CUserMng@@QAEXME@Z
_TEXT	SEGMENT
_uBufSize$ = -16424					; size = 4
_ar$ = -16420						; size = 16404
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_fRate$ = 8						; size = 4
_nFlag$ = 12						; size = 1
?AddGameRate@CUserMng@@QAEXME@Z PROC NEAR		; CUserMng::AddGameRate, COMDAT
; _this$ = ecx

; 5232 : {

  00000	6a ff		 push	 -1
  00002	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00008	68 00 00 00 00	 push	 __ehhandler$?AddGameRate@CUserMng@@QAEXME@Z
  0000d	50		 push	 eax
  0000e	b8 1c 40 00 00	 mov	 eax, 16412		; 0000401cH
  00013	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0001a	e8 00 00 00 00	 call	 __chkstk
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00024	33 c4		 xor	 eax, esp
  00026	56		 push	 esi

; 5233 : 	CAr ar;

  00027	6a 00		 push	 0
  00029	8b f1		 mov	 esi, ecx
  0002b	89 84 24 20 40
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+16432], eax
  00032	6a 00		 push	 0
  00034	8d 4c 24 10	 lea	 ecx, DWORD PTR _ar$[esp+16436]
  00038	e8 00 00 00 00	 call	 ??0CAr@@QAE@PAXI@Z	; CAr::CAr

; 5234 : 	ar << NULL_ID << SNAPSHOTTYPE_GAMERATE;

  0003d	6a 04		 push	 4
  0003f	8d 4c 24 0c	 lea	 ecx, DWORD PTR _ar$[esp+16432]
  00043	c7 84 24 2c 40
	00 00 00 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+16440], 0
  0004e	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00053	8b 44 24 10	 mov	 eax, DWORD PTR _ar$[esp+16436]
  00057	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [eax], -1
  0005d	83 44 24 10 04	 add	 DWORD PTR _ar$[esp+16436], 4
  00062	6a 02		 push	 2
  00064	8d 4c 24 0c	 lea	 ecx, DWORD PTR _ar$[esp+16432]
  00068	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0006d	8b 4c 24 10	 mov	 ecx, DWORD PTR _ar$[esp+16436]
  00071	66 c7 01 2e 00	 mov	 WORD PTR [ecx], 46	; 0000002eH
  00076	8b 54 24 10	 mov	 edx, DWORD PTR _ar$[esp+16436]
  0007a	83 c2 02	 add	 edx, 2

; 5235 : 	ar << fRate;

  0007d	6a 04		 push	 4
  0007f	8d 4c 24 0c	 lea	 ecx, DWORD PTR _ar$[esp+16432]
  00083	89 54 24 14	 mov	 DWORD PTR _ar$[esp+16440], edx
  00087	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0008c	d9 84 24 30 40
	00 00		 fld	 DWORD PTR _fRate$[esp+16424]
  00093	8b 54 24 10	 mov	 edx, DWORD PTR _ar$[esp+16436]
  00097	d9 1a		 fstp	 DWORD PTR [edx]
  00099	8b 44 24 10	 mov	 eax, DWORD PTR _ar$[esp+16436]
  0009d	83 c0 04	 add	 eax, 4

; 5236 : 	ar << nFlag;

  000a0	6a 01		 push	 1
  000a2	8d 4c 24 0c	 lea	 ecx, DWORD PTR _ar$[esp+16432]
  000a6	89 44 24 14	 mov	 DWORD PTR _ar$[esp+16440], eax
  000aa	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000af	8b 44 24 10	 mov	 eax, DWORD PTR _ar$[esp+16436]
  000b3	8a 8c 24 34 40
	00 00		 mov	 cl, BYTE PTR _nFlag$[esp+16424]
  000ba	88 08		 mov	 BYTE PTR [eax], cl
  000bc	8b 4c 24 10	 mov	 ecx, DWORD PTR _ar$[esp+16436]
  000c0	41		 inc	 ecx

; 5237 : 	GETBLOCK( ar, lpBuf, uBufSize );

  000c1	8d 54 24 04	 lea	 edx, DWORD PTR _uBufSize$[esp+16428]
  000c5	89 4c 24 10	 mov	 DWORD PTR _ar$[esp+16436], ecx
  000c9	52		 push	 edx
  000ca	8d 4c 24 0c	 lea	 ecx, DWORD PTR _ar$[esp+16432]
  000ce	e8 00 00 00 00	 call	 ?GetBuffer@CAr@@QAEPAEPAH@Z ; CAr::GetBuffer

; 5238 : 	
; 5239 : 	AddBlock( lpBuf, uBufSize );	// all

  000d3	8b 4c 24 04	 mov	 ecx, DWORD PTR _uBufSize$[esp+16428]
  000d7	51		 push	 ecx
  000d8	50		 push	 eax
  000d9	8b ce		 mov	 ecx, esi
  000db	e8 00 00 00 00	 call	 ?AddBlock@CUserMng@@QAEXPAEK@Z ; CUserMng::AddBlock

; 5240 : }

  000e0	8d 4c 24 08	 lea	 ecx, DWORD PTR _ar$[esp+16428]
  000e4	c7 84 24 28 40
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+16436], -1
  000ef	e8 00 00 00 00	 call	 ??1CAr@@QAE@XZ		; CAr::~CAr
  000f4	8b 8c 24 20 40
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+16428]
  000fb	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00102	8b 8c 24 1c 40
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+16428]
  00109	5e		 pop	 esi
  0010a	33 cc		 xor	 ecx, esp
  0010c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00111	81 c4 28 40 00
	00		 add	 esp, 16424		; 00004028H
  00117	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L341115:
  00000	8d 8d dc bf ff
	ff		 lea	 ecx, DWORD PTR _ar$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CAr@@QAE@XZ		; CAr::~CAr
__ehhandler$?AddGameRate@CUserMng@@QAEXME@Z:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T341136
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?AddGameRate@CUserMng@@QAEXME@Z ENDP			; CUserMng::AddGameRate
PUBLIC	?AddChangeFace@CUserMng@@QAEXKK@Z		; CUserMng::AddChangeFace
;	COMDAT xdata$x
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_network\misc\include\ar.h
xdata$x	SEGMENT
$T341170 DD	0ffffffffH
	DD	FLAT:$L341146
$T341167 DD	019930520H
	DD	01H
	DD	FLAT:$T341170
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
xdata$x	ENDS
;	COMDAT ?AddChangeFace@CUserMng@@QAEXKK@Z
_TEXT	SEGMENT
_uBufSize$ = -16424					; size = 4
_ar$ = -16420						; size = 16404
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_uidPlayer$ = 8						; size = 4
_dwFace$ = 12						; size = 4
?AddChangeFace@CUserMng@@QAEXKK@Z PROC NEAR		; CUserMng::AddChangeFace, COMDAT
; _this$ = ecx

; 5243 : {

  00000	6a ff		 push	 -1
  00002	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00008	68 00 00 00 00	 push	 __ehhandler$?AddChangeFace@CUserMng@@QAEXKK@Z
  0000d	50		 push	 eax
  0000e	b8 1c 40 00 00	 mov	 eax, 16412		; 0000401cH
  00013	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0001a	e8 00 00 00 00	 call	 __chkstk
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00024	33 c4		 xor	 eax, esp
  00026	56		 push	 esi

; 5244 : 	CAr ar;

  00027	6a 00		 push	 0
  00029	8b f1		 mov	 esi, ecx
  0002b	89 84 24 20 40
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+16432], eax
  00032	6a 00		 push	 0
  00034	8d 4c 24 10	 lea	 ecx, DWORD PTR _ar$[esp+16436]
  00038	e8 00 00 00 00	 call	 ??0CAr@@QAE@PAXI@Z	; CAr::CAr

; 5245 : 	ar << NULL_ID << SNAPSHOTTYPE_CHANGEFACE;

  0003d	6a 04		 push	 4
  0003f	8d 4c 24 0c	 lea	 ecx, DWORD PTR _ar$[esp+16432]
  00043	c7 84 24 2c 40
	00 00 00 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+16440], 0
  0004e	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00053	8b 44 24 10	 mov	 eax, DWORD PTR _ar$[esp+16436]
  00057	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [eax], -1
  0005d	8b 54 24 10	 mov	 edx, DWORD PTR _ar$[esp+16436]
  00061	83 c2 04	 add	 edx, 4
  00064	6a 02		 push	 2
  00066	8d 4c 24 0c	 lea	 ecx, DWORD PTR _ar$[esp+16432]
  0006a	89 54 24 14	 mov	 DWORD PTR _ar$[esp+16440], edx
  0006e	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00073	8b 4c 24 10	 mov	 ecx, DWORD PTR _ar$[esp+16436]
  00077	66 c7 01 4d 00	 mov	 WORD PTR [ecx], 77	; 0000004dH
  0007c	8b 44 24 10	 mov	 eax, DWORD PTR _ar$[esp+16436]
  00080	83 c0 02	 add	 eax, 2

; 5246 : 	ar << uidPlayer << dwFace;

  00083	6a 04		 push	 4
  00085	8d 4c 24 0c	 lea	 ecx, DWORD PTR _ar$[esp+16432]
  00089	89 44 24 14	 mov	 DWORD PTR _ar$[esp+16440], eax
  0008d	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00092	8b 54 24 10	 mov	 edx, DWORD PTR _ar$[esp+16436]
  00096	8b 84 24 30 40
	00 00		 mov	 eax, DWORD PTR _uidPlayer$[esp+16424]
  0009d	89 02		 mov	 DWORD PTR [edx], eax
  0009f	83 44 24 10 04	 add	 DWORD PTR _ar$[esp+16436], 4
  000a4	6a 04		 push	 4
  000a6	8d 4c 24 0c	 lea	 ecx, DWORD PTR _ar$[esp+16432]
  000aa	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000af	8b 4c 24 10	 mov	 ecx, DWORD PTR _ar$[esp+16436]
  000b3	8b 94 24 34 40
	00 00		 mov	 edx, DWORD PTR _dwFace$[esp+16424]
  000ba	89 11		 mov	 DWORD PTR [ecx], edx
  000bc	8b 54 24 10	 mov	 edx, DWORD PTR _ar$[esp+16436]

; 5247 : 	GETBLOCK( ar, lpBuf, uBufSize );

  000c0	8d 44 24 04	 lea	 eax, DWORD PTR _uBufSize$[esp+16428]
  000c4	83 c2 04	 add	 edx, 4
  000c7	50		 push	 eax
  000c8	8d 4c 24 0c	 lea	 ecx, DWORD PTR _ar$[esp+16432]
  000cc	89 54 24 14	 mov	 DWORD PTR _ar$[esp+16440], edx
  000d0	e8 00 00 00 00	 call	 ?GetBuffer@CAr@@QAEPAEPAH@Z ; CAr::GetBuffer

; 5248 : 
; 5249 : 	AddBlock( lpBuf, uBufSize );	// all

  000d5	8b 4c 24 04	 mov	 ecx, DWORD PTR _uBufSize$[esp+16428]
  000d9	51		 push	 ecx
  000da	50		 push	 eax
  000db	8b ce		 mov	 ecx, esi
  000dd	e8 00 00 00 00	 call	 ?AddBlock@CUserMng@@QAEXPAEK@Z ; CUserMng::AddBlock

; 5250 : }

  000e2	8d 4c 24 08	 lea	 ecx, DWORD PTR _ar$[esp+16428]
  000e6	c7 84 24 28 40
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+16436], -1
  000f1	e8 00 00 00 00	 call	 ??1CAr@@QAE@XZ		; CAr::~CAr
  000f6	8b 8c 24 20 40
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+16428]
  000fd	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00104	8b 8c 24 1c 40
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+16428]
  0010b	5e		 pop	 esi
  0010c	33 cc		 xor	 ecx, esp
  0010e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00113	81 c4 28 40 00
	00		 add	 esp, 16424		; 00004028H
  00119	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L341146:
  00000	8d 8d dc bf ff
	ff		 lea	 ecx, DWORD PTR _ar$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CAr@@QAE@XZ		; CAr::~CAr
__ehhandler$?AddChangeFace@CUserMng@@QAEXKK@Z:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T341167
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?AddChangeFace@CUserMng@@QAEXKK@Z ENDP			; CUserMng::AddChangeFace
PUBLIC	?AddSchoolReport@CUserMng@@QAEXPAU_SCHOOL_ENTRY@@F@Z ; CUserMng::AddSchoolReport
;	COMDAT xdata$x
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_network\misc\include\ar.h
xdata$x	SEGMENT
$T341204 DD	0ffffffffH
	DD	FLAT:$L341177
$T341201 DD	019930520H
	DD	01H
	DD	FLAT:$T341204
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
xdata$x	ENDS
;	COMDAT ?AddSchoolReport@CUserMng@@QAEXPAU_SCHOOL_ENTRY@@F@Z
_TEXT	SEGMENT
_uBufSize$ = -16424					; size = 4
_ar$ = -16420						; size = 16404
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_pSchool$ = 8						; size = 4
_nElapse$ = 12						; size = 2
?AddSchoolReport@CUserMng@@QAEXPAU_SCHOOL_ENTRY@@F@Z PROC NEAR ; CUserMng::AddSchoolReport, COMDAT
; _this$ = ecx

; 5253 : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?AddSchoolReport@CUserMng@@QAEXPAU_SCHOOL_ENTRY@@F@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	b8 1c 40 00 00	 mov	 eax, 16412		; 0000401cH
  00013	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0001a	e8 00 00 00 00	 call	 __chkstk
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00024	33 c4		 xor	 eax, esp
  00026	56		 push	 esi
  00027	57		 push	 edi
  00028	8b bc 24 34 40
	00 00		 mov	 edi, DWORD PTR _pSchool$[esp+16428]

; 5254 : 	CAr ar;

  0002f	6a 00		 push	 0
  00031	8b f1		 mov	 esi, ecx
  00033	89 84 24 24 40
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+16436], eax
  0003a	6a 00		 push	 0
  0003c	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  00040	e8 00 00 00 00	 call	 ??0CAr@@QAE@PAXI@Z	; CAr::CAr

; 5255 : 	ar << NULL_ID << SNAPSHOTTYPE_SCHOOL_REPORT;

  00045	6a 04		 push	 4
  00047	8d 4c 24 10	 lea	 ecx, DWORD PTR _ar$[esp+16436]
  0004b	c7 84 24 30 40
	00 00 00 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+16444], 0
  00056	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0005b	8b 44 24 14	 mov	 eax, DWORD PTR _ar$[esp+16440]
  0005f	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [eax], -1
  00065	83 44 24 14 04	 add	 DWORD PTR _ar$[esp+16440], 4
  0006a	6a 02		 push	 2
  0006c	8d 4c 24 10	 lea	 ecx, DWORD PTR _ar$[esp+16436]
  00070	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00075	8b 4c 24 14	 mov	 ecx, DWORD PTR _ar$[esp+16440]
  00079	66 c7 01 2d 00	 mov	 WORD PTR [ecx], 45	; 0000002dH
  0007e	8b 54 24 14	 mov	 edx, DWORD PTR _ar$[esp+16440]

; 5256 : 	ar.Write( pSchool, sizeof(SCHOOL_ENTRY) * MAX_SCHOOL );

  00082	68 a8 02 00 00	 push	 680			; 000002a8H
  00087	83 c2 02	 add	 edx, 2
  0008a	57		 push	 edi
  0008b	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  0008f	89 54 24 1c	 mov	 DWORD PTR _ar$[esp+16448], edx
  00093	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write

; 5257 : 	ar << nElapse;

  00098	6a 02		 push	 2
  0009a	8d 4c 24 10	 lea	 ecx, DWORD PTR _ar$[esp+16436]
  0009e	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000a3	8b 54 24 14	 mov	 edx, DWORD PTR _ar$[esp+16440]
  000a7	66 8b 84 24 38
	40 00 00	 mov	 ax, WORD PTR _nElapse$[esp+16428]
  000af	66 89 02	 mov	 WORD PTR [edx], ax
  000b2	83 44 24 14 02	 add	 DWORD PTR _ar$[esp+16440], 2

; 5258 : 
; 5259 : 	GETBLOCK( ar, lpBuf, uBufSize );

  000b7	8d 4c 24 08	 lea	 ecx, DWORD PTR _uBufSize$[esp+16432]
  000bb	51		 push	 ecx
  000bc	8d 4c 24 10	 lea	 ecx, DWORD PTR _ar$[esp+16436]
  000c0	e8 00 00 00 00	 call	 ?GetBuffer@CAr@@QAEPAEPAH@Z ; CAr::GetBuffer

; 5260 : 	AddBlock( lpBuf, uBufSize );	// all

  000c5	8b 54 24 08	 mov	 edx, DWORD PTR _uBufSize$[esp+16432]
  000c9	52		 push	 edx
  000ca	50		 push	 eax
  000cb	8b ce		 mov	 ecx, esi
  000cd	e8 00 00 00 00	 call	 ?AddBlock@CUserMng@@QAEXPAEK@Z ; CUserMng::AddBlock

; 5261 : }

  000d2	8d 4c 24 0c	 lea	 ecx, DWORD PTR _ar$[esp+16432]
  000d6	c7 84 24 2c 40
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+16440], -1
  000e1	e8 00 00 00 00	 call	 ??1CAr@@QAE@XZ		; CAr::~CAr
  000e6	8b 8c 24 24 40
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+16432]
  000ed	5f		 pop	 edi
  000ee	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  000f5	8b 8c 24 1c 40
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+16428]
  000fc	5e		 pop	 esi
  000fd	33 cc		 xor	 ecx, esp
  000ff	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00104	81 c4 28 40 00
	00		 add	 esp, 16424		; 00004028H
  0010a	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L341177:
  00000	8d 8d dc bf ff
	ff		 lea	 ecx, DWORD PTR _ar$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CAr@@QAE@XZ		; CAr::~CAr
__ehhandler$?AddSchoolReport@CUserMng@@QAEXPAU_SCHOOL_ENTRY@@F@Z:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T341201
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?AddSchoolReport@CUserMng@@QAEXPAU_SCHOOL_ENTRY@@F@Z ENDP ; CUserMng::AddSchoolReport
PUBLIC	?AddCreateGuild@CUserMng@@QAEXKPBDK0@Z		; CUserMng::AddCreateGuild
;	COMDAT xdata$x
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_network\misc\include\ar.h
xdata$x	SEGMENT
$T341239 DD	0ffffffffH
	DD	FLAT:$L341213
$T341236 DD	019930520H
	DD	01H
	DD	FLAT:$T341239
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
xdata$x	ENDS
;	COMDAT ?AddCreateGuild@CUserMng@@QAEXKPBDK0@Z
_TEXT	SEGMENT
_uBufSize$ = -16424					; size = 4
_ar$ = -16420						; size = 16404
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_idPlayer$ = 8						; size = 4
_lpszPlayer$ = 12					; size = 4
_idGuild$ = 16						; size = 4
_szGuild$ = 20						; size = 4
?AddCreateGuild@CUserMng@@QAEXKPBDK0@Z PROC NEAR	; CUserMng::AddCreateGuild, COMDAT
; _this$ = ecx

; 5276 : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?AddCreateGuild@CUserMng@@QAEXKPBDK0@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	b8 1c 40 00 00	 mov	 eax, 16412		; 0000401cH
  00013	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0001a	e8 00 00 00 00	 call	 __chkstk
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00024	33 c4		 xor	 eax, esp
  00026	53		 push	 ebx
  00027	8b 9c 24 3c 40
	00 00		 mov	 ebx, DWORD PTR _szGuild$[esp+16424]
  0002e	56		 push	 esi
  0002f	8b b4 24 38 40
	00 00		 mov	 esi, DWORD PTR _lpszPlayer$[esp+16428]
  00036	57		 push	 edi

; 5277 : 	CAr ar;

  00037	6a 00		 push	 0
  00039	8b f9		 mov	 edi, ecx
  0003b	6a 00		 push	 0
  0003d	8d 4c 24 18	 lea	 ecx, DWORD PTR _ar$[esp+16444]
  00041	89 84 24 2c 40
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+16444], eax
  00048	e8 00 00 00 00	 call	 ??0CAr@@QAE@PAXI@Z	; CAr::CAr

; 5278 : 	ar << NULL_ID << SNAPSHOTTYPE_CREATE_GUILD;

  0004d	6a 04		 push	 4
  0004f	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  00053	c7 84 24 34 40
	00 00 00 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+16448], 0
  0005e	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00063	8b 44 24 18	 mov	 eax, DWORD PTR _ar$[esp+16444]
  00067	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [eax], -1
  0006d	83 44 24 18 04	 add	 DWORD PTR _ar$[esp+16444], 4
  00072	6a 02		 push	 2
  00074	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  00078	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0007d	8b 4c 24 18	 mov	 ecx, DWORD PTR _ar$[esp+16444]
  00081	66 c7 01 9c 00	 mov	 WORD PTR [ecx], 156	; 0000009cH
  00086	8b 54 24 18	 mov	 edx, DWORD PTR _ar$[esp+16444]
  0008a	83 c2 02	 add	 edx, 2

; 5279 : 	ar << idPlayer << idGuild;

  0008d	6a 04		 push	 4
  0008f	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  00093	89 54 24 1c	 mov	 DWORD PTR _ar$[esp+16448], edx
  00097	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0009c	8b 54 24 18	 mov	 edx, DWORD PTR _ar$[esp+16444]
  000a0	8b 84 24 38 40
	00 00		 mov	 eax, DWORD PTR _idPlayer$[esp+16432]
  000a7	89 02		 mov	 DWORD PTR [edx], eax
  000a9	8b 44 24 18	 mov	 eax, DWORD PTR _ar$[esp+16444]
  000ad	83 c0 04	 add	 eax, 4
  000b0	6a 04		 push	 4
  000b2	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  000b6	89 44 24 1c	 mov	 DWORD PTR _ar$[esp+16448], eax
  000ba	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000bf	8b 4c 24 18	 mov	 ecx, DWORD PTR _ar$[esp+16444]
  000c3	8b 94 24 40 40
	00 00		 mov	 edx, DWORD PTR _idGuild$[esp+16432]
  000ca	89 11		 mov	 DWORD PTR [ecx], edx
  000cc	8b 4c 24 18	 mov	 ecx, DWORD PTR _ar$[esp+16444]
  000d0	83 c1 04	 add	 ecx, 4

; 5280 : 	ar.WriteString( lpszPlayer? lpszPlayer: "" );

  000d3	85 f6		 test	 esi, esi
  000d5	89 4c 24 18	 mov	 DWORD PTR _ar$[esp+16444], ecx
  000d9	75 05		 jne	 SHORT $L341212
  000db	be 00 00 00 00	 mov	 esi, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
$L341212:
  000e0	56		 push	 esi
  000e1	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  000e5	e8 00 00 00 00	 call	 ?WriteString@CAr@@QAEXPBD@Z ; CAr::WriteString

; 5281 : 	ar.WriteString( szGuild );

  000ea	53		 push	 ebx
  000eb	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  000ef	e8 00 00 00 00	 call	 ?WriteString@CAr@@QAEXPBD@Z ; CAr::WriteString

; 5282 : 	GETBLOCK( ar, lpBuf, uBufSize );

  000f4	8d 44 24 0c	 lea	 eax, DWORD PTR _uBufSize$[esp+16436]
  000f8	50		 push	 eax
  000f9	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  000fd	e8 00 00 00 00	 call	 ?GetBuffer@CAr@@QAEPAEPAH@Z ; CAr::GetBuffer

; 5283 : 
; 5284 : 	AddBlock( lpBuf, uBufSize );	// all

  00102	8b 4c 24 0c	 mov	 ecx, DWORD PTR _uBufSize$[esp+16436]
  00106	51		 push	 ecx
  00107	50		 push	 eax
  00108	8b cf		 mov	 ecx, edi
  0010a	e8 00 00 00 00	 call	 ?AddBlock@CUserMng@@QAEXPAEK@Z ; CUserMng::AddBlock

; 5285 : }

  0010f	8d 4c 24 10	 lea	 ecx, DWORD PTR _ar$[esp+16436]
  00113	c7 84 24 30 40
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+16444], -1
  0011e	e8 00 00 00 00	 call	 ??1CAr@@QAE@XZ		; CAr::~CAr
  00123	8b 8c 24 28 40
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+16436]
  0012a	5f		 pop	 edi
  0012b	5e		 pop	 esi
  0012c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00133	8b 8c 24 1c 40
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+16428]
  0013a	5b		 pop	 ebx
  0013b	33 cc		 xor	 ecx, esp
  0013d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00142	81 c4 28 40 00
	00		 add	 esp, 16424		; 00004028H
  00148	c2 10 00	 ret	 16			; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L341213:
  00000	8d 8d dc bf ff
	ff		 lea	 ecx, DWORD PTR _ar$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CAr@@QAE@XZ		; CAr::~CAr
__ehhandler$?AddCreateGuild@CUserMng@@QAEXKPBDK0@Z:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T341236
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?AddCreateGuild@CUserMng@@QAEXKPBDK0@Z ENDP		; CUserMng::AddCreateGuild
PUBLIC	?AddDestroyGuild@CUserMng@@QAEXPBDK@Z		; CUserMng::AddDestroyGuild
;	COMDAT xdata$x
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_network\misc\include\ar.h
xdata$x	SEGMENT
$T341270 DD	0ffffffffH
	DD	FLAT:$L341248
$T341267 DD	019930520H
	DD	01H
	DD	FLAT:$T341270
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
xdata$x	ENDS
;	COMDAT ?AddDestroyGuild@CUserMng@@QAEXPBDK@Z
_TEXT	SEGMENT
_uBufSize$ = -16424					; size = 4
_ar$ = -16420						; size = 16404
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_lpszPlayer$ = 8					; size = 4
_idGuild$ = 12						; size = 4
?AddDestroyGuild@CUserMng@@QAEXPBDK@Z PROC NEAR		; CUserMng::AddDestroyGuild, COMDAT
; _this$ = ecx

; 5288 : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?AddDestroyGuild@CUserMng@@QAEXPBDK@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	b8 1c 40 00 00	 mov	 eax, 16412		; 0000401cH
  00013	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0001a	e8 00 00 00 00	 call	 __chkstk
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00024	33 c4		 xor	 eax, esp
  00026	56		 push	 esi
  00027	8b b4 24 30 40
	00 00		 mov	 esi, DWORD PTR _lpszPlayer$[esp+16424]
  0002e	57		 push	 edi

; 5289 : 	CAr ar;

  0002f	6a 00		 push	 0
  00031	8b f9		 mov	 edi, ecx
  00033	6a 00		 push	 0
  00035	8d 4c 24 14	 lea	 ecx, DWORD PTR _ar$[esp+16440]
  00039	89 84 24 28 40
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+16440], eax
  00040	e8 00 00 00 00	 call	 ??0CAr@@QAE@PAXI@Z	; CAr::CAr

; 5290 : 	ar << NULL_ID << SNAPSHOTTYPE_DESTROY_GUILD;

  00045	6a 04		 push	 4
  00047	8d 4c 24 10	 lea	 ecx, DWORD PTR _ar$[esp+16436]
  0004b	c7 84 24 30 40
	00 00 00 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+16444], 0
  00056	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0005b	8b 44 24 14	 mov	 eax, DWORD PTR _ar$[esp+16440]
  0005f	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [eax], -1
  00065	8b 44 24 14	 mov	 eax, DWORD PTR _ar$[esp+16440]
  00069	83 c0 04	 add	 eax, 4
  0006c	6a 02		 push	 2
  0006e	8d 4c 24 10	 lea	 ecx, DWORD PTR _ar$[esp+16436]
  00072	89 44 24 18	 mov	 DWORD PTR _ar$[esp+16444], eax
  00076	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0007b	8b 4c 24 14	 mov	 ecx, DWORD PTR _ar$[esp+16440]
  0007f	66 c7 01 9d 00	 mov	 WORD PTR [ecx], 157	; 0000009dH
  00084	8b 4c 24 14	 mov	 ecx, DWORD PTR _ar$[esp+16440]
  00088	83 c1 02	 add	 ecx, 2

; 5291 : 	ar.WriteString( lpszPlayer? lpszPlayer: "" );

  0008b	85 f6		 test	 esi, esi
  0008d	89 4c 24 14	 mov	 DWORD PTR _ar$[esp+16440], ecx
  00091	75 05		 jne	 SHORT $L341247
  00093	be 00 00 00 00	 mov	 esi, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
$L341247:
  00098	56		 push	 esi
  00099	8d 4c 24 10	 lea	 ecx, DWORD PTR _ar$[esp+16436]
  0009d	e8 00 00 00 00	 call	 ?WriteString@CAr@@QAEXPBD@Z ; CAr::WriteString

; 5292 : 	ar << idGuild;

  000a2	6a 04		 push	 4
  000a4	8d 4c 24 10	 lea	 ecx, DWORD PTR _ar$[esp+16436]
  000a8	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000ad	8b 54 24 14	 mov	 edx, DWORD PTR _ar$[esp+16440]
  000b1	8b 84 24 38 40
	00 00		 mov	 eax, DWORD PTR _idGuild$[esp+16428]
  000b8	89 02		 mov	 DWORD PTR [edx], eax
  000ba	83 44 24 14 04	 add	 DWORD PTR _ar$[esp+16440], 4

; 5293 : 	GETBLOCK( ar, lpBuf, uBufSize );

  000bf	8d 4c 24 08	 lea	 ecx, DWORD PTR _uBufSize$[esp+16432]
  000c3	51		 push	 ecx
  000c4	8d 4c 24 10	 lea	 ecx, DWORD PTR _ar$[esp+16436]
  000c8	e8 00 00 00 00	 call	 ?GetBuffer@CAr@@QAEPAEPAH@Z ; CAr::GetBuffer

; 5294 : 
; 5295 : 	AddBlock( lpBuf, uBufSize );	// all

  000cd	8b 54 24 08	 mov	 edx, DWORD PTR _uBufSize$[esp+16432]
  000d1	52		 push	 edx
  000d2	50		 push	 eax
  000d3	8b cf		 mov	 ecx, edi
  000d5	e8 00 00 00 00	 call	 ?AddBlock@CUserMng@@QAEXPAEK@Z ; CUserMng::AddBlock

; 5296 : }

  000da	8d 4c 24 0c	 lea	 ecx, DWORD PTR _ar$[esp+16432]
  000de	c7 84 24 2c 40
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+16440], -1
  000e9	e8 00 00 00 00	 call	 ??1CAr@@QAE@XZ		; CAr::~CAr
  000ee	8b 8c 24 24 40
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+16432]
  000f5	5f		 pop	 edi
  000f6	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  000fd	8b 8c 24 1c 40
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+16428]
  00104	5e		 pop	 esi
  00105	33 cc		 xor	 ecx, esp
  00107	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0010c	81 c4 28 40 00
	00		 add	 esp, 16424		; 00004028H
  00112	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L341248:
  00000	8d 8d dc bf ff
	ff		 lea	 ecx, DWORD PTR _ar$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CAr@@QAE@XZ		; CAr::~CAr
__ehhandler$?AddDestroyGuild@CUserMng@@QAEXPBDK@Z:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T341267
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?AddDestroyGuild@CUserMng@@QAEXPBDK@Z ENDP		; CUserMng::AddDestroyGuild
PUBLIC	?AddSetLogo@CUserMng@@QAEXKK@Z			; CUserMng::AddSetLogo
;	COMDAT xdata$x
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_network\misc\include\ar.h
xdata$x	SEGMENT
$T341301 DD	0ffffffffH
	DD	FLAT:$L341277
$T341298 DD	019930520H
	DD	01H
	DD	FLAT:$T341301
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
xdata$x	ENDS
;	COMDAT ?AddSetLogo@CUserMng@@QAEXKK@Z
_TEXT	SEGMENT
_uBufSize$ = -16424					; size = 4
_ar$ = -16420						; size = 16404
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_idGuild$ = 8						; size = 4
_dwLogo$ = 12						; size = 4
?AddSetLogo@CUserMng@@QAEXKK@Z PROC NEAR		; CUserMng::AddSetLogo, COMDAT
; _this$ = ecx

; 5324 : {

  00000	6a ff		 push	 -1
  00002	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00008	68 00 00 00 00	 push	 __ehhandler$?AddSetLogo@CUserMng@@QAEXKK@Z
  0000d	50		 push	 eax
  0000e	b8 1c 40 00 00	 mov	 eax, 16412		; 0000401cH
  00013	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0001a	e8 00 00 00 00	 call	 __chkstk
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00024	33 c4		 xor	 eax, esp
  00026	56		 push	 esi

; 5325 : 	CAr ar;

  00027	6a 00		 push	 0
  00029	8b f1		 mov	 esi, ecx
  0002b	89 84 24 20 40
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+16432], eax
  00032	6a 00		 push	 0
  00034	8d 4c 24 10	 lea	 ecx, DWORD PTR _ar$[esp+16436]
  00038	e8 00 00 00 00	 call	 ??0CAr@@QAE@PAXI@Z	; CAr::CAr

; 5326 : 	ar << NULL_ID << SNAPSHOTTYPE_GUILD_LOGO;

  0003d	6a 04		 push	 4
  0003f	8d 4c 24 0c	 lea	 ecx, DWORD PTR _ar$[esp+16432]
  00043	c7 84 24 2c 40
	00 00 00 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+16440], 0
  0004e	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00053	8b 44 24 10	 mov	 eax, DWORD PTR _ar$[esp+16436]
  00057	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [eax], -1
  0005d	8b 54 24 10	 mov	 edx, DWORD PTR _ar$[esp+16436]
  00061	83 c2 04	 add	 edx, 4
  00064	6a 02		 push	 2
  00066	8d 4c 24 0c	 lea	 ecx, DWORD PTR _ar$[esp+16432]
  0006a	89 54 24 14	 mov	 DWORD PTR _ar$[esp+16440], edx
  0006e	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00073	8b 4c 24 10	 mov	 ecx, DWORD PTR _ar$[esp+16436]
  00077	66 c7 01 fb 00	 mov	 WORD PTR [ecx], 251	; 000000fbH
  0007c	8b 44 24 10	 mov	 eax, DWORD PTR _ar$[esp+16436]
  00080	83 c0 02	 add	 eax, 2

; 5327 : 	ar << idGuild << dwLogo;

  00083	6a 04		 push	 4
  00085	8d 4c 24 0c	 lea	 ecx, DWORD PTR _ar$[esp+16432]
  00089	89 44 24 14	 mov	 DWORD PTR _ar$[esp+16440], eax
  0008d	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00092	8b 54 24 10	 mov	 edx, DWORD PTR _ar$[esp+16436]
  00096	8b 84 24 30 40
	00 00		 mov	 eax, DWORD PTR _idGuild$[esp+16424]
  0009d	89 02		 mov	 DWORD PTR [edx], eax
  0009f	83 44 24 10 04	 add	 DWORD PTR _ar$[esp+16436], 4
  000a4	6a 04		 push	 4
  000a6	8d 4c 24 0c	 lea	 ecx, DWORD PTR _ar$[esp+16432]
  000aa	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000af	8b 4c 24 10	 mov	 ecx, DWORD PTR _ar$[esp+16436]
  000b3	8b 94 24 34 40
	00 00		 mov	 edx, DWORD PTR _dwLogo$[esp+16424]
  000ba	89 11		 mov	 DWORD PTR [ecx], edx
  000bc	8b 54 24 10	 mov	 edx, DWORD PTR _ar$[esp+16436]

; 5328 : 
; 5329 : 	GETBLOCK( ar, lpBuf, uBufSize );

  000c0	8d 44 24 04	 lea	 eax, DWORD PTR _uBufSize$[esp+16428]
  000c4	83 c2 04	 add	 edx, 4
  000c7	50		 push	 eax
  000c8	8d 4c 24 0c	 lea	 ecx, DWORD PTR _ar$[esp+16432]
  000cc	89 54 24 14	 mov	 DWORD PTR _ar$[esp+16440], edx
  000d0	e8 00 00 00 00	 call	 ?GetBuffer@CAr@@QAEPAEPAH@Z ; CAr::GetBuffer

; 5330 : 	AddBlock( lpBuf, uBufSize );	// all

  000d5	8b 4c 24 04	 mov	 ecx, DWORD PTR _uBufSize$[esp+16428]
  000d9	51		 push	 ecx
  000da	50		 push	 eax
  000db	8b ce		 mov	 ecx, esi
  000dd	e8 00 00 00 00	 call	 ?AddBlock@CUserMng@@QAEXPAEK@Z ; CUserMng::AddBlock

; 5331 : }

  000e2	8d 4c 24 08	 lea	 ecx, DWORD PTR _ar$[esp+16428]
  000e6	c7 84 24 28 40
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+16436], -1
  000f1	e8 00 00 00 00	 call	 ??1CAr@@QAE@XZ		; CAr::~CAr
  000f6	8b 8c 24 20 40
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+16428]
  000fd	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00104	8b 8c 24 1c 40
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+16428]
  0010b	5e		 pop	 esi
  0010c	33 cc		 xor	 ecx, esp
  0010e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00113	81 c4 28 40 00
	00		 add	 esp, 16424		; 00004028H
  00119	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L341277:
  00000	8d 8d dc bf ff
	ff		 lea	 ecx, DWORD PTR _ar$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CAr@@QAE@XZ		; CAr::~CAr
__ehhandler$?AddSetLogo@CUserMng@@QAEXKK@Z:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T341298
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?AddSetLogo@CUserMng@@QAEXKK@Z ENDP			; CUserMng::AddSetLogo
PUBLIC	?AddGCLogWorld@CUserMng@@QAEXXZ			; CUserMng::AddGCLogWorld
;	COMDAT xdata$x
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\obj.h
xdata$x	SEGMENT
$T341726 DD	0ffffffffH
	DD	FLAT:$L341310
$T341717 DD	019930520H
	DD	01H
	DD	FLAT:$T341726
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
xdata$x	ENDS
;	COMDAT ?AddGCLogWorld@CUserMng@@QAEXXZ
_TEXT	SEGMENT
_uBlockSize$ = -16464					; size = 4
$T341715 = -16460					; size = 4
_GCGetPoint$282593 = -16456				; size = 36
_arBlock$ = -16420					; size = 16404
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
?AddGCLogWorld@CUserMng@@QAEXXZ PROC NEAR		; CUserMng::AddGCLogWorld, COMDAT
; _this$ = ecx

; 5826 : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?AddGCLogWorld@CUserMng@@QAEXXZ
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	b8 44 40 00 00	 mov	 eax, 16452		; 00004044H
  00013	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0001a	e8 00 00 00 00	 call	 __chkstk
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00024	33 c4		 xor	 eax, esp
  00026	53		 push	 ebx
  00027	55		 push	 ebp
  00028	56		 push	 esi
  00029	57		 push	 edi

; 5827 : 	CAr arBlock;

  0002a	33 ed		 xor	 ebp, ebp
  0002c	8b f9		 mov	 edi, ecx
  0002e	55		 push	 ebp
  0002f	55		 push	 ebp
  00030	8d 4c 24 44	 lea	 ecx, DWORD PTR _arBlock$[esp+16488]
  00034	89 84 24 58 40
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+16488], eax

; 5832 : 	{
; 5833 : 		CGuildCombat::__GCGETPOINT GCGetPoint = g_GuildCombatMng.m_vecGCGetPoint[ veci ];

  0003b	89 7c 24 1c	 mov	 DWORD PTR $T341715[esp+16488], edi
  0003f	e8 00 00 00 00	 call	 ??0CAr@@QAE@PAXI@Z	; CAr::CAr
  00044	bb 04 00 00 00	 mov	 ebx, 4
  00049	53		 push	 ebx
  0004a	8d 4c 24 40	 lea	 ecx, DWORD PTR _arBlock$[esp+16484]
  0004e	89 ac 24 60 40
	00 00		 mov	 DWORD PTR __$EHRec$[esp+16492], ebp
  00055	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0005a	8b 44 24 44	 mov	 eax, DWORD PTR _arBlock$[esp+16488]
  0005e	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [eax], -1
  00064	8b 54 24 44	 mov	 edx, DWORD PTR _arBlock$[esp+16488]
  00068	03 d3		 add	 edx, ebx
  0006a	6a 02		 push	 2
  0006c	8d 4c 24 40	 lea	 ecx, DWORD PTR _arBlock$[esp+16484]
  00070	89 54 24 48	 mov	 DWORD PTR _arBlock$[esp+16492], edx
  00074	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00079	8b 4c 24 44	 mov	 ecx, DWORD PTR _arBlock$[esp+16488]
  0007d	66 c7 01 b8 00	 mov	 WORD PTR [ecx], 184	; 000000b8H
  00082	8b 44 24 44	 mov	 eax, DWORD PTR _arBlock$[esp+16488]
  00086	83 c0 02	 add	 eax, 2
  00089	6a 01		 push	 1
  0008b	8d 4c 24 40	 lea	 ecx, DWORD PTR _arBlock$[esp+16484]
  0008f	89 44 24 48	 mov	 DWORD PTR _arBlock$[esp+16492], eax
  00093	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00098	8b 54 24 44	 mov	 edx, DWORD PTR _arBlock$[esp+16488]
  0009c	c6 02 35	 mov	 BYTE PTR [edx], 53	; 00000035H
  0009f	8b 54 24 44	 mov	 edx, DWORD PTR _arBlock$[esp+16488]
  000a3	a1 54 00 00 00	 mov	 eax, DWORD PTR ?g_GuildCombatMng@@3VCGuildCombat@@A+84
  000a8	42		 inc	 edx
  000a9	3b c5		 cmp	 eax, ebp
  000ab	89 54 24 44	 mov	 DWORD PTR _arBlock$[esp+16488], edx
  000af	75 04		 jne	 SHORT $L341331

; 5828 : 	arBlock << NULL_ID << SNAPSHOTTYPE_GUILDCOMBAT;
; 5829 : 	arBlock << GC_LOG;
; 5830 : 	arBlock << (u_long)g_GuildCombatMng.m_vecGCGetPoint.size();

  000b1	33 f6		 xor	 esi, esi
  000b3	eb 19		 jmp	 SHORT $L341332
$L341331:
  000b5	8b 0d 58 00 00
	00		 mov	 ecx, DWORD PTR ?g_GuildCombatMng@@3VCGuildCombat@@A+88
  000bb	2b c8		 sub	 ecx, eax
  000bd	b8 39 8e e3 38	 mov	 eax, 954437177		; 38e38e39H
  000c2	f7 e9		 imul	 ecx
  000c4	c1 fa 03	 sar	 edx, 3
  000c7	8b f2		 mov	 esi, edx
  000c9	c1 ee 1f	 shr	 esi, 31			; 0000001fH
  000cc	03 f2		 add	 esi, edx
$L341332:
  000ce	53		 push	 ebx
  000cf	8d 4c 24 40	 lea	 ecx, DWORD PTR _arBlock$[esp+16484]
  000d3	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000d8	8b 44 24 44	 mov	 eax, DWORD PTR _arBlock$[esp+16488]
  000dc	89 30		 mov	 DWORD PTR [eax], esi
  000de	01 5c 24 44	 add	 DWORD PTR _arBlock$[esp+16488], ebx

; 5831 : 	for( int veci = 0 ; veci < (int)( g_GuildCombatMng.m_vecGCGetPoint.size() ) ; ++veci )

  000e2	33 db		 xor	 ebx, ebx
$L282590:
  000e4	8b 0d 54 00 00
	00		 mov	 ecx, DWORD PTR ?g_GuildCombatMng@@3VCGuildCombat@@A+84
  000ea	85 c9		 test	 ecx, ecx
  000ec	75 04		 jne	 SHORT $L341342
  000ee	33 c0		 xor	 eax, eax
  000f0	eb 19		 jmp	 SHORT $L341343
$L341342:
  000f2	8b 15 58 00 00
	00		 mov	 edx, DWORD PTR ?g_GuildCombatMng@@3VCGuildCombat@@A+88
  000f8	2b d1		 sub	 edx, ecx
  000fa	b8 39 8e e3 38	 mov	 eax, 954437177		; 38e38e39H
  000ff	f7 ea		 imul	 edx
  00101	c1 fa 03	 sar	 edx, 3
  00104	8b c2		 mov	 eax, edx
  00106	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00109	03 c2		 add	 eax, edx
$L341343:
  0010b	3b d8		 cmp	 ebx, eax
  0010d	0f 8d 2e 01 00
	00		 jge	 $L282592

; 5832 : 	{
; 5833 : 		CGuildCombat::__GCGETPOINT GCGetPoint = g_GuildCombatMng.m_vecGCGetPoint[ veci ];

  00113	8d 34 29	 lea	 esi, DWORD PTR [ecx+ebp]
  00116	b9 09 00 00 00	 mov	 ecx, 9
  0011b	8d 7c 24 18	 lea	 edi, DWORD PTR _GCGetPoint$282593[esp+16480]
  0011f	f3 a5		 rep movsd

; 5834 : 		arBlock << GCGetPoint.uidGuildAttack;

  00121	be 04 00 00 00	 mov	 esi, 4
  00126	56		 push	 esi
  00127	8d 4c 24 40	 lea	 ecx, DWORD PTR _arBlock$[esp+16484]
  0012b	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00130	8b 4c 24 44	 mov	 ecx, DWORD PTR _arBlock$[esp+16488]
  00134	8b 54 24 18	 mov	 edx, DWORD PTR _GCGetPoint$282593[esp+16480]
  00138	89 11		 mov	 DWORD PTR [ecx], edx
  0013a	8b 54 24 44	 mov	 edx, DWORD PTR _arBlock$[esp+16488]
  0013e	03 d6		 add	 edx, esi

; 5835 : 		arBlock << GCGetPoint.uidGuildDefence;

  00140	56		 push	 esi
  00141	8d 4c 24 40	 lea	 ecx, DWORD PTR _arBlock$[esp+16484]
  00145	89 54 24 48	 mov	 DWORD PTR _arBlock$[esp+16492], edx
  00149	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0014e	8b 44 24 44	 mov	 eax, DWORD PTR _arBlock$[esp+16488]
  00152	8b 4c 24 1c	 mov	 ecx, DWORD PTR _GCGetPoint$282593[esp+16484]
  00156	89 08		 mov	 DWORD PTR [eax], ecx
  00158	8b 44 24 44	 mov	 eax, DWORD PTR _arBlock$[esp+16488]
  0015c	03 c6		 add	 eax, esi

; 5836 : 		arBlock << GCGetPoint.uidPlayerAttack;

  0015e	56		 push	 esi
  0015f	8d 4c 24 40	 lea	 ecx, DWORD PTR _arBlock$[esp+16484]
  00163	89 44 24 48	 mov	 DWORD PTR _arBlock$[esp+16492], eax
  00167	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0016c	8b 54 24 44	 mov	 edx, DWORD PTR _arBlock$[esp+16488]
  00170	8b 44 24 20	 mov	 eax, DWORD PTR _GCGetPoint$282593[esp+16488]
  00174	89 02		 mov	 DWORD PTR [edx], eax
  00176	8b 54 24 44	 mov	 edx, DWORD PTR _arBlock$[esp+16488]
  0017a	03 d6		 add	 edx, esi

; 5837 : 		arBlock << GCGetPoint.uidPlayerDefence;

  0017c	56		 push	 esi
  0017d	8d 4c 24 40	 lea	 ecx, DWORD PTR _arBlock$[esp+16484]
  00181	89 54 24 48	 mov	 DWORD PTR _arBlock$[esp+16492], edx
  00185	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0018a	8b 4c 24 44	 mov	 ecx, DWORD PTR _arBlock$[esp+16488]
  0018e	8b 54 24 24	 mov	 edx, DWORD PTR _GCGetPoint$282593[esp+16492]
  00192	89 11		 mov	 DWORD PTR [ecx], edx
  00194	8b 44 24 44	 mov	 eax, DWORD PTR _arBlock$[esp+16488]
  00198	03 c6		 add	 eax, esi

; 5838 : 		arBlock << GCGetPoint.nPoint;

  0019a	56		 push	 esi
  0019b	8d 4c 24 40	 lea	 ecx, DWORD PTR _arBlock$[esp+16484]
  0019f	89 44 24 48	 mov	 DWORD PTR _arBlock$[esp+16492], eax
  001a3	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  001a8	8b 44 24 44	 mov	 eax, DWORD PTR _arBlock$[esp+16488]
  001ac	8b 4c 24 28	 mov	 ecx, DWORD PTR _GCGetPoint$282593[esp+16496]
  001b0	89 08		 mov	 DWORD PTR [eax], ecx
  001b2	8b 54 24 44	 mov	 edx, DWORD PTR _arBlock$[esp+16488]
  001b6	03 d6		 add	 edx, esi

; 5839 : 		arBlock << GCGetPoint.bKillDiffernceGuild;

  001b8	56		 push	 esi
  001b9	8d 4c 24 40	 lea	 ecx, DWORD PTR _arBlock$[esp+16484]
  001bd	89 54 24 48	 mov	 DWORD PTR _arBlock$[esp+16492], edx
  001c1	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  001c6	8b 54 24 44	 mov	 edx, DWORD PTR _arBlock$[esp+16488]
  001ca	8b 44 24 2c	 mov	 eax, DWORD PTR _GCGetPoint$282593[esp+16500]
  001ce	89 02		 mov	 DWORD PTR [edx], eax
  001d0	8b 44 24 44	 mov	 eax, DWORD PTR _arBlock$[esp+16488]
  001d4	03 c6		 add	 eax, esi

; 5840 : 		arBlock << GCGetPoint.bMaster;

  001d6	56		 push	 esi
  001d7	8d 4c 24 40	 lea	 ecx, DWORD PTR _arBlock$[esp+16484]
  001db	89 44 24 48	 mov	 DWORD PTR _arBlock$[esp+16492], eax
  001df	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  001e4	8b 4c 24 44	 mov	 ecx, DWORD PTR _arBlock$[esp+16488]
  001e8	8b 54 24 30	 mov	 edx, DWORD PTR _GCGetPoint$282593[esp+16504]
  001ec	89 11		 mov	 DWORD PTR [ecx], edx
  001ee	8b 54 24 44	 mov	 edx, DWORD PTR _arBlock$[esp+16488]
  001f2	03 d6		 add	 edx, esi

; 5841 : 		arBlock << GCGetPoint.bDefender;

  001f4	56		 push	 esi
  001f5	8d 4c 24 40	 lea	 ecx, DWORD PTR _arBlock$[esp+16484]
  001f9	89 54 24 48	 mov	 DWORD PTR _arBlock$[esp+16492], edx
  001fd	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00202	8b 44 24 44	 mov	 eax, DWORD PTR _arBlock$[esp+16488]
  00206	8b 4c 24 34	 mov	 ecx, DWORD PTR _GCGetPoint$282593[esp+16508]
  0020a	89 08		 mov	 DWORD PTR [eax], ecx
  0020c	8b 44 24 44	 mov	 eax, DWORD PTR _arBlock$[esp+16488]
  00210	03 c6		 add	 eax, esi

; 5842 : 		arBlock << GCGetPoint.bLastLife;

  00212	56		 push	 esi
  00213	8d 4c 24 40	 lea	 ecx, DWORD PTR _arBlock$[esp+16484]
  00217	89 44 24 48	 mov	 DWORD PTR _arBlock$[esp+16492], eax
  0021b	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00220	8b 54 24 44	 mov	 edx, DWORD PTR _arBlock$[esp+16488]
  00224	8b 44 24 38	 mov	 eax, DWORD PTR _GCGetPoint$282593[esp+16512]
  00228	8b 7c 24 14	 mov	 edi, DWORD PTR $T341715[esp+16480]
  0022c	89 02		 mov	 DWORD PTR [edx], eax
  0022e	8b 54 24 44	 mov	 edx, DWORD PTR _arBlock$[esp+16488]
  00232	03 d6		 add	 edx, esi
  00234	43		 inc	 ebx
  00235	89 54 24 44	 mov	 DWORD PTR _arBlock$[esp+16488], edx
  00239	83 c5 24	 add	 ebp, 36			; 00000024H
  0023c	e9 a3 fe ff ff	 jmp	 $L282590
$L282592:

; 5843 : 	}
; 5844 : 	GETBLOCK( arBlock, lpBlock, uBlockSize );

  00241	8d 4c 24 10	 lea	 ecx, DWORD PTR _uBlockSize$[esp+16480]
  00245	51		 push	 ecx
  00246	8d 4c 24 40	 lea	 ecx, DWORD PTR _arBlock$[esp+16484]
  0024a	e8 00 00 00 00	 call	 ?GetBuffer@CAr@@QAEPAEPAH@Z ; CAr::GetBuffer
  0024f	8b d8		 mov	 ebx, eax

; 5845 : 
; 5846 : 	map<DWORD, CUser*>::iterator it;
; 5847 : 	for( it = m_users.begin(); it != m_users.end(); ++it )

  00251	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  00254	8b 30		 mov	 esi, DWORD PTR [eax]
  00256	3b f0		 cmp	 esi, eax
  00258	0f 84 8e 00 00
	00		 je	 $L282606
  0025e	8b ff		 npad	 2
$L341601:

; 5848 : 	{
; 5849 : 		CUser* pUser = it->second;

  00260	8b 46 10	 mov	 eax, DWORD PTR [esi+16]

; 5850 : 		if( pUser->IsValid() == FALSE )

  00263	f6 40 04 01	 test	 BYTE PTR [eax+4], 1
  00267	75 30		 jne	 SHORT $L282605
  00269	8b 88 e8 16 00
	00		 mov	 ecx, DWORD PTR [eax+5864]
  0026f	85 c9		 test	 ecx, ecx
  00271	74 26		 je	 SHORT $L282605

; 5851 : 			continue;
; 5852 : 		
; 5853 : 		if( pUser->GetWorld()->GetID() == WI_WORLD_GUILDWAR )

  00273	8b 88 6c 01 00
	00		 mov	 ecx, DWORD PTR [eax+364]
  00279	81 39 ca 00 00
	00		 cmp	 DWORD PTR [ecx], 202	; 000000caH
  0027f	75 18		 jne	 SHORT $L282605

; 5854 : 			pUser->AddBlock( lpBlock, uBlockSize );

  00281	8b 4c 24 10	 mov	 ecx, DWORD PTR _uBlockSize$[esp+16480]
  00285	66 ff 80 0c 57
	00 00		 inc	 WORD PTR [eax+22284]
  0028c	51		 push	 ecx
  0028d	53		 push	 ebx
  0028e	8d 88 f8 16 00
	00		 lea	 ecx, DWORD PTR [eax+5880]
  00294	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
$L282605:
  00299	8a 46 15	 mov	 al, BYTE PTR [esi+21]
  0029c	84 c0		 test	 al, al
  0029e	75 43		 jne	 SHORT $L341608
  002a0	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  002a3	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  002a6	84 c9		 test	 cl, cl
  002a8	75 18		 jne	 SHORT $L341721
  002aa	8b f0		 mov	 esi, eax
  002ac	8b 06		 mov	 eax, DWORD PTR [esi]
  002ae	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  002b1	84 c9		 test	 cl, cl
  002b3	75 2e		 jne	 SHORT $L341608

; 5845 : 
; 5846 : 	map<DWORD, CUser*>::iterator it;
; 5847 : 	for( it = m_users.begin(); it != m_users.end(); ++it )

$L341629:
  002b5	8b f0		 mov	 esi, eax
  002b7	8b 06		 mov	 eax, DWORD PTR [esi]
  002b9	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  002bc	84 c9		 test	 cl, cl
  002be	74 f5		 je	 SHORT $L341629
  002c0	eb 21		 jmp	 SHORT $L341608
$L341721:
  002c2	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  002c5	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  002c8	84 c9		 test	 cl, cl
  002ca	75 15		 jne	 SHORT $L341611
  002cc	8d 64 24 00	 npad	 4
$L341610:
  002d0	3b 70 08	 cmp	 esi, DWORD PTR [eax+8]
  002d3	75 0c		 jne	 SHORT $L341611
  002d5	8b f0		 mov	 esi, eax
  002d7	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  002da	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  002dd	84 c9		 test	 cl, cl
  002df	74 ef		 je	 SHORT $L341610
$L341611:
  002e1	8b f0		 mov	 esi, eax
$L341608:
  002e3	3b 77 0c	 cmp	 esi, DWORD PTR [edi+12]
  002e6	0f 85 74 ff ff
	ff		 jne	 $L341601
$L282606:

; 5855 : 	}
; 5856 : }

  002ec	8d 4c 24 3c	 lea	 ecx, DWORD PTR _arBlock$[esp+16480]
  002f0	c7 84 24 5c 40
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+16488], -1
  002fb	e8 00 00 00 00	 call	 ??1CAr@@QAE@XZ		; CAr::~CAr
  00300	8b 8c 24 54 40
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+16480]
  00307	5f		 pop	 edi
  00308	5e		 pop	 esi
  00309	5d		 pop	 ebp
  0030a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00311	8b 8c 24 44 40
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+16468]
  00318	5b		 pop	 ebx
  00319	33 cc		 xor	 ecx, esp
  0031b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00320	81 c4 50 40 00
	00		 add	 esp, 16464		; 00004050H
  00326	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L341310:
  00000	8d 8d dc bf ff
	ff		 lea	 ecx, DWORD PTR _arBlock$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CAr@@QAE@XZ		; CAr::~CAr
__ehhandler$?AddGCLogWorld@CUserMng@@QAEXXZ:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T341717
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?AddGCLogWorld@CUserMng@@QAEXXZ ENDP			; CUserMng::AddGCLogWorld
PUBLIC	??_C@_09NNGGDJBM@Not?5Guild?$AA@		; `string'
PUBLIC	?AddGCGuildPrecedence@CUserMng@@QAEXPAVCUser@@@Z ; CUserMng::AddGCGuildPrecedence
EXTRN	?GetGuild@CGuildMng@@QAEPAVCGuild@@K@Z:NEAR	; CGuildMng::GetGuild
;	COMDAT xdata$x
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\obj.h
xdata$x	SEGMENT
$T342006 DD	0ffffffffH
	DD	FLAT:$L341735
$T341997 DD	019930520H
	DD	01H
	DD	FLAT:$T342006
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_C@_09NNGGDJBM@Not?5Guild?$AA@
CONST	SEGMENT
??_C@_09NNGGDJBM@Not?5Guild?$AA@ DB 'Not Guild', 00H	; `string'
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
CONST	ENDS
;	COMDAT ?AddGCGuildPrecedence@CUserMng@@QAEXPAVCUser@@@Z
_TEXT	SEGMENT
$T341994 = -16428					; size = 4
_it$282941 = -16428					; size = 4
_uBlockSize$ = -16424					; size = 4
_arBlock$ = -16420					; size = 16404
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_pSendUser$ = 8						; size = 4
?AddGCGuildPrecedence@CUserMng@@QAEXPAVCUser@@@Z PROC NEAR ; CUserMng::AddGCGuildPrecedence, COMDAT
; _this$ = ecx

; 6171 : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?AddGCGuildPrecedence@CUserMng@@QAEXPAVCUser@@@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	b8 20 40 00 00	 mov	 eax, 16416		; 00004020H
  00013	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0001a	e8 00 00 00 00	 call	 __chkstk
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00024	33 c4		 xor	 eax, esp
  00026	53		 push	 ebx
  00027	89 84 24 20 40
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+16432], eax

; 6172 : 	if( g_GuildCombatMng.m_nState == CGuildCombat::CLOSE_STATE )

  0002e	a1 40 11 00 00	 mov	 eax, DWORD PTR ?g_GuildCombatMng@@3VCGuildCombat@@A+4416
  00033	bb 01 00 00 00	 mov	 ebx, 1
  00038	3b c3		 cmp	 eax, ebx
  0003a	55		 push	 ebp
  0003b	8b ac 24 38 40
	00 00		 mov	 ebp, DWORD PTR _pSendUser$[esp+16432]
  00042	89 4c 24 08	 mov	 DWORD PTR $T341994[esp+16436], ecx
  00046	0f 84 fd 01 00
	00		 je	 $L282914
  0004c	56		 push	 esi
  0004d	57		 push	 edi

; 6173 : 		return;
; 6174 : 
; 6175 : 	CAr arBlock;

  0004e	33 ff		 xor	 edi, edi
  00050	57		 push	 edi
  00051	57		 push	 edi
  00052	8d 4c 24 20	 lea	 ecx, DWORD PTR _arBlock$[esp+16452]
  00056	e8 00 00 00 00	 call	 ??0CAr@@QAE@PAXI@Z	; CAr::CAr

; 6176 : 	arBlock << NULL_ID << SNAPSHOTTYPE_GUILDCOMBAT;

  0005b	6a 04		 push	 4
  0005d	8d 4c 24 1c	 lea	 ecx, DWORD PTR _arBlock$[esp+16448]
  00061	89 bc 24 3c 40
	00 00		 mov	 DWORD PTR __$EHRec$[esp+16456], edi
  00068	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0006d	8b 44 24 20	 mov	 eax, DWORD PTR _arBlock$[esp+16452]
  00071	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [eax], -1
  00077	8b 54 24 20	 mov	 edx, DWORD PTR _arBlock$[esp+16452]
  0007b	83 c2 04	 add	 edx, 4
  0007e	6a 02		 push	 2
  00080	8d 4c 24 1c	 lea	 ecx, DWORD PTR _arBlock$[esp+16448]
  00084	89 54 24 24	 mov	 DWORD PTR _arBlock$[esp+16456], edx
  00088	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0008d	8b 4c 24 20	 mov	 ecx, DWORD PTR _arBlock$[esp+16452]
  00091	66 c7 01 b8 00	 mov	 WORD PTR [ecx], 184	; 000000b8H
  00096	8b 44 24 20	 mov	 eax, DWORD PTR _arBlock$[esp+16452]
  0009a	83 c0 02	 add	 eax, 2

; 6177 : 	arBlock << GC_GUILDPRECEDENCE;

  0009d	53		 push	 ebx
  0009e	8d 4c 24 1c	 lea	 ecx, DWORD PTR _arBlock$[esp+16448]
  000a2	89 44 24 24	 mov	 DWORD PTR _arBlock$[esp+16456], eax
  000a6	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000ab	8b 54 24 20	 mov	 edx, DWORD PTR _arBlock$[esp+16452]
  000af	c6 02 21	 mov	 BYTE PTR [edx], 33	; 00000021H
  000b2	8b 54 24 20	 mov	 edx, DWORD PTR _arBlock$[esp+16452]

; 6178 : 
; 6179 : #ifdef __S_BUG_GC
; 6180 : 	arBlock << (int)g_GuildCombatMng.m_vecGuildCombatMem.size();

  000b6	a1 74 00 00 00	 mov	 eax, DWORD PTR ?g_GuildCombatMng@@3VCGuildCombat@@A+116
  000bb	42		 inc	 edx
  000bc	3b c7		 cmp	 eax, edi
  000be	89 54 24 20	 mov	 DWORD PTR _arBlock$[esp+16452], edx
  000c2	75 04		 jne	 SHORT $L341756
  000c4	33 f6		 xor	 esi, esi
  000c6	eb 0b		 jmp	 SHORT $L341757
$L341756:
  000c8	8b 35 78 00 00
	00		 mov	 esi, DWORD PTR ?g_GuildCombatMng@@3VCGuildCombat@@A+120
  000ce	2b f0		 sub	 esi, eax
  000d0	c1 fe 02	 sar	 esi, 2
$L341757:
  000d3	6a 04		 push	 4
  000d5	8d 4c 24 1c	 lea	 ecx, DWORD PTR _arBlock$[esp+16448]
  000d9	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000de	8b 44 24 20	 mov	 eax, DWORD PTR _arBlock$[esp+16452]
  000e2	89 30		 mov	 DWORD PTR [eax], esi
  000e4	8b 44 24 20	 mov	 eax, DWORD PTR _arBlock$[esp+16452]
  000e8	83 c0 04	 add	 eax, 4
$L342005:

; 6181 : 	for( int gcmi = 0 ; gcmi < (int)( g_GuildCombatMng.m_vecGuildCombatMem.size() ) ; ++gcmi )

  000eb	8b 0d 74 00 00
	00		 mov	 ecx, DWORD PTR ?g_GuildCombatMng@@3VCGuildCombat@@A+116
  000f1	85 c9		 test	 ecx, ecx
  000f3	89 44 24 20	 mov	 DWORD PTR _arBlock$[esp+16452], eax
  000f7	75 04		 jne	 SHORT $L341772
  000f9	33 c0		 xor	 eax, eax
  000fb	eb 0a		 jmp	 SHORT $L341773
$L341772:
  000fd	a1 78 00 00 00	 mov	 eax, DWORD PTR ?g_GuildCombatMng@@3VCGuildCombat@@A+120
  00102	2b c1		 sub	 eax, ecx
  00104	c1 f8 02	 sar	 eax, 2
$L341773:
  00107	3b f8		 cmp	 edi, eax
  00109	0f 8d 94 00 00
	00		 jge	 $L282923

; 6182 : 	{
; 6183 : 		CGuildCombat::__GuildCombatMember* pGCMember = g_GuildCombatMng.m_vecGuildCombatMem[gcmi];

  0010f	8b 34 b9	 mov	 esi, DWORD PTR [ecx+edi*4]

; 6184 : 		if( 0 < pGCMember->vecGCSelectMember.size() )

  00112	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00115	85 c9		 test	 ecx, ecx
  00117	74 68		 je	 SHORT $L282925
  00119	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  0011c	2b c1		 sub	 eax, ecx
  0011e	c1 f8 02	 sar	 eax, 2
  00121	85 c0		 test	 eax, eax
  00123	76 5c		 jbe	 SHORT $L282925

; 6185 : 		{			
; 6186 : 			arBlock << (BOOL)TRUE; // bSend;

  00125	6a 04		 push	 4
  00127	8d 4c 24 1c	 lea	 ecx, DWORD PTR _arBlock$[esp+16448]
  0012b	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00130	8b 4c 24 20	 mov	 ecx, DWORD PTR _arBlock$[esp+16452]
  00134	89 19		 mov	 DWORD PTR [ecx], ebx
  00136	83 44 24 20 04	 add	 DWORD PTR _arBlock$[esp+16452], 4

; 6187 : 			CGuild* pGuild = g_GuildMng.GetGuild( pGCMember->uGuildId );

  0013b	8b 16		 mov	 edx, DWORD PTR [esi]
  0013d	52		 push	 edx
  0013e	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_GuildMng@@3VCGuildMng@@A
  00143	e8 00 00 00 00	 call	 ?GetGuild@CGuildMng@@QAEPAVCGuild@@K@Z ; CGuildMng::GetGuild

; 6188 : 			if( pGuild )

  00148	85 c0		 test	 eax, eax

; 6189 : 				arBlock.WriteString( pGuild->m_szGuild );

  0014a	8d 4c 24 18	 lea	 ecx, DWORD PTR _arBlock$[esp+16444]
  0014e	74 06		 je	 SHORT $L282928
  00150	83 c0 08	 add	 eax, 8
  00153	50		 push	 eax

; 6190 : 			else

  00154	eb 05		 jmp	 SHORT $L342003
$L282928:

; 6191 : 				arBlock.WriteString( "Not Guild" );

  00156	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_09NNGGDJBM@Not?5Guild?$AA@
$L342003:
  0015b	e8 00 00 00 00	 call	 ?WriteString@CAr@@QAEXPBD@Z ; CAr::WriteString

; 6192 : 			arBlock << pGCMember->nGuildPoint;

  00160	8b 76 28	 mov	 esi, DWORD PTR [esi+40]
  00163	6a 04		 push	 4
  00165	8d 4c 24 1c	 lea	 ecx, DWORD PTR _arBlock$[esp+16448]
  00169	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0016e	8b 44 24 20	 mov	 eax, DWORD PTR _arBlock$[esp+16452]
  00172	89 30		 mov	 DWORD PTR [eax], esi

; 6193 : 		}
; 6194 : 		else
; 6195 : 		{
; 6196 : 			arBlock << (BOOL)FALSE; // bSend;

  00174	8b 44 24 20	 mov	 eax, DWORD PTR _arBlock$[esp+16452]
  00178	83 c0 04	 add	 eax, 4
  0017b	47		 inc	 edi
  0017c	e9 6a ff ff ff	 jmp	 $L342005
$L282925:
  00181	6a 04		 push	 4
  00183	8d 4c 24 1c	 lea	 ecx, DWORD PTR _arBlock$[esp+16448]
  00187	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0018c	8b 4c 24 20	 mov	 ecx, DWORD PTR _arBlock$[esp+16452]
  00190	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  00196	8b 44 24 20	 mov	 eax, DWORD PTR _arBlock$[esp+16452]
  0019a	83 c0 04	 add	 eax, 4
  0019d	47		 inc	 edi
  0019e	e9 48 ff ff ff	 jmp	 $L342005
$L282923:

; 6197 : 		}
; 6198 : 	}
; 6199 : #else // __S_BUG_GC
; 6200 : 	arBlock << (int)g_GuildCombatMng.m_GuildCombatMem.size();
; 6201 : 	for( map<u_long, CGuildCombat::__GuildCombatMember*>::iterator itGuild = g_GuildCombatMng.m_GuildCombatMem.begin();
; 6202 : 		itGuild != g_GuildCombatMng.m_GuildCombatMem.end(); ++itGuild )
; 6203 : 	{
; 6204 : 		CGuildCombat::__GuildCombatMember* pGCMember = itGuild->second;
; 6205 : 		if( 0 < pGCMember->vecGCSelectMember.size() )
; 6206 : 		{			
; 6207 : 			arBlock << (BOOL)TRUE; // bSend;
; 6208 : 			CGuild* pGuild = g_GuildMng.GetGuild( itGuild->first );
; 6209 : 			if( pGuild )
; 6210 : 				arBlock.WriteString( pGuild->m_szGuild );
; 6211 : 			else
; 6212 : 				arBlock.WriteString( "Not Guild" );
; 6213 : 			arBlock << pGCMember->nGuildPoint;
; 6214 : 		}
; 6215 : 		else
; 6216 : 		{
; 6217 : 			arBlock << (BOOL)FALSE; // bSend;
; 6218 : 		}		
; 6219 : 	}
; 6220 : #endif // __S_BUG_GC
; 6221 : 
; 6222 : 	GETBLOCK( arBlock, lpBlock, uBlockSize );

  001a3	8d 54 24 14	 lea	 edx, DWORD PTR _uBlockSize$[esp+16444]
  001a7	52		 push	 edx
  001a8	8d 4c 24 1c	 lea	 ecx, DWORD PTR _arBlock$[esp+16448]
  001ac	e8 00 00 00 00	 call	 ?GetBuffer@CAr@@QAEPAEPAH@Z ; CAr::GetBuffer

; 6223 : 	if( pSendUser == NULL )

  001b1	85 ed		 test	 ebp, ebp
  001b3	8b f0		 mov	 esi, eax
  001b5	75 5f		 jne	 SHORT $L282935

; 6224 : 	{
; 6225 : 		map<DWORD, CUser*>::iterator it;
; 6226 : 		for( it = m_users.begin(); it != m_users.end(); ++it )

  001b7	8b 7c 24 10	 mov	 edi, DWORD PTR $T341994[esp+16444]
  001bb	8b 4f 0c	 mov	 ecx, DWORD PTR [edi+12]
  001be	8b 01		 mov	 eax, DWORD PTR [ecx]
  001c0	3b c1		 cmp	 eax, ecx
  001c2	89 44 24 10	 mov	 DWORD PTR _it$282941[esp+16444], eax
  001c6	74 6b		 je	 SHORT $L341988
$L342000:

; 6227 : 		{
; 6228 : 			CUser* pUser = it->second;

  001c8	8b 40 10	 mov	 eax, DWORD PTR [eax+16]

; 6229 : 			if( pUser->IsValid() == FALSE )

  001cb	84 58 04	 test	 BYTE PTR [eax+4], bl
  001ce	75 30		 jne	 SHORT $L282945
  001d0	8b 88 e8 16 00
	00		 mov	 ecx, DWORD PTR [eax+5864]
  001d6	85 c9		 test	 ecx, ecx
  001d8	74 26		 je	 SHORT $L282945

; 6230 : 				continue;
; 6231 : 			if( pUser->GetWorld()->GetID() == WI_WORLD_GUILDWAR )

  001da	8b 88 6c 01 00
	00		 mov	 ecx, DWORD PTR [eax+364]
  001e0	81 39 ca 00 00
	00		 cmp	 DWORD PTR [ecx], 202	; 000000caH
  001e6	75 18		 jne	 SHORT $L282945

; 6232 : 				pUser->AddBlock( lpBlock, uBlockSize );

  001e8	8b 4c 24 14	 mov	 ecx, DWORD PTR _uBlockSize$[esp+16444]
  001ec	66 ff 80 0c 57
	00 00		 inc	 WORD PTR [eax+22284]
  001f3	51		 push	 ecx
  001f4	56		 push	 esi
  001f5	8d 88 f8 16 00
	00		 lea	 ecx, DWORD PTR [eax+5880]
  001fb	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
$L282945:
  00200	8d 4c 24 10	 lea	 ecx, DWORD PTR _it$282941[esp+16444]
  00204	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::const_iterator::_Inc
  00209	8b 4f 0c	 mov	 ecx, DWORD PTR [edi+12]
  0020c	8b 44 24 10	 mov	 eax, DWORD PTR _it$282941[esp+16444]
  00210	3b c1		 cmp	 eax, ecx
  00212	75 b4		 jne	 SHORT $L342000

; 6233 : 		}
; 6234 : 	}
; 6235 : 	else

  00214	eb 1d		 jmp	 SHORT $L341988
$L282935:

; 6236 : 	{
; 6237 : 		pSendUser->AddBlock( lpBlock, uBlockSize );

  00216	84 5d 04	 test	 BYTE PTR [ebp+4], bl
  00219	75 18		 jne	 SHORT $L341988
  0021b	8b 44 24 14	 mov	 eax, DWORD PTR _uBlockSize$[esp+16444]
  0021f	66 ff 85 0c 57
	00 00		 inc	 WORD PTR [ebp+22284]
  00226	50		 push	 eax
  00227	56		 push	 esi
  00228	8d 8d f8 16 00
	00		 lea	 ecx, DWORD PTR [ebp+5880]
  0022e	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
$L341988:

; 6238 : 	}
; 6239 : }

  00233	8d 4c 24 18	 lea	 ecx, DWORD PTR _arBlock$[esp+16444]
  00237	c7 84 24 38 40
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+16452], -1
  00242	e8 00 00 00 00	 call	 ??1CAr@@QAE@XZ		; CAr::~CAr
  00247	5f		 pop	 edi
  00248	5e		 pop	 esi
$L282914:
  00249	8b 8c 24 28 40
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+16436]
  00250	5d		 pop	 ebp
  00251	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00258	8b 8c 24 20 40
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+16432]
  0025f	5b		 pop	 ebx
  00260	33 cc		 xor	 ecx, esp
  00262	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00267	81 c4 2c 40 00
	00		 add	 esp, 16428		; 0000402cH
  0026d	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L341735:
  00000	8d 8d dc bf ff
	ff		 lea	 ecx, DWORD PTR _arBlock$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CAr@@QAE@XZ		; CAr::~CAr
__ehhandler$?AddGCGuildPrecedence@CUserMng@@QAEXPAVCUser@@@Z:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T341997
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?AddGCGuildPrecedence@CUserMng@@QAEXPAVCUser@@@Z ENDP	; CUserMng::AddGCGuildPrecedence
PUBLIC	?AddGCPlayerPrecedence@CUserMng@@QAEXPAVCUser@@@Z ; CUserMng::AddGCPlayerPrecedence
;	COMDAT xdata$x
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\obj.h
xdata$x	SEGMENT
$T342343 DD	0ffffffffH
	DD	FLAT:$L342015
$T342337 DD	019930520H
	DD	01H
	DD	FLAT:$T342343
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
xdata$x	ENDS
;	COMDAT ?AddGCPlayerPrecedence@CUserMng@@QAEXPAVCUser@@@Z
_TEXT	SEGMENT
_it$282980 = -16436					; size = 4
_gcmi$282959 = -16436					; size = 4
_uBlockSize$ = -16432					; size = 4
$T342335 = -16428					; size = 4
$T342334 = -16424					; size = 4
_arBlock$ = -16420					; size = 16404
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_pSendUser$ = 8						; size = 4
?AddGCPlayerPrecedence@CUserMng@@QAEXPAVCUser@@@Z PROC NEAR ; CUserMng::AddGCPlayerPrecedence, COMDAT
; _this$ = ecx

; 6241 : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?AddGCPlayerPrecedence@CUserMng@@QAEXPAVCUser@@@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	b8 28 40 00 00	 mov	 eax, 16424		; 00004028H
  00013	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0001a	e8 00 00 00 00	 call	 __chkstk
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00024	33 c4		 xor	 eax, esp
  00026	55		 push	 ebp
  00027	8b ac 24 3c 40
	00 00		 mov	 ebp, DWORD PTR _pSendUser$[esp+16436]
  0002e	89 84 24 28 40
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+16440], eax

; 6242 : 	if( g_GuildCombatMng.m_nState == CGuildCombat::CLOSE_STATE )

  00035	83 3d 40 11 00
	00 01		 cmp	 DWORD PTR ?g_GuildCombatMng@@3VCGuildCombat@@A+4416, 1
  0003c	57		 push	 edi
  0003d	8b f9		 mov	 edi, ecx

; 6255 : 		for( int veci = 0 ; veci < (int)( pGCMember->vecGCSelectMember.size() ) ; ++veci )

  0003f	89 7c 24 14	 mov	 DWORD PTR $T342334[esp+16444], edi
  00043	89 6c 24 10	 mov	 DWORD PTR $T342335[esp+16444], ebp
  00047	0f 84 16 02 00
	00		 je	 $L282954
  0004d	53		 push	 ebx
  0004e	56		 push	 esi
  0004f	33 f6		 xor	 esi, esi
  00051	56		 push	 esi
  00052	56		 push	 esi
  00053	8d 4c 24 28	 lea	 ecx, DWORD PTR _arBlock$[esp+16460]
  00057	e8 00 00 00 00	 call	 ??0CAr@@QAE@PAXI@Z	; CAr::CAr
  0005c	bb 04 00 00 00	 mov	 ebx, 4
  00061	53		 push	 ebx
  00062	8d 4c 24 24	 lea	 ecx, DWORD PTR _arBlock$[esp+16456]
  00066	89 b4 24 44 40
	00 00		 mov	 DWORD PTR __$EHRec$[esp+16464], esi
  0006d	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00072	8b 44 24 28	 mov	 eax, DWORD PTR _arBlock$[esp+16460]
  00076	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [eax], -1
  0007c	8b 44 24 28	 mov	 eax, DWORD PTR _arBlock$[esp+16460]
  00080	03 c3		 add	 eax, ebx
  00082	6a 02		 push	 2
  00084	8d 4c 24 24	 lea	 ecx, DWORD PTR _arBlock$[esp+16456]
  00088	89 44 24 2c	 mov	 DWORD PTR _arBlock$[esp+16464], eax
  0008c	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00091	8b 4c 24 28	 mov	 ecx, DWORD PTR _arBlock$[esp+16460]
  00095	66 c7 01 b8 00	 mov	 WORD PTR [ecx], 184	; 000000b8H
  0009a	83 44 24 28 02	 add	 DWORD PTR _arBlock$[esp+16460], 2
  0009f	6a 01		 push	 1
  000a1	8d 4c 24 24	 lea	 ecx, DWORD PTR _arBlock$[esp+16456]
  000a5	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000aa	8b 54 24 28	 mov	 edx, DWORD PTR _arBlock$[esp+16460]
  000ae	c6 02 22	 mov	 BYTE PTR [edx], 34	; 00000022H
  000b1	8b 54 24 28	 mov	 edx, DWORD PTR _arBlock$[esp+16460]
  000b5	a1 74 00 00 00	 mov	 eax, DWORD PTR ?g_GuildCombatMng@@3VCGuildCombat@@A+116
  000ba	42		 inc	 edx
  000bb	3b c6		 cmp	 eax, esi
  000bd	89 54 24 28	 mov	 DWORD PTR _arBlock$[esp+16460], edx
  000c1	74 0b		 je	 SHORT $L342036
  000c3	8b 35 78 00 00
	00		 mov	 esi, DWORD PTR ?g_GuildCombatMng@@3VCGuildCombat@@A+120
  000c9	2b f0		 sub	 esi, eax
  000cb	c1 fe 02	 sar	 esi, 2
$L342036:
  000ce	53		 push	 ebx
  000cf	8d 4c 24 24	 lea	 ecx, DWORD PTR _arBlock$[esp+16456]
  000d3	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000d8	8b 44 24 28	 mov	 eax, DWORD PTR _arBlock$[esp+16460]
  000dc	89 30		 mov	 DWORD PTR [eax], esi
  000de	8b 44 24 28	 mov	 eax, DWORD PTR _arBlock$[esp+16460]
  000e2	03 c3		 add	 eax, ebx
  000e4	33 d2		 xor	 edx, edx
  000e6	89 44 24 28	 mov	 DWORD PTR _arBlock$[esp+16460], eax
  000ea	89 54 24 10	 mov	 DWORD PTR _gcmi$282959[esp+16452], edx
  000ee	8b ff		 npad	 2
$L282961:
  000f0	8b 0d 74 00 00
	00		 mov	 ecx, DWORD PTR ?g_GuildCombatMng@@3VCGuildCombat@@A+116
  000f6	85 c9		 test	 ecx, ecx
  000f8	75 04		 jne	 SHORT $L342051

; 6243 : 		return;
; 6244 : 	
; 6245 : 	CAr arBlock;
; 6246 : 	arBlock << NULL_ID << SNAPSHOTTYPE_GUILDCOMBAT;
; 6247 : 	arBlock << GC_PLAYERPRECEDENCE;
; 6248 : 
; 6249 : #ifdef __S_BUG_GC
; 6250 : 	arBlock << (int)g_GuildCombatMng.m_vecGuildCombatMem.size();
; 6251 : 	for( int gcmi = 0 ; gcmi < (int)( g_GuildCombatMng.m_vecGuildCombatMem.size() ) ; ++gcmi )

  000fa	33 c0		 xor	 eax, eax
  000fc	eb 0a		 jmp	 SHORT $L342052
$L342051:
  000fe	a1 78 00 00 00	 mov	 eax, DWORD PTR ?g_GuildCombatMng@@3VCGuildCombat@@A+120
  00103	2b c1		 sub	 eax, ecx
  00105	c1 f8 02	 sar	 eax, 2
$L342052:
  00108	3b d0		 cmp	 edx, eax
  0010a	0f 8d aa 00 00
	00		 jge	 $L282963

; 6252 : 	{
; 6253 : 		CGuildCombat::__GuildCombatMember* pGCMember = g_GuildCombatMng.m_vecGuildCombatMem[gcmi];

  00110	8b 1c 91	 mov	 ebx, DWORD PTR [ecx+edx*4]

; 6254 : 		arBlock << (int)pGCMember->vecGCSelectMember.size();

  00113	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  00116	85 c0		 test	 eax, eax
  00118	75 04		 jne	 SHORT $L342113
  0011a	33 f6		 xor	 esi, esi
  0011c	eb 08		 jmp	 SHORT $L342114
$L342113:
  0011e	8b 73 0c	 mov	 esi, DWORD PTR [ebx+12]
  00121	2b f0		 sub	 esi, eax
  00123	c1 fe 02	 sar	 esi, 2
$L342114:
  00126	6a 04		 push	 4
  00128	8d 4c 24 24	 lea	 ecx, DWORD PTR _arBlock$[esp+16456]
  0012c	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00131	8b 4c 24 28	 mov	 ecx, DWORD PTR _arBlock$[esp+16460]
  00135	89 31		 mov	 DWORD PTR [ecx], esi
  00137	83 44 24 28 04	 add	 DWORD PTR _arBlock$[esp+16460], 4

; 6255 : 		for( int veci = 0 ; veci < (int)( pGCMember->vecGCSelectMember.size() ) ; ++veci )

  0013c	33 ff		 xor	 edi, edi
  0013e	8b ff		 npad	 2
$L282968:
  00140	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  00143	85 c9		 test	 ecx, ecx
  00145	75 04		 jne	 SHORT $L342130
  00147	33 c0		 xor	 eax, eax
  00149	eb 08		 jmp	 SHORT $L342131
$L342130:
  0014b	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]
  0014e	2b c1		 sub	 eax, ecx
  00150	c1 f8 02	 sar	 eax, 2
$L342131:
  00153	3b f8		 cmp	 edi, eax
  00155	7d 4f		 jge	 SHORT $L282962
  00157	8b 53 08	 mov	 edx, DWORD PTR [ebx+8]

; 6256 : 		{
; 6257 : 			CGuildCombat::__JOINPLAYER* pJoinPlayer = pGCMember->vecGCSelectMember[veci];

  0015a	8b 34 ba	 mov	 esi, DWORD PTR [edx+edi*4]

; 6258 : 			arBlock << pJoinPlayer->uidPlayer;

  0015d	8b 2e		 mov	 ebp, DWORD PTR [esi]
  0015f	8d 04 ba	 lea	 eax, DWORD PTR [edx+edi*4]
  00162	6a 04		 push	 4
  00164	8d 4c 24 24	 lea	 ecx, DWORD PTR _arBlock$[esp+16456]
  00168	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0016d	8b 44 24 28	 mov	 eax, DWORD PTR _arBlock$[esp+16460]
  00171	89 28		 mov	 DWORD PTR [eax], ebp
  00173	8b 44 24 28	 mov	 eax, DWORD PTR _arBlock$[esp+16460]
  00177	bd 04 00 00 00	 mov	 ebp, 4
  0017c	03 c5		 add	 eax, ebp
  0017e	89 44 24 28	 mov	 DWORD PTR _arBlock$[esp+16460], eax

; 6259 : 			arBlock << pJoinPlayer->nPoint;

  00182	8b 76 08	 mov	 esi, DWORD PTR [esi+8]
  00185	55		 push	 ebp
  00186	8d 4c 24 24	 lea	 ecx, DWORD PTR _arBlock$[esp+16456]
  0018a	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0018f	8b 4c 24 28	 mov	 ecx, DWORD PTR _arBlock$[esp+16460]
  00193	89 31		 mov	 DWORD PTR [ecx], esi
  00195	8b 4c 24 28	 mov	 ecx, DWORD PTR _arBlock$[esp+16460]
  00199	03 cd		 add	 ecx, ebp
  0019b	8b 6c 24 18	 mov	 ebp, DWORD PTR $T342335[esp+16452]
  0019f	89 4c 24 28	 mov	 DWORD PTR _arBlock$[esp+16460], ecx
  001a3	47		 inc	 edi
  001a4	eb 9a		 jmp	 SHORT $L282968
$L282962:

; 6243 : 		return;
; 6244 : 	
; 6245 : 	CAr arBlock;
; 6246 : 	arBlock << NULL_ID << SNAPSHOTTYPE_GUILDCOMBAT;
; 6247 : 	arBlock << GC_PLAYERPRECEDENCE;
; 6248 : 
; 6249 : #ifdef __S_BUG_GC
; 6250 : 	arBlock << (int)g_GuildCombatMng.m_vecGuildCombatMem.size();
; 6251 : 	for( int gcmi = 0 ; gcmi < (int)( g_GuildCombatMng.m_vecGuildCombatMem.size() ) ; ++gcmi )

  001a6	8b 44 24 10	 mov	 eax, DWORD PTR _gcmi$282959[esp+16452]
  001aa	8b 7c 24 1c	 mov	 edi, DWORD PTR $T342334[esp+16452]
  001ae	40		 inc	 eax
  001af	89 44 24 10	 mov	 DWORD PTR _gcmi$282959[esp+16452], eax
  001b3	8b d0		 mov	 edx, eax
  001b5	e9 36 ff ff ff	 jmp	 $L282961
$L282963:

; 6260 : 		}
; 6261 : 	}
; 6262 : #else // __S_BUG_GC
; 6263 : 	arBlock << (int)g_GuildCombatMng.m_GuildCombatMem.size();
; 6264 : 	for( map<u_long, CGuildCombat::__GuildCombatMember*>::iterator itGuild = g_GuildCombatMng.m_GuildCombatMem.begin();
; 6265 : 	itGuild != g_GuildCombatMng.m_GuildCombatMem.end(); ++itGuild )
; 6266 : 	{
; 6267 : 		CGuildCombat::__GuildCombatMember* pGCMember = itGuild->second;
; 6268 : 		arBlock << (int)pGCMember->vecGCSelectMember.size();
; 6269 : 		for( int veci = 0 ; veci < pGCMember->vecGCSelectMember.size() ; ++veci )
; 6270 : 		{
; 6271 : 			CGuildCombat::__JOINPLAYER* pJoinPlayer = pGCMember->vecGCSelectMember[veci];
; 6272 : 			arBlock << pJoinPlayer->uidPlayer;
; 6273 : 			arBlock << pJoinPlayer->nPoint;
; 6274 : 		}
; 6275 : 	}
; 6276 : #endif // __S_BUG_GC
; 6277 : 
; 6278 : 	GETBLOCK( arBlock, lpBlock, uBlockSize );

  001ba	8d 54 24 14	 lea	 edx, DWORD PTR _uBlockSize$[esp+16452]
  001be	52		 push	 edx
  001bf	8d 4c 24 24	 lea	 ecx, DWORD PTR _arBlock$[esp+16456]
  001c3	e8 00 00 00 00	 call	 ?GetBuffer@CAr@@QAEPAEPAH@Z ; CAr::GetBuffer

; 6279 : 	
; 6280 : 	if( pSendUser == NULL )

  001c8	85 ed		 test	 ebp, ebp
  001ca	8b f0		 mov	 esi, eax
  001cc	75 61		 jne	 SHORT $L282974

; 6281 : 	{
; 6282 : 		map<DWORD, CUser*>::iterator it;
; 6283 : 		for( it = m_users.begin(); it != m_users.end(); ++it )

  001ce	8b 4f 0c	 mov	 ecx, DWORD PTR [edi+12]
  001d1	8b 01		 mov	 eax, DWORD PTR [ecx]
  001d3	3b c1		 cmp	 eax, ecx
  001d5	89 44 24 10	 mov	 DWORD PTR _it$282980[esp+16452], eax
  001d9	74 72		 je	 SHORT $L342331
  001db	eb 03 8d 49 00	 npad	 5
$L342246:

; 6284 : 		{
; 6285 : 			CUser* pUser = it->second;

  001e0	8b 40 10	 mov	 eax, DWORD PTR [eax+16]

; 6286 : 			if( pUser->IsValid() == FALSE )

  001e3	f6 40 04 01	 test	 BYTE PTR [eax+4], 1
  001e7	75 30		 jne	 SHORT $L282984
  001e9	8b 88 e8 16 00
	00		 mov	 ecx, DWORD PTR [eax+5864]
  001ef	85 c9		 test	 ecx, ecx
  001f1	74 26		 je	 SHORT $L282984

; 6287 : 				continue;
; 6288 : 			
; 6289 : 			if( pUser->GetWorld()->GetID() == WI_WORLD_GUILDWAR )

  001f3	8b 88 6c 01 00
	00		 mov	 ecx, DWORD PTR [eax+364]
  001f9	81 39 ca 00 00
	00		 cmp	 DWORD PTR [ecx], 202	; 000000caH
  001ff	75 18		 jne	 SHORT $L282984

; 6290 : 			{
; 6291 : 				pUser->AddBlock( lpBlock, uBlockSize );

  00201	8b 4c 24 14	 mov	 ecx, DWORD PTR _uBlockSize$[esp+16452]
  00205	66 ff 80 0c 57
	00 00		 inc	 WORD PTR [eax+22284]
  0020c	51		 push	 ecx
  0020d	56		 push	 esi
  0020e	8d 88 f8 16 00
	00		 lea	 ecx, DWORD PTR [eax+5880]
  00214	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
$L282984:
  00219	8d 4c 24 10	 lea	 ecx, DWORD PTR _it$282980[esp+16452]
  0021d	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::const_iterator::_Inc
  00222	8b 4f 0c	 mov	 ecx, DWORD PTR [edi+12]
  00225	8b 44 24 10	 mov	 eax, DWORD PTR _it$282980[esp+16452]
  00229	3b c1		 cmp	 eax, ecx
  0022b	75 b3		 jne	 SHORT $L342246

; 6292 : 			}
; 6293 : 		}
; 6294 : 	}
; 6295 : 	else

  0022d	eb 1e		 jmp	 SHORT $L342331
$L282974:

; 6296 : 	{
; 6297 : 		pSendUser->AddBlock( lpBlock, uBlockSize );

  0022f	f6 45 04 01	 test	 BYTE PTR [ebp+4], 1
  00233	75 18		 jne	 SHORT $L342331
  00235	8b 44 24 14	 mov	 eax, DWORD PTR _uBlockSize$[esp+16452]
  00239	66 ff 85 0c 57
	00 00		 inc	 WORD PTR [ebp+22284]
  00240	50		 push	 eax
  00241	56		 push	 esi
  00242	8d 8d f8 16 00
	00		 lea	 ecx, DWORD PTR [ebp+5880]
  00248	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
$L342331:

; 6298 : 	}
; 6299 : }

  0024d	8d 4c 24 20	 lea	 ecx, DWORD PTR _arBlock$[esp+16452]
  00251	c7 84 24 40 40
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+16460], -1
  0025c	e8 00 00 00 00	 call	 ??1CAr@@QAE@XZ		; CAr::~CAr
  00261	5e		 pop	 esi
  00262	5b		 pop	 ebx
$L282954:
  00263	8b 8c 24 30 40
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+16444]
  0026a	5f		 pop	 edi
  0026b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00272	8b 8c 24 28 40
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+16440]
  00279	5d		 pop	 ebp
  0027a	33 cc		 xor	 ecx, esp
  0027c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00281	81 c4 34 40 00
	00		 add	 esp, 16436		; 00004034H
  00287	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L342015:
  00000	8d 8d dc bf ff
	ff		 lea	 ecx, DWORD PTR _arBlock$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CAr@@QAE@XZ		; CAr::~CAr
__ehhandler$?AddGCPlayerPrecedence@CUserMng@@QAEXPAVCUser@@@Z:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T342337
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?AddGCPlayerPrecedence@CUserMng@@QAEXPAVCUser@@@Z ENDP	; CUserMng::AddGCPlayerPrecedence
PUBLIC	??1logic_error@std@@UAE@XZ			; std::logic_error::~logic_error
PUBLIC	?what@logic_error@std@@UBEPBDXZ			; std::logic_error::what
PUBLIC	??_7logic_error@std@@6B@			; std::logic_error::`vftable'
PUBLIC	??_Glogic_error@std@@UAEPAXI@Z			; std::logic_error::`scalar deleting destructor'
EXTRN	??1exception@@UAE@XZ:NEAR			; exception::~exception
EXTRN	??_Elogic_error@std@@UAEPAXI@Z:NEAR		; std::logic_error::`vector deleting destructor'
;	COMDAT ??_7logic_error@std@@6B@
; File c:\program files\microsoft visual studio .net 2003\vc7\include\iosfwd
CONST	SEGMENT
??_7logic_error@std@@6B@ DD FLAT:??_Elogic_error@std@@UAEPAXI@Z ; std::logic_error::`vftable'
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\stdexcept
CONST	ENDS
;	COMDAT ??1logic_error@std@@UAE@XZ
_TEXT	SEGMENT
??1logic_error@std@@UAE@XZ PROC NEAR			; std::logic_error::~logic_error, COMDAT
; _this$ = ecx

; 23   : 		{}	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7logic_error@std@@6B@
  00009	83 7e 24 10	 cmp	 DWORD PTR [esi+36], 16	; 00000010H
  0000d	72 0c		 jb	 SHORT $L342406
  0000f	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00018	83 c4 04	 add	 esp, 4
$L342406:
  0001b	33 c0		 xor	 eax, eax
  0001d	c7 46 24 0f 00
	00 00		 mov	 DWORD PTR [esi+36], 15	; 0000000fH
  00024	89 46 20	 mov	 DWORD PTR [esi+32], eax
  00027	88 46 10	 mov	 BYTE PTR [esi+16], al
  0002a	8b ce		 mov	 ecx, esi
  0002c	5e		 pop	 esi
  0002d	e9 00 00 00 00	 jmp	 ??1exception@@UAE@XZ	; exception::~exception
??1logic_error@std@@UAE@XZ ENDP				; std::logic_error::~logic_error
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT
?what@logic_error@std@@UBEPBDXZ PROC NEAR		; std::logic_error::what, COMDAT
; _this$ = ecx

; 27   : 		return (_Str.c_str());

  00000	83 79 24 10	 cmp	 DWORD PTR [ecx+36], 16	; 00000010H
  00004	72 04		 jb	 SHORT $L342439
  00006	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]

; 28   : 		}

  00009	c3		 ret	 0

; 27   : 		return (_Str.c_str());

$L342439:
  0000a	8d 41 10	 lea	 eax, DWORD PTR [ecx+16]

; 28   : 		}

  0000d	c3		 ret	 0
?what@logic_error@std@@UBEPBDXZ ENDP			; std::logic_error::what
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Glogic_error@std@@UAEPAXI@Z PROC NEAR		; std::logic_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	e8 00 00 00 00	 call	 ??1logic_error@std@@UAE@XZ ; std::logic_error::~logic_error
  00008	f6 44 24 08 01	 test	 BYTE PTR ___flags$[esp], 1
  0000d	74 09		 je	 SHORT $L342447
  0000f	56		 push	 esi
  00010	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00015	83 c4 04	 add	 esp, 4
$L342447:
  00018	8b c6		 mov	 eax, esi
  0001a	5e		 pop	 esi
  0001b	c2 04 00	 ret	 4
??_Glogic_error@std@@UAEPAXI@Z ENDP			; std::logic_error::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?AddGCSelectPlayerWindow@CUser@@QAEXAAV?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@KHH@Z ; CUser::AddGCSelectPlayerWindow
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
;	COMDAT ?AddGCSelectPlayerWindow@CUser@@QAEXAAV?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@KHH@Z
_TEXT	SEGMENT
_JoinPlayer$283559 = -24				; size = 24
_vecSelectPlayer$ = 8					; size = 4
_uidDefender$ = 12					; size = 4
_bWindow$ = 16						; size = 4
tv141 = 20						; size = 4
_bRequestWar$ = 20					; size = 4
?AddGCSelectPlayerWindow@CUser@@QAEXAAV?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@KHH@Z PROC NEAR ; CUser::AddGCSelectPlayerWindow, COMDAT
; _this$ = ecx

; 6842 : 	if( IsDelete() )	return;

  00000	8a 41 04	 mov	 al, BYTE PTR [ecx+4]
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	a8 01		 test	 al, 1
  00008	0f 85 8a 01 00
	00		 jne	 $L283558

; 6843 : 	
; 6844 : 	m_Snapshot.cb++;

  0000e	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  00015	53		 push	 ebx
  00016	55		 push	 ebp
  00017	56		 push	 esi
  00018	57		 push	 edi

; 6845 : 	m_Snapshot.ar << GetId();

  00019	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  0001f	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  00025	bd 04 00 00 00	 mov	 ebp, 4
  0002a	55		 push	 ebp
  0002b	8b ce		 mov	 ecx, esi
  0002d	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00032	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00035	89 38		 mov	 DWORD PTR [eax], edi
  00037	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0003a	03 d5		 add	 edx, ebp

; 6846 : 	m_Snapshot.ar << SNAPSHOTTYPE_GUILDCOMBAT;

  0003c	6a 02		 push	 2
  0003e	8b ce		 mov	 ecx, esi
  00040	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00043	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00048	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0004b	66 c7 01 b8 00	 mov	 WORD PTR [ecx], 184	; 000000b8H
  00050	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00053	83 c0 02	 add	 eax, 2

; 6847 : 	m_Snapshot.ar << GC_SELECTPLAYER;

  00056	6a 01		 push	 1
  00058	8b ce		 mov	 ecx, esi
  0005a	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0005d	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00062	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00065	c6 02 05	 mov	 BYTE PTR [edx], 5
  00068	ff 46 08	 inc	 DWORD PTR [esi+8]

; 6848 : 	m_Snapshot.ar << g_GuildCombatMng.m_nMaxJoinMember;

  0006b	8b 3d a4 10 00
	00		 mov	 edi, DWORD PTR ?g_GuildCombatMng@@3VCGuildCombat@@A+4260
  00071	55		 push	 ebp
  00072	8b ce		 mov	 ecx, esi
  00074	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00079	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0007c	89 38		 mov	 DWORD PTR [eax], edi
  0007e	01 6e 08	 add	 DWORD PTR [esi+8], ebp

; 6849 : 	m_Snapshot.ar << g_GuildCombatMng.m_nMaxWarPlayer;

  00081	8b 3d ac 10 00
	00		 mov	 edi, DWORD PTR ?g_GuildCombatMng@@3VCGuildCombat@@A+4268
  00087	55		 push	 ebp
  00088	8b ce		 mov	 ecx, esi
  0008a	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0008f	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00092	89 39		 mov	 DWORD PTR [ecx], edi
  00094	8b 5e 08	 mov	 ebx, DWORD PTR [esi+8]
  00097	03 dd		 add	 ebx, ebp

; 6850 : 
; 6851 : 	m_Snapshot.ar << bRequestWar;

  00099	55		 push	 ebp
  0009a	8b ce		 mov	 ecx, esi
  0009c	89 5e 08	 mov	 DWORD PTR [esi+8], ebx
  0009f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000a4	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  000a7	8b 44 24 38	 mov	 eax, DWORD PTR _bRequestWar$[esp+36]
  000ab	89 02		 mov	 DWORD PTR [edx], eax
  000ad	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  000b0	03 d5		 add	 edx, ebp

; 6852 : 	if( bRequestWar )

  000b2	85 c0		 test	 eax, eax
  000b4	89 56 08	 mov	 DWORD PTR [esi+8], edx
  000b7	0f 84 d7 00 00
	00		 je	 $L342589

; 6853 : 	{
; 6854 : 		m_Snapshot.ar << bWindow;

  000bd	55		 push	 ebp
  000be	8b ce		 mov	 ecx, esi
  000c0	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000c5	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  000c8	8b 44 24 34	 mov	 eax, DWORD PTR _bWindow$[esp+36]
  000cc	89 01		 mov	 DWORD PTR [ecx], eax
  000ce	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  000d1	03 d5		 add	 edx, ebp

; 6855 : 		if( bWindow )

  000d3	85 c0		 test	 eax, eax
  000d5	89 56 08	 mov	 DWORD PTR [esi+8], edx
  000d8	0f 84 b6 00 00
	00		 je	 $L342589

; 6856 : 		{
; 6857 : 			m_Snapshot.ar << uidDefender;

  000de	55		 push	 ebp
  000df	8b ce		 mov	 ecx, esi
  000e1	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000e6	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  000e9	8b 44 24 30	 mov	 eax, DWORD PTR _uidDefender$[esp+36]

; 6858 : 			int nSize = vecSelectPlayer.size();

  000ed	8b 4c 24 2c	 mov	 ecx, DWORD PTR _vecSelectPlayer$[esp+36]
  000f1	89 02		 mov	 DWORD PTR [edx], eax
  000f3	01 6e 08	 add	 DWORD PTR [esi+8], ebp
  000f6	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  000f9	85 c0		 test	 eax, eax
  000fb	75 04		 jne	 SHORT $L342517
  000fd	33 db		 xor	 ebx, ebx
  000ff	eb 16		 jmp	 SHORT $L342518
$L342517:
  00101	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  00104	2b c8		 sub	 ecx, eax
  00106	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0010b	f7 e9		 imul	 ecx
  0010d	c1 fa 02	 sar	 edx, 2
  00110	8b da		 mov	 ebx, edx
  00112	c1 eb 1f	 shr	 ebx, 31			; 0000001fH
  00115	03 da		 add	 ebx, edx
$L342518:

; 6859 : 			m_Snapshot.ar << nSize;

  00117	55		 push	 ebp
  00118	8b ce		 mov	 ecx, esi
  0011a	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0011f	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00122	89 19		 mov	 DWORD PTR [ecx], ebx
  00124	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00127	03 cd		 add	 ecx, ebp

; 6860 : 			for( int i = 0 ; i < nSize ; ++i )

  00129	85 db		 test	 ebx, ebx
  0012b	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  0012e	7e 64		 jle	 SHORT $L342589
  00130	33 ff		 xor	 edi, edi
  00132	89 5c 24 38	 mov	 DWORD PTR tv141[esp+36], ebx
  00136	eb 08 8d a4 24
	00 00 00 00 90	 npad	 10
$L283556:

; 6861 : 			{
; 6862 : 				CGuildCombat::__JOINPLAYER JoinPlayer = vecSelectPlayer[i];

  00140	8b 54 24 2c	 mov	 edx, DWORD PTR _vecSelectPlayer$[esp+36]
  00144	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00147	8b 4c 38 04	 mov	 ecx, DWORD PTR [eax+edi+4]
  0014b	8b 54 38 08	 mov	 edx, DWORD PTR [eax+edi+8]
  0014f	8b 1c 38	 mov	 ebx, DWORD PTR [eax+edi]
  00152	03 c7		 add	 eax, edi
  00154	89 4c 24 14	 mov	 DWORD PTR _JoinPlayer$283559[esp+44], ecx
  00158	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0015b	89 54 24 18	 mov	 DWORD PTR _JoinPlayer$283559[esp+48], edx
  0015f	8b 50 10	 mov	 edx, DWORD PTR [eax+16]
  00162	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  00165	89 4c 24 1c	 mov	 DWORD PTR _JoinPlayer$283559[esp+52], ecx

; 6863 : 				m_Snapshot.ar << JoinPlayer.uidPlayer;

  00169	55		 push	 ebp
  0016a	8b ce		 mov	 ecx, esi
  0016c	89 54 24 24	 mov	 DWORD PTR _JoinPlayer$283559[esp+60], edx
  00170	89 44 24 28	 mov	 DWORD PTR _JoinPlayer$283559[esp+64], eax
  00174	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00179	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0017c	8b 44 24 38	 mov	 eax, DWORD PTR tv141[esp+36]
  00180	89 19		 mov	 DWORD PTR [ecx], ebx
  00182	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00185	03 d5		 add	 edx, ebp
  00187	83 c7 18	 add	 edi, 24			; 00000018H
  0018a	48		 dec	 eax
  0018b	89 56 08	 mov	 DWORD PTR [esi+8], edx
  0018e	89 44 24 38	 mov	 DWORD PTR tv141[esp+36], eax
  00192	75 ac		 jne	 SHORT $L283556
$L342589:
  00194	5f		 pop	 edi
  00195	5e		 pop	 esi
  00196	5d		 pop	 ebp
  00197	5b		 pop	 ebx
$L283558:

; 6864 : 			}	
; 6865 : 		}
; 6866 : 	}
; 6867 : 	
; 6868 : }

  00198	83 c4 18	 add	 esp, 24			; 00000018H
  0019b	c2 10 00	 ret	 16			; 00000010H
?AddGCSelectPlayerWindow@CUser@@QAEXAAV?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@KHH@Z ENDP ; CUser::AddGCSelectPlayerWindow
_TEXT	ENDS
PUBLIC	?AddGCLog@CUser@@QAEXXZ				; CUser::AddGCLog
; Function compile flags: /Ogty
;	COMDAT ?AddGCLog@CUser@@QAEXXZ
_TEXT	SEGMENT
_veci$283647 = -44					; size = 4
tv475 = -40						; size = 4
_GCGetPoint$283652 = -36				; size = 36
?AddGCLog@CUser@@QAEXXZ PROC NEAR			; CUser::AddGCLog, COMDAT
; _this$ = ecx

; 7019 : 	if( IsDelete() )	return;

  00000	8a 41 04	 mov	 al, BYTE PTR [ecx+4]
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	a8 01		 test	 al, 1
  00008	0f 85 ce 01 00
	00		 jne	 $L283651

; 7020 : 	
; 7021 : 	m_Snapshot.cb++;

  0000e	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  00015	53		 push	 ebx
  00016	55		 push	 ebp
  00017	56		 push	 esi

; 7022 : 	m_Snapshot.ar << GetId();

  00018	8b b1 bc 01 00
	00		 mov	 esi, DWORD PTR [ecx+444]
  0001e	57		 push	 edi
  0001f	8d 99 f8 16 00
	00		 lea	 ebx, DWORD PTR [ecx+5880]
  00025	bd 04 00 00 00	 mov	 ebp, 4
  0002a	55		 push	 ebp
  0002b	8b cb		 mov	 ecx, ebx
  0002d	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00032	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  00035	89 30		 mov	 DWORD PTR [eax], esi
  00037	01 6b 08	 add	 DWORD PTR [ebx+8], ebp

; 7023 : 	m_Snapshot.ar << SNAPSHOTTYPE_GUILDCOMBAT;

  0003a	6a 02		 push	 2
  0003c	8b cb		 mov	 ecx, ebx
  0003e	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00043	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  00046	66 c7 01 b8 00	 mov	 WORD PTR [ecx], 184	; 000000b8H
  0004b	8b 7b 08	 mov	 edi, DWORD PTR [ebx+8]
  0004e	83 c7 02	 add	 edi, 2

; 7024 : 	m_Snapshot.ar << GC_LOG;

  00051	6a 01		 push	 1
  00053	8b cb		 mov	 ecx, ebx
  00055	89 7b 08	 mov	 DWORD PTR [ebx+8], edi
  00058	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0005d	8b 53 08	 mov	 edx, DWORD PTR [ebx+8]
  00060	c6 02 35	 mov	 BYTE PTR [edx], 53	; 00000035H
  00063	ff 43 08	 inc	 DWORD PTR [ebx+8]

; 7025 : 	m_Snapshot.ar << (u_long)g_GuildCombatMng.m_vecGCGetPoint.size();

  00066	a1 54 00 00 00	 mov	 eax, DWORD PTR ?g_GuildCombatMng@@3VCGuildCombat@@A+84
  0006b	33 ff		 xor	 edi, edi
  0006d	3b c7		 cmp	 eax, edi
  0006f	75 04		 jne	 SHORT $L342620
  00071	33 f6		 xor	 esi, esi
  00073	eb 19		 jmp	 SHORT $L342621
$L342620:
  00075	8b 0d 58 00 00
	00		 mov	 ecx, DWORD PTR ?g_GuildCombatMng@@3VCGuildCombat@@A+88
  0007b	2b c8		 sub	 ecx, eax
  0007d	b8 39 8e e3 38	 mov	 eax, 954437177		; 38e38e39H
  00082	f7 e9		 imul	 ecx
  00084	c1 fa 03	 sar	 edx, 3
  00087	8b f2		 mov	 esi, edx
  00089	c1 ee 1f	 shr	 esi, 31			; 0000001fH
  0008c	03 f2		 add	 esi, edx
$L342621:
  0008e	55		 push	 ebp
  0008f	8b cb		 mov	 ecx, ebx
  00091	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00096	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  00099	89 30		 mov	 DWORD PTR [eax], esi
  0009b	01 6b 08	 add	 DWORD PTR [ebx+8], ebp

; 7026 : 	for( int veci = 0 ; veci < (int)( g_GuildCombatMng.m_vecGCGetPoint.size() ) ; ++veci )

  0009e	89 7c 24 10	 mov	 DWORD PTR _veci$283647[esp+60], edi
  000a2	89 7c 24 14	 mov	 DWORD PTR tv475[esp+60], edi
$L283649:
  000a6	8b 35 54 00 00
	00		 mov	 esi, DWORD PTR ?g_GuildCombatMng@@3VCGuildCombat@@A+84
  000ac	85 f6		 test	 esi, esi
  000ae	75 04		 jne	 SHORT $L342632
  000b0	33 c0		 xor	 eax, eax
  000b2	eb 19		 jmp	 SHORT $L342633
$L342632:
  000b4	8b 0d 58 00 00
	00		 mov	 ecx, DWORD PTR ?g_GuildCombatMng@@3VCGuildCombat@@A+88
  000ba	2b ce		 sub	 ecx, esi
  000bc	b8 39 8e e3 38	 mov	 eax, 954437177		; 38e38e39H
  000c1	f7 e9		 imul	 ecx
  000c3	c1 fa 03	 sar	 edx, 3
  000c6	8b c2		 mov	 eax, edx
  000c8	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  000cb	03 c2		 add	 eax, edx
$L342633:
  000cd	39 44 24 10	 cmp	 DWORD PTR _veci$283647[esp+60], eax
  000d1	0f 8d 01 01 00
	00		 jge	 $L342751

; 7027 : 	{
; 7028 : 		CGuildCombat::__GCGETPOINT GCGetPoint = g_GuildCombatMng.m_vecGCGetPoint[ veci ];

  000d7	8b 4c 24 14	 mov	 ecx, DWORD PTR tv475[esp+60]
  000db	03 f1		 add	 esi, ecx
  000dd	b9 09 00 00 00	 mov	 ecx, 9
  000e2	8d 7c 24 18	 lea	 edi, DWORD PTR _GCGetPoint$283652[esp+60]
  000e6	f3 a5		 rep movsd

; 7029 : 		m_Snapshot.ar << GCGetPoint.uidGuildAttack;

  000e8	55		 push	 ebp
  000e9	8b cb		 mov	 ecx, ebx
  000eb	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000f0	8b 53 08	 mov	 edx, DWORD PTR [ebx+8]
  000f3	8b 44 24 18	 mov	 eax, DWORD PTR _GCGetPoint$283652[esp+60]
  000f7	89 02		 mov	 DWORD PTR [edx], eax
  000f9	8b 73 08	 mov	 esi, DWORD PTR [ebx+8]
  000fc	03 f5		 add	 esi, ebp

; 7030 : 		m_Snapshot.ar << GCGetPoint.uidGuildDefence;

  000fe	55		 push	 ebp
  000ff	8b cb		 mov	 ecx, ebx
  00101	89 73 08	 mov	 DWORD PTR [ebx+8], esi
  00104	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00109	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  0010c	8b 54 24 1c	 mov	 edx, DWORD PTR _GCGetPoint$283652[esp+64]
  00110	89 11		 mov	 DWORD PTR [ecx], edx
  00112	01 6b 08	 add	 DWORD PTR [ebx+8], ebp

; 7031 : 		m_Snapshot.ar << GCGetPoint.uidPlayerAttack;

  00115	55		 push	 ebp
  00116	8b cb		 mov	 ecx, ebx
  00118	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0011d	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  00120	8b 4c 24 20	 mov	 ecx, DWORD PTR _GCGetPoint$283652[esp+68]
  00124	89 08		 mov	 DWORD PTR [eax], ecx
  00126	8b 7b 08	 mov	 edi, DWORD PTR [ebx+8]
  00129	03 fd		 add	 edi, ebp

; 7032 : 		m_Snapshot.ar << GCGetPoint.uidPlayerDefence;

  0012b	55		 push	 ebp
  0012c	8b cb		 mov	 ecx, ebx
  0012e	89 7b 08	 mov	 DWORD PTR [ebx+8], edi
  00131	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00136	8b 53 08	 mov	 edx, DWORD PTR [ebx+8]
  00139	8b 44 24 24	 mov	 eax, DWORD PTR _GCGetPoint$283652[esp+72]
  0013d	89 02		 mov	 DWORD PTR [edx], eax
  0013f	8b 53 08	 mov	 edx, DWORD PTR [ebx+8]
  00142	03 d5		 add	 edx, ebp

; 7033 : 		m_Snapshot.ar << GCGetPoint.nPoint;

  00144	55		 push	 ebp
  00145	8b cb		 mov	 ecx, ebx
  00147	89 53 08	 mov	 DWORD PTR [ebx+8], edx
  0014a	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0014f	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  00152	8b 54 24 28	 mov	 edx, DWORD PTR _GCGetPoint$283652[esp+76]
  00156	89 11		 mov	 DWORD PTR [ecx], edx
  00158	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  0015b	03 c5		 add	 eax, ebp

; 7034 : 		m_Snapshot.ar << GCGetPoint.bKillDiffernceGuild;

  0015d	55		 push	 ebp
  0015e	8b cb		 mov	 ecx, ebx
  00160	89 43 08	 mov	 DWORD PTR [ebx+8], eax
  00163	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00168	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  0016b	8b 4c 24 2c	 mov	 ecx, DWORD PTR _GCGetPoint$283652[esp+80]
  0016f	89 08		 mov	 DWORD PTR [eax], ecx
  00171	8b 73 08	 mov	 esi, DWORD PTR [ebx+8]
  00174	03 f5		 add	 esi, ebp

; 7035 : 		m_Snapshot.ar << GCGetPoint.bMaster;

  00176	55		 push	 ebp
  00177	8b cb		 mov	 ecx, ebx
  00179	89 73 08	 mov	 DWORD PTR [ebx+8], esi
  0017c	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00181	8b 53 08	 mov	 edx, DWORD PTR [ebx+8]
  00184	8b 44 24 30	 mov	 eax, DWORD PTR _GCGetPoint$283652[esp+84]
  00188	89 02		 mov	 DWORD PTR [edx], eax
  0018a	01 6b 08	 add	 DWORD PTR [ebx+8], ebp

; 7036 : 		m_Snapshot.ar << GCGetPoint.bDefender;

  0018d	55		 push	 ebp
  0018e	8b cb		 mov	 ecx, ebx
  00190	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00195	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  00198	8b 54 24 34	 mov	 edx, DWORD PTR _GCGetPoint$283652[esp+88]
  0019c	89 11		 mov	 DWORD PTR [ecx], edx
  0019e	8b 7b 08	 mov	 edi, DWORD PTR [ebx+8]
  001a1	03 fd		 add	 edi, ebp

; 7037 : 		m_Snapshot.ar << GCGetPoint.bLastLife;

  001a3	55		 push	 ebp
  001a4	8b cb		 mov	 ecx, ebx
  001a6	89 7b 08	 mov	 DWORD PTR [ebx+8], edi
  001a9	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  001ae	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  001b1	8b 4c 24 38	 mov	 ecx, DWORD PTR _GCGetPoint$283652[esp+92]
  001b5	89 08		 mov	 DWORD PTR [eax], ecx
  001b7	8b 53 08	 mov	 edx, DWORD PTR [ebx+8]
  001ba	8b 4c 24 10	 mov	 ecx, DWORD PTR _veci$283647[esp+60]
  001be	8b 44 24 14	 mov	 eax, DWORD PTR tv475[esp+60]
  001c2	03 d5		 add	 edx, ebp
  001c4	41		 inc	 ecx
  001c5	83 c0 24	 add	 eax, 36			; 00000024H
  001c8	89 53 08	 mov	 DWORD PTR [ebx+8], edx
  001cb	89 4c 24 10	 mov	 DWORD PTR _veci$283647[esp+60], ecx
  001cf	89 44 24 14	 mov	 DWORD PTR tv475[esp+60], eax
  001d3	e9 ce fe ff ff	 jmp	 $L283649
$L342751:
  001d8	5f		 pop	 edi
  001d9	5e		 pop	 esi
  001da	5d		 pop	 ebp
  001db	5b		 pop	 ebx
$L283651:

; 7038 : 	}
; 7039 : 	
; 7040 : }

  001dc	83 c4 2c	 add	 esp, 44			; 0000002cH
  001df	c3		 ret	 0
?AddGCLog@CUser@@QAEXXZ ENDP				; CUser::AddGCLog
_TEXT	ENDS
PUBLIC	?AddGCPlayerPoint@CUser@@QAEXXZ			; CUser::AddGCPlayerPoint
; Function compile flags: /Ogty
;	COMDAT ?AddGCPlayerPoint@CUser@@QAEXXZ
_TEXT	SEGMENT
_veci$283660 = -8					; size = 4
tv325 = -4						; size = 4
?AddGCPlayerPoint@CUser@@QAEXXZ PROC NEAR		; CUser::AddGCPlayerPoint, COMDAT
; _this$ = ecx

; 7043 : 	if( IsDelete() )	return;

  00000	8a 41 04	 mov	 al, BYTE PTR [ecx+4]
  00003	83 ec 08	 sub	 esp, 8
  00006	a8 01		 test	 al, 1
  00008	0f 85 36 01 00
	00		 jne	 $L283664

; 7044 : 	
; 7045 : 	m_Snapshot.cb++;

  0000e	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  00015	53		 push	 ebx
  00016	55		 push	 ebp
  00017	56		 push	 esi
  00018	57		 push	 edi

; 7046 : 	m_Snapshot.ar << GetId();

  00019	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  0001f	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  00025	bb 04 00 00 00	 mov	 ebx, 4
  0002a	53		 push	 ebx
  0002b	8b ce		 mov	 ecx, esi
  0002d	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00032	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00035	89 38		 mov	 DWORD PTR [eax], edi
  00037	01 5e 08	 add	 DWORD PTR [esi+8], ebx

; 7047 : 	m_Snapshot.ar << SNAPSHOTTYPE_GUILDCOMBAT;

  0003a	6a 02		 push	 2
  0003c	8b ce		 mov	 ecx, esi
  0003e	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00043	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00046	66 c7 01 b8 00	 mov	 WORD PTR [ecx], 184	; 000000b8H
  0004b	8b 6e 08	 mov	 ebp, DWORD PTR [esi+8]
  0004e	83 c5 02	 add	 ebp, 2

; 7048 : 	m_Snapshot.ar << GC_PLAYERPOINT;

  00051	6a 01		 push	 1
  00053	8b ce		 mov	 ecx, esi
  00055	89 6e 08	 mov	 DWORD PTR [esi+8], ebp
  00058	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0005d	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00060	c6 02 42	 mov	 BYTE PTR [edx], 66	; 00000042H
  00063	ff 46 08	 inc	 DWORD PTR [esi+8]

; 7049 : 	m_Snapshot.ar << (u_long)g_GuildCombatMng.m_vecGCPlayerPoint.size();

  00066	a1 64 00 00 00	 mov	 eax, DWORD PTR ?g_GuildCombatMng@@3VCGuildCombat@@A+100
  0006b	33 ed		 xor	 ebp, ebp
  0006d	3b c5		 cmp	 eax, ebp
  0006f	75 04		 jne	 SHORT $L342782
  00071	33 ff		 xor	 edi, edi
  00073	eb 18		 jmp	 SHORT $L342783
$L342782:
  00075	8b 0d 68 00 00
	00		 mov	 ecx, DWORD PTR ?g_GuildCombatMng@@3VCGuildCombat@@A+104
  0007b	2b c8		 sub	 ecx, eax
  0007d	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00082	f7 e9		 imul	 ecx
  00084	d1 fa		 sar	 edx, 1
  00086	8b fa		 mov	 edi, edx
  00088	c1 ef 1f	 shr	 edi, 31			; 0000001fH
  0008b	03 fa		 add	 edi, edx
$L342783:
  0008d	53		 push	 ebx
  0008e	8b ce		 mov	 ecx, esi
  00090	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00095	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00098	89 38		 mov	 DWORD PTR [eax], edi
  0009a	01 5e 08	 add	 DWORD PTR [esi+8], ebx

; 7050 : 	for( int veci = 0 ; veci < (int)( g_GuildCombatMng.m_vecGCPlayerPoint.size() ) ; ++veci )

  0009d	89 6c 24 10	 mov	 DWORD PTR _veci$283660[esp+24], ebp
  000a1	89 6c 24 14	 mov	 DWORD PTR tv325[esp+24], ebp
$L283662:
  000a5	8b 3d 64 00 00
	00		 mov	 edi, DWORD PTR ?g_GuildCombatMng@@3VCGuildCombat@@A+100
  000ab	85 ff		 test	 edi, edi
  000ad	75 04		 jne	 SHORT $L342794
  000af	33 c0		 xor	 eax, eax
  000b1	eb 18		 jmp	 SHORT $L342795
$L342794:
  000b3	8b 0d 68 00 00
	00		 mov	 ecx, DWORD PTR ?g_GuildCombatMng@@3VCGuildCombat@@A+104
  000b9	2b cf		 sub	 ecx, edi
  000bb	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  000c0	f7 e9		 imul	 ecx
  000c2	d1 fa		 sar	 edx, 1
  000c4	8b c2		 mov	 eax, edx
  000c6	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  000c9	03 c2		 add	 eax, edx
$L342795:
  000cb	39 44 24 10	 cmp	 DWORD PTR _veci$283660[esp+24], eax
  000cf	7d 6f		 jge	 SHORT $L342874

; 7051 : 	{
; 7052 : 		CGuildCombat::__GCPLAYERPOINT GCPlayerPoint = g_GuildCombatMng.m_vecGCPlayerPoint[ veci ];

  000d1	8b 4c 24 14	 mov	 ecx, DWORD PTR tv325[esp+24]
  000d5	8b 5c 39 04	 mov	 ebx, DWORD PTR [ecx+edi+4]
  000d9	8b 6c 39 08	 mov	 ebp, DWORD PTR [ecx+edi+8]
  000dd	8d 04 39	 lea	 eax, DWORD PTR [ecx+edi]
  000e0	8b 38		 mov	 edi, DWORD PTR [eax]

; 7053 : 		m_Snapshot.ar << GCPlayerPoint.uidPlayer;

  000e2	6a 04		 push	 4
  000e4	8b ce		 mov	 ecx, esi
  000e6	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000eb	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  000ee	89 3a		 mov	 DWORD PTR [edx], edi
  000f0	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  000f3	bf 04 00 00 00	 mov	 edi, 4
  000f8	03 d7		 add	 edx, edi

; 7054 : 		m_Snapshot.ar << GCPlayerPoint.nJob;

  000fa	57		 push	 edi
  000fb	8b ce		 mov	 ecx, esi
  000fd	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00100	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00105	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00108	89 18		 mov	 DWORD PTR [eax], ebx
  0010a	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0010d	03 c7		 add	 eax, edi

; 7055 : 		m_Snapshot.ar << GCPlayerPoint.nPoint;

  0010f	57		 push	 edi
  00110	8b ce		 mov	 ecx, esi
  00112	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00115	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0011a	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0011d	8b 44 24 14	 mov	 eax, DWORD PTR tv325[esp+24]
  00121	89 29		 mov	 DWORD PTR [ecx], ebp
  00123	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00126	8b 4c 24 10	 mov	 ecx, DWORD PTR _veci$283660[esp+24]
  0012a	03 d7		 add	 edx, edi
  0012c	41		 inc	 ecx
  0012d	83 c0 0c	 add	 eax, 12			; 0000000cH
  00130	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00133	89 4c 24 10	 mov	 DWORD PTR _veci$283660[esp+24], ecx
  00137	89 44 24 14	 mov	 DWORD PTR tv325[esp+24], eax
  0013b	e9 65 ff ff ff	 jmp	 $L283662
$L342874:
  00140	5f		 pop	 edi
  00141	5e		 pop	 esi
  00142	5d		 pop	 ebp
  00143	5b		 pop	 ebx
$L283664:

; 7056 : 	}	
; 7057 : }

  00144	83 c4 08	 add	 esp, 8
  00147	c3		 ret	 0
?AddGCPlayerPoint@CUser@@QAEXXZ ENDP			; CUser::AddGCPlayerPoint
_TEXT	ENDS
PUBLIC	?AddReassembleOpenWnd@CUser@@QAEXV?$vector@KV?$allocator@K@std@@@std@@@Z ; CUser::AddReassembleOpenWnd
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
xdata$x	SEGMENT
$T343028 DD	0ffffffffH
	DD	FLAT:$L342881
$T343024 DD	019930520H
	DD	01H
	DD	FLAT:$T343028
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
xdata$x	ENDS
;	COMDAT ?AddReassembleOpenWnd@CUser@@QAEXV?$vector@KV?$allocator@K@std@@@std@@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_vecItemId$ = 8						; size = 16
?AddReassembleOpenWnd@CUser@@QAEXV?$vector@KV?$allocator@K@std@@@std@@@Z PROC NEAR ; CUser::AddReassembleOpenWnd, COMDAT
; _this$ = ecx

; 7688 : {

  00000	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00006	6a ff		 push	 -1
  00008	68 00 00 00 00	 push	 __ehhandler$?AddReassembleOpenWnd@CUser@@QAEXV?$vector@KV?$allocator@K@std@@@std@@@Z
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	53		 push	 ebx
  00016	55		 push	 ebp
  00017	56		 push	 esi
  00018	57		 push	 edi

; 7689 : 	if( IsDelete() )	return;

  00019	8a 41 04	 mov	 al, BYTE PTR [ecx+4]
  0001c	33 db		 xor	 ebx, ebx
  0001e	a8 01		 test	 al, 1
  00020	89 5c 24 18	 mov	 DWORD PTR __$EHRec$[esp+36], ebx
  00024	74 12		 je	 SHORT $L284799
  00026	8b 44 24 24	 mov	 eax, DWORD PTR _vecItemId$[esp+28]
  0002a	3b c3		 cmp	 eax, ebx
  0002c	0f 84 bb 00 00
	00		 je	 $L343021
  00032	50		 push	 eax
  00033	e9 ad 00 00 00	 jmp	 $L343027
$L284799:

; 7690 : 	
; 7691 : 	m_Snapshot.cb++;

  00038	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]

; 7692 : 	m_Snapshot.ar << GetId();

  0003f	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  00045	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  0004b	bd 04 00 00 00	 mov	 ebp, 4
  00050	55		 push	 ebp
  00051	8b ce		 mov	 ecx, esi
  00053	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00058	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0005b	89 38		 mov	 DWORD PTR [eax], edi
  0005d	01 6e 08	 add	 DWORD PTR [esi+8], ebp

; 7693 : 	m_Snapshot.ar << SNAPSHOTTYPE_MINIGAME;

  00060	6a 02		 push	 2
  00062	8b ce		 mov	 ecx, esi
  00064	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00069	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0006c	66 c7 01 e8 00	 mov	 WORD PTR [ecx], 232	; 000000e8H
  00071	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  00074	83 c7 02	 add	 edi, 2

; 7694 : 	m_Snapshot.ar << MINIGAME_REASSEMBLE_OPENWND;

  00077	6a 01		 push	 1
  00079	8b ce		 mov	 ecx, esi
  0007b	89 7e 08	 mov	 DWORD PTR [esi+8], edi
  0007e	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00083	8b 56 08	 mov	 edx, DWORD PTR [esi+8]

; 7695 : 	m_Snapshot.ar << vecItemId.size();

  00086	8b 7c 24 24	 mov	 edi, DWORD PTR _vecItemId$[esp+28]
  0008a	c6 02 03	 mov	 BYTE PTR [edx], 3
  0008d	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00090	41		 inc	 ecx
  00091	3b fb		 cmp	 edi, ebx
  00093	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  00096	74 09		 je	 SHORT $L342926
  00098	8b 5c 24 28	 mov	 ebx, DWORD PTR _vecItemId$[esp+32]
  0009c	2b df		 sub	 ebx, edi
  0009e	c1 fb 02	 sar	 ebx, 2
$L342926:
  000a1	55		 push	 ebp
  000a2	8b ce		 mov	 ecx, esi
  000a4	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000a9	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000ac	89 18		 mov	 DWORD PTR [eax], ebx
  000ae	01 6e 08	 add	 DWORD PTR [esi+8], ebp

; 7696 : 	for( int i=0; i<(int)( vecItemId.size() ); ++i )

  000b1	33 db		 xor	 ebx, ebx
$L284803:
  000b3	85 ff		 test	 edi, edi
  000b5	75 04		 jne	 SHORT $L342942
  000b7	33 c0		 xor	 eax, eax
  000b9	eb 09		 jmp	 SHORT $L342943
$L342942:
  000bb	8b 44 24 28	 mov	 eax, DWORD PTR _vecItemId$[esp+32]
  000bf	2b c7		 sub	 eax, edi
  000c1	c1 f8 02	 sar	 eax, 2
$L342943:
  000c4	3b d8		 cmp	 ebx, eax
  000c6	7d 18		 jge	 SHORT $L284805

; 7697 : 		m_Snapshot.ar << vecItemId[i];

  000c8	8b 2c 9f	 mov	 ebp, DWORD PTR [edi+ebx*4]
  000cb	6a 04		 push	 4
  000cd	8b ce		 mov	 ecx, esi
  000cf	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000d4	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  000d7	89 29		 mov	 DWORD PTR [ecx], ebp
  000d9	83 46 08 04	 add	 DWORD PTR [esi+8], 4
  000dd	43		 inc	 ebx
  000de	eb d3		 jmp	 SHORT $L284803
$L284805:

; 7698 : }

  000e0	85 ff		 test	 edi, edi
  000e2	74 09		 je	 SHORT $L343021
  000e4	57		 push	 edi
$L343027:
  000e5	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000ea	83 c4 04	 add	 esp, 4
$L343021:
  000ed	8b 4c 24 10	 mov	 ecx, DWORD PTR __$EHRec$[esp+28]
  000f1	5f		 pop	 edi
  000f2	5e		 pop	 esi
  000f3	5d		 pop	 ebp
  000f4	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  000fb	5b		 pop	 ebx
  000fc	83 c4 0c	 add	 esp, 12			; 0000000cH
  000ff	c2 10 00	 ret	 16			; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L342881:
  00000	8d 4d 04	 lea	 ecx, DWORD PTR _vecItemId$[ebp-4]
  00003	e9 00 00 00 00	 jmp	 ??1?$vector@KV?$allocator@K@std@@@std@@QAE@XZ ; std::vector<unsigned long,std::allocator<unsigned long> >::~vector<unsigned long,std::allocator<unsigned long> >
__ehhandler$?AddReassembleOpenWnd@CUser@@QAEXV?$vector@KV?$allocator@K@std@@@std@@@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T343024
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?AddReassembleOpenWnd@CUser@@QAEXV?$vector@KV?$allocator@K@std@@@std@@@Z ENDP ; CUser::AddReassembleOpenWnd
PUBLIC	?AddSecretRoomLineUpOpenWnd@CUser@@QAEXAAV?$vector@KV?$allocator@K@std@@@std@@@Z ; CUser::AddSecretRoomLineUpOpenWnd
; Function compile flags: /Ogty
;	COMDAT ?AddSecretRoomLineUpOpenWnd@CUser@@QAEXAAV?$vector@KV?$allocator@K@std@@@std@@@Z
_TEXT	SEGMENT
_vecLineUpMember$ = 8					; size = 4
?AddSecretRoomLineUpOpenWnd@CUser@@QAEXAAV?$vector@KV?$allocator@K@std@@@std@@@Z PROC NEAR ; CUser::AddSecretRoomLineUpOpenWnd, COMDAT
; _this$ = ecx

; 8151 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	0f 85 d9 00 00
	00		 jne	 $L285213

; 8152 : 	m_Snapshot.cb++;

  0000a	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  00011	53		 push	 ebx
  00012	55		 push	 ebp
  00013	56		 push	 esi
  00014	57		 push	 edi

; 8153 : 	m_Snapshot.ar << GetId();

  00015	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  0001b	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  00021	bb 04 00 00 00	 mov	 ebx, 4
  00026	53		 push	 ebx
  00027	8b ce		 mov	 ecx, esi
  00029	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0002e	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00031	89 38		 mov	 DWORD PTR [eax], edi
  00033	8b 6e 08	 mov	 ebp, DWORD PTR [esi+8]
  00036	03 eb		 add	 ebp, ebx

; 8154 : 	m_Snapshot.ar << SNAPSHOTTYPE_SECRETROOM_LINEUPOPENWND;

  00038	6a 02		 push	 2
  0003a	8b ce		 mov	 ecx, esi
  0003c	89 6e 08	 mov	 DWORD PTR [esi+8], ebp
  0003f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00044	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00047	66 c7 01 03 03	 mov	 WORD PTR [ecx], 771	; 00000303H
  0004c	83 46 08 02	 add	 DWORD PTR [esi+8], 2

; 8155 : 	m_Snapshot.ar << CSecretRoomMng::GetInstance()->m_nMinGuildMemberNum;

  00050	e8 00 00 00 00	 call	 ?GetInstance@CSecretRoomMng@@SAPAV1@XZ ; CSecretRoomMng::GetInstance
  00055	8b 78 24	 mov	 edi, DWORD PTR [eax+36]
  00058	53		 push	 ebx
  00059	8b ce		 mov	 ecx, esi
  0005b	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00060	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00063	89 3a		 mov	 DWORD PTR [edx], edi
  00065	01 5e 08	 add	 DWORD PTR [esi+8], ebx

; 8156 : 	m_Snapshot.ar << CSecretRoomMng::GetInstance()->m_nMaxGuildMemberNum;

  00068	e8 00 00 00 00	 call	 ?GetInstance@CSecretRoomMng@@SAPAV1@XZ ; CSecretRoomMng::GetInstance
  0006d	8b 78 28	 mov	 edi, DWORD PTR [eax+40]
  00070	53		 push	 ebx
  00071	8b ce		 mov	 ecx, esi
  00073	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00078	8b 46 08	 mov	 eax, DWORD PTR [esi+8]

; 8157 : 	m_Snapshot.ar << vecLineUpMember.size();

  0007b	8b 6c 24 14	 mov	 ebp, DWORD PTR _vecLineUpMember$[esp+12]
  0007f	89 38		 mov	 DWORD PTR [eax], edi
  00081	01 5e 08	 add	 DWORD PTR [esi+8], ebx
  00084	8b 45 04	 mov	 eax, DWORD PTR [ebp+4]
  00087	85 c0		 test	 eax, eax
  00089	75 04		 jne	 SHORT $L343073
  0008b	33 ff		 xor	 edi, edi
  0008d	eb 08		 jmp	 SHORT $L343074
$L343073:
  0008f	8b 7d 08	 mov	 edi, DWORD PTR [ebp+8]
  00092	2b f8		 sub	 edi, eax
  00094	c1 ff 02	 sar	 edi, 2
$L343074:
  00097	53		 push	 ebx
  00098	8b ce		 mov	 ecx, esi
  0009a	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0009f	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  000a2	89 39		 mov	 DWORD PTR [ecx], edi
  000a4	01 5e 08	 add	 DWORD PTR [esi+8], ebx

; 8158 : 
; 8159 : 	for( int i=0; i<(int)( vecLineUpMember.size() ); i++ )

  000a7	33 ff		 xor	 edi, edi
  000a9	8d a4 24 00 00
	00 00		 npad	 7
$L285211:
  000b0	8b 4d 04	 mov	 ecx, DWORD PTR [ebp+4]
  000b3	85 c9		 test	 ecx, ecx
  000b5	75 04		 jne	 SHORT $L343090
  000b7	33 c0		 xor	 eax, eax
  000b9	eb 08		 jmp	 SHORT $L343091
$L343090:
  000bb	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  000be	2b c1		 sub	 eax, ecx
  000c0	c1 f8 02	 sar	 eax, 2
$L343091:
  000c3	3b f8		 cmp	 edi, eax
  000c5	7d 18		 jge	 SHORT $L343154

; 8160 : 		m_Snapshot.ar << vecLineUpMember[i];

  000c7	8b 1c b9	 mov	 ebx, DWORD PTR [ecx+edi*4]
  000ca	6a 04		 push	 4
  000cc	8b ce		 mov	 ecx, esi
  000ce	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000d3	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  000d6	89 1a		 mov	 DWORD PTR [edx], ebx
  000d8	83 46 08 04	 add	 DWORD PTR [esi+8], 4
  000dc	47		 inc	 edi
  000dd	eb d1		 jmp	 SHORT $L285211
$L343154:
  000df	5f		 pop	 edi
  000e0	5e		 pop	 esi
  000e1	5d		 pop	 ebp
  000e2	5b		 pop	 ebx
$L285213:

; 8161 : }

  000e3	c2 04 00	 ret	 4
?AddSecretRoomLineUpOpenWnd@CUser@@QAEXAAV?$vector@KV?$allocator@K@std@@@std@@@Z ENDP ; CUser::AddSecretRoomLineUpOpenWnd
_TEXT	ENDS
PUBLIC	?AddSecretRoomTenderView@CUser@@QAEXHHJAAV?$vector@U__SECRETROOM_TENDER@@V?$allocator@U__SECRETROOM_TENDER@@@std@@@std@@@Z ; CUser::AddSecretRoomTenderView
; Function compile flags: /Ogty
;	COMDAT ?AddSecretRoomTenderView@CUser@@QAEXHHJAAV?$vector@U__SECRETROOM_TENDER@@V?$allocator@U__SECRETROOM_TENDER@@@std@@@std@@@Z
_TEXT	SEGMENT
_i$285224 = 8						; size = 4
_nTenderPenya$ = 8					; size = 4
_nRanking$ = 12						; size = 4
_t$ = 16						; size = 4
_vecSRTender$ = 20					; size = 4
?AddSecretRoomTenderView@CUser@@QAEXHHJAAV?$vector@U__SECRETROOM_TENDER@@V?$allocator@U__SECRETROOM_TENDER@@@std@@@std@@@Z PROC NEAR ; CUser::AddSecretRoomTenderView, COMDAT
; _this$ = ecx

; 8165 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	0f 85 1f 01 00
	00		 jne	 $L285228

; 8166 : 	m_Snapshot.cb++;

  0000a	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  00011	53		 push	 ebx
  00012	55		 push	 ebp
  00013	56		 push	 esi
  00014	57		 push	 edi

; 8167 : 	m_Snapshot.ar << GetId();

  00015	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  0001b	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  00021	bb 04 00 00 00	 mov	 ebx, 4
  00026	53		 push	 ebx
  00027	8b ce		 mov	 ecx, esi
  00029	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0002e	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00031	89 38		 mov	 DWORD PTR [eax], edi
  00033	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00036	03 c3		 add	 eax, ebx

; 8168 : 	m_Snapshot.ar << SNAPSHOTTYPE_SECRETROOM_TENDERVIEW;

  00038	6a 02		 push	 2
  0003a	8b ce		 mov	 ecx, esi
  0003c	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0003f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00044	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00047	66 c7 01 04 03	 mov	 WORD PTR [ecx], 772	; 00000304H
  0004c	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  0004f	83 c7 02	 add	 edi, 2

; 8169 : 	m_Snapshot.ar << nTenderPenya;

  00052	53		 push	 ebx
  00053	8b ce		 mov	 ecx, esi
  00055	89 7e 08	 mov	 DWORD PTR [esi+8], edi
  00058	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0005d	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00060	8b 44 24 14	 mov	 eax, DWORD PTR _nTenderPenya$[esp+12]
  00064	89 02		 mov	 DWORD PTR [edx], eax
  00066	01 5e 08	 add	 DWORD PTR [esi+8], ebx

; 8170 : 	m_Snapshot.ar << nRanking;

  00069	53		 push	 ebx
  0006a	8b ce		 mov	 ecx, esi
  0006c	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00071	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00074	8b 54 24 18	 mov	 edx, DWORD PTR _nRanking$[esp+12]
  00078	89 11		 mov	 DWORD PTR [ecx], edx
  0007a	8b 6e 08	 mov	 ebp, DWORD PTR [esi+8]
  0007d	03 eb		 add	 ebp, ebx

; 8171 : 	m_Snapshot.ar << t;

  0007f	53		 push	 ebx
  00080	8b ce		 mov	 ecx, esi
  00082	89 6e 08	 mov	 DWORD PTR [esi+8], ebp
  00085	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0008a	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0008d	8b 4c 24 1c	 mov	 ecx, DWORD PTR _t$[esp+12]

; 8172 : 	m_Snapshot.ar << vecSRTender.size();

  00091	8b 6c 24 20	 mov	 ebp, DWORD PTR _vecSRTender$[esp+12]
  00095	89 08		 mov	 DWORD PTR [eax], ecx
  00097	01 5e 08	 add	 DWORD PTR [esi+8], ebx
  0009a	8b 45 04	 mov	 eax, DWORD PTR [ebp+4]
  0009d	85 c0		 test	 eax, eax
  0009f	75 04		 jne	 SHORT $L343202
  000a1	33 ff		 xor	 edi, edi
  000a3	eb 16		 jmp	 SHORT $L343203
$L343202:
  000a5	8b 4d 08	 mov	 ecx, DWORD PTR [ebp+8]
  000a8	2b c8		 sub	 ecx, eax
  000aa	b8 4f ec c4 4e	 mov	 eax, 1321528399		; 4ec4ec4fH
  000af	f7 e9		 imul	 ecx
  000b1	c1 fa 04	 sar	 edx, 4
  000b4	8b fa		 mov	 edi, edx
  000b6	c1 ef 1f	 shr	 edi, 31			; 0000001fH
  000b9	03 fa		 add	 edi, edx
$L343203:
  000bb	53		 push	 ebx
  000bc	8b ce		 mov	 ecx, esi
  000be	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000c3	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  000c6	89 3a		 mov	 DWORD PTR [edx], edi
  000c8	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000cb	03 c3		 add	 eax, ebx

; 8173 : 	for( int i=0; i<(int)( vecSRTender.size() ); i++ )

  000cd	33 db		 xor	 ebx, ebx
  000cf	89 46 08	 mov	 DWORD PTR [esi+8], eax
  000d2	89 5c 24 14	 mov	 DWORD PTR _i$285224[esp+12], ebx
$L285226:
  000d6	8b 7d 04	 mov	 edi, DWORD PTR [ebp+4]
  000d9	85 ff		 test	 edi, edi
  000db	75 04		 jne	 SHORT $L343219
  000dd	33 c0		 xor	 eax, eax
  000df	eb 16		 jmp	 SHORT $L343220
$L343219:
  000e1	8b 4d 08	 mov	 ecx, DWORD PTR [ebp+8]
  000e4	2b cf		 sub	 ecx, edi
  000e6	b8 4f ec c4 4e	 mov	 eax, 1321528399		; 4ec4ec4fH
  000eb	f7 e9		 imul	 ecx
  000ed	c1 fa 04	 sar	 edx, 4
  000f0	8b c2		 mov	 eax, edx
  000f2	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  000f5	03 c2		 add	 eax, edx
$L343220:
  000f7	39 44 24 14	 cmp	 DWORD PTR _i$285224[esp+12], eax
  000fb	7d 28		 jge	 SHORT $L343283

; 8174 : 		m_Snapshot.ar << vecSRTender[i].dwGuildId;

  000fd	8b 3c 3b	 mov	 edi, DWORD PTR [ebx+edi]
  00100	6a 04		 push	 4
  00102	8b ce		 mov	 ecx, esi
  00104	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00109	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0010c	8b 4c 24 14	 mov	 ecx, DWORD PTR _i$285224[esp+12]
  00110	89 38		 mov	 DWORD PTR [eax], edi
  00112	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00115	83 c2 04	 add	 edx, 4
  00118	41		 inc	 ecx
  00119	89 56 08	 mov	 DWORD PTR [esi+8], edx
  0011c	89 4c 24 14	 mov	 DWORD PTR _i$285224[esp+12], ecx
  00120	83 c3 34	 add	 ebx, 52			; 00000034H
  00123	eb b1		 jmp	 SHORT $L285226
$L343283:
  00125	5f		 pop	 edi
  00126	5e		 pop	 esi
  00127	5d		 pop	 ebp
  00128	5b		 pop	 ebx
$L285228:

; 8175 : }

  00129	c2 10 00	 ret	 16			; 00000010H
?AddSecretRoomTenderView@CUser@@QAEXHHJAAV?$vector@U__SECRETROOM_TENDER@@V?$allocator@U__SECRETROOM_TENDER@@@std@@@std@@@Z ENDP ; CUser::AddSecretRoomTenderView
_TEXT	ENDS
PUBLIC	?AddHousingVisitableList@CUser@@QAEXAAV?$vector@KV?$allocator@K@std@@@std@@@Z ; CUser::AddHousingVisitableList
; Function compile flags: /Ogty
;	COMDAT ?AddHousingVisitableList@CUser@@QAEXAAV?$vector@KV?$allocator@K@std@@@std@@@Z
_TEXT	SEGMENT
_vecVisitable$ = 8					; size = 4
?AddHousingVisitableList@CUser@@QAEXAAV?$vector@KV?$allocator@K@std@@@std@@@Z PROC NEAR ; CUser::AddHousingVisitableList, COMDAT
; _this$ = ecx

; 8502 : 	if( IsDelete() )	return;

  00000	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00004	0f 85 a9 00 00
	00		 jne	 $L285511

; 8503 : 	m_Snapshot.cb++;

  0000a	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  00011	53		 push	 ebx
  00012	55		 push	 ebp
  00013	56		 push	 esi
  00014	57		 push	 edi

; 8504 : 	m_Snapshot.ar << GetId();

  00015	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  0001b	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  00021	bb 04 00 00 00	 mov	 ebx, 4
  00026	53		 push	 ebx
  00027	8b ce		 mov	 ecx, esi
  00029	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0002e	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00031	89 38		 mov	 DWORD PTR [eax], edi
  00033	8b 6e 08	 mov	 ebp, DWORD PTR [esi+8]
  00036	03 eb		 add	 ebp, ebx

; 8505 : 	m_Snapshot.ar << SNAPSHOTTYPE_HOUSING_VISITABLELIST;

  00038	6a 02		 push	 2
  0003a	8b ce		 mov	 ecx, esi
  0003c	89 6e 08	 mov	 DWORD PTR [esi+8], ebp
  0003f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00044	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]

; 8506 : 	m_Snapshot.ar << vecVisitable.size();

  00047	8b 6c 24 14	 mov	 ebp, DWORD PTR _vecVisitable$[esp+12]
  0004b	66 c7 01 05 92	 mov	 WORD PTR [ecx], 37381	; 00009205H
  00050	83 46 08 02	 add	 DWORD PTR [esi+8], 2
  00054	8b 45 04	 mov	 eax, DWORD PTR [ebp+4]
  00057	85 c0		 test	 eax, eax
  00059	75 04		 jne	 SHORT $L343310
  0005b	33 ff		 xor	 edi, edi
  0005d	eb 08		 jmp	 SHORT $L343311
$L343310:
  0005f	8b 7d 08	 mov	 edi, DWORD PTR [ebp+8]
  00062	2b f8		 sub	 edi, eax
  00064	c1 ff 02	 sar	 edi, 2
$L343311:
  00067	53		 push	 ebx
  00068	8b ce		 mov	 ecx, esi
  0006a	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0006f	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00072	89 3a		 mov	 DWORD PTR [edx], edi
  00074	01 5e 08	 add	 DWORD PTR [esi+8], ebx

; 8507 : 	for( int i=0; i<(int)( vecVisitable.size() ); i++ )

  00077	33 ff		 xor	 edi, edi
  00079	8d a4 24 00 00
	00 00		 npad	 7
$L285509:
  00080	8b 4d 04	 mov	 ecx, DWORD PTR [ebp+4]
  00083	85 c9		 test	 ecx, ecx
  00085	75 04		 jne	 SHORT $L343327
  00087	33 c0		 xor	 eax, eax
  00089	eb 08		 jmp	 SHORT $L343328
$L343327:
  0008b	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  0008e	2b c1		 sub	 eax, ecx
  00090	c1 f8 02	 sar	 eax, 2
$L343328:
  00093	3b f8		 cmp	 edi, eax
  00095	7d 18		 jge	 SHORT $L343390

; 8508 : 		m_Snapshot.ar << vecVisitable[i];

  00097	8b 1c b9	 mov	 ebx, DWORD PTR [ecx+edi*4]
  0009a	6a 04		 push	 4
  0009c	8b ce		 mov	 ecx, esi
  0009e	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000a3	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000a6	89 18		 mov	 DWORD PTR [eax], ebx
  000a8	83 46 08 04	 add	 DWORD PTR [esi+8], 4
  000ac	47		 inc	 edi
  000ad	eb d1		 jmp	 SHORT $L285509
$L343390:
  000af	5f		 pop	 edi
  000b0	5e		 pop	 esi
  000b1	5d		 pop	 ebp
  000b2	5b		 pop	 ebx
$L285511:

; 8509 : }

  000b3	c2 04 00	 ret	 4
?AddHousingVisitableList@CUser@@QAEXAAV?$vector@KV?$allocator@K@std@@@std@@@Z ENDP ; CUser::AddHousingVisitableList
_TEXT	ENDS
PUBLIC	?DoUseItemInput@CUser@@QAEHPAUItemProp@@PAVCItemElem@@@Z ; CUser::DoUseItemInput
; Function compile flags: /Ogty
;	COMDAT ?DoUseItemInput@CUser@@QAEHPAUItemProp@@PAVCItemElem@@@Z
_TEXT	SEGMENT
_pProp$ = 8						; size = 4
_pItem$ = 12						; size = 4
?DoUseItemInput@CUser@@QAEHPAUItemProp@@PAVCItemElem@@@Z PROC NEAR ; CUser::DoUseItemInput, COMDAT
; _this$ = ecx

; 8542 : 	switch( pProp->dwItemKind3 )

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _pProp$[esp-4]
  00004	83 78 78 7a	 cmp	 DWORD PTR [eax+120], 122 ; 0000007aH
  00008	74 18		 je	 SHORT $L285536

; 8547 : 		default:	break;
; 8548 : 	}
; 8549 : 	switch( pProp->dwID )

  0000a	81 38 47 4e 00
	00		 cmp	 DWORD PTR [eax], 20039	; 00004e47H
  00010	74 08		 je	 SHORT $L285542

; 8554 : #endif	// __PET_1024
; 8555 : 		default:
; 8556 : 			return 1;

  00012	b8 01 00 00 00	 mov	 eax, 1

; 8557 : 	}
; 8558 : 	return 1;
; 8559 : }

  00017	c2 08 00	 ret	 8
$L285542:

; 8550 : 	{
; 8551 : #ifdef __PET_1024
; 8552 : 		case II_SYS_SYS_SCR_PET_NAMING:
; 8553 : 			return DoUseItemPetNaming();

  0001a	e8 00 00 00 00	 call	 ?DoUseItemPetNaming@CUser@@QAEHXZ ; CUser::DoUseItemPetNaming

; 8557 : 	}
; 8558 : 	return 1;
; 8559 : }

  0001f	c2 08 00	 ret	 8
$L285536:

; 8543 : 	{
; 8544 : 		case IK3_TICKET:
; 8545 : 			DoUseItemTicket( pItem );

  00022	8b 44 24 08	 mov	 eax, DWORD PTR _pItem$[esp-4]
  00026	50		 push	 eax
  00027	e8 00 00 00 00	 call	 ?DoUseItemTicket@CUser@@QAEXPAVCItemElem@@@Z ; CUser::DoUseItemTicket

; 8546 : 			return 0;

  0002c	33 c0		 xor	 eax, eax

; 8557 : 	}
; 8558 : 	return 1;
; 8559 : }

  0002e	c2 08 00	 ret	 8
?DoUseItemInput@CUser@@QAEHPAUItemProp@@PAVCItemElem@@@Z ENDP ; CUser::DoUseItemInput
_TEXT	ENDS
PUBLIC	??0?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE@XZ ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\list
;	COMDAT ??0?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE@XZ PROC NEAR ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >, COMDAT
; _this$ = ecx

; 280  : 		{	// construct empty list

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	e8 00 00 00 00	 call	 ?_Buynode@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAEPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@XZ ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Buynode
  00008	89 46 04	 mov	 DWORD PTR [esi+4], eax
  0000b	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0

; 281  : 		}

  00012	8b c6		 mov	 eax, esi
  00014	5e		 pop	 esi
  00015	c3		 ret	 0
??0?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE@XZ ENDP ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >
_TEXT	ENDS
PUBLIC	??0?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@QAE@XZ ; std::list<CUser *,std::allocator<CUser *> >::list<CUser *,std::allocator<CUser *> >
; Function compile flags: /Ogty
;	COMDAT ??0?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@QAE@XZ PROC NEAR ; std::list<CUser *,std::allocator<CUser *> >::list<CUser *,std::allocator<CUser *> >, COMDAT
; _this$ = ecx

; 280  : 		{	// construct empty list

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	e8 00 00 00 00	 call	 ?_Buynode@?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@IAEPAU_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@2@XZ ; std::list<CUser *,std::allocator<CUser *> >::_Buynode
  00008	89 46 04	 mov	 DWORD PTR [esi+4], eax
  0000b	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0

; 281  : 		}

  00012	8b c6		 mov	 eax, esi
  00014	5e		 pop	 esi
  00015	c3		 ret	 0
??0?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@QAE@XZ ENDP ; std::list<CUser *,std::allocator<CUser *> >::list<CUser *,std::allocator<CUser *> >
_TEXT	ENDS
PUBLIC	??0?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@K@1@ABV?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@K@1@ABV?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 4
??0?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@K@1@ABV?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@1@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >, COMDAT
; _this$ = ecx

; 361  : 		{	// construct empty tree

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 362  : 		_Init();

  00003	e8 00 00 00 00	 call	 ?_Buynode@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Buynode
  00008	89 46 04	 mov	 DWORD PTR [esi+4], eax
  0000b	c6 40 15 01	 mov	 BYTE PTR [eax+21], 1
  0000f	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00012	89 40 04	 mov	 DWORD PTR [eax+4], eax
  00015	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00018	89 00		 mov	 DWORD PTR [eax], eax
  0001a	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0001d	89 40 08	 mov	 DWORD PTR [eax+8], eax
  00020	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0

; 363  : 		}

  00027	8b c6		 mov	 eax, esi
  00029	5e		 pop	 esi
  0002a	c2 08 00	 ret	 8
??0?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@K@1@ABV?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >
_TEXT	ENDS
PUBLIC	??0?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@K@1@ABV?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::_Tree<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >
; Function compile flags: /Ogty
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@K@1@ABV?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 4
??0?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@K@1@ABV?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@1@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::_Tree<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >, COMDAT
; _this$ = ecx

; 361  : 		{	// construct empty tree

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 362  : 		_Init();

  00003	e8 00 00 00 00	 call	 ?_Buynode@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::_Buynode
  00008	89 46 04	 mov	 DWORD PTR [esi+4], eax
  0000b	c6 40 15 01	 mov	 BYTE PTR [eax+21], 1
  0000f	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00012	89 40 04	 mov	 DWORD PTR [eax+4], eax
  00015	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00018	89 00		 mov	 DWORD PTR [eax], eax
  0001a	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0001d	89 40 08	 mov	 DWORD PTR [eax+8], eax
  00020	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0

; 363  : 		}

  00027	8b c6		 mov	 eax, esi
  00029	5e		 pop	 esi
  0002a	c2 08 00	 ret	 8
??0?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@K@1@ABV?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::_Tree<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >
_TEXT	ENDS
PUBLIC	?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXABV12@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Copy
; Function compile flags: /Ogty
;	COMDAT ?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXABV12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXABV12@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Copy, COMDAT
; _this$ = ecx

; 854  : 		{	// copy entire tree from _Right

  00000	53		 push	 ebx

; 855  : 		_Root() = _Copy(_Right._Root(), _Myhead);

  00001	8b 5c 24 08	 mov	 ebx, DWORD PTR __Right$[esp]
  00005	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  00008	56		 push	 esi
  00009	57		 push	 edi
  0000a	8b f1		 mov	 esi, ecx
  0000c	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]
  0000f	83 c0 04	 add	 eax, 4
  00012	8b 00		 mov	 eax, DWORD PTR [eax]
  00014	57		 push	 edi
  00015	50		 push	 eax
  00016	e8 00 00 00 00	 call	 ?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@0@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Copy
  0001b	89 47 04	 mov	 DWORD PTR [edi+4], eax

; 856  : 		_Mysize = _Right.size();

  0001e	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]

; 857  : 		if (!_Isnil(_Root()))

  00021	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00024	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  00027	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0002a	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  0002d	84 c9		 test	 cl, cl
  0002f	75 44		 jne	 SHORT $L288635

; 858  : 			{	// nonempty tree, look for new smallest and largest
; 859  : 			_Lmost() = _Min(_Root());

  00031	8b 08		 mov	 ecx, DWORD PTR [eax]
  00033	8a 59 15	 mov	 bl, BYTE PTR [ecx+21]
  00036	84 db		 test	 bl, bl
  00038	75 11		 jne	 SHORT $L343825
  0003a	8d 9b 00 00 00
	00		 npad	 6
$L343824:
  00040	8b c1		 mov	 eax, ecx
  00042	8b 08		 mov	 ecx, DWORD PTR [eax]
  00044	8a 59 15	 mov	 bl, BYTE PTR [ecx+21]
  00047	84 db		 test	 bl, bl
  00049	74 f5		 je	 SHORT $L343824
$L343825:
  0004b	89 02		 mov	 DWORD PTR [edx], eax

; 860  : 			_Rmost() = _Max(_Root());

  0004d	8b 76 04	 mov	 esi, DWORD PTR [esi+4]
  00050	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00053	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00056	8a 50 15	 mov	 dl, BYTE PTR [eax+21]
  00059	84 d2		 test	 dl, dl
  0005b	75 0f		 jne	 SHORT $L343863
  0005d	8d 49 00	 npad	 3
$L343862:
  00060	8b c8		 mov	 ecx, eax
  00062	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00065	8a 50 15	 mov	 dl, BYTE PTR [eax+21]
  00068	84 d2		 test	 dl, dl
  0006a	74 f4		 je	 SHORT $L343862
$L343863:
  0006c	5f		 pop	 edi
  0006d	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  00070	5e		 pop	 esi
  00071	5b		 pop	 ebx

; 864  : 		}

  00072	c2 04 00	 ret	 4
$L288635:

; 861  : 			}
; 862  : 		else
; 863  : 			_Lmost() = _Myhead, _Rmost() = _Myhead;	// empty tree

  00075	89 12		 mov	 DWORD PTR [edx], edx
  00077	8b 76 04	 mov	 esi, DWORD PTR [esi+4]
  0007a	5f		 pop	 edi
  0007b	89 76 08	 mov	 DWORD PTR [esi+8], esi
  0007e	5e		 pop	 esi
  0007f	5b		 pop	 ebx

; 864  : 		}

  00080	c2 04 00	 ret	 4
?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXABV12@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Copy
_TEXT	ENDS
PUBLIC	?_Ufill@?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@IAEPAU__ITEMINFO@@PAU3@IABU3@@Z ; std::vector<__ITEMINFO,std::allocator<__ITEMINFO> >::_Ufill
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ?_Ufill@?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@IAEPAU__ITEMINFO@@PAU3@IABU3@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Cat$343914 = 16					; size = 1
__Val$ = 16						; size = 4
?_Ufill@?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@IAEPAU__ITEMINFO@@PAU3@IABU3@@Z PROC NEAR ; std::vector<__ITEMINFO,std::allocator<__ITEMINFO> >::_Ufill, COMDAT
; _this$ = ecx

; 878  : 		_Uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

  00000	8b 44 24 0c	 mov	 eax, DWORD PTR __Cat$343914[esp-4]
  00004	56		 push	 esi
  00005	8b 74 24 0c	 mov	 esi, DWORD PTR __Count$[esp]
  00009	57		 push	 edi
  0000a	8b 7c 24 0c	 mov	 edi, DWORD PTR __Ptr$[esp+4]
  0000e	50		 push	 eax
  0000f	51		 push	 ecx
  00010	8b 4c 24 1c	 mov	 ecx, DWORD PTR __Val$[esp+12]
  00014	51		 push	 ecx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	e8 00 00 00 00	 call	 ??$_Uninit_fill_n@PAU__ITEMINFO@@IU1@V?$allocator@U__ITEMINFO@@@std@@@std@@YAXPAU__ITEMINFO@@IABU1@AAV?$allocator@U__ITEMINFO@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<__ITEMINFO *,unsigned int,__ITEMINFO,std::allocator<__ITEMINFO> >

; 879  : 		return (_Ptr + _Count);

  0001c	8d 14 76	 lea	 edx, DWORD PTR [esi+esi*2]
  0001f	83 c4 14	 add	 esp, 20			; 00000014H
  00022	8d 04 97	 lea	 eax, DWORD PTR [edi+edx*4]
  00025	5f		 pop	 edi
  00026	5e		 pop	 esi

; 880  : 		}

  00027	c2 0c 00	 ret	 12			; 0000000cH
?_Ufill@?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@IAEPAU__ITEMINFO@@PAU3@IABU3@@Z ENDP ; std::vector<__ITEMINFO,std::allocator<__ITEMINFO> >::_Ufill
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@IAEXPAU__REQUESTGUILD@CGuildCombat@@0@Z ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::_Destroy
; Function compile flags: /Ogty
;	COMDAT ?_Destroy@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@IAEXPAU__REQUESTGUILD@CGuildCombat@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@IAEXPAU__REQUESTGUILD@CGuildCombat@@0@Z PROC NEAR ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::_Destroy, COMDAT
; _this$ = ecx

; 787  : 		_Destroy_range(_First, _Last, this->_Alval);
; 788  : 		}

  00000	c2 08 00	 ret	 8
?_Destroy@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@IAEXPAU__REQUESTGUILD@CGuildCombat@@0@Z ENDP ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::_Destroy
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@IAEXPAU__ITEMINFO@@0@Z ; std::vector<__ITEMINFO,std::allocator<__ITEMINFO> >::_Destroy
; Function compile flags: /Ogty
;	COMDAT ?_Destroy@?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@IAEXPAU__ITEMINFO@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@IAEXPAU__ITEMINFO@@0@Z PROC NEAR ; std::vector<__ITEMINFO,std::allocator<__ITEMINFO> >::_Destroy, COMDAT
; _this$ = ecx

; 787  : 		_Destroy_range(_First, _Last, this->_Alval);
; 788  : 		}

  00000	c2 08 00	 ret	 8
?_Destroy@?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@IAEXPAU__ITEMINFO@@0@Z ENDP ; std::vector<__ITEMINFO,std::allocator<__ITEMINFO> >::_Destroy
_TEXT	ENDS
PUBLIC	??_G?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPAXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::`scalar deleting destructor'
; Function compile flags: /Ogty
;	COMDAT ??_G?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPAXI@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	83 7e 18 10	 cmp	 DWORD PTR [esi+24], 16	; 00000010H
  00007	72 0c		 jb	 SHORT $L343982
  00009	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00012	83 c4 04	 add	 esp, 4
$L343982:
  00015	33 c0		 xor	 eax, eax
  00017	89 46 14	 mov	 DWORD PTR [esi+20], eax
  0001a	c7 46 18 0f 00
	00 00		 mov	 DWORD PTR [esi+24], 15	; 0000000fH
  00021	88 46 04	 mov	 BYTE PTR [esi+4], al
  00024	f6 44 24 08 01	 test	 BYTE PTR ___flags$[esp], 1
  00029	74 09		 je	 SHORT $L343999
  0002b	56		 push	 esi
  0002c	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00031	83 c4 04	 add	 esp, 4
$L343999:
  00034	8b c6		 mov	 eax, esi
  00036	5e		 pop	 esi
  00037	c2 04 00	 ret	 4
??_G?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPAXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?LoadStringA@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEHI@Z ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::LoadStringA
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\cstringt.h
;	COMDAT ?LoadStringA@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEHI@Z
_TEXT	SEGMENT
_nID$ = 8						; size = 4
?LoadStringA@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEHI@Z PROC NEAR ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::LoadStringA, COMDAT
; _this$ = ecx

; 1969 : 	{

  00000	56		 push	 esi
  00001	57		 push	 edi

; 1970 : 		HINSTANCE hInst = StringTraits::FindStringResourceInstance( nID );

  00002	8b 7c 24 0c	 mov	 edi, DWORD PTR _nID$[esp+4]
  00006	57		 push	 edi
  00007	8b f1		 mov	 esi, ecx
  00009	e8 00 00 00 00	 call	 ?AfxFindStringResourceHandle@@YGPAUHINSTANCE__@@I@Z ; AfxFindStringResourceHandle

; 1971 : 		if( hInst == NULL )

  0000e	85 c0		 test	 eax, eax
  00010	75 05		 jne	 SHORT $L218601
  00012	5f		 pop	 edi
  00013	5e		 pop	 esi

; 1977 : 	}

  00014	c2 04 00	 ret	 4
$L218601:

; 1972 : 		{
; 1973 : 			return( FALSE );
; 1974 : 		}
; 1975 : 
; 1976 : 		return( LoadString( hInst, nID ) );		

  00017	57		 push	 edi
  00018	50		 push	 eax
  00019	8b ce		 mov	 ecx, esi
  0001b	e8 00 00 00 00	 call	 ?LoadStringA@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEHPAUHINSTANCE__@@I@Z ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::LoadStringA
  00020	5f		 pop	 edi
  00021	5e		 pop	 esi

; 1977 : 	}

  00022	c2 04 00	 ret	 4
?LoadStringA@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEHI@Z ENDP ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::LoadStringA
_TEXT	ENDS
PUBLIC	?find@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::find
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ?find@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z
_TEXT	SEGMENT
$T344012 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Keyval$ = 12						; size = 4
?find@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::find, COMDAT
; _this$ = ecx

; 787  : 		{	// find an element in mutable sequence that matches _Keyval

  00000	51		 push	 ecx

; 788  : 		iterator _Where = lower_bound(_Keyval);

  00001	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00004	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00007	53		 push	 ebx
  00008	8a 58 15	 mov	 bl, BYTE PTR [eax+21]
  0000b	84 db		 test	 bl, bl
  0000d	56		 push	 esi
  0000e	57		 push	 edi
  0000f	8b 7c 24 18	 mov	 edi, DWORD PTR __Keyval$[esp+12]
  00013	75 17		 jne	 SHORT $L344104
  00015	8b 37		 mov	 esi, DWORD PTR [edi]
$L344103:
  00017	39 70 0c	 cmp	 DWORD PTR [eax+12], esi
  0001a	73 05		 jae	 SHORT $L344105
  0001c	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0001f	eb 04		 jmp	 SHORT $L344106
$L344105:
  00021	8b d0		 mov	 edx, eax
  00023	8b 00		 mov	 eax, DWORD PTR [eax]
$L344106:
  00025	8a 58 15	 mov	 bl, BYTE PTR [eax+21]
  00028	84 db		 test	 bl, bl
  0002a	74 eb		 je	 SHORT $L344103
$L344104:

; 789  : 		return (_Where == end() || this->comp(_Keyval, _Key(_Where._Mynode()))
; 790  : 			? end() : _Where);

  0002c	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0002f	3b d0		 cmp	 edx, eax
  00031	89 54 24 18	 mov	 DWORD PTR __Where$[esp+12], edx
  00035	74 1a		 je	 SHORT $L344011
  00037	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00039	3b 4a 0c	 cmp	 ecx, DWORD PTR [edx+12]
  0003c	72 13		 jb	 SHORT $L344011
  0003e	8d 44 24 18	 lea	 eax, DWORD PTR __Where$[esp+12]
  00042	8b 10		 mov	 edx, DWORD PTR [eax]
  00044	8b 44 24 14	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp+12]
  00048	5f		 pop	 edi
  00049	5e		 pop	 esi
  0004a	89 10		 mov	 DWORD PTR [eax], edx
  0004c	5b		 pop	 ebx

; 791  : 		}

  0004d	59		 pop	 ecx
  0004e	c2 08 00	 ret	 8
$L344011:

; 789  : 		return (_Where == end() || this->comp(_Keyval, _Key(_Where._Mynode()))
; 790  : 			? end() : _Where);

  00051	89 44 24 0c	 mov	 DWORD PTR $T344012[esp+16], eax
  00055	8d 44 24 0c	 lea	 eax, DWORD PTR $T344012[esp+16]
  00059	8b 10		 mov	 edx, DWORD PTR [eax]
  0005b	8b 44 24 14	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp+12]
  0005f	5f		 pop	 edi
  00060	5e		 pop	 esi
  00061	89 10		 mov	 DWORD PTR [eax], edx
  00063	5b		 pop	 ebx

; 791  : 		}

  00064	59		 pop	 ecx
  00065	c2 08 00	 ret	 8
?find@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::find
_TEXT	ENDS
PUBLIC	?CheckImplicitLoad@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@AAE_NPBX@Z ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::CheckImplicitLoad
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\cstringt.h
;	COMDAT ?CheckImplicitLoad@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@AAE_NPBX@Z
_TEXT	SEGMENT
_pv$ = 8						; size = 4
?CheckImplicitLoad@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@AAE_NPBX@Z PROC NEAR ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::CheckImplicitLoad, COMDAT
; _this$ = ecx

; 2229 : 	{

  00000	57		 push	 edi
  00001	8b f9		 mov	 edi, ecx

; 2230 : 		bool bRet = false;
; 2231 : 
; 2232 : 		if( (pv != NULL) && IS_INTRESOURCE( pv ) )

  00003	8b 4c 24 08	 mov	 ecx, DWORD PTR _pv$[esp]
  00007	32 c0		 xor	 al, al
  00009	85 c9		 test	 ecx, ecx
  0000b	74 22		 je	 SHORT $L219935
  0000d	f7 c1 00 00 ff
	ff		 test	 ecx, -65536		; ffff0000H
  00013	75 1a		 jne	 SHORT $L219935
  00015	56		 push	 esi

; 2233 : 		{
; 2234 : 			UINT nID = LOWORD( reinterpret_cast< DWORD_PTR >( pv ) );

  00016	0f b7 f1	 movzx	 esi, cx

; 2235 : 			if( !LoadString( nID ) )

  00019	56		 push	 esi
  0001a	e8 00 00 00 00	 call	 ?AfxFindStringResourceHandle@@YGPAUHINSTANCE__@@I@Z ; AfxFindStringResourceHandle
  0001f	85 c0		 test	 eax, eax
  00021	74 09		 je	 SHORT $L344180
  00023	56		 push	 esi
  00024	50		 push	 eax
  00025	8b cf		 mov	 ecx, edi
  00027	e8 00 00 00 00	 call	 ?LoadStringA@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEHPAUHINSTANCE__@@I@Z ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::LoadStringA
$L344180:

; 2236 : 			{
; 2237 : 				ATLTRACE( atlTraceString, 2, _T( "Warning: implicit LoadString(%u) failed\n" ), nID );
; 2238 : 			}
; 2239 : 			bRet = true;

  0002c	b0 01		 mov	 al, 1
  0002e	5e		 pop	 esi
$L219935:
  0002f	5f		 pop	 edi

; 2240 : 		}
; 2241 : 
; 2242 : 		return( bRet );
; 2243 : 	}

  00030	c2 04 00	 ret	 4
?CheckImplicitLoad@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@AAE_NPBX@Z ENDP ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::CheckImplicitLoad
_TEXT	ENDS
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 590  : 		{	// assign _Right [_Roff, _Roff + _Count)

  00000	53		 push	 ebx
  00001	55		 push	 ebp
  00002	56		 push	 esi

; 591  : 		if (_Right.size() < _Roff)

  00003	8b 74 24 14	 mov	 esi, DWORD PTR __Roff$[esp+8]
  00007	57		 push	 edi
  00008	8b 7c 24 14	 mov	 edi, DWORD PTR __Right$[esp+12]
  0000c	39 77 14	 cmp	 DWORD PTR [edi+20], esi
  0000f	8b d9		 mov	 ebx, ecx
  00011	73 05		 jae	 SHORT $L220001

; 592  : 			_String_base::_Xran();	// _Roff off end

  00013	e8 00 00 00 00	 call	 ?_Xran@_String_base@std@@QBEXXZ ; std::_String_base::_Xran
$L220001:

; 593  : 		size_type _Num = _Right.size() - _Roff;

  00018	8b 6f 14	 mov	 ebp, DWORD PTR [edi+20]

; 594  : 		if (_Count < _Num)

  0001b	8b 44 24 1c	 mov	 eax, DWORD PTR __Count$[esp+12]
  0001f	2b ee		 sub	 ebp, esi
  00021	3b c5		 cmp	 eax, ebp
  00023	73 02		 jae	 SHORT $L220003

; 595  : 			_Num = _Count;	// trim _Num to size

  00025	8b e8		 mov	 ebp, eax
$L220003:

; 596  : 
; 597  : 		if (this == &_Right)

  00027	3b df		 cmp	 ebx, edi
  00029	75 1f		 jne	 SHORT $L220004

; 598  : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring

  0002b	6a ff		 push	 -1
  0002d	03 ee		 add	 ebp, esi
  0002f	55		 push	 ebp
  00030	8b cb		 mov	 ecx, ebx
  00032	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
  00037	56		 push	 esi
  00038	6a 00		 push	 0
  0003a	8b cb		 mov	 ecx, ebx
  0003c	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
  00041	5f		 pop	 edi
  00042	5e		 pop	 esi
  00043	5d		 pop	 ebp

; 603  : 			}
; 604  : 		return (*this);

  00044	8b c3		 mov	 eax, ebx
  00046	5b		 pop	 ebx

; 605  : 		}

  00047	c2 0c 00	 ret	 12			; 0000000cH
$L220004:

; 599  : 		else if (_Grow(_Num))

  0004a	83 fd fe	 cmp	 ebp, -2			; fffffffeH
  0004d	76 07		 jbe	 SHORT $L344318
  0004f	8b cb		 mov	 ecx, ebx
  00051	e8 00 00 00 00	 call	 ?_Xlen@_String_base@std@@QBEXXZ ; std::_String_base::_Xlen
$L344318:
  00056	8b 43 18	 mov	 eax, DWORD PTR [ebx+24]
  00059	3b c5		 cmp	 eax, ebp
  0005b	73 21		 jae	 SHORT $L344320
  0005d	8b 43 14	 mov	 eax, DWORD PTR [ebx+20]
  00060	50		 push	 eax
  00061	55		 push	 ebp
  00062	8b cb		 mov	 ecx, ebx
  00064	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
  00069	85 ed		 test	 ebp, ebp
$L344382:
  0006b	76 6d		 jbe	 SHORT $L344381

; 600  : 			{	// make room and assign new stuff
; 601  : 			_Traits::copy(_Myptr(), _Right._Myptr() + _Roff, _Num);

  0006d	8b 4f 18	 mov	 ecx, DWORD PTR [edi+24]
  00070	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00075	3b c8		 cmp	 ecx, eax
  00077	72 2f		 jb	 SHORT $L344346
  00079	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  0007c	eb 2d		 jmp	 SHORT $L344347

; 599  : 		else if (_Grow(_Num))

$L344320:
  0007e	85 ed		 test	 ebp, ebp
  00080	75 e9		 jne	 SHORT $L344382
  00082	83 f8 10	 cmp	 eax, 16			; 00000010H
  00085	89 6b 14	 mov	 DWORD PTR [ebx+20], ebp
  00088	72 0f		 jb	 SHORT $L344338
  0008a	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  0008d	5f		 pop	 edi
  0008e	5e		 pop	 esi
  0008f	c6 00 00	 mov	 BYTE PTR [eax], 0
  00092	5d		 pop	 ebp

; 603  : 			}
; 604  : 		return (*this);

  00093	8b c3		 mov	 eax, ebx
  00095	5b		 pop	 ebx

; 605  : 		}

  00096	c2 0c 00	 ret	 12			; 0000000cH

; 599  : 		else if (_Grow(_Num))

$L344338:
  00099	5f		 pop	 edi
  0009a	8d 43 04	 lea	 eax, DWORD PTR [ebx+4]
  0009d	5e		 pop	 esi
  0009e	c6 00 00	 mov	 BYTE PTR [eax], 0
  000a1	5d		 pop	 ebp

; 603  : 			}
; 604  : 		return (*this);

  000a2	8b c3		 mov	 eax, ebx
  000a4	5b		 pop	 ebx

; 605  : 		}

  000a5	c2 0c 00	 ret	 12			; 0000000cH

; 600  : 			{	// make room and assign new stuff
; 601  : 			_Traits::copy(_Myptr(), _Right._Myptr() + _Roff, _Num);

$L344346:
  000a8	8d 57 04	 lea	 edx, DWORD PTR [edi+4]
$L344347:
  000ab	39 43 18	 cmp	 DWORD PTR [ebx+24], eax
  000ae	8d 43 04	 lea	 eax, DWORD PTR [ebx+4]
  000b1	72 04		 jb	 SHORT $L344354
  000b3	8b 38		 mov	 edi, DWORD PTR [eax]
  000b5	eb 02		 jmp	 SHORT $L344355
$L344354:
  000b7	8b f8		 mov	 edi, eax
$L344355:
  000b9	03 f2		 add	 esi, edx
  000bb	8b cd		 mov	 ecx, ebp
  000bd	8b d1		 mov	 edx, ecx
  000bf	c1 e9 02	 shr	 ecx, 2
  000c2	f3 a5		 rep movsd
  000c4	8b ca		 mov	 ecx, edx
  000c6	83 e1 03	 and	 ecx, 3
  000c9	f3 a4		 rep movsb

; 602  : 			_Eos(_Num);

  000cb	83 7b 18 10	 cmp	 DWORD PTR [ebx+24], 16	; 00000010H
  000cf	89 6b 14	 mov	 DWORD PTR [ebx+20], ebp
  000d2	72 02		 jb	 SHORT $L344378
  000d4	8b 00		 mov	 eax, DWORD PTR [eax]
$L344378:
  000d6	c6 04 28 00	 mov	 BYTE PTR [eax+ebp], 0
$L344381:
  000da	5f		 pop	 edi
  000db	5e		 pop	 esi
  000dc	5d		 pop	 ebp

; 603  : 			}
; 604  : 		return (*this);

  000dd	8b c3		 mov	 eax, ebx
  000df	5b		 pop	 ebx

; 605  : 		}

  000e0	c2 0c 00	 ret	 12			; 0000000cH
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
PUBLIC	?SetString@?$CSimpleStringT@D$0A@@ATL@@QAEXPBD@Z ; ATL::CSimpleStringT<char,0>::SetString
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlsimpstr.h
;	COMDAT ?SetString@?$CSimpleStringT@D$0A@@ATL@@QAEXPBD@Z
_TEXT	SEGMENT
_pszSrc$ = 8						; size = 4
?SetString@?$CSimpleStringT@D$0A@@ATL@@QAEXPBD@Z PROC NEAR ; ATL::CSimpleStringT<char,0>::SetString, COMDAT
; _this$ = ecx

; 579  : 	{

  00000	56		 push	 esi

; 580  : 		SetString( pszSrc, StringLength( pszSrc ) );

  00001	8b 74 24 08	 mov	 esi, DWORD PTR _pszSrc$[esp]
  00005	85 f6		 test	 esi, esi
  00007	75 0d		 jne	 SHORT $L344389
  00009	33 c0		 xor	 eax, eax
  0000b	50		 push	 eax
  0000c	56		 push	 esi
  0000d	e8 00 00 00 00	 call	 ?SetString@?$CSimpleStringT@D$0A@@ATL@@QAEXPBDH@Z ; ATL::CSimpleStringT<char,0>::SetString
  00012	5e		 pop	 esi

; 581  : 	}

  00013	c2 04 00	 ret	 4

; 580  : 		SetString( pszSrc, StringLength( pszSrc ) );

$L344389:
  00016	8b c6		 mov	 eax, esi
  00018	57		 push	 edi
  00019	8d 78 01	 lea	 edi, DWORD PTR [eax+1]
  0001c	8d 64 24 00	 npad	 4
$L344391:
  00020	8a 10		 mov	 dl, BYTE PTR [eax]
  00022	40		 inc	 eax
  00023	84 d2		 test	 dl, dl
  00025	75 f9		 jne	 SHORT $L344391
  00027	2b c7		 sub	 eax, edi
  00029	5f		 pop	 edi
  0002a	50		 push	 eax
  0002b	56		 push	 esi
  0002c	e8 00 00 00 00	 call	 ?SetString@?$CSimpleStringT@D$0A@@ATL@@QAEXPBDH@Z ; ATL::CSimpleStringT<char,0>::SetString
  00031	5e		 pop	 esi

; 581  : 	}

  00032	c2 04 00	 ret	 4
?SetString@?$CSimpleStringT@D$0A@@ATL@@QAEXPBD@Z ENDP	; ATL::CSimpleStringT<char,0>::SetString
_TEXT	ENDS
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Num$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 608  : 		{	// assign [_Ptr, _Ptr + _Num)

  00000	53		 push	 ebx
  00001	8b d9		 mov	 ebx, ecx

; 609  : 		if (_Inside(_Ptr))

  00003	8b 53 18	 mov	 edx, DWORD PTR [ebx+24]
  00006	83 fa 10	 cmp	 edx, 16			; 00000010H
  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	72 05		 jb	 SHORT $L344413
  0000d	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  00010	eb 03		 jmp	 SHORT $L344414
$L344413:
  00012	8d 43 04	 lea	 eax, DWORD PTR [ebx+4]
$L344414:
  00015	8b 74 24 10	 mov	 esi, DWORD PTR __Ptr$[esp+8]
  00019	3b f0		 cmp	 esi, eax
  0001b	72 34		 jb	 SHORT $L221367
  0001d	83 fa 10	 cmp	 edx, 16			; 00000010H
  00020	8d 43 04	 lea	 eax, DWORD PTR [ebx+4]
  00023	72 04		 jb	 SHORT $L344417
  00025	8b 08		 mov	 ecx, DWORD PTR [eax]
  00027	eb 02		 jmp	 SHORT $L344418
$L344417:
  00029	8b c8		 mov	 ecx, eax
$L344418:
  0002b	8b 7b 14	 mov	 edi, DWORD PTR [ebx+20]
  0002e	03 f9		 add	 edi, ecx
  00030	3b fe		 cmp	 edi, esi
  00032	76 1d		 jbe	 SHORT $L221367

; 610  : 			return (assign(*this, _Ptr - _Myptr(), _Num));	// substring

  00034	83 fa 10	 cmp	 edx, 16			; 00000010H
  00037	72 02		 jb	 SHORT $L344430
  00039	8b 00		 mov	 eax, DWORD PTR [eax]
$L344430:
  0003b	8b 4c 24 14	 mov	 ecx, DWORD PTR __Num$[esp+8]
  0003f	51		 push	 ecx
  00040	2b f0		 sub	 esi, eax
  00042	56		 push	 esi
  00043	53		 push	 ebx
  00044	8b cb		 mov	 ecx, ebx
  00046	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  0004b	5f		 pop	 edi
  0004c	5e		 pop	 esi
  0004d	5b		 pop	 ebx

; 618  : 		}

  0004e	c2 08 00	 ret	 8
$L221367:
  00051	55		 push	 ebp

; 611  : 
; 612  : 		if (_Grow(_Num))

  00052	8b 6c 24 18	 mov	 ebp, DWORD PTR __Num$[esp+12]
  00056	83 fd fe	 cmp	 ebp, -2			; fffffffeH
  00059	76 07		 jbe	 SHORT $L344528
  0005b	8b cb		 mov	 ecx, ebx
  0005d	e8 00 00 00 00	 call	 ?_Xlen@_String_base@std@@QBEXXZ ; std::_String_base::_Xlen
$L344528:
  00062	8b 43 18	 mov	 eax, DWORD PTR [ebx+24]
  00065	3b c5		 cmp	 eax, ebp
  00067	73 1b		 jae	 SHORT $L344529
  00069	8b 53 14	 mov	 edx, DWORD PTR [ebx+20]
  0006c	52		 push	 edx
  0006d	55		 push	 ebp
  0006e	8b cb		 mov	 ecx, ebx
  00070	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
  00075	85 ed		 test	 ebp, ebp
$L344609:
  00077	76 68		 jbe	 SHORT $L344606

; 613  : 			{	// make room and assign new stuff
; 614  : 			_Traits::copy(_Myptr(), _Ptr, _Num);

  00079	83 7b 18 10	 cmp	 DWORD PTR [ebx+24], 16	; 00000010H
  0007d	72 2f		 jb	 SHORT $L344581
  0007f	8b 7b 04	 mov	 edi, DWORD PTR [ebx+4]
  00082	eb 2d		 jmp	 SHORT $L344582

; 611  : 
; 612  : 		if (_Grow(_Num))

$L344529:
  00084	85 ed		 test	 ebp, ebp
  00086	75 ef		 jne	 SHORT $L344609
  00088	83 f8 10	 cmp	 eax, 16			; 00000010H
  0008b	89 6b 14	 mov	 DWORD PTR [ebx+20], ebp
  0008e	72 0f		 jb	 SHORT $L344572
  00090	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  00093	5d		 pop	 ebp
  00094	5f		 pop	 edi
  00095	c6 00 00	 mov	 BYTE PTR [eax], 0
  00098	5e		 pop	 esi

; 616  : 			}
; 617  : 		return (*this);

  00099	8b c3		 mov	 eax, ebx
  0009b	5b		 pop	 ebx

; 618  : 		}

  0009c	c2 08 00	 ret	 8

; 611  : 
; 612  : 		if (_Grow(_Num))

$L344572:
  0009f	5d		 pop	 ebp
  000a0	8d 43 04	 lea	 eax, DWORD PTR [ebx+4]
  000a3	5f		 pop	 edi
  000a4	c6 00 00	 mov	 BYTE PTR [eax], 0
  000a7	5e		 pop	 esi

; 616  : 			}
; 617  : 		return (*this);

  000a8	8b c3		 mov	 eax, ebx
  000aa	5b		 pop	 ebx

; 618  : 		}

  000ab	c2 08 00	 ret	 8

; 613  : 			{	// make room and assign new stuff
; 614  : 			_Traits::copy(_Myptr(), _Ptr, _Num);

$L344581:
  000ae	8d 7b 04	 lea	 edi, DWORD PTR [ebx+4]
$L344582:
  000b1	8b cd		 mov	 ecx, ebp
  000b3	8b c1		 mov	 eax, ecx
  000b5	c1 e9 02	 shr	 ecx, 2
  000b8	f3 a5		 rep movsd
  000ba	8b c8		 mov	 ecx, eax
  000bc	83 e1 03	 and	 ecx, 3
  000bf	f3 a4		 rep movsb

; 615  : 			_Eos(_Num);

  000c1	83 7b 18 10	 cmp	 DWORD PTR [ebx+24], 16	; 00000010H
  000c5	89 6b 14	 mov	 DWORD PTR [ebx+20], ebp
  000c8	72 10		 jb	 SHORT $L344604
  000ca	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  000cd	c6 04 28 00	 mov	 BYTE PTR [eax+ebp], 0
  000d1	5d		 pop	 ebp
  000d2	5f		 pop	 edi
  000d3	5e		 pop	 esi

; 616  : 			}
; 617  : 		return (*this);

  000d4	8b c3		 mov	 eax, ebx
  000d6	5b		 pop	 ebx

; 618  : 		}

  000d7	c2 08 00	 ret	 8

; 615  : 			_Eos(_Num);

$L344604:
  000da	8d 43 04	 lea	 eax, DWORD PTR [ebx+4]
  000dd	c6 04 28 00	 mov	 BYTE PTR [eax+ebp], 0
$L344606:
  000e1	5d		 pop	 ebp
  000e2	5f		 pop	 edi
  000e3	5e		 pop	 esi

; 616  : 			}
; 617  : 		return (*this);

  000e4	8b c3		 mov	 eax, ebx
  000e6	5b		 pop	 ebx

; 618  : 		}

  000e7	c2 08 00	 ret	 8
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@IAEXXZ ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::_Tidy
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ?_Tidy@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@IAEXXZ PROC NEAR ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::_Tidy, COMDAT
; _this$ = ecx

; 791  : 		{	// free all storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 792  : 		if (_Myfirst != 0)

  00003	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00006	85 c0		 test	 eax, eax
  00008	74 09		 je	 SHORT $L344614

; 793  : 			{	// something to free, destroy and deallocate it
; 794  : 			_Destroy(_Myfirst, _Mylast);
; 795  : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00010	83 c4 04	 add	 esp, 4
$L344614:

; 796  : 			}
; 797  : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

  00013	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  0001a	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00021	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
  00028	5e		 pop	 esi

; 798  : 		}

  00029	c3		 ret	 0
?_Tidy@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@IAEXXZ ENDP ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::_Tidy
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@IAEXXZ ; std::vector<__ITEMINFO,std::allocator<__ITEMINFO> >::_Tidy
; Function compile flags: /Ogty
;	COMDAT ?_Tidy@?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@IAEXXZ PROC NEAR ; std::vector<__ITEMINFO,std::allocator<__ITEMINFO> >::_Tidy, COMDAT
; _this$ = ecx

; 791  : 		{	// free all storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 792  : 		if (_Myfirst != 0)

  00003	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00006	85 c0		 test	 eax, eax
  00008	74 09		 je	 SHORT $L344623

; 793  : 			{	// something to free, destroy and deallocate it
; 794  : 			_Destroy(_Myfirst, _Mylast);
; 795  : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00010	83 c4 04	 add	 esp, 4
$L344623:

; 796  : 			}
; 797  : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

  00013	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  0001a	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00021	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
  00028	5e		 pop	 esi

; 798  : 		}

  00029	c3		 ret	 0
?_Tidy@?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@IAEXXZ ENDP ; std::vector<__ITEMINFO,std::allocator<__ITEMINFO> >::_Tidy
_TEXT	ENDS
PUBLIC	?GetUserByID@CProject@@QAEPAVCMover@@K@Z	; CProject::GetUserByID
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\project.h
;	COMDAT ?GetUserByID@CProject@@QAEPAVCMover@@K@Z
_TEXT	SEGMENT
_i$ = -4						; size = 4
_idPlayer$ = 8						; size = 4
?GetUserByID@CProject@@QAEPAVCMover@@K@Z PROC NEAR	; CProject::GetUserByID, COMDAT
; _this$ = ecx

; 1409 : {

  00000	51		 push	 ecx
  00001	56		 push	 esi
  00002	8b f1		 mov	 esi, ecx

; 1410 : 	map<u_long, CMover*>::iterator i = m_idPlayerToUserPtr.find( idPlayer );

  00004	8d 44 24 0c	 lea	 eax, DWORD PTR _idPlayer$[esp+4]
  00008	50		 push	 eax
  00009	8d 4c 24 08	 lea	 ecx, DWORD PTR _i$[esp+12]
  0000d	51		 push	 ecx
  0000e	8d 4e 38	 lea	 ecx, DWORD PTR [esi+56]
  00011	e8 00 00 00 00	 call	 ?find@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::find

; 1411 : 	if( i != m_idPlayerToUserPtr.end() )

  00016	8b 4e 3c	 mov	 ecx, DWORD PTR [esi+60]
  00019	8b 44 24 04	 mov	 eax, DWORD PTR _i$[esp+8]
  0001d	3b c1		 cmp	 eax, ecx
  0001f	5e		 pop	 esi
  00020	74 07		 je	 SHORT $L198064

; 1412 : 		return i->second;

  00022	8b 40 10	 mov	 eax, DWORD PTR [eax+16]

; 1414 : }

  00025	59		 pop	 ecx
  00026	c2 04 00	 ret	 4
$L198064:

; 1413 : 	return NULL;

  00029	33 c0		 xor	 eax, eax

; 1414 : }

  0002b	59		 pop	 ecx
  0002c	c2 04 00	 ret	 4
?GetUserByID@CProject@@QAEPAVCMover@@K@Z ENDP		; CProject::GetUserByID
_TEXT	ENDS
PUBLIC	??$_Destroy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::_Destroy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??$_Destroy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z PROC NEAR ; std::_Destroy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 48   : 	{	// destroy object at _Ptr

  00000	56		 push	 esi

; 49   : 	_DESTRUCTOR(_Ty, _Ptr);

  00001	8b 74 24 08	 mov	 esi, DWORD PTR __Ptr$[esp]
  00005	83 7e 18 10	 cmp	 DWORD PTR [esi+24], 16	; 00000010H
  00009	72 0c		 jb	 SHORT $L344761
  0000b	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0000e	50		 push	 eax
  0000f	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00014	83 c4 04	 add	 esp, 4
$L344761:
  00017	33 c0		 xor	 eax, eax
  00019	c7 46 18 0f 00
	00 00		 mov	 DWORD PTR [esi+24], 15	; 0000000fH
  00020	89 46 14	 mov	 DWORD PTR [esi+20], eax
  00023	88 46 04	 mov	 BYTE PTR [esi+4], al
  00026	5e		 pop	 esi

; 50   : 	}

  00027	c3		 ret	 0
??$_Destroy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ENDP ; std::_Destroy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 323  : 		{	// construct by copying _Right

  00000	56		 push	 esi

; 324  : 		_Tidy();

  00001	33 c0		 xor	 eax, eax
  00003	8b f1		 mov	 esi, ecx

; 325  : 		assign(_Right, 0, npos);

  00005	6a ff		 push	 -1
  00007	89 46 14	 mov	 DWORD PTR [esi+20], eax
  0000a	c7 46 18 0f 00
	00 00		 mov	 DWORD PTR [esi+24], 15	; 0000000fH
  00011	50		 push	 eax
  00012	88 46 04	 mov	 BYTE PTR [esi+4], al
  00015	8b 44 24 10	 mov	 eax, DWORD PTR __Right$[esp+8]
  00019	50		 push	 eax
  0001a	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 326  : 		}

  0001f	8b c6		 mov	 eax, esi
  00021	5e		 pop	 esi
  00022	c2 04 00	 ret	 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
PUBLIC	??4?$CSimpleStringT@D$0A@@ATL@@QAEAAV01@PBD@Z	; ATL::CSimpleStringT<char,0>::operator=
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlsimpstr.h
;	COMDAT ??4?$CSimpleStringT@D$0A@@ATL@@QAEAAV01@PBD@Z
_TEXT	SEGMENT
_pszSrc$ = 8						; size = 4
??4?$CSimpleStringT@D$0A@@ATL@@QAEAAV01@PBD@Z PROC NEAR	; ATL::CSimpleStringT<char,0>::operator=, COMDAT
; _this$ = ecx

; 316  : 		SetString( pszSrc );

  00000	8b 54 24 04	 mov	 edx, DWORD PTR _pszSrc$[esp-4]
  00004	85 d2		 test	 edx, edx
  00006	57		 push	 edi
  00007	8b f9		 mov	 edi, ecx
  00009	75 0f		 jne	 SHORT $L344860
  0000b	33 c0		 xor	 eax, eax
  0000d	50		 push	 eax
  0000e	52		 push	 edx
  0000f	e8 00 00 00 00	 call	 ?SetString@?$CSimpleStringT@D$0A@@ATL@@QAEXPBDH@Z ; ATL::CSimpleStringT<char,0>::SetString

; 317  : 
; 318  : 		return( *this );

  00014	8b c7		 mov	 eax, edi
  00016	5f		 pop	 edi

; 319  : 	}

  00017	c2 04 00	 ret	 4

; 316  : 		SetString( pszSrc );

$L344860:
  0001a	8b c2		 mov	 eax, edx
  0001c	56		 push	 esi
  0001d	8d 70 01	 lea	 esi, DWORD PTR [eax+1]
$L344861:
  00020	8a 08		 mov	 cl, BYTE PTR [eax]
  00022	40		 inc	 eax
  00023	84 c9		 test	 cl, cl
  00025	75 f9		 jne	 SHORT $L344861
  00027	2b c6		 sub	 eax, esi
  00029	5e		 pop	 esi
  0002a	50		 push	 eax
  0002b	52		 push	 edx
  0002c	8b cf		 mov	 ecx, edi
  0002e	e8 00 00 00 00	 call	 ?SetString@?$CSimpleStringT@D$0A@@ATL@@QAEXPBDH@Z ; ATL::CSimpleStringT<char,0>::SetString

; 317  : 
; 318  : 		return( *this );

  00033	8b c7		 mov	 eax, edi
  00035	5f		 pop	 edi

; 319  : 	}

  00036	c2 04 00	 ret	 4
??4?$CSimpleStringT@D$0A@@ATL@@QAEAAV01@PBD@Z ENDP	; ATL::CSimpleStringT<char,0>::operator=
_TEXT	ENDS
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 585  : 		return (assign(_Right, 0, npos));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Right$[esp-4]
  00004	6a ff		 push	 -1
  00006	6a 00		 push	 0
  00008	50		 push	 eax
  00009	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 586  : 		}

  0000e	c2 04 00	 ret	 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; Function compile flags: /Ogty
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 621  : 		{	// assign [_Ptr, <null>)

  00000	56		 push	 esi

; 622  : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  00001	8b 74 24 08	 mov	 esi, DWORD PTR __Ptr$[esp]
  00005	8b c6		 mov	 eax, esi
  00007	57		 push	 edi
  00008	8d 78 01	 lea	 edi, DWORD PTR [eax+1]
  0000b	eb 03 8d 49 00	 npad	 5
$L344871:
  00010	8a 10		 mov	 dl, BYTE PTR [eax]
  00012	40		 inc	 eax
  00013	84 d2		 test	 dl, dl
  00015	75 f9		 jne	 SHORT $L344871
  00017	2b c7		 sub	 eax, edi
  00019	50		 push	 eax
  0001a	56		 push	 esi
  0001b	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00020	5f		 pop	 edi
  00021	5e		 pop	 esi

; 623  : 		}

  00022	c2 04 00	 ret	 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
PUBLIC	?ProcessCouple@CUser@@QAEXXZ			; CUser::ProcessCouple
EXTRN	?SendQueryAddCoupleExperience@CDPDatabaseClient@@QAEXKH@Z:NEAR ; CDPDatabaseClient::SendQueryAddCoupleExperience
EXTRN	?GetLevel@CCouple@@QAEHH@Z:NEAR			; CCouple::GetLevel
EXTRN	?GetPartner@CCouple@@QAEKK@Z:NEAR		; CCouple::GetPartner
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
;	COMDAT ?ProcessCouple@CUser@@QAEXXZ
_TEXT	SEGMENT
$T344953 = -8						; size = 4
_i$344931 = -4						; size = 4
?ProcessCouple@CUser@@QAEXXZ PROC NEAR			; CUser::ProcessCouple, COMDAT
; _this$ = ecx

; 3802 : {

  00000	83 ec 08	 sub	 esp, 8
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx

; 3803 : 	BOOL bTick	= FALSE;
; 3804 : 	if( ++m_cbProcessCouple > 60 )

  00007	8b 96 bc 96 00
	00		 mov	 edx, DWORD PTR [esi+38588]
  0000d	33 db		 xor	 ebx, ebx
  0000f	42		 inc	 edx
  00010	8b c2		 mov	 eax, edx
  00012	83 f8 3c	 cmp	 eax, 60			; 0000003cH
  00015	57		 push	 edi
  00016	89 96 bc 96 00
	00		 mov	 DWORD PTR [esi+38588], edx
  0001c	7e 0f		 jle	 SHORT $L344967

; 3805 : 	{
; 3806 : 		bTick	= TRUE;

  0001e	bb 01 00 00 00	 mov	 ebx, 1

; 3807 : 		m_cbProcessCouple	= 0;

  00023	c7 86 bc 96 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+38588], 0
$L344967:

; 3808 : 	}
; 3809 : 	CCouple* pCouple	= CCoupleHelper::Instance()->GetCouple( m_idPlayer );

  0002d	8b be 38 02 00
	00		 mov	 edi, DWORD PTR [esi+568]
  00033	e8 00 00 00 00	 call	 ?Instance@CCoupleHelper@@SAPAV1@XZ ; CCoupleHelper::Instance
  00038	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0003b	57		 push	 edi
  0003c	e8 00 00 00 00	 call	 ?GetCouple@CCoupleMgr@@QAEPAVCCouple@@K@Z ; CCoupleMgr::GetCouple
  00041	8b f8		 mov	 edi, eax

; 3810 : 	if( pCouple )

  00043	85 ff		 test	 edi, edi
  00045	0f 84 99 00 00
	00		 je	 $L279979

; 3811 : 	{
; 3812 : 		CUser* pPartner	= static_cast<CUser*>( prj.GetUserByID( pCouple->GetPartner( m_idPlayer ) ) );

  0004b	8b 86 38 02 00
	00		 mov	 eax, DWORD PTR [esi+568]
  00051	50		 push	 eax
  00052	8b cf		 mov	 ecx, edi
  00054	e8 00 00 00 00	 call	 ?GetPartner@CCouple@@QAEKK@Z ; CCouple::GetPartner
  00059	8d 4c 24 0c	 lea	 ecx, DWORD PTR $T344953[esp+20]
  0005d	51		 push	 ecx
  0005e	8d 54 24 14	 lea	 edx, DWORD PTR _i$344931[esp+24]
  00062	52		 push	 edx
  00063	b9 38 00 00 00	 mov	 ecx, OFFSET FLAT:?prj@@3VCProject@@A+56
  00068	89 44 24 14	 mov	 DWORD PTR $T344953[esp+28], eax
  0006c	e8 00 00 00 00	 call	 ?find@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::find
  00071	8b 44 24 10	 mov	 eax, DWORD PTR _i$344931[esp+20]
  00075	3b 05 3c 00 00
	00		 cmp	 eax, DWORD PTR ?prj@@3VCProject@@A+60
  0007b	74 67		 je	 SHORT $L279979
  0007d	8b 40 10	 mov	 eax, DWORD PTR [eax+16]

; 3813 : 		if( IsValidObj( pPartner ) )

  00080	85 c0		 test	 eax, eax
  00082	74 60		 je	 SHORT $L279979
  00084	f6 40 04 01	 test	 BYTE PTR [eax+4], 1
  00088	75 5a		 jne	 SHORT $L279979

; 3814 : 		{
; 3815 : 			if( bTick && m_idPlayer > pPartner->m_idPlayer && pCouple->GetLevel() < CCouple::eMaxLevel )	// 1  1 

  0008a	85 db		 test	 ebx, ebx
  0008c	74 2f		 je	 SHORT $L279983
  0008e	8b 8e 38 02 00
	00		 mov	 ecx, DWORD PTR [esi+568]
  00094	3b 88 38 02 00
	00		 cmp	 ecx, DWORD PTR [eax+568]
  0009a	76 21		 jbe	 SHORT $L279983
  0009c	6a 00		 push	 0
  0009e	8b cf		 mov	 ecx, edi
  000a0	e8 00 00 00 00	 call	 ?GetLevel@CCouple@@QAEHH@Z ; CCouple::GetLevel
  000a5	83 f8 15	 cmp	 eax, 21			; 00000015H
  000a8	7d 13		 jge	 SHORT $L279983

; 3816 : 				g_dpDBClient.SendQueryAddCoupleExperience( m_idPlayer, 1 );

  000aa	8b 96 38 02 00
	00		 mov	 edx, DWORD PTR [esi+568]
  000b0	6a 01		 push	 1
  000b2	52		 push	 edx
  000b3	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_dpDBClient@@3VCDPDatabaseClient@@A
  000b8	e8 00 00 00 00	 call	 ?SendQueryAddCoupleExperience@CDPDatabaseClient@@QAEXKH@Z ; CDPDatabaseClient::SendQueryAddCoupleExperience
$L279983:

; 3817 : 
; 3818 : 			if( !HasBuffByIk3( IK3_COUPLE_BUFF ) )

  000bd	68 85 00 00 00	 push	 133			; 00000085H
  000c2	8b ce		 mov	 ecx, esi
  000c4	e8 00 00 00 00	 call	 ?HasBuffByIk3@CMover@@QAEHK@Z ; CMover::HasBuffByIk3
  000c9	85 c0		 test	 eax, eax
  000cb	75 23		 jne	 SHORT $L279986

; 3819 : 				ActiveCoupleBuff( pCouple->GetLevel() );

  000cd	50		 push	 eax
  000ce	8b cf		 mov	 ecx, edi
  000d0	e8 00 00 00 00	 call	 ?GetLevel@CCouple@@QAEHH@Z ; CCouple::GetLevel
  000d5	50		 push	 eax
  000d6	8b ce		 mov	 ecx, esi
  000d8	e8 00 00 00 00	 call	 ?ActiveCoupleBuff@CUser@@QAEXH@Z ; CUser::ActiveCoupleBuff
  000dd	5f		 pop	 edi
  000de	5e		 pop	 esi
  000df	5b		 pop	 ebx

; 3829 : 	}
; 3830 : }

  000e0	83 c4 08	 add	 esp, 8
  000e3	c3		 ret	 0
$L279979:

; 3820 : 		}
; 3821 : 		else
; 3822 : 		{
; 3823 : 			RemoveIk3Buffs( IK3_COUPLE_BUFF );
; 3824 : 		}
; 3825 : 	}
; 3826 : 	else
; 3827 : 	{
; 3828 : 		RemoveIk3Buffs( IK3_COUPLE_BUFF );

  000e4	8b ce		 mov	 ecx, esi
  000e6	68 85 00 00 00	 push	 133			; 00000085H
  000eb	e8 00 00 00 00	 call	 ?RemoveIk3Buffs@CMover@@QAEXK@Z ; CMover::RemoveIk3Buffs
$L279986:
  000f0	5f		 pop	 edi
  000f1	5e		 pop	 esi
  000f2	5b		 pop	 ebx

; 3829 : 	}
; 3830 : }

  000f3	83 c4 08	 add	 esp, 8
  000f6	c3		 ret	 0
?ProcessCouple@CUser@@QAEXXZ ENDP			; CUser::ProcessCouple
_TEXT	ENDS
PUBLIC	?GetUserByPlayerID@CUserMng@@QAEPAVCUser@@K@Z	; CUserMng::GetUserByPlayerID
; Function compile flags: /Ogty
;	COMDAT ?GetUserByPlayerID@CUserMng@@QAEPAVCUser@@K@Z
_TEXT	SEGMENT
_i$345022 = -4						; size = 4
$T345044 = 8						; size = 4
_idPlayer$ = 8						; size = 4
?GetUserByPlayerID@CUserMng@@QAEPAVCUser@@K@Z PROC NEAR	; CUserMng::GetUserByPlayerID, COMDAT
; _this$ = ecx

; 3968 : {

  00000	51		 push	 ecx

; 3969 : 	return (CUser*)prj.GetUserByID( idPlayer );

  00001	8b 44 24 08	 mov	 eax, DWORD PTR _idPlayer$[esp]
  00005	8d 4c 24 08	 lea	 ecx, DWORD PTR $T345044[esp]
  00009	51		 push	 ecx
  0000a	8d 54 24 04	 lea	 edx, DWORD PTR _i$345022[esp+8]
  0000e	52		 push	 edx
  0000f	b9 38 00 00 00	 mov	 ecx, OFFSET FLAT:?prj@@3VCProject@@A+56
  00014	89 44 24 10	 mov	 DWORD PTR $T345044[esp+8], eax
  00018	e8 00 00 00 00	 call	 ?find@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::find
  0001d	8b 04 24	 mov	 eax, DWORD PTR _i$345022[esp+4]
  00020	3b 05 3c 00 00
	00		 cmp	 eax, DWORD PTR ?prj@@3VCProject@@A+60
  00026	74 07		 je	 SHORT $L345023
  00028	8b 40 10	 mov	 eax, DWORD PTR [eax+16]

; 3970 : }

  0002b	59		 pop	 ecx
  0002c	c2 04 00	 ret	 4

; 3969 : 	return (CUser*)prj.GetUserByID( idPlayer );

$L345023:
  0002f	33 c0		 xor	 eax, eax

; 3970 : }

  00031	59		 pop	 ecx
  00032	c2 04 00	 ret	 4
?GetUserByPlayerID@CUserMng@@QAEPAVCUser@@K@Z ENDP	; CUserMng::GetUserByPlayerID
_TEXT	ENDS
PUBLIC	?DestroyPlayer@CUserMng@@QAEXPAVCUser@@@Z	; CUserMng::DestroyPlayer
PUBLIC	??_C@_06NDLDHKAP@flaris?$AA@			; `string'
EXTRN	?GoOutGuildHouse@CGuildHouseMng@@QAEXPAVCUser@@@Z:NEAR ; CGuildHouseMng::GoOutGuildHouse
EXTRN	?AddObj@CWorld@@QAEHPAVCObj@@HH@Z:NEAR		; CWorld::AddObj
EXTRN	?DoNotAdd@CWorld@@QAEHPAVCObj@@@Z:NEAR		; CWorld::DoNotAdd
EXTRN	?SavePlayer@CDPDatabaseClient@@QAEXPAVCUser@@KAAUD3DXVECTOR3@@HH@Z:NEAR ; CDPDatabaseClient::SavePlayer
EXTRN	?SendLogConnect@CDPDatabaseClient@@QAEXPAVCUser@@@Z:NEAR ; CDPDatabaseClient::SendLogConnect
EXTRN	?SubDieDecExp@CMover@@QAEMHKH@Z:NEAR		; CMover::SubDieDecExp
EXTRN	?CalluspXXXMultiServer@CDPDatabaseClient@@QAEXKPAVCUser@@@Z:NEAR ; CDPDatabaseClient::CalluspXXXMultiServer
EXTRN	?SendLogExpBox@CDPDatabaseClient@@QAEXKK_JH@Z:NEAR ; CDPDatabaseClient::SendLogExpBox
EXTRN	?SetDropOut@CRainbowRaceMng@@QAEHK@Z:NEAR	; CRainbowRaceMng::SetDropOut
EXTRN	?Delete@CObj@@QAEXXZ:NEAR			; CObj::Delete
EXTRN	?GuildCombat1to1WarResultCheck@CGuildCombat1to1@@QAEXHPAVCUser@@@Z:NEAR ; CGuildCombat1to1::GuildCombat1to1WarResultCheck
EXTRN	?SetHitPoint@CMover@@QAEXH@Z:NEAR		; CMover::SetHitPoint
EXTRN	?SetManaPoint@CMover@@QAEXH@Z:NEAR		; CMover::SetManaPoint
EXTRN	?SetFatiguePoint@CMover@@QAEXH@Z:NEAR		; CMover::SetFatiguePoint
EXTRN	?DestroyWnd_FiveSystem@CMiniGame@@QAEXPAVCUser@@@Z:NEAR ; CMiniGame::DestroyWnd_FiveSystem
EXTRN	?GetChttingRoom@CChattingMng@@QAEPAVCChatting@@K@Z:NEAR ; CChattingMng::GetChttingRoom
EXTRN	?GetManaPoint@CMover@@QAEHXZ:NEAR		; CMover::GetManaPoint
EXTRN	?GetFatiguePoint@CMover@@QAEHXZ:NEAR		; CMover::GetFatiguePoint
EXTRN	?GetMaxHitPoint@CMover@@QAEHXZ:NEAR		; CMover::GetMaxHitPoint
EXTRN	?GetMaxManaPoint@CMover@@QAEHXZ:NEAR		; CMover::GetMaxManaPoint
EXTRN	?GetMaxFatiguePoint@CMover@@QAEHXZ:NEAR		; CMover::GetMaxFatiguePoint
EXTRN	?GetRevivalPos@CSecretRoomMng@@QAE?AUD3DXVECTOR3@@PAVCUser@@@Z:NEAR ; CSecretRoomMng::GetRevivalPos
EXTRN	?CreateExpBox@@YAPAVCCommonCtrl@@PAVCUser@@@Z:NEAR ; CreateExpBox
EXTRN	?GetInstance@CHousingMng@@SAPAV1@XZ:NEAR	; CHousingMng::GetInstance
EXTRN	?g_ChattingMng@@3VCChattingMng@@A:BYTE		; g_ChattingMng
EXTRN	?DestroyHousing@CHousingMng@@QAEHK@Z:NEAR	; CHousingMng::DestroyHousing
EXTRN	?GetInstance@CPCBang@@SAPAV1@XZ:NEAR		; CPCBang::GetInstance
EXTRN	?DestroyPCBangPlayer@CPCBang@@QAEXK@Z:NEAR	; CPCBang::DestroyPCBangPlayer
EXTRN	?RemoveAllEnemies@CMover@@QAEXXZ:NEAR		; CMover::RemoveAllEnemies
EXTRN	?GoOut@CInstanceDungeonHelper@@QAEXPAVCUser@@@Z:NEAR ; CInstanceDungeonHelper::GoOut
EXTRN	?OutWar@CGuildCombat@@QAEXPAVCUser@@0H@Z:NEAR	; CGuildCombat::OutWar
EXTRN	?RemoveChattingMember@CChatting@@QAEHK@Z:NEAR	; CChatting::RemoveChattingMember
EXTRN	?IsInTheSecretRoom@CSecretRoomMng@@QAEHPAVCMover@@@Z:NEAR ; CSecretRoomMng::IsInTheSecretRoom
;	COMDAT ??_C@_06NDLDHKAP@flaris?$AA@
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
CONST	SEGMENT
??_C@_06NDLDHKAP@flaris?$AA@ DB 'flaris', 00H		; `string'
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
CONST	ENDS
;	COMDAT ?DestroyPlayer@CUserMng@@QAEXPAVCUser@@@Z
_TEXT	SEGMENT
tv909 = -40						; size = 4
tv905 = -40						; size = 4
tv900 = -40						; size = 4
_i$280189 = -40						; size = 4
$T345276 = -36						; size = 4
_i$345274 = -32						; size = 4
_pWorld$ = -28						; size = 4
_vPos$ = -24						; size = 12
$T345061 = -12						; size = 12
$T345060 = -12						; size = 12
$T345059 = -12						; size = 12
$T345058 = -12						; size = 12
$T345055 = -12						; size = 12
$T345054 = -12						; size = 12
_fRate$280164 = 8					; size = 4
_nLayer$ = 8						; size = 4
_pUser$ = 8						; size = 4
?DestroyPlayer@CUserMng@@QAEXPAVCUser@@@Z PROC NEAR	; CUserMng::DestroyPlayer, COMDAT
; _this$ = ecx

; 3993 : {

  00000	83 ec 28	 sub	 esp, 40			; 00000028H
  00003	53		 push	 ebx
  00004	56		 push	 esi

; 3994 : 	CWorld* pWorld = pUser->GetWorld();

  00005	8b 74 24 34	 mov	 esi, DWORD PTR _pUser$[esp+44]
  00009	8b 9e 6c 01 00
	00		 mov	 ebx, DWORD PTR [esi+364]

; 3995 : 	if( pWorld == NULL ) 	

  0000f	85 db		 test	 ebx, ebx
  00011	89 5c 24 14	 mov	 DWORD PTR _pWorld$[esp+48], ebx
  00015	75 10		 jne	 SHORT $L280143

; 3996 : 	{
; 3997 : 		safe_delete( pUser );

  00017	8b 06		 mov	 eax, DWORD PTR [esi]
  00019	6a 01		 push	 1
  0001b	8b ce		 mov	 ecx, esi
  0001d	ff 10		 call	 DWORD PTR [eax]
  0001f	5e		 pop	 esi
  00020	5b		 pop	 ebx

; 4259 : 				}
; 4260 : 			}
; 4261 : 		}
; 4262 : #endif // __GUILD_COMBAT_1TO1
; 4263 : 	}
; 4264 : }

  00021	83 c4 28	 add	 esp, 40			; 00000028H
  00024	c2 04 00	 ret	 4
$L280143:

; 3998 : 		return;
; 3999 : 	}
; 4000 : 
; 4001 : #if __VER >= 11 // __SYS_COLLECTING
; 4002 : 	if( pUser->IsCollecting() )

  00027	8b 8e 3c 02 00
	00		 mov	 ecx, DWORD PTR [esi+572]
  0002d	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00030	81 e2 00 00 00
	f0		 and	 edx, -268435456		; f0000000H
  00036	81 fa 00 00 00
	10		 cmp	 edx, 268435456		; 10000000H
  0003c	75 07		 jne	 SHORT $L280147

; 4003 : 		pUser->StopCollecting();

  0003e	8b 06		 mov	 eax, DWORD PTR [esi]
  00040	8b ce		 mov	 ecx, esi
  00042	ff 50 4c	 call	 DWORD PTR [eax+76]
$L280147:

; 4004 : #endif	// __SYS_COLLECTING
; 4005 : 
; 4006 : #ifdef __EVE_MINIGAME
; 4007 : 	prj.m_MiniGame.DestroyWnd_FiveSystem( pUser );

  00045	56		 push	 esi
  00046	b9 2c 91 11 00	 mov	 ecx, OFFSET FLAT:?prj@@3VCProject@@A+1151276
  0004b	e8 00 00 00 00	 call	 ?DestroyWnd_FiveSystem@CMiniGame@@QAEXPAVCUser@@@Z ; CMiniGame::DestroyWnd_FiveSystem

; 4008 : #endif // __EVE_MINIGAME
; 4009 : 
; 4010 : #if __VER >= 8 //__Y_FLAG_SKILL_BUFF
; 4011 : 	if( pUser->HasActivatedEatPet() )

  00050	83 be 7c 06 00
	00 ff		 cmp	 DWORD PTR [esi+1660], -1
  00057	74 07		 je	 SHORT $L280148

; 4012 : 		pUser->InactivateEatPet();

  00059	8b ce		 mov	 ecx, esi
  0005b	e8 00 00 00 00	 call	 ?InactivateEatPet@CMover@@QAEXXZ ; CMover::InactivateEatPet
$L280148:
  00060	55		 push	 ebp
  00061	57		 push	 edi

; 4013 : #endif //__Y_FLAG_SKILL_BUFF		
; 4014 : 
; 4015 : 	D3DXVECTOR3 vPos;
; 4016 : 	DWORD		dwWorldId;
; 4017 : #ifdef __LAYER_1015
; 4018 : 	int nLayer	= nDefaultLayer;
; 4019 : #endif	// __LAYER_1015
; 4020 : 
; 4021 : 	//       flaris 
; 4022 : 	if( pUser->GetWorld() && pUser->GetWorld()->GetID() == WI_WORLD_GUILDWAR )

  00062	8b be 6c 01 00
	00		 mov	 edi, DWORD PTR [esi+364]
  00068	85 ff		 test	 edi, edi
  0006a	0f 84 9a 00 00
	00		 je	 $L280152
  00070	81 3f ca 00 00
	00		 cmp	 DWORD PTR [edi], 202	; 000000caH
  00076	0f 85 8e 00 00
	00		 jne	 $L280152

; 4023 : 	{
; 4024 : 		PRegionElem pRgnElem = g_WorldMng.GetRevivalPos( WI_WORLD_MADRIGAL, "flaris" );

  0007c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_06NDLDHKAP@flaris?$AA@
  00081	6a 01		 push	 1
  00083	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_WorldMng@@3VCWorldMng@@A
  00088	e8 00 00 00 00	 call	 ?GetRevivalPos@CWorldMng@@QAEPAUREGIONELEM@@KPBD@Z ; CWorldMng::GetRevivalPos

; 4025 : 		if( pRgnElem )

  0008d	85 c0		 test	 eax, eax
  0008f	74 27		 je	 SHORT $L280155

; 4026 : 		{
; 4027 : 			dwWorldId	= pRgnElem->m_dwWorldId;

  00091	8b b8 c0 02 00
	00		 mov	 edi, DWORD PTR [eax+704]

; 4028 : 			vPos	= pRgnElem->m_vPos;

  00097	83 c0 10	 add	 eax, 16			; 00000010H
  0009a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0009c	89 4c 24 20	 mov	 DWORD PTR _vPos$[esp+56], ecx
  000a0	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000a3	89 54 24 24	 mov	 DWORD PTR _vPos$[esp+60], edx
  000a7	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000aa	89 44 24 28	 mov	 DWORD PTR _vPos$[esp+64], eax

; 4029 : #ifdef __LAYER_1015
; 4030 : 			nLayer	= nRevivalLayer;

  000ae	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR _nLayer$[esp+52], 0

; 4031 : #endif	// __LAYER_1015
; 4032 : 		}
; 4033 : 		else

  000b6	eb 2c		 jmp	 SHORT $L345107
$L280155:

; 4034 : 		{
; 4035 : 			dwWorldId	= pUser->GetWorld()->GetID();

  000b8	8b 8e 6c 01 00
	00		 mov	 ecx, DWORD PTR [esi+364]
  000be	8b 39		 mov	 edi, DWORD PTR [ecx]

; 4036 : 			vPos	= pUser->GetPos();

  000c0	8d 96 60 01 00
	00		 lea	 edx, DWORD PTR [esi+352]
  000c6	8b 02		 mov	 eax, DWORD PTR [edx]
  000c8	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  000cb	8b 52 08	 mov	 edx, DWORD PTR [edx+8]
  000ce	89 44 24 20	 mov	 DWORD PTR _vPos$[esp+56], eax

; 4037 : #ifdef __LAYER_1015
; 4038 : 			nLayer	= pUser->GetLayer();

  000d2	8b 86 b8 01 00
	00		 mov	 eax, DWORD PTR [esi+440]
  000d8	89 4c 24 24	 mov	 DWORD PTR _vPos$[esp+60], ecx
  000dc	89 54 24 28	 mov	 DWORD PTR _vPos$[esp+64], edx
  000e0	89 44 24 3c	 mov	 DWORD PTR _nLayer$[esp+52], eax
$L345107:

; 4039 : #endif	// __LAYER_1015
; 4040 : 		}
; 4041 : 		if( !pUser->IsDie() )

  000e4	8b 8e 3c 02 00
	00		 mov	 ecx, DWORD PTR [esi+572]
  000ea	f7 41 04 00 00
	00 08		 test	 DWORD PTR [ecx+4], 134217728 ; 08000000H
  000f1	0f 85 55 02 00
	00		 jne	 $L280183
  000f7	8b 86 00 06 00
	00		 mov	 eax, DWORD PTR [esi+1536]
  000fd	85 c0		 test	 eax, eax
  000ff	0f 84 47 02 00
	00		 je	 $L280183

; 4042 : 			pUser->RemoveAllEnemies();
; 4043 : 	}
; 4044 : 	else

  00105	e9 3b 02 00 00	 jmp	 $L345197
$L280152:

; 4045 : 	{
; 4046 : 		if( pUser->IsDie() )

  0010a	8b 8e 3c 02 00
	00		 mov	 ecx, DWORD PTR [esi+572]
  00110	f7 41 04 00 00
	00 08		 test	 DWORD PTR [ecx+4], 134217728 ; 08000000H
  00117	75 0e		 jne	 SHORT $L345127
  00119	8b 86 00 06 00
	00		 mov	 eax, DWORD PTR [esi+1536]
  0011f	85 c0		 test	 eax, eax
  00121	0f 85 dd 01 00
	00		 jne	 $L280160
$L345127:

; 4047 : 		{
; 4048 : 			CWorld* pWorld = pUser->GetWorld();
; 4049 : 			
; 4050 : 			CCommonCtrl* pCtrl	= CreateExpBox( pUser );

  00127	56		 push	 esi
  00128	e8 00 00 00 00	 call	 ?CreateExpBox@@YAPAVCCommonCtrl@@PAVCUser@@@Z ; CreateExpBox
  0012d	8b e8		 mov	 ebp, eax
  0012f	83 c4 04	 add	 esp, 4

; 4051 : 			if( pCtrl && pWorld )

  00132	85 ed		 test	 ebp, ebp
  00134	74 45		 je	 SHORT $L280163
  00136	85 ff		 test	 edi, edi
  00138	74 41		 je	 SHORT $L280163

; 4052 : 			{
; 4053 : 				pCtrl->AddItToGlobalId();

  0013a	8b 55 00	 mov	 edx, DWORD PTR [ebp]
  0013d	8b cd		 mov	 ecx, ebp
  0013f	ff 52 3c	 call	 DWORD PTR [edx+60]

; 4054 : 				pWorld->ADDOBJ( pCtrl, FALSE, pUser->GetLayer() );

  00142	8b 86 b8 01 00
	00		 mov	 eax, DWORD PTR [esi+440]
  00148	50		 push	 eax
  00149	6a 00		 push	 0
  0014b	55		 push	 ebp
  0014c	8b cf		 mov	 ecx, edi
  0014e	e8 00 00 00 00	 call	 ?AddObj@CWorld@@QAEHPAVCObj@@HH@Z ; CWorld::AddObj

; 4055 : 				g_dpDBClient.SendLogExpBox( pUser->m_idPlayer, pCtrl->GetId(), pCtrl->m_nExpBox );

  00153	8b 8d 3c 04 00
	00		 mov	 ecx, DWORD PTR [ebp+1084]
  00159	8b 95 38 04 00
	00		 mov	 edx, DWORD PTR [ebp+1080]
  0015f	8b 85 bc 01 00
	00		 mov	 eax, DWORD PTR [ebp+444]
  00165	6a 00		 push	 0
  00167	51		 push	 ecx
  00168	8b 8e 38 02 00
	00		 mov	 ecx, DWORD PTR [esi+568]
  0016e	52		 push	 edx
  0016f	50		 push	 eax
  00170	51		 push	 ecx
  00171	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_dpDBClient@@3VCDPDatabaseClient@@A
  00176	e8 00 00 00 00	 call	 ?SendLogExpBox@CDPDatabaseClient@@QAEXKK_JH@Z ; CDPDatabaseClient::SendLogExpBox
$L280163:

; 4056 : 			}
; 4057 : 			float fRate		= pUser->SubDieDecExp( FALSE );

  0017b	6a 00		 push	 0
  0017d	6a 00		 push	 0
  0017f	6a 00		 push	 0
  00181	8b ce		 mov	 ecx, esi
  00183	e8 00 00 00 00	 call	 ?SubDieDecExp@CMover@@QAEMHKH@Z ; CMover::SubDieDecExp
  00188	d9 5c 24 3c	 fstp	 DWORD PTR _fRate$280164[esp+52]

; 4058 : 			pUser->SetHitPoint( (int)(pUser->GetMaxHitPoint() * fRate) );	// hp 

  0018c	8b ce		 mov	 ecx, esi
  0018e	e8 00 00 00 00	 call	 ?GetMaxHitPoint@CMover@@QAEHXZ ; CMover::GetMaxHitPoint
  00193	89 44 24 10	 mov	 DWORD PTR tv909[esp+56], eax
  00197	db 44 24 10	 fild	 DWORD PTR tv909[esp+56]
  0019b	d8 4c 24 3c	 fmul	 DWORD PTR _fRate$280164[esp+52]
  0019f	e8 00 00 00 00	 call	 __ftol2
  001a4	50		 push	 eax
  001a5	8b ce		 mov	 ecx, esi
  001a7	e8 00 00 00 00	 call	 ?SetHitPoint@CMover@@QAEXH@Z ; CMover::SetHitPoint

; 4059 : 			int nVal	= (int)(pUser->GetMaxManaPoint() * fRate);			// mp 

  001ac	8b ce		 mov	 ecx, esi
  001ae	e8 00 00 00 00	 call	 ?GetMaxManaPoint@CMover@@QAEHXZ ; CMover::GetMaxManaPoint
  001b3	89 44 24 10	 mov	 DWORD PTR tv905[esp+56], eax
  001b7	db 44 24 10	 fild	 DWORD PTR tv905[esp+56]
  001bb	d8 4c 24 3c	 fmul	 DWORD PTR _fRate$280164[esp+52]
  001bf	e8 00 00 00 00	 call	 __ftol2

; 4060 : 			if( pUser->GetManaPoint() < nVal )

  001c4	8b ce		 mov	 ecx, esi
  001c6	8b d8		 mov	 ebx, eax
  001c8	e8 00 00 00 00	 call	 ?GetManaPoint@CMover@@QAEHXZ ; CMover::GetManaPoint
  001cd	3b c3		 cmp	 eax, ebx
  001cf	7d 08		 jge	 SHORT $L280168

; 4061 : 				pUser->SetManaPoint( nVal );

  001d1	53		 push	 ebx
  001d2	8b ce		 mov	 ecx, esi
  001d4	e8 00 00 00 00	 call	 ?SetManaPoint@CMover@@QAEXH@Z ; CMover::SetManaPoint
$L280168:

; 4062 : 			nVal	= (int)(pUser->GetMaxFatiguePoint() * fRate);			// fp 

  001d9	8b ce		 mov	 ecx, esi
  001db	e8 00 00 00 00	 call	 ?GetMaxFatiguePoint@CMover@@QAEHXZ ; CMover::GetMaxFatiguePoint
  001e0	89 44 24 10	 mov	 DWORD PTR tv900[esp+56], eax
  001e4	db 44 24 10	 fild	 DWORD PTR tv900[esp+56]
  001e8	d8 4c 24 3c	 fmul	 DWORD PTR _fRate$280164[esp+52]
  001ec	e8 00 00 00 00	 call	 __ftol2

; 4063 : 			if( pUser->GetFatiguePoint() < nVal )

  001f1	8b ce		 mov	 ecx, esi
  001f3	8b d8		 mov	 ebx, eax
  001f5	e8 00 00 00 00	 call	 ?GetFatiguePoint@CMover@@QAEHXZ ; CMover::GetFatiguePoint
  001fa	3b c3		 cmp	 eax, ebx
  001fc	7d 08		 jge	 SHORT $L280170

; 4064 : 				pUser->SetFatiguePoint( nVal );

  001fe	53		 push	 ebx
  001ff	8b ce		 mov	 ecx, esi
  00201	e8 00 00 00 00	 call	 ?SetFatiguePoint@CMover@@QAEXH@Z ; CMover::SetFatiguePoint
$L280170:

; 4065 : 			
; 4066 : 
; 4067 : 			PRegionElem pRgnElem	= NULL;
; 4068 : 			if( pUser->IsChaotic() )

  00206	8b 86 60 07 00
	00		 mov	 eax, DWORD PTR [esi+1888]

; 4069 : 			{
; 4070 : #if __VER >= 8 // __S8_PK
; 4071 : 				if( pWorld->GetID() != pWorld->m_dwIdWorldRevival && pWorld->m_dwIdWorldRevival != 0 )

  0020c	8b 0f		 mov	 ecx, DWORD PTR [edi]
  0020e	85 c0		 test	 eax, eax
  00210	8b 87 18 93 08
	00		 mov	 eax, DWORD PTR [edi+561944]
  00216	76 52		 jbe	 SHORT $L280172
  00218	3b c8		 cmp	 ecx, eax
  0021a	74 1e		 je	 SHORT $L345452
  0021c	85 c0		 test	 eax, eax
  0021e	74 1a		 je	 SHORT $L345452

; 4072 : 					pRgnElem	= g_WorldMng.GetRevivalPosChao( pWorld->m_dwIdWorldRevival, pWorld->m_szKeyRevival );

  00220	8d 97 f8 92 08
	00		 lea	 edx, DWORD PTR [edi+561912]
  00226	52		 push	 edx
  00227	50		 push	 eax
  00228	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_WorldMng@@3VCWorldMng@@A
  0022d	e8 00 00 00 00	 call	 ?GetRevivalPosChao@CWorldMng@@QAEPAUREGIONELEM@@KPBD@Z ; CWorldMng::GetRevivalPosChao

; 4073 : 				
; 4074 : 				if( NULL == pRgnElem )

  00232	85 c0		 test	 eax, eax
  00234	0f 85 80 00 00
	00		 jne	 $L345449
$L345452:

; 4075 : 					pRgnElem	= g_WorldMng.GetNearRevivalPosChao( pWorld->GetID(), pUser->GetPos() );

  0023a	8d ae 60 01 00
	00		 lea	 ebp, DWORD PTR [esi+352]
  00240	8b c5		 mov	 eax, ebp
  00242	8b 08		 mov	 ecx, DWORD PTR [eax]
  00244	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00247	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0024a	89 4c 24 2c	 mov	 DWORD PTR $T345054[esp+56], ecx
  0024e	8d 4c 24 2c	 lea	 ecx, DWORD PTR $T345054[esp+56]
  00252	89 44 24 34	 mov	 DWORD PTR $T345054[esp+64], eax
  00256	8b 07		 mov	 eax, DWORD PTR [edi]
  00258	51		 push	 ecx
  00259	50		 push	 eax
  0025a	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_WorldMng@@3VCWorldMng@@A
  0025f	89 54 24 38	 mov	 DWORD PTR $T345054[esp+68], edx
  00263	e8 00 00 00 00	 call	 ?GetNearRevivalPosChao@CWorldMng@@QAEPAUREGIONELEM@@KAAUD3DXVECTOR3@@@Z ; CWorldMng::GetNearRevivalPosChao

; 4076 : #else // __VER >= 8 // __S8_PK
; 4077 : 				pRgnElem	= g_WorldMng.GetNearRevivalPosChao( pWorld->GetID(), pUser->GetPos() );
; 4078 : #endif // __VER >= 8 // __S8_PK
; 4079 : 			}
; 4080 : 			else

  00268	eb 4c		 jmp	 SHORT $L280178
$L280172:

; 4081 : 			{
; 4082 : 				if( pWorld->GetID() != pWorld->m_dwIdWorldRevival && pWorld->m_dwIdWorldRevival != 0 )

  0026a	3b c8		 cmp	 ecx, eax
  0026c	74 1a		 je	 SHORT $L345453
  0026e	85 c0		 test	 eax, eax
  00270	74 16		 je	 SHORT $L345453

; 4083 : 					pRgnElem	= g_WorldMng.GetRevivalPos( pWorld->m_dwIdWorldRevival, pWorld->m_szKeyRevival );

  00272	8d 97 f8 92 08
	00		 lea	 edx, DWORD PTR [edi+561912]
  00278	52		 push	 edx
  00279	50		 push	 eax
  0027a	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_WorldMng@@3VCWorldMng@@A
  0027f	e8 00 00 00 00	 call	 ?GetRevivalPos@CWorldMng@@QAEPAUREGIONELEM@@KPBD@Z ; CWorldMng::GetRevivalPos

; 4084 : 				
; 4085 : 				if( NULL == pRgnElem )

  00284	85 c0		 test	 eax, eax
  00286	75 32		 jne	 SHORT $L345449
$L345453:

; 4086 : 					pRgnElem	= g_WorldMng.GetNearRevivalPos( pWorld->GetID(), pUser->GetPos() );

  00288	8d ae 60 01 00
	00		 lea	 ebp, DWORD PTR [esi+352]
  0028e	8b c5		 mov	 eax, ebp
  00290	8b 08		 mov	 ecx, DWORD PTR [eax]
  00292	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00295	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00298	89 4c 24 2c	 mov	 DWORD PTR $T345055[esp+56], ecx
  0029c	8d 4c 24 2c	 lea	 ecx, DWORD PTR $T345055[esp+56]
  002a0	89 44 24 34	 mov	 DWORD PTR $T345055[esp+64], eax
  002a4	8b 07		 mov	 eax, DWORD PTR [edi]
  002a6	51		 push	 ecx
  002a7	50		 push	 eax
  002a8	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_WorldMng@@3VCWorldMng@@A
  002ad	89 54 24 38	 mov	 DWORD PTR $T345055[esp+68], edx
  002b1	e8 00 00 00 00	 call	 ?GetNearRevivalPos@CWorldMng@@QAEPAUREGIONELEM@@KAAUD3DXVECTOR3@@@Z ; CWorldMng::GetNearRevivalPos
$L280178:

; 4087 : 			}
; 4088 : 
; 4089 : 			if( pRgnElem )

  002b6	85 c0		 test	 eax, eax
  002b8	74 27		 je	 SHORT $L280180
$L345449:

; 4090 : 			{
; 4091 : 				dwWorldId	= pRgnElem->m_dwWorldId;

  002ba	8b b8 c0 02 00
	00		 mov	 edi, DWORD PTR [eax+704]

; 4092 : 				vPos	= pRgnElem->m_vPos;

  002c0	83 c0 10	 add	 eax, 16			; 00000010H
  002c3	8b 10		 mov	 edx, DWORD PTR [eax]
  002c5	89 54 24 20	 mov	 DWORD PTR _vPos$[esp+56], edx
  002c9	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  002cc	89 4c 24 24	 mov	 DWORD PTR _vPos$[esp+60], ecx
  002d0	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  002d3	89 54 24 28	 mov	 DWORD PTR _vPos$[esp+64], edx

; 4093 : #ifdef __LAYER_1015
; 4094 : 				nLayer	= nRevivalLayer;

  002d7	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR _nLayer$[esp+52], 0

; 4095 : #endif	// __LAYER_1015
; 4096 : 			}
; 4097 : 			else

  002df	eb 6b		 jmp	 SHORT $L280183
$L280180:

; 4098 : 			{
; 4099 : 				dwWorldId	= pWorld->GetID();

  002e1	8b 3f		 mov	 edi, DWORD PTR [edi]

; 4100 : 				vPos	= pUser->GetPos();

  002e3	8b 45 00	 mov	 eax, DWORD PTR [ebp]
  002e6	8b 4d 04	 mov	 ecx, DWORD PTR [ebp+4]
  002e9	8b 55 08	 mov	 edx, DWORD PTR [ebp+8]
  002ec	89 44 24 20	 mov	 DWORD PTR _vPos$[esp+56], eax

; 4101 : #ifdef __LAYER_1015
; 4102 : 				nLayer	= pUser->GetLayer();

  002f0	8b 86 b8 01 00
	00		 mov	 eax, DWORD PTR [esi+440]
  002f6	89 4c 24 24	 mov	 DWORD PTR _vPos$[esp+60], ecx
  002fa	89 54 24 28	 mov	 DWORD PTR _vPos$[esp+64], edx
  002fe	89 44 24 3c	 mov	 DWORD PTR _nLayer$[esp+52], eax

; 4103 : #endif	// __LAYER_1015
; 4104 : 			}
; 4105 : 		}
; 4106 : 		else 

  00302	eb 48		 jmp	 SHORT $L280183
$L280160:

; 4107 : 		{
; 4108 : 			dwWorldId	= pWorld->GetID();

  00304	8b 3b		 mov	 edi, DWORD PTR [ebx]

; 4109 : 			vPos	= pUser->GetPos();

  00306	8d 96 60 01 00
	00		 lea	 edx, DWORD PTR [esi+352]
  0030c	8b 02		 mov	 eax, DWORD PTR [edx]
  0030e	89 44 24 20	 mov	 DWORD PTR _vPos$[esp+56], eax
  00312	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00315	8b 52 08	 mov	 edx, DWORD PTR [edx+8]
  00318	89 44 24 24	 mov	 DWORD PTR _vPos$[esp+60], eax

; 4110 : #ifdef __LAYER_1015
; 4111 : 			nLayer	= pUser->GetLayer();

  0031c	8b 86 b8 01 00
	00		 mov	 eax, DWORD PTR [esi+440]
  00322	89 54 24 28	 mov	 DWORD PTR _vPos$[esp+64], edx
  00326	89 44 24 3c	 mov	 DWORD PTR _nLayer$[esp+52], eax

; 4112 : #endif	// __LAYER_1015
; 4113 : 			if( pUser->IsFly() )	//  .

  0032a	f6 41 08 08	 test	 BYTE PTR [ecx+8], 8
  0032e	74 15		 je	 SHORT $L345197

; 4114 : 				pUser->SendActMsg( OBJMSG_STOP );

  00330	85 c9		 test	 ecx, ecx
  00332	74 11		 je	 SHORT $L345197
  00334	8b 11		 mov	 edx, DWORD PTR [ecx]
  00336	6a 00		 push	 0
  00338	6a 00		 push	 0
  0033a	6a 00		 push	 0
  0033c	6a 00		 push	 0
  0033e	6a 00		 push	 0
  00340	6a 06		 push	 6
  00342	ff 52 04	 call	 DWORD PTR [edx+4]
$L345197:

; 4115 : 
; 4116 : 			pUser->RemoveAllEnemies();

  00345	8b ce		 mov	 ecx, esi
  00347	e8 00 00 00 00	 call	 ?RemoveAllEnemies@CMover@@QAEXXZ ; CMover::RemoveAllEnemies
$L280183:

; 4117 : 		}
; 4118 : 	}
; 4119 : 
; 4120 : 	CChatting* pChatting = g_ChattingMng.GetChttingRoom( pUser->m_idChatting );

  0034c	8b 86 98 95 00
	00		 mov	 eax, DWORD PTR [esi+38296]
  00352	50		 push	 eax
  00353	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_ChattingMng@@3VCChattingMng@@A
  00358	e8 00 00 00 00	 call	 ?GetChttingRoom@CChattingMng@@QAEPAVCChatting@@K@Z ; CChattingMng::GetChttingRoom
  0035d	8b d8		 mov	 ebx, eax

; 4121 : 	if( pChatting )

  0035f	33 ed		 xor	 ebp, ebp
  00361	3b dd		 cmp	 ebx, ebp
  00363	74 75		 je	 SHORT $L280187

; 4122 : 	{
; 4123 : 		CUser * pUserBuf;
; 4124 : 		for( int i = 0 ; i < pChatting->GetChattingMember() ; ++i )

  00365	39 6b 28	 cmp	 DWORD PTR [ebx+40], ebp
  00368	89 6c 24 10	 mov	 DWORD PTR _i$280189[esp+56], ebp
  0036c	7e 58		 jle	 SHORT $L280192
  0036e	8d 6b 2c	 lea	 ebp, DWORD PTR [ebx+44]
$L280190:

; 4125 : 		{
; 4126 : 			pUserBuf = (CUser*)prj.GetUserByID( pChatting->m_idMember[i] );

  00371	8b 4d 00	 mov	 ecx, DWORD PTR [ebp]
  00374	8d 54 24 14	 lea	 edx, DWORD PTR $T345276[esp+56]
  00378	52		 push	 edx
  00379	8d 44 24 1c	 lea	 eax, DWORD PTR _i$345274[esp+60]
  0037d	89 4c 24 18	 mov	 DWORD PTR $T345276[esp+60], ecx
  00381	50		 push	 eax
  00382	b9 38 00 00 00	 mov	 ecx, OFFSET FLAT:?prj@@3VCProject@@A+56
  00387	e8 00 00 00 00	 call	 ?find@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::find
  0038c	8b 44 24 18	 mov	 eax, DWORD PTR _i$345274[esp+56]
  00390	3b 05 3c 00 00
	00		 cmp	 eax, DWORD PTR ?prj@@3VCProject@@A+60
  00396	74 19		 je	 SHORT $L280191
  00398	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]

; 4127 : 			if( ::IsValidObj( pUserBuf ) )

  0039b	85 c9		 test	 ecx, ecx
  0039d	74 12		 je	 SHORT $L280191
  0039f	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  003a3	75 0c		 jne	 SHORT $L280191

; 4128 : 			{
; 4129 : 				//  
; 4130 : 				pUserBuf->AddRemoveChatting( pUser->m_idPlayer );

  003a5	8b 96 38 02 00
	00		 mov	 edx, DWORD PTR [esi+568]
  003ab	52		 push	 edx
  003ac	e8 00 00 00 00	 call	 ?AddRemoveChatting@CUser@@QAEXK@Z ; CUser::AddRemoveChatting
$L280191:
  003b1	8b 44 24 10	 mov	 eax, DWORD PTR _i$280189[esp+56]
  003b5	8b 4b 28	 mov	 ecx, DWORD PTR [ebx+40]
  003b8	40		 inc	 eax
  003b9	83 c5 04	 add	 ebp, 4
  003bc	3b c1		 cmp	 eax, ecx
  003be	89 44 24 10	 mov	 DWORD PTR _i$280189[esp+56], eax
  003c2	7c ad		 jl	 SHORT $L280190

; 4122 : 	{
; 4123 : 		CUser * pUserBuf;
; 4124 : 		for( int i = 0 ; i < pChatting->GetChattingMember() ; ++i )

  003c4	33 ed		 xor	 ebp, ebp
$L280192:

; 4131 : 			}
; 4132 : 		}
; 4133 : 		pChatting->RemoveChattingMember( pUser->m_idPlayer );

  003c6	8b 86 38 02 00
	00		 mov	 eax, DWORD PTR [esi+568]
  003cc	50		 push	 eax
  003cd	8b cb		 mov	 ecx, ebx
  003cf	e8 00 00 00 00	 call	 ?RemoveChattingMember@CChatting@@QAEHK@Z ; CChatting::RemoveChattingMember

; 4134 : 		pUser->m_idChatting = 0;

  003d4	89 ae 98 95 00
	00		 mov	 DWORD PTR [esi+38296], ebp
$L280187:

; 4135 : 	}	
; 4136 : 
; 4137 : #if __VER >= 12 // __SECRET_ROOM
; 4138 : 	//   -      
; 4139 : 	if( CSecretRoomMng::GetInstance()->IsInTheSecretRoom( pUser ) )

  003da	56		 push	 esi
  003db	e8 00 00 00 00	 call	 ?GetInstance@CSecretRoomMng@@SAPAV1@XZ ; CSecretRoomMng::GetInstance
  003e0	8b c8		 mov	 ecx, eax
  003e2	e8 00 00 00 00	 call	 ?IsInTheSecretRoom@CSecretRoomMng@@QAEHPAVCMover@@@Z ; CSecretRoomMng::IsInTheSecretRoom
  003e7	85 c0		 test	 eax, eax
  003e9	74 2f		 je	 SHORT $L345459

; 4140 : 	{
; 4141 : 		//if( CSecretRoomMng::GetInstance()->IsGuildMaster( pUser ) )
; 4142 : 		//	CSecretRoomMng::GetInstance()->SetFailGuild( pUser );
; 4143 : 		
; 4144 : 		dwWorldId = WI_WORLD_MADRIGAL;
; 4145 : 		vPos = CSecretRoomMng::GetInstance()->GetRevivalPos( pUser );

  003eb	8d 4c 24 2c	 lea	 ecx, DWORD PTR $T345058[esp+56]
  003ef	56		 push	 esi
  003f0	51		 push	 ecx
  003f1	bf 01 00 00 00	 mov	 edi, 1
  003f6	e8 00 00 00 00	 call	 ?GetInstance@CSecretRoomMng@@SAPAV1@XZ ; CSecretRoomMng::GetInstance
  003fb	8b c8		 mov	 ecx, eax
  003fd	e8 00 00 00 00	 call	 ?GetRevivalPos@CSecretRoomMng@@QAE?AUD3DXVECTOR3@@PAVCUser@@@Z ; CSecretRoomMng::GetRevivalPos
  00402	8b 10		 mov	 edx, DWORD PTR [eax]
  00404	89 54 24 20	 mov	 DWORD PTR _vPos$[esp+56], edx
  00408	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0040b	89 4c 24 24	 mov	 DWORD PTR _vPos$[esp+60], ecx
  0040f	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00412	89 54 24 28	 mov	 DWORD PTR _vPos$[esp+64], edx

; 4146 : #ifdef __LAYER_1015
; 4147 : 		nLayer	= nRevivalLayer;

  00416	89 6c 24 3c	 mov	 DWORD PTR _nLayer$[esp+52], ebp
$L345459:

; 4148 : #endif	// __LAYER_1015
; 4149 : 	}
; 4150 : 	
; 4151 : 	//    ...
; 4152 : 	if( pUser->GetWorld() && pUser->GetWorld()->GetID() == WI_DUNGEON_SECRET_0 )

  0041a	8b 86 6c 01 00
	00		 mov	 eax, DWORD PTR [esi+364]
  00420	3b c5		 cmp	 eax, ebp
  00422	0f 84 ac 00 00
	00		 je	 $L280201
  00428	81 38 97 00 00
	00		 cmp	 DWORD PTR [eax], 151	; 00000097H
  0042e	75 5f		 jne	 SHORT $L345461

; 4153 : 	{
; 4154 : #ifdef __LAYER_1015
; 4155 : 		nLayer	= nDefaultLayer;
; 4156 : #endif	// __LAYER_1015
; 4157 : 		if( pUser->m_idMarkingWorld == WI_WORLD_MADRIGAL )

  00430	8b 8e a8 0e 00
	00		 mov	 ecx, DWORD PTR [esi+3752]
  00436	bf 01 00 00 00	 mov	 edi, 1
  0043b	3b cf		 cmp	 ecx, edi
  0043d	89 6c 24 3c	 mov	 DWORD PTR _nLayer$[esp+52], ebp
  00441	75 1c		 jne	 SHORT $L280198

; 4158 : 		{
; 4159 : 			dwWorldId = pUser->m_idMarkingWorld;
; 4160 : 			vPos = pUser->m_vMarkingPos;

  00443	8d 8e 9c 0e 00
	00		 lea	 ecx, DWORD PTR [esi+3740]
  00449	8b 11		 mov	 edx, DWORD PTR [ecx]
  0044b	89 54 24 20	 mov	 DWORD PTR _vPos$[esp+56], edx
  0044f	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00452	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  00455	89 54 24 24	 mov	 DWORD PTR _vPos$[esp+60], edx
  00459	89 4c 24 28	 mov	 DWORD PTR _vPos$[esp+64], ecx

; 4161 : 		}
; 4162 : 		else

  0045d	eb 30		 jmp	 SHORT $L345461
$L280198:

; 4163 : 		{
; 4164 : 			dwWorldId = WI_WORLD_MADRIGAL;
; 4165 : 			vPos = D3DXVECTOR3( 6968, 100, 3328 );

  0045f	c7 44 24 2c 00
	c0 d9 45	 mov	 DWORD PTR $T345059[esp+56], 1171898368 ; 45d9c000H
  00467	8b 54 24 2c	 mov	 edx, DWORD PTR $T345059[esp+56]
  0046b	c7 44 24 30 00
	00 c8 42	 mov	 DWORD PTR $T345059[esp+60], 1120403456 ; 42c80000H
  00473	8b 4c 24 30	 mov	 ecx, DWORD PTR $T345059[esp+60]
  00477	c7 44 24 34 00
	00 50 45	 mov	 DWORD PTR $T345059[esp+64], 1162870784 ; 45500000H
  0047f	89 54 24 20	 mov	 DWORD PTR _vPos$[esp+56], edx
  00483	8b 54 24 34	 mov	 edx, DWORD PTR $T345059[esp+64]
  00487	89 4c 24 24	 mov	 DWORD PTR _vPos$[esp+60], ecx
  0048b	89 54 24 28	 mov	 DWORD PTR _vPos$[esp+64], edx
$L345461:

; 4166 : 		}
; 4167 : 	}
; 4168 : #endif // __SECRET_ROOM
; 4169 : 
; 4170 : #if __VER >= 13 // __HOUSING
; 4171 : 	if( pUser->GetWorld() && pUser->GetWorld()->GetID() == WI_WORLD_MINIROOM )

  0048f	3b c5		 cmp	 eax, ebp
  00491	74 41		 je	 SHORT $L280201
  00493	81 38 d1 00 00
	00		 cmp	 DWORD PTR [eax], 209	; 000000d1H
  00499	75 39		 jne	 SHORT $L280201

; 4172 : 	{
; 4173 : 		dwWorldId = WI_WORLD_MADRIGAL;
; 4174 : 		vPos = D3DXVECTOR3( 6968, 100, 3328 );

  0049b	c7 44 24 2c 00
	c0 d9 45	 mov	 DWORD PTR $T345060[esp+56], 1171898368 ; 45d9c000H
  004a3	8b 44 24 2c	 mov	 eax, DWORD PTR $T345060[esp+56]
  004a7	c7 44 24 30 00
	00 c8 42	 mov	 DWORD PTR $T345060[esp+60], 1120403456 ; 42c80000H
  004af	8b 4c 24 30	 mov	 ecx, DWORD PTR $T345060[esp+60]
  004b3	c7 44 24 34 00
	00 50 45	 mov	 DWORD PTR $T345060[esp+64], 1162870784 ; 45500000H
  004bb	8b 54 24 34	 mov	 edx, DWORD PTR $T345060[esp+64]
  004bf	bf 01 00 00 00	 mov	 edi, 1
  004c4	89 44 24 20	 mov	 DWORD PTR _vPos$[esp+56], eax
  004c8	89 4c 24 24	 mov	 DWORD PTR _vPos$[esp+60], ecx
  004cc	89 54 24 28	 mov	 DWORD PTR _vPos$[esp+64], edx

; 4175 : #ifdef __LAYER_1015
; 4176 : 		nLayer	= nDefaultLayer;

  004d0	89 6c 24 3c	 mov	 DWORD PTR _nLayer$[esp+52], ebp
$L280201:

; 4177 : #endif	// __LAYER_1015
; 4178 : 	}
; 4179 : 	CHousingMng::GetInstance()->DestroyHousing( pUser->m_idPlayer );

  004d4	8b 86 38 02 00
	00		 mov	 eax, DWORD PTR [esi+568]
  004da	50		 push	 eax
  004db	e8 00 00 00 00	 call	 ?GetInstance@CHousingMng@@SAPAV1@XZ ; CHousingMng::GetInstance
  004e0	8b c8		 mov	 ecx, eax
  004e2	e8 00 00 00 00	 call	 ?DestroyHousing@CHousingMng@@QAEHK@Z ; CHousingMng::DestroyHousing

; 4180 : #endif // __HOUSING
; 4181 : 
; 4182 : #if __VER >= 13 // __RAINBOW_RACE
; 4183 : 	//     chipi_090317
; 4184 : 	CRainbowRaceMng::GetInstance()->SetDropOut( pUser->m_idPlayer );

  004e7	8b 8e 38 02 00
	00		 mov	 ecx, DWORD PTR [esi+568]
  004ed	51		 push	 ecx
  004ee	e8 00 00 00 00	 call	 ?GetInstance@CRainbowRaceMng@@SAPAV1@XZ ; CRainbowRaceMng::GetInstance
  004f3	8b c8		 mov	 ecx, eax
  004f5	e8 00 00 00 00	 call	 ?SetDropOut@CRainbowRaceMng@@QAEHK@Z ; CRainbowRaceMng::SetDropOut

; 4185 : #endif // __RAINBOW_RACE
; 4186 : 
; 4187 : #if __VER >= 14 // __INSTANCE_DUNGEON
; 4188 : 	if( CInstanceDungeonHelper::GetInstance()->IsInstanceDungeon( pUser->GetWorld()->GetID() ) )

  004fa	8b 96 6c 01 00
	00		 mov	 edx, DWORD PTR [esi+364]
  00500	8b 1a		 mov	 ebx, DWORD PTR [edx]
  00502	e8 00 00 00 00	 call	 ?GetInstance@CInstanceDungeonHelper@@SAPAV1@XZ ; CInstanceDungeonHelper::GetInstance
  00507	53		 push	 ebx
  00508	8b c8		 mov	 ecx, eax
  0050a	e8 00 00 00 00	 call	 ?GetType@CInstanceDungeonHelper@@AAEHK@Z ; CInstanceDungeonHelper::GetType
  0050f	83 f8 ff	 cmp	 eax, -1
  00512	74 60		 je	 SHORT $L345460

; 4189 : 	{
; 4190 : 		CInstanceDungeonHelper::GetInstance()->GoOut( pUser );

  00514	56		 push	 esi
  00515	e8 00 00 00 00	 call	 ?GetInstance@CInstanceDungeonHelper@@SAPAV1@XZ ; CInstanceDungeonHelper::GetInstance
  0051a	8b c8		 mov	 ecx, eax
  0051c	e8 00 00 00 00	 call	 ?GoOut@CInstanceDungeonHelper@@QAEXPAVCUser@@@Z ; CInstanceDungeonHelper::GoOut

; 4191 : 		if( pUser->m_idMarkingWorld == WI_WORLD_MADRIGAL )

  00521	8b 86 a8 0e 00
	00		 mov	 eax, DWORD PTR [esi+3752]
  00527	bf 01 00 00 00	 mov	 edi, 1
  0052c	3b c7		 cmp	 eax, edi
  0052e	75 10		 jne	 SHORT $L280204

; 4192 : 		{
; 4193 : 			dwWorldId = pUser->m_idMarkingWorld;
; 4194 : 			vPos = pUser->m_vMarkingPos;

  00530	8d 86 9c 0e 00
	00		 lea	 eax, DWORD PTR [esi+3740]
  00536	8b 08		 mov	 ecx, DWORD PTR [eax]
  00538	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0053b	8b 40 08	 mov	 eax, DWORD PTR [eax+8]

; 4195 : 		}
; 4196 : 		else

  0053e	eb 24		 jmp	 SHORT $L345465
$L280204:

; 4197 : 		{
; 4198 : 			dwWorldId = WI_WORLD_MADRIGAL;
; 4199 : 			vPos = D3DXVECTOR3( 6968, 100, 3328 );

  00540	c7 44 24 2c 00
	c0 d9 45	 mov	 DWORD PTR $T345061[esp+56], 1171898368 ; 45d9c000H
  00548	8b 4c 24 2c	 mov	 ecx, DWORD PTR $T345061[esp+56]
  0054c	c7 44 24 30 00
	00 c8 42	 mov	 DWORD PTR $T345061[esp+60], 1120403456 ; 42c80000H
  00554	8b 54 24 30	 mov	 edx, DWORD PTR $T345061[esp+60]
  00558	c7 44 24 34 00
	00 50 45	 mov	 DWORD PTR $T345061[esp+64], 1162870784 ; 45500000H
  00560	8b 44 24 34	 mov	 eax, DWORD PTR $T345061[esp+64]
$L345465:
  00564	89 4c 24 20	 mov	 DWORD PTR _vPos$[esp+56], ecx
  00568	89 54 24 24	 mov	 DWORD PTR _vPos$[esp+60], edx
  0056c	89 44 24 28	 mov	 DWORD PTR _vPos$[esp+64], eax

; 4200 : 		}
; 4201 : 		nLayer = nDefaultLayer;

  00570	89 6c 24 3c	 mov	 DWORD PTR _nLayer$[esp+52], ebp
$L345460:

; 4202 : 	}
; 4203 : #endif // __INSTANCE_DUNGEON
; 4204 : 
; 4205 : #ifdef __LAYER_1015
; 4206 : 	g_dpDBClient.SavePlayer( pUser, dwWorldId, vPos, nLayer, TRUE );

  00574	8b 4c 24 3c	 mov	 ecx, DWORD PTR _nLayer$[esp+52]
  00578	6a 01		 push	 1
  0057a	51		 push	 ecx
  0057b	8d 54 24 28	 lea	 edx, DWORD PTR _vPos$[esp+64]
  0057f	52		 push	 edx
  00580	57		 push	 edi
  00581	56		 push	 esi
  00582	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_dpDBClient@@3VCDPDatabaseClient@@A
  00587	e8 00 00 00 00	 call	 ?SavePlayer@CDPDatabaseClient@@QAEXPAVCUser@@KAAUD3DXVECTOR3@@HH@Z ; CDPDatabaseClient::SavePlayer

; 4207 : #else	// __LAYER_1015
; 4208 : 	g_dpDBClient.SavePlayer( pUser, dwWorldId, vPos, TRUE );
; 4209 : #endif	// __LAYER_1015
; 4210 : 
; 4211 : #ifdef __S_NEW_SKILL_2
; 4212 : 	g_dpDBClient.SaveSkill( pUser );	//    
; 4213 : #endif // __S_NEW_SKILL_2
; 4214 : 	g_dpDBClient.SendLogConnect( pUser );

  0058c	56		 push	 esi
  0058d	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_dpDBClient@@3VCDPDatabaseClient@@A
  00592	e8 00 00 00 00	 call	 ?SendLogConnect@CDPDatabaseClient@@QAEXPAVCUser@@@Z ; CDPDatabaseClient::SendLogConnect

; 4215 : #if __VER >= 14 // __PCBANG
; 4216 : 	CPCBang::GetInstance()->DestroyPCBangPlayer( pUser->m_idPlayer );

  00597	8b 86 38 02 00
	00		 mov	 eax, DWORD PTR [esi+568]
  0059d	50		 push	 eax
  0059e	e8 00 00 00 00	 call	 ?GetInstance@CPCBang@@SAPAV1@XZ ; CPCBang::GetInstance
  005a3	8b c8		 mov	 ecx, eax
  005a5	e8 00 00 00 00	 call	 ?DestroyPCBangPlayer@CPCBang@@QAEXK@Z ; CPCBang::DestroyPCBangPlayer

; 4217 : #endif // __PCBANG
; 4218 : #if __VER >= 15 // __GUILD_HOUSE
; 4219 : 	GuildHouseMng->GoOutGuildHouse( pUser );

  005aa	56		 push	 esi
  005ab	e8 00 00 00 00	 call	 ?GetInstance@CGuildHouseMng@@SAPAV1@XZ ; CGuildHouseMng::GetInstance
  005b0	8b c8		 mov	 ecx, eax
  005b2	e8 00 00 00 00	 call	 ?GoOutGuildHouse@CGuildHouseMng@@QAEXPAVCUser@@@Z ; CGuildHouseMng::GoOutGuildHouse

; 4220 : #endif // __GUILD_HOUSE
; 4221 : #ifdef __INVALID_LOGIN_0320
; 4222 : 	g_dpDBClient.CalluspXXXMultiServer( 0, pUser );

  005b7	56		 push	 esi
  005b8	55		 push	 ebp
  005b9	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_dpDBClient@@3VCDPDatabaseClient@@A
  005be	e8 00 00 00 00	 call	 ?CalluspXXXMultiServer@CDPDatabaseClient@@QAEXKPAVCUser@@@Z ; CDPDatabaseClient::CalluspXXXMultiServer

; 4223 : #else	// __INVALID_LOGIN_0320
; 4224 : 	g_dpDBClient.CalluspXXXMultiServer( 0, pUser->m_idPlayer );
; 4225 : #endif	// __INVALID_LOGIN_0320
; 4226 : 
; 4227 : 	
; 4228 : 	//////////////////////////////////////////////////////////////////////////
; 4229 : 	pUser->ResetCheckClientReq();
; 4230 : 	//////////////////////////////////////////////////////////////////////////
; 4231 : 
; 4232 : 
; 4233 : 	if( pWorld->DoNotAdd( pUser ) )		// pUser m_apAddObjs  LINKMAP . 

  005c3	8b 4c 24 1c	 mov	 ecx, DWORD PTR _pWorld$[esp+56]
  005c7	56		 push	 esi
  005c8	89 ae e0 16 00
	00		 mov	 DWORD PTR [esi+5856], ebp
  005ce	89 ae dc 16 00
	00		 mov	 DWORD PTR [esi+5852], ebp
  005d4	e8 00 00 00 00	 call	 ?DoNotAdd@CWorld@@QAEHPAVCObj@@@Z ; CWorld::DoNotAdd
  005d9	85 c0		 test	 eax, eax

; 4234 : 	{
; 4235 : 		SAFE_DELETE( pUser );			//   

  005db	8b ce		 mov	 ecx, esi
  005dd	74 10		 je	 SHORT $L280207
  005df	8b 16		 mov	 edx, DWORD PTR [esi]
  005e1	6a 01		 push	 1
  005e3	ff 12		 call	 DWORD PTR [edx]
  005e5	5f		 pop	 edi
  005e6	5d		 pop	 ebp
  005e7	5e		 pop	 esi
  005e8	5b		 pop	 ebx

; 4259 : 				}
; 4260 : 			}
; 4261 : 		}
; 4262 : #endif // __GUILD_COMBAT_1TO1
; 4263 : 	}
; 4264 : }

  005e9	83 c4 28	 add	 esp, 40			; 00000028H
  005ec	c2 04 00	 ret	 4
$L280207:

; 4236 : 	}
; 4237 : 	else
; 4238 : 	{
; 4239 : 		pUser->Delete();				//   .

  005ef	e8 00 00 00 00	 call	 ?Delete@CObj@@QAEXXZ	; CObj::Delete

; 4240 : 	}
; 4241 : 	if( pUser )
; 4242 : 	{
; 4243 : 		if( g_eLocal.GetState( EVE_GUILDCOMBAT ) )

  005f4	6a 0f		 push	 15			; 0000000fH
  005f6	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_eLocal@@3VCFlyffEvent@@A
  005fb	e8 00 00 00 00	 call	 ?GetState@CFlyffEvent@@QAEEH@Z ; CFlyffEvent::GetState
  00600	84 c0		 test	 al, al
  00602	74 1d		 je	 SHORT $L280215

; 4244 : 		{
; 4245 : 			if( g_GuildCombatMng.m_nGCState == CGuildCombat::MAINTENANCE_STATE || g_GuildCombatMng.m_nGCState == CGuildCombat::WAR_WAR_STATE )

  00604	a1 44 11 00 00	 mov	 eax, DWORD PTR ?g_GuildCombatMng@@3VCGuildCombat@@A+4420
  00609	83 f8 67	 cmp	 eax, 103		; 00000067H
  0060c	74 05		 je	 SHORT $L280216
  0060e	83 f8 68	 cmp	 eax, 104		; 00000068H
  00611	75 0e		 jne	 SHORT $L280215
$L280216:

; 4246 : 				g_GuildCombatMng.OutWar( pUser, NULL, TRUE );

  00613	6a 01		 push	 1
  00615	55		 push	 ebp
  00616	56		 push	 esi
  00617	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_GuildCombatMng@@3VCGuildCombat@@A
  0061c	e8 00 00 00 00	 call	 ?OutWar@CGuildCombat@@QAEXPAVCUser@@0H@Z ; CGuildCombat::OutWar
$L280215:

; 4247 : 		}
; 4248 : #if __VER >= 11 // __GUILD_COMBAT_1TO1
; 4249 : 		if( g_eLocal.GetState( EVE_GUILDCOMBAT1TO1 ) )

  00621	6a 16		 push	 22			; 00000016H
  00623	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_eLocal@@3VCFlyffEvent@@A
  00628	e8 00 00 00 00	 call	 ?GetState@CFlyffEvent@@QAEEH@Z ; CFlyffEvent::GetState
  0062d	84 c0		 test	 al, al
  0062f	74 54		 je	 SHORT $L345462

; 4250 : 		{
; 4251 : 			if( g_GuildCombat1to1Mng.IsPossibleUser( pUser ) && pUser->m_nGuildCombatState == 1 )

  00631	56		 push	 esi
  00632	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_GuildCombat1to1Mng@@3VCGuildCombat1to1Mng@@A
  00637	e8 00 00 00 00	 call	 ?IsPossibleUser@CGuildCombat1to1Mng@@QAEHPAVCUser@@@Z ; CGuildCombat1to1Mng::IsPossibleUser
  0063c	85 c0		 test	 eax, eax
  0063e	74 45		 je	 SHORT $L345462
  00640	83 be 98 0e 00
	00 01		 cmp	 DWORD PTR [esi+3736], 1
  00647	75 3c		 jne	 SHORT $L345462

; 4252 : 			{
; 4253 : 				int nIndex = g_GuildCombat1to1Mng.GetTenderGuildIndexByUser( pUser );

  00649	56		 push	 esi
  0064a	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_GuildCombat1to1Mng@@3VCGuildCombat1to1Mng@@A
  0064f	e8 00 00 00 00	 call	 ?GetTenderGuildIndexByUser@CGuildCombat1to1Mng@@QAEHPAVCUser@@@Z ; CGuildCombat1to1Mng::GetTenderGuildIndexByUser

; 4254 : 				if( nIndex != NULL_ID )

  00654	83 f8 ff	 cmp	 eax, -1
  00657	74 2c		 je	 SHORT $L345462

; 4255 : 				{
; 4256 : 					int nStageId = g_GuildCombat1to1Mng.m_vecTenderGuild[nIndex].nStageId;

  00659	8b 15 54 00 00
	00		 mov	 edx, DWORD PTR ?g_GuildCombat1to1Mng@@3VCGuildCombat1to1Mng@@A+84
  0065f	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00662	c1 e0 04	 shl	 eax, 4
  00665	03 c2		 add	 eax, edx
  00667	8b 40 08	 mov	 eax, DWORD PTR [eax+8]

; 4257 : 					if( nStageId != NULL_ID )

  0066a	83 f8 ff	 cmp	 eax, -1
  0066d	74 16		 je	 SHORT $L345462

; 4258 : 						g_GuildCombat1to1Mng.m_vecGuilCombat1to1[nStageId].GuildCombat1to1WarResultCheck( TRUE, pUser );

  0066f	8b 3d 44 00 00
	00		 mov	 edi, DWORD PTR ?g_GuildCombat1to1Mng@@3VCGuildCombat1to1Mng@@A+68
  00675	8d 0c 40	 lea	 ecx, DWORD PTR [eax+eax*2]
  00678	c1 e1 04	 shl	 ecx, 4
  0067b	56		 push	 esi
  0067c	03 cf		 add	 ecx, edi
  0067e	6a 01		 push	 1
  00680	e8 00 00 00 00	 call	 ?GuildCombat1to1WarResultCheck@CGuildCombat1to1@@QAEXHPAVCUser@@@Z ; CGuildCombat1to1::GuildCombat1to1WarResultCheck
$L345462:
  00685	5f		 pop	 edi
  00686	5d		 pop	 ebp
  00687	5e		 pop	 esi
  00688	5b		 pop	 ebx

; 4259 : 				}
; 4260 : 			}
; 4261 : 		}
; 4262 : #endif // __GUILD_COMBAT_1TO1
; 4263 : 	}
; 4264 : }

  00689	83 c4 28	 add	 esp, 40			; 00000028H
  0068c	c2 04 00	 ret	 4
?DestroyPlayer@CUserMng@@QAEXPAVCUser@@@Z ENDP		; CUserMng::DestroyPlayer
_TEXT	ENDS
PUBLIC	?AddGuildMsg@CUserMng@@QAEXPAVCGuild@@PBD@Z	; CUserMng::AddGuildMsg
; Function compile flags: /Ogty
;	COMDAT ?AddGuildMsg@CUserMng@@QAEXPAVCGuild@@PBD@Z
_TEXT	SEGMENT
_i$345606 = -4						; size = 4
_i$282739 = 8						; size = 4
_pGuild$ = 8						; size = 4
$T345628 = 12						; size = 4
_lpsz$ = 12						; size = 4
?AddGuildMsg@CUserMng@@QAEXPAVCGuild@@PBD@Z PROC NEAR	; CUserMng::AddGuildMsg, COMDAT
; _this$ = ecx

; 5985 : {

  00000	51		 push	 ecx
  00001	57		 push	 edi

; 5986 : 	CGuildMember*	pMember;
; 5987 : 	CUser*			pUsertmp;
; 5988 : 	
; 5989 : 	for( map<u_long, CGuildMember*>::iterator i = pGuild->m_mapPMember.begin();

  00002	8b 7c 24 0c	 mov	 edi, DWORD PTR _pGuild$[esp+4]
  00006	8b 4f 3c	 mov	 ecx, DWORD PTR [edi+60]
  00009	8b 01		 mov	 eax, DWORD PTR [ecx]

; 5990 : 	i != pGuild->m_mapPMember.end(); ++i )

  0000b	3b c1		 cmp	 eax, ecx
  0000d	89 44 24 0c	 mov	 DWORD PTR _i$282739[esp+4], eax
  00011	74 5d		 je	 SHORT $L282744
  00013	56		 push	 esi
  00014	8b 74 24 14	 mov	 esi, DWORD PTR _lpsz$[esp+8]
  00018	eb 06 8d 9b 00
	00 00 00	 npad	 8
$L345506:

; 5991 : 	{
; 5992 : 		pMember		= i->second;
; 5993 : 		pUsertmp	= (CUser*)prj.GetUserByID( pMember->m_idPlayer );

  00020	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00023	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00026	8d 54 24 14	 lea	 edx, DWORD PTR $T345628[esp+8]
  0002a	52		 push	 edx
  0002b	8d 44 24 0c	 lea	 eax, DWORD PTR _i$345606[esp+16]
  0002f	89 4c 24 18	 mov	 DWORD PTR $T345628[esp+12], ecx
  00033	50		 push	 eax
  00034	b9 38 00 00 00	 mov	 ecx, OFFSET FLAT:?prj@@3VCProject@@A+56
  00039	e8 00 00 00 00	 call	 ?find@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::find
  0003e	8b 44 24 08	 mov	 eax, DWORD PTR _i$345606[esp+12]
  00042	3b 05 3c 00 00
	00		 cmp	 eax, DWORD PTR ?prj@@3VCProject@@A+60
  00048	74 13		 je	 SHORT $L282743
  0004a	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]

; 5994 : 		if( IsValidObj( pUsertmp ) )

  0004d	85 c9		 test	 ecx, ecx
  0004f	74 0c		 je	 SHORT $L282743
  00051	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00055	75 06		 jne	 SHORT $L282743

; 5995 : 			pUsertmp->AddText( lpsz );

  00057	56		 push	 esi
  00058	e8 00 00 00 00	 call	 ?AddText@CUser@@QAEXPBD@Z ; CUser::AddText
$L282743:
  0005d	8d 4c 24 10	 lea	 ecx, DWORD PTR _i$282739[esp+8]
  00061	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned long,CGuildMember *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuildMember *> >,0> >::const_iterator::_Inc
  00066	8b 44 24 10	 mov	 eax, DWORD PTR _i$282739[esp+8]
  0006a	3b 47 3c	 cmp	 eax, DWORD PTR [edi+60]
  0006d	75 b1		 jne	 SHORT $L345506
  0006f	5e		 pop	 esi
$L282744:
  00070	5f		 pop	 edi

; 5996 : 	}
; 5997 : }

  00071	59		 pop	 ecx
  00072	c2 08 00	 ret	 8
?AddGuildMsg@CUserMng@@QAEXPAVCGuild@@PBD@Z ENDP	; CUserMng::AddGuildMsg
_TEXT	ENDS
PUBLIC	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
EXTRN	??0exception@@QAE@XZ:NEAR			; exception::exception
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\iosfwd
xdata$x	SEGMENT
$T345746 DD	0ffffffffH
	DD	FLAT:$L345646
$T345744 DD	019930520H
	DD	01H
	DD	FLAT:$T345746
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\stdexcept
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Message$ = 8						; size = 4
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC NEAR ; std::logic_error::logic_error, COMDAT
; _this$ = ecx

; 19   : 		{	// construct from message string

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	51		 push	 ecx
  00016	56		 push	 esi
  00017	8b f1		 mov	 esi, ecx
  00019	89 74 24 04	 mov	 DWORD PTR _this$[esp+20], esi
  0001d	e8 00 00 00 00	 call	 ??0exception@@QAE@XZ	; exception::exception
  00022	33 c0		 xor	 eax, eax
  00024	8d 4e 0c	 lea	 ecx, DWORD PTR [esi+12]
  00027	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7logic_error@std@@6B@
  0002d	6a ff		 push	 -1
  0002f	89 41 14	 mov	 DWORD PTR [ecx+20], eax
  00032	c7 41 18 0f 00
	00 00		 mov	 DWORD PTR [ecx+24], 15	; 0000000fH
  00039	50		 push	 eax
  0003a	89 44 24 18	 mov	 DWORD PTR __$EHRec$[esp+36], eax
  0003e	88 41 04	 mov	 BYTE PTR [ecx+4], al
  00041	8b 44 24 20	 mov	 eax, DWORD PTR __Message$[esp+24]
  00045	50		 push	 eax
  00046	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 20   : 		}

  0004b	8b 4c 24 08	 mov	 ecx, DWORD PTR __$EHRec$[esp+20]
  0004f	8b c6		 mov	 eax, esi
  00051	5e		 pop	 esi
  00052	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00059	83 c4 10	 add	 esp, 16			; 00000010H
  0005c	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L345646:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1exception@@UAE@XZ	; exception::~exception
__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T345744
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::logic_error::logic_error
PUBLIC	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
PUBLIC	??_7length_error@std@@6B@			; std::length_error::`vftable'
PUBLIC	??_Glength_error@std@@UAEPAXI@Z			; std::length_error::`scalar deleting destructor'
EXTRN	??_Elength_error@std@@UAEPAXI@Z:NEAR		; std::length_error::`vector deleting destructor'
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT
??_7length_error@std@@6B@ DD FLAT:??_Elength_error@std@@UAEPAXI@Z ; std::length_error::`vftable'
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC NEAR ; std::length_error::length_error, COMDAT
; _this$ = ecx

; 95   : 		{	// construct from message string

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Message$[esp-4]
  00004	56		 push	 esi
  00005	50		 push	 eax
  00006	8b f1		 mov	 esi, ecx
  00008	e8 00 00 00 00	 call	 ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7length_error@std@@6B@

; 96   : 		}

  00013	8b c6		 mov	 eax, esi
  00015	5e		 pop	 esi
  00016	c2 04 00	 ret	 4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::length_error::length_error
_TEXT	ENDS
PUBLIC	??1length_error@std@@UAE@XZ			; std::length_error::~length_error
; Function compile flags: /Ogty
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Glength_error@std@@UAEPAXI@Z PROC NEAR		; std::length_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	e8 00 00 00 00	 call	 ??1length_error@std@@UAE@XZ ; std::length_error::~length_error
  00008	f6 44 24 08 01	 test	 BYTE PTR ___flags$[esp], 1
  0000d	74 09		 je	 SHORT $L345756
  0000f	56		 push	 esi
  00010	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00015	83 c4 04	 add	 esp, 4
$L345756:
  00018	8b c6		 mov	 eax, esi
  0001a	5e		 pop	 esi
  0001b	c2 04 00	 ret	 4
??_Glength_error@std@@UAEPAXI@Z ENDP			; std::length_error::`scalar deleting destructor'
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT
??1length_error@std@@UAE@XZ PROC NEAR			; std::length_error::~length_error, COMDAT
; _this$ = ecx

; 99   : 		{}	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7logic_error@std@@6B@
  00009	83 7e 24 10	 cmp	 DWORD PTR [esi+36], 16	; 00000010H
  0000d	72 0c		 jb	 SHORT $L345844
  0000f	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00018	83 c4 04	 add	 esp, 4
$L345844:
  0001b	33 c0		 xor	 eax, eax
  0001d	c7 46 24 0f 00
	00 00		 mov	 DWORD PTR [esi+36], 15	; 0000000fH
  00024	89 46 20	 mov	 DWORD PTR [esi+32], eax
  00027	88 46 10	 mov	 BYTE PTR [esi+16], al
  0002a	8b ce		 mov	 ecx, esi
  0002c	5e		 pop	 esi
  0002d	e9 00 00 00 00	 jmp	 ??1exception@@UAE@XZ	; exception::~exception
??1length_error@std@@UAE@XZ ENDP			; std::length_error::~length_error
_TEXT	ENDS
PUBLIC	??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::out_of_range::out_of_range
PUBLIC	??_7out_of_range@std@@6B@			; std::out_of_range::`vftable'
PUBLIC	??_Gout_of_range@std@@UAEPAXI@Z			; std::out_of_range::`scalar deleting destructor'
EXTRN	??_Eout_of_range@std@@UAEPAXI@Z:NEAR		; std::out_of_range::`vector deleting destructor'
;	COMDAT ??_7out_of_range@std@@6B@
CONST	SEGMENT
??_7out_of_range@std@@6B@ DD FLAT:??_Eout_of_range@std@@UAEPAXI@Z ; std::out_of_range::`vftable'
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC NEAR ; std::out_of_range::out_of_range, COMDAT
; _this$ = ecx

; 118  : 		{	// construct from message string

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Message$[esp-4]
  00004	56		 push	 esi
  00005	50		 push	 eax
  00006	8b f1		 mov	 esi, ecx
  00008	e8 00 00 00 00	 call	 ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7out_of_range@std@@6B@

; 119  : 		}

  00013	8b c6		 mov	 eax, esi
  00015	5e		 pop	 esi
  00016	c2 04 00	 ret	 4
??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::out_of_range::out_of_range
_TEXT	ENDS
PUBLIC	??1out_of_range@std@@UAE@XZ			; std::out_of_range::~out_of_range
; Function compile flags: /Ogty
;	COMDAT ??_Gout_of_range@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gout_of_range@std@@UAEPAXI@Z PROC NEAR		; std::out_of_range::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	e8 00 00 00 00	 call	 ??1out_of_range@std@@UAE@XZ ; std::out_of_range::~out_of_range
  00008	f6 44 24 08 01	 test	 BYTE PTR ___flags$[esp], 1
  0000d	74 09		 je	 SHORT $L345870
  0000f	56		 push	 esi
  00010	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00015	83 c4 04	 add	 esp, 4
$L345870:
  00018	8b c6		 mov	 eax, esi
  0001a	5e		 pop	 esi
  0001b	c2 04 00	 ret	 4
??_Gout_of_range@std@@UAEPAXI@Z ENDP			; std::out_of_range::`scalar deleting destructor'
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ??1out_of_range@std@@UAE@XZ
_TEXT	SEGMENT
??1out_of_range@std@@UAE@XZ PROC NEAR			; std::out_of_range::~out_of_range, COMDAT
; _this$ = ecx

; 122  : 		{}	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7logic_error@std@@6B@
  00009	83 7e 24 10	 cmp	 DWORD PTR [esi+36], 16	; 00000010H
  0000d	72 0c		 jb	 SHORT $L345958
  0000f	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00018	83 c4 04	 add	 esp, 4
$L345958:
  0001b	33 c0		 xor	 eax, eax
  0001d	c7 46 24 0f 00
	00 00		 mov	 DWORD PTR [esi+36], 15	; 0000000fH
  00024	89 46 20	 mov	 DWORD PTR [esi+32], eax
  00027	88 46 10	 mov	 BYTE PTR [esi+16], al
  0002a	8b ce		 mov	 ecx, esi
  0002c	5e		 pop	 esi
  0002d	e9 00 00 00 00	 jmp	 ??1exception@@UAE@XZ	; exception::~exception
??1out_of_range@std@@UAE@XZ ENDP			; std::out_of_range::~out_of_range
_TEXT	ENDS
PUBLIC	?AddEventLua@CUserMng@@QAEXEH@Z			; CUserMng::AddEventLua
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\iosfwd
xdata$x	SEGMENT
$T346264 DD	0ffffffffH
	DD	FLAT:$L345984
$T346260 DD	019930520H
	DD	01H
	DD	FLAT:$T346264
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
xdata$x	ENDS
;	COMDAT ?AddEventLua@CUserMng@@QAEXEH@Z
_TEXT	SEGMENT
_it$ = -52						; size = 4
$T345983 = -48						; size = 4
_strDesc$ = -44						; size = 28
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_nId$ = 8						; size = 1
_bState$ = 12						; size = 4
?AddEventLua@CUserMng@@QAEXEH@Z PROC NEAR		; CUserMng::AddEventLua, COMDAT
; _this$ = ecx

; 7972 : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?AddEventLua@CUserMng@@QAEXEH@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	83 ec 28	 sub	 esp, 40			; 00000028H
  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001d	33 c4		 xor	 eax, esp
  0001f	53		 push	 ebx
  00020	55		 push	 ebp
  00021	56		 push	 esi
  00022	89 44 24 30	 mov	 DWORD PTR __$ArrayPad$[esp+64], eax

; 7973 : 	string strDesc = prj.m_EventLua.GetDesc( nId );

  00026	8b 44 24 44	 mov	 eax, DWORD PTR _nId$[esp+60]
  0002a	57		 push	 edi
  0002b	8b e9		 mov	 ebp, ecx
  0002d	50		 push	 eax
  0002e	8d 4c 24 1c	 lea	 ecx, DWORD PTR _strDesc$[esp+72]
  00032	51		 push	 ecx
  00033	b9 f8 91 11 00	 mov	 ecx, OFFSET FLAT:?prj@@3VCProject@@A+1151480
  00038	e8 00 00 00 00	 call	 ?GetDesc@CEventLua@@QAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@E@Z ; CEventLua::GetDesc

; 7974 : 	
; 7975 : 	map<DWORD, CUser*>::iterator it;
; 7976 : 	for( it = m_users.begin(); it != m_users.end(); ++it )

  0003d	8b 4d 0c	 mov	 ecx, DWORD PTR [ebp+12]
  00040	8b 01		 mov	 eax, DWORD PTR [ecx]
  00042	33 db		 xor	 ebx, ebx
  00044	3b c1		 cmp	 eax, ecx
  00046	89 5c 24 40	 mov	 DWORD PTR __$EHRec$[esp+76], ebx
  0004a	89 44 24 10	 mov	 DWORD PTR _it$[esp+68], eax
  0004e	74 52		 je	 SHORT $L285090
  00050	8b 7c 24 4c	 mov	 edi, DWORD PTR _bState$[esp+64]
$L346027:

; 7977 : 	{
; 7978 : 		CUser* pUser = it->second;

  00054	8b 70 10	 mov	 esi, DWORD PTR [eax+16]

; 7979 : 		if( pUser->IsValid() == FALSE )

  00057	f6 46 04 01	 test	 BYTE PTR [esi+4], 1
  0005b	75 33		 jne	 SHORT $L285089
  0005d	39 9e e8 16 00
	00		 cmp	 DWORD PTR [esi+5864], ebx
  00063	74 2b		 je	 SHORT $L285089

; 7980 : 			continue;
; 7981 : 		pUser->AddEventLuaDesc( (int)bState, strDesc );

  00065	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00068	8b cc		 mov	 ecx, esp
  0006a	89 64 24 30	 mov	 DWORD PTR $T345983[esp+96], esp
  0006e	6a ff		 push	 -1
  00070	53		 push	 ebx
  00071	8d 54 24 3c	 lea	 edx, DWORD PTR _strDesc$[esp+104]
  00075	c7 41 18 0f 00
	00 00		 mov	 DWORD PTR [ecx+24], 15	; 0000000fH
  0007c	89 59 14	 mov	 DWORD PTR [ecx+20], ebx
  0007f	52		 push	 edx
  00080	88 59 04	 mov	 BYTE PTR [ecx+4], bl
  00083	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00088	57		 push	 edi
  00089	8b ce		 mov	 ecx, esi
  0008b	e8 00 00 00 00	 call	 ?AddEventLuaDesc@CUser@@QAEXHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CUser::AddEventLuaDesc
$L285089:
  00090	8d 4c 24 10	 lea	 ecx, DWORD PTR _it$[esp+68]
  00094	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::const_iterator::_Inc
  00099	8b 44 24 10	 mov	 eax, DWORD PTR _it$[esp+68]
  0009d	3b 45 0c	 cmp	 eax, DWORD PTR [ebp+12]
  000a0	75 b2		 jne	 SHORT $L346027
$L285090:

; 7982 : 	}
; 7983 : }

  000a2	83 7c 24 30 10	 cmp	 DWORD PTR _strDesc$[esp+92], 16 ; 00000010H
  000a7	72 0d		 jb	 SHORT $L346241
  000a9	8b 44 24 1c	 mov	 eax, DWORD PTR _strDesc$[esp+72]
  000ad	50		 push	 eax
  000ae	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000b3	83 c4 04	 add	 esp, 4
$L346241:
  000b6	8b 4c 24 38	 mov	 ecx, DWORD PTR __$EHRec$[esp+68]
  000ba	5f		 pop	 edi
  000bb	5e		 pop	 esi
  000bc	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  000c3	8b 4c 24 2c	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+60]
  000c7	5d		 pop	 ebp
  000c8	5b		 pop	 ebx
  000c9	33 cc		 xor	 ecx, esp
  000cb	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000d0	83 c4 34	 add	 esp, 52			; 00000034H
  000d3	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L345984:
  00000	8d 4d d4	 lea	 ecx, DWORD PTR _strDesc$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?AddEventLua@CUserMng@@QAEXEH@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T346260
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?AddEventLua@CUserMng@@QAEXEH@Z ENDP			; CUserMng::AddEventLua
PUBLIC	??1?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QAE@XZ ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::~vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ??1?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QAE@XZ PROC NEAR ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::~vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >, COMDAT
; _this$ = ecx

; 387  : 		{	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 388  : 		_Tidy();

  00003	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00006	85 c0		 test	 eax, eax
  00008	74 09		 je	 SHORT $L346279
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00010	83 c4 04	 add	 esp, 4
$L346279:
  00013	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  0001a	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00021	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
  00028	5e		 pop	 esi

; 389  : 		}

  00029	c3		 ret	 0
??1?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QAE@XZ ENDP ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::~vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >
_TEXT	ENDS
PUBLIC	??1?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@QAE@XZ ; std::vector<__ITEMINFO,std::allocator<__ITEMINFO> >::~vector<__ITEMINFO,std::allocator<__ITEMINFO> >
; Function compile flags: /Ogty
;	COMDAT ??1?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@QAE@XZ PROC NEAR ; std::vector<__ITEMINFO,std::allocator<__ITEMINFO> >::~vector<__ITEMINFO,std::allocator<__ITEMINFO> >, COMDAT
; _this$ = ecx

; 387  : 		{	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 388  : 		_Tidy();

  00003	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00006	85 c0		 test	 eax, eax
  00008	74 09		 je	 SHORT $L346292
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00010	83 c4 04	 add	 esp, 4
$L346292:
  00013	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  0001a	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00021	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
  00028	5e		 pop	 esi

; 389  : 		}

  00029	c3		 ret	 0
??1?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@QAE@XZ ENDP ; std::vector<__ITEMINFO,std::allocator<__ITEMINFO> >::~vector<__ITEMINFO,std::allocator<__ITEMINFO> >
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::destroy
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ?destroy@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z PROC NEAR ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::destroy, COMDAT
; _this$ = ecx

; 151  : 		{	// destroy object at _Ptr

  00000	56		 push	 esi

; 152  : 		_Destroy(_Ptr);

  00001	8b 74 24 08	 mov	 esi, DWORD PTR __Ptr$[esp]
  00005	83 7e 18 10	 cmp	 DWORD PTR [esi+24], 16	; 00000010H
  00009	72 0c		 jb	 SHORT $L346405
  0000b	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0000e	50		 push	 eax
  0000f	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00014	83 c4 04	 add	 esp, 4
$L346405:
  00017	33 c0		 xor	 eax, eax
  00019	c7 46 18 0f 00
	00 00		 mov	 DWORD PTR [esi+24], 15	; 0000000fH
  00020	89 46 14	 mov	 DWORD PTR [esi+20], eax
  00023	88 46 04	 mov	 BYTE PTR [esi+4], al
  00026	5e		 pop	 esi

; 153  : 		}

  00027	c2 04 00	 ret	 4
?destroy@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ENDP ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::destroy
_TEXT	ENDS
PUBLIC	??$_Construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@@Z ; std::_Construct<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\iosfwd
xdata$x	SEGMENT
$T346533 DD	0ffffffffH
	DD	FLAT:$L346432
$T346531 DD	019930520H
	DD	01H
	DD	FLAT:$T346533
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
xdata$x	ENDS
;	COMDAT ??$_Construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@@Z
_TEXT	SEGMENT
$T346429 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@@Z PROC NEAR ; std::_Construct<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 41   : 	{	// construct object at _Ptr with value _Val

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$??$_Construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	51		 push	 ecx

; 42   : 	new ((void _FARQ *)_Ptr) _T1(_Val);

  00016	8b 4c 24 14	 mov	 ecx, DWORD PTR __Ptr$[esp+12]
  0001a	89 0c 24	 mov	 DWORD PTR $T346429[esp+16], ecx
  0001d	33 c0		 xor	 eax, eax
  0001f	3b c8		 cmp	 ecx, eax
  00021	89 44 24 0c	 mov	 DWORD PTR __$EHRec$[esp+24], eax
  00025	74 1a		 je	 SHORT $L346430
  00027	6a ff		 push	 -1
  00029	89 41 14	 mov	 DWORD PTR [ecx+20], eax
  0002c	c7 41 18 0f 00
	00 00		 mov	 DWORD PTR [ecx+24], 15	; 0000000fH
  00033	50		 push	 eax
  00034	88 41 04	 mov	 BYTE PTR [ecx+4], al
  00037	8b 44 24 20	 mov	 eax, DWORD PTR __Val$[esp+20]
  0003b	50		 push	 eax
  0003c	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$L346430:

; 43   : 	}

  00041	8b 4c 24 04	 mov	 ecx, DWORD PTR __$EHRec$[esp+16]
  00045	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0004c	83 c4 10	 add	 esp, 16			; 00000010H
  0004f	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L346432:
  00000	8b 45 04	 mov	 eax, DWORD PTR __Ptr$[ebp-4]
  00003	50		 push	 eax
  00004	8b 4d f0	 mov	 ecx, DWORD PTR $T346429[ebp]
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$_Construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@@Z:
  00011	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T346531
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$_Construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@@Z ENDP ; std::_Construct<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??4?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@PBD@Z ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::operator=
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\cstringt.h
;	COMDAT ??4?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@PBD@Z
_TEXT	SEGMENT
_pszSrc$ = 8						; size = 4
??4?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@PBD@Z PROC NEAR ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::operator=, COMDAT
; _this$ = ecx

; 983  : 		CThisSimpleString::operator=( pszSrc );

  00000	8b 54 24 04	 mov	 edx, DWORD PTR _pszSrc$[esp-4]
  00004	85 d2		 test	 edx, edx
  00006	57		 push	 edi
  00007	8b f9		 mov	 edi, ecx
  00009	75 0f		 jne	 SHORT $L346556
  0000b	33 c0		 xor	 eax, eax
  0000d	50		 push	 eax
  0000e	52		 push	 edx
  0000f	e8 00 00 00 00	 call	 ?SetString@?$CSimpleStringT@D$0A@@ATL@@QAEXPBDH@Z ; ATL::CSimpleStringT<char,0>::SetString

; 984  : 
; 985  : 		return( *this );

  00014	8b c7		 mov	 eax, edi
  00016	5f		 pop	 edi

; 986  : 	}

  00017	c2 04 00	 ret	 4

; 983  : 		CThisSimpleString::operator=( pszSrc );

$L346556:
  0001a	8b c2		 mov	 eax, edx
  0001c	56		 push	 esi
  0001d	8d 70 01	 lea	 esi, DWORD PTR [eax+1]
$L346558:
  00020	8a 08		 mov	 cl, BYTE PTR [eax]
  00022	40		 inc	 eax
  00023	84 c9		 test	 cl, cl
  00025	75 f9		 jne	 SHORT $L346558
  00027	2b c6		 sub	 eax, esi
  00029	5e		 pop	 esi
  0002a	50		 push	 eax
  0002b	52		 push	 edx
  0002c	8b cf		 mov	 ecx, edi
  0002e	e8 00 00 00 00	 call	 ?SetString@?$CSimpleStringT@D$0A@@ATL@@QAEXPBDH@Z ; ATL::CSimpleStringT<char,0>::SetString

; 984  : 
; 985  : 		return( *this );

  00033	8b c7		 mov	 eax, edi
  00035	5f		 pop	 edi

; 986  : 	}

  00036	c2 04 00	 ret	 4
??4?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@PBD@Z ENDP ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::operator=
_TEXT	ENDS
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 361  : 		_Tidy();
; 362  : 		assign(_Ptr);

  00000	8b 54 24 04	 mov	 edx, DWORD PTR __Ptr$[esp-4]
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx
  00007	8b c2		 mov	 eax, edx
  00009	57		 push	 edi
  0000a	c7 46 18 0f 00
	00 00		 mov	 DWORD PTR [esi+24], 15	; 0000000fH
  00011	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0
  00018	c6 46 04 00	 mov	 BYTE PTR [esi+4], 0
  0001c	8d 78 01	 lea	 edi, DWORD PTR [eax+1]
  0001f	90		 npad	 1
$L346634:
  00020	8a 08		 mov	 cl, BYTE PTR [eax]
  00022	40		 inc	 eax
  00023	84 c9		 test	 cl, cl
  00025	75 f9		 jne	 SHORT $L346634
  00027	2b c7		 sub	 eax, edi
  00029	50		 push	 eax
  0002a	52		 push	 edx
  0002b	8b ce		 mov	 ecx, esi
  0002d	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00032	5f		 pop	 edi

; 363  : 		}

  00033	8b c6		 mov	 eax, esi
  00035	5e		 pop	 esi
  00036	c2 04 00	 ret	 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
PUBLIC	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
; Function compile flags: /Ogty
;	COMDAT ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=, COMDAT
; _this$ = ecx

; 467  : 		return (assign(_Right));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Right$[esp-4]
  00004	6a ff		 push	 -1
  00006	6a 00		 push	 0
  00008	50		 push	 eax
  00009	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 468  : 		}

  0000e	c2 04 00	 ret	 4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
_TEXT	ENDS
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::erase
PUBLIC	??_R0?AVlogic_error@std@@@8			; std::logic_error `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
PUBLIC	??_R0?AVexception@@@8				; exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
PUBLIC	__TI3?AVout_of_range@std@@
PUBLIC	__CTA3?AVout_of_range@std@@
PUBLIC	??_R0?AVout_of_range@std@@@8			; std::out_of_range `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z40
PUBLIC	??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@ ; `string'
PUBLIC	??0logic_error@std@@QAE@ABV01@@Z		; std::logic_error::logic_error
PUBLIC	??0out_of_range@std@@QAE@ABV01@@Z		; std::out_of_range::out_of_range
EXTRN	??0exception@@QAE@ABV0@@Z:NEAR			; exception::exception
EXTRN	??_7type_info@@6B@:DWORD			; type_info::`vftable'
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
xdata$x	SEGMENT
$T347136 DD	0ffffffffH
	DD	FLAT:$L346650
$T347128 DD	019930520H
	DD	01H
	DD	FLAT:$T347136
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@
CONST	SEGMENT
??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@ DB 'invalid '
	DB	'map/set<T> iterator', 00H			; `string'
CONST	ENDS
;	COMDAT __TI3?AVout_of_range@std@@
xdata$x	SEGMENT
__TI3?AVout_of_range@std@@ DD 00H
	DD	FLAT:??1out_of_range@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVout_of_range@std@@
xdata$x	ENDS
;	COMDAT __CTA3?AVout_of_range@std@@
xdata$x	SEGMENT
__CTA3?AVout_of_range@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
xdata$x	ENDS
;	COMDAT __CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVout_of_range@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0out_of_range@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVout_of_range@std@@@8
_DATA	SEGMENT
??_R0?AVout_of_range@std@@@8 DD FLAT:??_7type_info@@6B@	; std::out_of_range `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVout_of_range@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0logic_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT
??_R0?AVlogic_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::logic_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlogic_error@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@@QAE@ABV0@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@@@8
_DATA	SEGMENT
??_R0?AVexception@@@8 DD FLAT:??_7type_info@@6B@	; exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@@', 00H
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
_DATA	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z
_TEXT	SEGMENT
__Erasednode$ = -84					; size = 4
$T346645 = -80						; size = 28
$T346644 = -52						; size = 40
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::erase, COMDAT
; _this$ = ecx

; 590  : 		{	// erase element at _Where

  00000	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00006	6a ff		 push	 -1
  00008	68 00 00 00 00	 push	 __ehhandler$?erase@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z
  0000d	50		 push	 eax

; 591  : 		if (_Isnil(_Where._Mynode()))

  0000e	8b 44 24 14	 mov	 eax, DWORD PTR __Where$[esp+8]
  00012	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00019	83 ec 48	 sub	 esp, 72			; 00000048H
  0001c	55		 push	 ebp
  0001d	8b e9		 mov	 ebp, ecx
  0001f	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00022	84 c9		 test	 cl, cl
  00024	56		 push	 esi
  00025	74 4c		 je	 SHORT $L221501

; 592  : 			_THROW(out_of_range, "invalid map/set<T> iterator");

  00027	6a 1b		 push	 27			; 0000001bH
  00029	33 f6		 xor	 esi, esi
  0002b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@
  00030	8d 4c 24 14	 lea	 ecx, DWORD PTR $T346645[esp+100]
  00034	c7 44 24 2c 0f
	00 00 00	 mov	 DWORD PTR $T346645[esp+124], 15 ; 0000000fH
  0003c	89 74 24 28	 mov	 DWORD PTR $T346645[esp+120], esi
  00040	c6 44 24 18 00	 mov	 BYTE PTR $T346645[esp+104], 0
  00045	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  0004a	8d 44 24 0c	 lea	 eax, DWORD PTR $T346645[esp+92]
  0004e	50		 push	 eax
  0004f	8d 4c 24 2c	 lea	 ecx, DWORD PTR $T346644[esp+96]
  00053	89 74 24 5c	 mov	 DWORD PTR __$EHRec$[esp+104], esi
  00057	e8 00 00 00 00	 call	 ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
  0005c	68 00 00 00 00	 push	 OFFSET FLAT:__TI3?AVout_of_range@std@@
  00061	8d 4c 24 2c	 lea	 ecx, DWORD PTR $T346644[esp+96]
  00065	51		 push	 ecx
  00066	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR $T346644[esp+100], OFFSET FLAT:??_7out_of_range@std@@6B@
  0006e	e8 00 00 00 00	 call	 __CxxThrowException@8
$L347137:
$L221501:
  00073	53		 push	 ebx

; 593  : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase

  00074	8b d8		 mov	 ebx, eax
  00076	57		 push	 edi

; 594  : 		++_Where;	// save successor iterator for return

  00077	8d 4c 24 6c	 lea	 ecx, DWORD PTR __Where$[esp+96]
  0007b	89 5c 24 10	 mov	 DWORD PTR __Erasednode$[esp+100], ebx
  0007f	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::const_iterator::_Inc

; 595  : 
; 596  : 		_Nodeptr _Fixnode;	// the node to recolor as needed
; 597  : 		_Nodeptr _Fixnodeparent;	// parent of _Fixnode (which may be nil)
; 598  : 		_Nodeptr _Pnode = _Erasednode;
; 599  : 
; 600  : 		if (_Isnil(_Left(_Pnode)))

  00084	8b 03		 mov	 eax, DWORD PTR [ebx]
  00086	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00089	84 c9		 test	 cl, cl
  0008b	74 05		 je	 SHORT $L221514

; 601  : 			_Fixnode = _Right(_Pnode);	// must stitch up right subtree

  0008d	8b 7b 08	 mov	 edi, DWORD PTR [ebx+8]

; 602  : 		else if (_Isnil(_Right(_Pnode)))

  00090	eb 19		 jmp	 SHORT $L347131
$L221514:
  00092	8b 53 08	 mov	 edx, DWORD PTR [ebx+8]
  00095	8a 4a 15	 mov	 cl, BYTE PTR [edx+21]
  00098	84 c9		 test	 cl, cl
  0009a	74 04		 je	 SHORT $L221516

; 603  : 			_Fixnode = _Left(_Pnode);	// must stitch up left subtree

  0009c	8b f8		 mov	 edi, eax

; 604  : 		else

  0009e	eb 0b		 jmp	 SHORT $L347131
$L221516:

; 605  : 			{	// two subtrees, must lift successor node to replace erased
; 606  : 			_Pnode = _Where._Mynode();	// _Pnode is successor node
; 607  : 			_Fixnode = _Right(_Pnode);	// _Fixnode is its only subtree

  000a0	8b 4c 24 6c	 mov	 ecx, DWORD PTR __Where$[esp+96]

; 608  : 			}
; 609  : 
; 610  : 		if (_Pnode == _Erasednode)

  000a4	3b cb		 cmp	 ecx, ebx
  000a6	8b 79 08	 mov	 edi, DWORD PTR [ecx+8]
  000a9	75 6e		 jne	 SHORT $L221518
$L347131:

; 611  : 			{	// at most one subtree, relink it
; 612  : 			_Fixnodeparent = _Parent(_Erasednode);
; 613  : 			if (!_Isnil(_Fixnode))

  000ab	8a 47 15	 mov	 al, BYTE PTR [edi+21]
  000ae	84 c0		 test	 al, al
  000b0	8b 73 04	 mov	 esi, DWORD PTR [ebx+4]
  000b3	75 03		 jne	 SHORT $L221519

; 614  : 				_Parent(_Fixnode) = _Fixnodeparent;	// link up

  000b5	89 77 04	 mov	 DWORD PTR [edi+4], esi
$L221519:

; 615  : 
; 616  : 			if (_Root() == _Erasednode)

  000b8	8b 45 04	 mov	 eax, DWORD PTR [ebp+4]
  000bb	39 58 04	 cmp	 DWORD PTR [eax+4], ebx
  000be	75 05		 jne	 SHORT $L221520

; 617  : 				_Root() = _Fixnode;	// link down from root

  000c0	89 78 04	 mov	 DWORD PTR [eax+4], edi

; 618  : 			else if (_Left(_Fixnodeparent) == _Erasednode)

  000c3	eb 0b		 jmp	 SHORT $L221523
$L221520:
  000c5	39 1e		 cmp	 DWORD PTR [esi], ebx
  000c7	75 04		 jne	 SHORT $L221522

; 619  : 				_Left(_Fixnodeparent) = _Fixnode;	// link down to left

  000c9	89 3e		 mov	 DWORD PTR [esi], edi

; 620  : 			else

  000cb	eb 03		 jmp	 SHORT $L221523
$L221522:

; 621  : 				_Right(_Fixnodeparent) = _Fixnode;	// link down to right

  000cd	89 7e 08	 mov	 DWORD PTR [esi+8], edi
$L221523:

; 622  : 
; 623  : 			if (_Lmost() == _Erasednode)

  000d0	8b 5d 04	 mov	 ebx, DWORD PTR [ebp+4]
  000d3	8b 03		 mov	 eax, DWORD PTR [ebx]
  000d5	3b 44 24 10	 cmp	 eax, DWORD PTR __Erasednode$[esp+100]
  000d9	75 16		 jne	 SHORT $L221524

; 624  : 				_Lmost() = _Isnil(_Fixnode)
; 625  : 					? _Fixnodeparent	// smallest is parent of erased node
; 626  : 					: _Min(_Fixnode);	// smallest in relinked subtree

  000db	8a 47 15	 mov	 al, BYTE PTR [edi+21]
  000de	84 c0		 test	 al, al
  000e0	74 04		 je	 SHORT $L346646
  000e2	8b c6		 mov	 eax, esi
  000e4	eb 09		 jmp	 SHORT $L346647
$L346646:
  000e6	57		 push	 edi
  000e7	e8 00 00 00 00	 call	 ?_Min@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Min
  000ec	83 c4 04	 add	 esp, 4
$L346647:
  000ef	89 03		 mov	 DWORD PTR [ebx], eax
$L221524:

; 627  : 
; 628  : 			if (_Rmost() == _Erasednode)

  000f1	8b 5d 04	 mov	 ebx, DWORD PTR [ebp+4]
  000f4	8b 4c 24 10	 mov	 ecx, DWORD PTR __Erasednode$[esp+100]
  000f8	39 4b 08	 cmp	 DWORD PTR [ebx+8], ecx
  000fb	75 74		 jne	 SHORT $L346964

; 629  : 				_Rmost() = _Isnil(_Fixnode)
; 630  : 					? _Fixnodeparent	// largest is parent of erased node
; 631  : 					: _Max(_Fixnode);	// largest in relinked subtree

  000fd	8a 47 15	 mov	 al, BYTE PTR [edi+21]
  00100	84 c0		 test	 al, al
  00102	74 07		 je	 SHORT $L346648
  00104	8b c6		 mov	 eax, esi
  00106	89 43 08	 mov	 DWORD PTR [ebx+8], eax

; 632  : 			}
; 633  : 		else

  00109	eb 66		 jmp	 SHORT $L346964
$L346648:

; 629  : 				_Rmost() = _Isnil(_Fixnode)
; 630  : 					? _Fixnodeparent	// largest is parent of erased node
; 631  : 					: _Max(_Fixnode);	// largest in relinked subtree

  0010b	57		 push	 edi
  0010c	e8 00 00 00 00	 call	 ?_Max@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Max
  00111	83 c4 04	 add	 esp, 4
  00114	89 43 08	 mov	 DWORD PTR [ebx+8], eax

; 632  : 			}
; 633  : 		else

  00117	eb 58		 jmp	 SHORT $L346964
$L221518:

; 634  : 			{	// erased has two subtrees, _Pnode is successor to erased
; 635  : 			_Parent(_Left(_Erasednode)) = _Pnode;	// link left up

  00119	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 636  : 			_Left(_Pnode) = _Left(_Erasednode);	// link successor down

  0011c	8b 13		 mov	 edx, DWORD PTR [ebx]
  0011e	89 11		 mov	 DWORD PTR [ecx], edx

; 637  : 
; 638  : 			if (_Pnode == _Right(_Erasednode))

  00120	3b 4b 08	 cmp	 ecx, DWORD PTR [ebx+8]
  00123	75 04		 jne	 SHORT $L221527

; 639  : 				_Fixnodeparent = _Pnode;	// successor is next to erased

  00125	8b f1		 mov	 esi, ecx

; 640  : 			else

  00127	eb 1b		 jmp	 SHORT $L221528
$L221527:

; 641  : 				{	// successor further down, link in place of erased
; 642  : 				_Fixnodeparent = _Parent(_Pnode);	// parent is successor's
; 643  : 				if (!_Isnil(_Fixnode))

  00129	8a 47 15	 mov	 al, BYTE PTR [edi+21]
  0012c	84 c0		 test	 al, al
  0012e	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  00131	75 03		 jne	 SHORT $L221529

; 644  : 					_Parent(_Fixnode) = _Fixnodeparent;	// link fix up

  00133	89 77 04	 mov	 DWORD PTR [edi+4], esi
$L221529:

; 645  : 				_Left(_Fixnodeparent) = _Fixnode;	// link fix down

  00136	89 3e		 mov	 DWORD PTR [esi], edi

; 646  : 				_Right(_Pnode) = _Right(_Erasednode);	// link successor down

  00138	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  0013b	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 647  : 				_Parent(_Right(_Erasednode)) = _Pnode;	// link right up

  0013e	8b 53 08	 mov	 edx, DWORD PTR [ebx+8]
  00141	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
$L221528:

; 648  : 				}
; 649  : 
; 650  : 			if (_Root() == _Erasednode)

  00144	8b 45 04	 mov	 eax, DWORD PTR [ebp+4]
  00147	39 58 04	 cmp	 DWORD PTR [eax+4], ebx
  0014a	75 05		 jne	 SHORT $L221530

; 651  : 				_Root() = _Pnode;	// link down from root

  0014c	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 652  : 			else if (_Left(_Parent(_Erasednode)) == _Erasednode)

  0014f	eb 0e		 jmp	 SHORT $L221533
$L221530:
  00151	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  00154	39 18		 cmp	 DWORD PTR [eax], ebx
  00156	75 04		 jne	 SHORT $L221532

; 653  : 				_Left(_Parent(_Erasednode)) = _Pnode;	// link down to left

  00158	89 08		 mov	 DWORD PTR [eax], ecx

; 654  : 			else

  0015a	eb 03		 jmp	 SHORT $L221533
$L221532:

; 655  : 				_Right(_Parent(_Erasednode)) = _Pnode;	// link down to right

  0015c	89 48 08	 mov	 DWORD PTR [eax+8], ecx
$L221533:

; 656  : 
; 657  : 			_Parent(_Pnode) = _Parent(_Erasednode);	// link successor up

  0015f	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  00162	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 658  : 			std::swap(_Color(_Pnode), _Color(_Erasednode));	// recolor it

  00165	8a 53 14	 mov	 dl, BYTE PTR [ebx+20]
  00168	8a 41 14	 mov	 al, BYTE PTR [ecx+20]
  0016b	88 51 14	 mov	 BYTE PTR [ecx+20], dl
  0016e	88 43 14	 mov	 BYTE PTR [ebx+20], al
$L346964:

; 659  : 			}
; 660  : 
; 661  : 		if (_Color(_Erasednode) == _Black)

  00171	8b 44 24 10	 mov	 eax, DWORD PTR __Erasednode$[esp+100]
  00175	8a 48 14	 mov	 cl, BYTE PTR [eax+20]
  00178	b3 01		 mov	 bl, 1
  0017a	3a cb		 cmp	 cl, bl
  0017c	0f 85 ff 00 00
	00		 jne	 $L221539

; 662  : 			{	// erasing black link, must recolor/rebalance tree
; 663  : 			for (; _Fixnode != _Root() && _Color(_Fixnode) == _Black;
; 664  : 				_Fixnodeparent = _Parent(_Fixnode))

  00182	8b 4d 04	 mov	 ecx, DWORD PTR [ebp+4]
  00185	3b 79 04	 cmp	 edi, DWORD PTR [ecx+4]
  00188	0f 84 f0 00 00
	00		 je	 $L221542
  0018e	8b ff		 npad	 2
$L221540:
  00190	38 5f 14	 cmp	 BYTE PTR [edi+20], bl
  00193	0f 85 e5 00 00
	00		 jne	 $L221542

; 665  : 				if (_Fixnode == _Left(_Fixnodeparent))

  00199	8b 06		 mov	 eax, DWORD PTR [esi]
  0019b	3b f8		 cmp	 edi, eax
  0019d	75 67		 jne	 SHORT $L221543

; 666  : 					{	// fixup left subtree
; 667  : 					_Pnode = _Right(_Fixnodeparent);

  0019f	8b 46 08	 mov	 eax, DWORD PTR [esi+8]

; 668  : 					if (_Color(_Pnode) == _Red)

  001a2	8a 48 14	 mov	 cl, BYTE PTR [eax+20]
  001a5	84 c9		 test	 cl, cl
  001a7	75 12		 jne	 SHORT $L221544

; 669  : 						{	// rotate red up from right subtree
; 670  : 						_Color(_Pnode) = _Black;

  001a9	88 58 14	 mov	 BYTE PTR [eax+20], bl

; 671  : 						_Color(_Fixnodeparent) = _Red;
; 672  : 						_Lrotate(_Fixnodeparent);

  001ac	56		 push	 esi
  001ad	8b cd		 mov	 ecx, ebp
  001af	c6 46 14 00	 mov	 BYTE PTR [esi+20], 0
  001b3	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Lrotate

; 673  : 						_Pnode = _Right(_Fixnodeparent);

  001b8	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
$L221544:

; 674  : 						}
; 675  : 
; 676  : 					if (_Isnil(_Pnode))

  001bb	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  001be	84 c9		 test	 cl, cl

; 677  : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 678  : 					else if (_Color(_Left(_Pnode)) == _Black

  001c0	75 76		 jne	 SHORT $L347134

; 679  : 						&& _Color(_Right(_Pnode)) == _Black)

  001c2	8b 10		 mov	 edx, DWORD PTR [eax]
  001c4	38 5a 14	 cmp	 BYTE PTR [edx+20], bl
  001c7	75 08		 jne	 SHORT $L221547
  001c9	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  001cc	38 59 14	 cmp	 BYTE PTR [ecx+20], bl
  001cf	74 63		 je	 SHORT $L347135
$L221547:

; 680  : 						{	// redden right subtree with black children
; 681  : 						_Color(_Pnode) = _Red;
; 682  : 						_Fixnode = _Fixnodeparent;
; 683  : 						}
; 684  : 					else
; 685  : 						{	// must rearrange right subtree
; 686  : 						if (_Color(_Right(_Pnode)) == _Black)

  001d1	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  001d4	38 59 14	 cmp	 BYTE PTR [ecx+20], bl
  001d7	75 14		 jne	 SHORT $L221549

; 687  : 							{	// rotate red up from left sub-subtree
; 688  : 							_Color(_Left(_Pnode)) = _Black;

  001d9	8b 10		 mov	 edx, DWORD PTR [eax]
  001db	88 5a 14	 mov	 BYTE PTR [edx+20], bl

; 689  : 							_Color(_Pnode) = _Red;
; 690  : 							_Rrotate(_Pnode);

  001de	50		 push	 eax
  001df	8b cd		 mov	 ecx, ebp
  001e1	c6 40 14 00	 mov	 BYTE PTR [eax+20], 0
  001e5	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Rrotate

; 691  : 							_Pnode = _Right(_Fixnodeparent);

  001ea	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
$L221549:

; 692  : 							}
; 693  : 
; 694  : 						_Color(_Pnode) = _Color(_Fixnodeparent);

  001ed	8a 4e 14	 mov	 cl, BYTE PTR [esi+20]
  001f0	88 48 14	 mov	 BYTE PTR [eax+20], cl

; 695  : 						_Color(_Fixnodeparent) = _Black;

  001f3	88 5e 14	 mov	 BYTE PTR [esi+20], bl

; 696  : 						_Color(_Right(_Pnode)) = _Black;

  001f6	8b 50 08	 mov	 edx, DWORD PTR [eax+8]

; 697  : 						_Lrotate(_Fixnodeparent);

  001f9	56		 push	 esi
  001fa	8b cd		 mov	 ecx, ebp
  001fc	88 5a 14	 mov	 BYTE PTR [edx+20], bl
  001ff	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Lrotate

; 698  : 						break;	// tree now recolored/rebalanced

  00204	eb 78		 jmp	 SHORT $L221542
$L221543:

; 699  : 						}
; 700  : 					}
; 701  : 				else
; 702  : 					{	// fixup right subtree
; 703  : 					_Pnode = _Left(_Fixnodeparent);
; 704  : 					if (_Color(_Pnode) == _Red)

  00206	8a 48 14	 mov	 cl, BYTE PTR [eax+20]
  00209	84 c9		 test	 cl, cl
  0020b	75 11		 jne	 SHORT $L221551

; 705  : 						{	// rotate red up from left subtree
; 706  : 						_Color(_Pnode) = _Black;

  0020d	88 58 14	 mov	 BYTE PTR [eax+20], bl

; 707  : 						_Color(_Fixnodeparent) = _Red;
; 708  : 						_Rrotate(_Fixnodeparent);

  00210	56		 push	 esi
  00211	8b cd		 mov	 ecx, ebp
  00213	c6 46 14 00	 mov	 BYTE PTR [esi+20], 0
  00217	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Rrotate

; 709  : 						_Pnode = _Left(_Fixnodeparent);

  0021c	8b 06		 mov	 eax, DWORD PTR [esi]
$L221551:

; 710  : 						}
; 711  : 					if (_Isnil(_Pnode))

  0021e	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00221	84 c9		 test	 cl, cl

; 712  : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 713  : 					else if (_Color(_Right(_Pnode)) == _Black

  00223	75 13		 jne	 SHORT $L347134

; 714  : 						&& _Color(_Left(_Pnode)) == _Black)

  00225	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00228	38 5a 14	 cmp	 BYTE PTR [edx+20], bl
  0022b	75 20		 jne	 SHORT $L221554
  0022d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0022f	38 59 14	 cmp	 BYTE PTR [ecx+20], bl
  00232	75 19		 jne	 SHORT $L221554
$L347135:

; 715  : 						{	// redden left subtree with black children
; 716  : 						_Color(_Pnode) = _Red;

  00234	c6 40 14 00	 mov	 BYTE PTR [eax+20], 0
$L347134:

; 662  : 			{	// erasing black link, must recolor/rebalance tree
; 663  : 			for (; _Fixnode != _Root() && _Color(_Fixnode) == _Black;
; 664  : 				_Fixnodeparent = _Parent(_Fixnode))

  00238	8b 55 04	 mov	 edx, DWORD PTR [ebp+4]
  0023b	8b 42 04	 mov	 eax, DWORD PTR [edx+4]

; 717  : 						_Fixnode = _Fixnodeparent;

  0023e	8b fe		 mov	 edi, esi
  00240	3b f8		 cmp	 edi, eax
  00242	8b 76 04	 mov	 esi, DWORD PTR [esi+4]
  00245	0f 85 45 ff ff
	ff		 jne	 $L221540

; 662  : 			{	// erasing black link, must recolor/rebalance tree
; 663  : 			for (; _Fixnode != _Root() && _Color(_Fixnode) == _Black;
; 664  : 				_Fixnodeparent = _Parent(_Fixnode))

  0024b	eb 31		 jmp	 SHORT $L221542
$L221554:

; 718  : 						}
; 719  : 					else
; 720  : 						{	// must rearrange left subtree
; 721  : 						if (_Color(_Left(_Pnode)) == _Black)

  0024d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0024f	38 59 14	 cmp	 BYTE PTR [ecx+20], bl
  00252	75 14		 jne	 SHORT $L221556

; 722  : 							{	// rotate red up from right sub-subtree
; 723  : 							_Color(_Right(_Pnode)) = _Black;

  00254	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00257	88 5a 14	 mov	 BYTE PTR [edx+20], bl

; 724  : 							_Color(_Pnode) = _Red;
; 725  : 							_Lrotate(_Pnode);

  0025a	50		 push	 eax
  0025b	8b cd		 mov	 ecx, ebp
  0025d	c6 40 14 00	 mov	 BYTE PTR [eax+20], 0
  00261	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Lrotate

; 726  : 							_Pnode = _Left(_Fixnodeparent);

  00266	8b 06		 mov	 eax, DWORD PTR [esi]
$L221556:

; 727  : 							}
; 728  : 
; 729  : 						_Color(_Pnode) = _Color(_Fixnodeparent);

  00268	8a 4e 14	 mov	 cl, BYTE PTR [esi+20]
  0026b	88 48 14	 mov	 BYTE PTR [eax+20], cl

; 730  : 						_Color(_Fixnodeparent) = _Black;

  0026e	88 5e 14	 mov	 BYTE PTR [esi+20], bl

; 731  : 						_Color(_Left(_Pnode)) = _Black;

  00271	8b 10		 mov	 edx, DWORD PTR [eax]

; 732  : 						_Rrotate(_Fixnodeparent);

  00273	56		 push	 esi
  00274	8b cd		 mov	 ecx, ebp
  00276	88 5a 14	 mov	 BYTE PTR [edx+20], bl
  00279	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Rrotate
$L221542:

; 733  : 						break;	// tree now recolored/rebalanced
; 734  : 						}
; 735  : 					}
; 736  : 
; 737  : 			_Color(_Fixnode) = _Black;	// ensure stopping node is black

  0027e	88 5f 14	 mov	 BYTE PTR [edi+20], bl
$L221539:

; 738  : 			}
; 739  : 
; 740  : 		this->_Alnod.destroy(_Erasednode);	// destroy, free erased node
; 741  : 		this->_Alnod.deallocate(_Erasednode, 1);

  00281	8b 44 24 10	 mov	 eax, DWORD PTR __Erasednode$[esp+100]
  00285	50		 push	 eax
  00286	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete

; 742  : 
; 743  : 		if (0 < _Mysize)

  0028b	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  0028e	83 c4 04	 add	 esp, 4
  00291	85 c0		 test	 eax, eax
  00293	5f		 pop	 edi
  00294	5b		 pop	 ebx
  00295	76 04		 jbe	 SHORT $L221557

; 744  : 			--_Mysize;

  00297	48		 dec	 eax
  00298	89 45 08	 mov	 DWORD PTR [ebp+8], eax
$L221557:

; 745  : 
; 746  : 		return (_Where);	// return successor iterator

  0029b	8b 4c 24 64	 mov	 ecx, DWORD PTR __Where$[esp+88]
  0029f	8b 44 24 60	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp+88]
  002a3	89 08		 mov	 DWORD PTR [eax], ecx

; 747  : 		}

  002a5	8b 4c 24 50	 mov	 ecx, DWORD PTR __$EHRec$[esp+92]
  002a9	5e		 pop	 esi
  002aa	5d		 pop	 ebp
  002ab	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  002b2	83 c4 54	 add	 esp, 84			; 00000054H
  002b5	c2 08 00	 ret	 8
$L347133:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L346650:
  00000	8d 4d b0	 lea	 ecx, DWORD PTR $T346645[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?erase@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T347128
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?erase@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::erase
;	COMDAT xdata$x
xdata$x	SEGMENT
$T347243 DD	0ffffffffH
	DD	FLAT:$L347143
$T347241 DD	019930520H
	DD	01H
	DD	FLAT:$T347243
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0logic_error@std@@QAE@ABV01@@Z PROC NEAR		; std::logic_error::logic_error, COMDAT
; _this$ = ecx
  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$??0logic_error@std@@QAE@ABV01@@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	51		 push	 ecx
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	8b 7c 24 1c	 mov	 edi, DWORD PTR ___that$[esp+20]
  0001c	8b f1		 mov	 esi, ecx
  0001e	57		 push	 edi
  0001f	89 74 24 0c	 mov	 DWORD PTR _this$[esp+28], esi
  00023	e8 00 00 00 00	 call	 ??0exception@@QAE@ABV0@@Z ; exception::exception
  00028	33 c0		 xor	 eax, eax
  0002a	6a ff		 push	 -1
  0002c	8d 4e 0c	 lea	 ecx, DWORD PTR [esi+12]
  0002f	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7logic_error@std@@6B@
  00035	50		 push	 eax
  00036	83 c7 0c	 add	 edi, 12			; 0000000cH
  00039	c7 41 18 0f 00
	00 00		 mov	 DWORD PTR [ecx+24], 15	; 0000000fH
  00040	89 41 14	 mov	 DWORD PTR [ecx+20], eax
  00043	57		 push	 edi
  00044	89 44 24 20	 mov	 DWORD PTR __$EHRec$[esp+44], eax
  00048	88 41 04	 mov	 BYTE PTR [ecx+4], al
  0004b	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00050	8b 4c 24 0c	 mov	 ecx, DWORD PTR __$EHRec$[esp+24]
  00054	5f		 pop	 edi
  00055	8b c6		 mov	 eax, esi
  00057	5e		 pop	 esi
  00058	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0005f	83 c4 10	 add	 esp, 16			; 00000010H
  00062	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L347143:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1exception@@UAE@XZ	; exception::~exception
__ehhandler$??0logic_error@std@@QAE@ABV01@@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T347241
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0logic_error@std@@QAE@ABV01@@Z ENDP			; std::logic_error::logic_error
; Function compile flags: /Ogty
;	COMDAT ??0out_of_range@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0out_of_range@std@@QAE@ABV01@@Z PROC NEAR		; std::out_of_range::out_of_range, COMDAT
; _this$ = ecx
  00000	8b 44 24 04	 mov	 eax, DWORD PTR ___that$[esp-4]
  00004	56		 push	 esi
  00005	50		 push	 eax
  00006	8b f1		 mov	 esi, ecx
  00008	e8 00 00 00 00	 call	 ??0logic_error@std@@QAE@ABV01@@Z
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7out_of_range@std@@6B@
  00013	8b c6		 mov	 eax, esi
  00015	5e		 pop	 esi
  00016	c2 04 00	 ret	 4
??0out_of_range@std@@QAE@ABV01@@Z ENDP			; std::out_of_range::out_of_range
_TEXT	ENDS
PUBLIC	?_Insert@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBKPAVCUser@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Insert
PUBLIC	__TI3?AVlength_error@std@@
PUBLIC	__CTA3?AVlength_error@std@@
PUBLIC	??_R0?AVlength_error@std@@@8			; std::length_error `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
PUBLIC	??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	??0length_error@std@@QAE@ABV01@@Z		; std::length_error::length_error
;	COMDAT xdata$x
xdata$x	SEGMENT
$T347625 DD	0ffffffffH
	DD	FLAT:$L347255
$T347620 DD	019930520H
	DD	01H
	DD	FLAT:$T347625
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@ DB 'map/set<T> too l'
	DB	'ong', 00H					; `string'
CONST	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT
__TI3?AVlength_error@std@@ DD 00H
	DD	FLAT:??1length_error@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVlength_error@std@@
xdata$x	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT
__CTA3?AVlength_error@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0length_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT
??_R0?AVlength_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::length_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlength_error@std@@', 00H
; Function compile flags: /Ogty
_DATA	ENDS
;	COMDAT ?_Insert@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBKPAVCUser@@@2@@Z
_TEXT	SEGMENT
$T347254 = -80						; size = 28
$T347253 = -52						; size = 40
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Addleft$ = 12						; size = 1
__Wherenode$ = 16					; size = 4
__Newnode$ = 20						; size = 4
__Val$ = 20						; size = 4
?_Insert@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBKPAVCUser@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Insert, COMDAT
; _this$ = ecx

; 911  : 		{	// add node with value next to _Wherenode, to left if _Addnode

  00000	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00006	6a ff		 push	 -1
  00008	68 00 00 00 00	 push	 __ehhandler$?_Insert@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBKPAVCUser@@@2@@Z
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	83 ec 44	 sub	 esp, 68			; 00000044H
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	8b f9		 mov	 edi, ecx

; 912  : 		if (max_size() - 1 <= _Mysize)

  0001c	81 7f 08 fe ff
	ff 1f		 cmp	 DWORD PTR [edi+8], 536870910 ; 1ffffffeH
  00023	72 4c		 jb	 SHORT $L221567

; 913  : 			_THROW(length_error, "map/set<T> too long");

  00025	6a 13		 push	 19			; 00000013H
  00027	33 f6		 xor	 esi, esi
  00029	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
  0002e	8d 4c 24 10	 lea	 ecx, DWORD PTR $T347254[esp+96]
  00032	c7 44 24 28 0f
	00 00 00	 mov	 DWORD PTR $T347254[esp+120], 15 ; 0000000fH
  0003a	89 74 24 24	 mov	 DWORD PTR $T347254[esp+116], esi
  0003e	c6 44 24 14 00	 mov	 BYTE PTR $T347254[esp+100], 0
  00043	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00048	8d 44 24 08	 lea	 eax, DWORD PTR $T347254[esp+88]
  0004c	50		 push	 eax
  0004d	8d 4c 24 28	 lea	 ecx, DWORD PTR $T347253[esp+92]
  00051	89 74 24 58	 mov	 DWORD PTR __$EHRec$[esp+100], esi
  00055	e8 00 00 00 00	 call	 ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
  0005a	68 00 00 00 00	 push	 OFFSET FLAT:__TI3?AVlength_error@std@@
  0005f	8d 4c 24 28	 lea	 ecx, DWORD PTR $T347253[esp+92]
  00063	51		 push	 ecx
  00064	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR $T347253[esp+96], OFFSET FLAT:??_7length_error@std@@6B@
  0006c	e8 00 00 00 00	 call	 __CxxThrowException@8
$L347626:
$L221567:

; 914  : 		_Nodeptr _Newnode = _Buynode(_Myhead, _Wherenode, _Myhead,
; 915  : 			_Val, _Red);

  00071	8b 54 24 68	 mov	 edx, DWORD PTR __Val$[esp+84]
  00075	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00078	8b 74 24 64	 mov	 esi, DWORD PTR __Wherenode$[esp+84]
  0007c	53		 push	 ebx
  0007d	6a 00		 push	 0
  0007f	52		 push	 edx
  00080	50		 push	 eax
  00081	56		 push	 esi
  00082	50		 push	 eax
  00083	8b cf		 mov	 ecx, edi
  00085	e8 00 00 00 00	 call	 ?_Buynode@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBKPAVCUser@@@2@D@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Buynode

; 916  : 
; 917  : 		++_Mysize;

  0008a	8b 5f 08	 mov	 ebx, DWORD PTR [edi+8]
  0008d	8b c8		 mov	 ecx, eax

; 918  : 		if (_Wherenode == _Myhead)

  0008f	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00092	43		 inc	 ebx
  00093	3b f0		 cmp	 esi, eax
  00095	89 4c 24 6c	 mov	 DWORD PTR __Newnode$[esp+88], ecx
  00099	89 5f 08	 mov	 DWORD PTR [edi+8], ebx
  0009c	75 10		 jne	 SHORT $L221572

; 919  : 			{	// first node in tree, just set head values
; 920  : 			_Root() = _Newnode;

  0009e	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 921  : 			_Lmost() = _Newnode, _Rmost() = _Newnode;

  000a1	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  000a4	89 08		 mov	 DWORD PTR [eax], ecx
  000a6	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  000a9	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 922  : 			}
; 923  : 		else if (_Addleft)

  000ac	eb 23		 jmp	 SHORT $L221577
$L221572:
  000ae	8a 44 24 64	 mov	 al, BYTE PTR __Addleft$[esp+88]
  000b2	84 c0		 test	 al, al
  000b4	74 0d		 je	 SHORT $L221574

; 924  : 			{	// add to left of _Wherenode
; 925  : 			_Left(_Wherenode) = _Newnode;

  000b6	89 0e		 mov	 DWORD PTR [esi], ecx

; 926  : 			if (_Wherenode == _Lmost())

  000b8	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  000bb	3b 30		 cmp	 esi, DWORD PTR [eax]
  000bd	75 12		 jne	 SHORT $L221577

; 927  : 				_Lmost() = _Newnode;

  000bf	89 08		 mov	 DWORD PTR [eax], ecx

; 928  : 			}
; 929  : 		else

  000c1	eb 0e		 jmp	 SHORT $L221577
$L221574:

; 930  : 			{	// add to right of _Wherenode
; 931  : 			_Right(_Wherenode) = _Newnode;

  000c3	89 4e 08	 mov	 DWORD PTR [esi+8], ecx

; 932  : 			if (_Wherenode == _Rmost())

  000c6	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  000c9	3b 70 08	 cmp	 esi, DWORD PTR [eax+8]
  000cc	75 03		 jne	 SHORT $L221577

; 933  : 				_Rmost() = _Newnode;

  000ce	89 48 08	 mov	 DWORD PTR [eax+8], ecx
$L221577:

; 934  : 			}
; 935  : 
; 936  : 		for (_Nodeptr _Pnode = _Newnode; _Color(_Parent(_Pnode)) == _Red; )

  000d1	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000d4	80 7a 14 00	 cmp	 BYTE PTR [edx+20], 0
  000d8	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  000db	8b f1		 mov	 esi, ecx
  000dd	b3 01		 mov	 bl, 1
  000df	0f 85 a5 00 00
	00		 jne	 $L221581
  000e5	55		 push	 ebp
$L221580:

; 937  : 			if (_Parent(_Pnode) == _Left(_Parent(_Parent(_Pnode))))

  000e6	8b 08		 mov	 ecx, DWORD PTR [eax]
  000e8	8b 69 04	 mov	 ebp, DWORD PTR [ecx+4]
  000eb	8b 55 00	 mov	 edx, DWORD PTR [ebp]
  000ee	3b ca		 cmp	 ecx, edx
  000f0	75 50		 jne	 SHORT $L221582

; 938  : 				{	// fixup red-red in left subtree
; 939  : 				_Wherenode = _Right(_Parent(_Parent(_Pnode)));

  000f2	8b 55 08	 mov	 edx, DWORD PTR [ebp+8]

; 940  : 				if (_Color(_Wherenode) == _Red)

  000f5	80 7a 14 00	 cmp	 BYTE PTR [edx+20], 0
  000f9	75 18		 jne	 SHORT $L221583
$L347624:

; 941  : 					{	// parent has two red children, blacken both
; 942  : 					_Color(_Parent(_Pnode)) = _Black;

  000fb	8b 08		 mov	 ecx, DWORD PTR [eax]
  000fd	88 59 14	 mov	 BYTE PTR [ecx+20], bl

; 943  : 					_Color(_Wherenode) = _Black;

  00100	88 5a 14	 mov	 BYTE PTR [edx+20], bl

; 944  : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

  00103	8b 10		 mov	 edx, DWORD PTR [eax]
  00105	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00108	c6 41 14 00	 mov	 BYTE PTR [ecx+20], 0

; 945  : 					_Pnode = _Parent(_Parent(_Pnode));

  0010c	8b 10		 mov	 edx, DWORD PTR [eax]
  0010e	8b 72 04	 mov	 esi, DWORD PTR [edx+4]

; 946  : 					}
; 947  : 				else

  00111	eb 61		 jmp	 SHORT $L221588
$L221583:

; 948  : 					{	// parent has red and black children
; 949  : 					if (_Pnode == _Right(_Parent(_Pnode)))

  00113	3b 71 08	 cmp	 esi, DWORD PTR [ecx+8]
  00116	75 0a		 jne	 SHORT $L221585

; 950  : 						{	// rotate right child to left
; 951  : 						_Pnode = _Parent(_Pnode);

  00118	8b f1		 mov	 esi, ecx

; 952  : 						_Lrotate(_Pnode);

  0011a	56		 push	 esi
  0011b	8b cf		 mov	 ecx, edi
  0011d	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Lrotate
$L221585:

; 953  : 						}
; 954  : 					_Color(_Parent(_Pnode)) = _Black;	// propagate red up

  00122	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00125	88 58 14	 mov	 BYTE PTR [eax+20], bl

; 955  : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

  00128	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0012b	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0012e	c6 42 14 00	 mov	 BYTE PTR [edx+20], 0

; 956  : 					_Rrotate(_Parent(_Parent(_Pnode)));

  00132	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00135	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00138	51		 push	 ecx
  00139	8b cf		 mov	 ecx, edi
  0013b	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Rrotate

; 957  : 					}
; 958  : 				}
; 959  : 			else

  00140	eb 32		 jmp	 SHORT $L221588
$L221582:

; 960  : 				{	// fixup red-red in right subtree
; 961  : 				_Wherenode = _Left(_Parent(_Parent(_Pnode)));
; 962  : 				if (_Color(_Wherenode) == _Red)

  00142	80 7a 14 00	 cmp	 BYTE PTR [edx+20], 0

; 963  : 					{	// parent has two red children, blacken both
; 964  : 					_Color(_Parent(_Pnode)) = _Black;
; 965  : 					_Color(_Wherenode) = _Black;
; 966  : 					_Color(_Parent(_Parent(_Pnode))) = _Red;
; 967  : 					_Pnode = _Parent(_Parent(_Pnode));
; 968  : 					}
; 969  : 				else

  00146	74 b3		 je	 SHORT $L347624

; 970  : 					{	// parent has red and black children
; 971  : 					if (_Pnode == _Left(_Parent(_Pnode)))

  00148	3b 31		 cmp	 esi, DWORD PTR [ecx]
  0014a	75 0a		 jne	 SHORT $L221589

; 972  : 						{	// rotate left child to right
; 973  : 						_Pnode = _Parent(_Pnode);

  0014c	8b f1		 mov	 esi, ecx

; 974  : 						_Rrotate(_Pnode);

  0014e	56		 push	 esi
  0014f	8b cf		 mov	 ecx, edi
  00151	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Rrotate
$L221589:

; 975  : 						}
; 976  : 					_Color(_Parent(_Pnode)) = _Black;	// propagate red up

  00156	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00159	88 58 14	 mov	 BYTE PTR [eax+20], bl

; 977  : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

  0015c	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0015f	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00162	c6 42 14 00	 mov	 BYTE PTR [edx+20], 0

; 978  : 					_Lrotate(_Parent(_Parent(_Pnode)));

  00166	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00169	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0016c	51		 push	 ecx
  0016d	8b cf		 mov	 ecx, edi
  0016f	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Lrotate
$L221588:
  00174	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00177	8a 4a 14	 mov	 cl, BYTE PTR [edx+20]
  0017a	84 c9		 test	 cl, cl
  0017c	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  0017f	0f 84 61 ff ff
	ff		 je	 $L221580
  00185	8b 4c 24 70	 mov	 ecx, DWORD PTR __Newnode$[esp+92]
  00189	5d		 pop	 ebp
$L221581:

; 979  : 					}
; 980  : 				}
; 981  : 
; 982  : 		_Color(_Root()) = _Black;	// root is always black

  0018a	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0018d	8b 50 04	 mov	 edx, DWORD PTR [eax+4]

; 983  : 		return (_TREE_ITERATOR(_Newnode));

  00190	8b 44 24 60	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp+88]
  00194	88 5a 14	 mov	 BYTE PTR [edx+20], bl
  00197	5b		 pop	 ebx
  00198	89 08		 mov	 DWORD PTR [eax], ecx

; 984  : 		}

  0019a	8b 4c 24 4c	 mov	 ecx, DWORD PTR __$EHRec$[esp+88]
  0019e	5f		 pop	 edi
  0019f	5e		 pop	 esi
  001a0	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  001a7	83 c4 50	 add	 esp, 80			; 00000050H
  001aa	c2 10 00	 ret	 16			; 00000010H
$L347623:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L347255:
  00000	8d 4d b0	 lea	 ecx, DWORD PTR $T347254[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?_Insert@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBKPAVCUser@@@2@@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T347620
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?_Insert@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBKPAVCUser@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Insert
; Function compile flags: /Ogty
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0length_error@std@@QAE@ABV01@@Z PROC NEAR		; std::length_error::length_error, COMDAT
; _this$ = ecx
  00000	8b 44 24 04	 mov	 eax, DWORD PTR ___that$[esp-4]
  00004	56		 push	 esi
  00005	50		 push	 eax
  00006	8b f1		 mov	 esi, ecx
  00008	e8 00 00 00 00	 call	 ??0logic_error@std@@QAE@ABV01@@Z
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7length_error@std@@6B@
  00013	8b c6		 mov	 eax, esi
  00015	5e		 pop	 esi
  00016	c2 04 00	 ret	 4
??0length_error@std@@QAE@ABV01@@Z ENDP			; std::length_error::length_error
_TEXT	ENDS
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::erase
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
xdata$x	SEGMENT
$T348128 DD	0ffffffffH
	DD	FLAT:$L347642
$T348120 DD	019930520H
	DD	01H
	DD	FLAT:$T348128
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
xdata$x	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z
_TEXT	SEGMENT
__Erasednode$ = -84					; size = 4
$T347637 = -80						; size = 28
$T347636 = -52						; size = 40
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::erase, COMDAT
; _this$ = ecx

; 590  : 		{	// erase element at _Where

  00000	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00006	6a ff		 push	 -1
  00008	68 00 00 00 00	 push	 __ehhandler$?erase@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z
  0000d	50		 push	 eax

; 591  : 		if (_Isnil(_Where._Mynode()))

  0000e	8b 44 24 14	 mov	 eax, DWORD PTR __Where$[esp+8]
  00012	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00019	83 ec 48	 sub	 esp, 72			; 00000048H
  0001c	55		 push	 ebp
  0001d	8b e9		 mov	 ebp, ecx
  0001f	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00022	84 c9		 test	 cl, cl
  00024	56		 push	 esi
  00025	74 4c		 je	 SHORT $L221644

; 592  : 			_THROW(out_of_range, "invalid map/set<T> iterator");

  00027	6a 1b		 push	 27			; 0000001bH
  00029	33 f6		 xor	 esi, esi
  0002b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@
  00030	8d 4c 24 14	 lea	 ecx, DWORD PTR $T347637[esp+100]
  00034	c7 44 24 2c 0f
	00 00 00	 mov	 DWORD PTR $T347637[esp+124], 15 ; 0000000fH
  0003c	89 74 24 28	 mov	 DWORD PTR $T347637[esp+120], esi
  00040	c6 44 24 18 00	 mov	 BYTE PTR $T347637[esp+104], 0
  00045	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  0004a	8d 44 24 0c	 lea	 eax, DWORD PTR $T347637[esp+92]
  0004e	50		 push	 eax
  0004f	8d 4c 24 2c	 lea	 ecx, DWORD PTR $T347636[esp+96]
  00053	89 74 24 5c	 mov	 DWORD PTR __$EHRec$[esp+104], esi
  00057	e8 00 00 00 00	 call	 ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
  0005c	68 00 00 00 00	 push	 OFFSET FLAT:__TI3?AVout_of_range@std@@
  00061	8d 4c 24 2c	 lea	 ecx, DWORD PTR $T347636[esp+96]
  00065	51		 push	 ecx
  00066	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR $T347636[esp+100], OFFSET FLAT:??_7out_of_range@std@@6B@
  0006e	e8 00 00 00 00	 call	 __CxxThrowException@8
$L348129:
$L221644:
  00073	53		 push	 ebx

; 593  : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase

  00074	8b d8		 mov	 ebx, eax
  00076	57		 push	 edi

; 594  : 		++_Where;	// save successor iterator for return

  00077	8d 4c 24 6c	 lea	 ecx, DWORD PTR __Where$[esp+96]
  0007b	89 5c 24 10	 mov	 DWORD PTR __Erasednode$[esp+100], ebx
  0007f	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::const_iterator::_Inc

; 595  : 
; 596  : 		_Nodeptr _Fixnode;	// the node to recolor as needed
; 597  : 		_Nodeptr _Fixnodeparent;	// parent of _Fixnode (which may be nil)
; 598  : 		_Nodeptr _Pnode = _Erasednode;
; 599  : 
; 600  : 		if (_Isnil(_Left(_Pnode)))

  00084	8b 03		 mov	 eax, DWORD PTR [ebx]
  00086	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00089	84 c9		 test	 cl, cl
  0008b	74 05		 je	 SHORT $L221652

; 601  : 			_Fixnode = _Right(_Pnode);	// must stitch up right subtree

  0008d	8b 7b 08	 mov	 edi, DWORD PTR [ebx+8]

; 602  : 		else if (_Isnil(_Right(_Pnode)))

  00090	eb 19		 jmp	 SHORT $L348123
$L221652:
  00092	8b 53 08	 mov	 edx, DWORD PTR [ebx+8]
  00095	8a 4a 15	 mov	 cl, BYTE PTR [edx+21]
  00098	84 c9		 test	 cl, cl
  0009a	74 04		 je	 SHORT $L221654

; 603  : 			_Fixnode = _Left(_Pnode);	// must stitch up left subtree

  0009c	8b f8		 mov	 edi, eax

; 604  : 		else

  0009e	eb 0b		 jmp	 SHORT $L348123
$L221654:

; 605  : 			{	// two subtrees, must lift successor node to replace erased
; 606  : 			_Pnode = _Where._Mynode();	// _Pnode is successor node
; 607  : 			_Fixnode = _Right(_Pnode);	// _Fixnode is its only subtree

  000a0	8b 4c 24 6c	 mov	 ecx, DWORD PTR __Where$[esp+96]

; 608  : 			}
; 609  : 
; 610  : 		if (_Pnode == _Erasednode)

  000a4	3b cb		 cmp	 ecx, ebx
  000a6	8b 79 08	 mov	 edi, DWORD PTR [ecx+8]
  000a9	75 6e		 jne	 SHORT $L221656
$L348123:

; 611  : 			{	// at most one subtree, relink it
; 612  : 			_Fixnodeparent = _Parent(_Erasednode);
; 613  : 			if (!_Isnil(_Fixnode))

  000ab	8a 47 15	 mov	 al, BYTE PTR [edi+21]
  000ae	84 c0		 test	 al, al
  000b0	8b 73 04	 mov	 esi, DWORD PTR [ebx+4]
  000b3	75 03		 jne	 SHORT $L221657

; 614  : 				_Parent(_Fixnode) = _Fixnodeparent;	// link up

  000b5	89 77 04	 mov	 DWORD PTR [edi+4], esi
$L221657:

; 615  : 
; 616  : 			if (_Root() == _Erasednode)

  000b8	8b 45 04	 mov	 eax, DWORD PTR [ebp+4]
  000bb	39 58 04	 cmp	 DWORD PTR [eax+4], ebx
  000be	75 05		 jne	 SHORT $L221658

; 617  : 				_Root() = _Fixnode;	// link down from root

  000c0	89 78 04	 mov	 DWORD PTR [eax+4], edi

; 618  : 			else if (_Left(_Fixnodeparent) == _Erasednode)

  000c3	eb 0b		 jmp	 SHORT $L221661
$L221658:
  000c5	39 1e		 cmp	 DWORD PTR [esi], ebx
  000c7	75 04		 jne	 SHORT $L221660

; 619  : 				_Left(_Fixnodeparent) = _Fixnode;	// link down to left

  000c9	89 3e		 mov	 DWORD PTR [esi], edi

; 620  : 			else

  000cb	eb 03		 jmp	 SHORT $L221661
$L221660:

; 621  : 				_Right(_Fixnodeparent) = _Fixnode;	// link down to right

  000cd	89 7e 08	 mov	 DWORD PTR [esi+8], edi
$L221661:

; 622  : 
; 623  : 			if (_Lmost() == _Erasednode)

  000d0	8b 5d 04	 mov	 ebx, DWORD PTR [ebp+4]
  000d3	8b 03		 mov	 eax, DWORD PTR [ebx]
  000d5	3b 44 24 10	 cmp	 eax, DWORD PTR __Erasednode$[esp+100]
  000d9	75 16		 jne	 SHORT $L221662

; 624  : 				_Lmost() = _Isnil(_Fixnode)
; 625  : 					? _Fixnodeparent	// smallest is parent of erased node
; 626  : 					: _Min(_Fixnode);	// smallest in relinked subtree

  000db	8a 47 15	 mov	 al, BYTE PTR [edi+21]
  000de	84 c0		 test	 al, al
  000e0	74 04		 je	 SHORT $L347638
  000e2	8b c6		 mov	 eax, esi
  000e4	eb 09		 jmp	 SHORT $L347639
$L347638:
  000e6	57		 push	 edi
  000e7	e8 00 00 00 00	 call	 ?_Min@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::_Min
  000ec	83 c4 04	 add	 esp, 4
$L347639:
  000ef	89 03		 mov	 DWORD PTR [ebx], eax
$L221662:

; 627  : 
; 628  : 			if (_Rmost() == _Erasednode)

  000f1	8b 5d 04	 mov	 ebx, DWORD PTR [ebp+4]
  000f4	8b 4c 24 10	 mov	 ecx, DWORD PTR __Erasednode$[esp+100]
  000f8	39 4b 08	 cmp	 DWORD PTR [ebx+8], ecx
  000fb	75 74		 jne	 SHORT $L347956

; 629  : 				_Rmost() = _Isnil(_Fixnode)
; 630  : 					? _Fixnodeparent	// largest is parent of erased node
; 631  : 					: _Max(_Fixnode);	// largest in relinked subtree

  000fd	8a 47 15	 mov	 al, BYTE PTR [edi+21]
  00100	84 c0		 test	 al, al
  00102	74 07		 je	 SHORT $L347640
  00104	8b c6		 mov	 eax, esi
  00106	89 43 08	 mov	 DWORD PTR [ebx+8], eax

; 632  : 			}
; 633  : 		else

  00109	eb 66		 jmp	 SHORT $L347956
$L347640:

; 629  : 				_Rmost() = _Isnil(_Fixnode)
; 630  : 					? _Fixnodeparent	// largest is parent of erased node
; 631  : 					: _Max(_Fixnode);	// largest in relinked subtree

  0010b	57		 push	 edi
  0010c	e8 00 00 00 00	 call	 ?_Max@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::_Max
  00111	83 c4 04	 add	 esp, 4
  00114	89 43 08	 mov	 DWORD PTR [ebx+8], eax

; 632  : 			}
; 633  : 		else

  00117	eb 58		 jmp	 SHORT $L347956
$L221656:

; 634  : 			{	// erased has two subtrees, _Pnode is successor to erased
; 635  : 			_Parent(_Left(_Erasednode)) = _Pnode;	// link left up

  00119	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 636  : 			_Left(_Pnode) = _Left(_Erasednode);	// link successor down

  0011c	8b 13		 mov	 edx, DWORD PTR [ebx]
  0011e	89 11		 mov	 DWORD PTR [ecx], edx

; 637  : 
; 638  : 			if (_Pnode == _Right(_Erasednode))

  00120	3b 4b 08	 cmp	 ecx, DWORD PTR [ebx+8]
  00123	75 04		 jne	 SHORT $L221665

; 639  : 				_Fixnodeparent = _Pnode;	// successor is next to erased

  00125	8b f1		 mov	 esi, ecx

; 640  : 			else

  00127	eb 1b		 jmp	 SHORT $L221666
$L221665:

; 641  : 				{	// successor further down, link in place of erased
; 642  : 				_Fixnodeparent = _Parent(_Pnode);	// parent is successor's
; 643  : 				if (!_Isnil(_Fixnode))

  00129	8a 47 15	 mov	 al, BYTE PTR [edi+21]
  0012c	84 c0		 test	 al, al
  0012e	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  00131	75 03		 jne	 SHORT $L221667

; 644  : 					_Parent(_Fixnode) = _Fixnodeparent;	// link fix up

  00133	89 77 04	 mov	 DWORD PTR [edi+4], esi
$L221667:

; 645  : 				_Left(_Fixnodeparent) = _Fixnode;	// link fix down

  00136	89 3e		 mov	 DWORD PTR [esi], edi

; 646  : 				_Right(_Pnode) = _Right(_Erasednode);	// link successor down

  00138	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  0013b	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 647  : 				_Parent(_Right(_Erasednode)) = _Pnode;	// link right up

  0013e	8b 53 08	 mov	 edx, DWORD PTR [ebx+8]
  00141	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
$L221666:

; 648  : 				}
; 649  : 
; 650  : 			if (_Root() == _Erasednode)

  00144	8b 45 04	 mov	 eax, DWORD PTR [ebp+4]
  00147	39 58 04	 cmp	 DWORD PTR [eax+4], ebx
  0014a	75 05		 jne	 SHORT $L221668

; 651  : 				_Root() = _Pnode;	// link down from root

  0014c	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 652  : 			else if (_Left(_Parent(_Erasednode)) == _Erasednode)

  0014f	eb 0e		 jmp	 SHORT $L221671
$L221668:
  00151	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  00154	39 18		 cmp	 DWORD PTR [eax], ebx
  00156	75 04		 jne	 SHORT $L221670

; 653  : 				_Left(_Parent(_Erasednode)) = _Pnode;	// link down to left

  00158	89 08		 mov	 DWORD PTR [eax], ecx

; 654  : 			else

  0015a	eb 03		 jmp	 SHORT $L221671
$L221670:

; 655  : 				_Right(_Parent(_Erasednode)) = _Pnode;	// link down to right

  0015c	89 48 08	 mov	 DWORD PTR [eax+8], ecx
$L221671:

; 656  : 
; 657  : 			_Parent(_Pnode) = _Parent(_Erasednode);	// link successor up

  0015f	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  00162	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 658  : 			std::swap(_Color(_Pnode), _Color(_Erasednode));	// recolor it

  00165	8a 53 14	 mov	 dl, BYTE PTR [ebx+20]
  00168	8a 41 14	 mov	 al, BYTE PTR [ecx+20]
  0016b	88 51 14	 mov	 BYTE PTR [ecx+20], dl
  0016e	88 43 14	 mov	 BYTE PTR [ebx+20], al
$L347956:

; 659  : 			}
; 660  : 
; 661  : 		if (_Color(_Erasednode) == _Black)

  00171	8b 44 24 10	 mov	 eax, DWORD PTR __Erasednode$[esp+100]
  00175	8a 48 14	 mov	 cl, BYTE PTR [eax+20]
  00178	b3 01		 mov	 bl, 1
  0017a	3a cb		 cmp	 cl, bl
  0017c	0f 85 ff 00 00
	00		 jne	 $L221672

; 662  : 			{	// erasing black link, must recolor/rebalance tree
; 663  : 			for (; _Fixnode != _Root() && _Color(_Fixnode) == _Black;
; 664  : 				_Fixnodeparent = _Parent(_Fixnode))

  00182	8b 4d 04	 mov	 ecx, DWORD PTR [ebp+4]
  00185	3b 79 04	 cmp	 edi, DWORD PTR [ecx+4]
  00188	0f 84 f0 00 00
	00		 je	 $L221675
  0018e	8b ff		 npad	 2
$L221673:
  00190	38 5f 14	 cmp	 BYTE PTR [edi+20], bl
  00193	0f 85 e5 00 00
	00		 jne	 $L221675

; 665  : 				if (_Fixnode == _Left(_Fixnodeparent))

  00199	8b 06		 mov	 eax, DWORD PTR [esi]
  0019b	3b f8		 cmp	 edi, eax
  0019d	75 67		 jne	 SHORT $L221676

; 666  : 					{	// fixup left subtree
; 667  : 					_Pnode = _Right(_Fixnodeparent);

  0019f	8b 46 08	 mov	 eax, DWORD PTR [esi+8]

; 668  : 					if (_Color(_Pnode) == _Red)

  001a2	8a 48 14	 mov	 cl, BYTE PTR [eax+20]
  001a5	84 c9		 test	 cl, cl
  001a7	75 12		 jne	 SHORT $L221677

; 669  : 						{	// rotate red up from right subtree
; 670  : 						_Color(_Pnode) = _Black;

  001a9	88 58 14	 mov	 BYTE PTR [eax+20], bl

; 671  : 						_Color(_Fixnodeparent) = _Red;
; 672  : 						_Lrotate(_Fixnodeparent);

  001ac	56		 push	 esi
  001ad	8b cd		 mov	 ecx, ebp
  001af	c6 46 14 00	 mov	 BYTE PTR [esi+20], 0
  001b3	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::_Lrotate

; 673  : 						_Pnode = _Right(_Fixnodeparent);

  001b8	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
$L221677:

; 674  : 						}
; 675  : 
; 676  : 					if (_Isnil(_Pnode))

  001bb	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  001be	84 c9		 test	 cl, cl

; 677  : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 678  : 					else if (_Color(_Left(_Pnode)) == _Black

  001c0	75 76		 jne	 SHORT $L348126

; 679  : 						&& _Color(_Right(_Pnode)) == _Black)

  001c2	8b 10		 mov	 edx, DWORD PTR [eax]
  001c4	38 5a 14	 cmp	 BYTE PTR [edx+20], bl
  001c7	75 08		 jne	 SHORT $L221680
  001c9	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  001cc	38 59 14	 cmp	 BYTE PTR [ecx+20], bl
  001cf	74 63		 je	 SHORT $L348127
$L221680:

; 680  : 						{	// redden right subtree with black children
; 681  : 						_Color(_Pnode) = _Red;
; 682  : 						_Fixnode = _Fixnodeparent;
; 683  : 						}
; 684  : 					else
; 685  : 						{	// must rearrange right subtree
; 686  : 						if (_Color(_Right(_Pnode)) == _Black)

  001d1	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  001d4	38 59 14	 cmp	 BYTE PTR [ecx+20], bl
  001d7	75 14		 jne	 SHORT $L221682

; 687  : 							{	// rotate red up from left sub-subtree
; 688  : 							_Color(_Left(_Pnode)) = _Black;

  001d9	8b 10		 mov	 edx, DWORD PTR [eax]
  001db	88 5a 14	 mov	 BYTE PTR [edx+20], bl

; 689  : 							_Color(_Pnode) = _Red;
; 690  : 							_Rrotate(_Pnode);

  001de	50		 push	 eax
  001df	8b cd		 mov	 ecx, ebp
  001e1	c6 40 14 00	 mov	 BYTE PTR [eax+20], 0
  001e5	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::_Rrotate

; 691  : 							_Pnode = _Right(_Fixnodeparent);

  001ea	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
$L221682:

; 692  : 							}
; 693  : 
; 694  : 						_Color(_Pnode) = _Color(_Fixnodeparent);

  001ed	8a 4e 14	 mov	 cl, BYTE PTR [esi+20]
  001f0	88 48 14	 mov	 BYTE PTR [eax+20], cl

; 695  : 						_Color(_Fixnodeparent) = _Black;

  001f3	88 5e 14	 mov	 BYTE PTR [esi+20], bl

; 696  : 						_Color(_Right(_Pnode)) = _Black;

  001f6	8b 50 08	 mov	 edx, DWORD PTR [eax+8]

; 697  : 						_Lrotate(_Fixnodeparent);

  001f9	56		 push	 esi
  001fa	8b cd		 mov	 ecx, ebp
  001fc	88 5a 14	 mov	 BYTE PTR [edx+20], bl
  001ff	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::_Lrotate

; 698  : 						break;	// tree now recolored/rebalanced

  00204	eb 78		 jmp	 SHORT $L221675
$L221676:

; 699  : 						}
; 700  : 					}
; 701  : 				else
; 702  : 					{	// fixup right subtree
; 703  : 					_Pnode = _Left(_Fixnodeparent);
; 704  : 					if (_Color(_Pnode) == _Red)

  00206	8a 48 14	 mov	 cl, BYTE PTR [eax+20]
  00209	84 c9		 test	 cl, cl
  0020b	75 11		 jne	 SHORT $L221684

; 705  : 						{	// rotate red up from left subtree
; 706  : 						_Color(_Pnode) = _Black;

  0020d	88 58 14	 mov	 BYTE PTR [eax+20], bl

; 707  : 						_Color(_Fixnodeparent) = _Red;
; 708  : 						_Rrotate(_Fixnodeparent);

  00210	56		 push	 esi
  00211	8b cd		 mov	 ecx, ebp
  00213	c6 46 14 00	 mov	 BYTE PTR [esi+20], 0
  00217	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::_Rrotate

; 709  : 						_Pnode = _Left(_Fixnodeparent);

  0021c	8b 06		 mov	 eax, DWORD PTR [esi]
$L221684:

; 710  : 						}
; 711  : 					if (_Isnil(_Pnode))

  0021e	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00221	84 c9		 test	 cl, cl

; 712  : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 713  : 					else if (_Color(_Right(_Pnode)) == _Black

  00223	75 13		 jne	 SHORT $L348126

; 714  : 						&& _Color(_Left(_Pnode)) == _Black)

  00225	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00228	38 5a 14	 cmp	 BYTE PTR [edx+20], bl
  0022b	75 20		 jne	 SHORT $L221687
  0022d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0022f	38 59 14	 cmp	 BYTE PTR [ecx+20], bl
  00232	75 19		 jne	 SHORT $L221687
$L348127:

; 715  : 						{	// redden left subtree with black children
; 716  : 						_Color(_Pnode) = _Red;

  00234	c6 40 14 00	 mov	 BYTE PTR [eax+20], 0
$L348126:

; 662  : 			{	// erasing black link, must recolor/rebalance tree
; 663  : 			for (; _Fixnode != _Root() && _Color(_Fixnode) == _Black;
; 664  : 				_Fixnodeparent = _Parent(_Fixnode))

  00238	8b 55 04	 mov	 edx, DWORD PTR [ebp+4]
  0023b	8b 42 04	 mov	 eax, DWORD PTR [edx+4]

; 717  : 						_Fixnode = _Fixnodeparent;

  0023e	8b fe		 mov	 edi, esi
  00240	3b f8		 cmp	 edi, eax
  00242	8b 76 04	 mov	 esi, DWORD PTR [esi+4]
  00245	0f 85 45 ff ff
	ff		 jne	 $L221673

; 662  : 			{	// erasing black link, must recolor/rebalance tree
; 663  : 			for (; _Fixnode != _Root() && _Color(_Fixnode) == _Black;
; 664  : 				_Fixnodeparent = _Parent(_Fixnode))

  0024b	eb 31		 jmp	 SHORT $L221675
$L221687:

; 718  : 						}
; 719  : 					else
; 720  : 						{	// must rearrange left subtree
; 721  : 						if (_Color(_Left(_Pnode)) == _Black)

  0024d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0024f	38 59 14	 cmp	 BYTE PTR [ecx+20], bl
  00252	75 14		 jne	 SHORT $L221689

; 722  : 							{	// rotate red up from right sub-subtree
; 723  : 							_Color(_Right(_Pnode)) = _Black;

  00254	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00257	88 5a 14	 mov	 BYTE PTR [edx+20], bl

; 724  : 							_Color(_Pnode) = _Red;
; 725  : 							_Lrotate(_Pnode);

  0025a	50		 push	 eax
  0025b	8b cd		 mov	 ecx, ebp
  0025d	c6 40 14 00	 mov	 BYTE PTR [eax+20], 0
  00261	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::_Lrotate

; 726  : 							_Pnode = _Left(_Fixnodeparent);

  00266	8b 06		 mov	 eax, DWORD PTR [esi]
$L221689:

; 727  : 							}
; 728  : 
; 729  : 						_Color(_Pnode) = _Color(_Fixnodeparent);

  00268	8a 4e 14	 mov	 cl, BYTE PTR [esi+20]
  0026b	88 48 14	 mov	 BYTE PTR [eax+20], cl

; 730  : 						_Color(_Fixnodeparent) = _Black;

  0026e	88 5e 14	 mov	 BYTE PTR [esi+20], bl

; 731  : 						_Color(_Left(_Pnode)) = _Black;

  00271	8b 10		 mov	 edx, DWORD PTR [eax]

; 732  : 						_Rrotate(_Fixnodeparent);

  00273	56		 push	 esi
  00274	8b cd		 mov	 ecx, ebp
  00276	88 5a 14	 mov	 BYTE PTR [edx+20], bl
  00279	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::_Rrotate
$L221675:

; 733  : 						break;	// tree now recolored/rebalanced
; 734  : 						}
; 735  : 					}
; 736  : 
; 737  : 			_Color(_Fixnode) = _Black;	// ensure stopping node is black

  0027e	88 5f 14	 mov	 BYTE PTR [edi+20], bl
$L221672:

; 738  : 			}
; 739  : 
; 740  : 		this->_Alnod.destroy(_Erasednode);	// destroy, free erased node
; 741  : 		this->_Alnod.deallocate(_Erasednode, 1);

  00281	8b 44 24 10	 mov	 eax, DWORD PTR __Erasednode$[esp+100]
  00285	50		 push	 eax
  00286	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete

; 742  : 
; 743  : 		if (0 < _Mysize)

  0028b	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  0028e	83 c4 04	 add	 esp, 4
  00291	85 c0		 test	 eax, eax
  00293	5f		 pop	 edi
  00294	5b		 pop	 ebx
  00295	76 04		 jbe	 SHORT $L221690

; 744  : 			--_Mysize;

  00297	48		 dec	 eax
  00298	89 45 08	 mov	 DWORD PTR [ebp+8], eax
$L221690:

; 745  : 
; 746  : 		return (_Where);	// return successor iterator

  0029b	8b 4c 24 64	 mov	 ecx, DWORD PTR __Where$[esp+88]
  0029f	8b 44 24 60	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp+88]
  002a3	89 08		 mov	 DWORD PTR [eax], ecx

; 747  : 		}

  002a5	8b 4c 24 50	 mov	 ecx, DWORD PTR __$EHRec$[esp+92]
  002a9	5e		 pop	 esi
  002aa	5d		 pop	 ebp
  002ab	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  002b2	83 c4 54	 add	 esp, 84			; 00000054H
  002b5	c2 08 00	 ret	 8
$L348125:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L347642:
  00000	8d 4d b0	 lea	 ecx, DWORD PTR $T347637[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?erase@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T348120
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?erase@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::erase
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?_Xlen@?$vector@KV?$allocator@K@std@@@std@@IBEXXZ ; std::vector<unsigned long,std::allocator<unsigned long> >::_Xlen
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\stdexcept
xdata$x	SEGMENT
$T348252 DD	0ffffffffH
	DD	FLAT:$L348137
$T348249 DD	019930520H
	DD	01H
	DD	FLAT:$T348252
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
CONST	ENDS
;	COMDAT ?_Xlen@?$vector@KV?$allocator@K@std@@@std@@IBEXXZ
_TEXT	SEGMENT
$T348136 = -80						; size = 28
$T348135 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@KV?$allocator@K@std@@@std@@IBEXXZ PROC NEAR ; std::vector<unsigned long,std::allocator<unsigned long> >::_Xlen, COMDAT
; _this$ = ecx

; 883  : 		{	// report a length_error

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?_Xlen@?$vector@KV?$allocator@K@std@@@std@@IBEXXZ
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	83 ec 44	 sub	 esp, 68			; 00000044H

; 884  : 		_THROW(length_error, "vector<T> too long");

  00018	6a 12		 push	 18			; 00000012H
  0001a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  0001f	8d 4c 24 08	 lea	 ecx, DWORD PTR $T348136[esp+88]
  00023	c7 44 24 20 0f
	00 00 00	 mov	 DWORD PTR $T348136[esp+112], 15 ; 0000000fH
  0002b	c7 44 24 1c 00
	00 00 00	 mov	 DWORD PTR $T348136[esp+108], 0
  00033	c6 44 24 0c 00	 mov	 BYTE PTR $T348136[esp+92], 0
  00038	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  0003d	8d 04 24	 lea	 eax, DWORD PTR $T348136[esp+80]
  00040	50		 push	 eax
  00041	8d 4c 24 20	 lea	 ecx, DWORD PTR $T348135[esp+84]
  00045	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+92], 0
  0004d	e8 00 00 00 00	 call	 ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
  00052	68 00 00 00 00	 push	 OFFSET FLAT:__TI3?AVlength_error@std@@
  00057	8d 4c 24 20	 lea	 ecx, DWORD PTR $T348135[esp+84]
  0005b	51		 push	 ecx
  0005c	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR $T348135[esp+88], OFFSET FLAT:??_7length_error@std@@6B@
  00064	e8 00 00 00 00	 call	 __CxxThrowException@8
$L348253:
$L348251:
  00069	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L348137:
  00000	8d 4d b0	 lea	 ecx, DWORD PTR $T348136[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?_Xlen@?$vector@KV?$allocator@K@std@@@std@@IBEXXZ:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T348249
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?_Xlen@?$vector@KV?$allocator@K@std@@@std@@IBEXXZ ENDP	; std::vector<unsigned long,std::allocator<unsigned long> >::_Xlen
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::erase
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
xdata$x	SEGMENT
$T348751 DD	0ffffffffH
	DD	FLAT:$L348265
$T348743 DD	019930520H
	DD	01H
	DD	FLAT:$T348751
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
xdata$x	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z
_TEXT	SEGMENT
__Erasednode$ = -84					; size = 4
$T348260 = -80						; size = 28
$T348259 = -52						; size = 40
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::erase, COMDAT
; _this$ = ecx

; 590  : 		{	// erase element at _Where

  00000	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00006	6a ff		 push	 -1
  00008	68 00 00 00 00	 push	 __ehhandler$?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z
  0000d	50		 push	 eax

; 591  : 		if (_Isnil(_Where._Mynode()))

  0000e	8b 44 24 14	 mov	 eax, DWORD PTR __Where$[esp+8]
  00012	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00019	83 ec 48	 sub	 esp, 72			; 00000048H
  0001c	55		 push	 ebp
  0001d	8b e9		 mov	 ebp, ecx
  0001f	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00022	84 c9		 test	 cl, cl
  00024	56		 push	 esi
  00025	74 4c		 je	 SHORT $L222956

; 592  : 			_THROW(out_of_range, "invalid map/set<T> iterator");

  00027	6a 1b		 push	 27			; 0000001bH
  00029	33 f6		 xor	 esi, esi
  0002b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@
  00030	8d 4c 24 14	 lea	 ecx, DWORD PTR $T348260[esp+100]
  00034	c7 44 24 2c 0f
	00 00 00	 mov	 DWORD PTR $T348260[esp+124], 15 ; 0000000fH
  0003c	89 74 24 28	 mov	 DWORD PTR $T348260[esp+120], esi
  00040	c6 44 24 18 00	 mov	 BYTE PTR $T348260[esp+104], 0
  00045	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  0004a	8d 44 24 0c	 lea	 eax, DWORD PTR $T348260[esp+92]
  0004e	50		 push	 eax
  0004f	8d 4c 24 2c	 lea	 ecx, DWORD PTR $T348259[esp+96]
  00053	89 74 24 5c	 mov	 DWORD PTR __$EHRec$[esp+104], esi
  00057	e8 00 00 00 00	 call	 ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
  0005c	68 00 00 00 00	 push	 OFFSET FLAT:__TI3?AVout_of_range@std@@
  00061	8d 4c 24 2c	 lea	 ecx, DWORD PTR $T348259[esp+96]
  00065	51		 push	 ecx
  00066	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR $T348259[esp+100], OFFSET FLAT:??_7out_of_range@std@@6B@
  0006e	e8 00 00 00 00	 call	 __CxxThrowException@8
$L348752:
$L222956:
  00073	53		 push	 ebx

; 593  : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase

  00074	8b d8		 mov	 ebx, eax
  00076	57		 push	 edi

; 594  : 		++_Where;	// save successor iterator for return

  00077	8d 4c 24 6c	 lea	 ecx, DWORD PTR __Where$[esp+96]
  0007b	89 5c 24 10	 mov	 DWORD PTR __Erasednode$[esp+100], ebx
  0007f	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::const_iterator::_Inc

; 595  : 
; 596  : 		_Nodeptr _Fixnode;	// the node to recolor as needed
; 597  : 		_Nodeptr _Fixnodeparent;	// parent of _Fixnode (which may be nil)
; 598  : 		_Nodeptr _Pnode = _Erasednode;
; 599  : 
; 600  : 		if (_Isnil(_Left(_Pnode)))

  00084	8b 03		 mov	 eax, DWORD PTR [ebx]
  00086	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00089	84 c9		 test	 cl, cl
  0008b	74 05		 je	 SHORT $L222964

; 601  : 			_Fixnode = _Right(_Pnode);	// must stitch up right subtree

  0008d	8b 7b 08	 mov	 edi, DWORD PTR [ebx+8]

; 602  : 		else if (_Isnil(_Right(_Pnode)))

  00090	eb 19		 jmp	 SHORT $L348746
$L222964:
  00092	8b 53 08	 mov	 edx, DWORD PTR [ebx+8]
  00095	8a 4a 15	 mov	 cl, BYTE PTR [edx+21]
  00098	84 c9		 test	 cl, cl
  0009a	74 04		 je	 SHORT $L222966

; 603  : 			_Fixnode = _Left(_Pnode);	// must stitch up left subtree

  0009c	8b f8		 mov	 edi, eax

; 604  : 		else

  0009e	eb 0b		 jmp	 SHORT $L348746
$L222966:

; 605  : 			{	// two subtrees, must lift successor node to replace erased
; 606  : 			_Pnode = _Where._Mynode();	// _Pnode is successor node
; 607  : 			_Fixnode = _Right(_Pnode);	// _Fixnode is its only subtree

  000a0	8b 4c 24 6c	 mov	 ecx, DWORD PTR __Where$[esp+96]

; 608  : 			}
; 609  : 
; 610  : 		if (_Pnode == _Erasednode)

  000a4	3b cb		 cmp	 ecx, ebx
  000a6	8b 79 08	 mov	 edi, DWORD PTR [ecx+8]
  000a9	75 6e		 jne	 SHORT $L222968
$L348746:

; 611  : 			{	// at most one subtree, relink it
; 612  : 			_Fixnodeparent = _Parent(_Erasednode);
; 613  : 			if (!_Isnil(_Fixnode))

  000ab	8a 47 15	 mov	 al, BYTE PTR [edi+21]
  000ae	84 c0		 test	 al, al
  000b0	8b 73 04	 mov	 esi, DWORD PTR [ebx+4]
  000b3	75 03		 jne	 SHORT $L222969

; 614  : 				_Parent(_Fixnode) = _Fixnodeparent;	// link up

  000b5	89 77 04	 mov	 DWORD PTR [edi+4], esi
$L222969:

; 615  : 
; 616  : 			if (_Root() == _Erasednode)

  000b8	8b 45 04	 mov	 eax, DWORD PTR [ebp+4]
  000bb	39 58 04	 cmp	 DWORD PTR [eax+4], ebx
  000be	75 05		 jne	 SHORT $L222970

; 617  : 				_Root() = _Fixnode;	// link down from root

  000c0	89 78 04	 mov	 DWORD PTR [eax+4], edi

; 618  : 			else if (_Left(_Fixnodeparent) == _Erasednode)

  000c3	eb 0b		 jmp	 SHORT $L222973
$L222970:
  000c5	39 1e		 cmp	 DWORD PTR [esi], ebx
  000c7	75 04		 jne	 SHORT $L222972

; 619  : 				_Left(_Fixnodeparent) = _Fixnode;	// link down to left

  000c9	89 3e		 mov	 DWORD PTR [esi], edi

; 620  : 			else

  000cb	eb 03		 jmp	 SHORT $L222973
$L222972:

; 621  : 				_Right(_Fixnodeparent) = _Fixnode;	// link down to right

  000cd	89 7e 08	 mov	 DWORD PTR [esi+8], edi
$L222973:

; 622  : 
; 623  : 			if (_Lmost() == _Erasednode)

  000d0	8b 5d 04	 mov	 ebx, DWORD PTR [ebp+4]
  000d3	8b 03		 mov	 eax, DWORD PTR [ebx]
  000d5	3b 44 24 10	 cmp	 eax, DWORD PTR __Erasednode$[esp+100]
  000d9	75 16		 jne	 SHORT $L222974

; 624  : 				_Lmost() = _Isnil(_Fixnode)
; 625  : 					? _Fixnodeparent	// smallest is parent of erased node
; 626  : 					: _Min(_Fixnode);	// smallest in relinked subtree

  000db	8a 47 15	 mov	 al, BYTE PTR [edi+21]
  000de	84 c0		 test	 al, al
  000e0	74 04		 je	 SHORT $L348261
  000e2	8b c6		 mov	 eax, esi
  000e4	eb 09		 jmp	 SHORT $L348262
$L348261:
  000e6	57		 push	 edi
  000e7	e8 00 00 00 00	 call	 ?_Min@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Min
  000ec	83 c4 04	 add	 esp, 4
$L348262:
  000ef	89 03		 mov	 DWORD PTR [ebx], eax
$L222974:

; 627  : 
; 628  : 			if (_Rmost() == _Erasednode)

  000f1	8b 5d 04	 mov	 ebx, DWORD PTR [ebp+4]
  000f4	8b 4c 24 10	 mov	 ecx, DWORD PTR __Erasednode$[esp+100]
  000f8	39 4b 08	 cmp	 DWORD PTR [ebx+8], ecx
  000fb	75 74		 jne	 SHORT $L348580

; 629  : 				_Rmost() = _Isnil(_Fixnode)
; 630  : 					? _Fixnodeparent	// largest is parent of erased node
; 631  : 					: _Max(_Fixnode);	// largest in relinked subtree

  000fd	8a 47 15	 mov	 al, BYTE PTR [edi+21]
  00100	84 c0		 test	 al, al
  00102	74 07		 je	 SHORT $L348263
  00104	8b c6		 mov	 eax, esi
  00106	89 43 08	 mov	 DWORD PTR [ebx+8], eax

; 632  : 			}
; 633  : 		else

  00109	eb 66		 jmp	 SHORT $L348580
$L348263:

; 629  : 				_Rmost() = _Isnil(_Fixnode)
; 630  : 					? _Fixnodeparent	// largest is parent of erased node
; 631  : 					: _Max(_Fixnode);	// largest in relinked subtree

  0010b	57		 push	 edi
  0010c	e8 00 00 00 00	 call	 ?_Max@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Max
  00111	83 c4 04	 add	 esp, 4
  00114	89 43 08	 mov	 DWORD PTR [ebx+8], eax

; 632  : 			}
; 633  : 		else

  00117	eb 58		 jmp	 SHORT $L348580
$L222968:

; 634  : 			{	// erased has two subtrees, _Pnode is successor to erased
; 635  : 			_Parent(_Left(_Erasednode)) = _Pnode;	// link left up

  00119	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 636  : 			_Left(_Pnode) = _Left(_Erasednode);	// link successor down

  0011c	8b 13		 mov	 edx, DWORD PTR [ebx]
  0011e	89 11		 mov	 DWORD PTR [ecx], edx

; 637  : 
; 638  : 			if (_Pnode == _Right(_Erasednode))

  00120	3b 4b 08	 cmp	 ecx, DWORD PTR [ebx+8]
  00123	75 04		 jne	 SHORT $L222977

; 639  : 				_Fixnodeparent = _Pnode;	// successor is next to erased

  00125	8b f1		 mov	 esi, ecx

; 640  : 			else

  00127	eb 1b		 jmp	 SHORT $L222978
$L222977:

; 641  : 				{	// successor further down, link in place of erased
; 642  : 				_Fixnodeparent = _Parent(_Pnode);	// parent is successor's
; 643  : 				if (!_Isnil(_Fixnode))

  00129	8a 47 15	 mov	 al, BYTE PTR [edi+21]
  0012c	84 c0		 test	 al, al
  0012e	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  00131	75 03		 jne	 SHORT $L222979

; 644  : 					_Parent(_Fixnode) = _Fixnodeparent;	// link fix up

  00133	89 77 04	 mov	 DWORD PTR [edi+4], esi
$L222979:

; 645  : 				_Left(_Fixnodeparent) = _Fixnode;	// link fix down

  00136	89 3e		 mov	 DWORD PTR [esi], edi

; 646  : 				_Right(_Pnode) = _Right(_Erasednode);	// link successor down

  00138	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  0013b	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 647  : 				_Parent(_Right(_Erasednode)) = _Pnode;	// link right up

  0013e	8b 53 08	 mov	 edx, DWORD PTR [ebx+8]
  00141	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
$L222978:

; 648  : 				}
; 649  : 
; 650  : 			if (_Root() == _Erasednode)

  00144	8b 45 04	 mov	 eax, DWORD PTR [ebp+4]
  00147	39 58 04	 cmp	 DWORD PTR [eax+4], ebx
  0014a	75 05		 jne	 SHORT $L222980

; 651  : 				_Root() = _Pnode;	// link down from root

  0014c	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 652  : 			else if (_Left(_Parent(_Erasednode)) == _Erasednode)

  0014f	eb 0e		 jmp	 SHORT $L222983
$L222980:
  00151	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  00154	39 18		 cmp	 DWORD PTR [eax], ebx
  00156	75 04		 jne	 SHORT $L222982

; 653  : 				_Left(_Parent(_Erasednode)) = _Pnode;	// link down to left

  00158	89 08		 mov	 DWORD PTR [eax], ecx

; 654  : 			else

  0015a	eb 03		 jmp	 SHORT $L222983
$L222982:

; 655  : 				_Right(_Parent(_Erasednode)) = _Pnode;	// link down to right

  0015c	89 48 08	 mov	 DWORD PTR [eax+8], ecx
$L222983:

; 656  : 
; 657  : 			_Parent(_Pnode) = _Parent(_Erasednode);	// link successor up

  0015f	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  00162	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 658  : 			std::swap(_Color(_Pnode), _Color(_Erasednode));	// recolor it

  00165	8a 53 14	 mov	 dl, BYTE PTR [ebx+20]
  00168	8a 41 14	 mov	 al, BYTE PTR [ecx+20]
  0016b	88 51 14	 mov	 BYTE PTR [ecx+20], dl
  0016e	88 43 14	 mov	 BYTE PTR [ebx+20], al
$L348580:

; 659  : 			}
; 660  : 
; 661  : 		if (_Color(_Erasednode) == _Black)

  00171	8b 44 24 10	 mov	 eax, DWORD PTR __Erasednode$[esp+100]
  00175	8a 48 14	 mov	 cl, BYTE PTR [eax+20]
  00178	b3 01		 mov	 bl, 1
  0017a	3a cb		 cmp	 cl, bl
  0017c	0f 85 ff 00 00
	00		 jne	 $L222984

; 662  : 			{	// erasing black link, must recolor/rebalance tree
; 663  : 			for (; _Fixnode != _Root() && _Color(_Fixnode) == _Black;
; 664  : 				_Fixnodeparent = _Parent(_Fixnode))

  00182	8b 4d 04	 mov	 ecx, DWORD PTR [ebp+4]
  00185	3b 79 04	 cmp	 edi, DWORD PTR [ecx+4]
  00188	0f 84 f0 00 00
	00		 je	 $L222987
  0018e	8b ff		 npad	 2
$L222985:
  00190	38 5f 14	 cmp	 BYTE PTR [edi+20], bl
  00193	0f 85 e5 00 00
	00		 jne	 $L222987

; 665  : 				if (_Fixnode == _Left(_Fixnodeparent))

  00199	8b 06		 mov	 eax, DWORD PTR [esi]
  0019b	3b f8		 cmp	 edi, eax
  0019d	75 67		 jne	 SHORT $L222988

; 666  : 					{	// fixup left subtree
; 667  : 					_Pnode = _Right(_Fixnodeparent);

  0019f	8b 46 08	 mov	 eax, DWORD PTR [esi+8]

; 668  : 					if (_Color(_Pnode) == _Red)

  001a2	8a 48 14	 mov	 cl, BYTE PTR [eax+20]
  001a5	84 c9		 test	 cl, cl
  001a7	75 12		 jne	 SHORT $L222989

; 669  : 						{	// rotate red up from right subtree
; 670  : 						_Color(_Pnode) = _Black;

  001a9	88 58 14	 mov	 BYTE PTR [eax+20], bl

; 671  : 						_Color(_Fixnodeparent) = _Red;
; 672  : 						_Lrotate(_Fixnodeparent);

  001ac	56		 push	 esi
  001ad	8b cd		 mov	 ecx, ebp
  001af	c6 46 14 00	 mov	 BYTE PTR [esi+20], 0
  001b3	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Lrotate

; 673  : 						_Pnode = _Right(_Fixnodeparent);

  001b8	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
$L222989:

; 674  : 						}
; 675  : 
; 676  : 					if (_Isnil(_Pnode))

  001bb	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  001be	84 c9		 test	 cl, cl

; 677  : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 678  : 					else if (_Color(_Left(_Pnode)) == _Black

  001c0	75 76		 jne	 SHORT $L348749

; 679  : 						&& _Color(_Right(_Pnode)) == _Black)

  001c2	8b 10		 mov	 edx, DWORD PTR [eax]
  001c4	38 5a 14	 cmp	 BYTE PTR [edx+20], bl
  001c7	75 08		 jne	 SHORT $L222992
  001c9	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  001cc	38 59 14	 cmp	 BYTE PTR [ecx+20], bl
  001cf	74 63		 je	 SHORT $L348750
$L222992:

; 680  : 						{	// redden right subtree with black children
; 681  : 						_Color(_Pnode) = _Red;
; 682  : 						_Fixnode = _Fixnodeparent;
; 683  : 						}
; 684  : 					else
; 685  : 						{	// must rearrange right subtree
; 686  : 						if (_Color(_Right(_Pnode)) == _Black)

  001d1	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  001d4	38 59 14	 cmp	 BYTE PTR [ecx+20], bl
  001d7	75 14		 jne	 SHORT $L222994

; 687  : 							{	// rotate red up from left sub-subtree
; 688  : 							_Color(_Left(_Pnode)) = _Black;

  001d9	8b 10		 mov	 edx, DWORD PTR [eax]
  001db	88 5a 14	 mov	 BYTE PTR [edx+20], bl

; 689  : 							_Color(_Pnode) = _Red;
; 690  : 							_Rrotate(_Pnode);

  001de	50		 push	 eax
  001df	8b cd		 mov	 ecx, ebp
  001e1	c6 40 14 00	 mov	 BYTE PTR [eax+20], 0
  001e5	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Rrotate

; 691  : 							_Pnode = _Right(_Fixnodeparent);

  001ea	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
$L222994:

; 692  : 							}
; 693  : 
; 694  : 						_Color(_Pnode) = _Color(_Fixnodeparent);

  001ed	8a 4e 14	 mov	 cl, BYTE PTR [esi+20]
  001f0	88 48 14	 mov	 BYTE PTR [eax+20], cl

; 695  : 						_Color(_Fixnodeparent) = _Black;

  001f3	88 5e 14	 mov	 BYTE PTR [esi+20], bl

; 696  : 						_Color(_Right(_Pnode)) = _Black;

  001f6	8b 50 08	 mov	 edx, DWORD PTR [eax+8]

; 697  : 						_Lrotate(_Fixnodeparent);

  001f9	56		 push	 esi
  001fa	8b cd		 mov	 ecx, ebp
  001fc	88 5a 14	 mov	 BYTE PTR [edx+20], bl
  001ff	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Lrotate

; 698  : 						break;	// tree now recolored/rebalanced

  00204	eb 78		 jmp	 SHORT $L222987
$L222988:

; 699  : 						}
; 700  : 					}
; 701  : 				else
; 702  : 					{	// fixup right subtree
; 703  : 					_Pnode = _Left(_Fixnodeparent);
; 704  : 					if (_Color(_Pnode) == _Red)

  00206	8a 48 14	 mov	 cl, BYTE PTR [eax+20]
  00209	84 c9		 test	 cl, cl
  0020b	75 11		 jne	 SHORT $L222996

; 705  : 						{	// rotate red up from left subtree
; 706  : 						_Color(_Pnode) = _Black;

  0020d	88 58 14	 mov	 BYTE PTR [eax+20], bl

; 707  : 						_Color(_Fixnodeparent) = _Red;
; 708  : 						_Rrotate(_Fixnodeparent);

  00210	56		 push	 esi
  00211	8b cd		 mov	 ecx, ebp
  00213	c6 46 14 00	 mov	 BYTE PTR [esi+20], 0
  00217	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Rrotate

; 709  : 						_Pnode = _Left(_Fixnodeparent);

  0021c	8b 06		 mov	 eax, DWORD PTR [esi]
$L222996:

; 710  : 						}
; 711  : 					if (_Isnil(_Pnode))

  0021e	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00221	84 c9		 test	 cl, cl

; 712  : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 713  : 					else if (_Color(_Right(_Pnode)) == _Black

  00223	75 13		 jne	 SHORT $L348749

; 714  : 						&& _Color(_Left(_Pnode)) == _Black)

  00225	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00228	38 5a 14	 cmp	 BYTE PTR [edx+20], bl
  0022b	75 20		 jne	 SHORT $L222999
  0022d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0022f	38 59 14	 cmp	 BYTE PTR [ecx+20], bl
  00232	75 19		 jne	 SHORT $L222999
$L348750:

; 715  : 						{	// redden left subtree with black children
; 716  : 						_Color(_Pnode) = _Red;

  00234	c6 40 14 00	 mov	 BYTE PTR [eax+20], 0
$L348749:

; 662  : 			{	// erasing black link, must recolor/rebalance tree
; 663  : 			for (; _Fixnode != _Root() && _Color(_Fixnode) == _Black;
; 664  : 				_Fixnodeparent = _Parent(_Fixnode))

  00238	8b 55 04	 mov	 edx, DWORD PTR [ebp+4]
  0023b	8b 42 04	 mov	 eax, DWORD PTR [edx+4]

; 717  : 						_Fixnode = _Fixnodeparent;

  0023e	8b fe		 mov	 edi, esi
  00240	3b f8		 cmp	 edi, eax
  00242	8b 76 04	 mov	 esi, DWORD PTR [esi+4]
  00245	0f 85 45 ff ff
	ff		 jne	 $L222985

; 662  : 			{	// erasing black link, must recolor/rebalance tree
; 663  : 			for (; _Fixnode != _Root() && _Color(_Fixnode) == _Black;
; 664  : 				_Fixnodeparent = _Parent(_Fixnode))

  0024b	eb 31		 jmp	 SHORT $L222987
$L222999:

; 718  : 						}
; 719  : 					else
; 720  : 						{	// must rearrange left subtree
; 721  : 						if (_Color(_Left(_Pnode)) == _Black)

  0024d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0024f	38 59 14	 cmp	 BYTE PTR [ecx+20], bl
  00252	75 14		 jne	 SHORT $L223001

; 722  : 							{	// rotate red up from right sub-subtree
; 723  : 							_Color(_Right(_Pnode)) = _Black;

  00254	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00257	88 5a 14	 mov	 BYTE PTR [edx+20], bl

; 724  : 							_Color(_Pnode) = _Red;
; 725  : 							_Lrotate(_Pnode);

  0025a	50		 push	 eax
  0025b	8b cd		 mov	 ecx, ebp
  0025d	c6 40 14 00	 mov	 BYTE PTR [eax+20], 0
  00261	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Lrotate

; 726  : 							_Pnode = _Left(_Fixnodeparent);

  00266	8b 06		 mov	 eax, DWORD PTR [esi]
$L223001:

; 727  : 							}
; 728  : 
; 729  : 						_Color(_Pnode) = _Color(_Fixnodeparent);

  00268	8a 4e 14	 mov	 cl, BYTE PTR [esi+20]
  0026b	88 48 14	 mov	 BYTE PTR [eax+20], cl

; 730  : 						_Color(_Fixnodeparent) = _Black;

  0026e	88 5e 14	 mov	 BYTE PTR [esi+20], bl

; 731  : 						_Color(_Left(_Pnode)) = _Black;

  00271	8b 10		 mov	 edx, DWORD PTR [eax]

; 732  : 						_Rrotate(_Fixnodeparent);

  00273	56		 push	 esi
  00274	8b cd		 mov	 ecx, ebp
  00276	88 5a 14	 mov	 BYTE PTR [edx+20], bl
  00279	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Rrotate
$L222987:

; 733  : 						break;	// tree now recolored/rebalanced
; 734  : 						}
; 735  : 					}
; 736  : 
; 737  : 			_Color(_Fixnode) = _Black;	// ensure stopping node is black

  0027e	88 5f 14	 mov	 BYTE PTR [edi+20], bl
$L222984:

; 738  : 			}
; 739  : 
; 740  : 		this->_Alnod.destroy(_Erasednode);	// destroy, free erased node
; 741  : 		this->_Alnod.deallocate(_Erasednode, 1);

  00281	8b 44 24 10	 mov	 eax, DWORD PTR __Erasednode$[esp+100]
  00285	50		 push	 eax
  00286	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete

; 742  : 
; 743  : 		if (0 < _Mysize)

  0028b	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  0028e	83 c4 04	 add	 esp, 4
  00291	85 c0		 test	 eax, eax
  00293	5f		 pop	 edi
  00294	5b		 pop	 ebx
  00295	76 04		 jbe	 SHORT $L223002

; 744  : 			--_Mysize;

  00297	48		 dec	 eax
  00298	89 45 08	 mov	 DWORD PTR [ebp+8], eax
$L223002:

; 745  : 
; 746  : 		return (_Where);	// return successor iterator

  0029b	8b 4c 24 64	 mov	 ecx, DWORD PTR __Where$[esp+88]
  0029f	8b 44 24 60	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp+88]
  002a3	89 08		 mov	 DWORD PTR [eax], ecx

; 747  : 		}

  002a5	8b 4c 24 50	 mov	 ecx, DWORD PTR __$EHRec$[esp+92]
  002a9	5e		 pop	 esi
  002aa	5d		 pop	 ebp
  002ab	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  002b2	83 c4 54	 add	 esp, 84			; 00000054H
  002b5	c2 08 00	 ret	 8
$L348748:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L348265:
  00000	8d 4d b0	 lea	 ecx, DWORD PTR $T348260[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T348743
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::erase
PUBLIC	?Process@CUser@@UAEXXZ				; CUser::Process
EXTRN	?IsGuildHouse@CGuildHouseMng@@QAEHK@Z:NEAR	; CGuildHouseMng::IsGuildHouse
EXTRN	?Process@CMover@@UAEXXZ:NEAR			; CMover::Process
EXTRN	?CheckTickCheer@CMover@@QAEXXZ:NEAR		; CMover::CheckTickCheer
EXTRN	?g_tmCurrent@@3KA:DWORD				; g_tmCurrent
EXTRN	?SetStateNotMode@CMover@@QAEXKE@Z:NEAR		; CMover::SetStateNotMode
EXTRN	?SubSMMode@CMover@@QAEXXZ:NEAR			; CMover::SubSMMode
EXTRN	?CheckHonorTime@CMover@@QAEXXZ:NEAR		; CMover::CheckHonorTime
EXTRN	?GetTicket@CMover@@QAEPAVCItemElem@@XZ:NEAR	; CMover::GetTicket
EXTRN	?GetMover@CProject@@QAEPAVCMover@@K@Z:NEAR	; CProject::GetMover
EXTRN	?SetKeepConnectEvent@CEventLua@@QAEXPAVCUser@@K@Z:NEAR ; CEventLua::SetKeepConnectEvent
EXTRN	?DoUseItemVirtual@CMover@@QAEHKH@Z:NEAR		; CMover::DoUseItemVirtual
EXTRN	?IsTarget@CTicketProperty@@QAEHK@Z:NEAR		; CTicketProperty::IsTarget
EXTRN	?SetCoupon@CEventLua@@QAEXPAVCUser@@K@Z:NEAR	; CEventLua::SetCoupon
EXTRN	?IsValidArea@CMover@@QAEHPAV1@M@Z:NEAR		; CMover::IsValidArea
EXTRN	?RecoveryCampusPoint@CCampusHelper@@QAEXPAVCUser@@K@Z:NEAR ; CCampusHelper::RecoveryCampusPoint
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
;	COMDAT ?Process@CUser@@UAEXXZ
_TEXT	SEGMENT
$T348759 = -12						; size = 12
$T348758 = -12						; size = 12
_vPos$277936 = -12					; size = 12
?Process@CUser@@UAEXXZ PROC NEAR			; CUser::Process, COMDAT
; _this$ = ecx

; 367  : {

  00000	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 368  : 	if( IsValid() == FALSE )

  00006	f6 46 04 01	 test	 BYTE PTR [esi+4], 1
  0000a	0f 85 53 04 00
	00		 jne	 $L278002
  00010	8b 86 e8 16 00
	00		 mov	 eax, DWORD PTR [esi+5864]
  00016	57		 push	 edi
  00017	33 ff		 xor	 edi, edi
  00019	3b c7		 cmp	 eax, edi
  0001b	0f 84 41 04 00
	00		 je	 $L348898

; 369  : 		return;
; 370  : 
; 371  : 	DWORD dwTick	= g_tmCurrent;
; 372  : 
; 373  : 	if( IsMode( MODE_OUTOF_PARTYQUESTRGN ) )

  00021	8b 86 44 02 00
	00		 mov	 eax, DWORD PTR [esi+580]
  00027	8b c8		 mov	 ecx, eax
  00029	81 e1 00 00 00
	80		 and	 ecx, -2147483648	; 80000000H
  0002f	81 f9 00 00 00
	80		 cmp	 ecx, -2147483648	; 80000000H
  00035	55		 push	 ebp
  00036	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR ?g_tmCurrent@@3KA ; g_tmCurrent
  0003c	75 3c		 jne	 SHORT $L277934

; 374  : 	{
; 375  : 		SetNotMode( MODE_OUTOF_PARTYQUESTRGN );
; 376  : 		D3DXVECTOR3 vPos	= D3DXVECTOR3( 6968.0f, 0, 3328.8f );
; 377  : 		REPLACE( g_uIdofMulti, WI_WORLD_MADRIGAL, vPos, REPLACE_NORMAL, nDefaultLayer );

  0003e	57		 push	 edi
  0003f	57		 push	 edi
  00040	25 ff ff ff 7f	 and	 eax, 2147483647		; 7fffffffH
  00045	8d 54 24 14	 lea	 edx, DWORD PTR _vPos$277936[esp+32]
  00049	52		 push	 edx
  0004a	89 86 44 02 00
	00		 mov	 DWORD PTR [esi+580], eax
  00050	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_uIdofMulti@@3KA ; g_uIdofMulti
  00055	6a 01		 push	 1
  00057	50		 push	 eax
  00058	8b ce		 mov	 ecx, esi
  0005a	c7 44 24 20 00
	c0 d9 45	 mov	 DWORD PTR _vPos$277936[esp+44], 1171898368 ; 45d9c000H
  00062	89 7c 24 24	 mov	 DWORD PTR _vPos$277936[esp+48], edi
  00066	c7 44 24 28 cd
	0c 50 45	 mov	 DWORD PTR _vPos$277936[esp+52], 1162874061 ; 45500ccdH
  0006e	e8 00 00 00 00	 call	 ?Replace@CMover@@QAEHKKAAUD3DXVECTOR3@@W4REPLACE_TYPE@@H@Z ; CMover::Replace
  00073	5d		 pop	 ebp
  00074	5f		 pop	 edi
  00075	5e		 pop	 esi

; 576  : 			}
; 577  : 		}
; 578  : 	}
; 579  : #endif // __REACTIVATE_EATPET
; 580  : }

  00076	83 c4 0c	 add	 esp, 12			; 0000000cH
  00079	c3		 ret	 0
$L277934:

; 378  : 		return;
; 379  : 	}
; 380  : 
; 381  : 	if( m_dwDestroyTime && dwTick > m_dwDestroyTime )

  0007a	8b 86 2c 57 00
	00		 mov	 eax, DWORD PTR [esi+22316]
  00080	3b c7		 cmp	 eax, edi
  00082	74 16		 je	 SHORT $L277938
  00084	3b e8		 cmp	 ebp, eax
  00086	76 12		 jbe	 SHORT $L277938

; 382  : 	{
; 383  : 		g_UserMng.DestroyPlayer( this );

  00088	56		 push	 esi
  00089	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_UserMng@@3VCUserMng@@A
  0008e	e8 00 00 00 00	 call	 ?DestroyPlayer@CUserMng@@QAEXPAVCUser@@@Z ; CUserMng::DestroyPlayer
  00093	5d		 pop	 ebp
  00094	5f		 pop	 edi
  00095	5e		 pop	 esi

; 576  : 			}
; 577  : 		}
; 578  : 	}
; 579  : #endif // __REACTIVATE_EATPET
; 580  : }

  00096	83 c4 0c	 add	 esp, 12			; 0000000cH
  00099	c3		 ret	 0
$L277938:

; 384  : 		return;
; 385  : 	}
; 386  : 
; 387  : 	if( IsStateMode( STATE_BASEMOTION_MODE ) )

  0009a	f6 86 4c 02 00
	00 04		 test	 BYTE PTR [esi+588], 4
  000a1	0f 84 85 00 00
	00		 je	 $L348894

; 388  : 	{
; 389  : 		if( (int)( dwTick ) >= m_nReadyTime )

  000a7	3b ae 8c 06 00
	00		 cmp	 ebp, DWORD PTR [esi+1676]
  000ad	7c 7d		 jl	 SHORT $L348894

; 390  : 		{	
; 391  : 			m_nReadyTime	= 0;
; 392  : 			if( m_bItemFind )

  000af	39 be 88 06 00
	00		 cmp	 DWORD PTR [esi+1672], edi

; 393  : 			{
; 394  : 				CItemElem* pItemElem = m_Inventory.GetAtId( m_dwUseItemId );

  000b5	8b 8e 90 06 00
	00		 mov	 ecx, DWORD PTR [esi+1680]
  000bb	89 be 8c 06 00
	00		 mov	 DWORD PTR [esi+1676], edi
  000c1	51		 push	 ecx
  000c2	74 4b		 je	 SHORT $L277943
  000c4	8d 8e 90 0b 00
	00		 lea	 ecx, DWORD PTR [esi+2960]
  000ca	e8 00 00 00 00	 call	 ?GetAtId@?$CItemContainer@VCItemElem@@@@QAEPAVCItemElem@@K@Z ; CItemContainer<CItemElem>::GetAtId

; 395  : 				if( pItemElem )

  000cf	3b c7		 cmp	 eax, edi
  000d1	74 16		 je	 SHORT $L277945

; 396  : 				{
; 397  : 					DoUseItem( MAKELONG( ITYPE_ITEM, pItemElem->m_dwObjId ), pItemElem->m_dwObjId );

  000d3	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000d6	0f b7 c2	 movzx	 eax, dx
  000d9	6a ff		 push	 -1
  000db	52		 push	 edx
  000dc	c1 e0 10	 shl	 eax, 16			; 00000010H
  000df	50		 push	 eax
  000e0	8b ce		 mov	 ecx, esi
  000e2	e8 00 00 00 00	 call	 ?DoUseItem@CMover@@QAEHKKH@Z ; CMover::DoUseItem

; 398  : 				}
; 399  : 				else

  000e7	eb 43		 jmp	 SHORT $L348894
$L277945:

; 400  : 				{
; 401  : 					AddDefinedText(TID_PK_BLINK_LIMIT, "" );	//   

  000e9	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  000ee	68 b4 09 00 00	 push	 2484			; 000009b4H
  000f3	56		 push	 esi
  000f4	e8 00 00 00 00	 call	 ?AddDefinedText@CUser@@QAAXHPBDZZ ; CUser::AddDefinedText
  000f9	83 c4 0c	 add	 esp, 12			; 0000000cH

; 402  : 					SetStateNotMode( STATE_BASEMOTION_MODE, STATEMODE_BASEMOTION_CANCEL );	// V 

  000fc	6a 02		 push	 2
  000fe	6a 04		 push	 4
  00100	8b ce		 mov	 ecx, esi
  00102	e8 00 00 00 00	 call	 ?SetStateNotMode@CMover@@QAEXKE@Z ; CMover::SetStateNotMode

; 403  : 					m_dwUseItemId = 0;

  00107	89 be 90 06 00
	00		 mov	 DWORD PTR [esi+1680], edi

; 404  : 				}
; 405  : 			}
; 406  : 			else

  0010d	eb 1d		 jmp	 SHORT $L348894
$L277943:

; 407  : 			{
; 408  : 				ItemProp* pItemProp = prj.GetItemProp( m_dwUseItemId );

  0010f	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?prj@@3VCProject@@A
  00114	e8 00 00 00 00	 call	 ?GetItemProp@CProject@@QAEPAUItemProp@@H@Z ; CProject::GetItemProp

; 409  : 				if( pItemProp )

  00119	85 c0		 test	 eax, eax
  0011b	74 0f		 je	 SHORT $L348894

; 410  : 				{
; 411  : 					DoUseItemVirtual( m_dwUseItemId, FALSE );

  0011d	8b 96 90 06 00
	00		 mov	 edx, DWORD PTR [esi+1680]
  00123	57		 push	 edi
  00124	52		 push	 edx
  00125	8b ce		 mov	 ecx, esi
  00127	e8 00 00 00 00	 call	 ?DoUseItemVirtual@CMover@@QAEHKH@Z ; CMover::DoUseItemVirtual
$L348894:

; 412  : 				}
; 413  : 			}
; 414  : 		}
; 415  : 	}
; 416  : 
; 417  : #ifdef __SYS_TICKET
; 418  : 	if( ( m_nCount & 15 ) == 0 )

  0012c	f6 86 80 16 00
	00 0f		 test	 BYTE PTR [esi+5760], 15	; 0000000fH
  00133	0f 85 88 00 00
	00		 jne	 $L348897

; 419  : 	{
; 420  : 		if( GetWorld() && CTicketProperty::GetInstance()->IsTarget( GetWorld()->GetID() ) )

  00139	8b 86 6c 01 00
	00		 mov	 eax, DWORD PTR [esi+364]
  0013f	3b c7		 cmp	 eax, edi
  00141	74 59		 je	 SHORT $L277959
  00143	8b 00		 mov	 eax, DWORD PTR [eax]
  00145	50		 push	 eax
  00146	e8 00 00 00 00	 call	 ?GetInstance@CTicketProperty@@SAPAV1@XZ ; CTicketProperty::GetInstance
  0014b	8b c8		 mov	 ecx, eax
  0014d	e8 00 00 00 00	 call	 ?IsTarget@CTicketProperty@@QAEHK@Z ; CTicketProperty::IsTarget
  00152	85 c0		 test	 eax, eax
  00154	74 46		 je	 SHORT $L277959

; 421  : 		{
; 422  : 			CItemElem* pTicket	= GetTicket();

  00156	8b ce		 mov	 ecx, esi
  00158	e8 00 00 00 00	 call	 ?GetTicket@CMover@@QAEPAVCItemElem@@XZ ; CMover::GetTicket

; 423  : 			if( !pTicket )

  0015d	85 c0		 test	 eax, eax
  0015f	75 44		 jne	 SHORT $L348896

; 424  : 			{
; 425  : 				RemoveIk3Buffs( IK3_TICKET );

  00161	6a 7a		 push	 122			; 0000007aH
  00163	8b ce		 mov	 ecx, esi
  00165	e8 00 00 00 00	 call	 ?RemoveIk3Buffs@CMover@@QAEXK@Z ; CMover::RemoveIk3Buffs

; 426  : 				REPLACE( g_uIdofMulti, WI_WORLD_MADRIGAL, D3DXVECTOR3( 6971.984F, 100.0F, 3336.884F ), REPLACE_FORCE, nDefaultLayer );

  0016a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?g_uIdofMulti@@3KA ; g_uIdofMulti
  00170	57		 push	 edi
  00171	6a 01		 push	 1
  00173	8d 44 24 14	 lea	 eax, DWORD PTR $T348758[esp+32]
  00177	50		 push	 eax
  00178	6a 01		 push	 1
  0017a	51		 push	 ecx
  0017b	8b ce		 mov	 ecx, esi
  0017d	c7 44 24 20 df
	df d9 45	 mov	 DWORD PTR $T348758[esp+44], 1171906527 ; 45d9dfdfH
  00185	c7 44 24 24 00
	00 c8 42	 mov	 DWORD PTR $T348758[esp+48], 1120403456 ; 42c80000H
  0018d	c7 44 24 28 25
	8e 50 45	 mov	 DWORD PTR $T348758[esp+52], 1162907173 ; 45508e25H
  00195	e8 00 00 00 00	 call	 ?Replace@CMover@@QAEHKKAAUD3DXVECTOR3@@W4REPLACE_TYPE@@H@Z ; CMover::Replace

; 427  : 			}
; 428  : 		}
; 429  : 		else

  0019a	eb 09		 jmp	 SHORT $L348896
$L277959:

; 430  : 		{
; 431  : 			RemoveIk3Buffs( IK3_TICKET );

  0019c	6a 7a		 push	 122			; 0000007aH
  0019e	8b ce		 mov	 ecx, esi
  001a0	e8 00 00 00 00	 call	 ?RemoveIk3Buffs@CMover@@QAEXK@Z ; CMover::RemoveIk3Buffs
$L348896:

; 432  : 		}
; 433  : #if __VER >= 13 // __COUPLE_1202
; 434  : 		ProcessCouple();

  001a5	8b ce		 mov	 ecx, esi
  001a7	e8 00 00 00 00	 call	 ?ProcessCouple@CUser@@QAEXXZ ; CUser::ProcessCouple

; 435  : #endif // __COUPLE_1202
; 436  : #if __VER >= 15 // __CAMPUS
; 437  : 		ProcessCampus();

  001ac	8b ce		 mov	 ecx, esi
  001ae	e8 00 00 00 00	 call	 ?ProcessCampus@CUser@@QAEXXZ ; CUser::ProcessCampus

; 438  : 		CCampusHelper::GetInstance()->RecoveryCampusPoint( this, dwTick );

  001b3	55		 push	 ebp
  001b4	56		 push	 esi
  001b5	e8 00 00 00 00	 call	 ?GetInstance@CCampusHelper@@SAPAV1@XZ ; CCampusHelper::GetInstance
  001ba	8b c8		 mov	 ecx, eax
  001bc	e8 00 00 00 00	 call	 ?RecoveryCampusPoint@CCampusHelper@@QAEXPAVCUser@@K@Z ; CCampusHelper::RecoveryCampusPoint
$L348897:

; 439  : #endif // __CAMPUS
; 440  : 	}
; 441  : #endif	// __SYS_TICKET
; 442  : 
; 443  : 	CheckTickCheer();

  001c1	8b ce		 mov	 ecx, esi
  001c3	e8 00 00 00 00	 call	 ?CheckTickCheer@CMover@@QAEXXZ ; CMover::CheckTickCheer

; 444  : 
; 445  : 	CMover::Process();

  001c8	8b ce		 mov	 ecx, esi
  001ca	e8 00 00 00 00	 call	 ?Process@CMover@@UAEXXZ	; CMover::Process

; 446  : 
; 447  : 	if( IsLive() )

  001cf	8b 8e 3c 02 00
	00		 mov	 ecx, DWORD PTR [esi+572]
  001d5	f7 41 04 00 00
	00 08		 test	 DWORD PTR [ecx+4], 134217728 ; 08000000H
  001dc	74 0c		 je	 SHORT $L348809
  001de	39 be 00 06 00
	00		 cmp	 DWORD PTR [esi+1536], edi
  001e4	0f 8e c0 00 00
	00		 jle	 $L277975
$L348809:

; 448  : 	{
; 449  : 		if( m_dwFlag & MVRF_MEDITATION_SIT )

  001ea	8b 86 48 02 00
	00		 mov	 eax, DWORD PTR [esi+584]
  001f0	f6 c4 10	 test	 ah, 16			; 00000010H
  001f3	74 56		 je	 SHORT $L277968

; 450  : 		{
; 451  : 			if( m_pActMover->IsStateFlag( OBJSTAF_SIT ) ) 

  001f5	f6 41 08 04	 test	 BYTE PTR [ecx+8], 4

; 452  : 			{
; 453  : 				m_dwFlag &= (~MVRF_MEDITATION_SIT);
; 454  : 			} 
; 455  : 			else

  001f9	75 45		 jne	 SHORT $L348900

; 456  : 			{
; 457  : 				if( SendActMsg( OBJMSG_SITDOWN ) == 1 )

  001fb	57		 push	 edi
  001fc	57		 push	 edi
  001fd	57		 push	 edi
  001fe	57		 push	 edi
  001ff	6a 04		 push	 4
  00201	8b ce		 mov	 ecx, esi
  00203	e8 00 00 00 00	 call	 ?SendActMsg@CMover@@QAEHW4OBJMSG@@HHHH@Z ; CMover::SendActMsg
  00208	83 f8 01	 cmp	 eax, 1
  0020b	75 3e		 jne	 SHORT $L277968

; 458  : 				{
; 459  : 					ClearDest();

  0020d	8b ce		 mov	 ecx, esi
  0020f	e8 00 00 00 00	 call	 ?ClearDest@CMover@@QAEXXZ ; CMover::ClearDest

; 460  : 					ClearDestAngle();
; 461  : 					memset( &m_CorrAction, 0, sizeof(CORR_ACTION) );

  00214	33 c0		 xor	 eax, eax
  00216	c7 86 6c 02 00
	00 00 00 80 bf	 mov	 DWORD PTR [esi+620], -1082130432 ; bf800000H
  00220	b9 14 00 00 00	 mov	 ecx, 20			; 00000014H
  00225	8d be 80 02 00
	00		 lea	 edi, DWORD PTR [esi+640]

; 462  : 					
; 463  : 					g_UserMng.AddMotion( this, OBJMSG_SITDOWN );

  0022b	6a 04		 push	 4
  0022d	f3 ab		 rep stosd
  0022f	56		 push	 esi
  00230	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_UserMng@@3VCUserMng@@A
  00235	e8 00 00 00 00	 call	 ?AddMotion@CUserMng@@QAEXPAVCMover@@K@Z ; CUserMng::AddMotion

; 464  : 					m_dwFlag &= (~MVRF_MEDITATION_SIT);

  0023a	8b 86 48 02 00
	00		 mov	 eax, DWORD PTR [esi+584]
$L348900:
  00240	25 ff ef ff ff	 and	 eax, -4097		; ffffefffH
  00245	89 86 48 02 00
	00		 mov	 DWORD PTR [esi+584], eax
$L277968:

; 465  : 				}
; 466  : 			}
; 467  : 		}
; 468  : 
; 469  : 
; 470  : 		//   
; 471  : 		if( m_nFuel > 0 )

  0024b	8b 86 80 06 00
	00		 mov	 eax, DWORD PTR [esi+1664]
  00251	85 c0		 test	 eax, eax
  00253	7e 44		 jle	 SHORT $L277974

; 472  : 		{
; 473  : 			if( (m_nCount & 15) == 0 )

  00255	f6 86 80 16 00
	00 0f		 test	 BYTE PTR [esi+5760], 15	; 0000000fH
  0025c	75 3b		 jne	 SHORT $L277974

; 474  : 			{
; 475  : 				if( m_pActMover->IsFly() && m_pActMover->IsStateFlag( OBJSTAF_ACC ) )

  0025e	8b 96 3c 02 00
	00		 mov	 edx, DWORD PTR [esi+572]
  00264	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00267	a8 08		 test	 al, 8
  00269	74 2e		 je	 SHORT $L277974
  0026b	a8 10		 test	 al, 16			; 00000010H
  0026d	74 2a		 je	 SHORT $L277974

; 476  : 				{
; 477  : 					ItemProp *pItemProp = prj.GetItemProp( m_dwRideItemIdx );

  0026f	8b 86 88 16 00
	00		 mov	 eax, DWORD PTR [esi+5768]
  00275	50		 push	 eax
  00276	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?prj@@3VCProject@@A
  0027b	e8 00 00 00 00	 call	 ?GetItemProp@CProject@@QAEPAUItemProp@@H@Z ; CProject::GetItemProp

; 478  : 					if( pItemProp )

  00280	85 c0		 test	 eax, eax
  00282	74 15		 je	 SHORT $L277974

; 479  : 						AddSetFuel( m_nFuel, m_tmAccFuel );	//    

  00284	8b 8e 84 06 00
	00		 mov	 ecx, DWORD PTR [esi+1668]
  0028a	8b 96 80 06 00
	00		 mov	 edx, DWORD PTR [esi+1664]
  00290	51		 push	 ecx
  00291	52		 push	 edx
  00292	8b ce		 mov	 ecx, esi
  00294	e8 00 00 00 00	 call	 ?AddSetFuel@CUser@@QAEXHK@Z ; CUser::AddSetFuel
$L277974:

; 480  : 				}
; 481  : 			}
; 482  : 		}
; 483  : 
; 484  : 		if( m_nOverHeal > 0)

  00299	8b 86 88 95 00
	00		 mov	 eax, DWORD PTR [esi+38280]
  0029f	85 c0		 test	 eax, eax
  002a1	7e 07		 jle	 SHORT $L277975

; 485  : 			--m_nOverHeal;

  002a3	48		 dec	 eax
  002a4	89 86 88 95 00
	00		 mov	 DWORD PTR [esi+38280], eax
$L277975:

; 486  : 	}
; 487  : 
; 488  : 	if( dwTick > m_dwTickNotify )				// 200ms 

  002aa	3b ae 20 57 00
	00		 cmp	 ebp, DWORD PTR [esi+22304]
  002b0	76 13		 jbe	 SHORT $L277976

; 489  : 	{
; 490  : 		m_dwTickNotify = dwTick + 200;

  002b2	8d 85 c8 00 00
	00		 lea	 eax, DWORD PTR [ebp+200]

; 491  : 		Notify();

  002b8	8b ce		 mov	 ecx, esi
  002ba	89 86 20 57 00
	00		 mov	 DWORD PTR [esi+22304], eax
  002c0	e8 00 00 00 00	 call	 ?Notify@CUser@@QAEHXZ	; CUser::Notify
$L277976:

; 492  : 	}
; 493  : 
; 494  : 	if( dwTick > m_dwTickSFS )					// 1 

  002c5	8b 86 1c 57 00
	00		 mov	 eax, DWORD PTR [esi+22300]
  002cb	3b e8		 cmp	 ebp, eax
  002cd	0f 86 e5 00 00
	00		 jbe	 $L277984

; 495  : 	{
; 496  : //		m_dwTickSFS = dwTick + 1000;
; 497  : 		m_dwTickSFS	+= 1000;	//    33 ms	- 

  002d3	05 e8 03 00 00	 add	 eax, 1000		; 000003e8H

; 498  : #if __VER >= 11 // __CHIPI_071210
; 499  : 		CheckFiniteItem();

  002d8	8b ce		 mov	 ecx, esi
  002da	89 86 1c 57 00
	00		 mov	 DWORD PTR [esi+22300], eax
  002e0	e8 00 00 00 00	 call	 ?CheckFiniteItem@CUser@@QAEXXZ ; CUser::CheckFiniteItem

; 500  : #endif // __CHIPI_071210
; 501  : 		#ifdef __EVENTLUA_COUPON
; 502  : 		prj.m_EventLua.SetCoupon( this, dwTick );

  002e5	55		 push	 ebp
  002e6	56		 push	 esi
  002e7	b9 f8 91 11 00	 mov	 ecx, OFFSET FLAT:?prj@@3VCProject@@A+1151480
  002ec	e8 00 00 00 00	 call	 ?SetCoupon@CEventLua@@QAEXPAVCUser@@K@Z ; CEventLua::SetCoupon

; 503  : 		#endif // __EVENTLUA_COUPON
; 504  : #ifdef __EVENTLUA_KEEPCONNECT
; 505  : 		prj.m_EventLua.SetKeepConnectEvent( this, dwTick );

  002f1	55		 push	 ebp
  002f2	56		 push	 esi
  002f3	b9 f8 91 11 00	 mov	 ecx, OFFSET FLAT:?prj@@3VCProject@@A+1151480
  002f8	e8 00 00 00 00	 call	 ?SetKeepConnectEvent@CEventLua@@QAEXPAVCUser@@K@Z ; CEventLua::SetKeepConnectEvent

; 506  : #endif // __EVENTLUA_KEEPCONNECT
; 507  : 
; 508  : 		CWorld* pWorld = GetWorld();

  002fd	8b be 6c 01 00
	00		 mov	 edi, DWORD PTR [esi+364]

; 509  : 		if( pWorld )

  00303	85 ff		 test	 edi, edi
  00305	0f 84 ad 00 00
	00		 je	 $L277984

; 510  : 		{
; 511  : 			SubSMMode();

  0030b	8b ce		 mov	 ecx, esi
  0030d	e8 00 00 00 00	 call	 ?SubSMMode@CMover@@QAEXXZ ; CMover::SubSMMode

; 512  : 			if( --m_dwTimeout4Save == 0 )		// 180 

  00312	ff 8e 24 57 00
	00		 dec	 DWORD PTR [esi+22308]
  00318	75 32		 jne	 SHORT $L277980

; 513  : 			{
; 514  : #if __VER < 11 // __CHIPI_071210
; 515  : 				CheckFiniteItem();
; 516  : #endif // __CHIPI_071210
; 517  : #if __VER >= 13 // __HONORABLE_TITLE			// 
; 518  : 				CheckHonorTime();

  0031a	8b ce		 mov	 ecx, esi
  0031c	e8 00 00 00 00	 call	 ?CheckHonorTime@CMover@@QAEXXZ ; CMover::CheckHonorTime

; 519  : #endif	// __HONORABLE_TITLE			// 
; 520  : #ifdef __LAYER_1015
; 521  : 				g_dpDBClient.SavePlayer( this, pWorld->GetID(), GetPos(), GetLayer() );

  00321	8b 8e b8 01 00
	00		 mov	 ecx, DWORD PTR [esi+440]
  00327	6a 00		 push	 0
  00329	51		 push	 ecx
  0032a	8d 54 24 14	 lea	 edx, DWORD PTR $T348759[esp+32]
  0032e	52		 push	 edx
  0032f	8b ce		 mov	 ecx, esi
  00331	e8 00 00 00 00	 call	 ?GetPos@CObj@@QAE?AUD3DXVECTOR3@@XZ ; CObj::GetPos
  00336	50		 push	 eax
  00337	8b 07		 mov	 eax, DWORD PTR [edi]
  00339	50		 push	 eax
  0033a	56		 push	 esi
  0033b	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_dpDBClient@@3VCDPDatabaseClient@@A
  00340	e8 00 00 00 00	 call	 ?SavePlayer@CDPDatabaseClient@@QAEXPAVCUser@@KAAUD3DXVECTOR3@@HH@Z ; CDPDatabaseClient::SavePlayer

; 522  : #else	// __LAYER_1015
; 523  : 				g_dpDBClient.SavePlayer( this, pWorld->GetID(), GetPos() );
; 524  : #endif	// __LAYER_1015
; 525  : 				AddEventLuaDesc();

  00345	8b ce		 mov	 ecx, esi
  00347	e8 00 00 00 00	 call	 ?AddEventLuaDesc@CUser@@QAEXXZ ; CUser::AddEventLuaDesc
$L277980:

; 526  : 			}
; 527  : #if __VER >= 15 // __GUILD_HOUSE
; 528  : 			if( GuildHouseMng->IsGuildHouse( pWorld->GetID() ) && GetLayer() == m_idGuild )

  0034c	8b 3f		 mov	 edi, DWORD PTR [edi]
  0034e	57		 push	 edi
  0034f	e8 00 00 00 00	 call	 ?GetInstance@CGuildHouseMng@@SAPAV1@XZ ; CGuildHouseMng::GetInstance
  00354	8b c8		 mov	 ecx, eax
  00356	e8 00 00 00 00	 call	 ?IsGuildHouse@CGuildHouseMng@@QAEHK@Z ; CGuildHouseMng::IsGuildHouse
  0035b	85 c0		 test	 eax, eax
  0035d	74 38		 je	 SHORT $L348851
  0035f	8b 8e b8 01 00
	00		 mov	 ecx, DWORD PTR [esi+440]
  00365	3b 8e 1c 07 00
	00		 cmp	 ecx, DWORD PTR [esi+1820]
  0036b	75 2a		 jne	 SHORT $L348851

; 529  : 			{
; 530  : 				if( m_tRestPointTick <= time_null() )	

  0036d	8b 96 b0 96 00
	00		 mov	 edx, DWORD PTR [esi+38576]
  00373	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR ?g_tCurrent@@3JA ; g_tCurrent
  00379	7f 1c		 jg	 SHORT $L348851

; 531  : 				{
; 532  : 					SetIncRestPoint( REST_POINT_INC );

  0037b	68 10 27 00 00	 push	 10000			; 00002710H
  00380	8b ce		 mov	 ecx, esi
  00382	e8 00 00 00 00	 call	 ?SetIncRestPoint@CUser@@QAEHH@Z ; CUser::SetIncRestPoint

; 533  : 					SetRestPointTick();

  00387	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_tCurrent@@3JA ; g_tCurrent
  0038c	05 f0 00 00 00	 add	 eax, 240		; 000000f0H
  00391	89 86 b0 96 00
	00		 mov	 DWORD PTR [esi+38576], eax
$L348851:

; 534  : 				}
; 535  : 			}
; 536  : 			
; 537  : 			if( m_nRestPoint != m_nPrevRestPoint )

  00397	8b 8e a8 96 00
	00		 mov	 ecx, DWORD PTR [esi+38568]
  0039d	3b 8e ac 96 00
	00		 cmp	 ecx, DWORD PTR [esi+38572]
  003a3	74 13		 je	 SHORT $L277984

; 538  : 			{
; 539  : 				AddRestPoint();

  003a5	8b ce		 mov	 ecx, esi
  003a7	e8 00 00 00 00	 call	 ?AddRestPoint@CUser@@AAEXXZ ; CUser::AddRestPoint

; 540  : 				m_nPrevRestPoint = m_nRestPoint;

  003ac	8b 96 a8 96 00
	00		 mov	 edx, DWORD PTR [esi+38568]
  003b2	89 96 ac 96 00
	00		 mov	 DWORD PTR [esi+38572], edx
$L277984:

; 541  : 			}
; 542  : #endif // __GUILD_HOUSE
; 543  : 		}
; 544  : #ifdef __VTN_TIMELIMIT
; 545  : 		if( m_nAccountPlayTime > -1 )
; 546  : 			m_nAccountPlayTime += SEC( 1 );
; 547  : #endif // __VTN_TIMELIMIT
; 548  : 	}
; 549  : 
; 550  : 
; 551  : #if __VER >= 8 // __S8_PK
; 552  : 	if( IsPKPink() && GetTickCount() > GetPKPink() )

  003b8	8b be 58 07 00
	00		 mov	 edi, DWORD PTR [esi+1880]
  003be	85 ff		 test	 edi, edi
  003c0	76 21		 jbe	 SHORT $L277985
  003c2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  003c8	3b c7		 cmp	 eax, edi
  003ca	76 17		 jbe	 SHORT $L277985

; 553  : 	{
; 554  : 		SetPKPink( 0 );
; 555  : 		g_UserMng.AddPKPink( this, 0 );

  003cc	6a 00		 push	 0
  003ce	56		 push	 esi
  003cf	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_UserMng@@3VCUserMng@@A
  003d4	c7 86 58 07 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+1880], 0
  003de	e8 00 00 00 00	 call	 ?AddPKPink@CUserMng@@QAEXPAVCMover@@E@Z ; CUserMng::AddPKPink
$L277985:

; 556  : 	}
; 557  : #endif // __VER >= 8 // __S8_PK
; 558  : #if __VER >= 15 // __REACTIVATE_EATPET
; 559  : 	if( HasActivatedEatPet() )

  003e3	8b 86 7c 06 00
	00		 mov	 eax, DWORD PTR [esi+1660]
  003e9	83 f8 ff	 cmp	 eax, -1
  003ec	74 73		 je	 SHORT $L348899

; 560  : 	{
; 561  : 		CMover* pEatPet = prj.GetMover( GetEatPetId() );

  003ee	50		 push	 eax
  003ef	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?prj@@3VCProject@@A
  003f4	e8 00 00 00 00	 call	 ?GetMover@CProject@@QAEPAVCMover@@K@Z ; CProject::GetMover
  003f9	8b f8		 mov	 edi, eax

; 562  : 		if( IsValidObj( pEatPet ) )

  003fb	85 ff		 test	 edi, edi
  003fd	74 62		 je	 SHORT $L348899
  003ff	f6 47 04 01	 test	 BYTE PTR [edi+4], 1
  00403	75 5c		 jne	 SHORT $L348899

; 563  : 		{
; 564  : 			if( !IsValidArea( pEatPet, 32 ) )

  00405	68 00 00 00 42	 push	 1107296256		; 42000000H
  0040a	57		 push	 edi
  0040b	8b ce		 mov	 ecx, esi
  0040d	e8 00 00 00 00	 call	 ?IsValidArea@CMover@@QAEHPAV1@M@Z ; CMover::IsValidArea
  00412	85 c0		 test	 eax, eax
  00414	75 4b		 jne	 SHORT $L348899

; 565  : 			{
; 566  : 				CAIPet* pAIPet	= static_cast<CAIPet*>( pEatPet->m_pAIInterface );

  00416	8b bf 88 01 00
	00		 mov	 edi, DWORD PTR [edi+392]

; 567  : 				if( pAIPet )

  0041c	85 ff		 test	 edi, edi

; 568  : 				{
; 569  : 					CItemElem* pItemElem = (CItemElem*)GetItemId( pAIPet->GetPetItemId() );

  0041e	8b ce		 mov	 ecx, esi
  00420	74 3a		 je	 SHORT $L277992
  00422	8b 7f 4c	 mov	 edi, DWORD PTR [edi+76]
  00425	57		 push	 edi
  00426	e8 00 00 00 00	 call	 ?GetItemId@CMover@@QAEPAVCItemBase@@K@Z ; CMover::GetItemId

; 570  : 					InactivateEatPet();

  0042b	8b ce		 mov	 ecx, esi
  0042d	8b f8		 mov	 edi, eax
  0042f	e8 00 00 00 00	 call	 ?InactivateEatPet@CMover@@QAEXXZ ; CMover::InactivateEatPet

; 571  : 					if( IsUsableItem( pItemElem ) )

  00434	57		 push	 edi
  00435	e8 00 00 00 00	 call	 ?IsUsableItem@@YAHPAVCItemBase@@@Z ; IsUsableItem
  0043a	83 c4 04	 add	 esp, 4
  0043d	85 c0		 test	 eax, eax
  0043f	74 20		 je	 SHORT $L348899

; 572  : 						DoUseItem( MAKELONG( ITYPE_ITEM, pItemElem->m_dwObjId ), pItemElem->m_dwObjId );

  00441	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00444	0f b7 c8	 movzx	 ecx, ax
  00447	6a ff		 push	 -1
  00449	c1 e1 10	 shl	 ecx, 16			; 00000010H
  0044c	50		 push	 eax
  0044d	51		 push	 ecx
  0044e	8b ce		 mov	 ecx, esi
  00450	e8 00 00 00 00	 call	 ?DoUseItem@CMover@@QAEHKKH@Z ; CMover::DoUseItem
  00455	5d		 pop	 ebp
  00456	5f		 pop	 edi
  00457	5e		 pop	 esi

; 576  : 			}
; 577  : 		}
; 578  : 	}
; 579  : #endif // __REACTIVATE_EATPET
; 580  : }

  00458	83 c4 0c	 add	 esp, 12			; 0000000cH
  0045b	c3		 ret	 0
$L277992:

; 573  : 				}
; 574  : 				else
; 575  : 					InactivateEatPet();

  0045c	e8 00 00 00 00	 call	 ?InactivateEatPet@CMover@@QAEXXZ ; CMover::InactivateEatPet
$L348899:
  00461	5d		 pop	 ebp
$L348898:
  00462	5f		 pop	 edi
$L278002:
  00463	5e		 pop	 esi

; 576  : 			}
; 577  : 		}
; 578  : 	}
; 579  : #endif // __REACTIVATE_EATPET
; 580  : }

  00464	83 c4 0c	 add	 esp, 12			; 0000000cH
  00467	c3		 ret	 0
?Process@CUser@@UAEXXZ ENDP				; CUser::Process
_TEXT	ENDS
PUBLIC	?RemoveAllUsers@CUserMng@@QAEXXZ		; CUserMng::RemoveAllUsers
; Function compile flags: /Ogty
;	COMDAT ?RemoveAllUsers@CUserMng@@QAEXXZ
_TEXT	SEGMENT
_it$ = -4						; size = 4
?RemoveAllUsers@CUserMng@@QAEXXZ PROC NEAR		; CUserMng::RemoveAllUsers, COMDAT
; _this$ = ecx

; 3868 : {

  00000	51		 push	 ecx
  00001	53		 push	 ebx
  00002	8b d9		 mov	 ebx, ecx

; 3869 : 	map<DWORD, CUser*>::iterator it;
; 3870 : 	for( it = m_users.begin(); it != m_users.end(); ++it )

  00004	8b 4b 0c	 mov	 ecx, DWORD PTR [ebx+12]
  00007	8b 01		 mov	 eax, DWORD PTR [ecx]
  00009	3b c1		 cmp	 eax, ecx
  0000b	55		 push	 ebp
  0000c	56		 push	 esi
  0000d	57		 push	 edi
  0000e	89 44 24 10	 mov	 DWORD PTR _it$[esp+20], eax
  00012	74 1d		 je	 SHORT $L280030
$L348947:

; 3871 : 	{
; 3872 : 		DestroyPlayer( it->second );

  00014	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00017	50		 push	 eax
  00018	8b cb		 mov	 ecx, ebx
  0001a	e8 00 00 00 00	 call	 ?DestroyPlayer@CUserMng@@QAEXPAVCUser@@@Z ; CUserMng::DestroyPlayer
  0001f	8d 4c 24 10	 lea	 ecx, DWORD PTR _it$[esp+20]
  00023	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::const_iterator::_Inc
  00028	8b 44 24 10	 mov	 eax, DWORD PTR _it$[esp+20]
  0002c	3b 43 0c	 cmp	 eax, DWORD PTR [ebx+12]
  0002f	75 e3		 jne	 SHORT $L348947
$L280030:

; 3873 : 	}
; 3874 : 
; 3875 : 	m_users.clear();

  00031	8b 4b 0c	 mov	 ecx, DWORD PTR [ebx+12]
  00034	8b 69 04	 mov	 ebp, DWORD PTR [ecx+4]
  00037	8a 45 15	 mov	 al, BYTE PTR [ebp+21]
  0003a	84 c0		 test	 al, al
  0003c	8d 7b 08	 lea	 edi, DWORD PTR [ebx+8]
  0003f	8b f5		 mov	 esi, ebp
  00041	75 1f		 jne	 SHORT $L349071
$L349069:
  00043	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00046	52		 push	 edx
  00047	8b cf		 mov	 ecx, edi
  00049	e8 00 00 00 00	 call	 ?_Erase@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Erase
  0004e	8b 36		 mov	 esi, DWORD PTR [esi]
  00050	55		 push	 ebp
  00051	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00056	8a 46 15	 mov	 al, BYTE PTR [esi+21]
  00059	83 c4 04	 add	 esp, 4
  0005c	84 c0		 test	 al, al
  0005e	8b ee		 mov	 ebp, esi
  00060	74 e1		 je	 SHORT $L349069
$L349071:
  00062	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00065	89 40 04	 mov	 DWORD PTR [eax+4], eax
  00068	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0006b	33 c9		 xor	 ecx, ecx
  0006d	89 4f 08	 mov	 DWORD PTR [edi+8], ecx
  00070	89 00		 mov	 DWORD PTR [eax], eax
  00072	8b 7f 04	 mov	 edi, DWORD PTR [edi+4]
  00075	89 7f 08	 mov	 DWORD PTR [edi+8], edi
  00078	5f		 pop	 edi
  00079	5e		 pop	 esi
  0007a	5d		 pop	 ebp

; 3876 : 	m_lCount = 0;

  0007b	89 4b 04	 mov	 DWORD PTR [ebx+4], ecx
  0007e	5b		 pop	 ebx

; 3877 : }

  0007f	59		 pop	 ecx
  00080	c3		 ret	 0
?RemoveAllUsers@CUserMng@@QAEXXZ ENDP			; CUserMng::RemoveAllUsers
_TEXT	ENDS
PUBLIC	?RemoveUserFromCacheMsg@CUserMng@@AAEXPAVCUser@@@Z ; CUserMng::RemoveUserFromCacheMsg
EXTRN	?SendPreventLogin@CDPDatabaseClient@@QAEXPBDK@Z:NEAR ; CDPDatabaseClient::SendPreventLogin
; Function compile flags: /Ogty
;	COMDAT ?RemoveUserFromCacheMsg@CUserMng@@AAEXPAVCUser@@@Z
_TEXT	SEGMENT
_pUser$ = 8						; size = 4
?RemoveUserFromCacheMsg@CUserMng@@AAEXPAVCUser@@@Z PROC NEAR ; CUserMng::RemoveUserFromCacheMsg, COMDAT
; _this$ = ecx

; 3923 : {

  00000	56		 push	 esi

; 3924 : 	//    
; 3925 : 	if( pUser->m_pWorld == NULL || pUser->IsRegionAttr(RA_SAFETY) || pUser->IsAuthHigher( AUTH_GAMEMASTER ) )   // ?		

  00001	8b 74 24 08	 mov	 esi, DWORD PTR _pUser$[esp]
  00005	8b 86 6c 01 00
	00		 mov	 eax, DWORD PTR [esi+364]
  0000b	85 c0		 test	 eax, eax
  0000d	57		 push	 edi
  0000e	8b f9		 mov	 edi, ecx
  00010	0f 84 8f 00 00
	00		 je	 $L280104
  00016	f6 86 d4 02 00
	00 10		 test	 BYTE PTR [esi+724], 16	; 00000010H
  0001d	0f 85 82 00 00
	00		 jne	 $L280104
  00023	83 be 48 06 00
	00 4c		 cmp	 DWORD PTR [esi+1608], 76 ; 0000004cH
  0002a	73 79		 jae	 SHORT $L280104

; 3928 : 		return;
; 3929 : 	}
; 3930 : 
; 3931 : 	if( pUser->GetWorld() && pUser->GetWorld()->GetID() == WI_WORLD_GUILDWAR )

  0002c	81 38 ca 00 00
	00		 cmp	 DWORD PTR [eax], 202	; 000000caH

; 3932 : 	{
; 3933 : 		DestroyPlayer( pUser );
; 3934 : 		return;

  00032	74 71		 je	 SHORT $L280104

; 3935 : 	}
; 3936 : 
; 3937 : 	ASSERT( pUser->m_dwDestroyTime == 0 );
; 3938 : 
; 3939 : 	//    
; 3940 : 	if( pUser->m_dwLeavePenatyTime == 0 )						//     

  00034	8b 86 28 57 00
	00		 mov	 eax, DWORD PTR [esi+22312]
  0003a	85 c0		 test	 eax, eax
  0003c	75 29		 jne	 SHORT $L280107

; 3941 : 	{
; 3942 : 		pUser->ScheduleDestory( ::timeGetTime() + TIMEWAIT_CLOSE * 1000 );	//   

  0003e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__timeGetTime@0
  00044	05 10 27 00 00	 add	 eax, 10000		; 00002710H
  00049	89 86 2c 57 00
	00		 mov	 DWORD PTR [esi+22316], eax

; 3943 : 		g_dpDBClient.SendPreventLogin( pUser->m_playAccount.lpszAccount, TIMEWAIT_CLOSE + 5 );

  0004f	6a 0f		 push	 15			; 0000000fH
  00051	81 c6 38 57 00
	00		 add	 esi, 22328		; 00005738H
  00057	56		 push	 esi
  00058	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_dpDBClient@@3VCDPDatabaseClient@@A
  0005d	e8 00 00 00 00	 call	 ?SendPreventLogin@CDPDatabaseClient@@QAEXPBDK@Z ; CDPDatabaseClient::SendPreventLogin
  00062	5f		 pop	 edi
  00063	5e		 pop	 esi

; 3953 : 	}
; 3954 : }

  00064	c2 04 00	 ret	 4
$L280107:
  00067	53		 push	 ebx

; 3944 : 	}
; 3945 : 	else if( ::timeGetTime() > pUser->m_dwLeavePenatyTime )		//    

  00068	8b 9e 28 57 00
	00		 mov	 ebx, DWORD PTR [esi+22312]
  0006e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__timeGetTime@0
  00074	3b c3		 cmp	 eax, ebx
  00076	76 0e		 jbe	 SHORT $L280109

; 3946 : 	{
; 3947 : 		DestroyPlayer( pUser );												//  

  00078	56		 push	 esi
  00079	8b cf		 mov	 ecx, edi
  0007b	e8 00 00 00 00	 call	 ?DestroyPlayer@CUserMng@@QAEXPAVCUser@@@Z ; CUserMng::DestroyPlayer
  00080	5b		 pop	 ebx
  00081	5f		 pop	 edi
  00082	5e		 pop	 esi

; 3953 : 	}
; 3954 : }

  00083	c2 04 00	 ret	 4
$L280109:

; 3948 : 	}
; 3949 : 	else														//    
; 3950 : 	{
; 3951 : 		pUser->ScheduleDestory( pUser->m_dwLeavePenatyTime );				//   

  00086	89 9e 2c 57 00
	00		 mov	 DWORD PTR [esi+22316], ebx

; 3952 : 		g_dpDBClient.SendPreventLogin( pUser->m_playAccount.lpszAccount, TIMEWAIT_CLOSE );

  0008c	6a 0a		 push	 10			; 0000000aH
  0008e	81 c6 38 57 00
	00		 add	 esi, 22328		; 00005738H
  00094	56		 push	 esi
  00095	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_dpDBClient@@3VCDPDatabaseClient@@A
  0009a	e8 00 00 00 00	 call	 ?SendPreventLogin@CDPDatabaseClient@@QAEXPBDK@Z ; CDPDatabaseClient::SendPreventLogin
  0009f	5b		 pop	 ebx
  000a0	5f		 pop	 edi
  000a1	5e		 pop	 esi

; 3953 : 	}
; 3954 : }

  000a2	c2 04 00	 ret	 4
$L280104:

; 3926 : 	{
; 3927 : 		DestroyPlayer( pUser );

  000a5	56		 push	 esi
  000a6	8b cf		 mov	 ecx, edi
  000a8	e8 00 00 00 00	 call	 ?DestroyPlayer@CUserMng@@QAEXPAVCUser@@@Z ; CUserMng::DestroyPlayer
  000ad	5f		 pop	 edi
  000ae	5e		 pop	 esi

; 3953 : 	}
; 3954 : }

  000af	c2 04 00	 ret	 4
?RemoveUserFromCacheMsg@CUserMng@@AAEXPAVCUser@@@Z ENDP	; CUserMng::RemoveUserFromCacheMsg
_TEXT	ENDS
PUBLIC	?AddGuildMsg@CUserMng@@QAEXKPBD@Z		; CUserMng::AddGuildMsg
; Function compile flags: /Ogty
;	COMDAT ?AddGuildMsg@CUserMng@@QAEXKPBD@Z
_TEXT	SEGMENT
_idGuild$ = 8						; size = 4
_lpsz$ = 12						; size = 4
?AddGuildMsg@CUserMng@@QAEXKPBD@Z PROC NEAR		; CUserMng::AddGuildMsg, COMDAT
; _this$ = ecx

; 5979 : 	CGuild* pGuild	= g_GuildMng.GetGuild( idGuild );

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _idGuild$[esp-4]
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx
  00007	50		 push	 eax
  00008	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_GuildMng@@3VCGuildMng@@A
  0000d	e8 00 00 00 00	 call	 ?GetGuild@CGuildMng@@QAEPAVCGuild@@K@Z ; CGuildMng::GetGuild

; 5980 : 	if( pGuild )

  00012	85 c0		 test	 eax, eax
  00014	74 0d		 je	 SHORT $L282726

; 5981 : 		AddGuildMsg( pGuild, lpsz );

  00016	8b 4c 24 0c	 mov	 ecx, DWORD PTR _lpsz$[esp]
  0001a	51		 push	 ecx
  0001b	50		 push	 eax
  0001c	8b ce		 mov	 ecx, esi
  0001e	e8 00 00 00 00	 call	 ?AddGuildMsg@CUserMng@@QAEXPAVCGuild@@PBD@Z ; CUserMng::AddGuildMsg
$L282726:
  00023	5e		 pop	 esi

; 5982 : }

  00024	c2 08 00	 ret	 8
?AddGuildMsg@CUserMng@@QAEXKPBD@Z ENDP			; CUserMng::AddGuildMsg
_TEXT	ENDS
PUBLIC	??_C@_08DLFHAEOO@NotGuild?$AA@			; `string'
PUBLIC	?AddGCRequestStatus@CUser@@QAEX_JV?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@@Z ; CUser::AddGCRequestStatus
EXTRN	?GetNextGuildCobmatTime@CGuildCombat@@QAE?AVCTime@ATL@@XZ:NEAR ; CGuildCombat::GetNextGuildCobmatTime
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
xdata$x	SEGMENT
$T349288 DD	0ffffffffH
	DD	FLAT:$L349133
$T349282 DD	019930520H
	DD	01H
	DD	FLAT:$T349288
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_C@_08DLFHAEOO@NotGuild?$AA@
CONST	SEGMENT
??_C@_08DLFHAEOO@NotGuild?$AA@ DB 'NotGuild', 00H	; `string'
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
CONST	ENDS
;	COMDAT ?AddGCRequestStatus@CUser@@QAEX_JV?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@@Z
_TEXT	SEGMENT
_dwRequstPenya$ = -32					; size = 4
$T349185 = -28						; size = 8
_RequestGuild$283281 = -28				; size = 8
_tNextTime$ = -20					; size = 8
__$EHRec$ = -12						; size = 12
tv204 = 8						; size = 4
_nPrizePenya$ = 8					; size = 8
_vecRequestStatus$ = 16					; size = 16
?AddGCRequestStatus@CUser@@QAEX_JV?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@@Z PROC NEAR ; CUser::AddGCRequestStatus, COMDAT
; _this$ = ecx

; 6810 : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?AddGCRequestStatus@CUser@@QAEX_JV?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	83 ec 14	 sub	 esp, 20			; 00000014H
  00018	55		 push	 ebp
  00019	8b e9		 mov	 ebp, ecx

; 6811 : 	DWORD dwRequstPenya = 0;
; 6812 : 	if( IsDelete() )	return;

  0001b	8a 45 04	 mov	 al, BYTE PTR [ebp+4]
  0001e	33 c9		 xor	 ecx, ecx
  00020	a8 01		 test	 al, 1
  00022	89 4c 24 20	 mov	 DWORD PTR __$EHRec$[esp+44], ecx
  00026	89 4c 24 04	 mov	 DWORD PTR _dwRequstPenya$[esp+36], ecx
  0002a	74 27		 je	 SHORT $L283270
  0002c	8b 44 24 34	 mov	 eax, DWORD PTR _vecRequestStatus$[esp+36]
  00030	3b c1		 cmp	 eax, ecx
  00032	0f 84 6f 01 00
	00		 je	 $L349278
  00038	50		 push	 eax
  00039	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0003e	83 c4 04	 add	 esp, 4
  00041	5d		 pop	 ebp

; 6837 : 	
; 6838 : }

  00042	8b 4c 24 14	 mov	 ecx, DWORD PTR __$EHRec$[esp+32]
  00046	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0004d	83 c4 20	 add	 esp, 32			; 00000020H
  00050	c2 18 00	 ret	 24			; 00000018H
$L283270:

; 6813 : 	
; 6814 : 	m_Snapshot.cb++;

  00053	66 ff 85 0c 57
	00 00		 inc	 WORD PTR [ebp+22284]
  0005a	53		 push	 ebx
  0005b	56		 push	 esi
  0005c	57		 push	 edi

; 6815 : 	m_Snapshot.ar << GetId();

  0005d	8b bd bc 01 00
	00		 mov	 edi, DWORD PTR [ebp+444]
  00063	8d b5 f8 16 00
	00		 lea	 esi, DWORD PTR [ebp+5880]
  00069	bb 04 00 00 00	 mov	 ebx, 4
  0006e	53		 push	 ebx
  0006f	8b ce		 mov	 ecx, esi
  00071	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00076	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00079	89 38		 mov	 DWORD PTR [eax], edi
  0007b	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0007e	03 c3		 add	 eax, ebx

; 6816 : 	m_Snapshot.ar << SNAPSHOTTYPE_GUILDCOMBAT;

  00080	6a 02		 push	 2
  00082	8b ce		 mov	 ecx, esi
  00084	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00087	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0008c	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0008f	66 c7 01 b8 00	 mov	 WORD PTR [ecx], 184	; 000000b8H
  00094	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00097	83 c2 02	 add	 edx, 2

; 6817 : 	m_Snapshot.ar << GC_REQUEST_STATUS;

  0009a	6a 01		 push	 1
  0009c	8b ce		 mov	 ecx, esi
  0009e	89 56 08	 mov	 DWORD PTR [esi+8], edx
  000a1	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000a6	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  000a9	88 1a		 mov	 BYTE PTR [edx], bl
  000ab	ff 46 08	 inc	 DWORD PTR [esi+8]

; 6818 : 	CTime tNextTime = g_GuildCombatMng.GetNextGuildCobmatTime();

  000ae	8d 44 24 1c	 lea	 eax, DWORD PTR _tNextTime$[esp+48]
  000b2	50		 push	 eax
  000b3	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_GuildCombatMng@@3VCGuildCombat@@A
  000b8	e8 00 00 00 00	 call	 ?GetNextGuildCobmatTime@CGuildCombat@@QAE?AVCTime@ATL@@XZ ; CGuildCombat::GetNextGuildCobmatTime

; 6819 : 	time_t d = (time_t)( tNextTime.GetTime() - time_null() );

  000bd	8b 7c 24 1c	 mov	 edi, DWORD PTR _tNextTime$[esp+48]
  000c1	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?g_tCurrent@@3JA ; g_tCurrent

; 6820 : 	m_Snapshot.ar << d;

  000c7	53		 push	 ebx
  000c8	8b ce		 mov	 ecx, esi
  000ca	2b fa		 sub	 edi, edx
  000cc	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000d1	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]

; 6821 : 	m_Snapshot.ar << nPrizePenya;

  000d4	8b 54 24 34	 mov	 edx, DWORD PTR _nPrizePenya$[esp+44]
  000d8	89 39		 mov	 DWORD PTR [ecx], edi
  000da	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000dd	03 c3		 add	 eax, ebx
  000df	6a 08		 push	 8
  000e1	8d 4c 24 18	 lea	 ecx, DWORD PTR $T349185[esp+52]
  000e5	89 46 08	 mov	 DWORD PTR [esi+8], eax
  000e8	8b 44 24 3c	 mov	 eax, DWORD PTR _nPrizePenya$[esp+52]
  000ec	51		 push	 ecx
  000ed	8b ce		 mov	 ecx, esi
  000ef	89 54 24 1c	 mov	 DWORD PTR $T349185[esp+56], edx
  000f3	89 44 24 20	 mov	 DWORD PTR $T349185[esp+60], eax
  000f7	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write

; 6822 : 	int nSize = vecRequestStatus.size();

  000fc	8b 7c 24 40	 mov	 edi, DWORD PTR _vecRequestStatus$[esp+48]
  00100	85 ff		 test	 edi, edi
  00102	75 04		 jne	 SHORT $L349191
  00104	33 db		 xor	 ebx, ebx
  00106	eb 09		 jmp	 SHORT $L349192
$L349191:
  00108	8b 5c 24 44	 mov	 ebx, DWORD PTR _vecRequestStatus$[esp+52]
  0010c	2b df		 sub	 ebx, edi
  0010e	c1 fb 03	 sar	 ebx, 3
$L349192:

; 6823 : 	m_Snapshot.ar << nSize;

  00111	6a 04		 push	 4
  00113	8b ce		 mov	 ecx, esi
  00115	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0011a	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0011d	89 1a		 mov	 DWORD PTR [edx], ebx
  0011f	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00122	83 c1 04	 add	 ecx, 4

; 6824 : 	for( int i = 0 ; i < nSize ; ++i )

  00125	85 db		 test	 ebx, ebx
  00127	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  0012a	7e 50		 jle	 SHORT $L283280

; 6823 : 	m_Snapshot.ar << nSize;

  0012c	89 5c 24 34	 mov	 DWORD PTR tv204[esp+44], ebx
$L283278:

; 6825 : 	{
; 6826 : 		CGuildCombat::__REQUESTGUILD RequestGuild = vecRequestStatus[i];

  00130	8b 1f		 mov	 ebx, DWORD PTR [edi]
  00132	8b 47 04	 mov	 eax, DWORD PTR [edi+4]

; 6827 : 		CGuild* pGuild = g_GuildMng.GetGuild( RequestGuild.uidGuild );

  00135	53		 push	 ebx
  00136	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_GuildMng@@3VCGuildMng@@A
  0013b	89 44 24 1c	 mov	 DWORD PTR _RequestGuild$283281[esp+56], eax
  0013f	e8 00 00 00 00	 call	 ?GetGuild@CGuildMng@@QAEPAVCGuild@@K@Z ; CGuildMng::GetGuild

; 6828 : 		if( pGuild )

  00144	85 c0		 test	 eax, eax

; 6829 : 			m_Snapshot.ar.WriteString( pGuild->m_szGuild );

  00146	8b ce		 mov	 ecx, esi
  00148	74 06		 je	 SHORT $L283283
  0014a	83 c0 08	 add	 eax, 8
  0014d	50		 push	 eax

; 6830 : 		else

  0014e	eb 05		 jmp	 SHORT $L349287
$L283283:

; 6831 : 			m_Snapshot.ar.WriteString( "NotGuild" );

  00150	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08DLFHAEOO@NotGuild?$AA@
$L349287:
  00155	e8 00 00 00 00	 call	 ?WriteString@CAr@@QAEXPBD@Z ; CAr::WriteString

; 6832 : 
; 6833 : 		if( m_idGuild == RequestGuild.uidGuild )

  0015a	39 9d 1c 07 00
	00		 cmp	 DWORD PTR [ebp+1820], ebx
  00160	75 08		 jne	 SHORT $L283279

; 6834 : 			dwRequstPenya = RequestGuild.dwPenya;

  00162	8b 4c 24 18	 mov	 ecx, DWORD PTR _RequestGuild$283281[esp+52]
  00166	89 4c 24 10	 mov	 DWORD PTR _dwRequstPenya$[esp+48], ecx
$L283279:
  0016a	8b 44 24 34	 mov	 eax, DWORD PTR tv204[esp+44]
  0016e	83 c7 08	 add	 edi, 8
  00171	48		 dec	 eax
  00172	89 44 24 34	 mov	 DWORD PTR tv204[esp+44], eax
  00176	75 b8		 jne	 SHORT $L283278

; 6824 : 	for( int i = 0 ; i < nSize ; ++i )

  00178	8b 7c 24 40	 mov	 edi, DWORD PTR _vecRequestStatus$[esp+48]
$L283280:

; 6835 : 	}	
; 6836 : 	m_Snapshot.ar << dwRequstPenya;

  0017c	6a 04		 push	 4
  0017e	8b ce		 mov	 ecx, esi
  00180	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00185	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00188	8b 44 24 10	 mov	 eax, DWORD PTR _dwRequstPenya$[esp+48]
  0018c	89 02		 mov	 DWORD PTR [edx], eax
  0018e	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00191	83 c1 04	 add	 ecx, 4

; 6837 : 	
; 6838 : }

  00194	85 ff		 test	 edi, edi
  00196	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  00199	74 09		 je	 SHORT $L349286
  0019b	57		 push	 edi
  0019c	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  001a1	83 c4 04	 add	 esp, 4
$L349286:
  001a4	5f		 pop	 edi
  001a5	5e		 pop	 esi
  001a6	5b		 pop	 ebx
$L349278:
  001a7	8b 4c 24 18	 mov	 ecx, DWORD PTR __$EHRec$[esp+36]
  001ab	5d		 pop	 ebp
  001ac	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  001b3	83 c4 20	 add	 esp, 32			; 00000020H
  001b6	c2 18 00	 ret	 24			; 00000018H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L349133:
  00000	8d 4d 0c	 lea	 ecx, DWORD PTR _vecRequestStatus$[ebp-4]
  00003	e9 00 00 00 00	 jmp	 ??1?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QAE@XZ ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::~vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >
__ehhandler$?AddGCRequestStatus@CUser@@QAEX_JV?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T349282
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?AddGCRequestStatus@CUser@@QAEX_JV?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@@Z ENDP ; CUser::AddGCRequestStatus
PUBLIC	?_Insert_n@?$vector@KV?$allocator@K@std@@@std@@IAEXViterator@12@IABK@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::_Insert_n
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ?_Insert_n@?$vector@KV?$allocator@K@std@@@std@@IAEXViterator@12@IABK@Z
_TEXT	SEGMENT
__Newvec$289511 = -4					; size = 4
tv393 = 8						; size = 4
__Where$ = 8						; size = 4
tv382 = 12						; size = 4
__Count$ = 12						; size = 4
__Tmp$ = 16						; size = 4
__Val$ = 16						; size = 4
?_Insert_n@?$vector@KV?$allocator@K@std@@@std@@IAEXViterator@12@IABK@Z PROC NEAR ; std::vector<unsigned long,std::allocator<unsigned long> >::_Insert_n, COMDAT
; _this$ = ecx

; 809  : 		{	// insert _Count * _Val at _Where

  00000	51		 push	 ecx

; 810  : 		_Ty _Tmp = _Val;	// in case _Val is in sequence

  00001	8b 44 24 10	 mov	 eax, DWORD PTR __Val$[esp]
  00005	56		 push	 esi
  00006	8b f1		 mov	 esi, ecx

; 811  : 		size_type _Capacity = capacity();

  00008	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0000b	85 d2		 test	 edx, edx
  0000d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000f	57		 push	 edi
  00010	89 4c 24 18	 mov	 DWORD PTR __Tmp$[esp+8], ecx
  00014	75 04		 jne	 SHORT $L349304
  00016	33 c0		 xor	 eax, eax
  00018	eb 08		 jmp	 SHORT $L349305
$L349304:
  0001a	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  0001d	2b c2		 sub	 eax, edx
  0001f	c1 f8 02	 sar	 eax, 2
$L349305:

; 812  : 
; 813  : 		if (_Count == 0)

  00022	8b 7c 24 14	 mov	 edi, DWORD PTR __Count$[esp+8]
  00026	85 ff		 test	 edi, edi
  00028	0f 84 ac 01 00
	00		 je	 $L289526

; 814  : 			;
; 815  : 		else if (max_size() - size() < _Count)

  0002e	85 d2		 test	 edx, edx
  00030	75 04		 jne	 SHORT $L349327
  00032	33 c9		 xor	 ecx, ecx
  00034	eb 08		 jmp	 SHORT $L349328
$L349327:
  00036	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00039	2b ca		 sub	 ecx, edx
  0003b	c1 f9 02	 sar	 ecx, 2
$L349328:
  0003e	53		 push	 ebx
  0003f	bb ff ff ff 3f	 mov	 ebx, 1073741823		; 3fffffffH
  00044	2b d9		 sub	 ebx, ecx
  00046	3b df		 cmp	 ebx, edi
  00048	73 07		 jae	 SHORT $L289507

; 816  : 			_Xlen();	// result too long

  0004a	8b ce		 mov	 ecx, esi
  0004c	e8 00 00 00 00	 call	 ?_Xlen@?$vector@KV?$allocator@K@std@@@std@@IBEXXZ ; std::vector<unsigned long,std::allocator<unsigned long> >::_Xlen
$L349459:
$L289507:

; 817  : 		else if (_Capacity < size() + _Count)

  00051	85 d2		 test	 edx, edx
  00053	75 04		 jne	 SHORT $L349334
  00055	33 c9		 xor	 ecx, ecx
  00057	eb 08		 jmp	 SHORT $L349335
$L349334:
  00059	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0005c	2b ca		 sub	 ecx, edx
  0005e	c1 f9 02	 sar	 ecx, 2
$L349335:
  00061	03 cf		 add	 ecx, edi
  00063	3b c1		 cmp	 eax, ecx
  00065	55		 push	 ebp
  00066	0f 83 d6 00 00
	00		 jae	 $L289509

; 818  : 			{	// not enough room, reallocate
; 819  : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 820  : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  0006c	8b c8		 mov	 ecx, eax
  0006e	d1 e9		 shr	 ecx, 1
  00070	bb ff ff ff 3f	 mov	 ebx, 1073741823		; 3fffffffH
  00075	2b d9		 sub	 ebx, ecx
  00077	3b d8		 cmp	 ebx, eax
  00079	73 04		 jae	 SHORT $L349294
  0007b	33 c0		 xor	 eax, eax
  0007d	eb 02		 jmp	 SHORT $L349295
$L349294:
  0007f	03 c1		 add	 eax, ecx
$L349295:

; 821  : 			if (_Capacity < size() + _Count)

  00081	85 d2		 test	 edx, edx
  00083	75 04		 jne	 SHORT $L349357
  00085	33 c9		 xor	 ecx, ecx
  00087	eb 08		 jmp	 SHORT $L349358
$L349357:
  00089	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0008c	2b ca		 sub	 ecx, edx
  0008e	c1 f9 02	 sar	 ecx, 2
$L349358:
  00091	03 cf		 add	 ecx, edi
  00093	3b c1		 cmp	 eax, ecx
  00095	73 12		 jae	 SHORT $L289510

; 822  : 				_Capacity = size() + _Count;

  00097	85 d2		 test	 edx, edx
  00099	75 04		 jne	 SHORT $L349364
  0009b	33 c0		 xor	 eax, eax
  0009d	eb 08		 jmp	 SHORT $L349365
$L349364:
  0009f	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000a2	2b c2		 sub	 eax, edx
  000a4	c1 f8 02	 sar	 eax, 2
$L349365:
  000a7	03 c7		 add	 eax, edi
$L289510:

; 823  : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

  000a9	c1 e0 02	 shl	 eax, 2
  000ac	50		 push	 eax
  000ad	89 44 24 20	 mov	 DWORD PTR tv382[esp+20], eax
  000b1	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 824  : 			pointer _Ptr = _Newvec;
; 825  : 
; 826  : 			_TRY_BEGIN
; 827  : 			_Ptr = _Ucopy(_Myfirst, _ITER_BASE(_Where),
; 828  : 				_Newvec);	// copy prefix

  000b6	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  000b9	8b 5c 24 1c	 mov	 ebx, DWORD PTR __Where$[esp+20]
  000bd	8b d0		 mov	 edx, eax
  000bf	8b c3		 mov	 eax, ebx
  000c1	2b c1		 sub	 eax, ecx
  000c3	c1 f8 02	 sar	 eax, 2
  000c6	8d 2c 85 00 00
	00 00		 lea	 ebp, DWORD PTR [eax*4]
  000cd	55		 push	 ebp
  000ce	51		 push	 ecx
  000cf	52		 push	 edx
  000d0	89 54 24 20	 mov	 DWORD PTR __Newvec$289511[esp+36], edx
  000d4	e8 00 00 00 00	 call	 _memmove
  000d9	83 c4 10	 add	 esp, 16			; 00000010H

; 829  : 			_Ptr = _Ufill(_Ptr, _Count, _Tmp);	// add new stuff

  000dc	8d 54 24 20	 lea	 edx, DWORD PTR __Tmp$[esp+16]
  000e0	52		 push	 edx
  000e1	03 c5		 add	 eax, ebp
  000e3	57		 push	 edi
  000e4	50		 push	 eax
  000e5	8b ce		 mov	 ecx, esi
  000e7	e8 00 00 00 00	 call	 ?_Ufill@?$vector@KV?$allocator@K@std@@@std@@IAEPAKPAKIABK@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::_Ufill

; 830  : 			_Ucopy(_ITER_BASE(_Where), _Mylast, _Ptr);	// copy suffix

  000ec	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  000ef	2b cb		 sub	 ecx, ebx
  000f1	c1 f9 02	 sar	 ecx, 2
  000f4	c1 e1 02	 shl	 ecx, 2
  000f7	51		 push	 ecx
  000f8	53		 push	 ebx
  000f9	50		 push	 eax
  000fa	e8 00 00 00 00	 call	 _memmove

; 831  : 			_CATCH_ALL
; 832  : 			_Destroy(_Newvec, _Ptr);
; 833  : 			this->_Alval.deallocate(_Newvec, _Capacity);
; 834  : 			_RERAISE;
; 835  : 			_CATCH_END
; 836  : 
; 837  : 			_Count += size();

  000ff	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00102	83 c4 0c	 add	 esp, 12			; 0000000cH
  00105	85 c0		 test	 eax, eax
  00107	75 04		 jne	 SHORT $L349447
  00109	33 c9		 xor	 ecx, ecx
  0010b	eb 08		 jmp	 SHORT $L349448
$L349447:
  0010d	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00110	2b c8		 sub	 ecx, eax
  00112	c1 f9 02	 sar	 ecx, 2
$L349448:
  00115	03 f9		 add	 edi, ecx

; 838  : 			if (_Myfirst != 0)

  00117	85 c0		 test	 eax, eax
  00119	74 09		 je	 SHORT $L349451

; 839  : 				{	// destroy and deallocate old array
; 840  : 				_Destroy(_Myfirst, _Mylast);
; 841  : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

  0011b	50		 push	 eax
  0011c	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00121	83 c4 04	 add	 esp, 4
$L349451:

; 842  : 				}
; 843  : 			_Myend = _Newvec + _Capacity;

  00124	8b 44 24 10	 mov	 eax, DWORD PTR __Newvec$289511[esp+20]
  00128	8b 54 24 1c	 mov	 edx, DWORD PTR tv382[esp+16]
  0012c	5d		 pop	 ebp
  0012d	5b		 pop	 ebx

; 844  : 			_Mylast = _Newvec + _Count;

  0012e	8d 0c b8	 lea	 ecx, DWORD PTR [eax+edi*4]
  00131	03 d0		 add	 edx, eax
  00133	5f		 pop	 edi
  00134	89 56 0c	 mov	 DWORD PTR [esi+12], edx
  00137	89 4e 08	 mov	 DWORD PTR [esi+8], ecx

; 845  : 			_Myfirst = _Newvec;

  0013a	89 46 04	 mov	 DWORD PTR [esi+4], eax
  0013d	5e		 pop	 esi

; 873  : 			}
; 874  : 		}

  0013e	59		 pop	 ecx
  0013f	c2 0c 00	 ret	 12			; 0000000cH
$L289509:

; 846  : 			}
; 847  : 		else if ((size_type)(_Mylast - _ITER_BASE(_Where)) < _Count)

  00142	8b 6e 08	 mov	 ebp, DWORD PTR [esi+8]
  00145	8b 5c 24 18	 mov	 ebx, DWORD PTR __Where$[esp+16]
  00149	8b d5		 mov	 edx, ebp
  0014b	2b d3		 sub	 edx, ebx
  0014d	c1 fa 02	 sar	 edx, 2
  00150	3b d7		 cmp	 edx, edi

; 848  : 			{	// new stuff spills off end
; 849  : 			_Ucopy(_ITER_BASE(_Where), _Mylast,
; 850  : 				_ITER_BASE(_Where) + _Count);	// copy suffix

  00152	8d 04 bd 00 00
	00 00		 lea	 eax, DWORD PTR [edi*4]
  00159	8b ce		 mov	 ecx, esi
  0015b	89 44 24 18	 mov	 DWORD PTR tv393[esp+16], eax
  0015f	73 4b		 jae	 SHORT $L289517
  00161	03 c3		 add	 eax, ebx
  00163	50		 push	 eax
  00164	55		 push	 ebp
  00165	53		 push	 ebx
  00166	e8 00 00 00 00	 call	 ??$_Ucopy@PAK@?$vector@KV?$allocator@K@std@@@std@@IAEPAKPAK00@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::_Ucopy<unsigned long *>

; 851  : 
; 852  : 			_TRY_BEGIN
; 853  : 			_Ufill(_Mylast, _Count - (_Mylast - _ITER_BASE(_Where)),
; 854  : 				_Tmp);	// insert new stuff off end

  0016b	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0016e	8b d0		 mov	 edx, eax
  00170	2b d3		 sub	 edx, ebx
  00172	8d 4c 24 20	 lea	 ecx, DWORD PTR __Tmp$[esp+16]
  00176	51		 push	 ecx
  00177	c1 fa 02	 sar	 edx, 2
  0017a	2b fa		 sub	 edi, edx
  0017c	57		 push	 edi
  0017d	50		 push	 eax
  0017e	8b ce		 mov	 ecx, esi
  00180	e8 00 00 00 00	 call	 ?_Ufill@?$vector@KV?$allocator@K@std@@@std@@IAEPAKPAKIABK@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::_Ufill

; 855  : 			_CATCH_ALL
; 856  : 			_Destroy(_ITER_BASE(_Where) + _Count, _Mylast + _Count);
; 857  : 			_RERAISE;
; 858  : 			_CATCH_END
; 859  : 
; 860  : 			_Mylast += _Count;

  00185	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00188	8b 44 24 18	 mov	 eax, DWORD PTR tv393[esp+16]
  0018c	03 c8		 add	 ecx, eax
  0018e	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  00191	8b f1		 mov	 esi, ecx

; 861  : 			fill(_ITER_BASE(_Where), _Mylast - _Count,
; 862  : 				_Tmp);	// insert up to old end

  00193	8d 4c 24 20	 lea	 ecx, DWORD PTR __Tmp$[esp+16]
  00197	51		 push	 ecx
  00198	2b f0		 sub	 esi, eax
  0019a	56		 push	 esi
  0019b	53		 push	 ebx
  0019c	e8 00 00 00 00	 call	 ??$fill@PAKK@std@@YAXPAK0ABK@Z ; std::fill<unsigned long *,unsigned long>
  001a1	83 c4 0c	 add	 esp, 12			; 0000000cH
  001a4	5d		 pop	 ebp
  001a5	5b		 pop	 ebx
  001a6	5f		 pop	 edi
  001a7	5e		 pop	 esi

; 873  : 			}
; 874  : 		}

  001a8	59		 pop	 ecx
  001a9	c2 0c 00	 ret	 12			; 0000000cH
$L289517:

; 863  : 			}
; 864  : 		else
; 865  : 			{	// new stuff can all be assigned
; 866  : 			pointer _Oldend = _Mylast;
; 867  : 			_Mylast = _Ucopy(_Oldend - _Count, _Oldend,
; 868  : 				_Mylast);	// copy suffix

  001ac	55		 push	 ebp
  001ad	8b fd		 mov	 edi, ebp
  001af	2b f8		 sub	 edi, eax
  001b1	55		 push	 ebp
  001b2	57		 push	 edi
  001b3	e8 00 00 00 00	 call	 ??$_Ucopy@PAK@?$vector@KV?$allocator@K@std@@@std@@IAEPAKPAK00@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::_Ucopy<unsigned long *>

; 869  : 			copy_backward(_ITER_BASE(_Where), _Oldend - _Count,
; 870  : 				_Oldend);	// copy hole

  001b8	55		 push	 ebp
  001b9	57		 push	 edi
  001ba	53		 push	 ebx
  001bb	89 46 08	 mov	 DWORD PTR [esi+8], eax
  001be	e8 00 00 00 00	 call	 ??$copy_backward@PAKPAK@std@@YAPAKPAK00@Z ; std::copy_backward<unsigned long *,unsigned long *>

; 871  : 			fill(_ITER_BASE(_Where), _ITER_BASE(_Where) + _Count,
; 872  : 				_Tmp);	// insert into hole

  001c3	8b 44 24 24	 mov	 eax, DWORD PTR tv393[esp+28]
  001c7	8d 54 24 2c	 lea	 edx, DWORD PTR __Tmp$[esp+28]
  001cb	52		 push	 edx
  001cc	03 c3		 add	 eax, ebx
  001ce	50		 push	 eax
  001cf	53		 push	 ebx
  001d0	e8 00 00 00 00	 call	 ??$fill@PAKK@std@@YAXPAK0ABK@Z ; std::fill<unsigned long *,unsigned long>
  001d5	83 c4 18	 add	 esp, 24			; 00000018H
  001d8	5d		 pop	 ebp
  001d9	5b		 pop	 ebx
$L289526:
  001da	5f		 pop	 edi
  001db	5e		 pop	 esi

; 873  : 			}
; 874  : 		}

  001dc	59		 pop	 ecx
  001dd	c2 0c 00	 ret	 12			; 0000000cH
$L349458:
?_Insert_n@?$vector@KV?$allocator@K@std@@@std@@IAEXViterator@12@IABK@Z ENDP ; std::vector<unsigned long,std::allocator<unsigned long> >::_Insert_n
_TEXT	ENDS
PUBLIC	?_Incsize@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAEXI@Z ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Incsize
PUBLIC	??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@ ; `string'
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\stdexcept
xdata$x	SEGMENT
$T349596 DD	0ffffffffH
	DD	FLAT:$L349465
$T349593 DD	019930520H
	DD	01H
	DD	FLAT:$T349596
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@ DB 'list<T> too long', 00H ; `string'
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\list
CONST	ENDS
;	COMDAT ?_Incsize@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
$T349464 = -80						; size = 28
$T349463 = -52						; size = 40
__$EHRec$ = -12						; size = 12
__Count$ = 8						; size = 4
?_Incsize@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAEXI@Z PROC NEAR ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Incsize, COMDAT
; _this$ = ecx

; 956  : 		{	// alter element count, with checking

  00000	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list

; 957  : 		if (max_size() - _Mysize < _Count)

  00006	8b 54 24 04	 mov	 edx, DWORD PTR __Count$[esp-4]
  0000a	6a ff		 push	 -1
  0000c	68 00 00 00 00	 push	 __ehhandler$?_Incsize@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAEXI@Z
  00011	50		 push	 eax
  00012	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00019	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  0001c	83 ec 44	 sub	 esp, 68			; 00000044H
  0001f	56		 push	 esi
  00020	be ff ff ff 3f	 mov	 esi, 1073741823		; 3fffffffH
  00025	2b f0		 sub	 esi, eax
  00027	3b f2		 cmp	 esi, edx
  00029	5e		 pop	 esi
  0002a	73 51		 jae	 SHORT $L289774

; 958  : 			_THROW(length_error, "list<T> too long");

  0002c	6a 10		 push	 16			; 00000010H
  0002e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@
  00033	8d 4c 24 08	 lea	 ecx, DWORD PTR $T349464[esp+88]
  00037	c7 44 24 20 0f
	00 00 00	 mov	 DWORD PTR $T349464[esp+112], 15 ; 0000000fH
  0003f	c7 44 24 1c 00
	00 00 00	 mov	 DWORD PTR $T349464[esp+108], 0
  00047	c6 44 24 0c 00	 mov	 BYTE PTR $T349464[esp+92], 0
  0004c	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00051	8d 04 24	 lea	 eax, DWORD PTR $T349464[esp+80]
  00054	50		 push	 eax
  00055	8d 4c 24 20	 lea	 ecx, DWORD PTR $T349463[esp+84]
  00059	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+92], 0
  00061	e8 00 00 00 00	 call	 ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
  00066	68 00 00 00 00	 push	 OFFSET FLAT:__TI3?AVlength_error@std@@
  0006b	8d 4c 24 20	 lea	 ecx, DWORD PTR $T349463[esp+84]
  0006f	51		 push	 ecx
  00070	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR $T349463[esp+88], OFFSET FLAT:??_7length_error@std@@6B@
  00078	e8 00 00 00 00	 call	 __CxxThrowException@8
$L349597:
$L289774:

; 959  : 		_Mysize += _Count;

  0007d	03 c2		 add	 eax, edx
  0007f	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 960  : 		}

  00082	8b 4c 24 44	 mov	 ecx, DWORD PTR __$EHRec$[esp+80]
  00086	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0008d	83 c4 50	 add	 esp, 80			; 00000050H
  00090	c2 04 00	 ret	 4
$L349595:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L349465:
  00000	8d 4d b0	 lea	 ecx, DWORD PTR $T349464[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?_Incsize@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAEXI@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T349593
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?_Incsize@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAEXI@Z ENDP ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Incsize
PUBLIC	?_Xlen@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IBEXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Xlen
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\stdexcept
xdata$x	SEGMENT
$T349720 DD	0ffffffffH
	DD	FLAT:$L349605
$T349717 DD	019930520H
	DD	01H
	DD	FLAT:$T349720
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IBEXXZ
_TEXT	SEGMENT
$T349604 = -80						; size = 28
$T349603 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IBEXXZ PROC NEAR ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Xlen, COMDAT
; _this$ = ecx

; 883  : 		{	// report a length_error

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?_Xlen@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IBEXXZ
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	83 ec 44	 sub	 esp, 68			; 00000044H

; 884  : 		_THROW(length_error, "vector<T> too long");

  00018	6a 12		 push	 18			; 00000012H
  0001a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  0001f	8d 4c 24 08	 lea	 ecx, DWORD PTR $T349604[esp+88]
  00023	c7 44 24 20 0f
	00 00 00	 mov	 DWORD PTR $T349604[esp+112], 15 ; 0000000fH
  0002b	c7 44 24 1c 00
	00 00 00	 mov	 DWORD PTR $T349604[esp+108], 0
  00033	c6 44 24 0c 00	 mov	 BYTE PTR $T349604[esp+92], 0
  00038	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  0003d	8d 04 24	 lea	 eax, DWORD PTR $T349604[esp+80]
  00040	50		 push	 eax
  00041	8d 4c 24 20	 lea	 ecx, DWORD PTR $T349603[esp+84]
  00045	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+92], 0
  0004d	e8 00 00 00 00	 call	 ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
  00052	68 00 00 00 00	 push	 OFFSET FLAT:__TI3?AVlength_error@std@@
  00057	8d 4c 24 20	 lea	 ecx, DWORD PTR $T349603[esp+84]
  0005b	51		 push	 ecx
  0005c	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR $T349603[esp+88], OFFSET FLAT:??_7length_error@std@@6B@
  00064	e8 00 00 00 00	 call	 __CxxThrowException@8
$L349721:
$L349719:
  00069	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L349605:
  00000	8d 4d b0	 lea	 ecx, DWORD PTR $T349604[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?_Xlen@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IBEXXZ:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T349717
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?_Xlen@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IBEXXZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Xlen
PUBLIC	?_Incsize@?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@IAEXI@Z ; std::list<CUser *,std::allocator<CUser *> >::_Incsize
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\stdexcept
xdata$x	SEGMENT
$T349860 DD	0ffffffffH
	DD	FLAT:$L349729
$T349857 DD	019930520H
	DD	01H
	DD	FLAT:$T349860
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\list
xdata$x	ENDS
;	COMDAT ?_Incsize@?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
$T349728 = -80						; size = 28
$T349727 = -52						; size = 40
__$EHRec$ = -12						; size = 12
__Count$ = 8						; size = 4
?_Incsize@?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@IAEXI@Z PROC NEAR ; std::list<CUser *,std::allocator<CUser *> >::_Incsize, COMDAT
; _this$ = ecx

; 956  : 		{	// alter element count, with checking

  00000	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list

; 957  : 		if (max_size() - _Mysize < _Count)

  00006	8b 54 24 04	 mov	 edx, DWORD PTR __Count$[esp-4]
  0000a	6a ff		 push	 -1
  0000c	68 00 00 00 00	 push	 __ehhandler$?_Incsize@?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@IAEXI@Z
  00011	50		 push	 eax
  00012	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00019	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  0001c	83 ec 44	 sub	 esp, 68			; 00000044H
  0001f	56		 push	 esi
  00020	be ff ff ff 3f	 mov	 esi, 1073741823		; 3fffffffH
  00025	2b f0		 sub	 esi, eax
  00027	3b f2		 cmp	 esi, edx
  00029	5e		 pop	 esi
  0002a	73 51		 jae	 SHORT $L290467

; 958  : 			_THROW(length_error, "list<T> too long");

  0002c	6a 10		 push	 16			; 00000010H
  0002e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@
  00033	8d 4c 24 08	 lea	 ecx, DWORD PTR $T349728[esp+88]
  00037	c7 44 24 20 0f
	00 00 00	 mov	 DWORD PTR $T349728[esp+112], 15 ; 0000000fH
  0003f	c7 44 24 1c 00
	00 00 00	 mov	 DWORD PTR $T349728[esp+108], 0
  00047	c6 44 24 0c 00	 mov	 BYTE PTR $T349728[esp+92], 0
  0004c	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00051	8d 04 24	 lea	 eax, DWORD PTR $T349728[esp+80]
  00054	50		 push	 eax
  00055	8d 4c 24 20	 lea	 ecx, DWORD PTR $T349727[esp+84]
  00059	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+92], 0
  00061	e8 00 00 00 00	 call	 ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
  00066	68 00 00 00 00	 push	 OFFSET FLAT:__TI3?AVlength_error@std@@
  0006b	8d 4c 24 20	 lea	 ecx, DWORD PTR $T349727[esp+84]
  0006f	51		 push	 ecx
  00070	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR $T349727[esp+88], OFFSET FLAT:??_7length_error@std@@6B@
  00078	e8 00 00 00 00	 call	 __CxxThrowException@8
$L349861:
$L290467:

; 959  : 		_Mysize += _Count;

  0007d	03 c2		 add	 eax, edx
  0007f	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 960  : 		}

  00082	8b 4c 24 44	 mov	 ecx, DWORD PTR __$EHRec$[esp+80]
  00086	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0008d	83 c4 50	 add	 esp, 80			; 00000050H
  00090	c2 04 00	 ret	 4
$L349859:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L349729:
  00000	8d 4d b0	 lea	 ecx, DWORD PTR $T349728[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?_Incsize@?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@IAEXI@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T349857
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?_Incsize@?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@IAEXI@Z ENDP ; std::list<CUser *,std::allocator<CUser *> >::_Incsize
PUBLIC	?_Xlen@?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@IBEXXZ ; std::vector<__ITEMINFO,std::allocator<__ITEMINFO> >::_Xlen
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\stdexcept
xdata$x	SEGMENT
$T349984 DD	0ffffffffH
	DD	FLAT:$L349869
$T349981 DD	019930520H
	DD	01H
	DD	FLAT:$T349984
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
$T349868 = -80						; size = 28
$T349867 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@IBEXXZ PROC NEAR ; std::vector<__ITEMINFO,std::allocator<__ITEMINFO> >::_Xlen, COMDAT
; _this$ = ecx

; 883  : 		{	// report a length_error

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?_Xlen@?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@IBEXXZ
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	83 ec 44	 sub	 esp, 68			; 00000044H

; 884  : 		_THROW(length_error, "vector<T> too long");

  00018	6a 12		 push	 18			; 00000012H
  0001a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  0001f	8d 4c 24 08	 lea	 ecx, DWORD PTR $T349868[esp+88]
  00023	c7 44 24 20 0f
	00 00 00	 mov	 DWORD PTR $T349868[esp+112], 15 ; 0000000fH
  0002b	c7 44 24 1c 00
	00 00 00	 mov	 DWORD PTR $T349868[esp+108], 0
  00033	c6 44 24 0c 00	 mov	 BYTE PTR $T349868[esp+92], 0
  00038	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  0003d	8d 04 24	 lea	 eax, DWORD PTR $T349868[esp+80]
  00040	50		 push	 eax
  00041	8d 4c 24 20	 lea	 ecx, DWORD PTR $T349867[esp+84]
  00045	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+92], 0
  0004d	e8 00 00 00 00	 call	 ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
  00052	68 00 00 00 00	 push	 OFFSET FLAT:__TI3?AVlength_error@std@@
  00057	8d 4c 24 20	 lea	 ecx, DWORD PTR $T349867[esp+84]
  0005b	51		 push	 ecx
  0005c	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR $T349867[esp+88], OFFSET FLAT:??_7length_error@std@@6B@
  00064	e8 00 00 00 00	 call	 __CxxThrowException@8
$L349985:
$L349983:
  00069	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L349869:
  00000	8d 4d b0	 lea	 ecx, DWORD PTR $T349868[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?_Xlen@?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@IBEXXZ:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T349981
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?_Xlen@?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@IBEXXZ ENDP ; std::vector<__ITEMINFO,std::allocator<__ITEMINFO> >::_Xlen
PUBLIC	??$fill@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0ABV10@@Z ; std::fill<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xutility
;	COMDAT ??$fill@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0ABV10@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0ABV10@@Z PROC NEAR ; std::fill<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 1134 : 	{	// copy _Val through [_First, _Last)

  00000	53		 push	 ebx

; 1135 : 	for (; _First != _Last; ++_First)

  00001	8b 5c 24 0c	 mov	 ebx, DWORD PTR __Last$[esp]
  00005	56		 push	 esi
  00006	8b 74 24 0c	 mov	 esi, DWORD PTR __First$[esp+4]
  0000a	3b f3		 cmp	 esi, ebx
  0000c	74 19		 je	 SHORT $L292756
  0000e	57		 push	 edi
  0000f	8b 7c 24 18	 mov	 edi, DWORD PTR __Val$[esp+8]
$L292754:

; 1136 : 		*_First = _Val;

  00013	6a ff		 push	 -1
  00015	6a 00		 push	 0
  00017	57		 push	 edi
  00018	8b ce		 mov	 ecx, esi
  0001a	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  0001f	83 c6 1c	 add	 esi, 28			; 0000001cH
  00022	3b f3		 cmp	 esi, ebx
  00024	75 ed		 jne	 SHORT $L292754
  00026	5f		 pop	 edi
$L292756:
  00027	5e		 pop	 esi
  00028	5b		 pop	 ebx

; 1137 : 	}

  00029	c3		 ret	 0
??$fill@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0ABV10@@Z ENDP ; std::fill<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??$_Destroy_range@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Destroy_range<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT

; 224  : 	{	// destroy [_First, _Last), arbitrary type

  00000	56		 push	 esi

; 225  : 	for (; _First != _Last; ++_First)

  00001	8b 74 24 08	 mov	 esi, DWORD PTR __First$[esp]
  00005	57		 push	 edi
  00006	8b 7c 24 10	 mov	 edi, DWORD PTR __Last$[esp+4]
  0000a	3b f7		 cmp	 esi, edi
  0000c	74 2a		 je	 SHORT $L293301
  0000e	53		 push	 ebx
  0000f	33 db		 xor	 ebx, ebx
$L293299:

; 226  : 		_Al.destroy(_First);

  00011	83 7e 18 10	 cmp	 DWORD PTR [esi+24], 16	; 00000010H
  00015	72 0c		 jb	 SHORT $L350144
  00017	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00020	83 c4 04	 add	 esp, 4
$L350144:
  00023	c7 46 18 0f 00
	00 00		 mov	 DWORD PTR [esi+24], 15	; 0000000fH
  0002a	89 5e 14	 mov	 DWORD PTR [esi+20], ebx
  0002d	88 5e 04	 mov	 BYTE PTR [esi+4], bl
  00030	83 c6 1c	 add	 esi, 28			; 0000001cH
  00033	3b f7		 cmp	 esi, edi
  00035	75 da		 jne	 SHORT $L293299
  00037	5b		 pop	 ebx
$L293301:
  00038	5f		 pop	 edi
  00039	5e		 pop	 esi

; 227  : 	}

  0003a	c3		 ret	 0
??$_Destroy_range@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Copy_backward_opt<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xutility
;	COMDAT ??$_Copy_backward_opt@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Copy_backward_opt@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00U_Nonscalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Copy_backward_opt<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>, COMDAT

; 1048 : 	{	// copy [_First, _Last) backwards to [..., _Dest), arbitrary iterators

  00000	53		 push	 ebx

; 1049 : 	while (_First != _Last)

  00001	8b 5c 24 08	 mov	 ebx, DWORD PTR __First$[esp]
  00005	56		 push	 esi
  00006	8b 74 24 10	 mov	 esi, DWORD PTR __Last$[esp+4]
  0000a	3b de		 cmp	 ebx, esi
  0000c	74 21		 je	 SHORT $L350175
  0000e	57		 push	 edi
  0000f	8b 7c 24 18	 mov	 edi, DWORD PTR __Dest$[esp+8]
$L293344:

; 1050 : 		*--_Dest = *--_Last;

  00013	6a ff		 push	 -1
  00015	6a 00		 push	 0
  00017	83 ee 1c	 sub	 esi, 28			; 0000001cH
  0001a	83 ef 1c	 sub	 edi, 28			; 0000001cH
  0001d	56		 push	 esi
  0001e	8b cf		 mov	 ecx, edi
  00020	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00025	3b f3		 cmp	 esi, ebx
  00027	75 ea		 jne	 SHORT $L293344

; 1051 : 	return (_Dest);

  00029	8b c7		 mov	 eax, edi
  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx

; 1052 : 	}

  0002e	c3		 ret	 0
$L350175:

; 1051 : 	return (_Dest);

  0002f	8b 44 24 14	 mov	 eax, DWORD PTR __Dest$[esp+4]
  00033	5e		 pop	 esi
  00034	5b		 pop	 ebx

; 1052 : 	}

  00035	c3		 ret	 0
??$_Copy_backward_opt@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
_TEXT	ENDS
PUBLIC	?construct@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@ABV32@@Z ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::construct
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ?construct@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@ABV32@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@ABV32@@Z PROC NEAR ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::construct, COMDAT
; _this$ = ecx

; 147  : 		_Construct(_Ptr, _Val);

  00000	8b 44 24 08	 mov	 eax, DWORD PTR __Val$[esp-4]
  00004	8b 4c 24 04	 mov	 ecx, DWORD PTR __Ptr$[esp-4]
  00008	50		 push	 eax
  00009	51		 push	 ecx
  0000a	e8 00 00 00 00	 call	 ??$_Construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@@Z ; std::_Construct<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
  0000f	83 c4 08	 add	 esp, 8

; 148  : 		}

  00012	c2 08 00	 ret	 8
?construct@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@ABV32@@Z ENDP ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::construct
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\iosfwd
xdata$x	SEGMENT
$T350371 DD	0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:$L350190
	DD	0ffffffffH
	DD	00H
$T350373 DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L350183
$T350372 DD	00H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:$T350373
$T350365 DD	019930520H
	DD	03H
	DD	FLAT:$T350371
	DD	01H
	DD	FLAT:$T350372
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
$T350357 = 8						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
??$_Uninit_copy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Uninit_copy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT

; 77   : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Uninit_copy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 08	 sub	 esp, 8
  0001b	53		 push	 ebx
  0001c	56		 push	 esi

; 78   : 	_FwdIt _Next = _Dest;

  0001d	8b 75 10	 mov	 esi, DWORD PTR __Dest$[ebp]
  00020	57		 push	 edi

; 79   : 
; 80   : 	_TRY_BEGIN

  00021	8b 7d 08	 mov	 edi, DWORD PTR __First$[ebp]
  00024	33 db		 xor	 ebx, ebx
  00026	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00029	89 75 ec	 mov	 DWORD PTR __Next$[ebp], esi
  0002c	89 5d fc	 mov	 DWORD PTR __$EHRec$[ebp+12], ebx
  0002f	90		 npad	 1
$L293612:

; 81   : 	for (; _First != _Last; ++_Dest, ++_First)

  00030	3b 7d 0c	 cmp	 edi, DWORD PTR __Last$[ebp]
  00033	74 56		 je	 SHORT $L293614

; 82   : 		_Al.construct(_Dest, *_First);

  00035	89 75 08	 mov	 DWORD PTR $T350357[ebp], esi
  00038	3b f3		 cmp	 esi, ebx
  0003a	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1
  0003e	74 18		 je	 SHORT $L350358
  00040	6a ff		 push	 -1
  00042	53		 push	 ebx
  00043	c7 46 18 0f 00
	00 00		 mov	 DWORD PTR [esi+24], 15	; 0000000fH
  0004a	89 5e 14	 mov	 DWORD PTR [esi+20], ebx
  0004d	57		 push	 edi
  0004e	8b ce		 mov	 ecx, esi
  00050	88 5e 04	 mov	 BYTE PTR [esi+4], bl
  00053	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$L350358:
  00058	83 c6 1c	 add	 esi, 28			; 0000001cH
  0005b	88 5d fc	 mov	 BYTE PTR __$EHRec$[ebp+12], bl
  0005e	89 75 10	 mov	 DWORD PTR __Dest$[ebp], esi
  00061	83 c7 1c	 add	 edi, 28			; 0000001cH
  00064	eb ca		 jmp	 SHORT $L293612
$L350183:

; 83   : 	_CATCH_ALL
; 84   : 	for (; _Next != _Dest; ++_Next)

  00066	8b 75 ec	 mov	 esi, DWORD PTR __Next$[ebp]
  00069	8b 7d 10	 mov	 edi, DWORD PTR __Dest$[ebp]
  0006c	3b f7		 cmp	 esi, edi
  0006e	74 12		 je	 SHORT $L293617
  00070	8b 5d 14	 mov	 ebx, DWORD PTR __Al$[ebp]
$L293615:

; 85   : 		_Al.destroy(_Next);

  00073	56		 push	 esi
  00074	8b cb		 mov	 ecx, ebx
  00076	e8 00 00 00 00	 call	 ?destroy@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::destroy
  0007b	83 c6 1c	 add	 esi, 28			; 0000001cH
  0007e	3b f7		 cmp	 esi, edi
  00080	75 f1		 jne	 SHORT $L293615
$L293617:

; 86   : 	_RERAISE;

  00082	33 db		 xor	 ebx, ebx
  00084	53		 push	 ebx
  00085	53		 push	 ebx
  00086	e8 00 00 00 00	 call	 __CxxThrowException@8
$L350374:
$L293614:

; 87   : 	_CATCH_END
; 88   : 	return (_Dest);
; 89   : 	}

  0008b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0008e	5f		 pop	 edi
  0008f	8b c6		 mov	 eax, esi
  00091	5e		 pop	 esi
  00092	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00099	5b		 pop	 ebx
  0009a	8b e5		 mov	 esp, ebp
  0009c	5d		 pop	 ebp
  0009d	c3		 ret	 0
$L350370:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L350190:
  00000	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00003	50		 push	 eax
  00004	8b 4d 08	 mov	 ecx, DWORD PTR $T350357[ebp]
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$_Uninit_copy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z:
  00011	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T350365
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$_Uninit_copy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	??0?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlsimpstr.h
xdata$x	SEGMENT
$T350460 DD	0ffffffffH
	DD	FLAT:$L350379
$T350454 DD	019930520H
	DD	01H
	DD	FLAT:$T350460
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\cstringt.h
xdata$x	ENDS
;	COMDAT ??0?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_pszSrc$ = 8						; size = 4
??0?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z PROC NEAR ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >, COMDAT
; _this$ = ecx

; 830  : 	{

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$??0?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	51		 push	 ecx
  00016	56		 push	 esi
  00017	8b f1		 mov	 esi, ecx
  00019	57		 push	 edi
  0001a	89 74 24 08	 mov	 DWORD PTR _this$[esp+24], esi
  0001e	e8 00 00 00 00	 call	 ?AfxGetStringManager@@YGPAUIAtlStringMgr@ATL@@XZ ; AfxGetStringManager
  00023	8b 10		 mov	 edx, DWORD PTR [eax]
  00025	8b c8		 mov	 ecx, eax
  00027	ff 52 0c	 call	 DWORD PTR [edx+12]
  0002a	83 c0 10	 add	 eax, 16			; 00000010H
  0002d	89 06		 mov	 DWORD PTR [esi], eax

; 831  : 		if( !CheckImplicitLoad( pszSrc ) )

  0002f	8b 54 24 1c	 mov	 edx, DWORD PTR _pszSrc$[esp+20]
  00033	85 d2		 test	 edx, edx
  00035	c7 44 24 14 00
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+32], 0
  0003d	74 33		 je	 SHORT $L350456
  0003f	f7 c2 00 00 ff
	ff		 test	 edx, -65536		; ffff0000H
  00045	75 2f		 jne	 SHORT $L350450
  00047	0f b7 fa	 movzx	 edi, dx
  0004a	57		 push	 edi
  0004b	e8 00 00 00 00	 call	 ?AfxFindStringResourceHandle@@YGPAUHINSTANCE__@@I@Z ; AfxFindStringResourceHandle
  00050	85 c0		 test	 eax, eax
  00052	74 3e		 je	 SHORT $L350458
  00054	57		 push	 edi
  00055	50		 push	 eax
  00056	8b ce		 mov	 ecx, esi
  00058	e8 00 00 00 00	 call	 ?LoadStringA@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEHPAUHINSTANCE__@@I@Z ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::LoadStringA
  0005d	5f		 pop	 edi

; 835  : 		}
; 836  : 	}

  0005e	8b c6		 mov	 eax, esi
  00060	5e		 pop	 esi
  00061	8b 4c 24 04	 mov	 ecx, DWORD PTR __$EHRec$[esp+16]
  00065	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0006c	83 c4 10	 add	 esp, 16			; 00000010H
  0006f	c2 04 00	 ret	 4
$L350456:

; 832  : 		{
; 833  : 			// nDestLength is in XCHARs
; 834  : 			*this = pszSrc;

  00072	33 c0		 xor	 eax, eax
  00074	eb 13		 jmp	 SHORT $L350449
$L350450:
  00076	8b c2		 mov	 eax, edx
  00078	8d 78 01	 lea	 edi, DWORD PTR [eax+1]
  0007b	eb 03 8d 49 00	 npad	 5
$L350457:
  00080	8a 08		 mov	 cl, BYTE PTR [eax]
  00082	40		 inc	 eax
  00083	84 c9		 test	 cl, cl
  00085	75 f9		 jne	 SHORT $L350457
  00087	2b c7		 sub	 eax, edi
$L350449:
  00089	50		 push	 eax
  0008a	52		 push	 edx
  0008b	8b ce		 mov	 ecx, esi
  0008d	e8 00 00 00 00	 call	 ?SetString@?$CSimpleStringT@D$0A@@ATL@@QAEXPBDH@Z ; ATL::CSimpleStringT<char,0>::SetString
$L350458:

; 835  : 		}
; 836  : 	}

  00092	8b 4c 24 0c	 mov	 ecx, DWORD PTR __$EHRec$[esp+24]
  00096	5f		 pop	 edi
  00097	8b c6		 mov	 eax, esi
  00099	5e		 pop	 esi
  0009a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  000a1	83 c4 10	 add	 esp, 16			; 00000010H
  000a4	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L350379:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$CSimpleStringT@D$0A@@ATL@@QAE@XZ ; ATL::CSimpleStringT<char,0>::~CSimpleStringT<char,0>
__ehhandler$??0?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T350454
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z ENDP ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::erase
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
$T350469 = 12						; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@0@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::erase, COMDAT
; _this$ = ecx

; 750  : 		{	// erase [_First, _Last)

  00000	53		 push	 ebx

; 751  : 		if (_First == begin() && _Last == end())

  00001	8b 5c 24 10	 mov	 ebx, DWORD PTR __Last$[esp]
  00005	56		 push	 esi
  00006	8b 74 24 10	 mov	 esi, DWORD PTR __First$[esp+4]
  0000a	57		 push	 edi
  0000b	8b f9		 mov	 edi, ecx
  0000d	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00010	3b 30		 cmp	 esi, DWORD PTR [eax]
  00012	75 38		 jne	 SHORT $L350801
  00014	3b d8		 cmp	 ebx, eax
  00016	75 34		 jne	 SHORT $L350801

; 752  : 			{	// erase all
; 753  : 			clear();

  00018	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0001b	50		 push	 eax
  0001c	8b cf		 mov	 ecx, edi
  0001e	e8 00 00 00 00	 call	 ?_Erase@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Erase
  00023	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00026	89 40 04	 mov	 DWORD PTR [eax+4], eax
  00029	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0002c	c7 47 08 00 00
	00 00		 mov	 DWORD PTR [edi+8], 0
  00033	89 00		 mov	 DWORD PTR [eax], eax
  00035	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00038	89 40 08	 mov	 DWORD PTR [eax+8], eax

; 754  : 			return (begin());

  0003b	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  0003e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00040	8b 44 24 10	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp+8]
  00044	5f		 pop	 edi
  00045	5e		 pop	 esi
  00046	89 10		 mov	 DWORD PTR [eax], edx
  00048	5b		 pop	 ebx

; 761  : 			}
; 762  : 		}

  00049	c2 0c 00	 ret	 12			; 0000000cH
$L350801:

; 755  : 			}
; 756  : 		else
; 757  : 			{	// partial erase, one at a time
; 758  : 			while (_First != _Last)

  0004c	3b f3		 cmp	 esi, ebx
  0004e	74 5b		 je	 SHORT $L220380
$L220379:

; 759  : 				erase(_First++);

  00050	8a 46 15	 mov	 al, BYTE PTR [esi+21]
  00053	84 c0		 test	 al, al
  00055	8b ce		 mov	 ecx, esi
  00057	75 41		 jne	 SHORT $L350771
  00059	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0005c	8a 50 15	 mov	 dl, BYTE PTR [eax+21]
  0005f	84 d2		 test	 dl, dl
  00061	75 1a		 jne	 SHORT $L350803
  00063	8b f0		 mov	 esi, eax
  00065	8b 06		 mov	 eax, DWORD PTR [esi]
  00067	8a 50 15	 mov	 dl, BYTE PTR [eax+21]
  0006a	84 d2		 test	 dl, dl
  0006c	75 2c		 jne	 SHORT $L350771
  0006e	8b ff		 npad	 2
$L350792:
  00070	8b f0		 mov	 esi, eax
  00072	8b 06		 mov	 eax, DWORD PTR [esi]
  00074	8a 50 15	 mov	 dl, BYTE PTR [eax+21]
  00077	84 d2		 test	 dl, dl
  00079	74 f5		 je	 SHORT $L350792
  0007b	eb 1d		 jmp	 SHORT $L350771
$L350803:
  0007d	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00080	8a 50 15	 mov	 dl, BYTE PTR [eax+21]
  00083	84 d2		 test	 dl, dl
  00085	75 11		 jne	 SHORT $L350774
$L350773:
  00087	3b 70 08	 cmp	 esi, DWORD PTR [eax+8]
  0008a	75 0c		 jne	 SHORT $L350774
  0008c	8b f0		 mov	 esi, eax
  0008e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00091	8a 50 15	 mov	 dl, BYTE PTR [eax+21]
  00094	84 d2		 test	 dl, dl
  00096	74 ef		 je	 SHORT $L350773
$L350774:
  00098	8b f0		 mov	 esi, eax
$L350771:
  0009a	51		 push	 ecx
  0009b	8d 44 24 18	 lea	 eax, DWORD PTR $T350469[esp+12]
  0009f	50		 push	 eax
  000a0	8b cf		 mov	 ecx, edi
  000a2	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::erase
  000a7	3b f3		 cmp	 esi, ebx
  000a9	75 a5		 jne	 SHORT $L220379
$L220380:

; 760  : 			return (_First);

  000ab	8b 44 24 10	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp+8]
  000af	5f		 pop	 edi
  000b0	89 30		 mov	 DWORD PTR [eax], esi
  000b2	5e		 pop	 esi
  000b3	5b		 pop	 ebx

; 761  : 			}
; 762  : 		}

  000b4	c2 0c 00	 ret	 12			; 0000000cH
?erase@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@0@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::erase
_TEXT	ENDS
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::erase
; Function compile flags: /Ogty
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
$T350813 = 12						; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@0@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::erase, COMDAT
; _this$ = ecx

; 750  : 		{	// erase [_First, _Last)

  00000	53		 push	 ebx

; 751  : 		if (_First == begin() && _Last == end())

  00001	8b 5c 24 10	 mov	 ebx, DWORD PTR __Last$[esp]
  00005	56		 push	 esi
  00006	8b 74 24 10	 mov	 esi, DWORD PTR __First$[esp+4]
  0000a	57		 push	 edi
  0000b	8b f9		 mov	 edi, ecx
  0000d	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00010	3b 30		 cmp	 esi, DWORD PTR [eax]
  00012	75 38		 jne	 SHORT $L351145
  00014	3b d8		 cmp	 ebx, eax
  00016	75 34		 jne	 SHORT $L351145

; 752  : 			{	// erase all
; 753  : 			clear();

  00018	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0001b	50		 push	 eax
  0001c	8b cf		 mov	 ecx, edi
  0001e	e8 00 00 00 00	 call	 ?_Erase@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::_Erase
  00023	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00026	89 40 04	 mov	 DWORD PTR [eax+4], eax
  00029	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0002c	c7 47 08 00 00
	00 00		 mov	 DWORD PTR [edi+8], 0
  00033	89 00		 mov	 DWORD PTR [eax], eax
  00035	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00038	89 40 08	 mov	 DWORD PTR [eax+8], eax

; 754  : 			return (begin());

  0003b	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  0003e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00040	8b 44 24 10	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp+8]
  00044	5f		 pop	 edi
  00045	5e		 pop	 esi
  00046	89 10		 mov	 DWORD PTR [eax], edx
  00048	5b		 pop	 ebx

; 761  : 			}
; 762  : 		}

  00049	c2 0c 00	 ret	 12			; 0000000cH
$L351145:

; 755  : 			}
; 756  : 		else
; 757  : 			{	// partial erase, one at a time
; 758  : 			while (_First != _Last)

  0004c	3b f3		 cmp	 esi, ebx
  0004e	74 5b		 je	 SHORT $L220441
$L220440:

; 759  : 				erase(_First++);

  00050	8a 46 15	 mov	 al, BYTE PTR [esi+21]
  00053	84 c0		 test	 al, al
  00055	8b ce		 mov	 ecx, esi
  00057	75 41		 jne	 SHORT $L351125
  00059	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0005c	8a 50 15	 mov	 dl, BYTE PTR [eax+21]
  0005f	84 d2		 test	 dl, dl
  00061	75 1a		 jne	 SHORT $L351147
  00063	8b f0		 mov	 esi, eax
  00065	8b 06		 mov	 eax, DWORD PTR [esi]
  00067	8a 50 15	 mov	 dl, BYTE PTR [eax+21]
  0006a	84 d2		 test	 dl, dl
  0006c	75 2c		 jne	 SHORT $L351125
  0006e	8b ff		 npad	 2
$L351130:
  00070	8b f0		 mov	 esi, eax
  00072	8b 06		 mov	 eax, DWORD PTR [esi]
  00074	8a 50 15	 mov	 dl, BYTE PTR [eax+21]
  00077	84 d2		 test	 dl, dl
  00079	74 f5		 je	 SHORT $L351130
  0007b	eb 1d		 jmp	 SHORT $L351125
$L351147:
  0007d	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00080	8a 50 15	 mov	 dl, BYTE PTR [eax+21]
  00083	84 d2		 test	 dl, dl
  00085	75 11		 jne	 SHORT $L351128
$L351127:
  00087	3b 70 08	 cmp	 esi, DWORD PTR [eax+8]
  0008a	75 0c		 jne	 SHORT $L351128
  0008c	8b f0		 mov	 esi, eax
  0008e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00091	8a 50 15	 mov	 dl, BYTE PTR [eax+21]
  00094	84 d2		 test	 dl, dl
  00096	74 ef		 je	 SHORT $L351127
$L351128:
  00098	8b f0		 mov	 esi, eax
$L351125:
  0009a	51		 push	 ecx
  0009b	8d 44 24 18	 lea	 eax, DWORD PTR $T350813[esp+12]
  0009f	50		 push	 eax
  000a0	8b cf		 mov	 ecx, edi
  000a2	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::erase
  000a7	3b f3		 cmp	 esi, ebx
  000a9	75 a5		 jne	 SHORT $L220440
$L220441:

; 760  : 			return (_First);

  000ab	8b 44 24 10	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp+8]
  000af	5f		 pop	 edi
  000b0	89 30		 mov	 DWORD PTR [eax], esi
  000b2	5e		 pop	 esi
  000b3	5b		 pop	 ebx

; 761  : 			}
; 762  : 		}

  000b4	c2 0c 00	 ret	 12			; 0000000cH
?erase@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@0@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::erase
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@KV?$allocator@K@std@@@std@@IAE_NI@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::_Buy
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ?_Buy@?$vector@KV?$allocator@K@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@KV?$allocator@K@std@@@std@@IAE_NI@Z PROC NEAR ; std::vector<unsigned long,std::allocator<unsigned long> >::_Buy, COMDAT
; _this$ = ecx

; 771  : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;
; 772  : 		if (_Capacity == 0)

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Capacity$[esp-4]
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx
  00007	33 c9		 xor	 ecx, ecx
  00009	3b c1		 cmp	 eax, ecx
  0000b	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  0000e	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  00011	89 4e 0c	 mov	 DWORD PTR [esi+12], ecx
  00014	75 06		 jne	 SHORT $L220539

; 773  : 			return (false);

  00016	32 c0		 xor	 al, al
  00018	5e		 pop	 esi

; 783  : 		}

  00019	c2 04 00	 ret	 4
$L220539:

; 774  : 		else if (max_size() < _Capacity)

  0001c	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  00021	76 07		 jbe	 SHORT $L220541

; 775  : 			_Xlen();	// result too long

  00023	8b ce		 mov	 ecx, esi
  00025	e8 00 00 00 00	 call	 ?_Xlen@?$vector@KV?$allocator@K@std@@@std@@IBEXXZ ; std::vector<unsigned long,std::allocator<unsigned long> >::_Xlen
$L351179:
$L220541:
  0002a	57		 push	 edi

; 776  : 		else
; 777  : 			{	// nonempty array, allocate storage
; 778  : 			_Myfirst = this->_Alval.allocate(_Capacity);

  0002b	8d 3c 85 00 00
	00 00		 lea	 edi, DWORD PTR [eax*4]
  00032	57		 push	 edi
  00033	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 779  : 			_Mylast = _Myfirst;
; 780  : 			_Myend = _Myfirst + _Capacity;

  00038	03 f8		 add	 edi, eax
  0003a	83 c4 04	 add	 esp, 4
  0003d	89 7e 0c	 mov	 DWORD PTR [esi+12], edi
  00040	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00043	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00046	5f		 pop	 edi

; 781  : 			}
; 782  : 		return (true);

  00047	b0 01		 mov	 al, 1
  00049	5e		 pop	 esi

; 783  : 		}

  0004a	c2 04 00	 ret	 4
$L351178:
?_Buy@?$vector@KV?$allocator@K@std@@@std@@IAE_NI@Z ENDP	; std::vector<unsigned long,std::allocator<unsigned long> >::_Buy
_TEXT	ENDS
PUBLIC	?insert@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBKPAVCUser@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::insert
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ?insert@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBKPAVCUser@@@2@@Z
_TEXT	SEGMENT
__Addleft$ = -4						; size = 1
___$ReturnUdt$ = 8					; size = 4
$T351191 = 12						; size = 4
$T351189 = 12						; size = 4
__Where$221481 = 12					; size = 4
__Val$ = 12						; size = 4
?insert@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBKPAVCUser@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::insert, COMDAT
; _this$ = ecx

; 477  : 		{	// try to insert node with value _Val

  00000	51		 push	 ecx
  00001	55		 push	 ebp

; 478  : 		_Nodeptr _Trynode = _Root();
; 479  : 		_Nodeptr _Wherenode = _Myhead;
; 480  : 		bool _Addleft = true;	// add to left of head if tree empty
; 481  : 		while (!_Isnil(_Trynode))

  00002	8b 6c 24 10	 mov	 ebp, DWORD PTR __Val$[esp+4]
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	8b f9		 mov	 edi, ecx
  0000a	8b 77 04	 mov	 esi, DWORD PTR [edi+4]
  0000d	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00010	8a 50 15	 mov	 dl, BYTE PTR [eax+21]
  00013	84 d2		 test	 dl, dl
  00015	b1 01		 mov	 cl, 1
  00017	88 4c 24 0c	 mov	 BYTE PTR __Addleft$[esp+16], cl
  0001b	75 20		 jne	 SHORT $L221471
  0001d	8b 55 00	 mov	 edx, DWORD PTR [ebp]
$L221470:

; 482  : 			{	// look for leaf to insert before (_Addleft) or after
; 483  : 			_Wherenode = _Trynode;
; 484  : 			_Addleft = this->comp(this->_Kfn(_Val), _Key(_Trynode));

  00020	3b 50 0c	 cmp	 edx, DWORD PTR [eax+12]
  00023	0f 92 c1	 setb	 cl

; 485  : 			_Trynode = _Addleft ? _Left(_Trynode) : _Right(_Trynode);

  00026	84 c9		 test	 cl, cl
  00028	8b f0		 mov	 esi, eax
  0002a	88 4c 24 0c	 mov	 BYTE PTR __Addleft$[esp+16], cl
  0002e	74 04		 je	 SHORT $L351183
  00030	8b 00		 mov	 eax, DWORD PTR [eax]
  00032	eb 03		 jmp	 SHORT $L351184
$L351183:
  00034	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
$L351184:

; 478  : 		_Nodeptr _Trynode = _Root();
; 479  : 		_Nodeptr _Wherenode = _Myhead;
; 480  : 		bool _Addleft = true;	// add to left of head if tree empty
; 481  : 		while (!_Isnil(_Trynode))

  00037	80 78 15 00	 cmp	 BYTE PTR [eax+21], 0
  0003b	74 e3		 je	 SHORT $L221470
$L221471:

; 486  : 			}
; 487  : 
; 488  : 		if (this->_Multi)
; 489  : 			return (_Pairib(_Insert(_Addleft, _Wherenode, _Val), true));
; 490  : 		else
; 491  : 			{	// insert only if unique
; 492  : 			iterator _Where = _TREE_ITERATOR(_Wherenode);
; 493  : 			if (!_Addleft)

  0003d	84 c9		 test	 cl, cl
  0003f	8b d6		 mov	 edx, esi
  00041	89 54 24 18	 mov	 DWORD PTR __Where$221481[esp+12], edx
  00045	74 33		 je	 SHORT $L351283

; 494  : 				;	// need to test if insert after is okay
; 495  : 			else if (_Where == begin())

  00047	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0004a	3b 30		 cmp	 esi, DWORD PTR [eax]

; 496  : 				return (_Pairib(_Insert(true, _Wherenode, _Val), true));

  0004c	8d 4c 24 18	 lea	 ecx, DWORD PTR $T351189[esp+12]
  00050	75 1f		 jne	 SHORT $L221486
  00052	55		 push	 ebp
  00053	56		 push	 esi
  00054	6a 01		 push	 1
  00056	51		 push	 ecx
  00057	8b cf		 mov	 ecx, edi
  00059	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBKPAVCUser@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Insert
  0005e	8b 10		 mov	 edx, DWORD PTR [eax]
  00060	8b 44 24 14	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp+12]
  00064	5f		 pop	 edi
  00065	5e		 pop	 esi
  00066	c6 40 04 01	 mov	 BYTE PTR [eax+4], 1

; 502  : 			else
; 503  : 				return (_Pairib(_Where, false));

  0006a	89 10		 mov	 DWORD PTR [eax], edx
  0006c	5d		 pop	 ebp

; 504  : 			}
; 505  : 		}

  0006d	59		 pop	 ecx
  0006e	c2 08 00	 ret	 8
$L221486:

; 497  : 			else
; 498  : 				--_Where;	// need to test if insert before is okay

  00071	e8 00 00 00 00	 call	 ?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::const_iterator::_Dec
  00076	8b 54 24 18	 mov	 edx, DWORD PTR __Where$221481[esp+12]
$L351283:

; 499  : 
; 500  : 			if (this->comp(_Key(_Where._Mynode()), this->_Kfn(_Val)))

  0007a	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  0007d	3b 45 00	 cmp	 eax, DWORD PTR [ebp]
  00080	73 26		 jae	 SHORT $L221491

; 501  : 				return (_Pairib(_Insert(_Addleft, _Wherenode, _Val), true));

  00082	8b 4c 24 0c	 mov	 ecx, DWORD PTR __Addleft$[esp+16]
  00086	55		 push	 ebp
  00087	56		 push	 esi
  00088	51		 push	 ecx
  00089	8d 54 24 24	 lea	 edx, DWORD PTR $T351191[esp+24]
  0008d	52		 push	 edx
  0008e	8b cf		 mov	 ecx, edi
  00090	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBKPAVCUser@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Insert
  00095	8b 08		 mov	 ecx, DWORD PTR [eax]
  00097	8b 44 24 14	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp+12]
  0009b	5f		 pop	 edi
  0009c	5e		 pop	 esi
  0009d	89 08		 mov	 DWORD PTR [eax], ecx
  0009f	c6 40 04 01	 mov	 BYTE PTR [eax+4], 1
  000a3	5d		 pop	 ebp

; 504  : 			}
; 505  : 		}

  000a4	59		 pop	 ecx
  000a5	c2 08 00	 ret	 8
$L221491:

; 502  : 			else
; 503  : 				return (_Pairib(_Where, false));

  000a8	8b 44 24 14	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp+12]
  000ac	5f		 pop	 edi
  000ad	5e		 pop	 esi
  000ae	c6 40 04 00	 mov	 BYTE PTR [eax+4], 0
  000b2	89 10		 mov	 DWORD PTR [eax], edx
  000b4	5d		 pop	 ebp

; 504  : 			}
; 505  : 		}

  000b5	59		 pop	 ecx
  000b6	c2 08 00	 ret	 8
?insert@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBKPAVCUser@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::insert
_TEXT	ENDS
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@V312@0@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::erase
; Function compile flags: /Ogty
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@V312@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
$T351323 = 12						; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@V312@0@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::erase, COMDAT
; _this$ = ecx

; 750  : 		{	// erase [_First, _Last)

  00000	53		 push	 ebx

; 751  : 		if (_First == begin() && _Last == end())

  00001	8b 5c 24 10	 mov	 ebx, DWORD PTR __Last$[esp]
  00005	56		 push	 esi
  00006	8b 74 24 10	 mov	 esi, DWORD PTR __First$[esp+4]
  0000a	57		 push	 edi
  0000b	8b f9		 mov	 edi, ecx
  0000d	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00010	3b 30		 cmp	 esi, DWORD PTR [eax]
  00012	75 38		 jne	 SHORT $L351655
  00014	3b d8		 cmp	 ebx, eax
  00016	75 34		 jne	 SHORT $L351655

; 752  : 			{	// erase all
; 753  : 			clear();

  00018	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0001b	50		 push	 eax
  0001c	8b cf		 mov	 ecx, edi
  0001e	e8 00 00 00 00	 call	 ?_Erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Erase
  00023	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00026	89 40 04	 mov	 DWORD PTR [eax+4], eax
  00029	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0002c	c7 47 08 00 00
	00 00		 mov	 DWORD PTR [edi+8], 0
  00033	89 00		 mov	 DWORD PTR [eax], eax
  00035	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00038	89 40 08	 mov	 DWORD PTR [eax+8], eax

; 754  : 			return (begin());

  0003b	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  0003e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00040	8b 44 24 10	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp+8]
  00044	5f		 pop	 edi
  00045	5e		 pop	 esi
  00046	89 10		 mov	 DWORD PTR [eax], edx
  00048	5b		 pop	 ebx

; 761  : 			}
; 762  : 		}

  00049	c2 0c 00	 ret	 12			; 0000000cH
$L351655:

; 755  : 			}
; 756  : 		else
; 757  : 			{	// partial erase, one at a time
; 758  : 			while (_First != _Last)

  0004c	3b f3		 cmp	 esi, ebx
  0004e	74 5b		 je	 SHORT $L221906
$L221905:

; 759  : 				erase(_First++);

  00050	8a 46 15	 mov	 al, BYTE PTR [esi+21]
  00053	84 c0		 test	 al, al
  00055	8b ce		 mov	 ecx, esi
  00057	75 41		 jne	 SHORT $L351649
  00059	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0005c	8a 50 15	 mov	 dl, BYTE PTR [eax+21]
  0005f	84 d2		 test	 dl, dl
  00061	75 1a		 jne	 SHORT $L351657
  00063	8b f0		 mov	 esi, eax
  00065	8b 06		 mov	 eax, DWORD PTR [esi]
  00067	8a 50 15	 mov	 dl, BYTE PTR [eax+21]
  0006a	84 d2		 test	 dl, dl
  0006c	75 2c		 jne	 SHORT $L351649
  0006e	8b ff		 npad	 2
$L351637:
  00070	8b f0		 mov	 esi, eax
  00072	8b 06		 mov	 eax, DWORD PTR [esi]
  00074	8a 50 15	 mov	 dl, BYTE PTR [eax+21]
  00077	84 d2		 test	 dl, dl
  00079	74 f5		 je	 SHORT $L351637
  0007b	eb 1d		 jmp	 SHORT $L351649
$L351657:
  0007d	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00080	8a 50 15	 mov	 dl, BYTE PTR [eax+21]
  00083	84 d2		 test	 dl, dl
  00085	75 11		 jne	 SHORT $L351652
$L351651:
  00087	3b 70 08	 cmp	 esi, DWORD PTR [eax+8]
  0008a	75 0c		 jne	 SHORT $L351652
  0008c	8b f0		 mov	 esi, eax
  0008e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00091	8a 50 15	 mov	 dl, BYTE PTR [eax+21]
  00094	84 d2		 test	 dl, dl
  00096	74 ef		 je	 SHORT $L351651
$L351652:
  00098	8b f0		 mov	 esi, eax
$L351649:
  0009a	51		 push	 ecx
  0009b	8d 44 24 18	 lea	 eax, DWORD PTR $T351323[esp+12]
  0009f	50		 push	 eax
  000a0	8b cf		 mov	 ecx, edi
  000a2	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::erase
  000a7	3b f3		 cmp	 esi, ebx
  000a9	75 a5		 jne	 SHORT $L221905
$L221906:

; 760  : 			return (_First);

  000ab	8b 44 24 10	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp+8]
  000af	5f		 pop	 edi
  000b0	89 30		 mov	 DWORD PTR [eax], esi
  000b2	5e		 pop	 esi
  000b3	5b		 pop	 ebx

; 761  : 			}
; 762  : 		}

  000b4	c2 0c 00	 ret	 12			; 0000000cH
?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@V312@0@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::erase
_TEXT	ENDS
PUBLIC	?Format@CTime@ATL@@QBE?AV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@2@PBD@Z ; ATL::CTime::Format
EXTRN	_strftime:NEAR
EXTRN	__localtime64:NEAR
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atltime.h
;	COMDAT ?Format@CTime@ATL@@QBE?AV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@2@PBD@Z
_TEXT	SEGMENT
$T351666 = -136						; size = 4
_szBuffer$ = -132					; size = 128
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_pFormat$ = 12						; size = 4
?Format@CTime@ATL@@QBE?AV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@2@PBD@Z PROC NEAR ; ATL::CTime::Format, COMDAT
; _this$ = ecx

; 344  : {

  00000	81 ec 88 00 00
	00		 sub	 esp, 136		; 00000088H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c4		 xor	 eax, esp
  0000d	56		 push	 esi
  0000e	8b b4 24 94 00
	00 00		 mov	 esi, DWORD PTR _pFormat$[esp+136]

; 345  : 	if(pFormat == NULL)

  00015	85 f6		 test	 esi, esi
  00017	57		 push	 edi
  00018	8b bc 24 94 00
	00 00		 mov	 edi, DWORD PTR ___$ReturnUdt$[esp+140]
  0001f	89 84 24 8c 00
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+144], eax
  00026	c7 44 24 08 00
	00 00 00	 mov	 DWORD PTR $T351666[esp+144], 0
  0002e	75 03		 jne	 SHORT $L43110

; 346  : 		return pFormat;

  00030	56		 push	 esi
  00031	eb 2f		 jmp	 SHORT $L351672
$L43110:

; 347  : 
; 348  : 	TCHAR szBuffer[maxTimeBufferSize];
; 349  : 
; 350  : 	struct tm* ptmTemp = _localtime64(&m_time);

  00033	51		 push	 ecx
  00034	e8 00 00 00 00	 call	 __localtime64
  00039	83 c4 04	 add	 esp, 4

; 351  : 	if (ptmTemp == NULL ||
; 352  : 		!_tcsftime(szBuffer, maxTimeBufferSize, pFormat, ptmTemp))

  0003c	85 c0		 test	 eax, eax
  0003e	74 18		 je	 SHORT $L43114
  00040	50		 push	 eax
  00041	56		 push	 esi
  00042	8d 44 24 14	 lea	 eax, DWORD PTR _szBuffer$[esp+152]
  00046	68 80 00 00 00	 push	 128			; 00000080H
  0004b	50		 push	 eax
  0004c	e8 00 00 00 00	 call	 _strftime
  00051	83 c4 10	 add	 esp, 16			; 00000010H
  00054	85 c0		 test	 eax, eax
  00056	75 05		 jne	 SHORT $L43113
$L43114:

; 353  : 		szBuffer[0] = '\0';

  00058	c6 44 24 0c 00	 mov	 BYTE PTR _szBuffer$[esp+144], 0
$L43113:

; 354  : 	return szBuffer;

  0005d	8d 4c 24 0c	 lea	 ecx, DWORD PTR _szBuffer$[esp+144]
  00061	51		 push	 ecx
$L351672:
  00062	8b cf		 mov	 ecx, edi
  00064	e8 00 00 00 00	 call	 ??0?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >

; 355  : }

  00069	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+144]
  00070	8b c7		 mov	 eax, edi
  00072	5f		 pop	 edi
  00073	5e		 pop	 esi
  00074	33 cc		 xor	 ecx, esp
  00076	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0007b	81 c4 88 00 00
	00		 add	 esp, 136		; 00000088H
  00081	c2 08 00	 ret	 8
?Format@CTime@ATL@@QBE?AV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@2@PBD@Z ENDP ; ATL::CTime::Format
_TEXT	ENDS
PUBLIC	?SetAllAction@CUser@@QAEXXZ			; CUser::SetAllAction
EXTRN	?IsMultiByte@@YAHPBD@Z:NEAR			; IsMultiByte
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlsimpstr.h
xdata$x	SEGMENT
$T351785 DD	0ffffffffH
	DD	FLAT:$L351676
	DD	00H
	DD	FLAT:$L351677
$T351779 DD	019930520H
	DD	02H
	DD	FLAT:$T351785
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
xdata$x	ENDS
;	COMDAT ?SetAllAction@CUser@@QAEXXZ
_TEXT	SEGMENT
_strGuildName$278038 = -20				; size = 4
_strName$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?SetAllAction@CUser@@QAEXXZ PROC NEAR			; CUser::SetAllAction, COMDAT
; _this$ = ecx

; 610  : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?SetAllAction@CUser@@QAEXXZ
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	83 ec 08	 sub	 esp, 8
  00018	56		 push	 esi
  00019	57		 push	 edi

; 611  : 	//          
; 612  : 	CString strName = GetName();

  0001a	33 ff		 xor	 edi, edi
  0001c	57		 push	 edi
  0001d	8b f1		 mov	 esi, ecx
  0001f	e8 00 00 00 00	 call	 ?GetName@CMover@@QAEPBDH@Z ; CMover::GetName
  00024	50		 push	 eax
  00025	8d 4c 24 10	 lea	 ecx, DWORD PTR _strName$[esp+32]
  00029	e8 00 00 00 00	 call	 ??0?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >

; 613  : 	LPCTSTR lpszString = strName;
; 614  : 	char c = strName[ 0 ];

  0002e	8b 4c 24 0c	 mov	 ecx, DWORD PTR _strName$[esp+28]
  00032	39 79 f4	 cmp	 DWORD PTR [ecx-12], edi
  00035	89 7c 24 18	 mov	 DWORD PTR __$EHRec$[esp+36], edi
  00039	7d 0a		 jge	 SHORT $L351692
  0003b	68 57 00 07 80	 push	 -2147024809		; 80070057H
  00040	e8 00 00 00 00	 call	 ?AtlThrow@ATL@@YGXJ@Z	; ATL::AtlThrow
$L351786:
$L351692:
  00045	8a 01		 mov	 al, BYTE PTR [ecx]

; 615  : 	BOOL bCharacter = FALSE;
; 616  : 	m_bAllAction = TRUE;
; 617  : 	if( ( c >= '0' && c <= '9' ) && !IsMultiByte( lpszString ) ) // "     ."

  00047	3c 30		 cmp	 al, 48			; 00000030H
  00049	c7 86 f8 95 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+38392], 1
  00053	7c 21		 jl	 SHORT $L351781
  00055	3c 39		 cmp	 al, 57			; 00000039H
  00057	7f 1d		 jg	 SHORT $L351781
  00059	51		 push	 ecx
  0005a	e8 00 00 00 00	 call	 ?IsMultiByte@@YAHPBD@Z	; IsMultiByte
  0005f	83 c4 04	 add	 esp, 4
  00062	85 c0		 test	 eax, eax
  00064	75 10		 jne	 SHORT $L351781

; 618  : 	{
; 619  : 		m_bAllAction = FALSE;

  00066	89 be f8 95 00
	00		 mov	 DWORD PTR [esi+38392], edi

; 620  : 		bCharacter = TRUE;

  0006c	bf 01 00 00 00	 mov	 edi, 1

; 621  : 	}
; 622  : 	//          
; 623  : 	else if( m_idGuild != 0 )

  00071	e9 8f 00 00 00	 jmp	 $L351782
$L351781:
  00076	8b 86 1c 07 00
	00		 mov	 eax, DWORD PTR [esi+1820]
  0007c	3b c7		 cmp	 eax, edi
  0007e	0f 84 81 00 00
	00		 je	 $L351782

; 624  : 	{
; 625  : 		CGuild* pGuild	= g_GuildMng.GetGuild( m_idGuild );

  00084	50		 push	 eax
  00085	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_GuildMng@@3VCGuildMng@@A
  0008a	e8 00 00 00 00	 call	 ?GetGuild@CGuildMng@@QAEPAVCGuild@@K@Z ; CGuildMng::GetGuild

; 626  : 		if( pGuild && pGuild->IsMaster( m_idPlayer ) )

  0008f	3b c7		 cmp	 eax, edi
  00091	74 72		 je	 SHORT $L351782
  00093	8b 48 44	 mov	 ecx, DWORD PTR [eax+68]
  00096	3b 8e 38 02 00
	00		 cmp	 ecx, DWORD PTR [esi+568]
  0009c	75 67		 jne	 SHORT $L351782

; 627  : 		{
; 628  : 			CString strGuildName = pGuild->m_szGuild;

  0009e	83 c0 08	 add	 eax, 8
  000a1	50		 push	 eax
  000a2	8d 4c 24 0c	 lea	 ecx, DWORD PTR _strGuildName$278038[esp+32]
  000a6	e8 00 00 00 00	 call	 ??0?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >

; 629  : 			LPCTSTR lpszGuildString = strGuildName;
; 630  : #ifdef _DEBUG
; 631  : 			if( !strGuildName.IsEmpty() )
; 632  : #endif // _DEBUG
; 633  : 			{
; 634  : 				c = strGuildName[ 0 ];

  000ab	8b 44 24 08	 mov	 eax, DWORD PTR _strGuildName$278038[esp+28]
  000af	39 78 f4	 cmp	 DWORD PTR [eax-12], edi
  000b2	c6 44 24 18 01	 mov	 BYTE PTR __$EHRec$[esp+36], 1
  000b7	7d 0a		 jge	 SHORT $L351717
  000b9	68 57 00 07 80	 push	 -2147024809		; 80070057H
  000be	e8 00 00 00 00	 call	 ?AtlThrow@ATL@@YGXJ@Z	; ATL::AtlThrow
$L351787:
$L351717:
  000c3	8a 08		 mov	 cl, BYTE PTR [eax]

; 635  : 				if( ( c >= '0' && c <= '9' ) && !IsMultiByte( lpszGuildString ) ) // "     ."

  000c5	80 f9 30	 cmp	 cl, 48			; 00000030H
  000c8	7c 1c		 jl	 SHORT $L278040
  000ca	80 f9 39	 cmp	 cl, 57			; 00000039H
  000cd	7f 17		 jg	 SHORT $L278040
  000cf	50		 push	 eax
  000d0	e8 00 00 00 00	 call	 ?IsMultiByte@@YAHPBD@Z	; IsMultiByte
  000d5	83 c4 04	 add	 esp, 4
  000d8	85 c0		 test	 eax, eax

; 636  : 					m_bAllAction = FALSE;

  000da	8b 44 24 08	 mov	 eax, DWORD PTR _strGuildName$278038[esp+28]
  000de	75 06		 jne	 SHORT $L278040
  000e0	89 be f8 95 00
	00		 mov	 DWORD PTR [esi+38392], edi
$L278040:

; 637  : 			}
; 638  : 		}

  000e6	83 c0 f0	 add	 eax, -16		; fffffff0H
  000e9	c6 44 24 18 00	 mov	 BYTE PTR __$EHRec$[esp+36], 0
  000ee	8d 50 0c	 lea	 edx, DWORD PTR [eax+12]
  000f1	83 c9 ff	 or	 ecx, -1
  000f4	f0 0f c1 0a	 lock	  xadd	 DWORD PTR [edx], ecx
  000f8	49		 dec	 ecx
  000f9	85 c9		 test	 ecx, ecx
  000fb	7f 08		 jg	 SHORT $L351782
  000fd	8b 08		 mov	 ecx, DWORD PTR [eax]
  000ff	8b 11		 mov	 edx, DWORD PTR [ecx]
  00101	50		 push	 eax
  00102	ff 52 04	 call	 DWORD PTR [edx+4]
$L351782:

; 639  : 	}
; 640  : 	AddAllAction( bCharacter );

  00105	57		 push	 edi
  00106	8b ce		 mov	 ecx, esi
  00108	e8 00 00 00 00	 call	 ?AddAllAction@CUser@@QAEXH@Z ; CUser::AddAllAction

; 641  : }

  0010d	8b 44 24 0c	 mov	 eax, DWORD PTR _strName$[esp+28]
  00111	83 c0 f0	 add	 eax, -16		; fffffff0H
  00114	c7 44 24 18 ff
	ff ff ff	 mov	 DWORD PTR __$EHRec$[esp+36], -1
  0011c	8d 48 0c	 lea	 ecx, DWORD PTR [eax+12]
  0011f	83 ca ff	 or	 edx, -1
  00122	f0 0f c1 11	 lock	  xadd	 DWORD PTR [ecx], edx
  00126	4a		 dec	 edx
  00127	85 d2		 test	 edx, edx
  00129	7f 08		 jg	 SHORT $L351775
  0012b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0012d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0012f	50		 push	 eax
  00130	ff 52 04	 call	 DWORD PTR [edx+4]
$L351775:
  00133	8b 4c 24 10	 mov	 ecx, DWORD PTR __$EHRec$[esp+28]
  00137	5f		 pop	 edi
  00138	5e		 pop	 esi
  00139	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00140	83 c4 14	 add	 esp, 20			; 00000014H
  00143	c3		 ret	 0
$L351784:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L351676:
  00000	8d 4d f0	 lea	 ecx, DWORD PTR _strName$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::~CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >
$L351677:
  00008	8d 4d ec	 lea	 ecx, DWORD PTR _strGuildName$278038[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::~CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >
__ehhandler$?SetAllAction@CUser@@QAEXXZ:
  00010	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T351779
  00015	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?SetAllAction@CUser@@QAEXXZ ENDP			; CUser::SetAllAction
PUBLIC	?RemoveUser@CUserMng@@QAEXK@Z			; CUserMng::RemoveUser
EXTRN	?OnTradeRemoveUser@CMover@@QAEXXZ:NEAR		; CMover::OnTradeRemoveUser
; Function compile flags: /Ogty
;	COMDAT ?RemoveUser@CUserMng@@QAEXK@Z
_TEXT	SEGMENT
_it$ = -4						; size = 4
$T351794 = 8						; size = 4
_dwSerial$ = 8						; size = 4
?RemoveUser@CUserMng@@QAEXK@Z PROC NEAR			; CUserMng::RemoveUser, COMDAT
; _this$ = ecx

; 3903 : {

  00000	51		 push	 ecx
  00001	53		 push	 ebx
  00002	55		 push	 ebp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 3904 : 	map<DWORD, CUser*>::iterator it = m_users.find( dwSerial );

  00006	8d 44 24 14	 lea	 eax, DWORD PTR _dwSerial$[esp+12]
  0000a	50		 push	 eax
  0000b	8d 4c 24 10	 lea	 ecx, DWORD PTR _it$[esp+20]
  0000f	8d 5e 08	 lea	 ebx, DWORD PTR [esi+8]
  00012	51		 push	 ecx
  00013	8b cb		 mov	 ecx, ebx
  00015	e8 00 00 00 00	 call	 ?find@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::find

; 3905 : 	if( it == m_users.end() )

  0001a	8b 6c 24 0c	 mov	 ebp, DWORD PTR _it$[esp+16]
  0001e	3b 6e 0c	 cmp	 ebp, DWORD PTR [esi+12]
  00021	74 2e		 je	 SHORT $L280097
  00023	57		 push	 edi

; 3906 : 		return;
; 3907 : 
; 3908 : 	CUser* pUser = it->second;

  00024	8b 7d 10	 mov	 edi, DWORD PTR [ebp+16]

; 3909 : 
; 3910 : 	if( IsValidObj( pUser ) ) 

  00027	85 ff		 test	 edi, edi
  00029	74 25		 je	 SHORT $L351851
  0002b	f6 47 04 01	 test	 BYTE PTR [edi+4], 1
  0002f	75 1f		 jne	 SHORT $L351851

; 3911 : 	{
; 3912 : 		pUser->OnTradeRemoveUser();

  00031	8b cf		 mov	 ecx, edi
  00033	e8 00 00 00 00	 call	 ?OnTradeRemoveUser@CMover@@QAEXXZ ; CMover::OnTradeRemoveUser

; 3913 : 
; 3914 : 		m_users.erase( it );

  00038	55		 push	 ebp
  00039	8d 54 24 1c	 lea	 edx, DWORD PTR $T351794[esp+20]
  0003d	52		 push	 edx
  0003e	8b cb		 mov	 ecx, ebx
  00040	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::erase

; 3915 : 		--m_lCount;

  00045	ff 4e 04	 dec	 DWORD PTR [esi+4]

; 3916 : 		RemoveUserFromCacheMsg( pUser );

  00048	57		 push	 edi
  00049	8b ce		 mov	 ecx, esi
  0004b	e8 00 00 00 00	 call	 ?RemoveUserFromCacheMsg@CUserMng@@AAEXPAVCUser@@@Z ; CUserMng::RemoveUserFromCacheMsg
$L351851:
  00050	5f		 pop	 edi
$L280097:
  00051	5e		 pop	 esi
  00052	5d		 pop	 ebp
  00053	5b		 pop	 ebx

; 3917 : 	}
; 3918 : }

  00054	59		 pop	 ecx
  00055	c2 04 00	 ret	 4
?RemoveUser@CUserMng@@QAEXK@Z ENDP			; CUserMng::RemoveUser
_TEXT	ENDS
PUBLIC	??_C@_06EDLOMNPN@?$CFd?7?$CFd?6?$AA@		; `string'
PUBLIC	??_C@_0L@MLCPHCKD@U?$DN?$CFd?0?5A?$DN?$CFd?$AA@	; `string'
PUBLIC	??_C@_0BO@DPEJLCAF@?4?4?1statistics?$CFY?$CFm?$CFd?$CFH?$CFM?$CFS?4txt?$AA@ ; `string'
PUBLIC	?OutputStatistics@CUserMng@@QAEXXZ		; CUserMng::OutputStatistics
EXTRN	?FILEOUT@@YAXPBD0ZZ:NEAR			; FILEOUT
EXTRN	__imp__lstrcatA@8:NEAR
;	COMDAT ?lpOutputString@?8??OutputStatistics@CUserMng@@QAEXXZ@4PADA
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlsimpstr.h
_BSS	SEGMENT
?lpOutputString@?8??OutputStatistics@CUserMng@@QAEXXZ@4PADA DB 01000H DUP (?) ; `CUserMng::OutputStatistics'::`9'::lpOutputString
_BSS	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
$T352031 DD	0ffffffffH
	DD	FLAT:$L351859
$T352023 DD	019930520H
	DD	01H
	DD	FLAT:$T352031
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_C@_06EDLOMNPN@?$CFd?7?$CFd?6?$AA@
CONST	SEGMENT
??_C@_06EDLOMNPN@?$CFd?7?$CFd?6?$AA@ DB '%d', 09H, '%d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@MLCPHCKD@U?$DN?$CFd?0?5A?$DN?$CFd?$AA@
CONST	SEGMENT
??_C@_0L@MLCPHCKD@U?$DN?$CFd?0?5A?$DN?$CFd?$AA@ DB 'U=%d, A=%d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@DPEJLCAF@?4?4?1statistics?$CFY?$CFm?$CFd?$CFH?$CFM?$CFS?4txt?$AA@
CONST	SEGMENT
??_C@_0BO@DPEJLCAF@?4?4?1statistics?$CFY?$CFm?$CFd?$CFH?$CFM?$CFS?4txt?$AA@ DB '.'
	DB	'./statistics%Y%m%d%H%M%S.txt', 00H		; `string'
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
CONST	ENDS
;	COMDAT ?OutputStatistics@CUserMng@@QAEXXZ
_TEXT	SEGMENT
$T351858 = -592						; size = 4
_it$ = -592						; size = 4
_nTotal$ = -588						; size = 4
_time$ = -584						; size = 8
_acbUser$ = -576					; size = 520
_lpOverview$283205 = -52				; size = 32
_lpString$283202 = -52					; size = 32
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
?OutputStatistics@CUserMng@@QAEXXZ PROC NEAR		; CUserMng::OutputStatistics, COMDAT
; _this$ = ecx

; 6628 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	6a ff		 push	 -1
  00008	68 00 00 00 00	 push	 __ehhandler$?OutputStatistics@CUserMng@@QAEXXZ
  0000d	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00013	50		 push	 eax
  00014	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0001b	81 ec 48 02 00
	00		 sub	 esp, 584		; 00000248H
  00021	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00026	53		 push	 ebx
  00027	33 c5		 xor	 eax, ebp
  00029	56		 push	 esi
  0002a	8b d1		 mov	 edx, ecx

; 6629 : #if __VER >= 10 // __LEGEND	//	10 	Neuz, World, Trans
; 6630 : 	int	acbUser[MAX_LEGEND_LEVEL];
; 6631 : 	
; 6632 : 	int cb	= 0;
; 6633 : 	int nTotal	= 0;
; 6634 : 
; 6635 : 	memset( acbUser, 0, sizeof(int) * MAX_LEGEND_LEVEL );
; 6636 : 
; 6637 : 	map<DWORD, CUser*>::iterator it;
; 6638 : 	for( it = m_users.begin(); it != m_users.end(); ++it )

  0002c	8b 72 0c	 mov	 esi, DWORD PTR [edx+12]
  0002f	89 84 24 48 02
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+604], eax
  00036	57		 push	 edi
  00037	33 c0		 xor	 eax, eax
  00039	b9 82 00 00 00	 mov	 ecx, 130		; 00000082H
  0003e	8d 7c 24 20	 lea	 edi, DWORD PTR _acbUser$[esp+608]
  00042	f3 ab		 rep stosd
  00044	8b 06		 mov	 eax, DWORD PTR [esi]
  00046	33 db		 xor	 ebx, ebx
  00048	3b c6		 cmp	 eax, esi
  0004a	89 5c 24 14	 mov	 DWORD PTR _nTotal$[esp+608], ebx
  0004e	89 44 24 10	 mov	 DWORD PTR _it$[esp+608], eax
  00052	74 4d		 je	 SHORT $L283191
$L351901:

; 6639 : 	{
; 6640 : 		CUser* pUser = it->second;

  00054	8b 40 10	 mov	 eax, DWORD PTR [eax+16]

; 6641 : 		if( pUser->IsValid() == FALSE )

  00057	f6 40 04 01	 test	 BYTE PTR [eax+4], 1
  0005b	75 33		 jne	 SHORT $L283190
  0005d	8b 88 e8 16 00
	00		 mov	 ecx, DWORD PTR [eax+5864]
  00063	85 c9		 test	 ecx, ecx
  00065	74 29		 je	 SHORT $L283190

; 6642 : 			continue;
; 6643 : 
; 6644 : 		if( pUser->GetLevel() >= 1 && pUser->GetLevel() <= MAX_LEGEND_LEVEL )

  00067	8b 88 e0 05 00
	00		 mov	 ecx, DWORD PTR [eax+1504]
  0006d	83 f9 01	 cmp	 ecx, 1
  00070	7c 1e		 jl	 SHORT $L283190
  00072	81 f9 82 00 00
	00		 cmp	 ecx, 130		; 00000082H
  00078	7f 16		 jg	 SHORT $L283190

; 6645 : 		{
; 6646 : 			acbUser[pUser->GetLevel() - 1]++;

  0007a	8b c1		 mov	 eax, ecx
  0007c	8b 7c 84 1c	 mov	 edi, DWORD PTR _acbUser$[esp+eax*4+604]

; 6647 : 			cb++;
; 6648 : 			nTotal	+= pUser->GetLevel();

  00080	8b 4c 24 14	 mov	 ecx, DWORD PTR _nTotal$[esp+608]
  00084	47		 inc	 edi
  00085	43		 inc	 ebx
  00086	03 c8		 add	 ecx, eax
  00088	89 7c 84 1c	 mov	 DWORD PTR _acbUser$[esp+eax*4+604], edi
  0008c	89 4c 24 14	 mov	 DWORD PTR _nTotal$[esp+608], ecx
$L283190:
  00090	8d 4c 24 10	 lea	 ecx, DWORD PTR _it$[esp+608]
  00094	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::const_iterator::_Inc
  00099	8b 44 24 10	 mov	 eax, DWORD PTR _it$[esp+608]
  0009d	3b c6		 cmp	 eax, esi
  0009f	75 b3		 jne	 SHORT $L351901
$L283191:

; 6649 : 		}
; 6650 : 	}
; 6651 : 
; 6652 : 	static char lpOutputString[4096];
; 6653 : 	*lpOutputString	= '\0';
; 6654 : 	for( int i = 0; i < MAX_LEGEND_LEVEL; i++ )

  000a1	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__lstrcatA@8
  000a7	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?lpOutputString@?8??OutputStatistics@CUserMng@@QAEXXZ@4PADA, 0
  000ae	33 f6		 xor	 esi, esi
$L283198:

; 6655 : 	{
; 6656 : 		if( acbUser[i] == 0 )

  000b0	8b 44 b4 20	 mov	 eax, DWORD PTR _acbUser$[esp+esi*4+608]
  000b4	85 c0		 test	 eax, eax
  000b6	74 73		 je	 SHORT $L283199

; 6657 : 			continue;
; 6658 : 		char lpString[32]	= { 0, };

  000b8	33 c9		 xor	 ecx, ecx
  000ba	89 8c 24 2d 02
	00 00		 mov	 DWORD PTR _lpString$283202[esp+609], ecx
  000c1	89 8c 24 31 02
	00 00		 mov	 DWORD PTR _lpString$283202[esp+613], ecx
  000c8	89 8c 24 35 02
	00 00		 mov	 DWORD PTR _lpString$283202[esp+617], ecx
  000cf	89 8c 24 39 02
	00 00		 mov	 DWORD PTR _lpString$283202[esp+621], ecx
  000d6	89 8c 24 3d 02
	00 00		 mov	 DWORD PTR _lpString$283202[esp+625], ecx

; 6659 : 		sprintf( lpString, "%d\t%d\n", i+1, acbUser[i] );

  000dd	50		 push	 eax
  000de	89 8c 24 45 02
	00 00		 mov	 DWORD PTR _lpString$283202[esp+633], ecx
  000e5	8d 56 01	 lea	 edx, DWORD PTR [esi+1]
  000e8	52		 push	 edx
  000e9	89 8c 24 4d 02
	00 00		 mov	 DWORD PTR _lpString$283202[esp+641], ecx
  000f0	8d 84 24 34 02
	00 00		 lea	 eax, DWORD PTR _lpString$283202[esp+616]
  000f7	66 89 8c 24 51
	02 00 00	 mov	 WORD PTR _lpString$283202[esp+645], cx
  000ff	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_06EDLOMNPN@?$CFd?7?$CFd?6?$AA@
  00104	50		 push	 eax
  00105	c6 84 24 3c 02
	00 00 00	 mov	 BYTE PTR _lpString$283202[esp+624], 0
  0010d	88 8c 24 5b 02
	00 00		 mov	 BYTE PTR _lpString$283202[esp+655], cl
  00114	e8 00 00 00 00	 call	 _sprintf
  00119	83 c4 10	 add	 esp, 16			; 00000010H

; 6660 : 		lstrcat( lpOutputString, lpString );

  0011c	8d 8c 24 2c 02
	00 00		 lea	 ecx, DWORD PTR _lpString$283202[esp+608]
  00123	51		 push	 ecx
  00124	68 00 00 00 00	 push	 OFFSET FLAT:?lpOutputString@?8??OutputStatistics@CUserMng@@QAEXXZ@4PADA
  00129	ff d7		 call	 edi
$L283199:
  0012b	46		 inc	 esi
  0012c	81 fe 82 00 00
	00		 cmp	 esi, 130		; 00000082H
  00132	0f 8c 78 ff ff
	ff		 jl	 $L283198

; 6661 : 	}
; 6662 : 
; 6663 : 	if( cb > 0 )

  00138	85 db		 test	 ebx, ebx
  0013a	7e 77		 jle	 SHORT $L283204

; 6664 : 	{
; 6665 : 		char lpOverview[32]	= { 0, };
; 6666 : 		sprintf( lpOverview, "U=%d, A=%d", cb, nTotal / cb );

  0013c	8b 44 24 14	 mov	 eax, DWORD PTR _nTotal$[esp+608]
  00140	33 d2		 xor	 edx, edx
  00142	89 94 24 2d 02
	00 00		 mov	 DWORD PTR _lpOverview$283205[esp+609], edx
  00149	89 94 24 31 02
	00 00		 mov	 DWORD PTR _lpOverview$283205[esp+613], edx
  00150	89 94 24 35 02
	00 00		 mov	 DWORD PTR _lpOverview$283205[esp+617], edx
  00157	89 94 24 39 02
	00 00		 mov	 DWORD PTR _lpOverview$283205[esp+621], edx
  0015e	89 94 24 3d 02
	00 00		 mov	 DWORD PTR _lpOverview$283205[esp+625], edx
  00165	89 94 24 41 02
	00 00		 mov	 DWORD PTR _lpOverview$283205[esp+629], edx
  0016c	89 94 24 45 02
	00 00		 mov	 DWORD PTR _lpOverview$283205[esp+633], edx
  00173	66 89 94 24 49
	02 00 00	 mov	 WORD PTR _lpOverview$283205[esp+637], dx
  0017b	88 94 24 4b 02
	00 00		 mov	 BYTE PTR _lpOverview$283205[esp+639], dl
  00182	99		 cdq
  00183	f7 fb		 idiv	 ebx
  00185	c6 84 24 2c 02
	00 00 00	 mov	 BYTE PTR _lpOverview$283205[esp+608], 0
  0018d	50		 push	 eax
  0018e	53		 push	 ebx
  0018f	8d 84 24 34 02
	00 00		 lea	 eax, DWORD PTR _lpOverview$283205[esp+616]
  00196	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0L@MLCPHCKD@U?$DN?$CFd?0?5A?$DN?$CFd?$AA@
  0019b	50		 push	 eax
  0019c	e8 00 00 00 00	 call	 _sprintf
  001a1	83 c4 10	 add	 esp, 16			; 00000010H

; 6667 : 		lstrcat( lpOutputString, lpOverview );

  001a4	8d 8c 24 2c 02
	00 00		 lea	 ecx, DWORD PTR _lpOverview$283205[esp+608]
  001ab	51		 push	 ecx
  001ac	68 00 00 00 00	 push	 OFFSET FLAT:?lpOutputString@?8??OutputStatistics@CUserMng@@QAEXXZ@4PADA
  001b1	ff d7		 call	 edi
$L283204:

; 6668 : 	}
; 6669 : 
; 6670 : 	CTime time	= CTime::GetCurrentTime();

  001b3	6a 00		 push	 0
  001b5	e8 00 00 00 00	 call	 __time64
  001ba	83 c4 04	 add	 esp, 4
  001bd	89 54 24 1c	 mov	 DWORD PTR _time$[esp+612], edx

; 6671 : 	FILEOUT( time.Format( "../statistics%Y%m%d%H%M%S.txt" ), lpOutputString );

  001c1	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BO@DPEJLCAF@?4?4?1statistics?$CFY?$CFm?$CFd?$CFH?$CFM?$CFS?4txt?$AA@
  001c6	8d 54 24 14	 lea	 edx, DWORD PTR $T351858[esp+612]
  001ca	52		 push	 edx
  001cb	8d 4c 24 20	 lea	 ecx, DWORD PTR _time$[esp+616]
  001cf	89 44 24 20	 mov	 DWORD PTR _time$[esp+616], eax
  001d3	e8 00 00 00 00	 call	 ?Format@CTime@ATL@@QBE?AV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@2@PBD@Z ; ATL::CTime::Format
  001d8	8b 00		 mov	 eax, DWORD PTR [eax]
  001da	68 00 00 00 00	 push	 OFFSET FLAT:?lpOutputString@?8??OutputStatistics@CUserMng@@QAEXXZ@4PADA
  001df	50		 push	 eax
  001e0	c7 84 24 64 02
	00 00 00 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+624], 0
  001eb	e8 00 00 00 00	 call	 ?FILEOUT@@YAXPBD0ZZ	; FILEOUT
  001f0	8b 44 24 18	 mov	 eax, DWORD PTR $T351858[esp+616]
  001f4	83 c0 f0	 add	 eax, -16		; fffffff0H
  001f7	83 c4 08	 add	 esp, 8
  001fa	c7 84 24 5c 02
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+616], -1
  00205	8d 48 0c	 lea	 ecx, DWORD PTR [eax+12]
  00208	83 ca ff	 or	 edx, -1
  0020b	f0 0f c1 11	 lock	  xadd	 DWORD PTR [ecx], edx
  0020f	4a		 dec	 edx
  00210	85 d2		 test	 edx, edx
  00212	7f 08		 jg	 SHORT $L352018
  00214	8b 08		 mov	 ecx, DWORD PTR [eax]
  00216	8b 11		 mov	 edx, DWORD PTR [ecx]
  00218	50		 push	 eax
  00219	ff 52 04	 call	 DWORD PTR [edx+4]
$L352018:

; 6672 : #else //__LEGEND	//	10 	Neuz, World, Trans
; 6673 : 
; 6674 : 	int	acbUser[MAX_GENERAL_LEVEL];
; 6675 : 	int cb	= 0;
; 6676 : 	int nTotal	= 0;
; 6677 : 
; 6678 : 	memset( acbUser, 0, sizeof(int) * MAX_GENERAL_LEVEL );
; 6679 : 
; 6680 : 	map<DWORD, CUser*>::iterator it;
; 6681 : 	for( it = m_users.begin(); it != m_users.end(); ++it )
; 6682 : 	{
; 6683 : 		CUser* pUser = it->second;
; 6684 : 		if( pUser->IsValid() == FALSE )
; 6685 : 			continue;
; 6686 : 
; 6687 : 		if( pUser->GetLevel() >= 1 && pUser->GetLevel() <= MAX_GENERAL_LEVEL )
; 6688 : 		{
; 6689 : 			acbUser[pUser->GetLevel() - 1]++;
; 6690 : 			cb++;
; 6691 : 			nTotal	+= pUser->GetLevel();
; 6692 : 		}
; 6693 : 	}
; 6694 : 
; 6695 : 	static char lpOutputString[4096];
; 6696 : 	*lpOutputString	= '\0';
; 6697 : 	for( int i = 0; i < MAX_GENERAL_LEVEL; i++ )
; 6698 : 	{
; 6699 : 		if( acbUser[i] == 0 )
; 6700 : 			continue;
; 6701 : 		char lpString[32]	= { 0, };
; 6702 : 		sprintf( lpString, "%d\t%d\n", i+1, acbUser[i] );
; 6703 : 		lstrcat( lpOutputString, lpString );
; 6704 : 	}
; 6705 : 
; 6706 : 	if( cb > 0 )
; 6707 : 	{
; 6708 : 		char lpOverview[32]	= { 0, };
; 6709 : 		sprintf( lpOverview, "U=%d, A=%d", cb, nTotal / cb );
; 6710 : 		lstrcat( lpOutputString, lpOverview );
; 6711 : 	}
; 6712 : 
; 6713 : 	CTime time	= CTime::GetCurrentTime();
; 6714 : 	FILEOUT( time.Format( "../statistics%Y%m%d%H%M%S.txt" ), lpOutputString );
; 6715 : #endif	//__LEGEND	//	10 	Neuz, World, Trans
; 6716 : 
; 6717 : }

  0021c	8b 8c 24 54 02
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+608]
  00223	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0022a	8b 8c 24 4c 02
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+608]
  00231	5f		 pop	 edi
  00232	5e		 pop	 esi
  00233	33 cd		 xor	 ecx, ebp
  00235	5b		 pop	 ebx
  00236	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0023b	8b e5		 mov	 esp, ebp
  0023d	5d		 pop	 ebp
  0023e	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L351859:
  00000	8d 8d b0 fd ff
	ff		 lea	 ecx, DWORD PTR $T351858[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::~CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >
__ehhandler$?OutputStatistics@CUserMng@@QAEXXZ:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T352023
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?OutputStatistics@CUserMng@@QAEXXZ ENDP			; CUserMng::OutputStatistics
PUBLIC	??4?$vector@KV?$allocator@K@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::operator=
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ??4?$vector@KV?$allocator@K@std@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??4?$vector@KV?$allocator@K@std@@@std@@QAEAAV01@ABV01@@Z PROC NEAR ; std::vector<unsigned long,std::allocator<unsigned long> >::operator=, COMDAT
; _this$ = ecx

; 392  : 		{	// assign _Right

  00000	56		 push	 esi
  00001	57		 push	 edi

; 393  : 		if (this != &_Right)

  00002	8b 7c 24 0c	 mov	 edi, DWORD PTR __Right$[esp+4]
  00006	8b f1		 mov	 esi, ecx
  00008	3b f7		 cmp	 esi, edi
  0000a	0f 84 2f 01 00
	00		 je	 $L352140
  00010	53		 push	 ebx

; 394  : 			{	// worth doing
; 395  : 
; 396  : 
; 397  : 			if (_Right.size() == 0)

  00011	8b 5f 04	 mov	 ebx, DWORD PTR [edi+4]
  00014	55		 push	 ebp
  00015	33 ed		 xor	 ebp, ebp
  00017	3b dd		 cmp	 ebx, ebp
  00019	74 0e		 je	 SHORT $L352138
  0001b	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  0001e	8b d0		 mov	 edx, eax
  00020	2b d3		 sub	 edx, ebx
  00022	c1 fa 02	 sar	 edx, 2
  00025	3b d5		 cmp	 edx, ebp
  00027	75 22		 jne	 SHORT $L285895
$L352138:

; 398  : 				clear();	// new sequence empty, free storage

  00029	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0002c	3b c5		 cmp	 eax, ebp
  0002e	74 09		 je	 SHORT $L352059
  00030	50		 push	 eax
  00031	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00036	83 c4 04	 add	 esp, 4
$L352059:
  00039	89 6e 04	 mov	 DWORD PTR [esi+4], ebp
  0003c	89 6e 08	 mov	 DWORD PTR [esi+8], ebp
  0003f	89 6e 0c	 mov	 DWORD PTR [esi+12], ebp
  00042	5d		 pop	 ebp
  00043	5b		 pop	 ebx
  00044	5f		 pop	 edi

; 422  : 				}
; 423  : 			}
; 424  : 		return (*this);

  00045	8b c6		 mov	 eax, esi
  00047	5e		 pop	 esi

; 425  : 		}

  00048	c2 04 00	 ret	 4
$L285895:

; 399  : 			else if (_Right.size() <= size())

  0004b	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0004e	3b cd		 cmp	 ecx, ebp
  00050	75 04		 jne	 SHORT $L352074
  00052	33 ed		 xor	 ebp, ebp
  00054	eb 08		 jmp	 SHORT $L352075
$L352074:
  00056	8b 6e 08	 mov	 ebp, DWORD PTR [esi+8]
  00059	2b e9		 sub	 ebp, ecx
  0005b	c1 fd 02	 sar	 ebp, 2
$L352075:
  0005e	3b d5		 cmp	 edx, ebp
  00060	77 48		 ja	 SHORT $L285897

; 400  : 				{	// enough elements, copy new and destroy old
; 401  : 				pointer _Ptr = copy(_Right._Myfirst, _Right._Mylast,
; 402  : 					_Myfirst);	// copy new

  00062	2b c3		 sub	 eax, ebx
  00064	c1 f8 02	 sar	 eax, 2
  00067	c1 e0 02	 shl	 eax, 2
  0006a	50		 push	 eax
  0006b	53		 push	 ebx
  0006c	51		 push	 ecx
  0006d	e8 00 00 00 00	 call	 _memmove

; 403  : 				_Destroy(_Ptr, _Mylast);	// destroy old
; 404  : 				_Mylast = _Myfirst + _Right.size();

  00072	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00075	83 c4 0c	 add	 esp, 12			; 0000000cH
  00078	85 c0		 test	 eax, eax
  0007a	75 14		 jne	 SHORT $L352103
  0007c	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0007f	5d		 pop	 ebp
  00080	33 ff		 xor	 edi, edi
  00082	8d 0c b8	 lea	 ecx, DWORD PTR [eax+edi*4]
  00085	5b		 pop	 ebx
  00086	5f		 pop	 edi
  00087	89 4e 08	 mov	 DWORD PTR [esi+8], ecx

; 422  : 				}
; 423  : 			}
; 424  : 		return (*this);

  0008a	8b c6		 mov	 eax, esi
  0008c	5e		 pop	 esi

; 425  : 		}

  0008d	c2 04 00	 ret	 4

; 403  : 				_Destroy(_Ptr, _Mylast);	// destroy old
; 404  : 				_Mylast = _Myfirst + _Right.size();

$L352103:
  00090	8b 7f 08	 mov	 edi, DWORD PTR [edi+8]
  00093	2b f8		 sub	 edi, eax
  00095	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00098	5d		 pop	 ebp
  00099	c1 ff 02	 sar	 edi, 2
  0009c	8d 0c b8	 lea	 ecx, DWORD PTR [eax+edi*4]
  0009f	5b		 pop	 ebx
  000a0	5f		 pop	 edi
  000a1	89 4e 08	 mov	 DWORD PTR [esi+8], ecx

; 422  : 				}
; 423  : 			}
; 424  : 		return (*this);

  000a4	8b c6		 mov	 eax, esi
  000a6	5e		 pop	 esi

; 425  : 		}

  000a7	c2 04 00	 ret	 4
$L285897:

; 405  : 				}
; 406  : 			else if (_Right.size() <= capacity())

  000aa	85 c9		 test	 ecx, ecx
  000ac	75 04		 jne	 SHORT $L352117
  000ae	33 c0		 xor	 eax, eax
  000b0	eb 08		 jmp	 SHORT $L352118
$L352117:
  000b2	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  000b5	2b c1		 sub	 eax, ecx
  000b7	c1 f8 02	 sar	 eax, 2
$L352118:
  000ba	3b d0		 cmp	 edx, eax
  000bc	77 3d		 ja	 SHORT $L285907

; 407  : 				{	// enough room, copy and construct new
; 408  : 				pointer _Ptr = _Right._Myfirst + size();

  000be	85 c9		 test	 ecx, ecx
  000c0	75 04		 jne	 SHORT $L352124
  000c2	33 c0		 xor	 eax, eax
  000c4	eb 08		 jmp	 SHORT $L352125
$L352124:
  000c6	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000c9	2b c1		 sub	 eax, ecx
  000cb	c1 f8 02	 sar	 eax, 2
$L352125:
  000ce	8b 57 04	 mov	 edx, DWORD PTR [edi+4]

; 409  : 				copy(_Right._Myfirst, _Ptr, _Myfirst);

  000d1	51		 push	 ecx
  000d2	8d 1c 82	 lea	 ebx, DWORD PTR [edx+eax*4]
  000d5	53		 push	 ebx
  000d6	52		 push	 edx
  000d7	e8 00 00 00 00	 call	 ??$copy@PAKPAK@std@@YAPAKPAK00@Z ; std::copy<unsigned long *,unsigned long *>

; 410  : 				_Mylast = _Ucopy(_Ptr, _Right._Mylast, _Mylast);

  000dc	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  000df	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  000e2	83 c4 0c	 add	 esp, 12			; 0000000cH
  000e5	52		 push	 edx
  000e6	50		 push	 eax
  000e7	53		 push	 ebx
  000e8	8b ce		 mov	 ecx, esi
  000ea	e8 00 00 00 00	 call	 ??$_Ucopy@PAK@?$vector@KV?$allocator@K@std@@@std@@IAEPAKPAK00@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::_Ucopy<unsigned long *>
  000ef	5d		 pop	 ebp
  000f0	5b		 pop	 ebx
  000f1	89 46 08	 mov	 DWORD PTR [esi+8], eax
  000f4	5f		 pop	 edi

; 422  : 				}
; 423  : 			}
; 424  : 		return (*this);

  000f5	8b c6		 mov	 eax, esi
  000f7	5e		 pop	 esi

; 425  : 		}

  000f8	c2 04 00	 ret	 4
$L285907:

; 411  : 				}
; 412  : 			else
; 413  : 				{	// not enough room, allocate new array and construct new
; 414  : 				if (_Myfirst != 0)

  000fb	85 c9		 test	 ecx, ecx
  000fd	74 09		 je	 SHORT $L352127

; 415  : 					{	// discard old array
; 416  : 					_Destroy(_Myfirst, _Mylast);
; 417  : 					this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

  000ff	51		 push	 ecx
  00100	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00105	83 c4 04	 add	 esp, 4
$L352127:

; 418  : 					}
; 419  : 				if (_Buy(_Right.size()))

  00108	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  0010b	85 c9		 test	 ecx, ecx
  0010d	75 04		 jne	 SHORT $L352136
  0010f	33 c0		 xor	 eax, eax
  00111	eb 08		 jmp	 SHORT $L352137
$L352136:
  00113	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  00116	2b c1		 sub	 eax, ecx
  00118	c1 f8 02	 sar	 eax, 2
$L352137:
  0011b	50		 push	 eax
  0011c	8b ce		 mov	 ecx, esi
  0011e	e8 00 00 00 00	 call	 ?_Buy@?$vector@KV?$allocator@K@std@@@std@@IAE_NI@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::_Buy
  00123	84 c0		 test	 al, al
  00125	74 16		 je	 SHORT $L352139

; 420  : 					_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 421  : 						_Myfirst);

  00127	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0012a	8b 57 08	 mov	 edx, DWORD PTR [edi+8]
  0012d	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00130	51		 push	 ecx
  00131	52		 push	 edx
  00132	50		 push	 eax
  00133	8b ce		 mov	 ecx, esi
  00135	e8 00 00 00 00	 call	 ??$_Ucopy@PAK@?$vector@KV?$allocator@K@std@@@std@@IAEPAKPAK00@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::_Ucopy<unsigned long *>
  0013a	89 46 08	 mov	 DWORD PTR [esi+8], eax
$L352139:
  0013d	5d		 pop	 ebp
  0013e	5b		 pop	 ebx
$L352140:
  0013f	5f		 pop	 edi

; 422  : 				}
; 423  : 			}
; 424  : 		return (*this);

  00140	8b c6		 mov	 eax, esi
  00142	5e		 pop	 esi

; 425  : 		}

  00143	c2 04 00	 ret	 4
??4?$vector@KV?$allocator@K@std@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::vector<unsigned long,std::allocator<unsigned long> >::operator=
_TEXT	ENDS
PUBLIC	?_Tidy@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Tidy
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ?_Tidy@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
$T352149 = -4						; size = 4
?_Tidy@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@IAEXXZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Tidy, COMDAT
; _this$ = ecx

; 1142 : 		{	// free all storage

  00000	51		 push	 ecx
  00001	56		 push	 esi
  00002	8b f1		 mov	 esi, ecx

; 1143 : 		erase(begin(), end());

  00004	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00007	8b 08		 mov	 ecx, DWORD PTR [eax]
  00009	50		 push	 eax
  0000a	51		 push	 ecx
  0000b	8d 44 24 0c	 lea	 eax, DWORD PTR $T352149[esp+16]
  0000f	50		 push	 eax
  00010	8b ce		 mov	 ecx, esi
  00012	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::erase

; 1144 : 		this->_Alptr.destroy(&_Left(_Myhead));
; 1145 : 		this->_Alptr.destroy(&_Parent(_Myhead));
; 1146 : 		this->_Alptr.destroy(&_Right(_Myhead));
; 1147 : 		this->_Alnod.deallocate(_Myhead, 1);

  00017	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0001a	51		 push	 ecx
  0001b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00020	83 c4 04	 add	 esp, 4

; 1148 : 		_Myhead = 0, _Mysize = 0;

  00023	33 c0		 xor	 eax, eax
  00025	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00028	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0002b	5e		 pop	 esi

; 1149 : 		}

  0002c	59		 pop	 ecx
  0002d	c3		 ret	 0
?_Tidy@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Tidy
_TEXT	ENDS
PUBLIC	?_Tidy@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::_Tidy
; Function compile flags: /Ogty
;	COMDAT ?_Tidy@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
$T352214 = -4						; size = 4
?_Tidy@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@IAEXXZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::_Tidy, COMDAT
; _this$ = ecx

; 1142 : 		{	// free all storage

  00000	51		 push	 ecx
  00001	56		 push	 esi
  00002	8b f1		 mov	 esi, ecx

; 1143 : 		erase(begin(), end());

  00004	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00007	8b 08		 mov	 ecx, DWORD PTR [eax]
  00009	50		 push	 eax
  0000a	51		 push	 ecx
  0000b	8d 44 24 0c	 lea	 eax, DWORD PTR $T352214[esp+16]
  0000f	50		 push	 eax
  00010	8b ce		 mov	 ecx, esi
  00012	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::erase

; 1144 : 		this->_Alptr.destroy(&_Left(_Myhead));
; 1145 : 		this->_Alptr.destroy(&_Parent(_Myhead));
; 1146 : 		this->_Alptr.destroy(&_Right(_Myhead));
; 1147 : 		this->_Alnod.deallocate(_Myhead, 1);

  00017	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0001a	51		 push	 ecx
  0001b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00020	83 c4 04	 add	 esp, 4

; 1148 : 		_Myhead = 0, _Mysize = 0;

  00023	33 c0		 xor	 eax, eax
  00025	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00028	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0002b	5e		 pop	 esi

; 1149 : 		}

  0002c	59		 pop	 ecx
  0002d	c3		 ret	 0
?_Tidy@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::_Tidy
_TEXT	ENDS
PUBLIC	?insert@?$vector@KV?$allocator@K@std@@@std@@QAE?AViterator@12@V312@ABK@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::insert
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ?insert@?$vector@KV?$allocator@K@std@@@std@@QAE?AViterator@12@V312@ABK@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@KV?$allocator@K@std@@@std@@QAE?AViterator@12@V312@ABK@Z PROC NEAR ; std::vector<unsigned long,std::allocator<unsigned long> >::insert, COMDAT
; _this$ = ecx

; 621  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

  00000	8b 54 24 08	 mov	 edx, DWORD PTR __Where$[esp-4]
  00004	56		 push	 esi
  00005	57		 push	 edi
  00006	8b f9		 mov	 edi, ecx
  00008	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  0000b	85 c9		 test	 ecx, ecx
  0000d	74 0c		 je	 SHORT $L352339
  0000f	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  00012	2b c1		 sub	 eax, ecx
  00014	c1 f8 02	 sar	 eax, 2
  00017	85 c0		 test	 eax, eax
  00019	75 04		 jne	 SHORT $L352278
$L352339:
  0001b	33 f6		 xor	 esi, esi
  0001d	eb 07		 jmp	 SHORT $L352279
$L352278:
  0001f	8b f2		 mov	 esi, edx
  00021	2b f1		 sub	 esi, ecx
  00023	c1 fe 02	 sar	 esi, 2
$L352279:

; 622  : 		_Insert_n(_Where, (size_type)1, _Val);

  00026	8b 44 24 14	 mov	 eax, DWORD PTR __Val$[esp+4]
  0002a	50		 push	 eax
  0002b	6a 01		 push	 1
  0002d	52		 push	 edx
  0002e	8b cf		 mov	 ecx, edi
  00030	e8 00 00 00 00	 call	 ?_Insert_n@?$vector@KV?$allocator@K@std@@@std@@IAEXViterator@12@IABK@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::_Insert_n

; 623  : 		return (begin() + _Off);

  00035	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  00038	8b 44 24 0c	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp+4]
  0003c	8d 14 b1	 lea	 edx, DWORD PTR [ecx+esi*4]
  0003f	5f		 pop	 edi
  00040	89 10		 mov	 DWORD PTR [eax], edx
  00042	5e		 pop	 esi

; 624  : 		}

  00043	c2 0c 00	 ret	 12			; 0000000cH
?insert@?$vector@KV?$allocator@K@std@@@std@@QAE?AViterator@12@V312@ABK@Z ENDP ; std::vector<unsigned long,std::allocator<unsigned long> >::insert
_TEXT	ENDS
PUBLIC	?_Insert@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAEXViterator@12@ABQAU__JOINPLAYER@CGuildCombat@@@Z ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Insert
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\list
;	COMDAT ?_Insert@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAEXViterator@12@ABQAU__JOINPLAYER@CGuildCombat@@@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 4
__Val$ = 12						; size = 4
?_Insert@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAEXViterator@12@ABQAU__JOINPLAYER@CGuildCombat@@@Z PROC NEAR ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Insert, COMDAT
; _this$ = ecx

; 522  : 		_Nodeptr _Pnode = _Where._Mynode();
; 523  : 		_Nodeptr _Newnode = _Buynode(_Pnode, _Prevnode(_Pnode), _Val);

  00000	8b 44 24 08	 mov	 eax, DWORD PTR __Val$[esp-4]
  00004	53		 push	 ebx
  00005	8b 5c 24 08	 mov	 ebx, DWORD PTR __Where$[esp]
  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	8b f9		 mov	 edi, ecx
  0000d	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	53		 push	 ebx
  00013	8b cf		 mov	 ecx, edi
  00015	e8 00 00 00 00	 call	 ?_Buynode@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAEPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@PAU342@0ABQAU__JOINPLAYER@CGuildCombat@@@Z ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Buynode

; 524  : 		_Incsize(1);

  0001a	6a 01		 push	 1
  0001c	8b cf		 mov	 ecx, edi
  0001e	8b f0		 mov	 esi, eax
  00020	e8 00 00 00 00	 call	 ?_Incsize@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAEXI@Z ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Incsize

; 525  : 		_Prevnode(_Pnode) = _Newnode;

  00025	89 73 04	 mov	 DWORD PTR [ebx+4], esi

; 526  : 		_Nextnode(_Prevnode(_Newnode)) = _Newnode;

  00028	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0002b	5f		 pop	 edi
  0002c	89 32		 mov	 DWORD PTR [edx], esi
  0002e	5e		 pop	 esi
  0002f	5b		 pop	 ebx

; 527  : 		}

  00030	c2 08 00	 ret	 8
?_Insert@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAEXViterator@12@ABQAU__JOINPLAYER@CGuildCombat@@@Z ENDP ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Insert
_TEXT	ENDS
PUBLIC	?_Insert@?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@QAEXViterator@12@ABQAVCUser@@@Z ; std::list<CUser *,std::allocator<CUser *> >::_Insert
; Function compile flags: /Ogty
;	COMDAT ?_Insert@?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@QAEXViterator@12@ABQAVCUser@@@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 4
__Val$ = 12						; size = 4
?_Insert@?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@QAEXViterator@12@ABQAVCUser@@@Z PROC NEAR ; std::list<CUser *,std::allocator<CUser *> >::_Insert, COMDAT
; _this$ = ecx

; 522  : 		_Nodeptr _Pnode = _Where._Mynode();
; 523  : 		_Nodeptr _Newnode = _Buynode(_Pnode, _Prevnode(_Pnode), _Val);

  00000	8b 44 24 08	 mov	 eax, DWORD PTR __Val$[esp-4]
  00004	53		 push	 ebx
  00005	8b 5c 24 08	 mov	 ebx, DWORD PTR __Where$[esp]
  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	8b f9		 mov	 edi, ecx
  0000d	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	53		 push	 ebx
  00013	8b cf		 mov	 ecx, edi
  00015	e8 00 00 00 00	 call	 ?_Buynode@?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@IAEPAU_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@2@PAU342@0ABQAVCUser@@@Z ; std::list<CUser *,std::allocator<CUser *> >::_Buynode

; 524  : 		_Incsize(1);

  0001a	6a 01		 push	 1
  0001c	8b cf		 mov	 ecx, edi
  0001e	8b f0		 mov	 esi, eax
  00020	e8 00 00 00 00	 call	 ?_Incsize@?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@IAEXI@Z ; std::list<CUser *,std::allocator<CUser *> >::_Incsize

; 525  : 		_Prevnode(_Pnode) = _Newnode;

  00025	89 73 04	 mov	 DWORD PTR [ebx+4], esi

; 526  : 		_Nextnode(_Prevnode(_Newnode)) = _Newnode;

  00028	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0002b	5f		 pop	 edi
  0002c	89 32		 mov	 DWORD PTR [edx], esi
  0002e	5e		 pop	 esi
  0002f	5b		 pop	 ebx

; 527  : 		}

  00030	c2 08 00	 ret	 8
?_Insert@?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@QAEXViterator@12@ABQAVCUser@@@Z ENDP ; std::list<CUser *,std::allocator<CUser *> >::_Insert
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@IAE_NI@Z ; std::vector<__ITEMINFO,std::allocator<__ITEMINFO> >::_Buy
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ?_Buy@?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@IAE_NI@Z PROC NEAR ; std::vector<__ITEMINFO,std::allocator<__ITEMINFO> >::_Buy, COMDAT
; _this$ = ecx

; 771  : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;
; 772  : 		if (_Capacity == 0)

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Capacity$[esp-4]
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx
  00007	33 c9		 xor	 ecx, ecx
  00009	3b c1		 cmp	 eax, ecx
  0000b	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  0000e	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  00011	89 4e 0c	 mov	 DWORD PTR [esi+12], ecx
  00014	75 06		 jne	 SHORT $L289308

; 773  : 			return (false);

  00016	32 c0		 xor	 al, al
  00018	5e		 pop	 esi

; 783  : 		}

  00019	c2 04 00	 ret	 4
$L289308:

; 774  : 		else if (max_size() < _Capacity)

  0001c	3d 55 55 55 15	 cmp	 eax, 357913941		; 15555555H
  00021	76 07		 jbe	 SHORT $L289310

; 775  : 			_Xlen();	// result too long

  00023	8b ce		 mov	 ecx, esi
  00025	e8 00 00 00 00	 call	 ?_Xlen@?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@IBEXXZ ; std::vector<__ITEMINFO,std::allocator<__ITEMINFO> >::_Xlen
$L352406:
$L289310:
  0002a	57		 push	 edi

; 776  : 		else
; 777  : 			{	// nonempty array, allocate storage
; 778  : 			_Myfirst = this->_Alval.allocate(_Capacity);

  0002b	8d 3c 40	 lea	 edi, DWORD PTR [eax+eax*2]
  0002e	c1 e7 02	 shl	 edi, 2
  00031	57		 push	 edi
  00032	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 779  : 			_Mylast = _Myfirst;
; 780  : 			_Myend = _Myfirst + _Capacity;

  00037	03 f8		 add	 edi, eax
  00039	83 c4 04	 add	 esp, 4
  0003c	89 7e 0c	 mov	 DWORD PTR [esi+12], edi
  0003f	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00042	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00045	5f		 pop	 edi

; 781  : 			}
; 782  : 		return (true);

  00046	b0 01		 mov	 al, 1
  00048	5e		 pop	 esi

; 783  : 		}

  00049	c2 04 00	 ret	 4
$L352405:
?_Buy@?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<__ITEMINFO,std::allocator<__ITEMINFO> >::_Buy
_TEXT	ENDS
PUBLIC	?_Insert_n@?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@IAEXViterator@12@IABU__ITEMINFO@@@Z ; std::vector<__ITEMINFO,std::allocator<__ITEMINFO> >::_Insert_n
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xutility
xdata$x	SEGMENT
$T352635 DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
$T352637 DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L352413
$T352638 DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L352415
$T352636 DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:$T352637
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:$T352638
$T352632 DD	019930520H
	DD	04H
	DD	FLAT:$T352635
	DD	02H
	DD	FLAT:$T352636
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@IAEXViterator@12@IABU__ITEMINFO@@@Z
_TEXT	SEGMENT
__Tmp$ = -28						; size = 12
__$EHRec$ = -16						; size = 16
tv427 = 8						; size = 4
tv414 = 8						; size = 4
__Cat$352628 = 8					; size = 1
__Cat$352614 = 8					; size = 1
__Cat$352590 = 8					; size = 1
__Cat$352551 = 8					; size = 1
__Cat$352527 = 8					; size = 1
__Cat$352505 = 8					; size = 1
__Where$ = 8						; size = 4
tv220 = 12						; size = 4
__Count$ = 12						; size = 4
tv398 = 16						; size = 4
__Newvec$290526 = 16					; size = 4
__Val$ = 16						; size = 4
?_Insert_n@?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@IAEXViterator@12@IABU__ITEMINFO@@@Z PROC NEAR ; std::vector<__ITEMINFO,std::allocator<__ITEMINFO> >::_Insert_n, COMDAT
; _this$ = ecx

; 809  : 		{	// insert _Count * _Val at _Where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Insert_n@?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@IAEXViterator@12@IABU__ITEMINFO@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 10	 sub	 esp, 16			; 00000010H

; 810  : 		_Ty _Tmp = _Val;	// in case _Val is in sequence

  0001b	8b 45 10	 mov	 eax, DWORD PTR __Val$[ebp]
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	8b f1		 mov	 esi, ecx
  00022	8b 08		 mov	 ecx, DWORD PTR [eax]
  00024	8b 50 04	 mov	 edx, DWORD PTR [eax+4]

; 811  : 		size_type _Capacity = capacity();

  00027	8b 5e 04	 mov	 ebx, DWORD PTR [esi+4]
  0002a	85 db		 test	 ebx, ebx
  0002c	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0002f	57		 push	 edi
  00030	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00033	89 4d e4	 mov	 DWORD PTR __Tmp$[ebp], ecx
  00036	89 55 e8	 mov	 DWORD PTR __Tmp$[ebp+4], edx
  00039	89 45 ec	 mov	 DWORD PTR __Tmp$[ebp+8], eax
  0003c	75 04		 jne	 SHORT $L352420
  0003e	33 c9		 xor	 ecx, ecx
  00040	eb 15		 jmp	 SHORT $L352421
$L352420:
  00042	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  00045	2b cb		 sub	 ecx, ebx
  00047	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0004c	f7 e9		 imul	 ecx
  0004e	d1 fa		 sar	 edx, 1
  00050	8b ca		 mov	 ecx, edx
  00052	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  00055	03 ca		 add	 ecx, edx
$L352421:

; 812  : 
; 813  : 		if (_Count == 0)

  00057	8b 7d 0c	 mov	 edi, DWORD PTR __Count$[ebp]
  0005a	85 ff		 test	 edi, edi
  0005c	0f 84 3c 02 00
	00		 je	 $L290546

; 814  : 			;
; 815  : 		else if (max_size() - size() < _Count)

  00062	85 db		 test	 ebx, ebx
  00064	75 04		 jne	 SHORT $L352443
  00066	33 c0		 xor	 eax, eax
  00068	eb 15		 jmp	 SHORT $L352444
$L352443:
  0006a	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0006d	2b d3		 sub	 edx, ebx
  0006f	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00074	f7 ea		 imul	 edx
  00076	d1 fa		 sar	 edx, 1
  00078	8b c2		 mov	 eax, edx
  0007a	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0007d	03 c2		 add	 eax, edx
$L352444:
  0007f	ba 55 55 55 15	 mov	 edx, 357913941		; 15555555H
  00084	2b d0		 sub	 edx, eax
  00086	3b d7		 cmp	 edx, edi
  00088	73 07		 jae	 SHORT $L290522

; 816  : 			_Xlen();	// result too long

  0008a	8b ce		 mov	 ecx, esi
  0008c	e8 00 00 00 00	 call	 ?_Xlen@?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@IBEXXZ ; std::vector<__ITEMINFO,std::allocator<__ITEMINFO> >::_Xlen
$L352639:
$L290522:

; 817  : 		else if (_Capacity < size() + _Count)

  00091	85 db		 test	 ebx, ebx
  00093	75 04		 jne	 SHORT $L352450
  00095	33 c0		 xor	 eax, eax
  00097	eb 15		 jmp	 SHORT $L352451
$L352450:
  00099	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0009c	2b d3		 sub	 edx, ebx
  0009e	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  000a3	f7 ea		 imul	 edx
  000a5	d1 fa		 sar	 edx, 1
  000a7	8b c2		 mov	 eax, edx
  000a9	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  000ac	03 c2		 add	 eax, edx
$L352451:
  000ae	03 c7		 add	 eax, edi
  000b0	3b c8		 cmp	 ecx, eax
  000b2	0f 83 0e 01 00
	00		 jae	 $L290524

; 818  : 			{	// not enough room, reallocate
; 819  : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 820  : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  000b8	8b c1		 mov	 eax, ecx
  000ba	d1 e8		 shr	 eax, 1
  000bc	ba 55 55 55 15	 mov	 edx, 357913941		; 15555555H
  000c1	2b d0		 sub	 edx, eax
  000c3	3b d1		 cmp	 edx, ecx
  000c5	73 04		 jae	 SHORT $L352410
  000c7	33 c9		 xor	 ecx, ecx
  000c9	eb 02		 jmp	 SHORT $L352411
$L352410:
  000cb	03 c8		 add	 ecx, eax
$L352411:

; 821  : 			if (_Capacity < size() + _Count)

  000cd	85 db		 test	 ebx, ebx
  000cf	75 04		 jne	 SHORT $L352473
  000d1	33 c0		 xor	 eax, eax
  000d3	eb 15		 jmp	 SHORT $L352474
$L352473:
  000d5	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  000d8	2b d3		 sub	 edx, ebx
  000da	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  000df	f7 ea		 imul	 edx
  000e1	d1 fa		 sar	 edx, 1
  000e3	8b c2		 mov	 eax, edx
  000e5	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  000e8	03 c2		 add	 eax, edx
$L352474:
  000ea	03 c7		 add	 eax, edi
  000ec	3b c8		 cmp	 ecx, eax
  000ee	73 0b		 jae	 SHORT $L290525

; 822  : 				_Capacity = size() + _Count;

  000f0	8b ce		 mov	 ecx, esi
  000f2	e8 00 00 00 00	 call	 ?size@?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@QBEIXZ ; std::vector<__ITEMINFO,std::allocator<__ITEMINFO> >::size
  000f7	8b c8		 mov	 ecx, eax
  000f9	03 cf		 add	 ecx, edi
$L290525:

; 823  : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

  000fb	8d 1c 49	 lea	 ebx, DWORD PTR [ecx+ecx*2]
  000fe	c1 e3 02	 shl	 ebx, 2
  00101	53		 push	 ebx
  00102	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 824  : 			pointer _Ptr = _Newvec;
; 825  : 
; 826  : 			_TRY_BEGIN
; 827  : 			_Ptr = _Ucopy(_Myfirst, _ITER_BASE(_Where),
; 828  : 				_Newvec);	// copy prefix

  00107	8b 55 08	 mov	 edx, DWORD PTR __Cat$352505[ebp]
  0010a	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0010d	52		 push	 edx
  0010e	56		 push	 esi
  0010f	50		 push	 eax
  00110	89 45 10	 mov	 DWORD PTR __Newvec$290526[ebp], eax
  00113	8b 45 08	 mov	 eax, DWORD PTR __Where$[ebp]
  00116	50		 push	 eax
  00117	51		 push	 ecx
  00118	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  0011f	e8 00 00 00 00	 call	 ??$_Uninit_copy@PAU__ITEMINFO@@PAU1@V?$allocator@U__ITEMINFO@@@std@@@std@@YAPAU__ITEMINFO@@PAU1@00AAV?$allocator@U__ITEMINFO@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<__ITEMINFO *,__ITEMINFO *,std::allocator<__ITEMINFO> >

; 829  : 			_Ptr = _Ufill(_Ptr, _Count, _Tmp);	// add new stuff

  00124	8b 4d 08	 mov	 ecx, DWORD PTR __Cat$352527[ebp]
  00127	83 c4 18	 add	 esp, 24			; 00000018H
  0012a	51		 push	 ecx
  0012b	56		 push	 esi
  0012c	8d 55 e4	 lea	 edx, DWORD PTR __Tmp$[ebp]
  0012f	52		 push	 edx
  00130	57		 push	 edi
  00131	50		 push	 eax
  00132	89 45 0c	 mov	 DWORD PTR tv220[ebp], eax
  00135	e8 00 00 00 00	 call	 ??$_Uninit_fill_n@PAU__ITEMINFO@@IU1@V?$allocator@U__ITEMINFO@@@std@@@std@@YAXPAU__ITEMINFO@@IABU1@AAV?$allocator@U__ITEMINFO@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<__ITEMINFO *,unsigned int,__ITEMINFO,std::allocator<__ITEMINFO> >

; 830  : 			_Ucopy(_ITER_BASE(_Where), _Mylast, _Ptr);	// copy suffix

  0013a	8b 55 08	 mov	 edx, DWORD PTR __Cat$352551[ebp]
  0013d	8b 4d 0c	 mov	 ecx, DWORD PTR tv220[ebp]
  00140	83 c4 14	 add	 esp, 20			; 00000014H
  00143	52		 push	 edx
  00144	8d 04 7f	 lea	 eax, DWORD PTR [edi+edi*2]
  00147	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  0014a	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0014d	56		 push	 esi
  0014e	50		 push	 eax
  0014f	8b 45 08	 mov	 eax, DWORD PTR __Where$[ebp]
  00152	51		 push	 ecx
  00153	50		 push	 eax
  00154	e8 00 00 00 00	 call	 ??$_Uninit_copy@PAU__ITEMINFO@@PAU1@V?$allocator@U__ITEMINFO@@@std@@@std@@YAPAU__ITEMINFO@@PAU1@00AAV?$allocator@U__ITEMINFO@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<__ITEMINFO *,__ITEMINFO *,std::allocator<__ITEMINFO> >

; 835  : 			_CATCH_END
; 836  : 
; 837  : 			_Count += size();

  00159	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0015c	83 c4 14	 add	 esp, 20			; 00000014H
  0015f	85 c0		 test	 eax, eax
  00161	74 15		 je	 SHORT $L352562
$L352561:
  00163	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00166	2b c8		 sub	 ecx, eax
  00168	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0016d	f7 e9		 imul	 ecx
  0016f	d1 fa		 sar	 edx, 1
  00171	8b c2		 mov	 eax, edx
  00173	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00176	03 c2		 add	 eax, edx
$L352562:
  00178	03 f8		 add	 edi, eax

; 838  : 			if (_Myfirst != 0)

  0017a	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0017d	85 c0		 test	 eax, eax
  0017f	74 09		 je	 SHORT $L352566

; 839  : 				{	// destroy and deallocate old array
; 840  : 				_Destroy(_Myfirst, _Mylast);
; 841  : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

  00181	50		 push	 eax
  00182	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00187	83 c4 04	 add	 esp, 4
$L352566:

; 842  : 				}
; 843  : 			_Myend = _Newvec + _Capacity;

  0018a	8b 45 10	 mov	 eax, DWORD PTR __Newvec$290526[ebp]

; 844  : 			_Mylast = _Newvec + _Count;

  0018d	8d 0c 7f	 lea	 ecx, DWORD PTR [edi+edi*2]
  00190	03 d8		 add	 ebx, eax
  00192	8d 14 88	 lea	 edx, DWORD PTR [eax+ecx*4]
  00195	89 5e 0c	 mov	 DWORD PTR [esi+12], ebx
  00198	89 56 08	 mov	 DWORD PTR [esi+8], edx

; 845  : 			_Myfirst = _Newvec;

  0019b	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 873  : 			}
; 874  : 		}

  0019e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  001a1	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  001a8	5f		 pop	 edi
  001a9	5e		 pop	 esi
  001aa	5b		 pop	 ebx
  001ab	8b e5		 mov	 esp, ebp
  001ad	5d		 pop	 ebp
  001ae	c2 0c 00	 ret	 12			; 0000000cH
$L352413:

; 831  : 			_CATCH_ALL
; 832  : 			_Destroy(_Newvec, _Ptr);
; 833  : 			this->_Alval.deallocate(_Newvec, _Capacity);

  001b1	8b 45 10	 mov	 eax, DWORD PTR __Newvec$290526[ebp]
  001b4	50		 push	 eax
  001b5	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  001ba	83 c4 04	 add	 esp, 4
$L352415:

; 834  : 			_RERAISE;

  001bd	6a 00		 push	 0
  001bf	6a 00		 push	 0
  001c1	e8 00 00 00 00	 call	 __CxxThrowException@8
$L352640:
$L290524:

; 846  : 			}
; 847  : 		else if ((size_type)(_Mylast - _ITER_BASE(_Where)) < _Count)

  001c6	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  001c9	8b 5d 08	 mov	 ebx, DWORD PTR __Where$[ebp]
  001cc	8b d1		 mov	 edx, ecx
  001ce	2b d3		 sub	 edx, ebx
  001d0	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  001d5	f7 ea		 imul	 edx
  001d7	d1 fa		 sar	 edx, 1
  001d9	8b c2		 mov	 eax, edx
  001db	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  001de	03 c2		 add	 eax, edx
  001e0	3b c7		 cmp	 eax, edi
  001e2	89 4d 10	 mov	 DWORD PTR tv398[ebp], ecx
  001e5	73 78		 jae	 SHORT $L290537

; 848  : 			{	// new stuff spills off end
; 849  : 			_Ucopy(_ITER_BASE(_Where), _Mylast,
; 850  : 				_ITER_BASE(_Where) + _Count);	// copy suffix

  001e7	8d 04 7f	 lea	 eax, DWORD PTR [edi+edi*2]
  001ea	c1 e0 02	 shl	 eax, 2
  001ed	89 45 08	 mov	 DWORD PTR tv414[ebp], eax
  001f0	8b 55 08	 mov	 edx, DWORD PTR __Cat$352590[ebp]
  001f3	52		 push	 edx
  001f4	56		 push	 esi
  001f5	03 c3		 add	 eax, ebx
  001f7	50		 push	 eax
  001f8	51		 push	 ecx
  001f9	53		 push	 ebx
  001fa	e8 00 00 00 00	 call	 ??$_Uninit_copy@PAU__ITEMINFO@@PAU1@V?$allocator@U__ITEMINFO@@@std@@@std@@YAPAU__ITEMINFO@@PAU1@00AAV?$allocator@U__ITEMINFO@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<__ITEMINFO *,__ITEMINFO *,std::allocator<__ITEMINFO> >

; 851  : 
; 852  : 			_TRY_BEGIN
; 853  : 			_Ufill(_Mylast, _Count - (_Mylast - _ITER_BASE(_Where)),
; 854  : 				_Tmp);	// insert new stuff off end

  001ff	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00202	83 c4 14	 add	 esp, 20			; 00000014H
  00205	8d 45 e4	 lea	 eax, DWORD PTR __Tmp$[ebp]
  00208	50		 push	 eax
  00209	8b d1		 mov	 edx, ecx
  0020b	2b d3		 sub	 edx, ebx
  0020d	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00212	f7 ea		 imul	 edx
  00214	d1 fa		 sar	 edx, 1
  00216	8b c2		 mov	 eax, edx
  00218	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0021b	03 c2		 add	 eax, edx
  0021d	2b f8		 sub	 edi, eax
  0021f	57		 push	 edi
  00220	51		 push	 ecx
  00221	8b ce		 mov	 ecx, esi
  00223	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 2
  0022a	e8 00 00 00 00	 call	 ?_Ufill@?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@IAEPAU__ITEMINFO@@PAU3@IABU3@@Z ; std::vector<__ITEMINFO,std::allocator<__ITEMINFO> >::_Ufill

; 855  : 			_CATCH_ALL
; 856  : 			_Destroy(_ITER_BASE(_Where) + _Count, _Mylast + _Count);
; 857  : 			_RERAISE;
; 858  : 			_CATCH_END
; 859  : 
; 860  : 			_Mylast += _Count;

  0022f	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  00232	8b 45 08	 mov	 eax, DWORD PTR tv414[ebp]
  00235	03 f8		 add	 edi, eax
  00237	89 7e 08	 mov	 DWORD PTR [esi+8], edi

; 861  : 			fill(_ITER_BASE(_Where), _Mylast - _Count,
; 862  : 				_Tmp);	// insert up to old end

  0023a	8d 4d e4	 lea	 ecx, DWORD PTR __Tmp$[ebp]
  0023d	8b f7		 mov	 esi, edi
  0023f	51		 push	 ecx
  00240	2b f0		 sub	 esi, eax
  00242	56		 push	 esi
  00243	53		 push	 ebx
  00244	e8 00 00 00 00	 call	 ??$fill@PAU__ITEMINFO@@U1@@std@@YAXPAU__ITEMINFO@@0ABU1@@Z ; std::fill<__ITEMINFO *,__ITEMINFO>
  00249	83 c4 0c	 add	 esp, 12			; 0000000cH

; 873  : 			}
; 874  : 		}

  0024c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0024f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00256	5f		 pop	 edi
  00257	5e		 pop	 esi
  00258	5b		 pop	 ebx
  00259	8b e5		 mov	 esp, ebp
  0025b	5d		 pop	 ebp
  0025c	c2 0c 00	 ret	 12			; 0000000cH
$L290537:

; 863  : 			}
; 864  : 		else
; 865  : 			{	// new stuff can all be assigned
; 866  : 			pointer _Oldend = _Mylast;
; 867  : 			_Mylast = _Ucopy(_Oldend - _Count, _Oldend,
; 868  : 				_Mylast);	// copy suffix

  0025f	8d 3c 7f	 lea	 edi, DWORD PTR [edi+edi*2]
  00262	8b c1		 mov	 eax, ecx
  00264	c1 e7 02	 shl	 edi, 2
  00267	2b c7		 sub	 eax, edi
  00269	89 45 08	 mov	 DWORD PTR tv427[ebp], eax
  0026c	8b 55 08	 mov	 edx, DWORD PTR __Cat$352614[ebp]
  0026f	52		 push	 edx
  00270	56		 push	 esi
  00271	51		 push	 ecx
  00272	51		 push	 ecx
  00273	50		 push	 eax
  00274	e8 00 00 00 00	 call	 ??$_Uninit_copy@PAU__ITEMINFO@@PAU1@V?$allocator@U__ITEMINFO@@@std@@@std@@YAPAU__ITEMINFO@@PAU1@00AAV?$allocator@U__ITEMINFO@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<__ITEMINFO *,__ITEMINFO *,std::allocator<__ITEMINFO> >

; 869  : 			copy_backward(_ITER_BASE(_Where), _Oldend - _Count,
; 870  : 				_Oldend);	// copy hole

  00279	8b 4d 10	 mov	 ecx, DWORD PTR tv398[ebp]
  0027c	8b 55 08	 mov	 edx, DWORD PTR tv427[ebp]
  0027f	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00282	8b 45 08	 mov	 eax, DWORD PTR __Cat$352628[ebp]
  00285	50		 push	 eax
  00286	51		 push	 ecx
  00287	52		 push	 edx
  00288	53		 push	 ebx
  00289	e8 00 00 00 00	 call	 ??$_Copy_backward_opt@PAU__ITEMINFO@@PAU1@@std@@YAPAU__ITEMINFO@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Copy_backward_opt<__ITEMINFO *,__ITEMINFO *>

; 871  : 			fill(_ITER_BASE(_Where), _ITER_BASE(_Where) + _Count,
; 872  : 				_Tmp);	// insert into hole

  0028e	8d 45 e4	 lea	 eax, DWORD PTR __Tmp$[ebp]
  00291	50		 push	 eax
  00292	03 fb		 add	 edi, ebx
  00294	57		 push	 edi
  00295	53		 push	 ebx
  00296	e8 00 00 00 00	 call	 ??$fill@PAU__ITEMINFO@@U1@@std@@YAXPAU__ITEMINFO@@0ABU1@@Z ; std::fill<__ITEMINFO *,__ITEMINFO>
  0029b	83 c4 30	 add	 esp, 48			; 00000030H
$L290546:

; 873  : 			}
; 874  : 		}

  0029e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  002a1	5f		 pop	 edi
  002a2	5e		 pop	 esi
  002a3	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  002aa	5b		 pop	 ebx
  002ab	8b e5		 mov	 esp, ebp
  002ad	5d		 pop	 ebp
  002ae	c2 0c 00	 ret	 12			; 0000000cH
$L352634:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Insert_n@?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@IAEXViterator@12@IABU__ITEMINFO@@@Z:
  00000	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T352632
  00005	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?_Insert_n@?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@IAEXViterator@12@IABU__ITEMINFO@@@Z ENDP ; std::vector<__ITEMINFO,std::allocator<__ITEMINFO> >::_Insert_n
PUBLIC	??$_Destroy_range@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Destroy_range<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??$_Destroy_range@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z
_TEXT	SEGMENT
__Cat$352648 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z PROC NEAR ; std::_Destroy_range<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT

; 216  : 	{	// destroy [_First, _Last)

  00000	51		 push	 ecx

; 217  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

  00001	8b 04 24	 mov	 eax, DWORD PTR __Cat$352648[esp+4]
  00004	8b 4c 24 10	 mov	 ecx, DWORD PTR __Al$[esp]
  00008	8b 54 24 0c	 mov	 edx, DWORD PTR __Last$[esp]
  0000c	50		 push	 eax
  0000d	8b 44 24 0c	 mov	 eax, DWORD PTR __First$[esp+4]
  00011	51		 push	 ecx
  00012	52		 push	 edx
  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >

; 218  : 	}

  00019	83 c4 14	 add	 esp, 20			; 00000014H
  0001c	c3		 ret	 0
??$_Destroy_range@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ENDP ; std::_Destroy_range<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
PUBLIC	??$copy_backward@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00@Z ; std::copy_backward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xutility
;	COMDAT ??$copy_backward@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00@Z
_TEXT	SEGMENT
__Cat$352656 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$copy_backward@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00@Z PROC NEAR ; std::copy_backward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>, COMDAT

; 1067 : 	{	// copy [_First, _Last) backwards to [..., _Dest)

  00000	51		 push	 ecx

; 1068 : 	return (_Copy_backward_opt(_First, _Last, _Dest,
; 1069 : 		_Ptr_cat(_First, _Dest)));

  00001	8b 04 24	 mov	 eax, DWORD PTR __Cat$352656[esp+4]
  00004	8b 4c 24 10	 mov	 ecx, DWORD PTR __Dest$[esp]
  00008	8b 54 24 0c	 mov	 edx, DWORD PTR __Last$[esp]
  0000c	50		 push	 eax
  0000d	8b 44 24 0c	 mov	 eax, DWORD PTR __First$[esp+4]
  00011	51		 push	 ecx
  00012	52		 push	 edx
  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 ??$_Copy_backward_opt@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Copy_backward_opt<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>

; 1070 : 	}

  00019	83 c4 14	 add	 esp, 20			; 00000014H
  0001c	c3		 ret	 0
??$copy_backward@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00@Z ENDP ; std::copy_backward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
_TEXT	ENDS
PUBLIC	??$_Uninit_fill_n@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IABV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\iosfwd
xdata$x	SEGMENT
$T352850 DD	0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:$L352669
	DD	0ffffffffH
	DD	00H
$T352852 DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L352662
$T352851 DD	00H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:$T352852
$T352844 DD	019930520H
	DD	03H
	DD	FLAT:$T352850
	DD	01H
	DD	FLAT:$T352851
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_fill_n@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IABV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
$T352807 = 12						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
??$_Uninit_fill_n@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IABV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Uninit_fill_n<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT

; 207  : 	{	// copy _Count *_Val to raw _First, using _Al, arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Uninit_fill_n@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IABV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 08	 sub	 esp, 8
  0001b	53		 push	 ebx
  0001c	56		 push	 esi

; 208  : 	_FwdIt _Next = _First;

  0001d	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  00020	57		 push	 edi

; 209  : 
; 210  : 	_TRY_BEGIN

  00021	8b 7d 0c	 mov	 edi, DWORD PTR __Count$[ebp]
  00024	33 db		 xor	 ebx, ebx
  00026	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00029	89 75 ec	 mov	 DWORD PTR __Next$[ebp], esi
  0002c	89 5d fc	 mov	 DWORD PTR __$EHRec$[ebp+12], ebx
  0002f	90		 npad	 1
$L293252:

; 211  : 	for (; 0 < _Count; --_Count, ++_First)

  00030	3b fb		 cmp	 edi, ebx
  00032	76 57		 jbe	 SHORT $L293254

; 212  : 		_Al.construct(_First, _Val);

  00034	89 75 0c	 mov	 DWORD PTR $T352807[ebp], esi
  00037	3b f3		 cmp	 esi, ebx
  00039	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1
  0003d	74 1b		 je	 SHORT $L352808
  0003f	8b 45 10	 mov	 eax, DWORD PTR __Val$[ebp]
  00042	6a ff		 push	 -1
  00044	53		 push	 ebx
  00045	c7 46 18 0f 00
	00 00		 mov	 DWORD PTR [esi+24], 15	; 0000000fH
  0004c	89 5e 14	 mov	 DWORD PTR [esi+20], ebx
  0004f	50		 push	 eax
  00050	8b ce		 mov	 ecx, esi
  00052	88 5e 04	 mov	 BYTE PTR [esi+4], bl
  00055	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$L352808:
  0005a	4f		 dec	 edi
  0005b	83 c6 1c	 add	 esi, 28			; 0000001cH
  0005e	88 5d fc	 mov	 BYTE PTR __$EHRec$[ebp+12], bl
  00061	89 75 08	 mov	 DWORD PTR __First$[ebp], esi
  00064	eb ca		 jmp	 SHORT $L293252
$L352662:

; 213  : 	_CATCH_ALL
; 214  : 	for (; _Next != _First; ++_Next)

  00066	8b 75 ec	 mov	 esi, DWORD PTR __Next$[ebp]
  00069	8b 7d 08	 mov	 edi, DWORD PTR __First$[ebp]
  0006c	3b f7		 cmp	 esi, edi
  0006e	74 12		 je	 SHORT $L293257
  00070	8b 5d 14	 mov	 ebx, DWORD PTR __Al$[ebp]
$L293255:

; 215  : 		_Al.destroy(_Next);

  00073	56		 push	 esi
  00074	8b cb		 mov	 ecx, ebx
  00076	e8 00 00 00 00	 call	 ?destroy@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::destroy
  0007b	83 c6 1c	 add	 esi, 28			; 0000001cH
  0007e	3b f7		 cmp	 esi, edi
  00080	75 f1		 jne	 SHORT $L293255
$L293257:

; 216  : 	_RERAISE;

  00082	33 db		 xor	 ebx, ebx
  00084	53		 push	 ebx
  00085	53		 push	 ebx
  00086	e8 00 00 00 00	 call	 __CxxThrowException@8
$L352853:
$L293254:

; 217  : 	_CATCH_END
; 218  : 	}

  0008b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0008e	5f		 pop	 edi
  0008f	5e		 pop	 esi
  00090	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00097	5b		 pop	 ebx
  00098	8b e5		 mov	 esp, ebp
  0009a	5d		 pop	 ebp
  0009b	c3		 ret	 0
$L352849:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L352669:
  00000	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00003	50		 push	 eax
  00004	8b 4d 0c	 mov	 ecx, DWORD PTR $T352807[ebp]
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$_Uninit_fill_n@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IABV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z:
  00011	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T352844
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$_Uninit_fill_n@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IABV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	??$_Uninitialized_copy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Uninitialized_copy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
; Function compile flags: /Ogty
;	COMDAT ??$_Uninitialized_copy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z
_TEXT	SEGMENT
__Cat$352861 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_copy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z PROC NEAR ; std::_Uninitialized_copy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT

; 126  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

  00000	51		 push	 ecx

; 127  : 	return (_Uninit_copy(_First, _Last, _Dest, _Al,
; 128  : 		_Ptr_cat(_First, _Dest)));

  00001	8b 04 24	 mov	 eax, DWORD PTR __Cat$352861[esp+4]
  00004	8b 4c 24 14	 mov	 ecx, DWORD PTR __Al$[esp]
  00008	8b 54 24 10	 mov	 edx, DWORD PTR __Dest$[esp]
  0000c	50		 push	 eax
  0000d	8b 44 24 10	 mov	 eax, DWORD PTR __Last$[esp+4]
  00011	51		 push	 ecx
  00012	8b 4c 24 10	 mov	 ecx, DWORD PTR __First$[esp+8]
  00016	52		 push	 edx
  00017	50		 push	 eax
  00018	51		 push	 ecx
  00019	e8 00 00 00 00	 call	 ??$_Uninit_copy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >

; 129  : 	}

  0001e	83 c4 18	 add	 esp, 24			; 00000018H
  00021	c3		 ret	 0
??$_Uninitialized_copy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ENDP ; std::_Uninitialized_copy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAEIABK@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::erase
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAEIABK@Z
_TEXT	SEGMENT
$T352866 = -8						; size = 4
__Where$ = -8						; size = 8
__Num$ = 8						; size = 4
__Keyval$ = 8						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAEIABK@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::erase, COMDAT
; _this$ = ecx

; 765  : 		{	// erase and count all that match _Keyval

  00000	83 ec 08	 sub	 esp, 8

; 766  : 		_Pairii _Where = equal_range(_Keyval);

  00003	8b 44 24 0c	 mov	 eax, DWORD PTR __Keyval$[esp+4]
  00007	53		 push	 ebx
  00008	56		 push	 esi
  00009	57		 push	 edi
  0000a	8b f1		 mov	 esi, ecx
  0000c	50		 push	 eax
  0000d	8d 4c 24 10	 lea	 ecx, DWORD PTR __Where$[esp+24]
  00011	51		 push	 ecx
  00012	8b ce		 mov	 ecx, esi
  00014	e8 00 00 00 00	 call	 ?equal_range@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@V123@@2@ABK@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::equal_range

; 767  : 		size_type _Num = 0;
; 768  : 		_Distance(_Where.first, _Where.second, _Num);

  00019	8b 7c 24 10	 mov	 edi, DWORD PTR __Where$[esp+24]
  0001d	8b 5c 24 0c	 mov	 ebx, DWORD PTR __Where$[esp+20]
  00021	8d 54 24 18	 lea	 edx, DWORD PTR __Num$[esp+16]
  00025	52		 push	 edx
  00026	57		 push	 edi
  00027	53		 push	 ebx
  00028	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR __Num$[esp+28], 0
  00030	e8 00 00 00 00	 call	 ??$_Distance@Viterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@I@std@@YAXViterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@0@0AAI@Z ; std::_Distance<std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::iterator,unsigned int>
  00035	83 c4 0c	 add	 esp, 12			; 0000000cH

; 769  : 		erase(_Where.first, _Where.second);

  00038	57		 push	 edi
  00039	53		 push	 ebx
  0003a	8d 44 24 14	 lea	 eax, DWORD PTR $T352866[esp+28]
  0003e	50		 push	 eax
  0003f	8b ce		 mov	 ecx, esi
  00041	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::erase

; 770  : 		return (_Num);

  00046	8b 44 24 18	 mov	 eax, DWORD PTR __Num$[esp+16]
  0004a	5f		 pop	 edi
  0004b	5e		 pop	 esi
  0004c	5b		 pop	 ebx

; 771  : 		}

  0004d	83 c4 08	 add	 esp, 8
  00050	c2 04 00	 ret	 4
?erase@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAEIABK@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::erase
_TEXT	ENDS
PUBLIC	??0?$vector@KV?$allocator@K@std@@@std@@QAE@XZ	; std::vector<unsigned long,std::allocator<unsigned long> >::vector<unsigned long,std::allocator<unsigned long> >
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ??0?$vector@KV?$allocator@K@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@KV?$allocator@K@std@@@std@@QAE@XZ PROC NEAR	; std::vector<unsigned long,std::allocator<unsigned long> >::vector<unsigned long,std::allocator<unsigned long> >, COMDAT
; _this$ = ecx

; 299  : 		{	// construct empty vector

  00000	8b c1		 mov	 eax, ecx

; 300  : 		_Buy(0);

  00002	33 c9		 xor	 ecx, ecx
  00004	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00007	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  0000a	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 301  : 		}

  0000d	c3		 ret	 0
??0?$vector@KV?$allocator@K@std@@@std@@QAE@XZ ENDP	; std::vector<unsigned long,std::allocator<unsigned long> >::vector<unsigned long,std::allocator<unsigned long> >
_TEXT	ENDS
PUBLIC	?insert@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@ABU?$pair@$$CBKPAVCUser@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::insert
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ?insert@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@ABU?$pair@$$CBKPAVCUser@@@2@@Z
_TEXT	SEGMENT
$T352936 = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Next$ = 16						; size = 4
__Val$ = 16						; size = 4
?insert@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@ABU?$pair@$$CBKPAVCUser@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::insert, COMDAT
; _this$ = ecx

; 509  : 		{	// try to insert node with value _Val using _Where as a hint

  00000	83 ec 08	 sub	 esp, 8
  00003	56		 push	 esi
  00004	57		 push	 edi
  00005	8b f9		 mov	 edi, ecx

; 510  : 		iterator _Next;
; 511  : 
; 512  : 		if (size() == 0)

  00007	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  0000a	85 c0		 test	 eax, eax
  0000c	75 21		 jne	 SHORT $L220296

; 513  : 			return (_Insert(true, _Myhead, _Val));	// insert into empty tree

  0000e	8b 44 24 1c	 mov	 eax, DWORD PTR __Val$[esp+12]
  00012	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  00015	8b 74 24 14	 mov	 esi, DWORD PTR ___$ReturnUdt$[esp+12]
  00019	50		 push	 eax
  0001a	51		 push	 ecx
  0001b	6a 01		 push	 1
  0001d	56		 push	 esi
  0001e	8b cf		 mov	 ecx, edi
  00020	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBKPAVCUser@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Insert
  00025	5f		 pop	 edi
  00026	8b c6		 mov	 eax, esi
  00028	5e		 pop	 esi

; 580  : 		}

  00029	83 c4 08	 add	 esp, 8
  0002c	c2 0c 00	 ret	 12			; 0000000cH
$L220296:

; 514  : 		else if (this->_Multi)
; 515  : 			{	// insert even if duplicate
; 516  : 			if (_Where == begin())
; 517  : 				{	// insert at beginning if before first element
; 518  : 				if (!this->comp(_Key(_Where._Mynode()), this->_Kfn(_Val)))
; 519  : 					return (_Insert(true, _Where._Mynode(), _Val));
; 520  : 				}
; 521  : 			else if (_Where == end())
; 522  : 				{	// insert at end if after last element
; 523  : 				if (!this->comp(this->_Kfn(_Val), _Key(_Rmost())))
; 524  : 					return (_Insert(false, _Rmost(), _Val));
; 525  : 				}
; 526  : 			else if (!this->comp(_Key(_Where._Mynode()), this->_Kfn(_Val))
; 527  : 				&& !this->comp(this->_Kfn(_Val),
; 528  : 					_Key((--(_Next = _Where))._Mynode())))
; 529  : 				{	// insert before _Where
; 530  : 				if (_Isnil(_Right(_Next._Mynode())))
; 531  : 					return (_Insert(false, _Next._Mynode(), _Val));
; 532  : 				else
; 533  : 					return (_Insert(true, _Where._Mynode(), _Val));
; 534  : 				}
; 535  : 			else if (!this->comp(this->_Kfn(_Val), _Key(_Where._Mynode()))
; 536  : 				&& (++(_Next = _Where) == end()
; 537  : 					|| !this->comp(_Key(_Next._Mynode()),
; 538  : 						this->_Kfn(_Val))))
; 539  : 				{	// insert after _Where
; 540  : 				if (_Isnil(_Right(_Where._Mynode())))
; 541  : 					return (_Insert(false, _Where._Mynode(), _Val));
; 542  : 				else
; 543  : 					return (_Insert(true, _Next._Mynode(), _Val));
; 544  : 				}
; 545  : 			}
; 546  : 		else
; 547  : 			{	// insert only if unique
; 548  : 			if (_Where == begin())

  0002f	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00032	8b 08		 mov	 ecx, DWORD PTR [eax]

; 549  : 				{	// insert at beginning if before first element
; 550  : 				if (this->comp(this->_Kfn(_Val), _Key(_Where._Mynode())))

  00034	8b 74 24 1c	 mov	 esi, DWORD PTR __Val$[esp+12]
  00038	53		 push	 ebx
  00039	8b 5c 24 1c	 mov	 ebx, DWORD PTR __Where$[esp+16]
  0003d	3b d9		 cmp	 ebx, ecx
  0003f	55		 push	 ebp
  00040	75 27		 jne	 SHORT $L220325
  00042	8b 16		 mov	 edx, DWORD PTR [esi]
  00044	3b 53 0c	 cmp	 edx, DWORD PTR [ebx+12]
  00047	0f 83 fd 00 00
	00		 jae	 $L220345

; 551  : 					return (_Insert(true, _Where._Mynode(), _Val));

  0004d	56		 push	 esi
  0004e	8b 74 24 20	 mov	 esi, DWORD PTR ___$ReturnUdt$[esp+24]
  00052	53		 push	 ebx
  00053	6a 01		 push	 1
  00055	56		 push	 esi
  00056	8b cf		 mov	 ecx, edi
  00058	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBKPAVCUser@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Insert
  0005d	5d		 pop	 ebp
  0005e	5b		 pop	 ebx
  0005f	5f		 pop	 edi
  00060	8b c6		 mov	 eax, esi
  00062	5e		 pop	 esi

; 580  : 		}

  00063	83 c4 08	 add	 esp, 8
  00066	c2 0c 00	 ret	 12			; 0000000cH
$L220325:

; 552  : 				}
; 553  : 			else if (_Where == end())

  00069	3b d8		 cmp	 ebx, eax
  0006b	75 2a		 jne	 SHORT $L220330

; 554  : 				{	// insert at end if after last element
; 555  : 				if (this->comp(_Key(_Rmost()), this->_Kfn(_Val)))

  0006d	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00070	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00073	3b 0e		 cmp	 ecx, DWORD PTR [esi]
  00075	0f 83 cf 00 00
	00		 jae	 $L220345

; 556  : 					return (_Insert(false, _Rmost(), _Val));

  0007b	56		 push	 esi
  0007c	8b 74 24 20	 mov	 esi, DWORD PTR ___$ReturnUdt$[esp+24]
  00080	50		 push	 eax
  00081	6a 00		 push	 0
  00083	56		 push	 esi
  00084	8b cf		 mov	 ecx, edi
  00086	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBKPAVCUser@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Insert
  0008b	5d		 pop	 ebp
  0008c	5b		 pop	 ebx
  0008d	5f		 pop	 edi
  0008e	8b c6		 mov	 eax, esi
  00090	5e		 pop	 esi

; 580  : 		}

  00091	83 c4 08	 add	 esp, 8
  00094	c2 0c 00	 ret	 12			; 0000000cH
$L220330:

; 557  : 				}
; 558  : 			else if (this->comp(this->_Kfn(_Val), _Key(_Where._Mynode()))
; 559  : 				&& this->comp(_Key((--(_Next = _Where))._Mynode()),
; 560  : 					this->_Kfn(_Val)))

  00097	8b 2e		 mov	 ebp, DWORD PTR [esi]
  00099	39 6b 0c	 cmp	 DWORD PTR [ebx+12], ebp
  0009c	76 54		 jbe	 SHORT $L353479
  0009e	8d 4c 24 24	 lea	 ecx, DWORD PTR __Next$[esp+20]
  000a2	89 5c 24 24	 mov	 DWORD PTR __Next$[esp+20], ebx
  000a6	e8 00 00 00 00	 call	 ?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::const_iterator::_Dec
  000ab	8b 44 24 24	 mov	 eax, DWORD PTR __Next$[esp+20]
  000af	39 68 0c	 cmp	 DWORD PTR [eax+12], ebp
  000b2	73 3b		 jae	 SHORT $L220334

; 561  : 				{	// insert before _Where
; 562  : 				if (_Isnil(_Right(_Next._Mynode())))

  000b4	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  000b7	8a 4a 15	 mov	 cl, BYTE PTR [edx+21]

; 563  : 					return (_Insert(false, _Next._Mynode(), _Val));

  000ba	56		 push	 esi
  000bb	8b 74 24 20	 mov	 esi, DWORD PTR ___$ReturnUdt$[esp+24]
  000bf	84 c9		 test	 cl, cl
  000c1	8b cf		 mov	 ecx, edi
  000c3	74 15		 je	 SHORT $L220335
  000c5	50		 push	 eax
  000c6	6a 00		 push	 0
  000c8	56		 push	 esi
  000c9	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBKPAVCUser@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Insert
  000ce	5d		 pop	 ebp
  000cf	5b		 pop	 ebx
  000d0	5f		 pop	 edi
  000d1	8b c6		 mov	 eax, esi
  000d3	5e		 pop	 esi

; 580  : 		}

  000d4	83 c4 08	 add	 esp, 8
  000d7	c2 0c 00	 ret	 12			; 0000000cH
$L220335:

; 564  : 				else
; 565  : 					return (_Insert(true, _Where._Mynode(), _Val));

  000da	53		 push	 ebx
  000db	6a 01		 push	 1
  000dd	56		 push	 esi
  000de	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBKPAVCUser@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Insert
  000e3	5d		 pop	 ebp
  000e4	5b		 pop	 ebx
  000e5	5f		 pop	 edi
  000e6	8b c6		 mov	 eax, esi
  000e8	5e		 pop	 esi

; 580  : 		}

  000e9	83 c4 08	 add	 esp, 8
  000ec	c2 0c 00	 ret	 12			; 0000000cH
$L220334:

; 566  : 				}
; 567  : 			else if (this->comp(_Key(_Where._Mynode()), this->_Kfn(_Val))
; 568  : 				&& (++(_Next = _Where) == end()
; 569  : 					|| this->comp(this->_Kfn(_Val),
; 570  : 						_Key(_Next._Mynode()))))

  000ef	39 6b 0c	 cmp	 DWORD PTR [ebx+12], ebp
$L353479:
  000f2	73 56		 jae	 SHORT $L220345
  000f4	8d 4c 24 24	 lea	 ecx, DWORD PTR __Next$[esp+20]
  000f8	89 5c 24 24	 mov	 DWORD PTR __Next$[esp+20], ebx
  000fc	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::const_iterator::_Inc
  00101	8b 44 24 24	 mov	 eax, DWORD PTR __Next$[esp+20]
  00105	3b 47 04	 cmp	 eax, DWORD PTR [edi+4]
  00108	74 05		 je	 SHORT $L220342
  0010a	3b 68 0c	 cmp	 ebp, DWORD PTR [eax+12]
  0010d	73 3b		 jae	 SHORT $L220345
$L220342:

; 571  : 				{	// insert after _Where
; 572  : 				if (_Isnil(_Right(_Where._Mynode())))

  0010f	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  00112	8a 51 15	 mov	 dl, BYTE PTR [ecx+21]
  00115	84 d2		 test	 dl, dl

; 573  : 					return (_Insert(false, _Where._Mynode(), _Val));

  00117	56		 push	 esi
  00118	8b 74 24 20	 mov	 esi, DWORD PTR ___$ReturnUdt$[esp+24]
  0011c	8b cf		 mov	 ecx, edi
  0011e	74 15		 je	 SHORT $L220343
  00120	53		 push	 ebx
  00121	6a 00		 push	 0
  00123	56		 push	 esi
  00124	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBKPAVCUser@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Insert
  00129	5d		 pop	 ebp
  0012a	5b		 pop	 ebx
  0012b	5f		 pop	 edi
  0012c	8b c6		 mov	 eax, esi
  0012e	5e		 pop	 esi

; 580  : 		}

  0012f	83 c4 08	 add	 esp, 8
  00132	c2 0c 00	 ret	 12			; 0000000cH
$L220343:

; 574  : 				else
; 575  : 					return (_Insert(true, _Next._Mynode(), _Val));

  00135	50		 push	 eax
  00136	6a 01		 push	 1
  00138	56		 push	 esi
  00139	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBKPAVCUser@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Insert
  0013e	5d		 pop	 ebp
  0013f	5b		 pop	 ebx
  00140	5f		 pop	 edi
  00141	8b c6		 mov	 eax, esi
  00143	5e		 pop	 esi

; 580  : 		}

  00144	83 c4 08	 add	 esp, 8
  00147	c2 0c 00	 ret	 12			; 0000000cH
$L220345:

; 576  : 				}
; 577  : 			}
; 578  : 
; 579  : 		return (insert(_Val).first);	// try usual insert if all else fails

  0014a	56		 push	 esi
  0014b	8d 54 24 14	 lea	 edx, DWORD PTR $T352936[esp+28]
  0014f	52		 push	 edx
  00150	8b cf		 mov	 ecx, edi
  00152	e8 00 00 00 00	 call	 ?insert@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBKPAVCUser@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::insert
  00157	8b 08		 mov	 ecx, DWORD PTR [eax]
  00159	8b 44 24 1c	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp+20]
  0015d	5d		 pop	 ebp
  0015e	5b		 pop	 ebx
  0015f	5f		 pop	 edi
  00160	89 08		 mov	 DWORD PTR [eax], ecx
  00162	5e		 pop	 esi

; 580  : 		}

  00163	83 c4 08	 add	 esp, 8
  00166	c2 0c 00	 ret	 12			; 0000000cH
?insert@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@ABU?$pair@$$CBKPAVCUser@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::insert
_TEXT	ENDS
PUBLIC	?_Tidy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Tidy
; Function compile flags: /Ogty
;	COMDAT ?_Tidy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
$T353485 = -4						; size = 4
?_Tidy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXXZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Tidy, COMDAT
; _this$ = ecx

; 1142 : 		{	// free all storage

  00000	51		 push	 ecx
  00001	56		 push	 esi
  00002	8b f1		 mov	 esi, ecx

; 1143 : 		erase(begin(), end());

  00004	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00007	8b 08		 mov	 ecx, DWORD PTR [eax]
  00009	50		 push	 eax
  0000a	51		 push	 ecx
  0000b	8d 44 24 0c	 lea	 eax, DWORD PTR $T353485[esp+16]
  0000f	50		 push	 eax
  00010	8b ce		 mov	 ecx, esi
  00012	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@V312@0@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::erase

; 1144 : 		this->_Alptr.destroy(&_Left(_Myhead));
; 1145 : 		this->_Alptr.destroy(&_Parent(_Myhead));
; 1146 : 		this->_Alptr.destroy(&_Right(_Myhead));
; 1147 : 		this->_Alnod.deallocate(_Myhead, 1);

  00017	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0001a	51		 push	 ecx
  0001b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00020	83 c4 04	 add	 esp, 4

; 1148 : 		_Myhead = 0, _Mysize = 0;

  00023	33 c0		 xor	 eax, eax
  00025	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00028	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0002b	5e		 pop	 esi

; 1149 : 		}

  0002c	59		 pop	 ecx
  0002d	c3		 ret	 0
?_Tidy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Tidy
_TEXT	ENDS
PUBLIC	?AddRainbowRacePrevRankingOpenWnd@CUser@@QAEXXZ	; CUser::AddRainbowRacePrevRankingOpenWnd
EXTRN	?GetPrevRanking@CRainbowRaceMng@@QAE?AV?$vector@KV?$allocator@K@std@@@std@@XZ:NEAR ; CRainbowRaceMng::GetPrevRanking
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
xdata$x	SEGMENT
$T353778 DD	0ffffffffH
	DD	FLAT:$L353549
	DD	00H
	DD	FLAT:$L353550
$T353774 DD	019930520H
	DD	02H
	DD	FLAT:$T353778
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
xdata$x	ENDS
;	COMDAT ?AddRainbowRacePrevRankingOpenWnd@CUser@@QAEXXZ
_TEXT	SEGMENT
_vecdwPrevRanking$ = -44				; size = 16
$T353548 = -28						; size = 16
__$EHRec$ = -12						; size = 12
?AddRainbowRacePrevRankingOpenWnd@CUser@@QAEXXZ PROC NEAR ; CUser::AddRainbowRacePrevRankingOpenWnd, COMDAT
; _this$ = ecx

; 8390 : {

  00000	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00006	6a ff		 push	 -1
  00008	68 00 00 00 00	 push	 __ehhandler$?AddRainbowRacePrevRankingOpenWnd@CUser@@QAEXXZ
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp

; 8391 : 	if( IsDelete() )	return;

  00015	8a 41 04	 mov	 al, BYTE PTR [ecx+4]
  00018	83 ec 20	 sub	 esp, 32			; 00000020H
  0001b	a8 01		 test	 al, 1
  0001d	0f 85 f9 00 00
	00		 jne	 $L353771

; 8392 : 	m_Snapshot.cb++;

  00023	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]
  0002a	53		 push	 ebx
  0002b	55		 push	 ebp
  0002c	56		 push	 esi
  0002d	57		 push	 edi

; 8393 : 	m_Snapshot.ar << GetId();

  0002e	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  00034	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  0003a	6a 04		 push	 4
  0003c	8b ce		 mov	 ecx, esi
  0003e	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00043	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00046	89 38		 mov	 DWORD PTR [eax], edi
  00048	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0004b	83 c0 04	 add	 eax, 4

; 8394 : 	m_Snapshot.ar << SNAPSHOTTYPE_RAINBOWRACE_PREVRANKING_OPENWND;

  0004e	6a 02		 push	 2
  00050	8b ce		 mov	 ecx, esi
  00052	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00055	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0005a	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0005d	66 c7 01 00 90	 mov	 WORD PTR [ecx], 36864	; 00009000H
  00062	83 46 08 02	 add	 DWORD PTR [esi+8], 2

; 8395 : 	vector<DWORD> vecdwPrevRanking;

  00066	33 db		 xor	 ebx, ebx
  00068	89 5c 24 14	 mov	 DWORD PTR _vecdwPrevRanking$[esp+64], ebx
  0006c	89 5c 24 18	 mov	 DWORD PTR _vecdwPrevRanking$[esp+68], ebx
  00070	89 5c 24 1c	 mov	 DWORD PTR _vecdwPrevRanking$[esp+72], ebx

; 8396 : 	vecdwPrevRanking = CRainbowRaceMng::GetInstance()->GetPrevRanking();

  00074	8d 54 24 20	 lea	 edx, DWORD PTR $T353548[esp+60]
  00078	52		 push	 edx
  00079	89 5c 24 3c	 mov	 DWORD PTR __$EHRec$[esp+72], ebx
  0007d	e8 00 00 00 00	 call	 ?GetInstance@CRainbowRaceMng@@SAPAV1@XZ ; CRainbowRaceMng::GetInstance
  00082	8b c8		 mov	 ecx, eax
  00084	e8 00 00 00 00	 call	 ?GetPrevRanking@CRainbowRaceMng@@QAE?AV?$vector@KV?$allocator@K@std@@@std@@XZ ; CRainbowRaceMng::GetPrevRanking
  00089	50		 push	 eax
  0008a	8d 4c 24 14	 lea	 ecx, DWORD PTR _vecdwPrevRanking$[esp+64]
  0008e	c6 44 24 3c 01	 mov	 BYTE PTR __$EHRec$[esp+72], 1
  00093	e8 00 00 00 00	 call	 ??4?$vector@KV?$allocator@K@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::operator=
  00098	8b 44 24 24	 mov	 eax, DWORD PTR $T353548[esp+64]
  0009c	3b c3		 cmp	 eax, ebx
  0009e	88 5c 24 38	 mov	 BYTE PTR __$EHRec$[esp+68], bl
  000a2	74 09		 je	 SHORT $L353667
  000a4	50		 push	 eax
  000a5	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000aa	83 c4 04	 add	 esp, 4
$L353667:

; 8397 : 	m_Snapshot.ar << vecdwPrevRanking.size();

  000ad	8b 6c 24 14	 mov	 ebp, DWORD PTR _vecdwPrevRanking$[esp+64]
  000b1	3b eb		 cmp	 ebp, ebx
  000b3	75 04		 jne	 SHORT $L353675
  000b5	33 ff		 xor	 edi, edi
  000b7	eb 09		 jmp	 SHORT $L353676
$L353675:
  000b9	8b 7c 24 18	 mov	 edi, DWORD PTR _vecdwPrevRanking$[esp+68]
  000bd	2b fd		 sub	 edi, ebp
  000bf	c1 ff 02	 sar	 edi, 2
$L353676:
  000c2	6a 04		 push	 4
  000c4	8b ce		 mov	 ecx, esi
  000c6	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000cb	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000ce	89 38		 mov	 DWORD PTR [eax], edi
  000d0	83 46 08 04	 add	 DWORD PTR [esi+8], 4

; 8398 : 	for( int i=0; i<(int)( vecdwPrevRanking.size() ); i++ )

  000d4	33 ff		 xor	 edi, edi
$L285418:
  000d6	3b eb		 cmp	 ebp, ebx
  000d8	75 04		 jne	 SHORT $L353692
  000da	33 c0		 xor	 eax, eax
  000dc	eb 09		 jmp	 SHORT $L353693
$L353692:
  000de	8b 44 24 18	 mov	 eax, DWORD PTR _vecdwPrevRanking$[esp+68]
  000e2	2b c5		 sub	 eax, ebp
  000e4	c1 f8 02	 sar	 eax, 2
$L353693:
  000e7	3b f8		 cmp	 edi, eax
  000e9	7d 20		 jge	 SHORT $L285420

; 8399 : 		m_Snapshot.ar << vecdwPrevRanking[i];

  000eb	8b 5c bd 00	 mov	 ebx, DWORD PTR [ebp+edi*4]
  000ef	6a 04		 push	 4
  000f1	8b ce		 mov	 ecx, esi
  000f3	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000f8	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  000fb	89 19		 mov	 DWORD PTR [ecx], ebx
  000fd	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00100	83 c1 04	 add	 ecx, 4
  00103	47		 inc	 edi
  00104	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  00107	33 db		 xor	 ebx, ebx
  00109	eb cb		 jmp	 SHORT $L285418
$L285420:

; 8400 : }

  0010b	3b eb		 cmp	 ebp, ebx
  0010d	74 09		 je	 SHORT $L353777
  0010f	55		 push	 ebp
  00110	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00115	83 c4 04	 add	 esp, 4
$L353777:
  00118	5f		 pop	 edi
  00119	5e		 pop	 esi
  0011a	5d		 pop	 ebp
  0011b	5b		 pop	 ebx
$L353771:
  0011c	8b 4c 24 20	 mov	 ecx, DWORD PTR __$EHRec$[esp+44]
  00120	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00127	83 c4 2c	 add	 esp, 44			; 0000002cH
  0012a	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L353549:
  00000	8d 4d d4	 lea	 ecx, DWORD PTR _vecdwPrevRanking$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$vector@KV?$allocator@K@std@@@std@@QAE@XZ ; std::vector<unsigned long,std::allocator<unsigned long> >::~vector<unsigned long,std::allocator<unsigned long> >
$L353550:
  00008	8d 4d e4	 lea	 ecx, DWORD PTR $T353548[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$vector@KV?$allocator@K@std@@@std@@QAE@XZ ; std::vector<unsigned long,std::allocator<unsigned long> >::~vector<unsigned long,std::allocator<unsigned long> >
__ehhandler$?AddRainbowRacePrevRankingOpenWnd@CUser@@QAEXXZ:
  00010	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T353774
  00015	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?AddRainbowRacePrevRankingOpenWnd@CUser@@QAEXXZ ENDP	; CUser::AddRainbowRacePrevRankingOpenWnd
PUBLIC	??1?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::~_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ??1?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T353850 = -4						; size = 4
??1?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAE@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::~_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >, COMDAT
; _this$ = ecx

; 391  : 		{	// destroy tree

  00000	51		 push	 ecx
  00001	56		 push	 esi
  00002	8b f1		 mov	 esi, ecx

; 392  : 		_Tidy();

  00004	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00007	8b 08		 mov	 ecx, DWORD PTR [eax]
  00009	50		 push	 eax
  0000a	51		 push	 ecx
  0000b	8d 44 24 0c	 lea	 eax, DWORD PTR $T353850[esp+16]
  0000f	50		 push	 eax
  00010	8b ce		 mov	 ecx, esi
  00012	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::erase
  00017	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0001a	51		 push	 ecx
  0001b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00020	83 c4 04	 add	 esp, 4
  00023	33 c0		 xor	 eax, eax
  00025	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00028	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0002b	5e		 pop	 esi

; 393  : 		}

  0002c	59		 pop	 ecx
  0002d	c3		 ret	 0
??1?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::~_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >
_TEXT	ENDS
PUBLIC	??1?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::~_Tree<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >
; Function compile flags: /Ogty
;	COMDAT ??1?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T353945 = -4						; size = 4
??1?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAE@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::~_Tree<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >, COMDAT
; _this$ = ecx

; 391  : 		{	// destroy tree

  00000	51		 push	 ecx
  00001	56		 push	 esi
  00002	8b f1		 mov	 esi, ecx

; 392  : 		_Tidy();

  00004	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00007	8b 08		 mov	 ecx, DWORD PTR [eax]
  00009	50		 push	 eax
  0000a	51		 push	 ecx
  0000b	8d 44 24 0c	 lea	 eax, DWORD PTR $T353945[esp+16]
  0000f	50		 push	 eax
  00010	8b ce		 mov	 ecx, esi
  00012	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::erase
  00017	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0001a	51		 push	 ecx
  0001b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00020	83 c4 04	 add	 esp, 4
  00023	33 c0		 xor	 eax, eax
  00025	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00028	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0002b	5e		 pop	 esi

; 393  : 		}

  0002c	59		 pop	 ecx
  0002d	c3		 ret	 0
??1?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::~_Tree<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >
_TEXT	ENDS
PUBLIC	?push_back@?$vector@KV?$allocator@K@std@@@std@@QAEXABK@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::push_back
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ?push_back@?$vector@KV?$allocator@K@std@@@std@@QAEXABK@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$vector@KV?$allocator@K@std@@@std@@QAEXABK@Z PROC NEAR ; std::vector<unsigned long,std::allocator<unsigned long> >::push_back, COMDAT
; _this$ = ecx

; 579  : 		{	// insert element at end

  00000	56		 push	 esi

; 580  : 		if (size() < capacity())

  00001	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  00004	85 f6		 test	 esi, esi
  00006	75 04		 jne	 SHORT $L353981
  00008	33 d2		 xor	 edx, edx
  0000a	eb 08		 jmp	 SHORT $L353982
$L353981:
  0000c	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0000f	2b d6		 sub	 edx, esi
  00011	c1 fa 02	 sar	 edx, 2
$L353982:
  00014	85 f6		 test	 esi, esi
  00016	74 21		 je	 SHORT $L286041
  00018	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  0001b	2b c6		 sub	 eax, esi
  0001d	c1 f8 02	 sar	 eax, 2
  00020	3b d0		 cmp	 edx, eax
  00022	73 15		 jae	 SHORT $L286041

; 581  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

  00024	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00027	8b 54 24 08	 mov	 edx, DWORD PTR __Val$[esp]
  0002b	8b 12		 mov	 edx, DWORD PTR [edx]
  0002d	89 10		 mov	 DWORD PTR [eax], edx
  0002f	83 c0 04	 add	 eax, 4
  00032	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  00035	5e		 pop	 esi

; 584  : 		}

  00036	c2 04 00	 ret	 4
$L286041:

; 582  : 		else
; 583  : 			insert(end(), _Val);

  00039	8b 54 24 08	 mov	 edx, DWORD PTR __Val$[esp]
  0003d	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00040	52		 push	 edx
  00041	6a 01		 push	 1
  00043	50		 push	 eax
  00044	e8 00 00 00 00	 call	 ?_Insert_n@?$vector@KV?$allocator@K@std@@@std@@IAEXViterator@12@IABK@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::_Insert_n
  00049	5e		 pop	 esi

; 584  : 		}

  0004a	c2 04 00	 ret	 4
?push_back@?$vector@KV?$allocator@K@std@@@std@@QAEXABK@Z ENDP ; std::vector<unsigned long,std::allocator<unsigned long> >::push_back
_TEXT	ENDS
PUBLIC	??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
xdata$x	SEGMENT
$T354292 DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
$T354294 DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L354163
$T354293 DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:$T354294
$T354289 DD	019930520H
	DD	02H
	DD	FLAT:$T354292
	DD	01H
	DD	FLAT:$T354293
	DD	2 DUP(00H)
; Function compile flags: /Ogty
xdata$x	ENDS
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Right$ = 8						; size = 4
??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >, COMDAT
; _this$ = ecx

; 380  : 		{	// construct tree by copying _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 08	 sub	 esp, 8
  0001b	53		 push	 ebx
  0001c	56		 push	 esi
  0001d	57		 push	 edi
  0001e	8b f1		 mov	 esi, ecx
  00020	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00023	89 75 ec	 mov	 DWORD PTR _this$[ebp], esi

; 381  : 		_Init();

  00026	e8 00 00 00 00	 call	 ?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Buynode
  0002b	89 46 04	 mov	 DWORD PTR [esi+4], eax
  0002e	c6 40 15 01	 mov	 BYTE PTR [eax+21], 1
  00032	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00035	89 40 04	 mov	 DWORD PTR [eax+4], eax
  00038	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0003b	89 00		 mov	 DWORD PTR [eax], eax
  0003d	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00040	89 40 08	 mov	 DWORD PTR [eax+8], eax

; 382  : 		_TRY_BEGIN
; 383  : 		_Copy(_Right);

  00043	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00046	50		 push	 eax
  00047	8b ce		 mov	 ecx, esi
  00049	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00050	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00057	e8 00 00 00 00	 call	 ?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXABV12@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Copy

; 387  : 		_CATCH_END
; 388  : 		}

  0005c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0005f	5f		 pop	 edi
  00060	8b c6		 mov	 eax, esi
  00062	5e		 pop	 esi
  00063	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0006a	5b		 pop	 ebx
  0006b	8b e5		 mov	 esp, ebp
  0006d	5d		 pop	 ebp
  0006e	c2 04 00	 ret	 4
$L354163:

; 384  : 		_CATCH_ALL
; 385  : 		_Tidy();

  00071	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00074	e8 00 00 00 00	 call	 ?_Tidy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Tidy

; 386  : 		_RERAISE;

  00079	6a 00		 push	 0
  0007b	6a 00		 push	 0
  0007d	e8 00 00 00 00	 call	 __CxxThrowException@8
$L354295:
$L354291:
  00082	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z:
  00000	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T354289
  00005	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >
PUBLIC	?push_front@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAEXABQAU__JOINPLAYER@CGuildCombat@@@Z ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::push_front
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\list
;	COMDAT ?push_front@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAEXABQAU__JOINPLAYER@CGuildCombat@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_front@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAEXABQAU__JOINPLAYER@CGuildCombat@@@Z PROC NEAR ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::push_front, COMDAT
; _this$ = ecx

; 470  : 		{	// insert element at beginning

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	8b f1		 mov	 esi, ecx

; 471  : 		_Insert(begin(), _Val);

  00004	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00007	8b 4c 24 0c	 mov	 ecx, DWORD PTR __Val$[esp+4]
  0000b	57		 push	 edi
  0000c	8b 38		 mov	 edi, DWORD PTR [eax]
  0000e	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  00011	51		 push	 ecx
  00012	52		 push	 edx
  00013	57		 push	 edi
  00014	8b ce		 mov	 ecx, esi
  00016	e8 00 00 00 00	 call	 ?_Buynode@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAEPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@PAU342@0ABQAU__JOINPLAYER@CGuildCombat@@@Z ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Buynode
  0001b	6a 01		 push	 1
  0001d	8b ce		 mov	 ecx, esi
  0001f	8b d8		 mov	 ebx, eax
  00021	e8 00 00 00 00	 call	 ?_Incsize@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAEXI@Z ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Incsize
  00026	89 5f 04	 mov	 DWORD PTR [edi+4], ebx
  00029	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  0002c	5f		 pop	 edi
  0002d	5e		 pop	 esi
  0002e	89 18		 mov	 DWORD PTR [eax], ebx
  00030	5b		 pop	 ebx

; 472  : 		}

  00031	c2 04 00	 ret	 4
?push_front@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAEXABQAU__JOINPLAYER@CGuildCombat@@@Z ENDP ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::push_front
_TEXT	ENDS
PUBLIC	?push_back@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAEXABQAU__JOINPLAYER@CGuildCombat@@@Z ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::push_back
; Function compile flags: /Ogty
;	COMDAT ?push_back@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAEXABQAU__JOINPLAYER@CGuildCombat@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAEXABQAU__JOINPLAYER@CGuildCombat@@@Z PROC NEAR ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::push_back, COMDAT
; _this$ = ecx

; 481  : 		_Insert(end(), _Val);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Val$[esp-4]
  00004	53		 push	 ebx
  00005	56		 push	 esi
  00006	57		 push	 edi
  00007	8b f1		 mov	 esi, ecx
  00009	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]
  0000c	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  0000f	50		 push	 eax
  00010	51		 push	 ecx
  00011	57		 push	 edi
  00012	8b ce		 mov	 ecx, esi
  00014	e8 00 00 00 00	 call	 ?_Buynode@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAEPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@PAU342@0ABQAU__JOINPLAYER@CGuildCombat@@@Z ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Buynode
  00019	6a 01		 push	 1
  0001b	8b ce		 mov	 ecx, esi
  0001d	8b d8		 mov	 ebx, eax
  0001f	e8 00 00 00 00	 call	 ?_Incsize@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAEXI@Z ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Incsize
  00024	89 5f 04	 mov	 DWORD PTR [edi+4], ebx
  00027	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  0002a	5f		 pop	 edi
  0002b	5e		 pop	 esi
  0002c	89 1a		 mov	 DWORD PTR [edx], ebx
  0002e	5b		 pop	 ebx

; 482  : 		}

  0002f	c2 04 00	 ret	 4
?push_back@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAEXABQAU__JOINPLAYER@CGuildCombat@@@Z ENDP ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::push_back
_TEXT	ENDS
PUBLIC	?push_back@?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@QAEXABQAVCUser@@@Z ; std::list<CUser *,std::allocator<CUser *> >::push_back
; Function compile flags: /Ogty
;	COMDAT ?push_back@?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@QAEXABQAVCUser@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@QAEXABQAVCUser@@@Z PROC NEAR ; std::list<CUser *,std::allocator<CUser *> >::push_back, COMDAT
; _this$ = ecx

; 481  : 		_Insert(end(), _Val);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Val$[esp-4]
  00004	53		 push	 ebx
  00005	56		 push	 esi
  00006	57		 push	 edi
  00007	8b f1		 mov	 esi, ecx
  00009	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]
  0000c	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  0000f	50		 push	 eax
  00010	51		 push	 ecx
  00011	57		 push	 edi
  00012	8b ce		 mov	 ecx, esi
  00014	e8 00 00 00 00	 call	 ?_Buynode@?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@IAEPAU_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@2@PAU342@0ABQAVCUser@@@Z ; std::list<CUser *,std::allocator<CUser *> >::_Buynode
  00019	6a 01		 push	 1
  0001b	8b ce		 mov	 ecx, esi
  0001d	8b d8		 mov	 ebx, eax
  0001f	e8 00 00 00 00	 call	 ?_Incsize@?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@IAEXI@Z ; std::list<CUser *,std::allocator<CUser *> >::_Incsize
  00024	89 5f 04	 mov	 DWORD PTR [edi+4], ebx
  00027	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  0002a	5f		 pop	 edi
  0002b	5e		 pop	 esi
  0002c	89 1a		 mov	 DWORD PTR [edx], ebx
  0002e	5b		 pop	 ebx

; 482  : 		}

  0002f	c2 04 00	 ret	 4
?push_back@?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@QAEXABQAVCUser@@@Z ENDP ; std::list<CUser *,std::allocator<CUser *> >::push_back
_TEXT	ENDS
PUBLIC	??0?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@QAE@XZ ; std::vector<__ITEMINFO,std::allocator<__ITEMINFO> >::vector<__ITEMINFO,std::allocator<__ITEMINFO> >
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ??0?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@QAE@XZ PROC NEAR ; std::vector<__ITEMINFO,std::allocator<__ITEMINFO> >::vector<__ITEMINFO,std::allocator<__ITEMINFO> >, COMDAT
; _this$ = ecx

; 299  : 		{	// construct empty vector

  00000	8b c1		 mov	 eax, ecx

; 300  : 		_Buy(0);

  00002	33 c9		 xor	 ecx, ecx
  00004	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00007	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  0000a	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 301  : 		}

  0000d	c3		 ret	 0
??0?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@QAE@XZ ENDP ; std::vector<__ITEMINFO,std::allocator<__ITEMINFO> >::vector<__ITEMINFO,std::allocator<__ITEMINFO> >
_TEXT	ENDS
PUBLIC	?insert@?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@QAE?AViterator@12@V312@ABU__ITEMINFO@@@Z ; std::vector<__ITEMINFO,std::allocator<__ITEMINFO> >::insert
; Function compile flags: /Ogty
;	COMDAT ?insert@?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@QAE?AViterator@12@V312@ABU__ITEMINFO@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
tv90 = 12						; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@QAE?AViterator@12@V312@ABU__ITEMINFO@@@Z PROC NEAR ; std::vector<__ITEMINFO,std::allocator<__ITEMINFO> >::insert, COMDAT
; _this$ = ecx

; 620  : 		{	// insert _Val at _Where

  00000	53		 push	 ebx

; 621  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

  00001	8b 5c 24 0c	 mov	 ebx, DWORD PTR __Where$[esp]
  00005	56		 push	 esi
  00006	57		 push	 edi
  00007	8b f9		 mov	 edi, ecx
  00009	8b 77 04	 mov	 esi, DWORD PTR [edi+4]
  0000c	85 f6		 test	 esi, esi
  0000e	74 1b		 je	 SHORT $L354584
  00010	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  00013	2b ce		 sub	 ecx, esi
  00015	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0001a	f7 e9		 imul	 ecx
  0001c	d1 fa		 sar	 edx, 1
  0001e	8b c2		 mov	 eax, edx
  00020	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00023	03 c2		 add	 eax, edx
  00025	89 44 24 14	 mov	 DWORD PTR tv90[esp+8], eax
  00029	75 04		 jne	 SHORT $L354523
$L354584:
  0002b	33 f6		 xor	 esi, esi
  0002d	eb 14		 jmp	 SHORT $L354524
$L354523:
  0002f	8b cb		 mov	 ecx, ebx
  00031	2b ce		 sub	 ecx, esi
  00033	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00038	f7 e9		 imul	 ecx
  0003a	d1 fa		 sar	 edx, 1
  0003c	8b f2		 mov	 esi, edx
  0003e	c1 ee 1f	 shr	 esi, 31			; 0000001fH
  00041	03 f2		 add	 esi, edx
$L354524:

; 622  : 		_Insert_n(_Where, (size_type)1, _Val);

  00043	8b 4c 24 18	 mov	 ecx, DWORD PTR __Val$[esp+8]
  00047	51		 push	 ecx
  00048	6a 01		 push	 1
  0004a	53		 push	 ebx
  0004b	8b cf		 mov	 ecx, edi
  0004d	e8 00 00 00 00	 call	 ?_Insert_n@?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@IAEXViterator@12@IABU__ITEMINFO@@@Z ; std::vector<__ITEMINFO,std::allocator<__ITEMINFO> >::_Insert_n

; 623  : 		return (begin() + _Off);

  00052	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00055	8d 14 76	 lea	 edx, DWORD PTR [esi+esi*2]
  00058	5f		 pop	 edi
  00059	8d 0c 90	 lea	 ecx, DWORD PTR [eax+edx*4]
  0005c	8b 44 24 0c	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp+4]
  00060	5e		 pop	 esi
  00061	89 08		 mov	 DWORD PTR [eax], ecx
  00063	5b		 pop	 ebx

; 624  : 		}

  00064	c2 0c 00	 ret	 12			; 0000000cH
?insert@?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@QAE?AViterator@12@V312@ABU__ITEMINFO@@@Z ENDP ; std::vector<__ITEMINFO,std::allocator<__ITEMINFO> >::insert
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Destroy
; Function compile flags: /Ogty
;	COMDAT ?_Destroy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Cat$354598 = 12					; size = 1
__Last$ = 12						; size = 4
?_Destroy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z PROC NEAR ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Destroy, COMDAT
; _this$ = ecx

; 787  : 		_Destroy_range(_First, _Last, this->_Alval);

  00000	8b 44 24 08	 mov	 eax, DWORD PTR __Cat$354598[esp-4]
  00004	8b 54 24 04	 mov	 edx, DWORD PTR __First$[esp-4]
  00008	50		 push	 eax
  00009	51		 push	 ecx
  0000a	8b 4c 24 10	 mov	 ecx, DWORD PTR __Last$[esp+4]
  0000e	51		 push	 ecx
  0000f	52		 push	 edx
  00010	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
  00015	83 c4 10	 add	 esp, 16			; 00000010H

; 788  : 		}

  00018	c2 08 00	 ret	 8
?_Destroy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Destroy
_TEXT	ENDS
PUBLIC	?PCRemoveKey@CCtrl@@QAEHK@Z			; CCtrl::PCRemoveKey
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\ctrl.h
;	COMDAT ?PCRemoveKey@CCtrl@@QAEHK@Z
_TEXT	SEGMENT
_objid$ = 8						; size = 4
?PCRemoveKey@CCtrl@@QAEHK@Z PROC NEAR			; CCtrl::PCRemoveKey, COMDAT
; _this$ = ecx

; 120  : 	return m_2pc.erase( objid ) > 0;

  00000	8d 44 24 04	 lea	 eax, DWORD PTR _objid$[esp-4]
  00004	50		 push	 eax
  00005	81 c1 0c 02 00
	00		 add	 ecx, 524		; 0000020cH
  0000b	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAEIABK@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::erase
  00010	33 c9		 xor	 ecx, ecx
  00012	3b c8		 cmp	 ecx, eax
  00014	1b c0		 sbb	 eax, eax
  00016	f7 d8		 neg	 eax

; 121  : }

  00018	c2 04 00	 ret	 4
?PCRemoveKey@CCtrl@@QAEHK@Z ENDP			; CCtrl::PCRemoveKey
_TEXT	ENDS
PUBLIC	??$_Uninitialized_fill_n@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IABV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Uninitialized_fill_n<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\memory
;	COMDAT ??$_Uninitialized_fill_n@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IABV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z
_TEXT	SEGMENT
__Cat$354612 = -4					; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_fill_n@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IABV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z PROC NEAR ; std::_Uninitialized_fill_n<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT

; 255  : 	{	// copy _Count *_Val to raw _First, using _Al

  00000	51		 push	 ecx

; 256  : 	_Uninit_fill_n(_First, _Count, _Val, _Al,
; 257  : 		_Ptr_cat(_First, _First));

  00001	8b 04 24	 mov	 eax, DWORD PTR __Cat$354612[esp+4]
  00004	8b 4c 24 14	 mov	 ecx, DWORD PTR __Al$[esp]
  00008	8b 54 24 10	 mov	 edx, DWORD PTR __Val$[esp]
  0000c	50		 push	 eax
  0000d	8b 44 24 10	 mov	 eax, DWORD PTR __Count$[esp+4]
  00011	51		 push	 ecx
  00012	8b 4c 24 10	 mov	 ecx, DWORD PTR __First$[esp+8]
  00016	52		 push	 edx
  00017	50		 push	 eax
  00018	51		 push	 ecx
  00019	e8 00 00 00 00	 call	 ??$_Uninit_fill_n@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IABV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >

; 258  : 	}

  0001e	83 c4 18	 add	 esp, 24			; 00000018H
  00021	c3		 ret	 0
??$_Uninitialized_fill_n@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IABV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ENDP ; std::_Uninitialized_fill_n<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
PUBLIC	??$_Ucopy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PAV21@00@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Ucopy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ??$_Ucopy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PAV21@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$354626 = 16					; size = 1
__Ptr$ = 16						; size = 4
??$_Ucopy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PAV21@00@Z PROC NEAR ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Ucopy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>, COMDAT
; _this$ = ecx

; 802  : 		{	// copy initializing [_First, _Last), using allocator
; 803  : 		return (_Uninitialized_copy(_First, _Last,
; 804  : 			_Ptr, this->_Alval));

  00000	8b 44 24 0c	 mov	 eax, DWORD PTR __Cat$354626[esp-4]
  00004	8b 54 24 08	 mov	 edx, DWORD PTR __Last$[esp-4]
  00008	50		 push	 eax
  00009	8b 44 24 08	 mov	 eax, DWORD PTR __First$[esp]
  0000d	51		 push	 ecx
  0000e	8b 4c 24 14	 mov	 ecx, DWORD PTR __Ptr$[esp+4]
  00012	51		 push	 ecx
  00013	52		 push	 edx
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 ??$_Uninit_copy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
  0001a	83 c4 14	 add	 esp, 20			; 00000014H

; 805  : 		}

  0001d	c2 0c 00	 ret	 12			; 0000000cH
??$_Ucopy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PAV21@00@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Ucopy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
_TEXT	ENDS
PUBLIC	??A?$map@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@@std@@QAEAAPAVCUser@@ABK@Z ; std::map<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> > >::operator[]
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\map
;	COMDAT ??A?$map@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@@std@@QAEAAPAVCUser@@ABK@Z
_TEXT	SEGMENT
$T354634 = -8						; size = 8
$T354636 = 8						; size = 4
__Keyval$ = 8						; size = 4
??A?$map@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@@std@@QAEAAPAVCUser@@ABK@Z PROC NEAR ; std::map<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> > >::operator[], COMDAT
; _this$ = ecx

; 143  : 		iterator _Where = this->lower_bound(_Keyval);

  00000	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00003	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00006	83 ec 08	 sub	 esp, 8
  00009	53		 push	 ebx
  0000a	8a 58 15	 mov	 bl, BYTE PTR [eax+21]
  0000d	84 db		 test	 bl, bl
  0000f	56		 push	 esi
  00010	8b 74 24 14	 mov	 esi, DWORD PTR __Keyval$[esp+12]
  00014	57		 push	 edi
  00015	75 1e		 jne	 SHORT $L354731
  00017	8b 3e		 mov	 edi, DWORD PTR [esi]
  00019	8d a4 24 00 00
	00 00		 npad	 7
$L354730:
  00020	39 78 0c	 cmp	 DWORD PTR [eax+12], edi
  00023	73 05		 jae	 SHORT $L354732
  00025	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00028	eb 04		 jmp	 SHORT $L354733
$L354732:
  0002a	8b d0		 mov	 edx, eax
  0002c	8b 00		 mov	 eax, DWORD PTR [eax]
$L354733:
  0002e	8a 58 15	 mov	 bl, BYTE PTR [eax+21]
  00031	84 db		 test	 bl, bl
  00033	74 eb		 je	 SHORT $L354730
$L354731:

; 144  : 		if (_Where == this->end() || this->comp(_Keyval, this->_Key(_Where._Mynode())))

  00035	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  00038	74 07		 je	 SHORT $L219001
  0003a	8b 06		 mov	 eax, DWORD PTR [esi]
  0003c	3b 42 0c	 cmp	 eax, DWORD PTR [edx+12]
  0003f	73 2c		 jae	 SHORT $L354795
$L219001:

; 145  : 			_Where = this->insert(_Where,
; 146  : 				value_type(_Keyval, mapped_type()));

  00041	8b 06		 mov	 eax, DWORD PTR [esi]
  00043	89 44 24 0c	 mov	 DWORD PTR $T354634[esp+20], eax
  00047	8d 44 24 0c	 lea	 eax, DWORD PTR $T354634[esp+20]
  0004b	50		 push	 eax
  0004c	52		 push	 edx
  0004d	8d 54 24 20	 lea	 edx, DWORD PTR $T354636[esp+24]
  00051	52		 push	 edx
  00052	c7 44 24 1c 00
	00 00 00	 mov	 DWORD PTR $T354634[esp+36], 0
  0005a	e8 00 00 00 00	 call	 ?insert@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@ABU?$pair@$$CBKPAVCUser@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::insert
  0005f	8b 00		 mov	 eax, DWORD PTR [eax]
  00061	5f		 pop	 edi
  00062	5e		 pop	 esi

; 147  : 		return ((*_Where).second);

  00063	83 c0 10	 add	 eax, 16			; 00000010H
  00066	5b		 pop	 ebx

; 148  : 		}

  00067	83 c4 08	 add	 esp, 8
  0006a	c2 04 00	 ret	 4
$L354795:
  0006d	5f		 pop	 edi
  0006e	5e		 pop	 esi

; 147  : 		return ((*_Where).second);

  0006f	8d 42 10	 lea	 eax, DWORD PTR [edx+16]
  00072	5b		 pop	 ebx

; 148  : 		}

  00073	83 c4 08	 add	 esp, 8
  00076	c2 04 00	 ret	 4
??A?$map@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@@std@@QAEAAPAVCUser@@ABK@Z ENDP ; std::map<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> > >::operator[]
_TEXT	ENDS
PUBLIC	??1?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::~_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ??1?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T354866 = -4						; size = 4
??1?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::~_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >, COMDAT
; _this$ = ecx

; 391  : 		{	// destroy tree

  00000	51		 push	 ecx
  00001	56		 push	 esi
  00002	8b f1		 mov	 esi, ecx

; 392  : 		_Tidy();

  00004	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00007	8b 08		 mov	 ecx, DWORD PTR [eax]
  00009	50		 push	 eax
  0000a	51		 push	 ecx
  0000b	8d 44 24 0c	 lea	 eax, DWORD PTR $T354866[esp+16]
  0000f	50		 push	 eax
  00010	8b ce		 mov	 ecx, esi
  00012	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@V312@0@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::erase
  00017	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0001a	51		 push	 ecx
  0001b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00020	83 c4 04	 add	 esp, 4
  00023	33 c0		 xor	 eax, eax
  00025	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00028	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0002b	5e		 pop	 esi

; 393  : 		}

  0002c	59		 pop	 ecx
  0002d	c3		 ret	 0
??1?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::~_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >
_TEXT	ENDS
PUBLIC	??1?$map@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@@std@@QAE@XZ ; std::map<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> > >::~map<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> > >
; Function compile flags: /Ogty
;	COMDAT ??1?$map@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@@std@@QAE@XZ
_TEXT	SEGMENT
$T354993 = -4						; size = 4
??1?$map@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@@std@@QAE@XZ PROC NEAR ; std::map<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> > >::~map<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> > >, COMDAT
; _this$ = ecx
  00000	51		 push	 ecx
  00001	56		 push	 esi
  00002	8b f1		 mov	 esi, ecx
  00004	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00007	8b 08		 mov	 ecx, DWORD PTR [eax]
  00009	50		 push	 eax
  0000a	51		 push	 ecx
  0000b	8d 44 24 0c	 lea	 eax, DWORD PTR $T354993[esp+16]
  0000f	50		 push	 eax
  00010	8b ce		 mov	 ecx, esi
  00012	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::erase
  00017	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0001a	51		 push	 ecx
  0001b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00020	83 c4 04	 add	 esp, 4
  00023	33 c0		 xor	 eax, eax
  00025	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00028	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0002b	5e		 pop	 esi
  0002c	59		 pop	 ecx
  0002d	c3		 ret	 0
??1?$map@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@@std@@QAE@XZ ENDP ; std::map<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> > >::~map<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> > >
_TEXT	ENDS
PUBLIC	?RemoveItFromView2@CUser@@QAEXH@Z		; CUser::RemoveItFromView2
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
;	COMDAT ?RemoveItFromView2@CUser@@QAEXH@Z
_TEXT	SEGMENT
_it$ = -16						; size = 4
$T355492 = -12						; size = 4
$T355498 = -12						; size = 4
__Where$355494 = -8					; size = 8
_bRemoveall$ = 8					; size = 4
?RemoveItFromView2@CUser@@QAEXH@Z PROC NEAR		; CUser::RemoveItFromView2, COMDAT
; _this$ = ecx

; 292  : {

  00000	83 ec 10	 sub	 esp, 16			; 00000010H
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	57		 push	 edi
  00006	8b f9		 mov	 edi, ecx

; 293  : 	CCtrl* pCtrl;
; 294  : 
; 295  : 	map<DWORD, CCtrl*>::iterator it = m_2npc.begin();

  00008	8b 8f 14 57 00
	00		 mov	 ecx, DWORD PTR [edi+22292]
  0000e	8b 01		 mov	 eax, DWORD PTR [ecx]

; 296  : 	for( ; it != m_2npc.end(); ++it )

  00010	3b c1		 cmp	 eax, ecx
  00012	89 44 24 0c	 mov	 DWORD PTR _it$[esp+28], eax
  00016	0f 84 a6 00 00
	00		 je	 $L277918
  0001c	8d 64 24 00	 npad	 4
$L355056:

; 297  : 	{
; 298  : 		pCtrl = it->second;
; 299  : 		pCtrl->PCRemoveKey( GetId() );

  00020	8b 70 10	 mov	 esi, DWORD PTR [eax+16]
  00023	8b 8f bc 01 00
	00		 mov	 ecx, DWORD PTR [edi+444]
  00029	8d 54 24 10	 lea	 edx, DWORD PTR $T355498[esp+28]
  0002d	52		 push	 edx
  0002e	8d 44 24 18	 lea	 eax, DWORD PTR __Where$355494[esp+32]
  00032	89 4c 24 14	 mov	 DWORD PTR $T355498[esp+32], ecx
  00036	81 c6 0c 02 00
	00		 add	 esi, 524		; 0000020cH
  0003c	50		 push	 eax
  0003d	8b ce		 mov	 ecx, esi
  0003f	e8 00 00 00 00	 call	 ?equal_range@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@V123@@2@ABK@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::equal_range
  00044	8b 54 24 14	 mov	 edx, DWORD PTR __Where$355494[esp+28]
  00048	8b 5c 24 18	 mov	 ebx, DWORD PTR __Where$355494[esp+32]
  0004c	3b d3		 cmp	 edx, ebx
  0004e	8b ca		 mov	 ecx, edx
  00050	74 49		 je	 SHORT $L355490
$L355454:
  00052	8a 41 15	 mov	 al, BYTE PTR [ecx+21]
  00055	84 c0		 test	 al, al
  00057	75 3e		 jne	 SHORT $L355601
  00059	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  0005c	80 78 15 00	 cmp	 BYTE PTR [eax+21], 0
  00060	75 1a		 jne	 SHORT $L355597
  00062	8b c8		 mov	 ecx, eax
  00064	8b 01		 mov	 eax, DWORD PTR [ecx]
  00066	80 78 15 00	 cmp	 BYTE PTR [eax+21], 0
  0006a	75 2b		 jne	 SHORT $L355601
  0006c	8d 64 24 00	 npad	 4
$L355468:
  00070	8b c8		 mov	 ecx, eax
  00072	8b 01		 mov	 eax, DWORD PTR [ecx]
  00074	80 78 15 00	 cmp	 BYTE PTR [eax+21], 0
  00078	74 f6		 je	 SHORT $L355468
  0007a	eb 1b		 jmp	 SHORT $L355601
$L355597:
  0007c	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0007f	80 78 15 00	 cmp	 BYTE PTR [eax+21], 0
  00083	75 10		 jne	 SHORT $L355457
$L355456:
  00085	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  00088	75 0b		 jne	 SHORT $L355457
  0008a	8b c8		 mov	 ecx, eax
  0008c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0008f	80 78 15 00	 cmp	 BYTE PTR [eax+21], 0
  00093	74 f0		 je	 SHORT $L355456
$L355457:
  00095	8b c8		 mov	 ecx, eax
$L355601:
  00097	3b cb		 cmp	 ecx, ebx
  00099	75 b7		 jne	 SHORT $L355454
$L355490:
  0009b	53		 push	 ebx
  0009c	52		 push	 edx
  0009d	8d 4c 24 18	 lea	 ecx, DWORD PTR $T355492[esp+36]
  000a1	51		 push	 ecx
  000a2	8b ce		 mov	 ecx, esi
  000a4	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::erase
  000a9	8d 4c 24 0c	 lea	 ecx, DWORD PTR _it$[esp+28]
  000ad	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::const_iterator::_Inc
  000b2	8b 44 24 0c	 mov	 eax, DWORD PTR _it$[esp+28]
  000b6	3b 87 14 57 00
	00		 cmp	 eax, DWORD PTR [edi+22292]
  000bc	0f 85 5e ff ff
	ff		 jne	 $L355056
$L277918:

; 300  : 	}
; 301  : 	if( bRemoveall )

  000c2	8b 44 24 20	 mov	 eax, DWORD PTR _bRemoveall$[esp+24]
  000c6	85 c0		 test	 eax, eax
  000c8	74 4f		 je	 SHORT $L355592

; 302  : 		m_2npc.clear();

  000ca	8b 97 14 57 00
	00		 mov	 edx, DWORD PTR [edi+22292]
  000d0	8b 5a 04	 mov	 ebx, DWORD PTR [edx+4]
  000d3	8a 43 15	 mov	 al, BYTE PTR [ebx+21]
  000d6	81 c7 10 57 00
	00		 add	 edi, 22288		; 00005710H
  000dc	84 c0		 test	 al, al
  000de	8b f3		 mov	 esi, ebx
  000e0	75 1f		 jne	 SHORT $L355579
$L355577:
  000e2	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000e5	50		 push	 eax
  000e6	8b cf		 mov	 ecx, edi
  000e8	e8 00 00 00 00	 call	 ?_Erase@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::_Erase
  000ed	8b 36		 mov	 esi, DWORD PTR [esi]
  000ef	53		 push	 ebx
  000f0	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000f5	8a 46 15	 mov	 al, BYTE PTR [esi+21]
  000f8	83 c4 04	 add	 esp, 4
  000fb	84 c0		 test	 al, al
  000fd	8b de		 mov	 ebx, esi
  000ff	74 e1		 je	 SHORT $L355577
$L355579:
  00101	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00104	89 40 04	 mov	 DWORD PTR [eax+4], eax
  00107	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0010a	c7 47 08 00 00
	00 00		 mov	 DWORD PTR [edi+8], 0
  00111	89 00		 mov	 DWORD PTR [eax], eax
  00113	8b 7f 04	 mov	 edi, DWORD PTR [edi+4]
  00116	89 7f 08	 mov	 DWORD PTR [edi+8], edi
$L355592:
  00119	5f		 pop	 edi
  0011a	5e		 pop	 esi
  0011b	5b		 pop	 ebx

; 303  : }

  0011c	83 c4 10	 add	 esp, 16			; 00000010H
  0011f	c2 04 00	 ret	 4
?RemoveItFromView2@CUser@@QAEXH@Z ENDP			; CUser::RemoveItFromView2
_TEXT	ENDS
PUBLIC	?AddPlayerData@CUser@@QAEXXZ			; CUser::AddPlayerData
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
xdata$x	SEGMENT
$T356662 DD	0ffffffffH
	DD	FLAT:$L355608
$T356645 DD	019930520H
	DD	01H
	DD	FLAT:$T356662
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
xdata$x	ENDS
;	COMDAT ?AddPlayerData@CUser@@QAEXXZ
_TEXT	SEGMENT
_i1$278734 = -36					; size = 4
_this$ = -32						; size = 4
_aPlayer$ = -28						; size = 16
__$EHRec$ = -12						; size = 12
?AddPlayerData@CUser@@QAEXXZ PROC NEAR			; CUser::AddPlayerData, COMDAT
; _this$ = ecx

; 1800 : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?AddPlayerData@CUser@@QAEXXZ
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	83 ec 18	 sub	 esp, 24			; 00000018H
  00018	53		 push	 ebx
  00019	55		 push	 ebp
  0001a	56		 push	 esi
  0001b	57		 push	 edi
  0001c	8b f1		 mov	 esi, ecx

; 1801 : 	vector<u_long>	aPlayer;

  0001e	33 ed		 xor	 ebp, ebp
  00020	33 ff		 xor	 edi, edi
  00022	33 db		 xor	 ebx, ebx
  00024	89 74 24 14	 mov	 DWORD PTR _this$[esp+52], esi
  00028	89 7c 24 1c	 mov	 DWORD PTR _aPlayer$[esp+56], edi
  0002c	89 5c 24 20	 mov	 DWORD PTR _aPlayer$[esp+60], ebx
  00030	89 6c 24 24	 mov	 DWORD PTR _aPlayer$[esp+64], ebp

; 1802 : #ifdef __RT_1025
; 1803 : 	for( map<u_long, Friend>::iterator i1 = m_RTMessenger.begin(); i1 != m_RTMessenger.end(); ++i1 )

  00034	8b 8e 54 95 00
	00		 mov	 ecx, DWORD PTR [esi+38228]
  0003a	8b 01		 mov	 eax, DWORD PTR [ecx]
  0003c	3b c1		 cmp	 eax, ecx
  0003e	89 6c 24 30	 mov	 DWORD PTR __$EHRec$[esp+60], ebp
  00042	89 44 24 10	 mov	 DWORD PTR _i1$278734[esp+52], eax
  00046	74 52		 je	 SHORT $L278739
$L356660:

; 1804 : 		aPlayer.push_back( i1->first );

  00048	3b fd		 cmp	 edi, ebp
  0004a	8d 50 0c	 lea	 edx, DWORD PTR [eax+12]
  0004d	74 21		 je	 SHORT $L355962
  0004f	8b 4c 24 24	 mov	 ecx, DWORD PTR _aPlayer$[esp+64]
  00053	8b c3		 mov	 eax, ebx
  00055	2b c7		 sub	 eax, edi
  00057	2b cf		 sub	 ecx, edi
  00059	c1 f8 02	 sar	 eax, 2
  0005c	c1 f9 02	 sar	 ecx, 2
  0005f	3b c1		 cmp	 eax, ecx
  00061	73 0d		 jae	 SHORT $L355962
  00063	8b 02		 mov	 eax, DWORD PTR [edx]
  00065	89 03		 mov	 DWORD PTR [ebx], eax
  00067	83 c3 04	 add	 ebx, 4
  0006a	89 5c 24 20	 mov	 DWORD PTR _aPlayer$[esp+60], ebx
  0006e	eb 15		 jmp	 SHORT $L278738
$L355962:
  00070	52		 push	 edx
  00071	6a 01		 push	 1
  00073	53		 push	 ebx
  00074	8d 4c 24 24	 lea	 ecx, DWORD PTR _aPlayer$[esp+64]
  00078	e8 00 00 00 00	 call	 ?_Insert_n@?$vector@KV?$allocator@K@std@@@std@@IAEXViterator@12@IABK@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::_Insert_n
  0007d	8b 5c 24 20	 mov	 ebx, DWORD PTR _aPlayer$[esp+60]
  00081	8b 7c 24 1c	 mov	 edi, DWORD PTR _aPlayer$[esp+56]
$L278738:
  00085	8d 4c 24 10	 lea	 ecx, DWORD PTR _i1$278734[esp+52]
  00089	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned long,_Friend,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,_Friend> >,0> >::const_iterator::_Inc
  0008e	8b 44 24 10	 mov	 eax, DWORD PTR _i1$278734[esp+52]
  00092	3b 86 54 95 00
	00		 cmp	 eax, DWORD PTR [esi+38228]
  00098	75 ae		 jne	 SHORT $L356660
$L278739:

; 1805 : #else	// __RT_1025
; 1806 : 	for( map<u_long, FRIEND*>::iterator i1 = m_Messenger.m_aFriend.begin(); i1 != m_Messenger.m_aFriend.end(); ++i1 )
; 1807 : 	{
; 1808 : 		if( i1->second )
; 1809 : 			aPlayer.push_back( i1->second->dwUserId );
; 1810 : 	}
; 1811 : #endif	//__RT_1025
; 1812 : 	CGuild* pGuild	= GetGuild();

  0009a	8b ce		 mov	 ecx, esi
  0009c	e8 00 00 00 00	 call	 ?GetGuild@CMover@@QAEPAVCGuild@@XZ ; CMover::GetGuild
  000a1	8b e8		 mov	 ebp, eax

; 1813 : 	if( pGuild )

  000a3	85 ed		 test	 ebp, ebp
  000a5	0f 84 a1 00 00
	00		 je	 $L356659

; 1814 : 	{
; 1815 : 		for( map<u_long, CGuildMember*>::iterator i2 = pGuild->m_mapPMember.begin(); i2 != pGuild->m_mapPMember.end(); ++i2 )

  000ab	8b 45 3c	 mov	 eax, DWORD PTR [ebp+60]
  000ae	8b 30		 mov	 esi, DWORD PTR [eax]
  000b0	3b f0		 cmp	 esi, eax
  000b2	0f 84 94 00 00
	00		 je	 $L356659
$L356172:

; 1816 : 			aPlayer.push_back( i2->second->m_idPlayer );

  000b8	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  000bb	83 c2 04	 add	 edx, 4
  000be	85 ff		 test	 edi, edi
  000c0	74 21		 je	 SHORT $L356473
  000c2	8b 4c 24 24	 mov	 ecx, DWORD PTR _aPlayer$[esp+64]
  000c6	8b c3		 mov	 eax, ebx
  000c8	2b c7		 sub	 eax, edi
  000ca	2b cf		 sub	 ecx, edi
  000cc	c1 f8 02	 sar	 eax, 2
  000cf	c1 f9 02	 sar	 ecx, 2
  000d2	3b c1		 cmp	 eax, ecx
  000d4	73 0d		 jae	 SHORT $L356473
  000d6	8b 0a		 mov	 ecx, DWORD PTR [edx]
  000d8	89 0b		 mov	 DWORD PTR [ebx], ecx
  000da	83 c3 04	 add	 ebx, 4
  000dd	89 5c 24 20	 mov	 DWORD PTR _aPlayer$[esp+60], ebx
  000e1	eb 15		 jmp	 SHORT $L278848
$L356473:
  000e3	52		 push	 edx
  000e4	6a 01		 push	 1
  000e6	53		 push	 ebx
  000e7	8d 4c 24 24	 lea	 ecx, DWORD PTR _aPlayer$[esp+64]
  000eb	e8 00 00 00 00	 call	 ?_Insert_n@?$vector@KV?$allocator@K@std@@@std@@IAEXViterator@12@IABK@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::_Insert_n
  000f0	8b 5c 24 20	 mov	 ebx, DWORD PTR _aPlayer$[esp+60]
  000f4	8b 7c 24 1c	 mov	 edi, DWORD PTR _aPlayer$[esp+56]
$L278848:
  000f8	8a 46 15	 mov	 al, BYTE PTR [esi+21]
  000fb	84 c0		 test	 al, al
  000fd	75 44		 jne	 SHORT $L356180
  000ff	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00102	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00105	84 c9		 test	 cl, cl
  00107	75 18		 jne	 SHORT $L356651
  00109	8b f0		 mov	 esi, eax
  0010b	8b 06		 mov	 eax, DWORD PTR [esi]
  0010d	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00110	84 c9		 test	 cl, cl
  00112	75 2f		 jne	 SHORT $L356180

; 1814 : 	{
; 1815 : 		for( map<u_long, CGuildMember*>::iterator i2 = pGuild->m_mapPMember.begin(); i2 != pGuild->m_mapPMember.end(); ++i2 )

$L356194:
  00114	8b f0		 mov	 esi, eax
  00116	8b 06		 mov	 eax, DWORD PTR [esi]
  00118	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  0011b	84 c9		 test	 cl, cl
  0011d	74 f5		 je	 SHORT $L356194
  0011f	eb 22		 jmp	 SHORT $L356180
$L356651:
  00121	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00124	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00127	84 c9		 test	 cl, cl
  00129	75 16		 jne	 SHORT $L356183
  0012b	eb 03 8d 49 00	 npad	 5
$L356182:
  00130	3b 70 08	 cmp	 esi, DWORD PTR [eax+8]
  00133	75 0c		 jne	 SHORT $L356183
  00135	8b f0		 mov	 esi, eax
  00137	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0013a	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  0013d	84 c9		 test	 cl, cl
  0013f	74 ef		 je	 SHORT $L356182
$L356183:
  00141	8b f0		 mov	 esi, eax
$L356180:
  00143	3b 75 3c	 cmp	 esi, DWORD PTR [ebp+60]
  00146	0f 85 6c ff ff
	ff		 jne	 $L356172
$L356659:

; 1817 : 	}
; 1818 : 	for( int i = 0; i < (int)( aPlayer.size() ); i++ )

  0014c	33 f6		 xor	 esi, esi
  0014e	8b ff		 npad	 2
$L278872:
  00150	85 ff		 test	 edi, edi
  00152	75 04		 jne	 SHORT $L356512
  00154	33 c0		 xor	 eax, eax
  00156	eb 07		 jmp	 SHORT $L356513
$L356512:
  00158	8b c3		 mov	 eax, ebx
  0015a	2b c7		 sub	 eax, edi
  0015c	c1 f8 02	 sar	 eax, 2
$L356513:
  0015f	3b f0		 cmp	 esi, eax
  00161	7d 25		 jge	 SHORT $L278874

; 1819 : 	{
; 1820 : 		PlayerData* pPlayerData	= CPlayerDataCenter::GetInstance()->GetPlayerData( aPlayer[i] );

  00163	8b 14 b7	 mov	 edx, DWORD PTR [edi+esi*4]
  00166	52		 push	 edx
  00167	e8 00 00 00 00	 call	 ?GetInstance@CPlayerDataCenter@@SAPAV1@XZ ; CPlayerDataCenter::GetInstance
  0016c	8b c8		 mov	 ecx, eax
  0016e	e8 00 00 00 00	 call	 ?GetPlayerData@CPlayerDataCenter@@QAEPAU_PlayerData@@K@Z ; CPlayerDataCenter::GetPlayerData

; 1821 : 		if( pPlayerData )

  00173	85 c0		 test	 eax, eax
  00175	74 0e		 je	 SHORT $L278873

; 1822 : 			AddQueryPlayerData( aPlayer[i], pPlayerData );

  00177	8b 4c 24 14	 mov	 ecx, DWORD PTR _this$[esp+52]
  0017b	50		 push	 eax
  0017c	8b 04 b7	 mov	 eax, DWORD PTR [edi+esi*4]
  0017f	50		 push	 eax
  00180	e8 00 00 00 00	 call	 ?AddQueryPlayerData@CUser@@QAEXKPAU_PlayerData@@@Z ; CUser::AddQueryPlayerData
$L278873:

; 1817 : 	}
; 1818 : 	for( int i = 0; i < (int)( aPlayer.size() ); i++ )

  00185	46		 inc	 esi
  00186	eb c8		 jmp	 SHORT $L278872
$L278874:

; 1823 : 	}
; 1824 : }

  00188	85 ff		 test	 edi, edi
  0018a	74 09		 je	 SHORT $L356641
  0018c	57		 push	 edi
  0018d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00192	83 c4 04	 add	 esp, 4
$L356641:
  00195	8b 4c 24 28	 mov	 ecx, DWORD PTR __$EHRec$[esp+52]
  00199	5f		 pop	 edi
  0019a	5e		 pop	 esi
  0019b	5d		 pop	 ebp
  0019c	5b		 pop	 ebx
  0019d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  001a4	83 c4 24	 add	 esp, 36			; 00000024H
  001a7	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L355608:
  00000	8d 4d e4	 lea	 ecx, DWORD PTR _aPlayer$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$vector@KV?$allocator@K@std@@@std@@QAE@XZ ; std::vector<unsigned long,std::allocator<unsigned long> >::~vector<unsigned long,std::allocator<unsigned long> >
__ehhandler$?AddPlayerData@CUser@@QAEXXZ:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T356645
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?AddPlayerData@CUser@@QAEXXZ ENDP			; CUser::AddPlayerData
PUBLIC	??1?$map@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@@std@@QAE@XZ ; std::map<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> > >::~map<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> > >
; Function compile flags: /Ogty
;	COMDAT ??1?$map@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@@std@@QAE@XZ
_TEXT	SEGMENT
$T356767 = -4						; size = 4
??1?$map@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@@std@@QAE@XZ PROC NEAR ; std::map<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> > >::~map<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> > >, COMDAT
; _this$ = ecx
  00000	51		 push	 ecx
  00001	56		 push	 esi
  00002	8b f1		 mov	 esi, ecx
  00004	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00007	8b 08		 mov	 ecx, DWORD PTR [eax]
  00009	50		 push	 eax
  0000a	51		 push	 ecx
  0000b	8d 44 24 0c	 lea	 eax, DWORD PTR $T356767[esp+16]
  0000f	50		 push	 eax
  00010	8b ce		 mov	 ecx, esi
  00012	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::erase
  00017	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0001a	51		 push	 ecx
  0001b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00020	83 c4 04	 add	 esp, 4
  00023	33 c0		 xor	 eax, eax
  00025	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00028	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0002b	5e		 pop	 esi
  0002c	59		 pop	 ecx
  0002d	c3		 ret	 0
??1?$map@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@@std@@QAE@XZ ENDP ; std::map<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> > >::~map<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> > >
_TEXT	ENDS
PUBLIC	??_7CUserMng@@6B@				; CUserMng::`vftable'
PUBLIC	??_GCUserMng@@UAEPAXI@Z				; CUserMng::`scalar deleting destructor'
PUBLIC	??1CUserMng@@UAE@XZ				; CUserMng::~CUserMng
EXTRN	??_ECUserMng@@UAEPAXI@Z:NEAR			; CUserMng::`vector deleting destructor'
;	COMDAT ??_7CUserMng@@6B@
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
CONST	SEGMENT
??_7CUserMng@@6B@ DD FLAT:??_ECUserMng@@UAEPAXI@Z	; CUserMng::`vftable'
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
CONST	ENDS
;	COMDAT ??1CUserMng@@UAE@XZ
_TEXT	SEGMENT
$T356930 = -4						; size = 4
??1CUserMng@@UAE@XZ PROC NEAR				; CUserMng::~CUserMng, COMDAT
; _this$ = ecx

; 3861 : {

  00000	51		 push	 ecx
  00001	56		 push	 esi

; 3862 : }

  00002	8d 71 08	 lea	 esi, DWORD PTR [ecx+8]
  00005	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET FLAT:??_7CUserMng@@6B@
  0000b	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0000e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	8d 44 24 0c	 lea	 eax, DWORD PTR $T356930[esp+16]
  00016	50		 push	 eax
  00017	8b ce		 mov	 ecx, esi
  00019	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::erase
  0001e	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00021	51		 push	 ecx
  00022	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00027	83 c4 04	 add	 esp, 4
  0002a	33 c0		 xor	 eax, eax
  0002c	89 46 04	 mov	 DWORD PTR [esi+4], eax
  0002f	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00032	5e		 pop	 esi
  00033	59		 pop	 ecx
  00034	c3		 ret	 0
??1CUserMng@@UAE@XZ ENDP				; CUserMng::~CUserMng
_TEXT	ENDS
PUBLIC	?AddGCGuildStatus@CUserMng@@QAEXKPAVCUser@@@Z	; CUserMng::AddGCGuildStatus
EXTRN	?FindGuildCombatMember@CGuildCombat@@QAEPAU__GuildCombatMember@1@K@Z:NEAR ; CGuildCombat::FindGuildCombatMember
;	COMDAT xdata$x
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\obj.h
xdata$x	SEGMENT
$T358041 DD	0ffffffffH
	DD	FLAT:$L356968
	DD	00H
	DD	FLAT:$L356969
$T358021 DD	019930520H
	DD	02H
	DD	FLAT:$T358041
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
xdata$x	ENDS
;	COMDAT ?AddGCGuildStatus@CUserMng@@QAEXKPAVCUser@@@Z
_TEXT	SEGMENT
_pJoinPlayer$282782 = -16448				; size = 4
_lspPlyaerList$282781 = -16444				; size = 12
_uBlockSize$ = -16432					; size = 4
$T358018 = -16428					; size = 4
$T358019 = -16424					; size = 4
_arBlock$ = -16420					; size = 16404
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_uidGuild$ = 8						; size = 4
_pSendUser$ = 12					; size = 4
?AddGCGuildStatus@CUserMng@@QAEXKPAVCUser@@@Z PROC NEAR	; CUserMng::AddGCGuildStatus, COMDAT
; _this$ = ecx

; 6019 : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?AddGCGuildStatus@CUserMng@@QAEXKPAVCUser@@@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	b8 34 40 00 00	 mov	 eax, 16436		; 00004034H
  00013	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0001a	e8 00 00 00 00	 call	 __chkstk
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00024	33 c4		 xor	 eax, esp
  00026	55		 push	 ebp
  00027	89 84 24 34 40
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+16452], eax

; 6020 : 	if( g_GuildCombatMng.m_nState == CGuildCombat::CLOSE_STATE )

  0002e	83 3d 40 11 00
	00 01		 cmp	 DWORD PTR ?g_GuildCombatMng@@3VCGuildCombat@@A+4416, 1
  00035	56		 push	 esi
  00036	8b b4 24 50 40
	00 00		 mov	 esi, DWORD PTR _pSendUser$[esp+16452]
  0003d	8b e9		 mov	 ebp, ecx

; 6066 : 			}
; 6067 : 		}
; 6068 : 
; 6069 : 		// 
; 6070 : 		if( 0 < pGCMember->lspFifo.size() )

  0003f	89 6c 24 1c	 mov	 DWORD PTR $T358018[esp+16456], ebp
  00043	89 74 24 20	 mov	 DWORD PTR $T358019[esp+16456], esi
  00047	0f 84 a8 03 00
	00		 je	 $L282774
  0004d	53		 push	 ebx
  0004e	57		 push	 edi
  0004f	6a 00		 push	 0
  00051	6a 00		 push	 0
  00053	8d 4c 24 34	 lea	 ecx, DWORD PTR _arBlock$[esp+16472]
  00057	e8 00 00 00 00	 call	 ??0CAr@@QAE@PAXI@Z	; CAr::CAr
  0005c	6a 04		 push	 4
  0005e	8d 4c 24 30	 lea	 ecx, DWORD PTR _arBlock$[esp+16468]
  00062	c7 84 24 50 40
	00 00 00 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+16476], 0
  0006d	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00072	8b 44 24 34	 mov	 eax, DWORD PTR _arBlock$[esp+16472]
  00076	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [eax], -1
  0007c	83 44 24 34 04	 add	 DWORD PTR _arBlock$[esp+16472], 4
  00081	6a 02		 push	 2
  00083	8d 4c 24 30	 lea	 ecx, DWORD PTR _arBlock$[esp+16468]
  00087	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0008c	8b 4c 24 34	 mov	 ecx, DWORD PTR _arBlock$[esp+16472]
  00090	66 c7 01 b8 00	 mov	 WORD PTR [ecx], 184	; 000000b8H
  00095	8b 5c 24 34	 mov	 ebx, DWORD PTR _arBlock$[esp+16472]
  00099	83 c3 02	 add	 ebx, 2
  0009c	6a 01		 push	 1
  0009e	8d 4c 24 30	 lea	 ecx, DWORD PTR _arBlock$[esp+16468]
  000a2	89 5c 24 38	 mov	 DWORD PTR _arBlock$[esp+16476], ebx
  000a6	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000ab	8b 54 24 34	 mov	 edx, DWORD PTR _arBlock$[esp+16472]
  000af	8b bc 24 54 40
	00 00		 mov	 edi, DWORD PTR _uidGuild$[esp+16460]
  000b6	c6 02 20	 mov	 BYTE PTR [edx], 32	; 00000020H
  000b9	8b 54 24 34	 mov	 edx, DWORD PTR _arBlock$[esp+16472]
  000bd	42		 inc	 edx
  000be	57		 push	 edi
  000bf	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_GuildCombatMng@@3VCGuildCombat@@A
  000c4	89 54 24 38	 mov	 DWORD PTR _arBlock$[esp+16476], edx
  000c8	e8 00 00 00 00	 call	 ?FindGuildCombatMember@CGuildCombat@@QAEPAU__GuildCombatMember@1@K@Z ; CGuildCombat::FindGuildCombatMember
  000cd	8b d8		 mov	 ebx, eax
  000cf	85 db		 test	 ebx, ebx
  000d1	0f 84 0a 02 00
	00		 je	 $L282779
  000d7	8d 4c 24 14	 lea	 ecx, DWORD PTR _lspPlyaerList$282781[esp+16464]
  000db	e8 00 00 00 00	 call	 ?_Buynode@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAEPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@XZ ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Buynode
  000e0	89 44 24 18	 mov	 DWORD PTR _lspPlyaerList$282781[esp+16468], eax
  000e4	c7 44 24 1c 00
	00 00 00	 mov	 DWORD PTR _lspPlyaerList$282781[esp+16472], 0
  000ec	8d 4c 24 14	 lea	 ecx, DWORD PTR _lspPlyaerList$282781[esp+16464]
  000f0	c6 84 24 4c 40
	00 00 01	 mov	 BYTE PTR __$EHRec$[esp+16472], 1
  000f8	e8 00 00 00 00	 call	 ?clear@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAEXXZ ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::clear
  000fd	8b 43 30	 mov	 eax, DWORD PTR [ebx+48]
  00100	8b 30		 mov	 esi, DWORD PTR [eax]
  00102	3b f0		 cmp	 esi, eax
  00104	74 47		 je	 SHORT $L282866
  00106	eb 08 8d a4 24
	00 00 00 00 90	 npad	 10

; 6021 : 		return;
; 6022 : 
; 6023 : 	CAr arBlock;
; 6024 : 	arBlock << NULL_ID << SNAPSHOTTYPE_GUILDCOMBAT;
; 6025 : 	arBlock << GC_GUILDSTATUS;
; 6026 : 	
; 6027 : #ifdef __S_BUG_GC
; 6028 : 	CGuildCombat::__GuildCombatMember* pGCMember = g_GuildCombatMng.FindGuildCombatMember( uidGuild );
; 6029 : 	if( pGCMember != NULL )
; 6030 : 	{
; 6031 : 		//   vecPlayerList  :  -> ( ) -> ()
; 6032 : 		list<CGuildCombat::__JOINPLAYER*> lspPlyaerList;
; 6033 : 		lspPlyaerList.clear();
; 6034 : 
; 6035 : 		CGuildCombat::__JOINPLAYER* pJoinPlayer;
; 6036 : 		// ( ) 
; 6037 : 		for( list<CGuildCombat::__JOINPLAYER*>::iterator i1 = pGCMember->lspFifo.begin(); i1 != pGCMember->lspFifo.end(); ++i1 )

$L357103:

; 6038 : 		{
; 6039 : 			pJoinPlayer = *i1;

  00110	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00113	89 44 24 10	 mov	 DWORD PTR _pJoinPlayer$282782[esp+16464], eax

; 6040 : 			lspPlyaerList.push_back( pJoinPlayer );

  00117	8b 44 24 18	 mov	 eax, DWORD PTR _lspPlyaerList$282781[esp+16468]
  0011b	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0011e	8d 68 04	 lea	 ebp, DWORD PTR [eax+4]
  00121	8d 4c 24 10	 lea	 ecx, DWORD PTR _pJoinPlayer$282782[esp+16464]
  00125	51		 push	 ecx
  00126	52		 push	 edx
  00127	50		 push	 eax
  00128	8d 4c 24 20	 lea	 ecx, DWORD PTR _lspPlyaerList$282781[esp+16476]
  0012c	e8 00 00 00 00	 call	 ?_Buynode@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAEPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@PAU342@0ABQAU__JOINPLAYER@CGuildCombat@@@Z ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Buynode
  00131	6a 01		 push	 1
  00133	8d 4c 24 18	 lea	 ecx, DWORD PTR _lspPlyaerList$282781[esp+16468]
  00137	8b f8		 mov	 edi, eax
  00139	e8 00 00 00 00	 call	 ?_Incsize@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAEXI@Z ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Incsize
  0013e	89 7d 00	 mov	 DWORD PTR [ebp], edi
  00141	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00144	89 38		 mov	 DWORD PTR [eax], edi
  00146	8b 36		 mov	 esi, DWORD PTR [esi]
  00148	3b 73 30	 cmp	 esi, DWORD PTR [ebx+48]
  0014b	75 c3		 jne	 SHORT $L357103
$L282866:

; 6041 : 		}
; 6042 : 
; 6043 : 		//   () 
; 6044 : 		for( int veci = pGCMember->vecGCSelectMember.size()-1 ; veci >= 0 ; --veci )

  0014d	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  00150	85 c9		 test	 ecx, ecx
  00152	75 04		 jne	 SHORT $L357225
  00154	33 c0		 xor	 eax, eax
  00156	eb 08		 jmp	 SHORT $L357226
$L357225:
  00158	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]
  0015b	2b c1		 sub	 eax, ecx
  0015d	c1 f8 02	 sar	 eax, 2
$L357226:
  00160	8d 68 ff	 lea	 ebp, DWORD PTR [eax-1]
  00163	85 ed		 test	 ebp, ebp
  00165	0f 8c 95 00 00
	00		 jl	 $L282870
  0016b	eb 03 8d 49 00	 npad	 5
$L358036:

; 6045 : 		{
; 6046 : 			pJoinPlayer = pGCMember->vecGCSelectMember[veci];

  00170	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  00173	8b 14 a8	 mov	 edx, DWORD PTR [eax+ebp*4]

; 6047 : 			if( 0 < pJoinPlayer->nlife )	// 

  00176	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00179	85 c0		 test	 eax, eax
  0017b	89 54 24 10	 mov	 DWORD PTR _pJoinPlayer$282782[esp+16464], edx
  0017f	7e 4a		 jle	 SHORT $L282871

; 6048 : 			{
; 6049 : 				BOOL bFind = FALSE;
; 6050 : 				for( i1 = pGCMember->lspFifo.begin(); i1 != pGCMember->lspFifo.end(); ++i1 )

  00181	8b 4b 30	 mov	 ecx, DWORD PTR [ebx+48]
  00184	8b 01		 mov	 eax, DWORD PTR [ecx]
  00186	3b c1		 cmp	 eax, ecx
  00188	74 11		 je	 SHORT $L358035
  0018a	8d 9b 00 00 00
	00		 npad	 6
$L357315:

; 6051 : 				{
; 6052 : 					if( pJoinPlayer == *i1 )

  00190	3b 50 08	 cmp	 edx, DWORD PTR [eax+8]
  00193	74 64		 je	 SHORT $L282869
  00195	8b 00		 mov	 eax, DWORD PTR [eax]
  00197	3b c1		 cmp	 eax, ecx
  00199	75 f5		 jne	 SHORT $L357315
$L358035:

; 6053 : 					{
; 6054 : 						bFind	= TRUE;
; 6055 : 						break;
; 6056 : 					}
; 6057 : 				}				
; 6058 : 				if( bFind == FALSE )
; 6059 : 				{
; 6060 : 					lspPlyaerList.push_front( pJoinPlayer );

  0019b	8b 44 24 18	 mov	 eax, DWORD PTR _lspPlyaerList$282781[esp+16468]
  0019f	8b 30		 mov	 esi, DWORD PTR [eax]
  001a1	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  001a4	8d 4c 24 10	 lea	 ecx, DWORD PTR _pJoinPlayer$282782[esp+16464]
  001a8	51		 push	 ecx
  001a9	52		 push	 edx
  001aa	56		 push	 esi
  001ab	8d 4c 24 20	 lea	 ecx, DWORD PTR _lspPlyaerList$282781[esp+16476]
  001af	e8 00 00 00 00	 call	 ?_Buynode@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAEPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@PAU342@0ABQAU__JOINPLAYER@CGuildCombat@@@Z ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Buynode
  001b4	6a 01		 push	 1
  001b6	8d 4c 24 18	 lea	 ecx, DWORD PTR _lspPlyaerList$282781[esp+16468]
  001ba	8b f8		 mov	 edi, eax
  001bc	e8 00 00 00 00	 call	 ?_Incsize@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAEXI@Z ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Incsize
  001c1	89 7e 04	 mov	 DWORD PTR [esi+4], edi
  001c4	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  001c7	89 38		 mov	 DWORD PTR [eax], edi

; 6061 : 				}
; 6062 : 			}
; 6063 : 			else // ()

  001c9	eb 2e		 jmp	 SHORT $L282869
$L282871:

; 6064 : 			{
; 6065 : 				lspPlyaerList.push_back( pJoinPlayer );

  001cb	8b 44 24 18	 mov	 eax, DWORD PTR _lspPlyaerList$282781[esp+16468]
  001cf	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  001d2	8d 78 04	 lea	 edi, DWORD PTR [eax+4]
  001d5	8d 4c 24 10	 lea	 ecx, DWORD PTR _pJoinPlayer$282782[esp+16464]
  001d9	51		 push	 ecx
  001da	52		 push	 edx
  001db	50		 push	 eax
  001dc	8d 4c 24 20	 lea	 ecx, DWORD PTR _lspPlyaerList$282781[esp+16476]
  001e0	e8 00 00 00 00	 call	 ?_Buynode@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAEPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@PAU342@0ABQAU__JOINPLAYER@CGuildCombat@@@Z ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Buynode
  001e5	6a 01		 push	 1
  001e7	8d 4c 24 18	 lea	 ecx, DWORD PTR _lspPlyaerList$282781[esp+16468]
  001eb	8b f0		 mov	 esi, eax
  001ed	e8 00 00 00 00	 call	 ?_Incsize@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAEXI@Z ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Incsize
  001f2	89 37		 mov	 DWORD PTR [edi], esi
  001f4	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  001f7	89 30		 mov	 DWORD PTR [eax], esi
$L282869:

; 6041 : 		}
; 6042 : 
; 6043 : 		//   () 
; 6044 : 		for( int veci = pGCMember->vecGCSelectMember.size()-1 ; veci >= 0 ; --veci )

  001f9	4d		 dec	 ebp
  001fa	0f 89 70 ff ff
	ff		 jns	 $L358036
$L282870:

; 6066 : 			}
; 6067 : 		}
; 6068 : 
; 6069 : 		// 
; 6070 : 		if( 0 < pGCMember->lspFifo.size() )

  00200	8b 43 34	 mov	 eax, DWORD PTR [ebx+52]
  00203	85 c0		 test	 eax, eax

; 6071 : 			arBlock << g_GuildCombatMng.m_nMaxWarPlayer;

  00205	8d 4c 24 2c	 lea	 ecx, DWORD PTR _arBlock$[esp+16464]
  00209	6a 04		 push	 4
  0020b	76 13		 jbe	 SHORT $L282881
  0020d	8b 35 ac 10 00
	00		 mov	 esi, DWORD PTR ?g_GuildCombatMng@@3VCGuildCombat@@A+4268
  00213	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00218	8b 44 24 34	 mov	 eax, DWORD PTR _arBlock$[esp+16472]
  0021c	89 30		 mov	 DWORD PTR [eax], esi

; 6072 : 		else

  0021e	eb 0f		 jmp	 SHORT $L358040
$L282881:

; 6073 : 			arBlock << (int)0;

  00220	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00225	8b 4c 24 34	 mov	 ecx, DWORD PTR _arBlock$[esp+16472]
  00229	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
$L358040:
  0022f	8b 44 24 34	 mov	 eax, DWORD PTR _arBlock$[esp+16472]
  00233	83 c0 04	 add	 eax, 4

; 6074 : 		
; 6075 : 		arBlock << (int)lspPlyaerList.size();

  00236	6a 04		 push	 4
  00238	8d 4c 24 30	 lea	 ecx, DWORD PTR _arBlock$[esp+16468]
  0023c	89 44 24 38	 mov	 DWORD PTR _arBlock$[esp+16476], eax
  00240	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00245	8b 54 24 34	 mov	 edx, DWORD PTR _arBlock$[esp+16472]
  00249	8b 44 24 1c	 mov	 eax, DWORD PTR _lspPlyaerList$282781[esp+16472]

; 6076 : 		for( i1 = lspPlyaerList.begin(); i1 != lspPlyaerList.end(); ++i1 )

  0024d	8b 7c 24 18	 mov	 edi, DWORD PTR _lspPlyaerList$282781[esp+16468]
  00251	89 02		 mov	 DWORD PTR [edx], eax
  00253	83 44 24 34 04	 add	 DWORD PTR _arBlock$[esp+16472], 4
  00258	8b 37		 mov	 esi, DWORD PTR [edi]
  0025a	3b f7		 cmp	 esi, edi
  0025c	74 45		 je	 SHORT $L282889
  0025e	8b ff		 npad	 2
$L357583:

; 6077 : 		{
; 6078 : 			pJoinPlayer = *i1;

  00260	8b 6e 08	 mov	 ebp, DWORD PTR [esi+8]

; 6079 : 			arBlock << pJoinPlayer->uidPlayer;

  00263	8b 5d 00	 mov	 ebx, DWORD PTR [ebp]
  00266	6a 04		 push	 4
  00268	8d 4c 24 30	 lea	 ecx, DWORD PTR _arBlock$[esp+16468]
  0026c	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00271	8b 4c 24 34	 mov	 ecx, DWORD PTR _arBlock$[esp+16472]
  00275	89 19		 mov	 DWORD PTR [ecx], ebx
  00277	8b 44 24 34	 mov	 eax, DWORD PTR _arBlock$[esp+16472]
  0027b	bb 04 00 00 00	 mov	 ebx, 4
  00280	03 c3		 add	 eax, ebx
  00282	89 44 24 34	 mov	 DWORD PTR _arBlock$[esp+16472], eax

; 6080 : 			arBlock << pJoinPlayer->nlife;

  00286	8b 6d 04	 mov	 ebp, DWORD PTR [ebp+4]
  00289	53		 push	 ebx
  0028a	8d 4c 24 30	 lea	 ecx, DWORD PTR _arBlock$[esp+16468]
  0028e	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00293	8b 54 24 34	 mov	 edx, DWORD PTR _arBlock$[esp+16472]
  00297	89 2a		 mov	 DWORD PTR [edx], ebp
  00299	01 5c 24 34	 add	 DWORD PTR _arBlock$[esp+16472], ebx
  0029d	8b 36		 mov	 esi, DWORD PTR [esi]
  0029f	3b f7		 cmp	 esi, edi
  002a1	75 bd		 jne	 SHORT $L357583
$L282889:

; 6081 : 		}	
; 6082 : 	}

  002a3	8b 07		 mov	 eax, DWORD PTR [edi]
  002a5	3b c7		 cmp	 eax, edi
  002a7	89 3f		 mov	 DWORD PTR [edi], edi
  002a9	c6 84 24 4c 40
	00 00 00	 mov	 BYTE PTR __$EHRec$[esp+16472], 0
  002b1	89 7f 04	 mov	 DWORD PTR [edi+4], edi
  002b4	74 11		 je	 SHORT $L357718
$L357716:
  002b6	8b 30		 mov	 esi, DWORD PTR [eax]
  002b8	50		 push	 eax
  002b9	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  002be	83 c4 04	 add	 esp, 4
  002c1	3b f7		 cmp	 esi, edi
  002c3	8b c6		 mov	 eax, esi
  002c5	75 ef		 jne	 SHORT $L357716
$L357718:
  002c7	57		 push	 edi
  002c8	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete

; 6083 : #else // __S_BUG_GC
; 6084 : 	map<u_long, CGuildCombat::__GuildCombatMember*>::iterator itGuild = g_GuildCombatMng.m_GuildCombatMem.find( uidGuild );
; 6085 : 	if( itGuild != g_GuildCombatMng.m_GuildCombatMem.end() )
; 6086 : 	{
; 6087 : 		CGuildCombat::__GuildCombatMember* pGCMember	= itGuild->second;
; 6088 : 		
; 6089 : 		//   vecPlayerList  :  -> ( ) -> ()
; 6090 : 		list<CGuildCombat::__JOINPLAYER*> lspPlyaerList;
; 6091 : 		lspPlyaerList.clear();
; 6092 : 
; 6093 : 		CGuildCombat::__JOINPLAYER* pJoinPlayer;
; 6094 : 
; 6095 : 		// ( ) 
; 6096 : 		for( list<CGuildCombat::__JOINPLAYER*>::iterator i1 = pGCMember->lspFifo.begin(); i1 != pGCMember->lspFifo.end(); ++i1 )
; 6097 : 		{
; 6098 : 			pJoinPlayer = *i1;
; 6099 : 			lspPlyaerList.push_back( pJoinPlayer );
; 6100 : 		}
; 6101 : 
; 6102 : 		//   () 
; 6103 : 		for( int veci = pGCMember->vecGCSelectMember.size()-1 ; veci >= 0 ; --veci )
; 6104 : 		{
; 6105 : 			pJoinPlayer = pGCMember->vecGCSelectMember[veci];
; 6106 : 			if( 0 < pJoinPlayer->nlife )	// 
; 6107 : 			{
; 6108 : 				BOOL bFind = FALSE;
; 6109 : 				for( i1 = pGCMember->lspFifo.begin(); i1 != pGCMember->lspFifo.end(); ++i1 )
; 6110 : 				{
; 6111 : 					if( pJoinPlayer == *i1 )
; 6112 : 					{
; 6113 : 						bFind	= TRUE;
; 6114 : 						break;
; 6115 : 					}
; 6116 : 				}				
; 6117 : 				if( bFind == FALSE )
; 6118 : 				{
; 6119 : 					lspPlyaerList.push_front( pJoinPlayer );
; 6120 : 				}
; 6121 : 			}
; 6122 : 			else // ()
; 6123 : 			{
; 6124 : 				lspPlyaerList.push_back( pJoinPlayer );
; 6125 : 			}
; 6126 : 		}
; 6127 : 
; 6128 : 		// 
; 6129 : 		if( 0 < pGCMember->lspFifo.size() )
; 6130 : 			arBlock << g_GuildCombatMng.m_nMaxWarPlayer;
; 6131 : 		else
; 6132 : 			arBlock << (int)0;
; 6133 : 		
; 6134 : 		arBlock << (int)lspPlyaerList.size();
; 6135 : 		for( i1 = lspPlyaerList.begin(); i1 != lspPlyaerList.end(); ++i1 )
; 6136 : 		{
; 6137 : 			pJoinPlayer = *i1;
; 6138 : 			arBlock << pJoinPlayer->uidPlayer;
; 6139 : 			arBlock << pJoinPlayer->nlife;
; 6140 : 		}	
; 6141 : 	}
; 6142 : #endif // __S_BUG_GC
; 6143 : 	else

  002cd	8b bc 24 58 40
	00 00		 mov	 edi, DWORD PTR _uidGuild$[esp+16464]
  002d4	8b 6c 24 28	 mov	 ebp, DWORD PTR $T358018[esp+16468]
  002d8	8b 74 24 2c	 mov	 esi, DWORD PTR $T358019[esp+16468]
  002dc	83 c4 04	 add	 esp, 4
  002df	eb 3b		 jmp	 SHORT $L357751
$L282779:

; 6144 : 	{
; 6145 : 		arBlock << (int)0;

  002e1	bb 04 00 00 00	 mov	 ebx, 4
  002e6	53		 push	 ebx
  002e7	8d 4c 24 30	 lea	 ecx, DWORD PTR _arBlock$[esp+16468]
  002eb	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  002f0	8b 44 24 34	 mov	 eax, DWORD PTR _arBlock$[esp+16472]
  002f4	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  002fa	8b 54 24 34	 mov	 edx, DWORD PTR _arBlock$[esp+16472]
  002fe	03 d3		 add	 edx, ebx

; 6146 : 		arBlock << (int)0;

  00300	53		 push	 ebx
  00301	8d 4c 24 30	 lea	 ecx, DWORD PTR _arBlock$[esp+16468]
  00305	89 54 24 38	 mov	 DWORD PTR _arBlock$[esp+16476], edx
  00309	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0030e	8b 4c 24 34	 mov	 ecx, DWORD PTR _arBlock$[esp+16472]
  00312	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  00318	01 5c 24 34	 add	 DWORD PTR _arBlock$[esp+16472], ebx
$L357751:

; 6147 : 	}
; 6148 : 
; 6149 : 	GETBLOCK( arBlock, lpBlock, uBlockSize );

  0031c	8d 54 24 20	 lea	 edx, DWORD PTR _uBlockSize$[esp+16464]
  00320	52		 push	 edx
  00321	8d 4c 24 30	 lea	 ecx, DWORD PTR _arBlock$[esp+16468]
  00325	e8 00 00 00 00	 call	 ?GetBuffer@CAr@@QAEPAEPAH@Z ; CAr::GetBuffer

; 6150 : 	if( pSendUser == NULL )

  0032a	85 f6		 test	 esi, esi
  0032c	8b d8		 mov	 ebx, eax
  0032e	0f 85 8d 00 00
	00		 jne	 $L282895

; 6151 : 	{
; 6152 : 		map<DWORD, CUser*>::iterator it;
; 6153 : 		for( it = m_users.begin(); it != m_users.end(); ++it )

  00334	8b 45 0c	 mov	 eax, DWORD PTR [ebp+12]
  00337	8b 30		 mov	 esi, DWORD PTR [eax]
  00339	3b f0		 cmp	 esi, eax
  0033b	0f 84 9e 00 00
	00		 je	 $L358012
$L358037:

; 6154 : 		{
; 6155 : 			CUser* pUser = it->second;

  00341	8b 46 10	 mov	 eax, DWORD PTR [esi+16]

; 6156 : 			if( pUser->IsValid() == FALSE )

  00344	f6 40 04 01	 test	 BYTE PTR [eax+4], 1
  00348	75 2a		 jne	 SHORT $L282905
  0034a	8b 88 e8 16 00
	00		 mov	 ecx, DWORD PTR [eax+5864]
  00350	85 c9		 test	 ecx, ecx
  00352	74 20		 je	 SHORT $L282905

; 6157 : 				continue;
; 6158 : 			
; 6159 : 			if( pUser->m_idGuild == uidGuild )

  00354	39 b8 1c 07 00
	00		 cmp	 DWORD PTR [eax+1820], edi
  0035a	75 18		 jne	 SHORT $L282905

; 6160 : 			{
; 6161 : 				pUser->AddBlock( lpBlock, uBlockSize );

  0035c	8b 4c 24 20	 mov	 ecx, DWORD PTR _uBlockSize$[esp+16464]
  00360	66 ff 80 0c 57
	00 00		 inc	 WORD PTR [eax+22284]
  00367	51		 push	 ecx
  00368	53		 push	 ebx
  00369	8d 88 f8 16 00
	00		 lea	 ecx, DWORD PTR [eax+5880]
  0036f	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
$L282905:
  00374	8a 46 15	 mov	 al, BYTE PTR [esi+21]
  00377	84 c0		 test	 al, al
  00379	75 3f		 jne	 SHORT $L357909
  0037b	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0037e	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00381	84 c9		 test	 cl, cl
  00383	75 18		 jne	 SHORT $L358029
  00385	8b f0		 mov	 esi, eax
  00387	8b 06		 mov	 eax, DWORD PTR [esi]
  00389	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  0038c	84 c9		 test	 cl, cl
  0038e	75 2a		 jne	 SHORT $L357909

; 6151 : 	{
; 6152 : 		map<DWORD, CUser*>::iterator it;
; 6153 : 		for( it = m_users.begin(); it != m_users.end(); ++it )

$L357930:
  00390	8b f0		 mov	 esi, eax
  00392	8b 06		 mov	 eax, DWORD PTR [esi]
  00394	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00397	84 c9		 test	 cl, cl
  00399	74 f5		 je	 SHORT $L357930
  0039b	eb 1d		 jmp	 SHORT $L357909
$L358029:
  0039d	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  003a0	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  003a3	84 c9		 test	 cl, cl
  003a5	75 11		 jne	 SHORT $L357912
$L357911:
  003a7	3b 70 08	 cmp	 esi, DWORD PTR [eax+8]
  003aa	75 0c		 jne	 SHORT $L357912
  003ac	8b f0		 mov	 esi, eax
  003ae	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  003b1	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  003b4	84 c9		 test	 cl, cl
  003b6	74 ef		 je	 SHORT $L357911
$L357912:
  003b8	8b f0		 mov	 esi, eax
$L357909:
  003ba	3b 75 0c	 cmp	 esi, DWORD PTR [ebp+12]
  003bd	75 82		 jne	 SHORT $L358037

; 6162 : 			}
; 6163 : 		}
; 6164 : 	}
; 6165 : 	else

  003bf	eb 1e		 jmp	 SHORT $L358012
$L282895:

; 6166 : 	{
; 6167 : 		pSendUser->AddBlock( lpBlock, uBlockSize );

  003c1	f6 46 04 01	 test	 BYTE PTR [esi+4], 1
  003c5	75 18		 jne	 SHORT $L358012
  003c7	8b 44 24 20	 mov	 eax, DWORD PTR _uBlockSize$[esp+16464]
  003cb	66 ff 86 0c 57
	00 00		 inc	 WORD PTR [esi+22284]
  003d2	50		 push	 eax
  003d3	53		 push	 ebx
  003d4	8d 8e f8 16 00
	00		 lea	 ecx, DWORD PTR [esi+5880]
  003da	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
$L358012:

; 6168 : 	}
; 6169 : }

  003df	8d 4c 24 2c	 lea	 ecx, DWORD PTR _arBlock$[esp+16464]
  003e3	c7 84 24 4c 40
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+16472], -1
  003ee	e8 00 00 00 00	 call	 ??1CAr@@QAE@XZ		; CAr::~CAr
  003f3	5f		 pop	 edi
  003f4	5b		 pop	 ebx
$L282774:
  003f5	8b 8c 24 3c 40
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+16456]
  003fc	5e		 pop	 esi
  003fd	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00404	8b 8c 24 34 40
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+16452]
  0040b	5d		 pop	 ebp
  0040c	33 cc		 xor	 ecx, esp
  0040e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00413	81 c4 40 40 00
	00		 add	 esp, 16448		; 00004040H
  00419	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L356968:
  00000	8d 8d dc bf ff
	ff		 lea	 ecx, DWORD PTR _arBlock$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CAr@@QAE@XZ		; CAr::~CAr
$L356969:
  0000b	8d 8d c4 bf ff
	ff		 lea	 ecx, DWORD PTR _lspPlyaerList$282781[ebp]
  00011	e9 00 00 00 00	 jmp	 ??1?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE@XZ ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::~list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >
__ehhandler$?AddGCGuildStatus@CUserMng@@QAEXKPAVCUser@@@Z:
  00016	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T358021
  0001b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?AddGCGuildStatus@CUserMng@@QAEXKPAVCUser@@@Z ENDP	; CUserMng::AddGCGuildStatus
PUBLIC	?AddAddRegion@CUserMng@@QAEXKAAUREGIONELEM@@@Z	; CUserMng::AddAddRegion
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
xdata$x	SEGMENT
$T358706 DD	0ffffffffH
	DD	FLAT:$L358056
	DD	00H
	DD	FLAT:$L358057
$T358694 DD	019930520H
	DD	02H
	DD	FLAT:$T358706
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
xdata$x	ENDS
;	COMDAT ?AddAddRegion@CUserMng@@QAEXKAAUREGIONELEM@@@Z
_TEXT	SEGMENT
_it$ = -16484						; size = 4
_lspUser$ = -16480					; size = 12
_nBufSize$ = -16468					; size = 4
_pUser$284398 = -16464					; size = 4
$T358691 = -16460					; size = 4
$T358692 = -16456					; size = 4
$T358050 = -16452					; size = 12
$T358051 = -16440					; size = 12
_point$284401 = -16428					; size = 8
_ar$ = -16420						; size = 16404
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_dwWorldId$ = 8						; size = 4
_re$ = 12						; size = 4
?AddAddRegion@CUserMng@@QAEXKAAUREGIONELEM@@@Z PROC NEAR ; CUserMng::AddAddRegion, COMDAT
; _this$ = ecx

; 7463 : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?AddAddRegion@CUserMng@@QAEXKAAUREGIONELEM@@@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	b8 58 40 00 00	 mov	 eax, 16472		; 00004058H
  00013	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0001a	e8 00 00 00 00	 call	 __chkstk
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00024	33 c4		 xor	 eax, esp
  00026	53		 push	 ebx
  00027	55		 push	 ebp
  00028	56		 push	 esi
  00029	8b b4 24 78 40
	00 00		 mov	 esi, DWORD PTR _re$[esp+16492]
  00030	57		 push	 edi

; 7464 : 	CAr ar;

  00031	33 db		 xor	 ebx, ebx
  00033	8b f9		 mov	 edi, ecx
  00035	53		 push	 ebx
  00036	53		 push	 ebx
  00037	8d 4c 24 58	 lea	 ecx, DWORD PTR _ar$[esp+16508]
  0003b	89 84 24 6c 40
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+16508], eax

; 7480 : 		if( pWorld && pWorld->GetID() == dwWorldId && re.m_rect.PtInRect( point ) )

  00042	89 7c 24 30	 mov	 DWORD PTR $T358691[esp+16508], edi
  00046	89 74 24 34	 mov	 DWORD PTR $T358692[esp+16508], esi
  0004a	e8 00 00 00 00	 call	 ??0CAr@@QAE@PAXI@Z	; CAr::CAr
  0004f	bd 04 00 00 00	 mov	 ebp, 4
  00054	55		 push	 ebp
  00055	8d 4c 24 54	 lea	 ecx, DWORD PTR _ar$[esp+16504]
  00059	89 9c 24 74 40
	00 00		 mov	 DWORD PTR __$EHRec$[esp+16512], ebx
  00060	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00065	8b 44 24 58	 mov	 eax, DWORD PTR _ar$[esp+16508]
  00069	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [eax], -1
  0006f	8b 44 24 58	 mov	 eax, DWORD PTR _ar$[esp+16508]
  00073	03 c5		 add	 eax, ebp
  00075	6a 02		 push	 2
  00077	8d 4c 24 54	 lea	 ecx, DWORD PTR _ar$[esp+16504]
  0007b	89 44 24 5c	 mov	 DWORD PTR _ar$[esp+16512], eax
  0007f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00084	8b 4c 24 58	 mov	 ecx, DWORD PTR _ar$[esp+16508]
  00088	66 c7 01 f9 00	 mov	 WORD PTR [ecx], 249	; 000000f9H
  0008d	83 44 24 58 02	 add	 DWORD PTR _ar$[esp+16508], 2
  00092	55		 push	 ebp
  00093	8d 4c 24 54	 lea	 ecx, DWORD PTR _ar$[esp+16504]
  00097	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0009c	8b 54 24 58	 mov	 edx, DWORD PTR _ar$[esp+16508]
  000a0	8b 84 24 78 40
	00 00		 mov	 eax, DWORD PTR _dwWorldId$[esp+16496]
  000a7	89 02		 mov	 DWORD PTR [edx], eax
  000a9	8b 54 24 58	 mov	 edx, DWORD PTR _ar$[esp+16508]
  000ad	68 f4 02 00 00	 push	 756			; 000002f4H
  000b2	03 d5		 add	 edx, ebp
  000b4	56		 push	 esi
  000b5	8d 4c 24 58	 lea	 ecx, DWORD PTR _ar$[esp+16508]
  000b9	89 54 24 60	 mov	 DWORD PTR _ar$[esp+16516], edx
  000bd	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
  000c2	8d 4c 24 14	 lea	 ecx, DWORD PTR _lspUser$[esp+16500]
  000c6	e8 00 00 00 00	 call	 ?_Buynode@?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@IAEPAU_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@2@XZ ; std::list<CUser *,std::allocator<CUser *> >::_Buynode
  000cb	8b f0		 mov	 esi, eax
  000cd	89 74 24 18	 mov	 DWORD PTR _lspUser$[esp+16504], esi
  000d1	89 5c 24 1c	 mov	 DWORD PTR _lspUser$[esp+16508], ebx
  000d5	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  000d8	8b 08		 mov	 ecx, DWORD PTR [eax]
  000da	3b c8		 cmp	 ecx, eax
  000dc	c6 84 24 70 40
	00 00 01	 mov	 BYTE PTR __$EHRec$[esp+16508], 1
  000e4	89 4c 24 10	 mov	 DWORD PTR _it$[esp+16500], ecx
  000e8	0f 84 eb 00 00
	00		 je	 $L284397
  000ee	8b ff		 npad	 2
$L358703:

; 7474 : 	{
; 7475 : 		CUser* pUser = it->second;

  000f0	8b 79 10	 mov	 edi, DWORD PTR [ecx+16]

; 7476 : 		if( pUser->IsValid() == FALSE )

  000f3	f6 47 04 01	 test	 BYTE PTR [edi+4], 1
  000f7	89 7c 24 24	 mov	 DWORD PTR _pUser$284398[esp+16500], edi
  000fb	0f 85 b7 00 00
	00		 jne	 $L284396
  00101	8b 87 e8 16 00
	00		 mov	 eax, DWORD PTR [edi+5864]
  00107	85 c0		 test	 eax, eax
  00109	0f 84 a9 00 00
	00		 je	 $L284396

; 7477 : 			continue;
; 7478 : 		CWorld* pWorld	= pUser->GetWorld();

  0010f	8b 9f 6c 01 00
	00		 mov	 ebx, DWORD PTR [edi+364]

; 7479 : 		POINT point	= {	(LONG)( pUser->GetPos().x ), (LONG)( pUser->GetPos().z ) };

  00115	8d af 60 01 00
	00		 lea	 ebp, DWORD PTR [edi+352]
  0011b	8b cd		 mov	 ecx, ebp
  0011d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0011f	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00122	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  00125	89 54 24 30	 mov	 DWORD PTR $T358050[esp+16500], edx
  00129	d9 44 24 30	 fld	 DWORD PTR $T358050[esp+16500]
  0012d	89 44 24 34	 mov	 DWORD PTR $T358050[esp+16504], eax
  00131	89 4c 24 38	 mov	 DWORD PTR $T358050[esp+16508], ecx
  00135	e8 00 00 00 00	 call	 __ftol2
  0013a	8b 4d 08	 mov	 ecx, DWORD PTR [ebp+8]
  0013d	8b 55 00	 mov	 edx, DWORD PTR [ebp]
  00140	89 44 24 48	 mov	 DWORD PTR _point$284401[esp+16500], eax
  00144	8b 45 04	 mov	 eax, DWORD PTR [ebp+4]
  00147	89 4c 24 44	 mov	 DWORD PTR $T358051[esp+16508], ecx
  0014b	d9 44 24 44	 fld	 DWORD PTR $T358051[esp+16508]
  0014f	89 54 24 3c	 mov	 DWORD PTR $T358051[esp+16500], edx
  00153	89 44 24 40	 mov	 DWORD PTR $T358051[esp+16504], eax
  00157	e8 00 00 00 00	 call	 __ftol2

; 7480 : 		if( pWorld && pWorld->GetID() == dwWorldId && re.m_rect.PtInRect( point ) )

  0015c	85 db		 test	 ebx, ebx
  0015e	74 58		 je	 SHORT $L284396
  00160	8b 94 24 78 40
	00 00		 mov	 edx, DWORD PTR _dwWorldId$[esp+16496]
  00167	39 13		 cmp	 DWORD PTR [ebx], edx
  00169	75 4d		 jne	 SHORT $L284396
  0016b	8b 4c 24 2c	 mov	 ecx, DWORD PTR $T358692[esp+16500]
  0016f	50		 push	 eax
  00170	8b 44 24 4c	 mov	 eax, DWORD PTR _point$284401[esp+16504]
  00174	50		 push	 eax
  00175	81 c1 a4 00 00
	00		 add	 ecx, 164		; 000000a4H
  0017b	51		 push	 ecx
  0017c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PtInRect@12
  00182	85 c0		 test	 eax, eax
  00184	74 32		 je	 SHORT $L284396

; 7481 : 		{
; 7482 : 			pUser->SetPosChanged( TRUE );

  00186	83 4f 04 10	 or	 DWORD PTR [edi+4], 16	; 00000010H

; 7483 : 			lspUser.push_back( pUser );

  0018a	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0018d	8d 54 24 24	 lea	 edx, DWORD PTR _pUser$284398[esp+16500]
  00191	8d 7e 04	 lea	 edi, DWORD PTR [esi+4]
  00194	52		 push	 edx
  00195	50		 push	 eax
  00196	56		 push	 esi
  00197	8d 4c 24 20	 lea	 ecx, DWORD PTR _lspUser$[esp+16512]
  0019b	e8 00 00 00 00	 call	 ?_Buynode@?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@IAEPAU_Node@?$_List_nod@PAVCUser@@V?$allocator@PAVCUser@@@std@@@2@PAU342@0ABQAVCUser@@@Z ; std::list<CUser *,std::allocator<CUser *> >::_Buynode
  001a0	6a 01		 push	 1
  001a2	8d 4c 24 18	 lea	 ecx, DWORD PTR _lspUser$[esp+16504]
  001a6	8b f0		 mov	 esi, eax
  001a8	e8 00 00 00 00	 call	 ?_Incsize@?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@IAEXI@Z ; std::list<CUser *,std::allocator<CUser *> >::_Incsize
  001ad	89 37		 mov	 DWORD PTR [edi], esi
  001af	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  001b2	89 30		 mov	 DWORD PTR [eax], esi
  001b4	8b 74 24 18	 mov	 esi, DWORD PTR _lspUser$[esp+16504]
$L284396:
  001b8	8d 4c 24 10	 lea	 ecx, DWORD PTR _it$[esp+16500]
  001bc	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::const_iterator::_Inc
  001c1	8b 4c 24 28	 mov	 ecx, DWORD PTR $T358691[esp+16500]
  001c5	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  001c8	8b 4c 24 10	 mov	 ecx, DWORD PTR _it$[esp+16500]
  001cc	3b c8		 cmp	 ecx, eax
  001ce	0f 85 1c ff ff
	ff		 jne	 $L358703

; 7465 : 	
; 7466 : 	ar << NULL_ID << SNAPSHOTTYPE_ADDREGION;
; 7467 : 	ar << dwWorldId;
; 7468 : 	ar.Write( &re, sizeof(re) );
; 7469 : 	
; 7470 : 	map<DWORD, CUser*>::iterator it;
; 7471 : 	list<CUser*>	lspUser;
; 7472 : 	list<CUser*>::iterator i;
; 7473 : 	for( it = m_users.begin(); it != m_users.end(); ++it )

  001d4	bd 04 00 00 00	 mov	 ebp, 4
$L284397:

; 7484 : 		}
; 7485 : 	}
; 7486 : 
; 7487 : 	ar << (int)lspUser.size();

  001d9	55		 push	 ebp
  001da	8d 4c 24 54	 lea	 ecx, DWORD PTR _ar$[esp+16504]
  001de	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  001e3	8b 54 24 58	 mov	 edx, DWORD PTR _ar$[esp+16508]
  001e7	8b 44 24 1c	 mov	 eax, DWORD PTR _lspUser$[esp+16508]
  001eb	89 02		 mov	 DWORD PTR [edx], eax
  001ed	01 6c 24 58	 add	 DWORD PTR _ar$[esp+16508], ebp

; 7488 : 	for( i	= lspUser.begin(); i != lspUser.end(); ++i )

  001f1	8b 3e		 mov	 edi, DWORD PTR [esi]
  001f3	3b fe		 cmp	 edi, esi
  001f5	74 2c		 je	 SHORT $L284412
  001f7	eb 07 8d a4 24
	00 00 00 00	 npad	 9
$L358422:

; 7489 : 		ar << (*i)->GetId();

  00200	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  00203	8b 99 bc 01 00
	00		 mov	 ebx, DWORD PTR [ecx+444]
  00209	55		 push	 ebp
  0020a	8d 4c 24 54	 lea	 ecx, DWORD PTR _ar$[esp+16504]
  0020e	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00213	8b 54 24 58	 mov	 edx, DWORD PTR _ar$[esp+16508]
  00217	89 1a		 mov	 DWORD PTR [edx], ebx
  00219	01 6c 24 58	 add	 DWORD PTR _ar$[esp+16508], ebp
  0021d	8b 3f		 mov	 edi, DWORD PTR [edi]
  0021f	3b fe		 cmp	 edi, esi
  00221	75 dd		 jne	 SHORT $L358422
$L284412:

; 7490 : 
; 7491 : 	GETBLOCK( ar, lpBuf, nBufSize );

  00223	8d 44 24 20	 lea	 eax, DWORD PTR _nBufSize$[esp+16500]
  00227	50		 push	 eax
  00228	8d 4c 24 54	 lea	 ecx, DWORD PTR _ar$[esp+16504]
  0022c	e8 00 00 00 00	 call	 ?GetBuffer@CAr@@QAEPAEPAH@Z ; CAr::GetBuffer

; 7492 : 
; 7493 : 	// transfer
; 7494 : 	for( i	= lspUser.begin(); i != lspUser.end(); ++i )

  00231	8b 3e		 mov	 edi, DWORD PTR [esi]
  00233	3b fe		 cmp	 edi, esi
  00235	8b d8		 mov	 ebx, eax
  00237	74 2e		 je	 SHORT $L284419
  00239	8d a4 24 00 00
	00 00		 npad	 7
$L358505:

; 7495 : 		(*i)->AddBlock( lpBuf, nBufSize );

  00240	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  00243	f6 40 04 01	 test	 BYTE PTR [eax+4], 1
  00247	8b 4c 24 20	 mov	 ecx, DWORD PTR _nBufSize$[esp+16500]
  0024b	75 14		 jne	 SHORT $L284418
  0024d	66 ff 80 0c 57
	00 00		 inc	 WORD PTR [eax+22284]
  00254	51		 push	 ecx
  00255	53		 push	 ebx
  00256	8d 88 f8 16 00
	00		 lea	 ecx, DWORD PTR [eax+5880]
  0025c	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
$L284418:
  00261	8b 3f		 mov	 edi, DWORD PTR [edi]
  00263	3b fe		 cmp	 edi, esi
  00265	75 d9		 jne	 SHORT $L358505
$L284419:

; 7496 : 
; 7497 : 	lspUser.clear();

  00267	8b 06		 mov	 eax, DWORD PTR [esi]
  00269	3b c6		 cmp	 eax, esi
  0026b	89 36		 mov	 DWORD PTR [esi], esi
  0026d	89 76 04	 mov	 DWORD PTR [esi+4], esi
  00270	74 11		 je	 SHORT $L358590
$L358588:
  00272	8b 38		 mov	 edi, DWORD PTR [eax]
  00274	50		 push	 eax
  00275	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0027a	83 c4 04	 add	 esp, 4
  0027d	3b fe		 cmp	 edi, esi
  0027f	8b c7		 mov	 eax, edi
  00281	75 ef		 jne	 SHORT $L358588
$L358590:

; 7498 : }

  00283	8b 06		 mov	 eax, DWORD PTR [esi]
  00285	3b c6		 cmp	 eax, esi
  00287	89 36		 mov	 DWORD PTR [esi], esi
  00289	89 76 04	 mov	 DWORD PTR [esi+4], esi
  0028c	74 13		 je	 SHORT $L358682
  0028e	8b ff		 npad	 2
$L358680:
  00290	8b 38		 mov	 edi, DWORD PTR [eax]
  00292	50		 push	 eax
  00293	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00298	83 c4 04	 add	 esp, 4
  0029b	3b fe		 cmp	 edi, esi
  0029d	8b c7		 mov	 eax, edi
  0029f	75 ef		 jne	 SHORT $L358680
$L358682:
  002a1	56		 push	 esi
  002a2	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  002a7	83 c4 04	 add	 esp, 4
  002aa	8d 4c 24 50	 lea	 ecx, DWORD PTR _ar$[esp+16500]
  002ae	c7 84 24 70 40
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+16508], -1
  002b9	e8 00 00 00 00	 call	 ??1CAr@@QAE@XZ		; CAr::~CAr
  002be	8b 8c 24 68 40
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+16500]
  002c5	5f		 pop	 edi
  002c6	5e		 pop	 esi
  002c7	5d		 pop	 ebp
  002c8	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  002cf	8b 8c 24 58 40
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+16488]
  002d6	5b		 pop	 ebx
  002d7	33 cc		 xor	 ecx, esp
  002d9	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002de	81 c4 64 40 00
	00		 add	 esp, 16484		; 00004064H
  002e4	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L358056:
  00000	8d 8d dc bf ff
	ff		 lea	 ecx, DWORD PTR _ar$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CAr@@QAE@XZ		; CAr::~CAr
$L358057:
  0000b	8d 8d a0 bf ff
	ff		 lea	 ecx, DWORD PTR _lspUser$[ebp]
  00011	e9 00 00 00 00	 jmp	 ??1?$list@PAVCUser@@V?$allocator@PAVCUser@@@std@@@std@@QAE@XZ ; std::list<CUser *,std::allocator<CUser *> >::~list<CUser *,std::allocator<CUser *> >
__ehhandler$?AddAddRegion@CUserMng@@QAEXKAAUREGIONELEM@@@Z:
  00016	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T358694
  0001b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?AddAddRegion@CUserMng@@QAEXKAAUREGIONELEM@@@Z ENDP	; CUserMng::AddAddRegion
PUBLIC	??0?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@ABV01@@Z ; std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >
; Function compile flags: /Ogty
;	COMDAT ??0?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@ABV01@@Z PROC NEAR ; std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >, COMDAT
; _this$ = ecx
  00000	8b 44 24 04	 mov	 eax, DWORD PTR ___that$[esp-4]
  00004	56		 push	 esi
  00005	50		 push	 eax
  00006	8b f1		 mov	 esi, ecx
  00008	e8 00 00 00 00	 call	 ??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >
  0000d	8b c6		 mov	 eax, esi
  0000f	5e		 pop	 esi
  00010	c2 04 00	 ret	 4
??0?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@ABV01@@Z ENDP ; std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >
_TEXT	ENDS
PUBLIC	??0?$map@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@@std@@QAE@XZ ; std::map<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> > >::map<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> > >
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\map
;	COMDAT ??0?$map@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$map@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@@std@@QAE@XZ PROC NEAR ; std::map<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> > >::map<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> > >, COMDAT
; _this$ = ecx

; 102  : 		{	// construct empty map from defaults

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	e8 00 00 00 00	 call	 ?_Buynode@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Buynode
  00008	89 46 04	 mov	 DWORD PTR [esi+4], eax
  0000b	c6 40 15 01	 mov	 BYTE PTR [eax+21], 1
  0000f	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00012	89 40 04	 mov	 DWORD PTR [eax+4], eax
  00015	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00018	89 00		 mov	 DWORD PTR [eax], eax
  0001a	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0001d	89 40 08	 mov	 DWORD PTR [eax+8], eax
  00020	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0

; 103  : 		}

  00027	8b c6		 mov	 eax, esi
  00029	5e		 pop	 esi
  0002a	c3		 ret	 0
??0?$map@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@@std@@QAE@XZ ENDP ; std::map<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> > >::map<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> > >
_TEXT	ENDS
PUBLIC	??0?$map@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@@std@@QAE@XZ ; std::map<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> > >::map<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> > >
; Function compile flags: /Ogty
;	COMDAT ??0?$map@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$map@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@@std@@QAE@XZ PROC NEAR ; std::map<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> > >::map<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> > >, COMDAT
; _this$ = ecx

; 102  : 		{	// construct empty map from defaults

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	e8 00 00 00 00	 call	 ?_Buynode@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::_Buynode
  00008	89 46 04	 mov	 DWORD PTR [esi+4], eax
  0000b	c6 40 15 01	 mov	 BYTE PTR [eax+21], 1
  0000f	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00012	89 40 04	 mov	 DWORD PTR [eax+4], eax
  00015	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00018	89 00		 mov	 DWORD PTR [eax], eax
  0001a	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0001d	89 40 08	 mov	 DWORD PTR [eax+8], eax
  00020	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0

; 103  : 		}

  00027	8b c6		 mov	 eax, esi
  00029	5e		 pop	 esi
  0002a	c3		 ret	 0
??0?$map@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@@std@@QAE@XZ ENDP ; std::map<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> > >::map<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> > >
_TEXT	ENDS
PUBLIC	?push_back@?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@QAEXABU__ITEMINFO@@@Z ; std::vector<__ITEMINFO,std::allocator<__ITEMINFO> >::push_back
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ?push_back@?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@QAEXABU__ITEMINFO@@@Z
_TEXT	SEGMENT
__Cat$359088 = 8					; size = 1
$T359053 = 8						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@QAEXABU__ITEMINFO@@@Z PROC NEAR ; std::vector<__ITEMINFO,std::allocator<__ITEMINFO> >::push_back, COMDAT
; _this$ = ecx

; 579  : 		{	// insert element at end

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	57		 push	 edi

; 580  : 		if (size() < capacity())

  00004	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]
  00007	85 ff		 test	 edi, edi
  00009	75 04		 jne	 SHORT $L359059
  0000b	33 c9		 xor	 ecx, ecx
  0000d	eb 15		 jmp	 SHORT $L359060
$L359059:
  0000f	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00012	2b cf		 sub	 ecx, edi
  00014	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00019	f7 e9		 imul	 ecx
  0001b	d1 fa		 sar	 edx, 1
  0001d	8b ca		 mov	 ecx, edx
  0001f	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  00022	03 ca		 add	 ecx, edx
$L359060:
  00024	85 ff		 test	 edi, edi
  00026	74 3d		 je	 SHORT $L288495
  00028	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  0002b	2b d7		 sub	 edx, edi
  0002d	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00032	f7 ea		 imul	 edx
  00034	d1 fa		 sar	 edx, 1
  00036	8b c2		 mov	 eax, edx
  00038	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0003b	03 c2		 add	 eax, edx
  0003d	3b c8		 cmp	 ecx, eax
  0003f	73 24		 jae	 SHORT $L288495

; 581  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

  00041	8b 44 24 0c	 mov	 eax, DWORD PTR __Cat$359088[esp+4]
  00045	8b 4c 24 0c	 mov	 ecx, DWORD PTR __Val$[esp+4]
  00049	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  0004c	50		 push	 eax
  0004d	56		 push	 esi
  0004e	51		 push	 ecx
  0004f	6a 01		 push	 1
  00051	57		 push	 edi
  00052	e8 00 00 00 00	 call	 ??$_Uninit_fill_n@PAU__ITEMINFO@@IU1@V?$allocator@U__ITEMINFO@@@std@@@std@@YAXPAU__ITEMINFO@@IABU1@AAV?$allocator@U__ITEMINFO@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<__ITEMINFO *,unsigned int,__ITEMINFO,std::allocator<__ITEMINFO> >
  00057	83 c4 14	 add	 esp, 20			; 00000014H
  0005a	83 c7 0c	 add	 edi, 12			; 0000000cH
  0005d	89 7e 08	 mov	 DWORD PTR [esi+8], edi
  00060	5f		 pop	 edi
  00061	5e		 pop	 esi

; 584  : 		}

  00062	c2 04 00	 ret	 4
$L288495:

; 582  : 		else
; 583  : 			insert(end(), _Val);

  00065	8b 54 24 0c	 mov	 edx, DWORD PTR __Val$[esp+4]
  00069	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0006c	52		 push	 edx
  0006d	50		 push	 eax
  0006e	8d 44 24 14	 lea	 eax, DWORD PTR $T359053[esp+12]
  00072	50		 push	 eax
  00073	8b ce		 mov	 ecx, esi
  00075	e8 00 00 00 00	 call	 ?insert@?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@QAE?AViterator@12@V312@ABU__ITEMINFO@@@Z ; std::vector<__ITEMINFO,std::allocator<__ITEMINFO> >::insert
  0007a	5f		 pop	 edi
  0007b	5e		 pop	 esi

; 584  : 		}

  0007c	c2 04 00	 ret	 4
?push_back@?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@QAEXABU__ITEMINFO@@@Z ENDP ; std::vector<__ITEMINFO,std::allocator<__ITEMINFO> >::push_back
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Tidy
; Function compile flags: /Ogty
;	COMDAT ?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXXZ
_TEXT	SEGMENT
__Cat$359130 = -4					; size = 1
?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXXZ PROC NEAR ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Tidy, COMDAT
; _this$ = ecx

; 791  : 		{	// free all storage

  00000	51		 push	 ecx
  00001	56		 push	 esi
  00002	8b f1		 mov	 esi, ecx

; 792  : 		if (_Myfirst != 0)

  00004	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00007	85 c0		 test	 eax, eax
  00009	74 1c		 je	 SHORT $L359136

; 793  : 			{	// something to free, destroy and deallocate it
; 794  : 			_Destroy(_Myfirst, _Mylast);

  0000b	8b 4c 24 04	 mov	 ecx, DWORD PTR __Cat$359130[esp+8]
  0000f	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00012	51		 push	 ecx
  00013	56		 push	 esi
  00014	52		 push	 edx
  00015	50		 push	 eax
  00016	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >

; 795  : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

  0001b	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00024	83 c4 14	 add	 esp, 20			; 00000014H
$L359136:

; 796  : 			}
; 797  : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

  00027	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  0002e	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00035	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
  0003c	5e		 pop	 esi

; 798  : 		}

  0003d	59		 pop	 ecx
  0003e	c3		 ret	 0
?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXXZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Tidy
_TEXT	ENDS
PUBLIC	?_Ufill@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@PAV32@IABV32@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Ufill
; Function compile flags: /Ogty
;	COMDAT ?_Ufill@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@PAV32@IABV32@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Cat$359153 = 16					; size = 1
__Val$ = 16						; size = 4
?_Ufill@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@PAV32@IABV32@@Z PROC NEAR ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Ufill, COMDAT
; _this$ = ecx

; 878  : 		_Uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

  00000	8b 44 24 0c	 mov	 eax, DWORD PTR __Cat$359153[esp-4]
  00004	56		 push	 esi
  00005	8b 74 24 0c	 mov	 esi, DWORD PTR __Count$[esp]
  00009	57		 push	 edi
  0000a	8b 7c 24 0c	 mov	 edi, DWORD PTR __Ptr$[esp+4]
  0000e	50		 push	 eax
  0000f	51		 push	 ecx
  00010	8b 4c 24 1c	 mov	 ecx, DWORD PTR __Val$[esp+12]
  00014	51		 push	 ecx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	e8 00 00 00 00	 call	 ??$_Uninit_fill_n@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IABV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >

; 879  : 		return (_Ptr + _Count);

  0001c	8b c6		 mov	 eax, esi
  0001e	6b c0 1c	 imul	 eax, 28			; 0000001cH
  00021	83 c4 14	 add	 esp, 20			; 00000014H
  00024	03 c7		 add	 eax, edi
  00026	5f		 pop	 edi
  00027	5e		 pop	 esi

; 880  : 		}

  00028	c2 0c 00	 ret	 12			; 0000000cH
?_Ufill@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@PAV32@IABV32@@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Ufill
_TEXT	ENDS
PUBLIC	?_Insert_n@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXViterator@12@IABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Insert_n
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\iosfwd
xdata$x	SEGMENT
$T359581 DD	0ffffffffH
	DD	FLAT:$L359166
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
$T359583 DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L359163
$T359584 DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L359165
$T359582 DD	01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:$T359583
	DD	03H
	DD	03H
	DD	04H
	DD	01H
	DD	FLAT:$T359584
$T359577 DD	019930520H
	DD	05H
	DD	FLAT:$T359581
	DD	02H
	DD	FLAT:$T359582
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXViterator@12@IABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
_TEXT	SEGMENT
$T359574 = -64						; size = 4
tv511 = -60						; size = 4
tv496 = -60						; size = 4
__Ptr$289868 = -56					; size = 4
tv573 = -52						; size = 4
tv525 = -52						; size = 4
tv512 = -52						; size = 4
__Cat$359497 = -52					; size = 1
__Cat$359483 = -52					; size = 1
__Cat$359459 = -52					; size = 1
__Cat$359430 = -52					; size = 1
__Cat$359396 = -52					; size = 1
__Cat$359373 = -52					; size = 1
__Cat$359350 = -52					; size = 1
__Newvec$289867 = -52					; size = 4
__Tmp$ = -48						; size = 28
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__$ReturnAddr$ = 4					; size = 4
__Where$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Insert_n@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXViterator@12@IABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z PROC NEAR ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Insert_n, COMDAT
; _this$ = ecx

; 809  : 		{	// insert _Count * _Val at _Where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Insert_n@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXViterator@12@IABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 34	 sub	 esp, 52			; 00000034H
  0001b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00020	53		 push	 ebx
  00021	56		 push	 esi
  00022	57		 push	 edi
  00023	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00026	33 c5		 xor	 eax, ebp

; 810  : 		_Ty _Tmp = _Val;	// in case _Val is in sequence

  00028	6a ff		 push	 -1
  0002a	33 ff		 xor	 edi, edi
  0002c	89 45 ec	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0002f	8b 45 10	 mov	 eax, DWORD PTR __Val$[ebp]
  00032	8b f1		 mov	 esi, ecx
  00034	57		 push	 edi
  00035	50		 push	 eax
  00036	8d 4d d0	 lea	 ecx, DWORD PTR __Tmp$[ebp]
  00039	89 75 c0	 mov	 DWORD PTR $T359574[ebp], esi
  0003c	c7 45 e8 0f 00
	00 00		 mov	 DWORD PTR __Tmp$[ebp+24], 15 ; 0000000fH
  00043	89 7d e4	 mov	 DWORD PTR __Tmp$[ebp+20], edi
  00046	c6 45 d4 00	 mov	 BYTE PTR __Tmp$[ebp+4], 0
  0004a	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 811  : 		size_type _Capacity = capacity();

  0004f	8b 5e 04	 mov	 ebx, DWORD PTR [esi+4]
  00052	3b df		 cmp	 ebx, edi
  00054	89 7d fc	 mov	 DWORD PTR __$EHRec$[ebp+12], edi
  00057	75 04		 jne	 SHORT $L359266
  00059	33 c9		 xor	 ecx, ecx
  0005b	eb 18		 jmp	 SHORT $L359267
$L359266:
  0005d	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  00060	2b cb		 sub	 ecx, ebx
  00062	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  00067	f7 e9		 imul	 ecx
  00069	03 d1		 add	 edx, ecx
  0006b	c1 fa 04	 sar	 edx, 4
  0006e	8b ca		 mov	 ecx, edx
  00070	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  00073	03 ca		 add	 ecx, edx
$L359267:

; 812  : 
; 813  : 		if (_Count == 0)

  00075	8b 7d 0c	 mov	 edi, DWORD PTR __Count$[ebp]
  00078	85 ff		 test	 edi, edi
  0007a	0f 84 8e 02 00
	00		 je	 $L289887

; 814  : 			;
; 815  : 		else if (max_size() - size() < _Count)

  00080	85 db		 test	 ebx, ebx
  00082	75 04		 jne	 SHORT $L359289
  00084	33 c0		 xor	 eax, eax
  00086	eb 1b		 jmp	 SHORT $L359290
$L359289:
  00088	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0008b	8b 5e 08	 mov	 ebx, DWORD PTR [esi+8]
  0008e	2b da		 sub	 ebx, edx
  00090	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  00095	f7 eb		 imul	 ebx
  00097	03 d3		 add	 edx, ebx
  00099	c1 fa 04	 sar	 edx, 4
  0009c	8b c2		 mov	 eax, edx
  0009e	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  000a1	03 c2		 add	 eax, edx
$L359290:
  000a3	ba 49 92 24 09	 mov	 edx, 153391689		; 09249249H
  000a8	2b d0		 sub	 edx, eax
  000aa	3b d7		 cmp	 edx, edi
  000ac	73 07		 jae	 SHORT $L289863

; 816  : 			_Xlen();	// result too long

  000ae	8b ce		 mov	 ecx, esi
  000b0	e8 00 00 00 00	 call	 ?_Xlen@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IBEXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Xlen
$L359585:
$L289863:

; 817  : 		else if (_Capacity < size() + _Count)

  000b5	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000b8	85 c0		 test	 eax, eax
  000ba	75 04		 jne	 SHORT $L359296
  000bc	33 c0		 xor	 eax, eax
  000be	eb 1b		 jmp	 SHORT $L359297
$L359296:
  000c0	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  000c3	8b 5e 08	 mov	 ebx, DWORD PTR [esi+8]
  000c6	2b da		 sub	 ebx, edx
  000c8	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  000cd	f7 eb		 imul	 ebx
  000cf	03 d3		 add	 edx, ebx
  000d1	c1 fa 04	 sar	 edx, 4
  000d4	8b c2		 mov	 eax, edx
  000d6	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  000d9	03 c2		 add	 eax, edx
$L359297:
  000db	03 c7		 add	 eax, edi
  000dd	3b c8		 cmp	 ecx, eax
  000df	0f 83 30 01 00
	00		 jae	 $L289865

; 818  : 			{	// not enough room, reallocate
; 819  : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 820  : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  000e5	8b c1		 mov	 eax, ecx
  000e7	d1 e8		 shr	 eax, 1
  000e9	ba 49 92 24 09	 mov	 edx, 153391689		; 09249249H
  000ee	2b d0		 sub	 edx, eax
  000f0	3b d1		 cmp	 edx, ecx
  000f2	73 04		 jae	 SHORT $L359160
  000f4	33 c9		 xor	 ecx, ecx
  000f6	eb 02		 jmp	 SHORT $L359161
$L359160:
  000f8	03 c8		 add	 ecx, eax
$L359161:

; 821  : 			if (_Capacity < size() + _Count)

  000fa	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000fd	85 c0		 test	 eax, eax
  000ff	75 04		 jne	 SHORT $L359319
  00101	33 c0		 xor	 eax, eax
  00103	eb 1b		 jmp	 SHORT $L359320
$L359319:
  00105	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00108	8b 5e 08	 mov	 ebx, DWORD PTR [esi+8]
  0010b	2b da		 sub	 ebx, edx
  0010d	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  00112	f7 eb		 imul	 ebx
  00114	03 d3		 add	 edx, ebx
  00116	c1 fa 04	 sar	 edx, 4
  00119	8b c2		 mov	 eax, edx
  0011b	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0011e	03 c2		 add	 eax, edx
$L359320:
  00120	03 c7		 add	 eax, edi
  00122	3b c8		 cmp	 ecx, eax
  00124	73 0b		 jae	 SHORT $L289866

; 822  : 				_Capacity = size() + _Count;

  00126	8b ce		 mov	 ecx, esi
  00128	e8 00 00 00 00	 call	 ?size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::size
  0012d	8b c8		 mov	 ecx, eax
  0012f	03 cf		 add	 ecx, edi
$L289866:

; 823  : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

  00131	6b c9 1c	 imul	 ecx, 28			; 0000001cH
  00134	51		 push	 ecx
  00135	89 4d c4	 mov	 DWORD PTR tv511[ebp], ecx
  00138	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 824  : 			pointer _Ptr = _Newvec;
; 825  : 
; 826  : 			_TRY_BEGIN
; 827  : 			_Ptr = _Ucopy(_Myfirst, _ITER_BASE(_Where),
; 828  : 				_Newvec);	// copy prefix

  0013d	8b 55 08	 mov	 edx, DWORD PTR __Where$[ebp]
  00140	8b d8		 mov	 ebx, eax
  00142	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00145	89 5d cc	 mov	 DWORD PTR __Newvec$289867[ebp], ebx
  00148	8b 4d cc	 mov	 ecx, DWORD PTR __Cat$359350[ebp]
  0014b	51		 push	 ecx
  0014c	56		 push	 esi
  0014d	53		 push	 ebx
  0014e	52		 push	 edx
  0014f	50		 push	 eax
  00150	89 5d c8	 mov	 DWORD PTR __Ptr$289868[ebp], ebx
  00153	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1
  00157	e8 00 00 00 00	 call	 ??$_Uninit_copy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >

; 829  : 			_Ptr = _Ufill(_Ptr, _Count, _Tmp);	// add new stuff

  0015c	8b 4d cc	 mov	 ecx, DWORD PTR __Cat$359373[ebp]
  0015f	83 c4 18	 add	 esp, 24			; 00000018H
  00162	51		 push	 ecx
  00163	56		 push	 esi
  00164	8d 55 d0	 lea	 edx, DWORD PTR __Tmp$[ebp]
  00167	52		 push	 edx
  00168	57		 push	 edi
  00169	50		 push	 eax
  0016a	89 45 c8	 mov	 DWORD PTR __Ptr$289868[ebp], eax
  0016d	e8 00 00 00 00	 call	 ??$_Uninit_fill_n@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IABV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >

; 830  : 			_Ucopy(_ITER_BASE(_Where), _Mylast, _Ptr);	// copy suffix

  00172	8b 55 cc	 mov	 edx, DWORD PTR __Cat$359396[ebp]
  00175	8b 4d c8	 mov	 ecx, DWORD PTR __Ptr$289868[ebp]
  00178	8b c7		 mov	 eax, edi
  0017a	6b c0 1c	 imul	 eax, 28			; 0000001cH
  0017d	83 c4 14	 add	 esp, 20			; 00000014H
  00180	52		 push	 edx
  00181	03 c8		 add	 ecx, eax
  00183	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00186	56		 push	 esi
  00187	51		 push	 ecx
  00188	50		 push	 eax
  00189	8b 45 08	 mov	 eax, DWORD PTR __Where$[ebp]
  0018c	50		 push	 eax
  0018d	89 4d c8	 mov	 DWORD PTR __Ptr$289868[ebp], ecx
  00190	e8 00 00 00 00	 call	 ??$_Uninit_copy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >

; 835  : 			_CATCH_END
; 836  : 
; 837  : 			_Count += size();

  00195	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00198	83 c4 14	 add	 esp, 20			; 00000014H
  0019b	85 c0		 test	 eax, eax
  0019d	74 18		 je	 SHORT $L359408
$L359407:
  0019f	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  001a2	2b c8		 sub	 ecx, eax
  001a4	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  001a9	f7 e9		 imul	 ecx
  001ab	03 d1		 add	 edx, ecx
  001ad	c1 fa 04	 sar	 edx, 4
  001b0	8b c2		 mov	 eax, edx
  001b2	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  001b5	03 c2		 add	 eax, edx
$L359408:
  001b7	03 f8		 add	 edi, eax

; 838  : 			if (_Myfirst != 0)

  001b9	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  001bc	85 c0		 test	 eax, eax
  001be	74 1b		 je	 SHORT $L359436

; 839  : 				{	// destroy and deallocate old array
; 840  : 				_Destroy(_Myfirst, _Mylast);

  001c0	8b 4d cc	 mov	 ecx, DWORD PTR __Cat$359430[ebp]
  001c3	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  001c6	51		 push	 ecx
  001c7	56		 push	 esi
  001c8	52		 push	 edx
  001c9	50		 push	 eax
  001ca	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >

; 841  : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

  001cf	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  001d2	50		 push	 eax
  001d3	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  001d8	83 c4 14	 add	 esp, 20			; 00000014H
$L359436:

; 842  : 				}
; 843  : 			_Myend = _Newvec + _Capacity;

  001db	8b 4d c4	 mov	 ecx, DWORD PTR tv511[ebp]

; 844  : 			_Mylast = _Newvec + _Count;

  001de	6b ff 1c	 imul	 edi, 28			; 0000001cH
  001e1	03 cb		 add	 ecx, ebx
  001e3	03 fb		 add	 edi, ebx
  001e5	89 4e 0c	 mov	 DWORD PTR [esi+12], ecx
  001e8	89 7e 08	 mov	 DWORD PTR [esi+8], edi

; 845  : 			_Myfirst = _Newvec;

  001eb	89 5e 04	 mov	 DWORD PTR [esi+4], ebx

; 846  : 			}
; 847  : 		else if ((size_type)(_Mylast - _ITER_BASE(_Where)) < _Count)

  001ee	e9 1b 01 00 00	 jmp	 $L289887
$L359163:

; 831  : 			_CATCH_ALL
; 832  : 			_Destroy(_Newvec, _Ptr);

  001f3	8b 55 c8	 mov	 edx, DWORD PTR __Ptr$289868[ebp]
  001f6	8b 75 cc	 mov	 esi, DWORD PTR __Newvec$289867[ebp]
  001f9	8b 4d c0	 mov	 ecx, DWORD PTR $T359574[ebp]
  001fc	52		 push	 edx
  001fd	56		 push	 esi
  001fe	e8 00 00 00 00	 call	 ?_Destroy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Destroy

; 833  : 			this->_Alval.deallocate(_Newvec, _Capacity);

  00203	56		 push	 esi
  00204	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00209	83 c4 04	 add	 esp, 4

; 834  : 			_RERAISE;

  0020c	6a 00		 push	 0
  0020e	6a 00		 push	 0
  00210	e8 00 00 00 00	 call	 __CxxThrowException@8
$L359586:
$L289865:

; 846  : 			}
; 847  : 		else if ((size_type)(_Mylast - _ITER_BASE(_Where)) < _Count)

  00215	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00218	8b 5d 08	 mov	 ebx, DWORD PTR __Where$[ebp]
  0021b	8b d1		 mov	 edx, ecx
  0021d	2b d3		 sub	 edx, ebx
  0021f	89 55 cc	 mov	 DWORD PTR tv573[ebp], edx
  00222	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  00227	f7 ea		 imul	 edx
  00229	03 55 cc	 add	 edx, DWORD PTR tv573[ebp]
  0022c	c1 fa 04	 sar	 edx, 4
  0022f	8b c2		 mov	 eax, edx
  00231	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00234	03 c2		 add	 eax, edx
  00236	3b c7		 cmp	 eax, edi
  00238	89 4d c4	 mov	 DWORD PTR tv496[ebp], ecx
  0023b	0f 83 91 00 00
	00		 jae	 $L289878

; 848  : 			{	// new stuff spills off end
; 849  : 			_Ucopy(_ITER_BASE(_Where), _Mylast,
; 850  : 				_ITER_BASE(_Where) + _Count);	// copy suffix

  00241	8b c7		 mov	 eax, edi
  00243	6b c0 1c	 imul	 eax, 28			; 0000001cH
  00246	89 45 cc	 mov	 DWORD PTR tv512[ebp], eax
  00249	8b 55 cc	 mov	 edx, DWORD PTR __Cat$359459[ebp]
  0024c	52		 push	 edx
  0024d	56		 push	 esi
  0024e	03 c3		 add	 eax, ebx
  00250	50		 push	 eax
  00251	51		 push	 ecx
  00252	53		 push	 ebx
  00253	e8 00 00 00 00	 call	 ??$_Uninit_copy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >

; 851  : 
; 852  : 			_TRY_BEGIN
; 853  : 			_Ufill(_Mylast, _Count - (_Mylast - _ITER_BASE(_Where)),
; 854  : 				_Tmp);	// insert new stuff off end

  00258	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0025b	83 c4 14	 add	 esp, 20			; 00000014H
  0025e	2b cb		 sub	 ecx, ebx
  00260	8d 45 d0	 lea	 eax, DWORD PTR __Tmp$[ebp]
  00263	50		 push	 eax
  00264	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  00269	f7 e9		 imul	 ecx
  0026b	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0026e	03 d1		 add	 edx, ecx
  00270	c1 fa 04	 sar	 edx, 4
  00273	8b ca		 mov	 ecx, edx
  00275	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  00278	03 ca		 add	 ecx, edx
  0027a	2b f9		 sub	 edi, ecx
  0027c	57		 push	 edi
  0027d	50		 push	 eax
  0027e	8b ce		 mov	 ecx, esi
  00280	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+12], 3
  00284	e8 00 00 00 00	 call	 ?_Ufill@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@PAV32@IABV32@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Ufill

; 858  : 			_CATCH_END
; 859  : 
; 860  : 			_Mylast += _Count;

  00289	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0028c	8b 45 cc	 mov	 eax, DWORD PTR tv512[ebp]
  0028f	03 d0		 add	 edx, eax
  00291	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00294	8b f2		 mov	 esi, edx

; 861  : 			fill(_ITER_BASE(_Where), _Mylast - _Count,
; 862  : 				_Tmp);	// insert up to old end

  00296	8d 55 d0	 lea	 edx, DWORD PTR __Tmp$[ebp]
  00299	52		 push	 edx
  0029a	2b f0		 sub	 esi, eax
  0029c	56		 push	 esi
  0029d	53		 push	 ebx
  0029e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  002a5	e8 00 00 00 00	 call	 ??$fill@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0ABV10@@Z ; std::fill<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
  002aa	83 c4 0c	 add	 esp, 12			; 0000000cH

; 863  : 			}
; 864  : 		else

  002ad	eb 5f		 jmp	 SHORT $L289887
$L359165:

; 855  : 			_CATCH_ALL
; 856  : 			_Destroy(_ITER_BASE(_Where) + _Count, _Mylast + _Count);

  002af	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  002b2	8b 4d c0	 mov	 ecx, DWORD PTR $T359574[ebp]
  002b5	6b c0 1c	 imul	 eax, 28			; 0000001cH
  002b8	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  002bb	03 d0		 add	 edx, eax
  002bd	52		 push	 edx
  002be	8b 55 08	 mov	 edx, DWORD PTR __Where$[ebp]
  002c1	03 c2		 add	 eax, edx
  002c3	50		 push	 eax
  002c4	e8 00 00 00 00	 call	 ?_Destroy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Destroy

; 857  : 			_RERAISE;

  002c9	6a 00		 push	 0
  002cb	6a 00		 push	 0
  002cd	e8 00 00 00 00	 call	 __CxxThrowException@8
$L359587:
$L289878:

; 865  : 			{	// new stuff can all be assigned
; 866  : 			pointer _Oldend = _Mylast;
; 867  : 			_Mylast = _Ucopy(_Oldend - _Count, _Oldend,
; 868  : 				_Mylast);	// copy suffix

  002d2	6b ff 1c	 imul	 edi, 28			; 0000001cH
  002d5	8b c1		 mov	 eax, ecx
  002d7	2b c7		 sub	 eax, edi
  002d9	89 45 cc	 mov	 DWORD PTR tv525[ebp], eax
  002dc	8b 55 cc	 mov	 edx, DWORD PTR __Cat$359483[ebp]
  002df	52		 push	 edx
  002e0	56		 push	 esi
  002e1	51		 push	 ecx
  002e2	51		 push	 ecx
  002e3	50		 push	 eax
  002e4	e8 00 00 00 00	 call	 ??$_Uninit_copy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >

; 869  : 			copy_backward(_ITER_BASE(_Where), _Oldend - _Count,
; 870  : 				_Oldend);	// copy hole

  002e9	8b 4d c4	 mov	 ecx, DWORD PTR tv496[ebp]
  002ec	8b 55 cc	 mov	 edx, DWORD PTR tv525[ebp]
  002ef	89 46 08	 mov	 DWORD PTR [esi+8], eax
  002f2	8b 45 cc	 mov	 eax, DWORD PTR __Cat$359497[ebp]
  002f5	50		 push	 eax
  002f6	51		 push	 ecx
  002f7	52		 push	 edx
  002f8	53		 push	 ebx
  002f9	e8 00 00 00 00	 call	 ??$_Copy_backward_opt@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Copy_backward_opt<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>

; 871  : 			fill(_ITER_BASE(_Where), _ITER_BASE(_Where) + _Count,
; 872  : 				_Tmp);	// insert into hole

  002fe	8d 45 d0	 lea	 eax, DWORD PTR __Tmp$[ebp]
  00301	50		 push	 eax
  00302	03 fb		 add	 edi, ebx
  00304	57		 push	 edi
  00305	53		 push	 ebx
  00306	e8 00 00 00 00	 call	 ??$fill@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0ABV10@@Z ; std::fill<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
  0030b	83 c4 30	 add	 esp, 48			; 00000030H
$L289887:

; 873  : 			}
; 874  : 		}

  0030e	83 7d e8 10	 cmp	 DWORD PTR __Tmp$[ebp+24], 16 ; 00000010H
  00312	72 0c		 jb	 SHORT $L359557
  00314	8b 4d d4	 mov	 ecx, DWORD PTR __Tmp$[ebp+4]
  00317	51		 push	 ecx
  00318	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0031d	83 c4 04	 add	 esp, 4
$L359557:
  00320	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00323	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0032a	8b 4d ec	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0032d	5f		 pop	 edi
  0032e	5e		 pop	 esi
  0032f	33 cd		 xor	 ecx, ebp
  00331	5b		 pop	 ebx
  00332	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00337	8b e5		 mov	 esp, ebp
  00339	5d		 pop	 ebp
  0033a	c2 0c 00	 ret	 12			; 0000000cH
$L359580:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L359166:
  00000	8d 4d d0	 lea	 ecx, DWORD PTR __Tmp$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?_Insert_n@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXViterator@12@IABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T359577
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?_Insert_n@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXViterator@12@IABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Insert_n
PUBLIC	?PCSetAt@CCtrl@@QAEXKPAV1@@Z			; CCtrl::PCSetAt
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\ctrl.h
;	COMDAT ?PCSetAt@CCtrl@@QAEXKPAV1@@Z
_TEXT	SEGMENT
_objid$ = 8						; size = 4
_pCtrl$ = 12						; size = 4
?PCSetAt@CCtrl@@QAEXKPAV1@@Z PROC NEAR			; CCtrl::PCSetAt, COMDAT
; _this$ = ecx

; 115  : 	m_2pc[ objid ] = (CUser *)pCtrl;

  00000	8d 44 24 04	 lea	 eax, DWORD PTR _objid$[esp-4]
  00004	50		 push	 eax
  00005	81 c1 0c 02 00
	00		 add	 ecx, 524		; 0000020cH
  0000b	e8 00 00 00 00	 call	 ??A?$map@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@@std@@QAEAAPAVCUser@@ABK@Z ; std::map<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> > >::operator[]
  00010	8b 4c 24 08	 mov	 ecx, DWORD PTR _pCtrl$[esp-4]
  00014	89 08		 mov	 DWORD PTR [eax], ecx

; 116  : }

  00016	c2 08 00	 ret	 8
?PCSetAt@CCtrl@@QAEXKPAV1@@Z ENDP			; CCtrl::PCSetAt
_TEXT	ENDS
PUBLIC	??1?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@XZ ; std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >::~map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >
; Function compile flags: /Ogty
;	COMDAT ??1?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
$T359694 = -4						; size = 4
??1?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@XZ PROC NEAR ; std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >::~map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >, COMDAT
; _this$ = ecx
  00000	51		 push	 ecx
  00001	56		 push	 esi
  00002	8b f1		 mov	 esi, ecx
  00004	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00007	8b 08		 mov	 ecx, DWORD PTR [eax]
  00009	50		 push	 eax
  0000a	51		 push	 ecx
  0000b	8d 44 24 0c	 lea	 eax, DWORD PTR $T359694[esp+16]
  0000f	50		 push	 eax
  00010	8b ce		 mov	 ecx, esi
  00012	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@V312@0@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::erase
  00017	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0001a	51		 push	 ecx
  0001b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00020	83 c4 04	 add	 esp, 4
  00023	33 c0		 xor	 eax, eax
  00025	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00028	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0002b	5e		 pop	 esi
  0002c	59		 pop	 ecx
  0002d	c3		 ret	 0
??1?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@XZ ENDP ; std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >::~map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >
_TEXT	ENDS
PUBLIC	?SendDamage@CMover@@UAEHKKHH@Z			; CMover::SendDamage
PUBLIC	?SendDamageForce@CMover@@UAEHKKHH@Z		; CMover::SendDamageForce
PUBLIC	?GetName@CObj@@UAEPBDXZ				; CObj::GetName
PUBLIC	?SetIndex@CObj@@UAEHPAUIDirect3DDevice9@@KH@Z	; CObj::SetIndex
PUBLIC	??_7CUser@@6B@					; CUser::`vftable'
PUBLIC	??_GCUser@@UAEPAXI@Z				; CUser::`scalar deleting destructor'
PUBLIC	??0CUser@@QAE@XZ				; CUser::CUser
EXTRN	??0CSnapshot@@QAE@XZ:NEAR			; CSnapshot::CSnapshot
EXTRN	??1CSnapshot@@UAE@XZ:NEAR			; CSnapshot::~CSnapshot
EXTRN	??0CUserTaskBar@@QAE@XZ:NEAR			; CUserTaskBar::CUserTaskBar
EXTRN	??1CUserTaskBar@@UAE@XZ:NEAR			; CUserTaskBar::~CUserTaskBar
EXTRN	?SetIndex@CMover@@UAEHPAUIDirect3DDevice9@@KHH@Z:NEAR ; CMover::SetIndex
EXTRN	?Read@CMover@@UAEHPAVCFileIO@@@Z:NEAR		; CMover::Read
EXTRN	?Serialize@CMover@@UAEXAAVCAr@@@Z:NEAR		; CMover::Serialize
EXTRN	?LoadModel@CMover@@UAEPAVCModel@@PAUIDirect3DDevice9@@KK@Z:NEAR ; CMover::LoadModel
EXTRN	?InitProp@CMover@@UAEXH@Z:NEAR			; CMover::InitProp
EXTRN	?AddItToGlobalId@CCtrl@@UAEXXZ:NEAR		; CCtrl::AddItToGlobalId
EXTRN	?RemoveItFromGlobalId@CCtrl@@UAEXXZ:NEAR	; CCtrl::RemoveItFromGlobalId
EXTRN	?Render@CCtrl@@UAEXPAUIDirect3DDevice9@@@Z:NEAR	; CCtrl::Render
EXTRN	??0CMover@@QAE@XZ:NEAR				; CMover::CMover
EXTRN	??1CMover@@UAE@XZ:NEAR				; CMover::~CMover
EXTRN	?RenderName@CObj@@UAEXPAUIDirect3DDevice9@@PAVCD3DFont@@K@Z:NEAR ; CObj::RenderName
EXTRN	?SetMotion@CMover@@UAEHKHK@Z:NEAR		; CMover::SetMotion
EXTRN	?InitMotion@CMover@@UAEHK@Z:NEAR		; CMover::InitMotion
EXTRN	??0CCooltimeMgr@@QAE@XZ:NEAR			; CCooltimeMgr::CCooltimeMgr
EXTRN	??0CRTMessenger@@QAE@XZ:NEAR			; CRTMessenger::CRTMessenger
EXTRN	??1CRTMessenger@@UAE@XZ:NEAR			; CRTMessenger::~CRTMessenger
EXTRN	??_ECUser@@UAEPAXI@Z:NEAR			; CUser::`vector deleting destructor'
EXTRN	?GetSkillProp@CMover@@UAEHPAPAUItemProp@@PAPAUAddSkillProp@@HKPBD@Z:NEAR ; CMover::GetSkillProp
;	COMDAT xdata$x
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\dx_sdk\d3dx9math.h
xdata$x	SEGMENT
$T359949 DD	0ffffffffH
	DD	FLAT:$L359723
	DD	00H
	DD	FLAT:$L359724
	DD	01H
	DD	FLAT:$L359725
	DD	02H
	DD	FLAT:$L359726
	DD	03H
	DD	FLAT:$L359727
$T359947 DD	019930520H
	DD	05H
	DD	FLAT:$T359949
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_7CUser@@6B@
CONST	SEGMENT
??_7CUser@@6B@ DD FLAT:??_ECUser@@UAEPAXI@Z		; CUser::`vftable'
	DD	FLAT:?SetMotion@CMover@@UAEHKHK@Z
	DD	FLAT:?InitMotion@CMover@@UAEHK@Z
	DD	FLAT:?LoadModel@CMover@@UAEPAVCModel@@PAUIDirect3DDevice9@@KK@Z
	DD	FLAT:?InitProp@CMover@@UAEXH@Z
	DD	FLAT:?GetName@CObj@@UAEPBDXZ
	DD	FLAT:?Process@CUser@@UAEXXZ
	DD	FLAT:?Read@CMover@@UAEHPAVCFileIO@@@Z
	DD	FLAT:?Serialize@CMover@@UAEXAAVCAr@@@Z
	DD	FLAT:?Render@CCtrl@@UAEXPAUIDirect3DDevice9@@@Z
	DD	FLAT:?RenderName@CObj@@UAEXPAUIDirect3DDevice9@@PAVCD3DFont@@K@Z
	DD	FLAT:?SetIndex@CObj@@UAEHPAUIDirect3DDevice9@@KH@Z
	DD	FLAT:?GetSkillProp@CMover@@UAEHPAPAUItemProp@@PAPAUAddSkillProp@@HKPBD@Z
	DD	FLAT:?SendDamage@CMover@@UAEHKKHH@Z
	DD	FLAT:?SendDamageForce@CMover@@UAEHKKHH@Z
	DD	FLAT:?AddItToGlobalId@CCtrl@@UAEXXZ
	DD	FLAT:?RemoveItFromGlobalId@CCtrl@@UAEXXZ
	DD	FLAT:?ProcessCollecting@CUser@@UAEXXZ
	DD	FLAT:?StartCollecting@CUser@@UAEXXZ
	DD	FLAT:?StopCollecting@CUser@@UAEXXZ
	DD	FLAT:?SetIndex@CMover@@UAEHPAUIDirect3DDevice9@@KHH@Z
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
CONST	ENDS
;	COMDAT ??0CUser@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CUser@@QAE@XZ PROC NEAR				; CUser::CUser, COMDAT
; _this$ = ecx

; 110  : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$??0CUser@@QAE@XZ
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	51		 push	 ecx
  00016	56		 push	 esi
  00017	8b f1		 mov	 esi, ecx
  00019	57		 push	 edi
  0001a	89 74 24 08	 mov	 DWORD PTR _this$[esp+24], esi
  0001e	e8 00 00 00 00	 call	 ??0CMover@@QAE@XZ	; CMover::CMover
  00023	8d 8e ec 16 00
	00		 lea	 ecx, DWORD PTR [esi+5868]
  00029	c7 44 24 14 00
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+32], 0
  00031	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7CUser@@6B@
  00037	e8 00 00 00 00	 call	 ??0CSnapshot@@QAE@XZ	; CSnapshot::CSnapshot
  0003c	8d be 10 57 00
	00		 lea	 edi, DWORD PTR [esi+22288]
  00042	8b cf		 mov	 ecx, edi
  00044	c6 44 24 14 01	 mov	 BYTE PTR __$EHRec$[esp+32], 1
  00049	e8 00 00 00 00	 call	 ?_Buynode@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::_Buynode
  0004e	89 47 04	 mov	 DWORD PTR [edi+4], eax
  00051	c6 40 15 01	 mov	 BYTE PTR [eax+21], 1
  00055	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00058	89 40 04	 mov	 DWORD PTR [eax+4], eax
  0005b	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0005e	89 00		 mov	 DWORD PTR [eax], eax
  00060	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00063	89 40 08	 mov	 DWORD PTR [eax+8], eax
  00066	c7 47 08 00 00
	00 00		 mov	 DWORD PTR [edi+8], 0
  0006d	8d 8e 7c 57 00
	00		 lea	 ecx, DWORD PTR [esi+22396]
  00073	c6 44 24 14 02	 mov	 BYTE PTR __$EHRec$[esp+32], 2
  00078	e8 00 00 00 00	 call	 ??0CUserTaskBar@@QAE@XZ	; CUserTaskBar::CUserTaskBar
  0007d	8d 8e 4c 95 00
	00		 lea	 ecx, DWORD PTR [esi+38220]
  00083	c6 44 24 14 03	 mov	 BYTE PTR __$EHRec$[esp+32], 3
  00088	e8 00 00 00 00	 call	 ??0CRTMessenger@@QAE@XZ	; CRTMessenger::CRTMessenger
  0008d	8d 8e a4 95 00
	00		 lea	 ecx, DWORD PTR [esi+38308]
  00093	c6 44 24 14 04	 mov	 BYTE PTR __$EHRec$[esp+32], 4
  00098	e8 00 00 00 00	 call	 ??0CCooltimeMgr@@QAE@XZ	; CCooltimeMgr::CCooltimeMgr

; 111  : 	Init();

  0009d	6a ff		 push	 -1
  0009f	6a ff		 push	 -1
  000a1	8b ce		 mov	 ecx, esi
  000a3	e8 00 00 00 00	 call	 ?Init@CUser@@AAEXKK@Z	; CUser::Init

; 112  : }

  000a8	8b 4c 24 0c	 mov	 ecx, DWORD PTR __$EHRec$[esp+24]
  000ac	5f		 pop	 edi
  000ad	8b c6		 mov	 eax, esi
  000af	5e		 pop	 esi
  000b0	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  000b7	83 c4 10	 add	 esp, 16			; 00000010H
  000ba	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L359723:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1CMover@@UAE@XZ	; CMover::~CMover
$L359724:
  00008	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	81 c1 ec 16 00
	00		 add	 ecx, 5868		; 000016ecH
  00011	e9 00 00 00 00	 jmp	 ??1CSnapshot@@UAE@XZ	; CSnapshot::~CSnapshot
$L359725:
  00016	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00019	81 c1 10 57 00
	00		 add	 ecx, 22288		; 00005710H
  0001f	e9 00 00 00 00	 jmp	 ??1?$map@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@@std@@QAE@XZ
$L359726:
  00024	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00027	81 c1 7c 57 00
	00		 add	 ecx, 22396		; 0000577cH
  0002d	e9 00 00 00 00	 jmp	 ??1CUserTaskBar@@UAE@XZ	; CUserTaskBar::~CUserTaskBar
$L359727:
  00032	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00035	81 c1 4c 95 00
	00		 add	 ecx, 38220		; 0000954cH
  0003b	e9 00 00 00 00	 jmp	 ??1CRTMessenger@@UAE@XZ	; CRTMessenger::~CRTMessenger
__ehhandler$??0CUser@@QAE@XZ:
  00040	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T359947
  00045	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0CUser@@QAE@XZ ENDP					; CUser::CUser
PUBLIC	??_C@_05CJBACGMB@hello?$AA@			; `string'
;	COMDAT ??_C@_05CJBACGMB@hello?$AA@
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\obj.h
CONST	SEGMENT
??_C@_05CJBACGMB@hello?$AA@ DB 'hello', 00H		; `string'
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ?GetName@CObj@@UAEPBDXZ
_TEXT	SEGMENT
?GetName@CObj@@UAEPBDXZ PROC NEAR			; CObj::GetName, COMDAT
; _this$ = ecx

; 166  : 	virtual	LPCTSTR GetName() { return _T( "hello" ); }

  00000	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:??_C@_05CJBACGMB@hello?$AA@
  00005	c3		 ret	 0
?GetName@CObj@@UAEPBDXZ ENDP				; CObj::GetName
_TEXT	ENDS
EXTRN	?SetTypeIndex@CObj@@QAEHPAUIDirect3DDevice9@@KKH@Z:NEAR ; CObj::SetTypeIndex
; Function compile flags: /Ogty
;	COMDAT ?SetIndex@CObj@@UAEHPAUIDirect3DDevice9@@KH@Z
_TEXT	SEGMENT
_pd3dDevice$ = 8					; size = 4
_dwIndex$ = 12						; size = 4
_bInitProp$ = 16					; size = 4
?SetIndex@CObj@@UAEHPAUIDirect3DDevice9@@KH@Z PROC NEAR	; CObj::SetIndex, COMDAT
; _this$ = ecx

; 172  : 	virtual	BOOL	SetIndex( LPDIRECT3DDEVICE9 pd3dDevice, DWORD dwIndex, BOOL bInitProp = FALSE ) { return SetTypeIndex( pd3dDevice, m_dwType, dwIndex, bInitProp ); }

  00000	8b 44 24 0c	 mov	 eax, DWORD PTR _bInitProp$[esp-4]
  00004	8b 54 24 08	 mov	 edx, DWORD PTR _dwIndex$[esp-4]
  00008	50		 push	 eax
  00009	8b 81 70 01 00
	00		 mov	 eax, DWORD PTR [ecx+368]
  0000f	52		 push	 edx
  00010	8b 54 24 0c	 mov	 edx, DWORD PTR _pd3dDevice$[esp+4]
  00014	50		 push	 eax
  00015	52		 push	 edx
  00016	e8 00 00 00 00	 call	 ?SetTypeIndex@CObj@@QAEHPAUIDirect3DDevice9@@KKH@Z ; CObj::SetTypeIndex
  0001b	c2 0c 00	 ret	 12			; 0000000cH
?SetIndex@CObj@@UAEHPAUIDirect3DDevice9@@KH@Z ENDP	; CObj::SetIndex
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\mover.h
_TEXT	ENDS
;	COMDAT ?SendDamage@CMover@@UAEHKKHH@Z
_TEXT	SEGMENT
_dwAtkFlag$ = 8						; size = 4
_idAttacker$ = 12					; size = 4
_nParam$ = 16						; size = 4
_bTarget$ = 20						; size = 4
?SendDamage@CMover@@UAEHKKHH@Z PROC NEAR		; CMover::SendDamage, COMDAT
; _this$ = ecx

; 998  : 	virtual int		SendDamage( DWORD dwAtkFlag, OBJID idAttacker, int nParam = 0, BOOL bTarget = TRUE ) { return m_pActMover->SendDamage( dwAtkFlag, idAttacker, nParam, bTarget );  }

  00000	8b 54 24 10	 mov	 edx, DWORD PTR _bTarget$[esp-4]
  00004	8b 89 3c 02 00
	00		 mov	 ecx, DWORD PTR [ecx+572]
  0000a	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000c	6a 00		 push	 0
  0000e	52		 push	 edx
  0000f	8b 54 24 14	 mov	 edx, DWORD PTR _nParam$[esp+4]
  00013	52		 push	 edx
  00014	8b 54 24 14	 mov	 edx, DWORD PTR _idAttacker$[esp+8]
  00018	52		 push	 edx
  00019	8b 54 24 14	 mov	 edx, DWORD PTR _dwAtkFlag$[esp+12]
  0001d	52		 push	 edx
  0001e	6a 29		 push	 41			; 00000029H
  00020	ff 50 04	 call	 DWORD PTR [eax+4]
  00023	c2 10 00	 ret	 16			; 00000010H
?SendDamage@CMover@@UAEHKKHH@Z ENDP			; CMover::SendDamage
_TEXT	ENDS
EXTRN	?SendDamageForce@CActionMover@@QAEHKKHH@Z:NEAR	; CActionMover::SendDamageForce
; Function compile flags: /Ogty
;	COMDAT ?SendDamageForce@CMover@@UAEHKKHH@Z
_TEXT	SEGMENT
_dwAtkFlag$ = 8						; size = 4
_idAttacker$ = 12					; size = 4
_nParam$ = 16						; size = 4
_bTarget$ = 20						; size = 4
?SendDamageForce@CMover@@UAEHKKHH@Z PROC NEAR		; CMover::SendDamageForce, COMDAT
; _this$ = ecx

; 999  : 	virtual int		SendDamageForce( DWORD dwAtkFlag, OBJID idAttacker, int nParam = 0, BOOL bTarget = TRUE ) { return m_pActMover->SendDamageForce( dwAtkFlag, idAttacker, nParam, bTarget ); }	// 

  00000	8b 89 3c 02 00
	00		 mov	 ecx, DWORD PTR [ecx+572]
  00006	e9 00 00 00 00	 jmp	 ?SendDamageForce@CActionMover@@QAEHKKHH@Z ; CActionMover::SendDamageForce
?SendDamageForce@CMover@@UAEHKKHH@Z ENDP		; CMover::SendDamageForce
_TEXT	ENDS
PUBLIC	??0CUser@@QAE@KK@Z				; CUser::CUser
;	COMDAT xdata$x
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\dx_sdk\d3dx9math.h
xdata$x	SEGMENT
$T360198 DD	0ffffffffH
	DD	FLAT:$L359972
	DD	00H
	DD	FLAT:$L359973
	DD	01H
	DD	FLAT:$L359974
	DD	02H
	DD	FLAT:$L359975
	DD	03H
	DD	FLAT:$L359976
$T360196 DD	019930520H
	DD	05H
	DD	FLAT:$T360198
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
xdata$x	ENDS
;	COMDAT ??0CUser@@QAE@KK@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_dpidCache$ = 8						; size = 4
_dpidUser$ = 12						; size = 4
??0CUser@@QAE@KK@Z PROC NEAR				; CUser::CUser, COMDAT
; _this$ = ecx

; 115  : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$??0CUser@@QAE@KK@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	51		 push	 ecx
  00016	56		 push	 esi
  00017	8b f1		 mov	 esi, ecx
  00019	57		 push	 edi
  0001a	89 74 24 08	 mov	 DWORD PTR _this$[esp+24], esi
  0001e	e8 00 00 00 00	 call	 ??0CMover@@QAE@XZ	; CMover::CMover
  00023	8d 8e ec 16 00
	00		 lea	 ecx, DWORD PTR [esi+5868]
  00029	c7 44 24 14 00
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+32], 0
  00031	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7CUser@@6B@
  00037	e8 00 00 00 00	 call	 ??0CSnapshot@@QAE@XZ	; CSnapshot::CSnapshot
  0003c	8d be 10 57 00
	00		 lea	 edi, DWORD PTR [esi+22288]
  00042	8b cf		 mov	 ecx, edi
  00044	c6 44 24 14 01	 mov	 BYTE PTR __$EHRec$[esp+32], 1
  00049	e8 00 00 00 00	 call	 ?_Buynode@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::_Buynode
  0004e	89 47 04	 mov	 DWORD PTR [edi+4], eax
  00051	c6 40 15 01	 mov	 BYTE PTR [eax+21], 1
  00055	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00058	89 40 04	 mov	 DWORD PTR [eax+4], eax
  0005b	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0005e	89 00		 mov	 DWORD PTR [eax], eax
  00060	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00063	89 40 08	 mov	 DWORD PTR [eax+8], eax
  00066	c7 47 08 00 00
	00 00		 mov	 DWORD PTR [edi+8], 0
  0006d	8d 8e 7c 57 00
	00		 lea	 ecx, DWORD PTR [esi+22396]
  00073	c6 44 24 14 02	 mov	 BYTE PTR __$EHRec$[esp+32], 2
  00078	e8 00 00 00 00	 call	 ??0CUserTaskBar@@QAE@XZ	; CUserTaskBar::CUserTaskBar
  0007d	8d 8e 4c 95 00
	00		 lea	 ecx, DWORD PTR [esi+38220]
  00083	c6 44 24 14 03	 mov	 BYTE PTR __$EHRec$[esp+32], 3
  00088	e8 00 00 00 00	 call	 ??0CRTMessenger@@QAE@XZ	; CRTMessenger::CRTMessenger
  0008d	8d 8e a4 95 00
	00		 lea	 ecx, DWORD PTR [esi+38308]
  00093	c6 44 24 14 04	 mov	 BYTE PTR __$EHRec$[esp+32], 4
  00098	e8 00 00 00 00	 call	 ??0CCooltimeMgr@@QAE@XZ	; CCooltimeMgr::CCooltimeMgr

; 116  : 	Init( dpidCache, dpidUser );

  0009d	8b 44 24 20	 mov	 eax, DWORD PTR _dpidUser$[esp+20]
  000a1	8b 4c 24 1c	 mov	 ecx, DWORD PTR _dpidCache$[esp+20]
  000a5	50		 push	 eax
  000a6	51		 push	 ecx
  000a7	8b ce		 mov	 ecx, esi
  000a9	e8 00 00 00 00	 call	 ?Init@CUser@@AAEXKK@Z	; CUser::Init

; 117  : }

  000ae	8b 4c 24 0c	 mov	 ecx, DWORD PTR __$EHRec$[esp+24]
  000b2	5f		 pop	 edi
  000b3	8b c6		 mov	 eax, esi
  000b5	5e		 pop	 esi
  000b6	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  000bd	83 c4 10	 add	 esp, 16			; 00000010H
  000c0	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L359972:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1CMover@@UAE@XZ	; CMover::~CMover
$L359973:
  00008	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	81 c1 ec 16 00
	00		 add	 ecx, 5868		; 000016ecH
  00011	e9 00 00 00 00	 jmp	 ??1CSnapshot@@UAE@XZ	; CSnapshot::~CSnapshot
$L359974:
  00016	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00019	81 c1 10 57 00
	00		 add	 ecx, 22288		; 00005710H
  0001f	e9 00 00 00 00	 jmp	 ??1?$map@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@@std@@QAE@XZ
$L359975:
  00024	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00027	81 c1 7c 57 00
	00		 add	 ecx, 22396		; 0000577cH
  0002d	e9 00 00 00 00	 jmp	 ??1CUserTaskBar@@UAE@XZ	; CUserTaskBar::~CUserTaskBar
$L359976:
  00032	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00035	81 c1 4c 95 00
	00		 add	 ecx, 38220		; 0000954cH
  0003b	e9 00 00 00 00	 jmp	 ??1CRTMessenger@@UAE@XZ	; CRTMessenger::~CRTMessenger
__ehhandler$??0CUser@@QAE@KK@Z:
  00040	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T360196
  00045	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0CUser@@QAE@KK@Z ENDP					; CUser::CUser
PUBLIC	??1CUser@@UAE@XZ				; CUser::~CUser
EXTRN	??1CCooltimeMgr@@UAE@XZ:NEAR			; CCooltimeMgr::~CCooltimeMgr
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
xdata$x	SEGMENT
$T360373 DD	0ffffffffH
	DD	FLAT:$L360204
	DD	00H
	DD	FLAT:$L360205
	DD	01H
	DD	FLAT:$L360206
	DD	02H
	DD	FLAT:$L360207
	DD	03H
	DD	FLAT:$L360208
	DD	04H
	DD	FLAT:$L360209
$T360371 DD	019930520H
	DD	06H
	DD	FLAT:$T360373
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
xdata$x	ENDS
;	COMDAT ??1CUser@@UAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T360343 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CUser@@UAE@XZ PROC NEAR				; CUser::~CUser, COMDAT
; _this$ = ecx

; 120  : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$??1CUser@@UAE@XZ
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	83 ec 08	 sub	 esp, 8
  00018	56		 push	 esi
  00019	8b f1		 mov	 esi, ecx
  0001b	57		 push	 edi
  0001c	89 74 24 08	 mov	 DWORD PTR _this$[esp+28], esi
  00020	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7CUser@@6B@

; 121  : 	RemoveItFromView2();	// npc

  00026	6a 00		 push	 0
  00028	c7 44 24 1c 05
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+40], 5
  00030	e8 00 00 00 00	 call	 ?RemoveItFromView2@CUser@@QAEXH@Z ; CUser::RemoveItFromView2

; 122  : }

  00035	8d 8e a4 95 00
	00		 lea	 ecx, DWORD PTR [esi+38308]
  0003b	c6 44 24 18 04	 mov	 BYTE PTR __$EHRec$[esp+36], 4
  00040	e8 00 00 00 00	 call	 ??1CCooltimeMgr@@UAE@XZ	; CCooltimeMgr::~CCooltimeMgr
  00045	8d 8e 4c 95 00
	00		 lea	 ecx, DWORD PTR [esi+38220]
  0004b	c6 44 24 18 03	 mov	 BYTE PTR __$EHRec$[esp+36], 3
  00050	e8 00 00 00 00	 call	 ??1CRTMessenger@@UAE@XZ	; CRTMessenger::~CRTMessenger
  00055	8d 8e 7c 57 00
	00		 lea	 ecx, DWORD PTR [esi+22396]
  0005b	c6 44 24 18 02	 mov	 BYTE PTR __$EHRec$[esp+36], 2
  00060	e8 00 00 00 00	 call	 ??1CUserTaskBar@@UAE@XZ	; CUserTaskBar::~CUserTaskBar
  00065	8b 86 14 57 00
	00		 mov	 eax, DWORD PTR [esi+22292]
  0006b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0006d	8d be 10 57 00
	00		 lea	 edi, DWORD PTR [esi+22288]
  00073	50		 push	 eax
  00074	51		 push	 ecx
  00075	8d 44 24 14	 lea	 eax, DWORD PTR $T360343[esp+36]
  00079	50		 push	 eax
  0007a	8b cf		 mov	 ecx, edi
  0007c	c6 44 24 24 01	 mov	 BYTE PTR __$EHRec$[esp+48], 1
  00081	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CCtrl *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CCtrl *> >,0> >::erase
  00086	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00089	50		 push	 eax
  0008a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0008f	83 c4 04	 add	 esp, 4
  00092	8d 8e ec 16 00
	00		 lea	 ecx, DWORD PTR [esi+5868]
  00098	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0
  0009f	c7 47 08 00 00
	00 00		 mov	 DWORD PTR [edi+8], 0
  000a6	c6 44 24 18 00	 mov	 BYTE PTR __$EHRec$[esp+36], 0
  000ab	e8 00 00 00 00	 call	 ??1CSnapshot@@UAE@XZ	; CSnapshot::~CSnapshot
  000b0	8b ce		 mov	 ecx, esi
  000b2	c7 44 24 18 ff
	ff ff ff	 mov	 DWORD PTR __$EHRec$[esp+36], -1
  000ba	e8 00 00 00 00	 call	 ??1CMover@@UAE@XZ	; CMover::~CMover
  000bf	8b 4c 24 10	 mov	 ecx, DWORD PTR __$EHRec$[esp+28]
  000c3	5f		 pop	 edi
  000c4	5e		 pop	 esi
  000c5	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  000cc	83 c4 14	 add	 esp, 20			; 00000014H
  000cf	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L360204:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1CMover@@UAE@XZ	; CMover::~CMover
$L360205:
  00008	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	81 c1 ec 16 00
	00		 add	 ecx, 5868		; 000016ecH
  00011	e9 00 00 00 00	 jmp	 ??1CSnapshot@@UAE@XZ	; CSnapshot::~CSnapshot
$L360206:
  00016	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00019	81 c1 10 57 00
	00		 add	 ecx, 22288		; 00005710H
  0001f	e9 00 00 00 00	 jmp	 ??1?$map@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@@std@@QAE@XZ
$L360207:
  00024	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00027	81 c1 7c 57 00
	00		 add	 ecx, 22396		; 0000577cH
  0002d	e9 00 00 00 00	 jmp	 ??1CUserTaskBar@@UAE@XZ	; CUserTaskBar::~CUserTaskBar
$L360208:
  00032	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00035	81 c1 4c 95 00
	00		 add	 ecx, 38220		; 0000954cH
  0003b	e9 00 00 00 00	 jmp	 ??1CRTMessenger@@UAE@XZ	; CRTMessenger::~CRTMessenger
$L360209:
  00040	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00043	81 c1 a4 95 00
	00		 add	 ecx, 38308		; 000095a4H
  00049	e9 00 00 00 00	 jmp	 ??1CCooltimeMgr@@UAE@XZ	; CCooltimeMgr::~CCooltimeMgr
__ehhandler$??1CUser@@UAE@XZ:
  0004e	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T360371
  00053	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??1CUser@@UAE@XZ ENDP					; CUser::~CUser
PUBLIC	?Open@CUser@@QAEXK@Z				; CUser::Open
EXTRN	?SetSnapshot@CSnapshot@@QAEXKK@Z:NEAR		; CSnapshot::SetSnapshot
EXTRN	?GetTickCount@CGameTimer@@QAENXZ:NEAR		; CGameTimer::GetTickCount
EXTRN	?g_GameTimer@@3VCGameTimer@@A:BYTE		; g_GameTimer
; Function compile flags: /Ogty
;	COMDAT ?Open@CUser@@QAEXK@Z
_TEXT	SEGMENT
$T360387 = -4						; size = 4
_dwWorldId$ = 8						; size = 4
?Open@CUser@@QAEXK@Z PROC NEAR				; CUser::Open, COMDAT
; _this$ = ecx

; 310  : {

  00000	51		 push	 ecx
  00001	56		 push	 esi
  00002	8b f1		 mov	 esi, ecx

; 311  : 	AddItToGlobalId();

  00004	8b 06		 mov	 eax, DWORD PTR [esi]
  00006	ff 50 3c	 call	 DWORD PTR [eax+60]

; 312  : 	PCSetAt( GetId(), (CCtrl*)this );

  00009	8b 8e bc 01 00
	00		 mov	 ecx, DWORD PTR [esi+444]
  0000f	8d 54 24 04	 lea	 edx, DWORD PTR $T360387[esp+8]
  00013	89 4c 24 04	 mov	 DWORD PTR $T360387[esp+8], ecx
  00017	52		 push	 edx
  00018	8d 8e 0c 02 00
	00		 lea	 ecx, DWORD PTR [esi+524]
  0001e	e8 00 00 00 00	 call	 ??A?$map@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@@std@@QAEAAPAVCUser@@ABK@Z ; std::map<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> > >::operator[]
  00023	89 30		 mov	 DWORD PTR [eax], esi

; 313  : 	m_Snapshot.SetSnapshot( GetId(),  PACKETTYPE_JOIN );

  00025	8b 86 bc 01 00
	00		 mov	 eax, DWORD PTR [esi+444]
  0002b	68 00 ff 00 00	 push	 65280			; 0000ff00H
  00030	50		 push	 eax
  00031	8d 8e ec 16 00
	00		 lea	 ecx, DWORD PTR [esi+5868]
  00037	e8 00 00 00 00	 call	 ?SetSnapshot@CSnapshot@@QAEXKK@Z ; CSnapshot::SetSnapshot

; 314  : 
; 315  : #ifdef __ENVIRONMENT_EFFECT
; 316  : 
; 317  : 	AddEnvironmentSetting();

  0003c	8b ce		 mov	 ecx, esi
  0003e	e8 00 00 00 00	 call	 ?AddEnvironmentSetting@CUser@@QAEXXZ ; CUser::AddEnvironmentSetting

; 318  : 
; 319  : #endif // __ENVIRONMENT_EFFECT
; 320  : 
; 321  : #ifdef __MAP_SECURITY
; 322  : 	AddWorldReadInfo( dwWorldId, GetPos() );

  00043	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00046	8d 8e 60 01 00
	00		 lea	 ecx, DWORD PTR [esi+352]
  0004c	8b 01		 mov	 eax, DWORD PTR [ecx]
  0004e	8b d4		 mov	 edx, esp
  00050	89 02		 mov	 DWORD PTR [edx], eax
  00052	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00055	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  00058	89 42 04	 mov	 DWORD PTR [edx+4], eax
  0005b	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  0005e	8b 54 24 18	 mov	 edx, DWORD PTR _dwWorldId$[esp+16]
  00062	52		 push	 edx
  00063	8b ce		 mov	 ecx, esi
  00065	e8 00 00 00 00	 call	 ?AddWorldReadInfo@CUser@@QAEXKUD3DXVECTOR3@@@Z ; CUser::AddWorldReadInfo

; 323  : #endif // __MAP_SECURITY
; 324  : 	AddAddObj( (CCtrl*)this );

  0006a	56		 push	 esi
  0006b	8b ce		 mov	 ecx, esi
  0006d	e8 00 00 00 00	 call	 ?AddAddObj@CUser@@QAEXPAVCCtrl@@@Z ; CUser::AddAddObj

; 325  : 	AddGameTimer( g_GameTimer.GetCurrentTime() );

  00072	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_GameTimer@@3VCGameTimer@@A
  00077	e8 00 00 00 00	 call	 ?GetTickCount@CGameTimer@@QAENXZ ; CGameTimer::GetTickCount
  0007c	83 ec 08	 sub	 esp, 8
  0007f	8b ce		 mov	 ecx, esi
  00081	dd 1c 24	 fstp	 QWORD PTR [esp]
  00084	e8 00 00 00 00	 call	 ?AddGameTimer@CUser@@QAEXN@Z ; CUser::AddGameTimer

; 326  : 	AddTaskBar();

  00089	8b ce		 mov	 ecx, esi
  0008b	e8 00 00 00 00	 call	 ?AddTaskBar@CUser@@QAEXXZ ; CUser::AddTaskBar

; 327  : 	AddEnvironment();

  00090	8b ce		 mov	 ecx, esi
  00092	e8 00 00 00 00	 call	 ?AddEnvironment@CUser@@QAEXXZ ; CUser::AddEnvironment

; 328  : #if __VER >= 11 // __SYS_PLAYER_DATA
; 329  : 	AddPlayerData();

  00097	8b ce		 mov	 ecx, esi
  00099	e8 00 00 00 00	 call	 ?AddPlayerData@CUser@@QAEXXZ ; CUser::AddPlayerData

; 330  : #endif	// __SYS_PLAYER_DATA
; 331  : 	AddFriendGameJoin();

  0009e	8b ce		 mov	 ecx, esi
  000a0	e8 00 00 00 00	 call	 ?AddFriendGameJoin@CUser@@QAEXXZ ; CUser::AddFriendGameJoin

; 332  : 	AddPartyName();

  000a5	8b ce		 mov	 ecx, esi
  000a7	e8 00 00 00 00	 call	 ?AddPartyName@CUser@@QAEXXZ ; CUser::AddPartyName

; 333  : 	ADDGameJoin();

  000ac	8b ce		 mov	 ecx, esi
  000ae	e8 00 00 00 00	 call	 ?ADDGameJoin@CUser@@QAEXXZ ; CUser::ADDGameJoin

; 334  : 
; 335  : 	AddAllGuilds();

  000b3	8b ce		 mov	 ecx, esi
  000b5	e8 00 00 00 00	 call	 ?AddAllGuilds@CUser@@QAEXXZ ; CUser::AddAllGuilds

; 336  : 	AddMyGuild();

  000ba	8b ce		 mov	 ecx, esi
  000bc	e8 00 00 00 00	 call	 ?AddMyGuild@CUser@@QAEXXZ ; CUser::AddMyGuild

; 337  : 	AddMyGuildWar();

  000c1	8b ce		 mov	 ecx, esi
  000c3	e8 00 00 00 00	 call	 ?AddMyGuildWar@CUser@@QAEXXZ ; CUser::AddMyGuildWar

; 338  : 
; 339  : 	AddFlyffEvent();

  000c8	8b ce		 mov	 ecx, esi
  000ca	e8 00 00 00 00	 call	 ?AddFlyffEvent@CUser@@QAEXXZ ; CUser::AddFlyffEvent

; 340  : 
; 341  : #if __VER >= 12 // __LORD
; 342  : 	AddLord();

  000cf	8b ce		 mov	 ecx, esi
  000d1	e8 00 00 00 00	 call	 ?AddLord@CUser@@QAEXXZ	; CUser::AddLord

; 343  : #endif	// __LORD
; 344  : #if __VER >= 13 // __COUPLE_1117
; 345  : 	AddCouple();

  000d6	8b ce		 mov	 ecx, esi
  000d8	e8 00 00 00 00	 call	 ?AddCouple@CUser@@QAEXXZ ; CUser::AddCouple

; 346  : #endif	// __COUPLE_1117
; 347  : 		
; 348  : /*	// chipi_090617 - .
; 349  : 	CItemElem *pShield = GetEquipItem( PARTS_SHIELD );
; 350  : 	if( pShield )	//   
; 351  : 	{
; 352  : 		ItemProp *pHandItemProp = GetActiveHandItemProp();
; 353  : 		if( pHandItemProp->dwHanded == HD_TWO )	//   .
; 354  : 		{
; 355  : 			DoEquip( pShield, 0 );	//  ;
; 356  : 			AddDoEquip( pShield->m_dwObjId, pShield->m_dwItemId, 0 );
; 357  : 		}
; 358  : 	}
; 359  : */
; 360  : }

  000dd	5e		 pop	 esi
  000de	59		 pop	 ecx
  000df	c2 04 00	 ret	 4
?Open@CUser@@QAEXK@Z ENDP				; CUser::Open
_TEXT	ENDS
PUBLIC	??0CUserMng@@QAE@XZ				; CUserMng::CUserMng
; Function compile flags: /Ogty
;	COMDAT ??0CUserMng@@QAE@XZ
_TEXT	SEGMENT
??0CUserMng@@QAE@XZ PROC NEAR				; CUserMng::CUserMng, COMDAT
; _this$ = ecx

; 3856 : {

  00000	56		 push	 esi
  00001	57		 push	 edi
  00002	8b f9		 mov	 edi, ecx
  00004	8d 77 08	 lea	 esi, DWORD PTR [edi+8]
  00007	8b ce		 mov	 ecx, esi
  00009	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET FLAT:??_7CUserMng@@6B@
  0000f	e8 00 00 00 00	 call	 ?_Buynode@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::_Buynode
  00014	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00017	c6 40 15 01	 mov	 BYTE PTR [eax+21], 1
  0001b	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0001e	89 40 04	 mov	 DWORD PTR [eax+4], eax
  00021	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00024	89 00		 mov	 DWORD PTR [eax], eax
  00026	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00029	89 40 08	 mov	 DWORD PTR [eax+8], eax
  0002c	33 c0		 xor	 eax, eax
  0002e	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 3857 : 	m_lCount = 0;

  00031	89 47 04	 mov	 DWORD PTR [edi+4], eax

; 3858 : }

  00034	8b c7		 mov	 eax, edi
  00036	5f		 pop	 edi
  00037	5e		 pop	 esi
  00038	c3		 ret	 0
??0CUserMng@@QAE@XZ ENDP				; CUserMng::CUserMng
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ??_GCUserMng@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCUserMng@@UAEPAXI@Z PROC NEAR			; CUserMng::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	e8 00 00 00 00	 call	 ??1CUserMng@@UAE@XZ	; CUserMng::~CUserMng
  00008	f6 44 24 08 01	 test	 BYTE PTR ___flags$[esp], 1
  0000d	74 09		 je	 SHORT $L360616
  0000f	56		 push	 esi
  00010	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00015	83 c4 04	 add	 esp, 4
$L360616:
  00018	8b c6		 mov	 eax, esi
  0001a	5e		 pop	 esi
  0001b	c2 04 00	 ret	 4
??_GCUserMng@@UAEPAXI@Z ENDP				; CUserMng::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?AddUser@CUserMng@@QAEPAVCUser@@KKK@Z		; CUserMng::AddUser
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\utility
xdata$x	SEGMENT
$T360720 DD	0ffffffffH
	DD	FLAT:$L360627
$T360717 DD	019930520H
	DD	01H
	DD	FLAT:$T360720
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
xdata$x	ENDS
;	COMDAT ?AddUser@CUserMng@@QAEPAVCUser@@KKK@Z
_TEXT	SEGMENT
_it$360699 = -28					; size = 4
$T360624 = -28						; size = 8
$T360626 = -20						; size = 8
__$EHRec$ = -12						; size = 12
_dpidCache$ = 8						; size = 4
$T360702 = 12						; size = 4
$T360621 = 12						; size = 4
_dpidUser$ = 12						; size = 4
_dpidSocket$ = 16					; size = 4
?AddUser@CUserMng@@QAEPAVCUser@@KKK@Z PROC NEAR		; CUserMng::AddUser, COMDAT
; _this$ = ecx

; 3881 : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?AddUser@CUserMng@@QAEPAVCUser@@KKK@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	83 ec 10	 sub	 esp, 16			; 00000010H
  00018	53		 push	 ebx

; 3882 : 	CUser *pUser = GetUser( dpidCache, dpidUser );

  00019	8b 5c 24 28	 mov	 ebx, DWORD PTR _dpidUser$[esp+28]
  0001d	56		 push	 esi
  0001e	57		 push	 edi
  0001f	8b f1		 mov	 esi, ecx
  00021	8d 44 24 30	 lea	 eax, DWORD PTR $T360702[esp+36]
  00025	50		 push	 eax
  00026	8d 4c 24 10	 lea	 ecx, DWORD PTR _it$360699[esp+44]
  0002a	8d 7e 08	 lea	 edi, DWORD PTR [esi+8]
  0002d	51		 push	 ecx
  0002e	8b cf		 mov	 ecx, edi
  00030	89 5c 24 38	 mov	 DWORD PTR $T360702[esp+44], ebx
  00034	e8 00 00 00 00	 call	 ?find@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::find
  00039	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  0003c	8b 4c 24 0c	 mov	 ecx, DWORD PTR _it$360699[esp+40]
  00040	3b c8		 cmp	 ecx, eax
  00042	74 07		 je	 SHORT $L360718

; 3883 : 	if( pUser == NULL )

  00044	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00047	85 c0		 test	 eax, eax
  00049	75 78		 jne	 SHORT $L280038
$L360718:

; 3884 : 	{
; 3885 : 		++m_lCount;

  0004b	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0004e	40		 inc	 eax

; 3886 : 		
; 3887 : 		pUser = new CUser( dpidCache, dpidSocket );

  0004f	68 c0 96 00 00	 push	 38592			; 000096c0H
  00054	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00057	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0005c	83 c4 04	 add	 esp, 4
  0005f	89 44 24 30	 mov	 DWORD PTR $T360621[esp+36], eax
  00063	85 c0		 test	 eax, eax
  00065	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+48], 0
  0006d	74 15		 je	 SHORT $L360622
  0006f	8b 54 24 34	 mov	 edx, DWORD PTR _dpidSocket$[esp+36]
  00073	8b 4c 24 2c	 mov	 ecx, DWORD PTR _dpidCache$[esp+36]
  00077	52		 push	 edx
  00078	51		 push	 ecx
  00079	8b c8		 mov	 ecx, eax
  0007b	e8 00 00 00 00	 call	 ??0CUser@@QAE@KK@Z	; CUser::CUser
  00080	8b f0		 mov	 esi, eax
  00082	eb 02		 jmp	 SHORT $L360623
$L360622:
  00084	33 f6		 xor	 esi, esi
$L360623:

; 3888 : 		pUser->m_dwSerial = dpidUser;
; 3889 : 		m_users.insert( make_pair( dpidUser, pUser ) );

  00086	8d 54 24 0c	 lea	 edx, DWORD PTR $T360624[esp+40]
  0008a	52		 push	 edx
  0008b	8d 44 24 18	 lea	 eax, DWORD PTR $T360626[esp+44]
  0008f	50		 push	 eax
  00090	8b cf		 mov	 ecx, edi
  00092	c7 44 24 2c ff
	ff ff ff	 mov	 DWORD PTR __$EHRec$[esp+56], -1
  0009a	89 9e e4 16 00
	00		 mov	 DWORD PTR [esi+5860], ebx
  000a0	89 5c 24 14	 mov	 DWORD PTR $T360624[esp+48], ebx
  000a4	89 74 24 18	 mov	 DWORD PTR $T360624[esp+52], esi
  000a8	e8 00 00 00 00	 call	 ?insert@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBKPAVCUser@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::insert
  000ad	5f		 pop	 edi

; 3890 : 	}
; 3891 : 	else
; 3892 : 	{
; 3893 : 		ASSERT( FALSE );
; 3894 : 		pUser = NULL;
; 3895 : 	}
; 3896 : 
; 3897 : 	return pUser;

  000ae	8b c6		 mov	 eax, esi
  000b0	5e		 pop	 esi
  000b1	5b		 pop	 ebx

; 3898 : }

  000b2	8b 4c 24 10	 mov	 ecx, DWORD PTR __$EHRec$[esp+28]
  000b6	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  000bd	83 c4 1c	 add	 esp, 28			; 0000001cH
  000c0	c2 0c 00	 ret	 12			; 0000000cH
$L280038:
  000c3	8b 4c 24 1c	 mov	 ecx, DWORD PTR __$EHRec$[esp+40]
  000c7	5f		 pop	 edi
  000c8	5e		 pop	 esi
  000c9	33 c0		 xor	 eax, eax
  000cb	5b		 pop	 ebx
  000cc	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  000d3	83 c4 1c	 add	 esp, 28			; 0000001cH
  000d6	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L360627:
  00000	8b 45 08	 mov	 eax, DWORD PTR $T360621[ebp-4]
  00003	50		 push	 eax
  00004	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00009	59		 pop	 ecx
  0000a	c3		 ret	 0
__ehhandler$?AddUser@CUserMng@@QAEPAVCUser@@KKK@Z:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T360717
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?AddUser@CUserMng@@QAEPAVCUser@@KKK@Z ENDP		; CUserMng::AddUser
PUBLIC	?AddPlayer@CUserMng@@QAEHPAVCUser@@KH@Z		; CUserMng::AddPlayer
EXTRN	?AddObj@CWorldMng@@QAEHPAVCObj@@KHH@Z:NEAR	; CWorldMng::AddObj
; Function compile flags: /Ogty
;	COMDAT ?AddPlayer@CUserMng@@QAEHPAVCUser@@KH@Z
_TEXT	SEGMENT
_pUser$ = 8						; size = 4
_dwWorldID$ = 12					; size = 4
_nLayer$ = 16						; size = 4
?AddPlayer@CUserMng@@QAEHPAVCUser@@KH@Z PROC NEAR	; CUserMng::AddPlayer, COMDAT
; _this$ = ecx

; 3977 : {

  00000	56		 push	 esi

; 3978 : #ifdef __MAP_SECURITY
; 3979 : 	pUser->Open( dwWorldID );

  00001	8b 74 24 08	 mov	 esi, DWORD PTR _pUser$[esp]
  00005	57		 push	 edi
  00006	8b 7c 24 10	 mov	 edi, DWORD PTR _dwWorldID$[esp+4]
  0000a	57		 push	 edi
  0000b	8b ce		 mov	 ecx, esi
  0000d	e8 00 00 00 00	 call	 ?Open@CUser@@QAEXK@Z	; CUser::Open

; 3980 : #else // __MAP_SECURITY
; 3981 : 	pUser->Open();	// Including set id
; 3982 : #endif // __MAP_SECURITY
; 3983 : #ifdef __LAYER_1015
; 3984 : 	BOOL bResult = g_WorldMng.AddObj( pUser, dwWorldID, FALSE, nLayer ); 

  00012	8b 44 24 14	 mov	 eax, DWORD PTR _nLayer$[esp+4]
  00016	50		 push	 eax
  00017	6a 00		 push	 0
  00019	57		 push	 edi
  0001a	56		 push	 esi
  0001b	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_WorldMng@@3VCWorldMng@@A
  00020	e8 00 00 00 00	 call	 ?AddObj@CWorldMng@@QAEHPAVCObj@@KHH@Z ; CWorldMng::AddObj
  00025	5f		 pop	 edi

; 3985 : #else	//__LAYER_1015
; 3986 : 	BOOL bResult = g_WorldMng.AddObj( pUser, dwWorldID, FALSE ); 
; 3987 : #endif	// __LAYER_1015
; 3988 : 	pUser->SetValid( bResult );

  00026	89 86 e8 16 00
	00		 mov	 DWORD PTR [esi+5864], eax
  0002c	5e		 pop	 esi

; 3989 : 	return bResult;
; 3990 : }

  0002d	c2 0c 00	 ret	 12			; 0000000cH
?AddPlayer@CUserMng@@QAEHPAVCUser@@KH@Z ENDP		; CUserMng::AddPlayer
_TEXT	ENDS
PUBLIC	?CallTheRoll@CUserMng@@QAEXH@Z			; CUserMng::CallTheRoll
EXTRN	?SendQueryPostMail@CDPDatabaseClient@@QAEXKKAAVCItemElem@@HPAD1@Z:NEAR ; CDPDatabaseClient::SendQueryPostMail
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
xdata$x	SEGMENT
$T361431 DD	0ffffffffH
	DD	FLAT:$L360753
	DD	00H
	DD	FLAT:$L360754
$T361418 DD	019930520H
	DD	02H
	DD	FLAT:$T361431
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
xdata$x	ENDS
;	COMDAT ?CallTheRoll@CUserMng@@QAEXH@Z
_TEXT	SEGMENT
_vecItemInfo$284740 = -972				; size = 16
_size$284772 = -956					; size = 4
_i$ = -952						; size = 4
_nCount$284481 = -948					; size = 4
$T361416 = -944						; size = 4
_pUser$284473 = -940					; size = 4
$T360742 = -936						; size = 12
$T360746 = -924						; size = 12
$T360737 = -912						; size = 12
$T360747 = -900						; size = 12
$T360739 = -888						; size = 12
$T360748 = -876						; size = 12
$T360741 = -864						; size = 12
$T360749 = -852						; size = 12
$T360743 = -840						; size = 12
$T360750 = -828						; size = 12
$T360745 = -816						; size = 12
$T360751 = -804						; size = 12
$T360740 = -792						; size = 12
$T360752 = -780						; size = 12
$T360744 = -768						; size = 12
$T360736 = -756						; size = 12
$T360735 = -744						; size = 12
$T360738 = -732						; size = 12
_itemElem$284777 = -720					; size = 184
_lpText$284771 = -536					; size = 512
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_nBit$ = 8						; size = 4
?CallTheRoll@CUserMng@@QAEXH@Z PROC NEAR		; CUserMng::CallTheRoll, COMDAT
; _this$ = ecx

; 7555 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	6a ff		 push	 -1
  00008	68 00 00 00 00	 push	 __ehhandler$?CallTheRoll@CUserMng@@QAEXH@Z
  0000d	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00013	50		 push	 eax
  00014	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0001b	81 ec c0 03 00
	00		 sub	 esp, 960		; 000003c0H
  00021	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00026	33 c5		 xor	 eax, ebp
  00028	89 84 24 b8 03
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+972], eax

; 7556 : 	map<DWORD, CUser*>::iterator i;
; 7557 : 	for( i = m_users.begin(); i != m_users.end(); ++i )

  0002f	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  00032	53		 push	 ebx

; 7633 : #endif // __PETVIS
; 7634 : 						break;
; 7635 : 
; 7636 : 					default:
; 7637 : 						break;
; 7638 : 				}
; 7639 : #endif // #ifdef __EVENT_1101_2
; 7640 : 				char lpText[512];
; 7641 : 				for( size_t size=0; size<vecItemInfo.size(); size++ )

  00033	89 4c 24 20	 mov	 DWORD PTR $T361416[esp+976], ecx
  00037	8b 08		 mov	 ecx, DWORD PTR [eax]
  00039	3b c8		 cmp	 ecx, eax
  0003b	56		 push	 esi
  0003c	57		 push	 edi
  0003d	89 4c 24 20	 mov	 DWORD PTR _i$[esp+984], ecx
  00041	0f 84 86 05 00
	00		 je	 $L284472

; 7556 : 	map<DWORD, CUser*>::iterator i;
; 7557 : 	for( i = m_users.begin(); i != m_users.end(); ++i )

  00047	33 db		 xor	 ebx, ebx
  00049	8d a4 24 00 00
	00 00		 npad	 7
$L360799:

; 7558 : 	{
; 7559 : 		CUser* pUser = i->second;

  00050	8b 71 10	 mov	 esi, DWORD PTR [ecx+16]

; 7560 : 		if( pUser->IsValid() == FALSE )

  00053	f6 46 04 01	 test	 BYTE PTR [esi+4], 1
  00057	89 74 24 2c	 mov	 DWORD PTR _pUser$284473[esp+984], esi
  0005b	0f 85 52 05 00
	00		 jne	 $L284471
  00061	39 9e e8 16 00
	00		 cmp	 DWORD PTR [esi+5864], ebx
  00067	0f 84 46 05 00
	00		 je	 $L284471

; 7561 : 			continue;
; 7562 : 		if( pUser->GetEventFlagBit( nBit ) )	// 0 or 1

  0006d	8b 4d 08	 mov	 ecx, DWORD PTR _nBit$[ebp]
  00070	bf 01 00 00 00	 mov	 edi, 1
  00075	8b c7		 mov	 eax, edi
  00077	33 d2		 xor	 edx, edx
  00079	e8 00 00 00 00	 call	 __allshl
  0007e	23 86 e0 95 00
	00		 and	 eax, DWORD PTR [esi+38368]
  00084	23 96 e4 95 00
	00		 and	 edx, DWORD PTR [esi+38372]
  0008a	0b c2		 or	 eax, edx
  0008c	0f 85 21 05 00
	00		 jne	 $L284471

; 7563 : 			continue;
; 7564 : 		
; 7565 : 		if( pUser->GetLevel() < 16 )

  00092	83 be e0 05 00
	00 10		 cmp	 DWORD PTR [esi+1504], 16 ; 00000010H
  00099	0f 8c 14 05 00
	00		 jl	 $L284471

; 7566 : 		{
; 7567 : 			continue;
; 7568 : 		}
; 7569 : 
; 7570 : 		if( (int)( pUser->m_dwEventElapsed ) < nBit )

  0009f	8b 45 08	 mov	 eax, DWORD PTR _nBit$[ebp]
  000a2	39 86 ec 95 00
	00		 cmp	 DWORD PTR [esi+38380], eax
  000a8	7d 11		 jge	 SHORT $L284478

; 7571 : 		{
; 7572 : 			pUser->m_dwEventElapsed	= nBit;

  000aa	89 86 ec 95 00
	00		 mov	 DWORD PTR [esi+38380], eax

; 7573 : 			pUser->m_dwEventTime	= 1;	// restart

  000b0	89 be e8 95 00
	00		 mov	 DWORD PTR [esi+38376], edi

; 7574 : 		}
; 7575 : 		else

  000b6	e9 f8 04 00 00	 jmp	 $L284471
$L284478:

; 7576 : 		{
; 7577 : #ifdef __MAINSERVER
; 7578 : 			if( ++pUser->m_dwEventTime >= 60 )

  000bb	8b 96 e8 95 00
	00		 mov	 edx, DWORD PTR [esi+38376]
  000c1	42		 inc	 edx
  000c2	8b ca		 mov	 ecx, edx
  000c4	83 f9 3c	 cmp	 ecx, 60			; 0000003cH
  000c7	89 96 e8 95 00
	00		 mov	 DWORD PTR [esi+38376], edx
  000cd	0f 82 e0 04 00
	00		 jb	 $L284471

; 7579 : #else	// __MAINSERVER
; 7580 : 			if( ++pUser->m_dwEventTime >= 1 )
; 7581 : #endif	// __MAINSERVER
; 7582 : 			{
; 7583 : 				int nCount	= pUser->SetEventFlagBit( nBit );

  000d3	50		 push	 eax
  000d4	8b ce		 mov	 ecx, esi
  000d6	e8 00 00 00 00	 call	 ?SetEventFlagBit@CUser@@QAEHH@Z ; CUser::SetEventFlagBit

; 7584 : 				pUser->AddCallTheRoll();	// print

  000db	8b ce		 mov	 ecx, esi
  000dd	89 44 24 24	 mov	 DWORD PTR _nCount$284481[esp+984], eax
  000e1	e8 00 00 00 00	 call	 ?AddCallTheRoll@CUser@@QAEXXZ ; CUser::AddCallTheRoll

; 7585 : 				vector<ITEMINFO> vecItemInfo;

  000e6	89 5c 24 10	 mov	 DWORD PTR _vecItemInfo$284740[esp+988], ebx
  000ea	89 5c 24 14	 mov	 DWORD PTR _vecItemInfo$284740[esp+992], ebx
  000ee	89 5c 24 18	 mov	 DWORD PTR _vecItemInfo$284740[esp+996], ebx

; 7586 : #ifdef __EVENT_1101_2
; 7587 : 				//  
; 7588 : 				vecItemInfo.push_back( ITEMINFO( II_SYS_SYS_EVE_FUN01, 2, 0 ) );

  000f2	8d 84 24 f0 00
	00 00		 lea	 eax, DWORD PTR $T360735[esp+984]
  000f9	be 02 00 00 00	 mov	 esi, 2
  000fe	50		 push	 eax
  000ff	8d 4c 24 10	 lea	 ecx, DWORD PTR _vecItemInfo$284740[esp+988]
  00103	89 9c 24 d8 03
	00 00		 mov	 DWORD PTR __$EHRec$[esp+996], ebx
  0010a	c7 84 24 f4 00
	00 00 2c 68 00
	00		 mov	 DWORD PTR $T360735[esp+988], 26668 ; 0000682cH
  00115	89 b4 24 f8 00
	00 00		 mov	 DWORD PTR $T360735[esp+992], esi
  0011c	89 9c 24 fc 00
	00 00		 mov	 DWORD PTR $T360735[esp+996], ebx
  00123	e8 00 00 00 00	 call	 ?push_back@?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@QAEXABU__ITEMINFO@@@Z ; std::vector<__ITEMINFO,std::allocator<__ITEMINFO> >::push_back

; 7589 : 				
; 7590 : 				switch( nCount )

  00128	8b 44 24 24	 mov	 eax, DWORD PTR _nCount$284481[esp+984]
  0012c	83 c0 fb	 add	 eax, -5			; fffffffbH
  0012f	83 f8 1e	 cmp	 eax, 30			; 0000001eH
  00132	0f 87 88 02 00
	00		 ja	 $L284770
  00138	0f b6 88 00 00
	00 00		 movzx	 ecx, BYTE PTR $L361424[eax]
  0013f	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $L361430[ecx*4]
$L284746:

; 7591 : 				{
; 7592 : 					case 5:
; 7593 : 						vecItemInfo.push_back( ITEMINFO( II_CHR_FOO_COO_REMANTIS, 3, 0 ) );

  00146	8d 94 24 e4 00
	00 00		 lea	 edx, DWORD PTR $T360736[esp+984]
  0014d	c7 84 24 e4 00
	00 00 de 27 00
	00		 mov	 DWORD PTR $T360736[esp+984], 10206 ; 000027deH
  00158	c7 84 24 e8 00
	00 00 03 00 00
	00		 mov	 DWORD PTR $T360736[esp+988], 3
  00163	89 9c 24 ec 00
	00 00		 mov	 DWORD PTR $T360736[esp+992], ebx
  0016a	52		 push	 edx

; 7594 : 						break;

  0016b	e9 47 02 00 00	 jmp	 $L361428
$L284748:

; 7595 : 
; 7596 : 					case 10:
; 7597 : 						vecItemInfo.push_back( ITEMINFO( II_CHR_FOO_COO_REMANTIS, 3, 0 ) );

  00170	8d 44 24 48	 lea	 eax, DWORD PTR $T360737[esp+984]
  00174	50		 push	 eax
  00175	8d 4c 24 10	 lea	 ecx, DWORD PTR _vecItemInfo$284740[esp+988]
  00179	c7 44 24 4c de
	27 00 00	 mov	 DWORD PTR $T360737[esp+988], 10206 ; 000027deH
  00181	c7 44 24 50 03
	00 00 00	 mov	 DWORD PTR $T360737[esp+992], 3
  00189	89 5c 24 54	 mov	 DWORD PTR $T360737[esp+996], ebx
  0018d	e8 00 00 00 00	 call	 ?push_back@?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@QAEXABU__ITEMINFO@@@Z ; std::vector<__ITEMINFO,std::allocator<__ITEMINFO> >::push_back

; 7598 : 						vecItemInfo.push_back( ITEMINFO( II_SYS_SYS_SCR_BX_PET_LEYENA07, 1, 0 ) );

  00192	8d 8c 24 fc 00
	00 00		 lea	 ecx, DWORD PTR $T360738[esp+984]
  00199	c7 84 24 fc 00
	00 00 91 3f 00
	00		 mov	 DWORD PTR $T360738[esp+984], 16273 ; 00003f91H
  001a4	89 bc 24 00 01
	00 00		 mov	 DWORD PTR $T360738[esp+988], edi
  001ab	89 9c 24 04 01
	00 00		 mov	 DWORD PTR $T360738[esp+992], ebx
  001b2	51		 push	 ecx

; 7599 : 						break;

  001b3	e9 ff 01 00 00	 jmp	 $L361428
$L284751:

; 7600 : 
; 7601 : 					case 19:
; 7602 : 						vecItemInfo.push_back( ITEMINFO( II_CHR_FOO_COO_REMANTIS, 3, 0 ) );

  001b8	8d 54 24 60	 lea	 edx, DWORD PTR $T360739[esp+984]
  001bc	52		 push	 edx
  001bd	8d 4c 24 10	 lea	 ecx, DWORD PTR _vecItemInfo$284740[esp+988]
  001c1	c7 44 24 64 de
	27 00 00	 mov	 DWORD PTR $T360739[esp+988], 10206 ; 000027deH
  001c9	c7 44 24 68 03
	00 00 00	 mov	 DWORD PTR $T360739[esp+992], 3
  001d1	89 5c 24 6c	 mov	 DWORD PTR $T360739[esp+996], ebx
  001d5	e8 00 00 00 00	 call	 ?push_back@?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@QAEXABU__ITEMINFO@@@Z ; std::vector<__ITEMINFO,std::allocator<__ITEMINFO> >::push_back

; 7603 : 						vecItemInfo.push_back( ITEMINFO( II_SYS_TICKET_KEBARAS001, 1, 0 ) );

  001da	c7 84 24 c0 00
	00 00 be 67 00
	00		 mov	 DWORD PTR $T360740[esp+984], 26558 ; 000067beH
  001e5	89 bc 24 c4 00
	00 00		 mov	 DWORD PTR $T360740[esp+988], edi
  001ec	89 9c 24 c8 00
	00 00		 mov	 DWORD PTR $T360740[esp+992], ebx
  001f3	8d 84 24 c0 00
	00 00		 lea	 eax, DWORD PTR $T360740[esp+984]

; 7604 : 						break;

  001fa	e9 b7 01 00 00	 jmp	 $L361429
$L284754:

; 7605 : 
; 7606 : 					case 24:
; 7607 : 						vecItemInfo.push_back( ITEMINFO( II_CHR_FOO_COO_REMANTIS, 3, 0 ) );

  001ff	8d 4c 24 78	 lea	 ecx, DWORD PTR $T360741[esp+984]
  00203	51		 push	 ecx
  00204	8d 4c 24 10	 lea	 ecx, DWORD PTR _vecItemInfo$284740[esp+988]
  00208	c7 44 24 7c de
	27 00 00	 mov	 DWORD PTR $T360741[esp+988], 10206 ; 000027deH
  00210	c7 84 24 80 00
	00 00 03 00 00
	00		 mov	 DWORD PTR $T360741[esp+992], 3
  0021b	89 9c 24 84 00
	00 00		 mov	 DWORD PTR $T360741[esp+996], ebx
  00222	e8 00 00 00 00	 call	 ?push_back@?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@QAEXABU__ITEMINFO@@@Z ; std::vector<__ITEMINFO,std::allocator<__ITEMINFO> >::push_back

; 7608 : 						vecItemInfo.push_back( ITEMINFO( II_SYS_SYS_SCR_BX_PET_LEYENA07, 1, 0 ) );

  00227	8d 54 24 30	 lea	 edx, DWORD PTR $T360742[esp+984]
  0022b	52		 push	 edx
  0022c	8d 4c 24 10	 lea	 ecx, DWORD PTR _vecItemInfo$284740[esp+988]
  00230	c7 44 24 34 91
	3f 00 00	 mov	 DWORD PTR $T360742[esp+988], 16273 ; 00003f91H
  00238	89 7c 24 38	 mov	 DWORD PTR $T360742[esp+992], edi
  0023c	89 5c 24 3c	 mov	 DWORD PTR $T360742[esp+996], ebx
  00240	e8 00 00 00 00	 call	 ?push_back@?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@QAEXABU__ITEMINFO@@@Z ; std::vector<__ITEMINFO,std::allocator<__ITEMINFO> >::push_back

; 7609 : 						vecItemInfo.push_back( ITEMINFO( II_GEN_TOO_COL_SILVERBATTERY, 1, 0 ) );

  00245	c7 84 24 90 00
	00 00 56 67 00
	00		 mov	 DWORD PTR $T360743[esp+984], 26454 ; 00006756H
  00250	89 bc 24 94 00
	00 00		 mov	 DWORD PTR $T360743[esp+988], edi
  00257	89 9c 24 98 00
	00 00		 mov	 DWORD PTR $T360743[esp+992], ebx
  0025e	8d 84 24 90 00
	00 00		 lea	 eax, DWORD PTR $T360743[esp+984]

; 7610 : 						break;

  00265	e9 4c 01 00 00	 jmp	 $L361429
$L284758:

; 7611 : 
; 7612 : 					case 29:
; 7613 : 						vecItemInfo.push_back( ITEMINFO( II_CHR_FOO_COO_REMANTIS, 3, 0 ) );

  0026a	8d 8c 24 d8 00
	00 00		 lea	 ecx, DWORD PTR $T360744[esp+984]
  00271	51		 push	 ecx
  00272	8d 4c 24 10	 lea	 ecx, DWORD PTR _vecItemInfo$284740[esp+988]
  00276	c7 84 24 dc 00
	00 00 de 27 00
	00		 mov	 DWORD PTR $T360744[esp+988], 10206 ; 000027deH
  00281	c7 84 24 e0 00
	00 00 03 00 00
	00		 mov	 DWORD PTR $T360744[esp+992], 3
  0028c	89 9c 24 e4 00
	00 00		 mov	 DWORD PTR $T360744[esp+996], ebx
  00293	e8 00 00 00 00	 call	 ?push_back@?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@QAEXABU__ITEMINFO@@@Z ; std::vector<__ITEMINFO,std::allocator<__ITEMINFO> >::push_back

; 7614 : 						vecItemInfo.push_back( ITEMINFO( II_SYS_SYS_SCR_AWAKECANCEL, 1, 0 ) );

  00298	8d 94 24 a8 00
	00 00		 lea	 edx, DWORD PTR $T360745[esp+984]
  0029f	52		 push	 edx
  002a0	8d 4c 24 10	 lea	 ecx, DWORD PTR _vecItemInfo$284740[esp+988]
  002a4	c7 84 24 ac 00
	00 00 5e 67 00
	00		 mov	 DWORD PTR $T360745[esp+988], 26462 ; 0000675eH
  002af	89 bc 24 b0 00
	00 00		 mov	 DWORD PTR $T360745[esp+992], edi
  002b6	89 9c 24 b4 00
	00 00		 mov	 DWORD PTR $T360745[esp+996], ebx
  002bd	e8 00 00 00 00	 call	 ?push_back@?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@QAEXABU__ITEMINFO@@@Z ; std::vector<__ITEMINFO,std::allocator<__ITEMINFO> >::push_back

; 7615 : 						vecItemInfo.push_back( ITEMINFO( II_SYS_SYS_SCR_BAGBAG15, 1, 0 ) );

  002c2	c7 44 24 3c 48
	4e 00 00	 mov	 DWORD PTR $T360746[esp+984], 20040 ; 00004e48H
  002ca	89 7c 24 40	 mov	 DWORD PTR $T360746[esp+988], edi
  002ce	89 5c 24 44	 mov	 DWORD PTR $T360746[esp+992], ebx
  002d2	8d 44 24 3c	 lea	 eax, DWORD PTR $T360746[esp+984]

; 7616 : 						break;

  002d6	e9 db 00 00 00	 jmp	 $L361429
$L284762:

; 7617 : 
; 7618 : 					case 34:
; 7619 : 						vecItemInfo.push_back( ITEMINFO( II_CHR_FOO_COO_REMANTIS, 3, 0 ) );

  002db	8d 4c 24 54	 lea	 ecx, DWORD PTR $T360747[esp+984]
  002df	51		 push	 ecx
  002e0	8d 4c 24 10	 lea	 ecx, DWORD PTR _vecItemInfo$284740[esp+988]
  002e4	c7 44 24 58 de
	27 00 00	 mov	 DWORD PTR $T360747[esp+988], 10206 ; 000027deH
  002ec	c7 44 24 5c 03
	00 00 00	 mov	 DWORD PTR $T360747[esp+992], 3
  002f4	89 5c 24 60	 mov	 DWORD PTR $T360747[esp+996], ebx
  002f8	e8 00 00 00 00	 call	 ?push_back@?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@QAEXABU__ITEMINFO@@@Z ; std::vector<__ITEMINFO,std::allocator<__ITEMINFO> >::push_back

; 7620 : #ifdef __PROTECT_AWAKE
; 7621 : 						vecItemInfo.push_back( ITEMINFO( II_SYS_SYS_SCR_AWAKESAFE, 1, 0 ) );

  002fd	8d 54 24 6c	 lea	 edx, DWORD PTR $T360748[esp+984]
  00301	52		 push	 edx
  00302	8d 4c 24 10	 lea	 ecx, DWORD PTR _vecItemInfo$284740[esp+988]
  00306	c7 44 24 70 51
	69 00 00	 mov	 DWORD PTR $T360748[esp+988], 26961 ; 00006951H
  0030e	89 7c 24 74	 mov	 DWORD PTR $T360748[esp+992], edi
  00312	89 5c 24 78	 mov	 DWORD PTR $T360748[esp+996], ebx
  00316	e8 00 00 00 00	 call	 ?push_back@?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@QAEXABU__ITEMINFO@@@Z ; std::vector<__ITEMINFO,std::allocator<__ITEMINFO> >::push_back

; 7622 : #endif // __PROTECT_AWAKE
; 7623 : #if __VER >= 15 // __PETVIS
; 7624 : 						vecItemInfo.push_back( ITEMINFO( II_SYS_SYS_SCR_BXVISMAGIC01, 2, 0 ) );

  0031b	8d 84 24 84 00
	00 00		 lea	 eax, DWORD PTR $T360749[esp+984]
  00322	50		 push	 eax
  00323	8d 4c 24 10	 lea	 ecx, DWORD PTR _vecItemInfo$284740[esp+988]
  00327	c7 84 24 88 00
	00 00 00 4f 00
	00		 mov	 DWORD PTR $T360749[esp+988], 20224 ; 00004f00H
  00332	89 b4 24 8c 00
	00 00		 mov	 DWORD PTR $T360749[esp+992], esi
  00339	89 9c 24 90 00
	00 00		 mov	 DWORD PTR $T360749[esp+996], ebx
  00340	e8 00 00 00 00	 call	 ?push_back@?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@QAEXABU__ITEMINFO@@@Z ; std::vector<__ITEMINFO,std::allocator<__ITEMINFO> >::push_back

; 7625 : 						vecItemInfo.push_back( ITEMINFO( II_SYS_SYS_SCR_BXVISMELEE01, 2, 0 ) );

  00345	8d 8c 24 9c 00
	00 00		 lea	 ecx, DWORD PTR $T360750[esp+984]
  0034c	c7 84 24 9c 00
	00 00 ff 4e 00
	00		 mov	 DWORD PTR $T360750[esp+984], 20223 ; 00004effH
  00357	89 b4 24 a0 00
	00 00		 mov	 DWORD PTR $T360750[esp+988], esi
  0035e	89 9c 24 a4 00
	00 00		 mov	 DWORD PTR $T360750[esp+992], ebx
  00365	51		 push	 ecx

; 7626 : #endif // __PETVIS
; 7627 : 						break;

  00366	eb 4f		 jmp	 SHORT $L361428
$L284767:

; 7628 : 
; 7629 : 					case 35:
; 7630 : 						vecItemInfo.push_back( ITEMINFO( II_CHR_FOO_COO_REMANTIS, 5, 0 ) );

  00368	8d 94 24 b4 00
	00 00		 lea	 edx, DWORD PTR $T360751[esp+984]
  0036f	52		 push	 edx
  00370	8d 4c 24 10	 lea	 ecx, DWORD PTR _vecItemInfo$284740[esp+988]
  00374	c7 84 24 b8 00
	00 00 de 27 00
	00		 mov	 DWORD PTR $T360751[esp+988], 10206 ; 000027deH
  0037f	c7 84 24 bc 00
	00 00 05 00 00
	00		 mov	 DWORD PTR $T360751[esp+992], 5
  0038a	89 9c 24 c0 00
	00 00		 mov	 DWORD PTR $T360751[esp+996], ebx
  00391	e8 00 00 00 00	 call	 ?push_back@?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@QAEXABU__ITEMINFO@@@Z ; std::vector<__ITEMINFO,std::allocator<__ITEMINFO> >::push_back

; 7631 : #if __VER >= 15 // __PETVIS
; 7632 : 						vecItemInfo.push_back( ITEMINFO( II_SYS_SYS_SCR_PET_MAGIC, 1, 0 ) );

  00396	c7 84 24 cc 00
	00 00 1e 69 00
	00		 mov	 DWORD PTR $T360752[esp+984], 26910 ; 0000691eH
  003a1	89 bc 24 d0 00
	00 00		 mov	 DWORD PTR $T360752[esp+988], edi
  003a8	89 9c 24 d4 00
	00 00		 mov	 DWORD PTR $T360752[esp+992], ebx
  003af	8d 84 24 cc 00
	00 00		 lea	 eax, DWORD PTR $T360752[esp+984]
$L361429:
  003b6	50		 push	 eax
$L361428:
  003b7	8d 4c 24 10	 lea	 ecx, DWORD PTR _vecItemInfo$284740[esp+988]
  003bb	e8 00 00 00 00	 call	 ?push_back@?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@QAEXABU__ITEMINFO@@@Z ; std::vector<__ITEMINFO,std::allocator<__ITEMINFO> >::push_back
$L284770:

; 7633 : #endif // __PETVIS
; 7634 : 						break;
; 7635 : 
; 7636 : 					default:
; 7637 : 						break;
; 7638 : 				}
; 7639 : #endif // #ifdef __EVENT_1101_2
; 7640 : 				char lpText[512];
; 7641 : 				for( size_t size=0; size<vecItemInfo.size(); size++ )

  003c0	8b 7c 24 10	 mov	 edi, DWORD PTR _vecItemInfo$284740[esp+988]
  003c4	89 5c 24 1c	 mov	 DWORD PTR _size$284772[esp+984], ebx
  003c8	8b f7		 mov	 esi, edi
  003ca	8d 9b 00 00 00
	00		 npad	 6
$L284773:
  003d0	3b fb		 cmp	 edi, ebx
  003d2	0f 84 b7 01 00
	00		 je	 $L361423
  003d8	8b 4c 24 14	 mov	 ecx, DWORD PTR _vecItemInfo$284740[esp+992]
  003dc	2b cf		 sub	 ecx, edi
  003de	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  003e3	f7 e9		 imul	 ecx
  003e5	8b 4c 24 1c	 mov	 ecx, DWORD PTR _size$284772[esp+984]
  003e9	d1 fa		 sar	 edx, 1
  003eb	8b c2		 mov	 eax, edx
  003ed	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  003f0	03 c2		 add	 eax, edx
  003f2	3b c8		 cmp	 ecx, eax
  003f4	0f 83 95 01 00
	00		 jae	 $L361423

; 7642 : 				{
; 7643 : 					if( vecItemInfo[size].dwItemId > 0 )

  003fa	39 1e		 cmp	 DWORD PTR [esi], ebx
  003fc	0f 86 81 01 00
	00		 jbe	 $L284774

; 7644 : 					{
; 7645 : 						CItemElem itemElem;

  00402	8d 8c 24 08 01
	00 00		 lea	 ecx, DWORD PTR _itemElem$284777[esp+984]
  00409	e8 00 00 00 00	 call	 ??0CItemElem@@QAE@XZ	; CItemElem::CItemElem

; 7646 : 						itemElem.m_dwItemId	= vecItemInfo[size].dwItemId;

  0040e	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00410	89 8c 24 14 01
	00 00		 mov	 DWORD PTR _itemElem$284777[esp+996], ecx

; 7647 : 						itemElem.m_nItemNum	= vecItemInfo[size].nItemNum;

  00417	66 8b 56 04	 mov	 dx, WORD PTR [esi+4]
  0041b	66 89 94 24 88
	01 00 00	 mov	 WORD PTR _itemElem$284777[esp+1112], dx

; 7648 : 						itemElem.SetFlag( vecItemInfo[size].nBins );

  00423	8a 46 08	 mov	 al, BYTE PTR [esi+8]
  00426	8a 94 24 8a 01
	00 00		 mov	 dl, BYTE PTR _itemElem$284777[esp+1114]
  0042d	0a d0		 or	 dl, al

; 7649 : 						itemElem.SetSerialNumber();

  0042f	8d 8c 24 08 01
	00 00		 lea	 ecx, DWORD PTR _itemElem$284777[esp+984]
  00436	c6 84 24 d4 03
	00 00 01	 mov	 BYTE PTR __$EHRec$[esp+992], 1
  0043e	88 94 24 8a 01
	00 00		 mov	 BYTE PTR _itemElem$284777[esp+1114], dl
  00445	e8 00 00 00 00	 call	 ?SetSerialNumber@CItemBase@@QAEXXZ ; CItemBase::SetSerialNumber

; 7650 : 
; 7651 : 						memset( lpText, 0, sizeof( lpText ) );

  0044a	33 c0		 xor	 eax, eax
  0044c	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  00451	8d bc 24 c0 01
	00 00		 lea	 edi, DWORD PTR _lpText$284771[esp+984]
  00458	f3 ab		 rep stosd

; 7652 : 						sprintf( lpText, (char*)GETTEXT( TID_GAME_EVENT_MAIL_CALLTHEROLL ), nCount, itemElem.GetProp()->szName );

  0045a	8b 84 24 14 01
	00 00		 mov	 eax, DWORD PTR _itemElem$284777[esp+996]
  00461	3b c3		 cmp	 eax, ebx
  00463	8b 0d 5c 02 00
	00		 mov	 ecx, DWORD PTR ?prj@@3VCProject@@A+604
  00469	7c 19		 jl	 SHORT $L361287
  0046b	3b c1		 cmp	 eax, ecx
  0046d	7d 15		 jge	 SHORT $L361287
  0046f	72 06		 jb	 SHORT $L361299
  00471	33 c0		 xor	 eax, eax
  00473	8b f8		 mov	 edi, eax
  00475	eb 24		 jmp	 SHORT $L361282
$L361299:
  00477	8b 0d 4c 02 00
	00		 mov	 ecx, DWORD PTR ?prj@@3VCProject@@A+588
  0047d	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  00480	8b f8		 mov	 edi, eax
  00482	eb 17		 jmp	 SHORT $L361282
$L361287:
  00484	50		 push	 eax
  00485	51		 push	 ecx
  00486	53		 push	 ebx
  00487	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BI@BEIFNGEL@GetItemProp?5range_error?$AA@
  0048c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@HMFGHCP@?$CFs?5min?3?$CFd?0?5max?3?$CFd?0?5index?3?$CFd?$AA@
  00491	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  00496	83 c4 14	 add	 esp, 20			; 00000014H
  00499	33 ff		 xor	 edi, edi
$L361282:
  0049b	a1 c8 02 00 00	 mov	 eax, DWORD PTR ?prj@@3VCProject@@A+712
  004a0	3d 27 0c 00 00	 cmp	 eax, 3111		; 00000c27H
  004a5	7e 1e		 jle	 SHORT $L361331
  004a7	76 10		 jbe	 SHORT $L361421
  004a9	8b 15 b8 02 00
	00		 mov	 edx, DWORD PTR ?prj@@3VCProject@@A+696
  004af	8b 82 9c 30 00
	00		 mov	 eax, DWORD PTR [edx+12444]
  004b5	3b c3		 cmp	 eax, ebx
  004b7	75 07		 jne	 SHORT $L361332
$L361421:
  004b9	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  004be	eb 23		 jmp	 SHORT $L361326
$L361332:
  004c0	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  004c3	eb 1e		 jmp	 SHORT $L361326
$L361331:
  004c5	68 27 0c 00 00	 push	 3111			; 00000c27H
  004ca	50		 push	 eax
  004cb	53		 push	 ebx
  004cc	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BE@OHDBLHOM@GetText?5range_error?$AA@
  004d1	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@HMFGHCP@?$CFs?5min?3?$CFd?0?5max?3?$CFd?0?5index?3?$CFd?$AA@
  004d6	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  004db	83 c4 14	 add	 esp, 20			; 00000014H
  004de	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:??_C@_05KKCIMGE@error?$AA@
$L361326:
  004e3	8b 4c 24 24	 mov	 ecx, DWORD PTR _nCount$284481[esp+984]
  004e7	83 c7 04	 add	 edi, 4
  004ea	57		 push	 edi
  004eb	51		 push	 ecx
  004ec	50		 push	 eax
  004ed	8d 94 24 cc 01
	00 00		 lea	 edx, DWORD PTR _lpText$284771[esp+996]
  004f4	52		 push	 edx
  004f5	e8 00 00 00 00	 call	 _sprintf

; 7653 : 						g_dpDBClient.SendQueryPostMail( pUser->m_idPlayer, 0, itemElem, 0, (char*)GETTEXT( TID_GAME_EVENT_MAIL_CALLTHEROLL_TITLE ), lpText );

  004fa	a1 c8 02 00 00	 mov	 eax, DWORD PTR ?prj@@3VCProject@@A+712
  004ff	83 c4 10	 add	 esp, 16			; 00000010H
  00502	3d 2d 0c 00 00	 cmp	 eax, 3117		; 00000c2dH
  00507	7e 1d		 jle	 SHORT $L361379
  00509	76 0f		 jbe	 SHORT $L361422
  0050b	a1 b8 02 00 00	 mov	 eax, DWORD PTR ?prj@@3VCProject@@A+696
  00510	8b 80 b4 30 00
	00		 mov	 eax, DWORD PTR [eax+12468]
  00516	3b c3		 cmp	 eax, ebx
  00518	75 07		 jne	 SHORT $L361380
$L361422:
  0051a	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  0051f	eb 23		 jmp	 SHORT $L361374
$L361380:
  00521	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00524	eb 1e		 jmp	 SHORT $L361374
$L361379:
  00526	68 2d 0c 00 00	 push	 3117			; 00000c2dH
  0052b	50		 push	 eax
  0052c	53		 push	 ebx
  0052d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BE@OHDBLHOM@GetText?5range_error?$AA@
  00532	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@HMFGHCP@?$CFs?5min?3?$CFd?0?5max?3?$CFd?0?5index?3?$CFd?$AA@
  00537	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  0053c	83 c4 14	 add	 esp, 20			; 00000014H
  0053f	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:??_C@_05KKCIMGE@error?$AA@
$L361374:
  00544	8d 8c 24 c0 01
	00 00		 lea	 ecx, DWORD PTR _lpText$284771[esp+984]
  0054b	51		 push	 ecx
  0054c	50		 push	 eax
  0054d	8b 44 24 34	 mov	 eax, DWORD PTR _pUser$284473[esp+992]
  00551	8b 88 38 02 00
	00		 mov	 ecx, DWORD PTR [eax+568]
  00557	53		 push	 ebx
  00558	8d 94 24 14 01
	00 00		 lea	 edx, DWORD PTR _itemElem$284777[esp+996]
  0055f	52		 push	 edx
  00560	53		 push	 ebx
  00561	51		 push	 ecx
  00562	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_dpDBClient@@3VCDPDatabaseClient@@A
  00567	e8 00 00 00 00	 call	 ?SendQueryPostMail@CDPDatabaseClient@@QAEXKKAAVCItemElem@@HPAD1@Z ; CDPDatabaseClient::SendQueryPostMail

; 7654 : 					}

  0056c	8d 8c 24 08 01
	00 00		 lea	 ecx, DWORD PTR _itemElem$284777[esp+984]
  00573	88 9c 24 d4 03
	00 00		 mov	 BYTE PTR __$EHRec$[esp+992], bl
  0057a	e8 00 00 00 00	 call	 ??1CItemElem@@UAE@XZ	; CItemElem::~CItemElem
  0057f	8b 7c 24 10	 mov	 edi, DWORD PTR _vecItemInfo$284740[esp+988]
$L284774:
  00583	ff 44 24 1c	 inc	 DWORD PTR _size$284772[esp+984]
  00587	83 c6 0c	 add	 esi, 12			; 0000000cH
  0058a	e9 41 fe ff ff	 jmp	 $L284773
$L361423:

; 7655 : 				}
; 7656 : 			}

  0058f	3b fb		 cmp	 edi, ebx
  00591	c7 84 24 d4 03
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+992], -1
  0059c	74 09		 je	 SHORT $L361414
  0059e	57		 push	 edi
  0059f	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  005a4	83 c4 04	 add	 esp, 4
$L361414:
  005a7	89 5c 24 10	 mov	 DWORD PTR _vecItemInfo$284740[esp+988], ebx
  005ab	89 5c 24 14	 mov	 DWORD PTR _vecItemInfo$284740[esp+992], ebx
  005af	89 5c 24 18	 mov	 DWORD PTR _vecItemInfo$284740[esp+996], ebx
$L284471:
  005b3	8d 4c 24 20	 lea	 ecx, DWORD PTR _i$[esp+984]
  005b7	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned long,CUser *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CUser *> >,0> >::const_iterator::_Inc
  005bc	8b 54 24 28	 mov	 edx, DWORD PTR $T361416[esp+984]
  005c0	8b 4c 24 20	 mov	 ecx, DWORD PTR _i$[esp+984]
  005c4	3b 4a 0c	 cmp	 ecx, DWORD PTR [edx+12]
  005c7	0f 85 83 fa ff
	ff		 jne	 $L360799
$L284472:

; 7657 : 		}
; 7658 : 	}
; 7659 : }

  005cd	8b 8c 24 cc 03
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+984]
  005d4	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  005db	8b 8c 24 c4 03
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+984]
  005e2	5f		 pop	 edi
  005e3	5e		 pop	 esi
  005e4	33 cd		 xor	 ecx, ebp
  005e6	5b		 pop	 ebx
  005e7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  005ec	8b e5		 mov	 esp, ebp
  005ee	5d		 pop	 ebp
  005ef	c2 04 00	 ret	 4
  005f2	8b ff		 npad	 2
$L361430:
  005f4	00 00 00 00	 DD	 $L284746
  005f8	00 00 00 00	 DD	 $L284748
  005fc	00 00 00 00	 DD	 $L284751
  00600	00 00 00 00	 DD	 $L284754
  00604	00 00 00 00	 DD	 $L284758
  00608	00 00 00 00	 DD	 $L284762
  0060c	00 00 00 00	 DD	 $L284767
  00610	00 00 00 00	 DD	 $L284770
$L361424:
  00614	00		 DB	 0
  00615	07		 DB	 7
  00616	07		 DB	 7
  00617	07		 DB	 7
  00618	07		 DB	 7
  00619	01		 DB	 1
  0061a	07		 DB	 7
  0061b	07		 DB	 7
  0061c	07		 DB	 7
  0061d	07		 DB	 7
  0061e	07		 DB	 7
  0061f	07		 DB	 7
  00620	07		 DB	 7
  00621	07		 DB	 7
  00622	02		 DB	 2
  00623	07		 DB	 7
  00624	07		 DB	 7
  00625	07		 DB	 7
  00626	07		 DB	 7
  00627	03		 DB	 3
  00628	07		 DB	 7
  00629	07		 DB	 7
  0062a	07		 DB	 7
  0062b	07		 DB	 7
  0062c	04		 DB	 4
  0062d	07		 DB	 7
  0062e	07		 DB	 7
  0062f	07		 DB	 7
  00630	07		 DB	 7
  00631	05		 DB	 5
  00632	06		 DB	 6
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L360753:
  00000	8d 8d 34 fc ff
	ff		 lea	 ecx, DWORD PTR _vecItemInfo$284740[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1?$vector@U__ITEMINFO@@V?$allocator@U__ITEMINFO@@@std@@@std@@QAE@XZ ; std::vector<__ITEMINFO,std::allocator<__ITEMINFO> >::~vector<__ITEMINFO,std::allocator<__ITEMINFO> >
$L360754:
  0000b	8d 8d 30 fd ff
	ff		 lea	 ecx, DWORD PTR _itemElem$284777[ebp]
  00011	e9 00 00 00 00	 jmp	 ??1CItemElem@@UAE@XZ	; CItemElem::~CItemElem
__ehhandler$?CallTheRoll@CUserMng@@QAEXH@Z:
  00016	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T361418
  0001b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?CallTheRoll@CUserMng@@QAEXH@Z ENDP			; CUserMng::CallTheRoll
PUBLIC	?AddSecretRoomContInfo@CUser@@QAEXEEAAV?$vector@U__SECRETROOM_TENDER@@V?$allocator@U__SECRETROOM_TENDER@@@std@@@std@@H@Z ; CUser::AddSecretRoomContInfo
;	COMDAT xdata$x
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_network\misc\include\ar.h
xdata$x	SEGMENT
$T362392 DD	0ffffffffH
	DD	FLAT:$L361438
$T362381 DD	019930520H
	DD	01H
	DD	FLAT:$T362392
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
xdata$x	ENDS
;	COMDAT ?AddSecretRoomContInfo@CUser@@QAEXEEAAV?$vector@U__SECRETROOM_TENDER@@V?$allocator@U__SECRETROOM_TENDER@@@std@@@std@@H@Z
_TEXT	SEGMENT
_this$ = -28						; size = 4
_mapMonsterNum$285178 = -24				; size = 12
__$EHRec$ = -12						; size = 12
$T362207 = 8						; size = 4
_it$285184 = 8						; size = 4
_nSize$285168 = 8					; size = 4
_nContinent$ = 8					; size = 1
_i$285162 = 12						; size = 4
_nType$ = 12						; size = 1
$T361916 = 16						; size = 4
_vecSecreetRoomTender$ = 16				; size = 4
_nIndex$ = 20						; size = 4
?AddSecretRoomContInfo@CUser@@QAEXEEAAV?$vector@U__SECRETROOM_TENDER@@V?$allocator@U__SECRETROOM_TENDER@@@std@@@std@@H@Z PROC NEAR ; CUser::AddSecretRoomContInfo, COMDAT
; _this$ = ecx

; 8080 : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?AddSecretRoomContInfo@CUser@@QAEXEEAAV?$vector@U__SECRETROOM_TENDER@@V?$allocator@U__SECRETROOM_TENDER@@@std@@@std@@H@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	83 ec 10	 sub	 esp, 16			; 00000010H
  00018	56		 push	 esi
  00019	8b f1		 mov	 esi, ecx

; 8081 : 	if( IsDelete() )	return;

  0001b	f6 46 04 01	 test	 BYTE PTR [esi+4], 1
  0001f	89 74 24 04	 mov	 DWORD PTR _this$[esp+32], esi
  00023	0f 85 31 03 00
	00		 jne	 $L285158

; 8082 : 	m_Snapshot.cb++;

  00029	66 ff 86 0c 57
	00 00		 inc	 WORD PTR [esi+22284]
  00030	53		 push	 ebx
  00031	55		 push	 ebp
  00032	57		 push	 edi

; 8083 : 	m_Snapshot.ar << GetId();

  00033	8b be bc 01 00
	00		 mov	 edi, DWORD PTR [esi+444]
  00039	81 c6 f8 16 00
	00		 add	 esi, 5880		; 000016f8H
  0003f	bb 04 00 00 00	 mov	 ebx, 4
  00044	53		 push	 ebx
  00045	8b ce		 mov	 ecx, esi
  00047	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0004c	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0004f	89 38		 mov	 DWORD PTR [eax], edi
  00051	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  00054	03 fb		 add	 edi, ebx

; 8084 : 	m_Snapshot.ar << SNAPSHOTTYPE_SECRETROOM_INFO;

  00056	6a 02		 push	 2
  00058	8b ce		 mov	 ecx, esi
  0005a	89 7e 08	 mov	 DWORD PTR [esi+8], edi
  0005d	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00062	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00065	66 c7 01 01 03	 mov	 WORD PTR [ecx], 769	; 00000301H
  0006a	83 46 08 02	 add	 DWORD PTR [esi+8], 2

; 8085 : 	m_Snapshot.ar << nContinent;

  0006e	6a 01		 push	 1
  00070	8b ce		 mov	 ecx, esi
  00072	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00077	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0007a	8a 44 24 30	 mov	 al, BYTE PTR _nContinent$[esp+40]
  0007e	88 02		 mov	 BYTE PTR [edx], al
  00080	8b 6e 08	 mov	 ebp, DWORD PTR [esi+8]
  00083	45		 inc	 ebp

; 8086 : 	m_Snapshot.ar << nType;

  00084	6a 01		 push	 1
  00086	8b ce		 mov	 ecx, esi
  00088	89 6e 08	 mov	 DWORD PTR [esi+8], ebp
  0008b	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00090	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00093	8a 44 24 34	 mov	 al, BYTE PTR _nType$[esp+40]
  00097	88 01		 mov	 BYTE PTR [ecx], al
  00099	8b 56 08	 mov	 edx, DWORD PTR [esi+8]

; 8087 : 
; 8088 : 	switch( nType )

  0009c	0f b6 c0	 movzx	 eax, al
  0009f	42		 inc	 edx
  000a0	48		 dec	 eax
  000a1	89 56 08	 mov	 DWORD PTR [esi+8], edx
  000a4	0f 84 a3 00 00
	00		 je	 $L285161
  000aa	48		 dec	 eax
  000ab	74 55		 je	 SHORT $L285191
  000ad	48		 dec	 eax
  000ae	0f 85 a3 02 00
	00		 jne	 $L362389

; 8127 : 			}
; 8128 : 			break;
; 8129 : 
; 8130 : 		case SECRETROOM_WARSTATE :
; 8131 : 			{
; 8132 : 				m_Snapshot.ar << nIndex;

  000b4	53		 push	 ebx
  000b5	8b ce		 mov	 ecx, esi
  000b7	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000bc	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  000bf	8b 44 24 3c	 mov	 eax, DWORD PTR _nIndex$[esp+40]

; 8133 : 				m_Snapshot.ar << vecSecreetRoomTender[nIndex].nWarState;

  000c3	8b 4c 24 38	 mov	 ecx, DWORD PTR _vecSecreetRoomTender$[esp+40]
  000c7	89 02		 mov	 DWORD PTR [edx], eax
  000c9	6b c0 34	 imul	 eax, 52			; 00000034H
  000cc	01 5e 08	 add	 DWORD PTR [esi+8], ebx
  000cf	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000d2	8b 7c 10 10	 mov	 edi, DWORD PTR [eax+edx+16]
  000d6	03 c2		 add	 eax, edx
  000d8	53		 push	 ebx
  000d9	8b ce		 mov	 ecx, esi
  000db	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000e0	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  000e3	89 3a		 mov	 DWORD PTR [edx], edi
  000e5	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000e8	5f		 pop	 edi
  000e9	5d		 pop	 ebp
  000ea	03 c3		 add	 eax, ebx
  000ec	5b		 pop	 ebx
  000ed	89 46 08	 mov	 DWORD PTR [esi+8], eax
  000f0	5e		 pop	 esi

; 8134 : 			}
; 8135 : 			break;
; 8136 : 	}
; 8137 : }

  000f1	8b 4c 24 10	 mov	 ecx, DWORD PTR __$EHRec$[esp+28]
  000f5	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  000fc	83 c4 1c	 add	 esp, 28			; 0000001cH
  000ff	c2 10 00	 ret	 16			; 00000010H
$L285191:

; 8121 : 			break;
; 8122 : 
; 8123 : 		case SECRETROOM_KILLCOUNT :
; 8124 : 			{
; 8125 : 				m_Snapshot.ar << nIndex;

  00102	53		 push	 ebx
  00103	8b ce		 mov	 ecx, esi
  00105	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0010a	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0010d	8b 44 24 3c	 mov	 eax, DWORD PTR _nIndex$[esp+40]

; 8126 : 				m_Snapshot.ar << vecSecreetRoomTender[nIndex].nKillCount;

  00111	8b 54 24 38	 mov	 edx, DWORD PTR _vecSecreetRoomTender$[esp+40]
  00115	89 01		 mov	 DWORD PTR [ecx], eax
  00117	6b c0 34	 imul	 eax, 52			; 00000034H
  0011a	01 5e 08	 add	 DWORD PTR [esi+8], ebx
  0011d	03 42 04	 add	 eax, DWORD PTR [edx+4]
  00120	8b 78 08	 mov	 edi, DWORD PTR [eax+8]
  00123	53		 push	 ebx
  00124	8b ce		 mov	 ecx, esi
  00126	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0012b	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0012e	89 38		 mov	 DWORD PTR [eax], edi
  00130	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00133	5f		 pop	 edi
  00134	5d		 pop	 ebp
  00135	03 c3		 add	 eax, ebx
  00137	5b		 pop	 ebx
  00138	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0013b	5e		 pop	 esi

; 8134 : 			}
; 8135 : 			break;
; 8136 : 	}
; 8137 : }

  0013c	8b 4c 24 10	 mov	 ecx, DWORD PTR __$EHRec$[esp+28]
  00140	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00147	83 c4 1c	 add	 esp, 28			; 0000001cH
  0014a	c2 10 00	 ret	 16			; 00000010H
$L285161:

; 8089 : 	{
; 8090 : 		case SECRETROOM_GUILDLIST :
; 8091 : 			{
; 8092 : 				m_Snapshot.ar << vecSecreetRoomTender.size();

  0014d	8b 6c 24 38	 mov	 ebp, DWORD PTR _vecSecreetRoomTender$[esp+40]
  00151	8b 45 04	 mov	 eax, DWORD PTR [ebp+4]
  00154	85 c0		 test	 eax, eax
  00156	75 04		 jne	 SHORT $L361467
  00158	33 ff		 xor	 edi, edi
  0015a	eb 16		 jmp	 SHORT $L361468
$L361467:
  0015c	8b 4d 08	 mov	 ecx, DWORD PTR [ebp+8]
  0015f	2b c8		 sub	 ecx, eax
  00161	b8 4f ec c4 4e	 mov	 eax, 1321528399		; 4ec4ec4fH
  00166	f7 e9		 imul	 ecx
  00168	c1 fa 04	 sar	 edx, 4
  0016b	8b fa		 mov	 edi, edx
  0016d	c1 ef 1f	 shr	 edi, 31			; 0000001fH
  00170	03 fa		 add	 edi, edx
$L361468:
  00172	53		 push	 ebx
  00173	8b ce		 mov	 ecx, esi
  00175	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0017a	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0017d	89 39		 mov	 DWORD PTR [ecx], edi
  0017f	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00182	03 c3		 add	 eax, ebx

; 8093 : 	
; 8094 : 				for( int i=0; i<(int)( vecSecreetRoomTender.size() ); i++ )

  00184	33 db		 xor	 ebx, ebx
  00186	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00189	89 5c 24 34	 mov	 DWORD PTR _i$285162[esp+40], ebx
  0018d	8d 49 00	 npad	 3
$L285164:
  00190	8b 7d 04	 mov	 edi, DWORD PTR [ebp+4]
  00193	85 ff		 test	 edi, edi
  00195	75 04		 jne	 SHORT $L361483
  00197	33 c0		 xor	 eax, eax
  00199	eb 16		 jmp	 SHORT $L361484
$L361483:
  0019b	8b 4d 08	 mov	 ecx, DWORD PTR [ebp+8]
  0019e	2b cf		 sub	 ecx, edi
  001a0	b8 4f ec c4 4e	 mov	 eax, 1321528399		; 4ec4ec4fH
  001a5	f7 e9		 imul	 ecx
  001a7	c1 fa 04	 sar	 edx, 4
  001aa	8b c2		 mov	 eax, edx
  001ac	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  001af	03 c2		 add	 eax, edx
$L361484:
  001b1	39 44 24 34	 cmp	 DWORD PTR _i$285162[esp+40], eax
  001b5	0f 8d e7 00 00
	00		 jge	 $L285166

; 8095 : 				{
; 8096 : 					m_Snapshot.ar << vecSecreetRoomTender[i].dwGuildId;

  001bb	8b 3c 3b	 mov	 edi, DWORD PTR [ebx+edi]
  001be	6a 04		 push	 4
  001c0	8b ce		 mov	 ecx, esi
  001c2	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  001c7	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  001ca	89 3a		 mov	 DWORD PTR [edx], edi
  001cc	83 46 08 04	 add	 DWORD PTR [esi+8], 4

; 8097 : 					m_Snapshot.ar << vecSecreetRoomTender[i].nWarState;

  001d0	8b 45 04	 mov	 eax, DWORD PTR [ebp+4]
  001d3	8b 7c 18 10	 mov	 edi, DWORD PTR [eax+ebx+16]
  001d7	03 c3		 add	 eax, ebx
  001d9	6a 04		 push	 4
  001db	8b ce		 mov	 ecx, esi
  001dd	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  001e2	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  001e5	89 38		 mov	 DWORD PTR [eax], edi
  001e7	83 46 08 04	 add	 DWORD PTR [esi+8], 4

; 8098 : 					m_Snapshot.ar << vecSecreetRoomTender[i].nKillCount;

  001eb	8b 45 04	 mov	 eax, DWORD PTR [ebp+4]
  001ee	8b 7c 18 08	 mov	 edi, DWORD PTR [eax+ebx+8]
  001f2	03 c3		 add	 eax, ebx
  001f4	6a 04		 push	 4
  001f6	8b ce		 mov	 ecx, esi
  001f8	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  001fd	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00200	89 39		 mov	 DWORD PTR [ecx], edi
  00202	8b 56 08	 mov	 edx, DWORD PTR [esi+8]

; 8099 : 
; 8100 : 					if( m_idGuild == vecSecreetRoomTender[i].dwGuildId )

  00205	8b 4c 24 10	 mov	 ecx, DWORD PTR _this$[esp+44]
  00209	bf 04 00 00 00	 mov	 edi, 4
  0020e	03 d7		 add	 edx, edi
  00210	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00213	8b 55 04	 mov	 edx, DWORD PTR [ebp+4]
  00216	8d 04 13	 lea	 eax, DWORD PTR [ebx+edx]
  00219	8b 91 1c 07 00
	00		 mov	 edx, DWORD PTR [ecx+1820]
  0021f	3b 10		 cmp	 edx, DWORD PTR [eax]
  00221	75 73		 jne	 SHORT $L285165

; 8101 : 					{
; 8102 : 						int nSize = vecSecreetRoomTender[i].vecLineUpMember.size();

  00223	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00226	85 c9		 test	 ecx, ecx
  00228	75 06		 jne	 SHORT $L361791
  0022a	89 4c 24 30	 mov	 DWORD PTR _nSize$285168[esp+40], ecx
  0022e	eb 0c		 jmp	 SHORT $L361792
$L361791:
  00230	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]
  00233	2b c1		 sub	 eax, ecx
  00235	c1 f8 02	 sar	 eax, 2
  00238	89 44 24 30	 mov	 DWORD PTR _nSize$285168[esp+40], eax
$L361792:

; 8103 : 						m_Snapshot.ar << nSize;

  0023c	57		 push	 edi
  0023d	8b ce		 mov	 ecx, esi
  0023f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00244	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00247	8b 4c 24 30	 mov	 ecx, DWORD PTR _nSize$285168[esp+40]
  0024b	89 08		 mov	 DWORD PTR [eax], ecx
  0024d	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]

; 8104 : 
; 8105 : 						for(int j=0; j<nSize; j++)

  00250	8b 44 24 30	 mov	 eax, DWORD PTR _nSize$285168[esp+40]
  00254	03 cf		 add	 ecx, edi
  00256	33 ff		 xor	 edi, edi
  00258	85 c0		 test	 eax, eax
  0025a	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  0025d	7e 37		 jle	 SHORT $L285165
  0025f	90		 npad	 1
$L285170:

; 8106 : 						{
; 8107 : 							m_Snapshot.ar << vecSecreetRoomTender[i].vecLineUpMember[j];

  00260	8b 45 04	 mov	 eax, DWORD PTR [ebp+4]
  00263	8b 54 18 18	 mov	 edx, DWORD PTR [eax+ebx+24]
  00267	03 c3		 add	 eax, ebx
  00269	8d 04 ba	 lea	 eax, DWORD PTR [edx+edi*4]
  0026c	8b 00		 mov	 eax, DWORD PTR [eax]
  0026e	6a 04		 push	 4
  00270	8b ce		 mov	 ecx, esi
  00272	89 44 24 3c	 mov	 DWORD PTR $T361916[esp+44], eax
  00276	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0027b	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0027e	8b 54 24 38	 mov	 edx, DWORD PTR $T361916[esp+40]
  00282	8b 44 24 30	 mov	 eax, DWORD PTR _nSize$285168[esp+40]
  00286	89 11		 mov	 DWORD PTR [ecx], edx
  00288	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0028b	83 c2 04	 add	 edx, 4
  0028e	47		 inc	 edi
  0028f	3b f8		 cmp	 edi, eax
  00291	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00294	7c ca		 jl	 SHORT $L285170
$L285165:

; 8093 : 	
; 8094 : 				for( int i=0; i<(int)( vecSecreetRoomTender.size() ); i++ )

  00296	ff 44 24 34	 inc	 DWORD PTR _i$285162[esp+40]
  0029a	83 c3 34	 add	 ebx, 52			; 00000034H
  0029d	e9 ee fe ff ff	 jmp	 $L285164
$L285166:

; 8108 : 						}
; 8109 : 					}
; 8110 : 				}
; 8111 : 				
; 8112 : 				map<int, int> mapMonsterNum = CSecretRoomMng::GetInstance()->m_mapMonsterNum;

  002a2	e8 00 00 00 00	 call	 ?GetInstance@CSecretRoomMng@@SAPAV1@XZ ; CSecretRoomMng::GetInstance
  002a7	83 c0 40	 add	 eax, 64			; 00000040H
  002aa	50		 push	 eax
  002ab	8d 4c 24 18	 lea	 ecx, DWORD PTR _mapMonsterNum$285178[esp+48]
  002af	e8 00 00 00 00	 call	 ??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >

; 8113 : 				map<int, int>::iterator it = mapMonsterNum.begin();

  002b4	8b 44 24 18	 mov	 eax, DWORD PTR _mapMonsterNum$285178[esp+48]
  002b8	8b 18		 mov	 ebx, DWORD PTR [eax]

; 8114 : 				m_Snapshot.ar << mapMonsterNum.size();

  002ba	8b 7c 24 1c	 mov	 edi, DWORD PTR _mapMonsterNum$285178[esp+52]
  002be	bd 04 00 00 00	 mov	 ebp, 4
  002c3	55		 push	 ebp
  002c4	8b ce		 mov	 ecx, esi
  002c6	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+56], 0
  002ce	89 5c 24 34	 mov	 DWORD PTR _it$285184[esp+44], ebx
  002d2	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  002d7	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  002da	89 39		 mov	 DWORD PTR [ecx], edi
  002dc	8b 56 08	 mov	 edx, DWORD PTR [esi+8]

; 8115 : 				for( ; it!=mapMonsterNum.end(); it++ )

  002df	8b 44 24 18	 mov	 eax, DWORD PTR _mapMonsterNum$285178[esp+48]
  002e3	03 d5		 add	 edx, ebp
  002e5	3b d8		 cmp	 ebx, eax
  002e7	89 56 08	 mov	 DWORD PTR [esi+8], edx
  002ea	74 44		 je	 SHORT $L285190
  002ec	8d 64 24 00	 npad	 4
$L361974:

; 8116 : 				{
; 8117 : 					m_Snapshot.ar << it->first;

  002f0	8b 7b 0c	 mov	 edi, DWORD PTR [ebx+12]
  002f3	55		 push	 ebp
  002f4	8b ce		 mov	 ecx, esi
  002f6	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  002fb	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  002fe	89 3a		 mov	 DWORD PTR [edx], edi
  00300	01 6e 08	 add	 DWORD PTR [esi+8], ebp

; 8118 : 					m_Snapshot.ar << it->second;

  00303	8b 5b 10	 mov	 ebx, DWORD PTR [ebx+16]
  00306	55		 push	 ebp
  00307	8b ce		 mov	 ecx, esi
  00309	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0030e	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00311	89 18		 mov	 DWORD PTR [eax], ebx
  00313	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00316	03 d5		 add	 edx, ebp
  00318	8d 4c 24 30	 lea	 ecx, DWORD PTR _it$285184[esp+40]
  0031c	89 56 08	 mov	 DWORD PTR [esi+8], edx
  0031f	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::const_iterator::_Inc
  00324	8b 5c 24 30	 mov	 ebx, DWORD PTR _it$285184[esp+40]
  00328	8b 44 24 18	 mov	 eax, DWORD PTR _mapMonsterNum$285178[esp+48]
  0032c	3b d8		 cmp	 ebx, eax
  0032e	75 c0		 jne	 SHORT $L361974
$L285190:

; 8119 : 				}
; 8120 : 			}

  00330	8b 08		 mov	 ecx, DWORD PTR [eax]
  00332	50		 push	 eax
  00333	51		 push	 ecx
  00334	8d 4c 24 38	 lea	 ecx, DWORD PTR $T362207[esp+48]
  00338	51		 push	 ecx
  00339	8d 4c 24 20	 lea	 ecx, DWORD PTR _mapMonsterNum$285178[esp+56]
  0033d	c7 44 24 34 ff
	ff ff ff	 mov	 DWORD PTR __$EHRec$[esp+64], -1
  00345	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@V312@0@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::erase
  0034a	8b 54 24 18	 mov	 edx, DWORD PTR _mapMonsterNum$285178[esp+48]
  0034e	52		 push	 edx
  0034f	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00354	83 c4 04	 add	 esp, 4
$L362389:
  00357	5f		 pop	 edi
  00358	5d		 pop	 ebp
  00359	5b		 pop	 ebx
$L285158:

; 8134 : 			}
; 8135 : 			break;
; 8136 : 	}
; 8137 : }

  0035a	8b 4c 24 14	 mov	 ecx, DWORD PTR __$EHRec$[esp+32]
  0035e	5e		 pop	 esi
  0035f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00366	83 c4 1c	 add	 esp, 28			; 0000001cH
  00369	c2 10 00	 ret	 16			; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L361438:
  00000	8d 4d e8	 lea	 ecx, DWORD PTR _mapMonsterNum$285178[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@XZ
__ehhandler$?AddSecretRoomContInfo@CUser@@QAEXEEAAV?$vector@U__SECRETROOM_TENDER@@V?$allocator@U__SECRETROOM_TENDER@@@std@@@std@@H@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T362381
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?AddSecretRoomContInfo@CUser@@QAEXEEAAV?$vector@U__SECRETROOM_TENDER@@V?$allocator@U__SECRETROOM_TENDER@@@std@@@std@@H@Z ENDP ; CUser::AddSecretRoomContInfo
PUBLIC	??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
__Cat$362438 = -4					; size = 1
??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ PROC NEAR ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT
; _this$ = ecx

; 387  : 		{	// destroy the object

  00000	51		 push	 ecx
  00001	56		 push	 esi
  00002	8b f1		 mov	 esi, ecx

; 388  : 		_Tidy();

  00004	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00007	85 c0		 test	 eax, eax
  00009	74 1c		 je	 SHORT $L362440
  0000b	8b 4c 24 04	 mov	 ecx, DWORD PTR __Cat$362438[esp+8]
  0000f	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00012	51		 push	 ecx
  00013	56		 push	 esi
  00014	52		 push	 edx
  00015	50		 push	 eax
  00016	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
  0001b	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00024	83 c4 14	 add	 esp, 20			; 00000014H
$L362440:
  00027	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  0002e	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00035	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
  0003c	5e		 pop	 esi

; 389  : 		}

  0003d	59		 pop	 ecx
  0003e	c3		 ret	 0
??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
PUBLIC	?clear@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::clear
; Function compile flags: /Ogty
;	COMDAT ?clear@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXXZ
_TEXT	SEGMENT
__Cat$362485 = -4					; size = 1
?clear@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXXZ PROC NEAR ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::clear, COMDAT
; _this$ = ecx

; 743  : 		{	// erase all

  00000	51		 push	 ecx
  00001	56		 push	 esi
  00002	8b f1		 mov	 esi, ecx

; 744  : 		_Tidy();

  00004	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00007	85 c0		 test	 eax, eax
  00009	74 1c		 je	 SHORT $L362487
  0000b	8b 4c 24 04	 mov	 ecx, DWORD PTR __Cat$362485[esp+8]
  0000f	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00012	51		 push	 ecx
  00013	56		 push	 esi
  00014	52		 push	 edx
  00015	50		 push	 eax
  00016	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
  0001b	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00024	83 c4 14	 add	 esp, 20			; 00000014H
$L362487:
  00027	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  0002e	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00035	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
  0003c	5e		 pop	 esi

; 745  : 		}

  0003d	59		 pop	 ecx
  0003e	c3		 ret	 0
?clear@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXXZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::clear
_TEXT	ENDS
PUBLIC	?insert@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AViterator@12@V312@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::insert
; Function compile flags: /Ogty
;	COMDAT ?insert@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AViterator@12@V312@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
tv90 = 12						; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AViterator@12@V312@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z PROC NEAR ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::insert, COMDAT
; _this$ = ecx

; 620  : 		{	// insert _Val at _Where

  00000	53		 push	 ebx

; 621  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

  00001	8b 5c 24 0c	 mov	 ebx, DWORD PTR __Where$[esp]
  00005	56		 push	 esi
  00006	57		 push	 edi
  00007	8b f9		 mov	 edi, ecx
  00009	8b 77 04	 mov	 esi, DWORD PTR [edi+4]
  0000c	85 f6		 test	 esi, esi
  0000e	74 1e		 je	 SHORT $L362554
  00010	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  00013	2b ce		 sub	 ecx, esi
  00015	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  0001a	f7 e9		 imul	 ecx
  0001c	03 d1		 add	 edx, ecx
  0001e	c1 fa 04	 sar	 edx, 4
  00021	8b c2		 mov	 eax, edx
  00023	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00026	03 c2		 add	 eax, edx
  00028	89 44 24 14	 mov	 DWORD PTR tv90[esp+8], eax
  0002c	75 04		 jne	 SHORT $L362493
$L362554:
  0002e	33 f6		 xor	 esi, esi
  00030	eb 17		 jmp	 SHORT $L362494
$L362493:
  00032	8b cb		 mov	 ecx, ebx
  00034	2b ce		 sub	 ecx, esi
  00036	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  0003b	f7 e9		 imul	 ecx
  0003d	03 d1		 add	 edx, ecx
  0003f	c1 fa 04	 sar	 edx, 4
  00042	8b f2		 mov	 esi, edx
  00044	c1 ee 1f	 shr	 esi, 31			; 0000001fH
  00047	03 f2		 add	 esi, edx
$L362494:

; 622  : 		_Insert_n(_Where, (size_type)1, _Val);

  00049	8b 4c 24 18	 mov	 ecx, DWORD PTR __Val$[esp+8]
  0004d	51		 push	 ecx
  0004e	6a 01		 push	 1
  00050	53		 push	 ebx
  00051	8b cf		 mov	 ecx, edi
  00053	e8 00 00 00 00	 call	 ?_Insert_n@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXViterator@12@IABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Insert_n

; 623  : 		return (begin() + _Off);

  00058	6b f6 1c	 imul	 esi, 28			; 0000001cH
  0005b	03 77 04	 add	 esi, DWORD PTR [edi+4]
  0005e	8b 44 24 10	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp+8]
  00062	5f		 pop	 edi
  00063	89 30		 mov	 DWORD PTR [eax], esi
  00065	5e		 pop	 esi
  00066	5b		 pop	 ebx

; 624  : 		}

  00067	c2 0c 00	 ret	 12			; 0000000cH
?insert@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AViterator@12@V312@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::insert
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ??_GCUser@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCUser@@UAEPAXI@Z PROC NEAR				; CUser::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	e8 00 00 00 00	 call	 ??1CUser@@UAE@XZ	; CUser::~CUser
  00008	f6 44 24 08 01	 test	 BYTE PTR ___flags$[esp], 1
  0000d	74 09		 je	 SHORT $L362558
  0000f	56		 push	 esi
  00010	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00015	83 c4 04	 add	 esp, 4
$L362558:
  00018	8b c6		 mov	 eax, esi
  0001a	5e		 pop	 esi
  0001b	c2 04 00	 ret	 4
??_GCUser@@UAEPAXI@Z ENDP				; CUser::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??1__MINIGAME_EXT_PACKET@@QAE@XZ		; __MINIGAME_EXT_PACKET::~__MINIGAME_EXT_PACKET
; Function compile flags: /Ogty
;	COMDAT ??1__MINIGAME_EXT_PACKET@@QAE@XZ
_TEXT	SEGMENT
__Cat$362618 = -4					; size = 1
??1__MINIGAME_EXT_PACKET@@QAE@XZ PROC NEAR		; __MINIGAME_EXT_PACKET::~__MINIGAME_EXT_PACKET, COMDAT
; _this$ = ecx
  00000	51		 push	 ecx
  00001	8b 41 18	 mov	 eax, DWORD PTR [ecx+24]
  00004	85 c0		 test	 eax, eax
  00006	56		 push	 esi
  00007	8d 71 14	 lea	 esi, DWORD PTR [ecx+20]
  0000a	74 1c		 je	 SHORT $L362621
  0000c	8b 4c 24 04	 mov	 ecx, DWORD PTR __Cat$362618[esp+8]
  00010	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00013	51		 push	 ecx
  00014	56		 push	 esi
  00015	52		 push	 edx
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
  0001c	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00025	83 c4 14	 add	 esp, 20			; 00000014H
$L362621:
  00028	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  0002f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00036	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
  0003d	5e		 pop	 esi
  0003e	59		 pop	 ecx
  0003f	c3		 ret	 0
??1__MINIGAME_EXT_PACKET@@QAE@XZ ENDP			; __MINIGAME_EXT_PACKET::~__MINIGAME_EXT_PACKET
_TEXT	ENDS
PUBLIC	?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back
; Function compile flags: /Ogty
;	COMDAT ?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
_TEXT	SEGMENT
__Cat$362663 = 8					; size = 1
$T362628 = 8						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z PROC NEAR ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back, COMDAT
; _this$ = ecx

; 579  : 		{	// insert element at end

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	57		 push	 edi
  00003	8b f9		 mov	 edi, ecx

; 580  : 		if (size() < capacity())

  00005	8b 5f 04	 mov	 ebx, DWORD PTR [edi+4]
  00008	85 db		 test	 ebx, ebx
  0000a	75 04		 jne	 SHORT $L362633
  0000c	33 f6		 xor	 esi, esi
  0000e	eb 18		 jmp	 SHORT $L362634
$L362633:
  00010	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  00013	2b cb		 sub	 ecx, ebx
  00015	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  0001a	f7 e9		 imul	 ecx
  0001c	03 d1		 add	 edx, ecx
  0001e	c1 fa 04	 sar	 edx, 4
  00021	8b f2		 mov	 esi, edx
  00023	c1 ee 1f	 shr	 esi, 31			; 0000001fH
  00026	03 f2		 add	 esi, edx
$L362634:
  00028	85 db		 test	 ebx, ebx
  0002a	74 41		 je	 SHORT $L287524
  0002c	8b 4f 0c	 mov	 ecx, DWORD PTR [edi+12]
  0002f	2b cb		 sub	 ecx, ebx
  00031	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  00036	f7 e9		 imul	 ecx
  00038	03 d1		 add	 edx, ecx
  0003a	c1 fa 04	 sar	 edx, 4
  0003d	8b c2		 mov	 eax, edx
  0003f	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00042	03 c2		 add	 eax, edx
  00044	3b f0		 cmp	 esi, eax
  00046	73 25		 jae	 SHORT $L287524

; 581  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

  00048	8b 44 24 10	 mov	 eax, DWORD PTR __Cat$362663[esp+8]
  0004c	8b 4c 24 10	 mov	 ecx, DWORD PTR __Val$[esp+8]
  00050	8b 77 08	 mov	 esi, DWORD PTR [edi+8]
  00053	50		 push	 eax
  00054	57		 push	 edi
  00055	51		 push	 ecx
  00056	6a 01		 push	 1
  00058	56		 push	 esi
  00059	e8 00 00 00 00	 call	 ??$_Uninit_fill_n@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IABV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
  0005e	83 c4 14	 add	 esp, 20			; 00000014H
  00061	83 c6 1c	 add	 esi, 28			; 0000001cH
  00064	89 77 08	 mov	 DWORD PTR [edi+8], esi
  00067	5f		 pop	 edi
  00068	5e		 pop	 esi
  00069	5b		 pop	 ebx

; 584  : 		}

  0006a	c2 04 00	 ret	 4
$L287524:

; 582  : 		else
; 583  : 			insert(end(), _Val);

  0006d	8b 54 24 10	 mov	 edx, DWORD PTR __Val$[esp+8]
  00071	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  00074	52		 push	 edx
  00075	50		 push	 eax
  00076	8d 44 24 18	 lea	 eax, DWORD PTR $T362628[esp+16]
  0007a	50		 push	 eax
  0007b	8b cf		 mov	 ecx, edi
  0007d	e8 00 00 00 00	 call	 ?insert@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AViterator@12@V312@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::insert
  00082	5f		 pop	 edi
  00083	5e		 pop	 esi
  00084	5b		 pop	 ebx

; 584  : 		}

  00085	c2 04 00	 ret	 4
?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back
_TEXT	ENDS
PUBLIC	?Serialize@__MINIGAME_EXT_PACKET@@UAEXAAVCAr@@@Z ; __MINIGAME_EXT_PACKET::Serialize
EXTRN	?ReadString@CAr@@QAEPADPADH@Z:NEAR		; CAr::ReadString
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\iosfwd
xdata$x	SEGMENT
$T363048 DD	0ffffffffH
	DD	FLAT:$L362687
$T363040 DD	019930520H
	DD	01H
	DD	FLAT:$T363048
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\minigamebase.h
xdata$x	ENDS
;	COMDAT ?Serialize@__MINIGAME_EXT_PACKET@@UAEXAAVCAr@@@Z
_TEXT	SEGMENT
tv484 = -312						; size = 4
__Cat$362840 = -312					; size = 1
tv188 = -312						; size = 4
$T362686 = -308						; size = 28
_szTemp$243830 = -280					; size = 256
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_ar$ = 8						; size = 4
?Serialize@__MINIGAME_EXT_PACKET@@UAEXAAVCAr@@@Z PROC NEAR ; __MINIGAME_EXT_PACKET::Serialize, COMDAT
; _this$ = ecx

; 30   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	6a ff		 push	 -1
  00008	68 00 00 00 00	 push	 __ehhandler$?Serialize@__MINIGAME_EXT_PACKET@@UAEXAAVCAr@@@Z
  0000d	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00013	50		 push	 eax
  00014	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0001b	81 ec 30 01 00
	00		 sub	 esp, 304		; 00000130H
  00021	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00026	53		 push	 ebx
  00027	8b 5d 08	 mov	 ebx, DWORD PTR _ar$[ebp]
  0002a	56		 push	 esi
  0002b	57		 push	 edi
  0002c	33 c5		 xor	 eax, ebp

; 31   : 		__MINIGAME_PACKET::Serialize( ar );

  0002e	53		 push	 ebx
  0002f	89 84 24 38 01
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+332], eax
  00036	8b f1		 mov	 esi, ecx
  00038	e8 00 00 00 00	 call	 ?Serialize@__MINIGAME_PACKET@@UAEXAAVCAr@@@Z ; __MINIGAME_PACKET::Serialize

; 32   : 		if( ar.IsStoring() )

  0003d	33 c0		 xor	 eax, eax
  0003f	8a 03		 mov	 al, BYTE PTR [ebx]
  00041	f7 d0		 not	 eax
  00043	a8 01		 test	 al, 1
  00045	0f 84 a0 00 00
	00		 je	 $L243819

; 33   : 		{
; 34   : 			ar << vecszData.size();

  0004b	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  0004e	85 c0		 test	 eax, eax
  00050	75 04		 jne	 SHORT $L362695
  00052	33 ff		 xor	 edi, edi
  00054	eb 18		 jmp	 SHORT $L362696
$L362695:
  00056	8b 4e 1c	 mov	 ecx, DWORD PTR [esi+28]
  00059	2b c8		 sub	 ecx, eax
  0005b	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  00060	f7 e9		 imul	 ecx
  00062	03 d1		 add	 edx, ecx
  00064	c1 fa 04	 sar	 edx, 4
  00067	8b fa		 mov	 edi, edx
  00069	c1 ef 1f	 shr	 edi, 31			; 0000001fH
  0006c	03 fa		 add	 edi, edx
$L362696:
  0006e	6a 04		 push	 4
  00070	8b cb		 mov	 ecx, ebx
  00072	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00077	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  0007a	89 39		 mov	 DWORD PTR [ecx], edi
  0007c	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  0007f	83 c0 04	 add	 eax, 4

; 35   : 			for( DWORD i=0; i<vecszData.size(); i++ )

  00082	33 ff		 xor	 edi, edi
  00084	89 43 08	 mov	 DWORD PTR [ebx+8], eax
  00087	89 7c 24 10	 mov	 DWORD PTR tv484[esp+328], edi
  0008b	eb 03 8d 49 00	 npad	 5
$L243821:
  00090	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  00093	85 c0		 test	 eax, eax
  00095	0f 84 50 01 00
	00		 je	 $L243829
  0009b	8b 4e 1c	 mov	 ecx, DWORD PTR [esi+28]
  0009e	2b c8		 sub	 ecx, eax
  000a0	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  000a5	f7 e9		 imul	 ecx
  000a7	03 d1		 add	 edx, ecx
  000a9	c1 fa 04	 sar	 edx, 4
  000ac	8b c2		 mov	 eax, edx
  000ae	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  000b1	03 c2		 add	 eax, edx
  000b3	3b f8		 cmp	 edi, eax
  000b5	0f 83 30 01 00
	00		 jae	 $L243829

; 36   : 				ar.WriteString( vecszData[i].c_str() );

  000bb	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  000be	8b 54 24 10	 mov	 edx, DWORD PTR tv484[esp+328]
  000c2	8b 4c 10 18	 mov	 ecx, DWORD PTR [eax+edx+24]
  000c6	03 c2		 add	 eax, edx
  000c8	83 f9 10	 cmp	 ecx, 16			; 00000010H
  000cb	72 05		 jb	 SHORT $L362781
  000cd	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000d0	eb 03		 jmp	 SHORT $L362782
$L362781:
  000d2	83 c0 04	 add	 eax, 4
$L362782:
  000d5	50		 push	 eax
  000d6	8b cb		 mov	 ecx, ebx
  000d8	e8 00 00 00 00	 call	 ?WriteString@CAr@@QAEXPBD@Z ; CAr::WriteString
  000dd	8b 44 24 10	 mov	 eax, DWORD PTR tv484[esp+328]
  000e1	47		 inc	 edi
  000e2	83 c0 1c	 add	 eax, 28			; 0000001cH
  000e5	89 44 24 10	 mov	 DWORD PTR tv484[esp+328], eax
  000e9	eb a5		 jmp	 SHORT $L243821
$L243819:

; 37   : 		}
; 38   : 		else
; 39   : 		{
; 40   : 			int nSize = 0; vecszData.clear();

  000eb	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  000ee	83 c6 14	 add	 esi, 20			; 00000014H
  000f1	33 ff		 xor	 edi, edi
  000f3	3b c7		 cmp	 eax, edi
  000f5	74 1c		 je	 SHORT $L362843
  000f7	8b 54 24 10	 mov	 edx, DWORD PTR __Cat$362840[esp+328]
  000fb	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  000fe	52		 push	 edx
  000ff	56		 push	 esi
  00100	51		 push	 ecx
  00101	50		 push	 eax
  00102	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
  00107	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0010a	50		 push	 eax
  0010b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00110	83 c4 14	 add	 esp, 20			; 00000014H
$L362843:
  00113	89 7e 04	 mov	 DWORD PTR [esi+4], edi
  00116	89 7e 08	 mov	 DWORD PTR [esi+8], edi
  00119	89 7e 0c	 mov	 DWORD PTR [esi+12], edi

; 41   : 			ar >> nSize;

  0011c	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  0011f	8b 53 0c	 mov	 edx, DWORD PTR [ebx+12]
  00122	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
  00125	3b ca		 cmp	 ecx, edx
  00127	77 07		 ja	 SHORT $L362855
  00129	8b 00		 mov	 eax, DWORD PTR [eax]
  0012b	89 4b 08	 mov	 DWORD PTR [ebx+8], ecx
  0012e	eb 05		 jmp	 SHORT $L362856
$L362855:
  00130	33 c0		 xor	 eax, eax
  00132	89 53 08	 mov	 DWORD PTR [ebx+8], edx
$L362856:

; 42   : 			for( int i=0; i<nSize; i++ )

  00135	3b c7		 cmp	 eax, edi
  00137	0f 8e ae 00 00
	00		 jle	 $L243829
  0013d	89 44 24 10	 mov	 DWORD PTR tv188[esp+328], eax
$L243827:

; 43   : 			{
; 44   : 				char szTemp[256] = {0,};

  00141	33 c0		 xor	 eax, eax
  00143	c6 44 24 30 00	 mov	 BYTE PTR _szTemp$243830[esp+328], 0
  00148	b9 3f 00 00 00	 mov	 ecx, 63			; 0000003fH
  0014d	8d 7c 24 31	 lea	 edi, DWORD PTR _szTemp$243830[esp+329]
  00151	f3 ab		 rep stosd
  00153	66 ab		 stosw
  00155	aa		 stosb

; 45   : 				ar.ReadString( szTemp, 256 );

  00156	68 00 01 00 00	 push	 256			; 00000100H
  0015b	8d 44 24 34	 lea	 eax, DWORD PTR _szTemp$243830[esp+332]
  0015f	50		 push	 eax
  00160	8b cb		 mov	 ecx, ebx
  00162	e8 00 00 00 00	 call	 ?ReadString@CAr@@QAEPADPADH@Z ; CAr::ReadString

; 46   : 				vecszData.push_back( szTemp );

  00167	33 ff		 xor	 edi, edi
  00169	8d 44 24 30	 lea	 eax, DWORD PTR _szTemp$243830[esp+328]
  0016d	c7 44 24 2c 0f
	00 00 00	 mov	 DWORD PTR $T362686[esp+352], 15 ; 0000000fH
  00175	89 7c 24 28	 mov	 DWORD PTR $T362686[esp+348], edi
  00179	c6 44 24 18 00	 mov	 BYTE PTR $T362686[esp+332], 0
  0017e	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
$L363045:
  00181	8a 08		 mov	 cl, BYTE PTR [eax]
  00183	40		 inc	 eax
  00184	84 c9		 test	 cl, cl
  00186	75 f9		 jne	 SHORT $L363045
  00188	2b c2		 sub	 eax, edx
  0018a	50		 push	 eax
  0018b	8d 4c 24 34	 lea	 ecx, DWORD PTR _szTemp$243830[esp+332]
  0018f	51		 push	 ecx
  00190	8d 4c 24 1c	 lea	 ecx, DWORD PTR $T362686[esp+336]
  00194	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00199	8d 54 24 14	 lea	 edx, DWORD PTR $T362686[esp+328]
  0019d	52		 push	 edx
  0019e	8b ce		 mov	 ecx, esi
  001a0	89 bc 24 48 01
	00 00		 mov	 DWORD PTR __$EHRec$[esp+340], edi
  001a7	e8 00 00 00 00	 call	 ?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back
  001ac	83 7c 24 2c 10	 cmp	 DWORD PTR $T362686[esp+352], 16 ; 00000010H
  001b1	c7 84 24 44 01
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+336], -1
  001bc	72 0d		 jb	 SHORT $L363019
  001be	8b 44 24 18	 mov	 eax, DWORD PTR $T362686[esp+332]
  001c2	50		 push	 eax
  001c3	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  001c8	83 c4 04	 add	 esp, 4
$L363019:
  001cb	8b 44 24 10	 mov	 eax, DWORD PTR tv188[esp+328]
  001cf	48		 dec	 eax
  001d0	c7 44 24 2c 0f
	00 00 00	 mov	 DWORD PTR $T362686[esp+352], 15 ; 0000000fH
  001d8	89 7c 24 28	 mov	 DWORD PTR $T362686[esp+348], edi
  001dc	c6 44 24 18 00	 mov	 BYTE PTR $T362686[esp+332], 0
  001e1	89 44 24 10	 mov	 DWORD PTR tv188[esp+328], eax
  001e5	0f 85 56 ff ff
	ff		 jne	 $L243827
$L243829:

; 47   : 			}
; 48   : 		}
; 49   : 	}

  001eb	8b 8c 24 3c 01
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+328]
  001f2	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  001f9	8b 8c 24 34 01
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+328]
  00200	5f		 pop	 edi
  00201	5e		 pop	 esi
  00202	33 cd		 xor	 ecx, ebp
  00204	5b		 pop	 ebx
  00205	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0020a	8b e5		 mov	 esp, ebp
  0020c	5d		 pop	 ebp
  0020d	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L362687:
  00000	8d 8d cc fe ff
	ff		 lea	 ecx, DWORD PTR $T362686[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?Serialize@__MINIGAME_EXT_PACKET@@UAEXAAVCAr@@@Z:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T363040
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?Serialize@__MINIGAME_EXT_PACKET@@UAEXAAVCAr@@@Z ENDP	; __MINIGAME_EXT_PACKET::Serialize
PUBLIC	?AddMiniGameExtState@CUser@@QAEXU__MINIGAME_EXT_PACKET@@@Z ; CUser::AddMiniGameExtState
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
xdata$x	SEGMENT
$T363231 DD	0ffffffffH
	DD	FLAT:$L363053
$T363228 DD	019930520H
	DD	01H
	DD	FLAT:$T363231
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.cpp
xdata$x	ENDS
;	COMDAT ?AddMiniGameExtState@CUser@@QAEXU__MINIGAME_EXT_PACKET@@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Cat$363221 = 8					; size = 1
__Cat$363129 = 8					; size = 1
_MiniGameExtPacket$ = 8					; size = 36
?AddMiniGameExtState@CUser@@QAEXU__MINIGAME_EXT_PACKET@@@Z PROC NEAR ; CUser::AddMiniGameExtState, COMDAT
; _this$ = ecx

; 8430 : {

  00000	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00006	6a ff		 push	 -1
  00008	68 00 00 00 00	 push	 __ehhandler$?AddMiniGameExtState@CUser@@QAEXU__MINIGAME_EXT_PACKET@@@Z
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	56		 push	 esi
  00016	57		 push	 edi

; 8431 : 	if( IsDelete() )	return;

  00017	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  0001b	c7 44 24 10 00
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+28], 0
  00023	74 1d		 je	 SHORT $L285442
  00025	8b 74 24 30	 mov	 esi, DWORD PTR _MiniGameExtPacket$[esp+40]
  00029	85 f6		 test	 esi, esi
  0002b	0f 84 85 00 00
	00		 je	 $L363225
  00031	8b 44 24 18	 mov	 eax, DWORD PTR __Cat$363129[esp+16]
  00035	8b 54 24 34	 mov	 edx, DWORD PTR _MiniGameExtPacket$[esp+44]
  00039	50		 push	 eax
  0003a	8d 4c 24 30	 lea	 ecx, DWORD PTR _MiniGameExtPacket$[esp+40]
  0003e	51		 push	 ecx
  0003f	52		 push	 edx
  00040	eb 65		 jmp	 SHORT $L363230
$L285442:

; 8432 : 	m_Snapshot.cb++;

  00042	66 ff 81 0c 57
	00 00		 inc	 WORD PTR [ecx+22284]

; 8433 : 	m_Snapshot.ar << GetId();

  00049	8b b9 bc 01 00
	00		 mov	 edi, DWORD PTR [ecx+444]
  0004f	8d b1 f8 16 00
	00		 lea	 esi, DWORD PTR [ecx+5880]
  00055	6a 04		 push	 4
  00057	8b ce		 mov	 ecx, esi
  00059	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0005e	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00061	89 38		 mov	 DWORD PTR [eax], edi
  00063	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00066	83 c0 04	 add	 eax, 4

; 8434 : 	m_Snapshot.ar << SNAPSHOTTYPE_RAINBOWRACE_MINIGAMEEXTSTATE;

  00069	6a 02		 push	 2
  0006b	8b ce		 mov	 ecx, esi
  0006d	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00070	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00075	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00078	66 c7 01 04 90	 mov	 WORD PTR [ecx], 36868	; 00009004H
  0007d	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00080	83 c2 02	 add	 edx, 2

; 8435 : 	MiniGameExtPacket.Serialize( m_Snapshot.ar );

  00083	56		 push	 esi
  00084	8d 4c 24 1c	 lea	 ecx, DWORD PTR _MiniGameExtPacket$[esp+20]
  00088	89 56 08	 mov	 DWORD PTR [esi+8], edx
  0008b	e8 00 00 00 00	 call	 ?Serialize@__MINIGAME_EXT_PACKET@@UAEXAAVCAr@@@Z ; __MINIGAME_EXT_PACKET::Serialize

; 8436 : }

  00090	8b 74 24 30	 mov	 esi, DWORD PTR _MiniGameExtPacket$[esp+40]
  00094	85 f6		 test	 esi, esi
  00096	74 1e		 je	 SHORT $L363225
  00098	8b 54 24 18	 mov	 edx, DWORD PTR __Cat$363221[esp+16]
  0009c	8b 4c 24 34	 mov	 ecx, DWORD PTR _MiniGameExtPacket$[esp+44]
  000a0	52		 push	 edx
  000a1	8d 44 24 30	 lea	 eax, DWORD PTR _MiniGameExtPacket$[esp+40]
  000a5	50		 push	 eax
  000a6	51		 push	 ecx
$L363230:
  000a7	56		 push	 esi
  000a8	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
  000ad	56		 push	 esi
  000ae	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000b3	83 c4 14	 add	 esp, 20			; 00000014H
$L363225:
  000b6	8b 4c 24 08	 mov	 ecx, DWORD PTR __$EHRec$[esp+20]
  000ba	5f		 pop	 edi
  000bb	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  000c2	5e		 pop	 esi
  000c3	83 c4 0c	 add	 esp, 12			; 0000000cH
  000c6	c2 24 00	 ret	 36			; 00000024H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L363053:
  00000	8d 4d 04	 lea	 ecx, DWORD PTR _MiniGameExtPacket$[ebp-4]
  00003	e9 00 00 00 00	 jmp	 ??1__MINIGAME_EXT_PACKET@@QAE@XZ
__ehhandler$?AddMiniGameExtState@CUser@@QAEXU__MINIGAME_EXT_PACKET@@@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T363228
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?AddMiniGameExtState@CUser@@QAEXU__MINIGAME_EXT_PACKET@@@Z ENDP ; CUser::AddMiniGameExtState
EXTRN	_atexit:NEAR
CRT$XCU	SEGMENT
_$S3	DD	FLAT:_$E1
; Function compile flags: /Ogty
CRT$XCU	ENDS
;	COMDAT _$E1
text$yc	SEGMENT
_$E1	PROC NEAR					; COMDAT

; 107  : CUserMng	g_UserMng;

  00000	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_UserMng@@3VCUserMng@@A
  00005	e8 00 00 00 00	 call	 ??0CUserMng@@QAE@XZ	; CUserMng::CUserMng
  0000a	68 00 00 00 00	 push	 OFFSET FLAT:_$E2
  0000f	e8 00 00 00 00	 call	 _atexit
  00014	59		 pop	 ecx
  00015	c3		 ret	 0
_$E1	ENDP
; Function compile flags: /Ogty
text$yc	ENDS
;	COMDAT _$E2
text$yd	SEGMENT
_$E2	PROC NEAR					; COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_UserMng@@3VCUserMng@@A
  00005	e9 00 00 00 00	 jmp	 ??1CUserMng@@UAE@XZ	; CUserMng::~CUserMng
_$E2	ENDP
text$yd	ENDS
PUBLIC	?g_UserMng@@3VCUserMng@@A			; g_UserMng
_BSS	SEGMENT
?g_UserMng@@3VCUserMng@@A DB 014H DUP (?)		; g_UserMng
_BSS	ENDS
END
